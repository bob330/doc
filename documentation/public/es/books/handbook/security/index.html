<!doctype html><html class=theme-light lang=es><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/es/books/handbook/security/><title>Capítulo 14. Seguridad | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capítulo 14. Seguridad"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="http://172.16.201.134:1313/es/books/handbook/security/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/es\/books\/handbook\/security\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/es/books>Books</a></li><li><a href=http://172.16.201.134:1313/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/preface/>Prefacio</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/preface/#preface-audience>A quién va dirigido este texto</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/preface/#preface-changes-from2>Cambios desde la segunda edición</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/preface/#preface-changes>Cambios desde la primera edición</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/preface/#preface-overview>Cómo se organiza este libro</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/preface/#preface-conv>Convenciones usadas en este libro</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/preface/#preface-acknowledgements>Agradecimientos</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/parti/>Parte I. Primeros pasos</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/introduction/>Capítulo 1. Introducción</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/introduction/#introcution-synopsis>1.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/introduction/#nutshell>1.2. Bienvenido a FreeBSD</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/introduction/#history>1.3. Acerca del Proyecto FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-6aaec170775233b7c45f6cdcfb70d466 class=toggle>
<label class="icon cursor" for=chapter-6aaec170775233b7c45f6cdcfb70d466><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/install/>Capítulo 2. Instalación de FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-synopsis>2.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-hardware>2.2. Requisitos de hardware</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-pre>2.3. Tareas anteriores a la instalación</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-start>2.4. Inicio de la instalación</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#using-sysinstall>2.5. ¿Qué es sysinstall?</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-steps>2.6. Asignación de espacio en disco</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-choosing>2.7. Elección de qué instalar</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-media>2.8. Elección del medio de instalación</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-final-warning>2.9. El punto sin retorno</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-post>2.10. Después de la instalación</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-trouble>2.11. Solución de problemas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-advanced>2.12. Guía avanzada de instalación</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/install/#install-diff-media>2.13. Cómo preparar su propio medio de instalación</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/basics/>Capítulo 3. Conceptos básicos de Unix</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#basics-synopsis>3.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#consoles>3.2. Consolas virtuales y terminales</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#permissions>3.3. Permisos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#dirstructure>3.4. Estructura de directorios</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#disk-organization>3.5. Organización de disco</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#mount-unmount>3.6. Montaje y desmontaje de sistemas de ficheros</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#basics-processes>3.7. Procesos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#basics-daemons>3.8. Dæmons, señales y cómo matar procesos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#editors>3.10. Editores de texto</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#basics-devices>3.11. Dispositivos y nodos de dispositivos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#binary-formats>3.12. Formatos binarios</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/basics/#basics-more-information>3.13. Más información</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/ports/>Capítulo 4. Instalación de aplicaciones: packages y ports</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/ports/#ports-synopsis>4.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ports/#ports-overview>4.2. Aproximación a la instalación de software</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ports/#ports-finding-applications>4.3. Cómo encontrar aplicaciones</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ports/#packages-using>4.4. Uso del sistema de packages</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ports/#ports-using>4.5. Uso de la colección de ports</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ports/#ports-nextsteps>4.6. Después de instalar un port</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ports/#ports-broken>4.7. Ports que no funcionan</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/x11/>Capítulo 5. El sistema X Window</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/x11/#x11-synopsis>5.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/x11/#x-understanding>5.2. Entender X</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/x11/#x-install>5.3. Instalar X11</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/x11/#x-config>5.4. Configuración de X11</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/x11/#x-fonts>5.5. Uso de tipos en X11</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/x11/#x-xdm>5.6. El gestor de pantalla X</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/x11/#x11-wm>5.7. Entornos de escritorio</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/partii/>Parte II. Tareas comunes</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/desktop/>Capítulo 6. Aplicaciones de escritorio</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/desktop/#desktop-synopsis>6.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/desktop/#desktop-browsers>6.2. Navegadores</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/desktop/#desktop-productivity>6.3. Productividad</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/desktop/#desktop-viewers>6.4. Visores de documentos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/desktop/#desktop-finance>6.5. Finanzas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/desktop/#desktop-summary>6.6. Resumen</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/multimedia/>Capítulo 7. Multimedia</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/multimedia/#_sinopsis>7.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/multimedia/#sound-setup>7.2. Configuración de la tarjeta de sonido</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/multimedia/#sound-mp3>7.3. Sonido MP3</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/multimedia/#video-playback>7.4. Reproducción de vídeo</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/multimedia/#tvcard>7.5. Configuración de tarjetas de TV</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/multimedia/#scanners>7.6. Escáneres de imágenes</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/>Capítulo 8. Configuración del kernel de FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/#_sinopsis>8.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/#_qué_razones_hay_para_compilar_un_kernel_personalizado>8.2. ¿Qué razones hay para compilar un kernel personalizado?</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Inventario de hardware del sistema</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/#kernelconfig-modules>8.4. Controladores del kernel, subsistemas y módulos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/#kernelconfig-building>8.5. Compilación e instalación de un kernel personalizado</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/#kernelconfig-config>8.6. El fichero de configuración</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/kernelconfig/#kernelconfig-trouble>8.7. Qué hacer si algo va mal</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/printing/>Capítulo 9. Imprimir</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/printing/#_sinopsis>9.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/printing/#printing-intro-spooler>9.2. Introducción</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/printing/#printing-intro-setup>9.3. Configuración básica</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/printing/#printing-advanced>9.4. Configuración avanzada de impresoras</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/printing/#printing-using>9.5. Cómo utilizar impresoras</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/printing/#printing-lpd-alternatives>9.6. Alternativas a LPD</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/printing/#printing-troubleshooting>9.7. Solución de problemas</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/>Capítulo 10. Compatibilidad binaria con Linux</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Instalación</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#linuxemu-mathematica>10.3. Instalación de Mathematica®</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#linuxemu-maple>10.4. Instalación de Maple™</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#linuxemu-matlab>10.5. Instalación de MATLAB®</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#linuxemu-oracle>10.6. Instalación de Oracle®</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#sapr3>10.7. Instalación de SAP® R/3®</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/linuxemu/#linuxemu-advanced>10.8. Temas avanzados</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/partiii/>Parte III. Administración del sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/config/>Capítulo 11. Configuración y Adaptación del Sistema</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/config/#config-network-setup>11.1. Configuración de Tarjetas de Red</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/config/#configtuning-starting-services>11.2. "Arrancar servicios"</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/config/#soft-updates>11.3. "Soft Updates"</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/config/#adding-swap-space>11.4. Añadir espacio swap</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/boot/>Capítulo 12. El proceso de arranque en FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/boot/#boot-synopsis>12.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/boot/#boot-introduction>12.2. El problema que representa arrancar el sistema</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/boot/#boot-blocks>12.3. El RMA y las etapas de arranque uno, dos y tres</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/boot/#boot-kernel>12.4. Interacción con el kernel durante el arranque</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/boot/#device-hints>12.5. Device Hints</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/boot/#boot-init>12.6. Init: inicialización del proceso de control</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/boot/#boot-shutdown>12.7. Secuencia de apagado</a></li></ul></li><li><input type=checkbox id=chapter-d251c21b963b5ab783e5aec225e02b5a class=toggle>
<label class="icon cursor" for=chapter-d251c21b963b5ab783e5aec225e02b5a><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/users/>Capítulo 13. Usuarios y administración básica de cuentas</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-synopsis>13.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-introduction>13.2. Introducción</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-superuser>13.3. La cuenta superusuario</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-system>13.4. Cuentas de sistema</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-user>13.5. Cuentas de usuario</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-modifying>13.6. Modificación de cuentas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-limiting>13.7. Limitar a los usuarios</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-personalizing>13.8. Personalizar a los usuarios</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/users/#users-groups>13.9. Grupos</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle checked>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/security/>Capítulo 14. Seguridad</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#security-synopsis>14.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#security-intro>14.2. Introducción</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#securing-freebsd>14.3. Asegurar FreeBSD</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#crypt>14.4. DES, MD5 y Crypt</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#one-time-passwords>14.5. Contraseñas de un solo uso</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#kerberosIV>14.7. KerberosIV</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#kerberos5>14.8. Kerberos5</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#openssl>14.9. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#ipsec>14.10. VPN sobre IPsec</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#openssh>14.11. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#fs-acl>14.12. Listas de control de acceso a sistemas de ficheros</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#security-portaudit>14.13. Monitorización de fallos de seguridad de aplicaciones</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#security-advisories>14.14. FreeBSD Security Advisories</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/security/#security-accounting>14.15. Contabilidad de procesos</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/jails/>Capítulo 15. Jaulas</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/jails/#jails-synopsis>15.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/jails/#jails-terms>15.2. Términos relacionados con las jaulas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/jails/#jails-intro>15.3. Introducción</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/jails/#jails-build>15.4. Creación y gestión de jaulas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/jails/#jails-tuning>15.5. Administración y personalización a fondo</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/jails/#jails-application>15.6. Uso de las jaulas</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/mac/>Capítulo 16. Mandatory Access Control</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-synopsis>16.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-inline-glossary>16.2. Términos clave en este capí­tulo</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-initial>16.3. Explicación de MAC</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-understandlabel>16.4. Las etiquetas MAC</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-modules>16.5. Configuración de módulos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-ifoff>16.6. El módulo MAC ifoff</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-portacl>16.7. El módulo MAC portacl</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-labelingpolicies>16.8. Polí­ticas de etiquetas MAC</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-partition>16.9. El módulo MAC partition</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-mls>16.10. El módulo de seguridad multinivel MAC</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-biba>16.11. El módulo MAC Biba</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-lomac>16.12. El módulo MAC LOMAC</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-implementing>16.13. Implementación de un entorno seguro con MAC</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#MAC-examplehttpd>16.14. Otro ejemplo: Uso de MAC para restringir un servidor web</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mac/#mac-troubleshoot>16.15. Depuración de errores en MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/audit/>Capítulo 17. Auditoría de eventos de seguridad</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/audit/#audit-synopsis>17.1. *</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/disks/>Capítulo 18. Almacenamiento</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#disks-synopsis>18.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#disks-naming>18.2. Nombres de dispositivo</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#disks-adding>18.3. Añadir discos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#raid>18.4. RAID</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#usb-disks>18.5. Dispositivos de almacenamiento USB</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#creating-cds>18.6. Creación y uso de medios ópticos (CD)</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#creating-dvds>18.7. Crear y utilizar medios ópticos (DVDs)</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#floppies>18.8. Creación y uso de disquetes (floppies)</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#backups-tapebackups>18.9. Creación y uso de cintas de datos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#backups-floppybackups>18.10. Respaldos en disquetes</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#backup-basics>18.11. Bases para respaldos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#disks-virtual>18.12. Sistemas de ficheros en red, memoria y respaldados en fichero</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#snapshots>18.13. Instantáneas ("snapshots") de sistemas de ficheros</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#quotas>18.14. Cuotas en sistemas de ficheros</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/disks/#disks-encrypting>18.15. Cifrado de particiones de disco</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/geom/>Capítulo 19. GEOM. Marco de trabajo modular de transformación de discos</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/geom/#GEOM-synopsis>19.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/geom/#GEOM-intro>19.2. Introducción a GEOM</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/geom/#GEOM-striping>19.3. RAID0 - Distribución por bandas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/geom/#GEOM-mirror>19.4. RAID1 - Replicación</a></li></ul></li><li><input type=checkbox id=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e class=toggle>
<label class="icon cursor" for=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/vinum/>Capítulo 20. El Gestor de Volúmenes Vinum</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-synopsis>20.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-intro>20.2. Los Discos son Demasiado Pequeños</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-access-bottlenecks>20.3. Cuellos de Botella en el Acceso</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-data-integrity>20.4. Integridad de Datos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-objects>20.5. Objetos Vinum</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-examples>20.6. Ejemplos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-object-naming>20.7. Esquema de Nombres de los Objetos</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-config>20.8. Configuración de Vinum</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/vinum/#vinum-root>20.9. Uso de Vinum en el Sistema de Ficheros Raíz</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/virtualization/>Capítulo 21. Virtualización</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/virtualization/#virtualization-synopsis>21.1. *</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/l10n/>Capítulo 22. Localización - Uso y configuración de I18N/L10N</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/l10n/#l10n-synopsis>22.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/l10n/#l10n-basics>22.2. Lo básico</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/l10n/#using-localization>22.3. Uso de la localización</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/l10n/#l10n-compiling>22.4. Compilación de programas con soporte para I18N</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/l10n/#lang-setup>22.5. Localización de FreeBSD a idiomas específicos</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/cutting-edge/>Capítulo 23. Lo último de lo último</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/cutting-edge/#_sinopsis>23.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/cutting-edge/#current-stable>23.2. FreeBSD-CURRENT vs. FreeBSD-STABLE</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/cutting-edge/#synching>23.3. Sincronización de su código fuente</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/cutting-edge/#makeworld>23.4. Uso de <code>make world</code></a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/cutting-edge/#small-lans>23.5. Redes pequeñas</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/partiv/>Parte IV. Comunicaciones en red</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/serialcomms/>Capítulo 24. Comunicaciones serie</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/serialcomms/#serial-synopsis>24.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/serialcomms/#serial>24.2. Introducción</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/serialcomms/#term>24.3. Terminales</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/serialcomms/#dialup>24.4. Servicio dial-in</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/serialcomms/#dialout>24.5. Servicio dial-out</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/serialcomms/#serialconsole-setup>24.6. Configurando la consola serie</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/ppp-and-slip/>Capítulo 25. PPP y SLIP</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/ppp-and-slip/#_sinopsis>25.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ppp-and-slip/#userppp>25.2. Uso de User PPP</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ppp-and-slip/#ppp>25.3. Uso de Kernel PPP</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ppp-and-slip/#pppoe>25.4. Uso de PPP sobre Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ppp-and-slip/#pppoa>25.5. Uso de PPP sobre ATM (PPPoA)</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/ppp-and-slip/#slip>25.6. Uso de SLIP</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/firewalls/>Capítulo 26. Cortafuegos</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/firewalls/#firewalls-intro>26.1. *</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/mail/>Capítulo 27. Correo Electrónico</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-synopsis>27.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-using>27.2. Utilización del correo electrónico</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#sendmail>27.3. Configuración de sendmail</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-changingmta>27.4. Sustitución del Agente de Transferencia de Correo</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-trouble>27.5. Depuración de Problemas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-advanced>27.6. Conceptos Avanzados</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#SMTP-UUCP>27.7. SMTP con UUCP</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#outgoing-only>27.8. Configuración para sólamente enviar correo</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#SMTP-dialup>27.9. Utilización del correo con una conexión mediante módem analógico (dial-up)</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#SMTP-Auth>27.10. Autentificación utilizando SMTP</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-agents>27.11. Agente de Correo de Usuario</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-fetchmail>27.12. Manejo de fetchmail</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mail/#mail-procmail>27.13. Uso de procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/network-servers/>Capítulo 28. Servidores de red</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/network-servers/#network-servers-synopsis>28.1. *</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/partv/>Parte V. Apéndices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/mirrors/>Apéndice A. Cómo obtener FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/mirrors/#mirrors-ftp>A.1. Servidores FTP</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/mirrors/#cvsup>A.2. Uso de CVSup</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/>Apéndice B. Bibliografía</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_libros_y_revistas_específicas_sobre_freebsd>B.1. Libros y revistas específicas sobre FreeBSD</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_guías_de_usuario>B.2. Guías de usuario</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_guías_de_administrador>B.3. Guías de administrador</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_guías_de_programadores>B.4. Guías de programadores</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_el_sistema_operativo_por_dentro>B.5. El sistema operativo por dentro</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_referencia_de_seguridad>B.6. Referencia de seguridad</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_referencia_de_hardware>B.7. Referencia de hardware</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_historia_de_unix>B.8. Historia de UNIX</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/bibliography/#_diarios_y_revistas>B.9. Diarios y revistas</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/eresources/>Apéndices C. Recursos en Internet</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/eresources/#eresources-mail>C.1. Listas de correo</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/eresources/#eresources-news>C.2. Grupos de noticias de Usenet</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/eresources/#eresources-web>C.3. Servidores WWW</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/eresources/#eresources-email>C.4. Direcciones de correo electrónico</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/eresources/#eresources-shell>C.5. Cuentas shell</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/pgpkeys/>Apéndice D. PGP keys</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Responsables</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/>Capítulo 34. Redes Avanzadas</a><ul><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#advanced-networking-synopsis>34.1. Sinopsis</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-routing>34.2. Gateways y Rutas</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#configtuning-virtual-hosts>34.3. Hosts Virtuales</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-advanced-wireless>34.4. Autenticación Inalámbrica Avanzada</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#wireless-ad-hoc-mode>34.5. Modo Ad-hoc Inalámbrico</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-usb-tethering>34.6. Tethering USB</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-bluetooth>34.7. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-bridging>34.8. Bridging</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-aggregation>34.9. Agregación de Enlaces y Conmutación</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-diskless>34.10. Operación sin Disco con PXE</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#carp>34.11. Common Address Redundancy Protocol (CARP)</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook/advanced-networking/#network-vlan>34.12. VLANs</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Menú del libro"></i>
Menú del libro</span></label></div><h1 class=title>Capítulo 14. Seguridad</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#security-synopsis>14.1. Sinopsis</a></li><li><a href=#security-intro>14.2. Introducción</a></li><li><a href=#securing-freebsd>14.3. Asegurar FreeBSD</a></li><li><a href=#crypt>14.4. DES, MD5 y Crypt</a></li><li><a href=#one-time-passwords>14.5. Contraseñas de un solo uso</a></li><li><a href=#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=#kerberosIV>14.7. KerberosIV</a></li><li><a href=#kerberos5>14.8. Kerberos5</a></li><li><a href=#openssl>14.9. OpenSSL</a></li><li><a href=#ipsec>14.10. VPN sobre IPsec</a></li><li><a href=#openssh>14.11. OpenSSH</a></li><li><a href=#fs-acl>14.12. Listas de control de acceso a sistemas de ficheros</a></li><li><a href=#security-portaudit>14.13. Monitorización de fallos de seguridad de aplicaciones</a></li><li><a href=#security-advisories>14.14. FreeBSD Security Advisories</a></li><li><a href=#security-accounting>14.15. Contabilidad de procesos</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=security-synopsis>14.1. Sinopsis<a class=anchor href=#security-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Este capítulo contiene una introducción básica a los conceptos de seguridad del sistema, unas cuantas normas básicas de uso y algunos avanzados del tema en FreeBSD. Muchos de los temas expuestos se aplican a la seguridad del sistema y de Internet en general. Internet ya no es aquél lugar "amistoso" en el que todo el mundo se comportaba como un buen ciudadano. Si quiere proteger sus datos, su propiedad intelectual, su tiempo y muchas más cosas de manos malintencionadas debe hacer que su sistema sea seguro.</p></div><div class=paragraph><p>FreeBSD proporciona un variado arsenal de utilidades y mecanismos para asegurar la integridad y la seguridad de su sistema y red.</p></div><div class=paragraph><p>Después de leer este capítulo:</p></div><div class=ulist><ul><li><p>conocerá conceptos básicos de la seguridad relacionados con FreeBSD.</p></li><li><p>Tendrá información sobre los diversos mecanismos de cifrado disponibles en FreeBSD, entre los cuales están DES y MD5.</p></li><li><p>Sabrá cómo configurar la autentificación de contraseñas de un solo uso.</p></li><li><p>Sabrá cómo configurar TCP Wrappers y usarlos con <code>inetd</code>.</p></li><li><p>Sabrá cómo instalar KerberosIV en versiones de FreeBSD anteriores a 5.0.</p></li><li><p>Sabrá cómo instalar Kerberos5 en versiones de FreeBSD posteriores a 5.0.</p></li><li><p>Podrá configurar IPsec y crear una VPN entre máquinas FreeBSD/Windows®.</p></li><li><p>Sabrá cómo configurar y utilizar OpenSSH, la implementación de SSH en FreeBSD.</p></li><li><p>Sabrá en qué consisten las ACL del sistema de ficheros y cómo utilizarlas.</p></li><li><p>Sabrá cómo usar Portaudit, con la que podrá auditar el software que instale desde la desde la colección de ports.</p></li><li><p>Sabrá cómo sacar partido de los avisos de seguridad que publica FreeBSD.</p></li><li><p>Podrá hacerse una idea clara de en qué consiste la contabilidad de procesos y de cómo activarla en FreeBSD.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo:</p></div><div class=ulist><ul><li><p>Comprender conceptos básicos de FreeBSD e Internet.</p></li></ul></div><div class=paragraph><p>En otras secciones de este manual se cubren aspectos adicionales sobre seguridad. Por ejemplo, MAC (controles de acceso obligatorio) se explica en el <a href=../mac/#mac>Mandatory Access Control</a> y los cortafuegos en el <a href=../firewalls/#firewalls>Cortafuegos</a>.</p></div></div></div><div class=sect1><h2 id=security-intro>14.2. Introducción<a class=anchor href=#security-intro></a></h2><div class=sectionbody><div class=paragraph><p>La seguridad es un trabajo que que comienza y termina en el administrador de sistema. Aunque que los sistemas multiusuario BSD UNIX® posean una seguridad inherente, el trabajo de construir y mantener mecanismos de seguridad adicionales para que los usuarios sean aún más "honestos" es probablemente una de las mayores tareas de la administración de sistemas. Los sistemas son tan seguros como uno los haga, y no hay que olvidar que los problemas de seguridad compiten con la comodidad a la que tendemos los humanos. Los sistemas UNIX® son capaces de ejecutar una gran cantidad de procesos simultáneamente, muchos de los cuales son servidores, lo que significa que las entidades externas pueden conectarse y "hablar" con ellos. Del mismo modo que las minicomputadoras de ayer se convirtieron en los sistemas de escritorio de hoy en día, la seguridad se va convirtiendo en un problemas más y más acuciante.</p></div><div class=paragraph><p>La seguridad bien entendida se implementa en capas, a la manera de una "cebolla". Básicamente lo que se hace es crear la mayor cantidad posible de capas de seguridad, para más tarde monitorizar el sistema en busca de intrusos. No es conveniente exagerar la seguridad, ya que interferiría con la detección, y la detección es uno de los aspectos más importantes de cualquier mecanismo de seguridad. Por ejemplo, no tiene mucho sentido activar la bandera <code>schg</code> (consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>) en cada binario del sistema, ya que aunque protegería en cierto modo los binarios, haría que cualquier cambio que pudiera realizar un atacante una vez dentro del sistema fuera más difícil de detectar o incluso hacerlo del todo imposible.</p></div><div class=paragraph><p>La seguridad del sistema depende también de estar preparados para distintos tipos de ataque, incluyendo intentos de "tirar" la máquina o dejarla en un estado inutilizable, pero que no impliquen intentos de comprometer el usuario <code>root</code> Los problemas de seguridad pueden dividirse en diferentes categorías:</p></div><div class="olist arabic"><ol class=arabic><li><p>Ataques de denegación de servicio (DoS).</p></li><li><p>Comprometer cuentas de usuarios.</p></li><li><p>Comprometer root a través de servidores accesibles.</p></li><li><p>Comprometer root desde cuentas de usuario.</p></li><li><p>Creación de puertas traseras ("Backdoors").</p></li></ol></div><div class=paragraph><p>Un ataque de denegación de servicio es una acción que priva al sistema de los recursos requeridos para su funcionamiento normal. Generalmente, los ataques DoS son mecanismos de fuerza bruta que intentan "tumbar" el sistema o hacerlo inutilizable sobrecargando la capacidad de sus servidores o de la pila de red. Algunos ataques DoS intentan aprovechar errores en la pila de red para "tumbar" el sistema con un solo paquete. Estos últimos únicamente pueden solucionarse aplicando al kernel una actualización que subsane el error. Los ataques a servidores muchas veces pueden solucionarse configurando las opciones apropiadas para limitar la carga del sistema en condiciones adversas. Los ataques de fuerza bruta a redes son más complicados. Los ataques con paquetes enmascarados, por ejemplo, son casi imposibles de detener, a menos que desconecte el sistema de Internet. Puede ser que no "tiren" el sistema, pero saturarán la conexión a Internet.</p></div><div class=paragraph><p>Comprometer una cuenta de usuario es mucho más común que un ataque DoS. Muchos administradores de sistemas todavía ejecutan servidores estándar telnetd, rlogind, rshd y ftpd en sus máquinas. Estos servidores, por defecto no operan a través de conexiones cifradas. El resultado es que se si se tiene una base de usuarios de tamaño medio, tarde o temprando la contraseña de uno (o más) de sus usuarios será descubierta durante sus accesos al sistema desde ubicaciones remotas.(que es, por otra parte, la forma más común y más cómoda de acceder a un sistema). El administrador de sistemas atento analizará sus logs de acceso remoto en busca de direcciones origen spspechosas, incluso entre los accesos al sistema.</p></div><div class=paragraph><p>Se debe asumir <em>siempre</em> que, una vez que el atacante tiene acceso a una cuenta de usuario, el atacante puede comprometer la cuenta <code>root</code>. En realidad en un sistema bien mantenido y asegurado el acceso a una cuenta de usuario no necesariamente da al atacante acceso a <code>root</code>. Esta precisión es importante porque sin acceso a <code>root</code> el atacante difícilmente podrá esconder sus huellas; podrá, como mucho, hacer poco más que sembrar el caos en los ficheros del usuario o "tirar" la máquina. Comprometer cuentas de usuario es muy común porque los usuarios tienden a no tomar las precauciones que toma el administrador.</p></div><div class=paragraph><p>Los administradores de sistemas deben tener presente que existen muchas formas potenciales de comprometer la cuenta <code>root</code> de una máquina. El atacante puede conocer la contraseña de <code>root</code>, el atacante puede encontrar un error en un servidor que se ejecuta como root y ser capaz de comprometer <code>root</code> a través de una conexión de red a ese servidor; puede ser que el atacante sepa de la existencia de un error en un programa suid-root que le permita comprometer <code>root</code> una vez dentro de una cuenta de usuario. Si un atacante encuentra la manera de comprometer la cuenta <code>root</code> de una máquina puede que no necesite instalar una puerta trasera. Muchos de los agujeros <code>root</code> encontrados y cerrados hasta la fecha implican una cantidad considerable de trabajo para el atacante limpiando todo después del ataque, así que la mayoría de los atacantes instalan puertas traseras. Una puerta trasera facilita al atacante una forma sencilla de recuperar el acceso de <code>root</code> al sistema, pero también proporciona al administrador de sistemas inteligente una forma de detectar la intrusión. Si hace imposible a un atacante la instalación de una puerta trasera puede estar actuando en detrimento de su seguridad, porque no cerrará el agujero que el atacante encontró para accder al sistema la primera vez que lo hizo.</p></div><div class=paragraph><p>Las medidas de seguridad se implementan en un modelo multicapa (tipo "cebolla"), que puede categorizarse del siguiente modo:</p></div><div class="olist arabic"><ol class=arabic><li><p>Asegurar <code>root</code> y cuentas administrativas.</p></li><li><p>Asegurar los servidores que se ejecuten como <code>root</code> los binarios suid/sgid.</p></li><li><p>Asegurar cuentas de usuario.</p></li><li><p>Asegurar el fichero de contraseñas.</p></li><li><p>Asegurar el núcleo del kernel, los dispositivos en bruto y el sistema de ficheros.</p></li><li><p>Detección rápida de cambios hechos al sistema.</p></li><li><p>Paranoia.</p></li></ol></div><div class=paragraph><p>La siguiente sección de este capítulo tratará los puntos de arriba con mayor profundidad.</p></div></div></div><div class=sect1><h2 id=securing-freebsd>14.3. Asegurar FreeBSD<a class=anchor href=#securing-freebsd></a></h2><div class=sectionbody><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Orden vs. protocolo</div><div class=paragraph><p>En este capítulo usaremos el texto en negrita para referirnos a una orden o aplicación, y una fuente en <code>cursiva</code> para referirnos a órdenes específicas. Usaremos un tipo normal para los protocolos. Esta diferencia tipográfica nos será útil por ejemplo con ssh, que es tanto un protocolo como una orden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Las siguientes secciones cubren los métodos a seguir para asegurar su sistema FreeBSD que se mencionados en la <a href=#security-intro>sección anterior</a> de este capítulo.</p></div><div class=sect2><h3 id=securing-root-and-staff>14.3.1. Asegurar la cuenta <code>root</code> y las cuentas administrativas<a class=anchor href=#securing-root-and-staff></a></h3><div class=paragraph><p>En primer lugar, no se moleste en asegurar las cuentas administrativas (o "staff") si no ha asegurado la cuenta <code>root</code>. La mayoría de los sistemas tienen una contraseña asignada para la cuenta <code>root</code>. Lo primero que se hace es asumir que la contraseña está <em>siempre</em> amenazada. Esto no significa que deba eliminar la contraseña. La contraseña es casi siempre necesaria para el acceso por consola a la máquina; significa que no se debe permitir el uso de la contraseña fuera de la consola o, mejor aún, mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Por ejemplo, asegúrese de que sus ptys aparezcan como <em>inseguras</em> en el fichero <span class=filename>/etc/ttys</span>, con lo que hará que los accesos como <code>root</code> vía <code>telnet</code> o <code>rlogin</code> no sean posibles. Si utiliza otros tipos de login como sshd asegúrese de que los accesos al sistema como <code>root</code> estén también deshabilitados. Para ello edite su <span class=filename>/etc/ssh/sshd_config</span> y asegúrese de que <code>PermitRootLogin</code> esté puesto a <code>NO</code>. Estudie cada método de acceso: hay servicios como FTP que frecuentemente son origen de grietas en la estructura del sistema. El acceso directo como usuario <code>root</code> sólamente debe permitirse a través de la consola.</p></div><div class=paragraph><p>Es evidente que, como administrador del sistema, debe usted tener la posibilidad de acceder a <code>root</code>, así que tendrá que abrir algunos agujeros, pero debe asegurarse de que estos agujeros necesiten contraseñas adicionales para verificar su correcto uso. Puede hacer que <code>root</code> sea accesible añadiendo cuentas administrativas al grupo <code>wheel</code> (en <span class=filename>/etc/group</span>). El personal que administra los sistemas que aparezcan en el grupo en el grupo <code>wheel</code> pueden hacer <code>su</code> a <code>root</code>. Nunca debe de proporcionar al personal administrativo el acceso nativo a <code>wheel</code> poniéndolos en el grupo <code>wheel</code> en su entrada de contraseña. Las cuentas administrativas deben colocarse en un grupo <code>staff</code>, y agregarse después al grupo <code>wheel</code> en <span class=filename>/etc/group</span>. Sólo aquellos administradores que realmente necesiten acceder a <code>root</code> deben pertenecer al grupo <code>wheel</code>. También es posible, mediante un método de autentificación como Kerberos, usar el fichero <span class=filename>.k5login</span> en la cuenta <code>root</code> para permitir un <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> a <code>root</code> sin tener que colocar a nadie en el grupo <code>wheel</code>. Puede ser una mejor solución, ya que el mecanismo <code>wheel</code> aún permite a un atacante comprometer <code>root</code> si el intruso ha conseguido el fichero de contraseñas y puede comprometer una cuenta de administración. Recurrir al mecanismo <code>wheel</code> es mejor que no tener nada, pero no es necesariamente la opción más segura.</p></div><div class=paragraph><p>Una manera indirecta de asegurar las cuentas de staff y el acceso a <code>root</code> es utilizar un método de acceso alternativo: es lo que se conoce como "estrellar" las contraseñas cifradas de las cuentas administrativas. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> para reemplazar cada contraseña cifrada por un sólo caracter asterisco (“*”). Esto actualizará <span class=filename>/etc/master.passwd</span> y la base de datos de usuario/contraseña y deshabilitará los accesos al sistema validados mediante contraseñas.</p></div><div class=paragraph><p>Veamos una cuenta administrativa típica:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>y cómo debería quedar:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>Este cambio evitará que se efectúen logins normales, ya que la contraseña cifrada nunca se corresponderá con “*”. Hecho esto, el personal de administración tendrá que usar otro mecanismo de validación como <a href="https://man.freebsd.org/cgi/man.cgi?query=kerberos&amp;sektion=1&amp;format=html">kerberos(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> que use un par de llave pública/privada. Si decide usar algo como Kerberos tendrá que asegurar la máquina que ejecuta los servidores Kerberos y su estación de trabajo. Si usa un par de llave pública/privada con ssh, debe asegurar la máquina <em>desde</em> desde la que se hace el login (normalmente nuestra estación de trabajo). Puede añadir una capa adicional de protección al par de llaves protegiéndolas con contraseña al crearlo con <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>. El "estrellado" de las contraseñas administrativas también garantiza que dicho personal sólo pueda entrar a través de métodos de acceso que haya usted configurado. Así obligará al personal administrativo a usar conexiones seguras, cifradas, en todas sus sesiones, lo que cierra un importante agujero de seguridad al que recurren muchos intrusos: usar un sniffer (olfateador) de red desde una máquina que le permita hacer tal cosa.</p></div><div class=paragraph><p>Los mecanismos de seguridad más indirectos también asumen que está validando su identidad desde un servidor más restrictivo un servidor menos restrictivo. Por ejemplo, si su máquina principal ejecuta toda clase de servidores su estación de trabajo no debe ejecutar ninguno. Para que su estación de trabajo sea razonablemente segura debe ejecutar los mínimos servidores posibles, si es posible ninguno, y debe usar un salvapantallas protegido por contraseña. Es evidente que un atancante con acceso físico al sistema puede romper cualquier barrera de seguridad que se disponga. Es un problema a tener en cuenta, pero la mayoría de las intrusiones tienen lugar de forma remota, a través de la red, por parte de gente que no tiene acceso físico a su estación de trabajo ni a sus servidores.</p></div><div class=paragraph><p>Usar Kerberos le ofrece también el poder de deshabilitar o cambiar la contraseña para una cuenta administrativa en un lugar, y que tenga un efecto inmediato en todas las máquinas en las cuales ese administrador pueda tener una cuenta. Si una de esas cuentas se ve comprometida la posibilidad para cambiar instantáneamente su contraseña en todas las máquinas no debe ser desestimada. Con contraseñas distintas, el cambio de una contraseña en N máquinas puede ser un problema. También puede imponer restricciones de re-contraseñas con Kerberos: no sólo se puede hacer un ticket de Kerberos que expire después de un tiempo, sino que el sistema Kerberos puede requerir al usuario que escoja una nueva contraseña después de cierto tiempo (digamos una vez al mes).</p></div></div><div class=sect2><h3 id=_asegurar_servidores_que_se_ejecutan_como_root_y_binarios_suidsgid>14.3.2. Asegurar servidores que se ejecutan como <code>root</code> y binarios SUID/SGID<a class=anchor href=#_asegurar_servidores_que_se_ejecutan_como_root_y_binarios_suidsgid></a></h3><div class=paragraph><p>Un administrador de sistemas prudente sólo ejecutará los servidores que necesita, ni uno más ni uno menos. Dese cuenta de que los servidores ajenos son los más propensos a contener errores. Por ejemplo, ejecutando una versión desfasada de imapd o popper es como dar una entrada universal de <code>root</code> al mundo entero. Nunca ejecute un servidor que no haya revisado cuidadosamente. Muchos servidores no necesitan ejecutarse como <code>root</code>. Por ejemplo, los dæmons ntalk, comsat y finger pueden ejecutarse en una <em>caja de arena (sandbox)</em> especial de usuario. Una caja de arena no es perfecta, a menos que pase por muchos problemas, pero la aproximación de cebolla a la seguridad prevalece aún y todo: Si alguien es capaz de penetrar a través de un servidor ejecutándose en una caja de arena, todavía tendrá que salir de la caja de arena. Cuantas más capas tenga que romper el atacante menor será la posibilidad de éxito que tenga. Se han encontrado vías de entrada a <code>root</code> en virtualmente todos los servidores que se haya ejecutado como <code>root</code>, incluyendo servidores básicos del sistema. Si está tiene una máquina a través de la cual la gente sólo entra por sshd, y nunca entra por telnetd, rshd, o rlogind <em>apague esos servicios</em>.</p></div><div class=paragraph><p>FreeBSD ejecuta por defecto ntalkd, comsat y finger en una caja de arena. Otro programa que puede ser candidato para ejecutarse en una caja de arena es <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. <span class=filename>/etc/defaults/rc.conf</span> contiene las directrices necesarias (con comentarios) para usar named en una caja de arena. Dependiendo de si está instalando un nuevo sistema o actualizando un sistema ya existente, las cuentas especiales de usuario que usan estas cajas de arena puede que no estén instaladas. El administrador de sistemas prudente debe investigar e implementar cajas de arena para servidores siempre que sea posible.</p></div><div class=paragraph><p>Existen numerosos servidores que no se suelen ejecutar en cajas de arena: sendmail, imapd, ftpd, y otros. Existen alternativas para algunos de ellos, pero instalarlas puede requerir más trabajo del que tal vez esté dispuesto a realizar (el factor comodidad ataca de nuevo). Tal vez tenga que ejecutar estos servidores como <code>root</code> y depender de otros mecanismos para detectar intrusiones que puedan tener lugar a través de ellos.</p></div><div class=paragraph><p>Los otros grandes agujeros potenciales de <code>root</code> que encontramos en un sistema son los binarios suid-root y sgid. La mayoría de estos binarios, como rlogin, están en <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span> o <span class=filename>/usr/sbin</span>. Aunque no hay nada absolutamente seguro los binarios suid y sgid del sistema por defecto pueden considerarse razonablemente seguros. Aún así, de vez en cuando aparecen agujeros <code>root</code> en estos binarios. En 1998 se encontró un agujero <code>root</code> en <code>Xlib</code>, que hacía a xterm (que suele ser suid) vulnerable. Es mejor prevenir que curar, y el administrador de sistemas prudente restringirá los binarios suid, que sólo el personal de administración debe ejecutar, a un grupo especial al que sólo dicho personal pueda acceder, y deshacerse de cualquier binario suid (<code>chmod 000</code>) que no se use. Un servidor sin pantalla generalmente no necesita un binario xterm. Los binarios sgid pueden ser igual de peligrosos. Si un intruso logra comprometer un binario sgid-kmem, el intruso podría leer <span class=filename>/dev/kmem</span> y llegar a leer el fichero cifrado de contraseñas, poniendo en compromiso potencial cualquier cuenta con contraseña. Por otra parte, un intruso que comprometa el grupo <code>kmem</code> puede monitorizar las pulsaciones de teclado que se envien a través de ptys, incluyendo las ptys a las que acceden usuarios que emplean métodos seguros. Un intruso que comprometa el grupo <code>tty</code> puede escribir en la pty de casi cualquier usuario. Si un usuario ejecuta un programa de terminal o un emulador capaz de simular un teclado, el intruso podría generar un flujo de datos que provoque que la terminal del usuario muestre una orden en pantalla, orden que el usuario ejecutará.</p></div></div><div class=sect2><h3 id=secure-users>14.3.3. Asegurar las cuentas de usuario<a class=anchor href=#secure-users></a></h3><div class=paragraph><p>Las cuentas de usuario suelen ser las más difíciles de asegurar. Aunque puede imponer restricciones de acceso draconianas a su personal administrativo y "estrellar" sus contraseñas, tal vez no pueda hacerlo con todas las cuentas de todos sus usuarios. Si mantiene el control en un grado suficiente quizás lo logre y sea capaz de hacer que las cuentas de sus usuarios sean seguras. Si no, tendrá que ser más cuidadoso (aún) en la monitorización de esas cuentas. Usar ssh y Kerberos en cuentas de usuario da más problemas debido al soporte técnico y administrativo que requerirá, pero sigue siendo mejor solución que un fichero de contraseñas cifradas.</p></div></div><div class=sect2><h3 id=_asegurar_el_fichero_de_contraseñas>14.3.4. Asegurar el fichero de contraseñas<a class=anchor href=#_asegurar_el_fichero_de_contraseñas></a></h3><div class=paragraph><p>La única manera segura es ponerle <code>*</code> a tantas contraseñas como sea posible y utilizar ssh o Kerberos para acceder a esas cuentas. Aunque el fichero cifrado de contraseñas (<span class=filename>/etc/spwd.db</span>) sólo puede ser legible para <code>root</code>, puede que un intruso consiga acceso de lectura a ese fichero, incluso sin haber alcanzado el acceso de escritura como root.</p></div><div class=paragraph><p>Sus "scripts" de seguridad deben buscar siempre cambios en el fichero de contraseñas (consulte <a href=#security-integrity>Revisión de integridad de ficheros</a> más abajo) e informar de ellos.</p></div></div><div class=sect2><h3 id=_asegurar_el_kernel_dispositivos_en_bruto_y_el_sistema_sistema_de_ficheros>14.3.5. Asegurar el Kernel, dispositivos en bruto y el sistema sistema de ficheros<a class=anchor href=#_asegurar_el_kernel_dispositivos_en_bruto_y_el_sistema_sistema_de_ficheros></a></h3><div class=paragraph><p>Si un atacante compromete <code>root</code> puede hacer cualquier cosa, pero hay ciertas cosas que puede usted preparar para "curarse en salud". Por ejemplo, la mayoría de los kernel modernos tienen un dispositivo de los Kernels modernos tienen un integrado un dispositivo de paquetes. En FreeBSD se llama <span class=filename>bpf</span>. Un intruso típico tratará de ejecutar un "sniffer" de paquetes en una máquina comprometida. No debería darle a ese intruso tal recurso, y la mayoría de los sistemas no necesitan el dispositivo <span class=filename>bpf</span>.</p></div><div class=paragraph><p>Pero si desactiva el dispositivo <span class=filename>bpf</span> todavía tendrá que preocuparse por <span class=filename>/dev/mem</span> y <span class=filename>/dev/kmem</span>. Desde ellos el intruso podría en dispositivos de disco en bruto. También hay que tener muy en cuenta una opción del kernel llamada cargador de módulos, <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Un intruso con iniciativa puede usar un módulo KLD para instalar su propio dispositivo <span class=filename>bpf</span>, u otro dispositivo que le permita el "sniffing" en un kernel en ejecución. Para prevenir estos problemas debe ejecutar el kernel en un nivel de seguridad mayor, al menos en securelevel 1. Puede configurar el securelevel mediante una <code>sysctl</code> en la variable <code>kern.securelevel</code>. Una vez que tiene su securelevel a 1, los accesos de escritura a dispositivos en bruto se denegarán y se impondrán las banderas especiales <code>schg</code>. También debe cerciorarse de activar la bandera <code>schg</code> en binarios críticos para el arranque, directorios y scripts (dicho de otro modo, todo aquello que se ejecuta <em>antes</em> de que se active el securelevel). Puede ser que todo esto sea una exageración, sobre todo teniendo en cuenta que la actualización del sistema se complica bastante a medida que se incrementa el nivel de seguridad. Puede ejecutar el sistema a un nivel de seguridad superior pero no activar la bandera <code>schg</code> en cada fichero y directorio del sistema. Otra posibilidad es montar <span class=filename>/</span> y <span class=filename>/usr</span> como sólo lectura. Recuerde que siendo demasiado draconiano en aquello que busca proteger puede dificultar mucho la detección de una intrusión.</p></div></div><div class=sect2><h3 id=security-integrity>14.3.6. Revisión de integridad de ficheros: binarios, ficheros de configuración, etc.<a class=anchor href=#security-integrity></a></h3><div class=paragraph><p>Cuando se piensa de proteccón, sólo se puede proteger la configuración central del sistema y los ficheros de control hasta el momento en el que el factor comodidad salta a la palestra. Por ejemplo, si usa <code>chflags</code> para activar el bit <code>schg</code> en la mayoría de los ficheros de <span class=filename>/</span> y <span class=filename>/usr</span> probablemente sea contraproducente; puede proteger los ficheros haciéndolo, pero también cierra una vía de detección. La última capa de su modelo de seguridad tipo cebolla es quizás la más importante: la detección. El resto de su estructura de seguridad será inútil (o peor aún, le proporcionará un sentimiento de seguridad totalmente infundado) si no puede detectar posibles intrusiones. La mitad del trabajo de la cebolla es alentar al atacante, en lugar de detenerlo, para darle a la parte de la ecuación de detección una oportunidad de atraparlo con las manos en la masa.</p></div><div class=paragraph><p>La mejor manera de detectar una intrusión es buscar ficheros modificados, perdidos, o cuya presencia o estado sea inesperado. La mejor forma de buscar ficheros modificados es desde otro sistema (que muchas veces es centralizado) con acceso restringido. Escribir sus "scripts" de seguridad en un sistema "extraseguro" y con acceso restringido los hace casi invisibles a posibles atacantes, y esto es algo muy importante. potenciales, y esto es importante. Para poderle sacar el máximo partido debe proporcionar a esa máquina con acceso restringido un acceso preferente al contenido de las otras máquinas de su entorno; suele hacerse mediante la importación vía NFS de sólo lectura de las demás máquinas, o configurando pares de llaves ssh para acceder a las otras máquinas desde la que tiene el acceso restringido. Si exceptuamos el tráfico de red, NFS es el método menos visible y le permite monitorizar los sistemas de ficheros de cada máquina cliente de forma prácticamente indetectable. Si su servidor de acceso restringido está conectado a las máquinas clientes a través de un concentrador o a través de varias capas de encaminamiento el método NFS puede ser muy inseguro, por lo que ssh puede ser la mejor opción, incluso con las huellas de auditoría que ssh va dejando.</p></div><div class=paragraph><p>Una vez que le da a una máquina de acceso restringido (al menos) acceso de lectura a los sistemas cliente que va a monitorizar, tendrá que escribir "scripts" para efectuar la monitorización. Si va a usar un montaje NFS puede escribir "scripts" utilizando simples herramientas del sistema como <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=md5&amp;sektion=1&amp;format=html">md5(1)</a>. Es aconsejable ejecutar MD5 físicamente en los ficheros de las máquinas cliente al menos una vez al día, y comprobar los ficheros de control (los que hay en <span class=filename>/etc</span> y <span class=filename>/usr/local/etc</span>) con una frecuencia incluso mayor. Si aparecen discrepancias al compararlos con la información basada en MD5 que la máquina de acceso restringido usa como base debe hacer una comprobación inmediata y profunda. Un buen "script" también debe buscar binarios que sean suid sin razón aparente, y ficheros nuevos o borrados en particiones del sistema como <span class=filename>/</span> y <span class=filename>/usr</span>.</p></div><div class=paragraph><p>Si usa ssh en lugar de NFS será mucho más complicado escribir el "script" de seguridad. En esencia, tiene que pasar por <code>scp</code> los "scripts" a la máquina cliente para poder ejecutarlos, haciéndolos visibles; por seguridad, también tendrá que pasar vía <code>scp</code> los binarios (por ejemplo find) que utilizan dichos "scripts". El cliente ssh de la máquina cliente puede estar ya bajo el control del intruso. Con todo y con eso, puede ser necesario usar ssh si trabaja sobre enlaces inseguros, también es mucho más difícil de manejar.</p></div><div class=paragraph><p>Un buen "script" de seguridad buscará también cambios en la configuración de los ficheros de acceso de usuarios y miembros del personal de administración: <span class=filename>.rhosts</span>, <span class=filename>.shosts</span>, <span class=filename>.ssh/authorized_keys</span>, etc; en resumen, ficheros fuera del rango de revisión <code>MD5</code>.</p></div><div class=paragraph><p>Si tiene que vérselas con una cantidad enorme de espacio en disco para usuarios le llevará mucho tiempo recorrer cada fichero de cada partición. En su caso sería una buena idea configurar mediante opciones de montaje la deshabilitación de binarios y dispositivos suid en esas particiones. Revise las opciones <code>nodev</code> y <code>nosuid</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Debería comprobarlos de todas maneras al menos una vez por semana, ya que el objeto de esta capa es detectar intrusiones, efectivas o no.</p></div><div class=paragraph><p>La contabilidad de procesos (vea <a href="https://man.freebsd.org/cgi/man.cgi?query=accton&amp;sektion=8&amp;format=html">accton(8)</a>) es una opción con una carga relativamente ligera para el sistema operativo, y puede ayudarle como mecanismo de evaluación tras una intrusión. Es especialmente útil para rastrear cómo consiguión realmente acceder el intruso al sistema (asumiendo que el fichero esté intacto después de la intrusión).</p></div><div class=paragraph><p>Los "scripts" de seguridad deben procesar los logs, y los propios logs deben generarse de la forma más segura posible: un syslog remoto puede ser muy útil. Un intruso trata de cubrir sus huellas, los logs son un recurso crítico cuando el administrador de sistemas intenta determinar la hora y el método de la intrusión inicial. La ejecución de la consola del sistema en un puerto serie y recolectar la información de forma periódica en una máquina segura de monitorización de consolas es una forma de cumplir esta tarea.</p></div></div><div class=sect2><h3 id=_paranoia>14.3.7. Paranoia<a class=anchor href=#_paranoia></a></h3><div class=paragraph><p>Un poco de paranoia nunca está de más. Como norma, un administrador de sistemas puede añadir cualquier tipo de mecanismo de seguridad siempre y cuando no afecte a la comodidad, y puede añadir mecanismos de seguridad que <em>sí</em> afecten a la comodidad si tiene una buena razón para hacerlo. Más aún, un administrador de seguridad debe mezclar un poco de ambas cosas: si sigue al pie de la letra las recomendaciones que se dan en este documento también está sirviendo en bandeja de plata al posible atancante su metodología. Ese posible atacante también tiene acceso a este documento.</p></div></div><div class=sect2><h3 id=_ataques_de_denegación_de_servicio>14.3.8. Ataques de denegación de servicio<a class=anchor href=#_ataques_de_denegación_de_servicio></a></h3><div class=paragraph><p>Esta sección cubre ataques de denegación de servicio. Un ataque DoS suele consistir en un ataque mediante paquetes. NO hay mucho que pueda hacerse contra un ataque mediante paquetes falsificados ("spoofed") que busque saturar su red, pero puede limitar el daño asegurándose de que los ataques no tiren sus servidores.</p></div><div class="olist arabic"><ol class=arabic><li><p>Limitación de forks en el servidor.</p></li><li><p>Limitación de ataques "springboard" (ataques de respuesta ICMP, ping broadcast, etc.)</p></li><li><p>Caché de rutas del kernel.</p></li></ol></div><div class=paragraph><p>Un típico ataque DoS contra un servidor con instancias (forks) sería tratar de provocar que el servidor consuma procesos, descriptores de fichero y memoria hasta tirar la máquina. inetd (consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>) dispone de varias opciones para limitar este tipo de ataque. Recuerde que aunque es posible evitar que una máquina caiga, generalmente no es posible evitar que un servicio sea vea interrumpido a causa el ataque. Consulte la página de manual de inetd atentamente y sobre todo estudie las las opciones <code>-c</code>, <code>-C</code>, y <code>-R</code>. Observe que los ataques con direcciones IP falsificadas sortearán la opción <code>-C</code> de inetd, así que debe usar una combinación de opciones. Algunos servidores autónomos ("standalone") cuentan con parámetros de autolimitación de instancias.</p></div><div class=paragraph><p>Sendmail tiene la opción <code>-OMaxDaemonChildren</code>, que tiende a funcionar mucho mejor que las opciones de límite de carga de sendmail debido al retraso que provoca la carga. Debe especificar un parámetro <code>MaxDaemonChildren</code> al inicio de sendmail que sea lo suficientemente alto como para gestionar la carga esperada, pero no tan alto que la computadora no pueda absorber tal número de sendmails sin caerse de boca. También es prudente ejecutar sendmail en modo de cola (<code>-ODeliveryMode=queued</code>) y ejecutar el dæmon (<code>sendmail -bd</code>) de manera independiente de las ejecuciones de cola (<code>sendmail -q15m</code>). Si a pesar de todo necesita entregas en tiempo real puede ejecutar la cola a un intervalo menor, como <code>-q1m</code>, pero asegúrese de especificar una opción <code>MaxDaemonChildren</code> razonable para <em>ese</em> sendmail y así evitar fallos en cascada.</p></div><div class=paragraph><p>Syslogd puede recibir ataques directos y se recomienda encarecidamente que utilice la opción <code>-s</code> siempre que sea posible, y si no la opción <code>-a</code>.</p></div><div class=paragraph><p>También debe ser extremadamente cuidadoso con servicios de conexión inversa como el ident inverso de TCP Wrapper, que puede recibir ataques directos. No se suele usar el ident inverso de TCP Wrapper por esa misma razón.</p></div><div class=paragraph><p>Es una muy buena idea proteger los servicios internos de acceso externo protegiéndolos vía con un cortafuegos en los routers de frontera. La idea es prevenir ataques de saturación desde el exterior de la LAN, y no tanto para proteger servicios internos de compromisos <code>root</code> basados en red. Configure siempre un cortafuegos exclusivo, esto es, "restringir todo <em>menos</em> los puertos A, B, C, D y M-Z". De esta manera restringirá todos sus puertos con números bajos excepto ciertos servicios específicos como named (si es el servidor primario de una zona), ntalkd, sendmail, y otros servicios accesibles desde Internet. Si configura el cortafuegos de la otra manera (como un cortafuegos inclusivo o permisivo), tiene grandes posibilidades de que olvide "cerrar" un par de servicios, o de que agregue un nuevo servicio interno y olvide actualizar el cortafuegos. Puede incluso abrir el rango de números de puerto altos en el cortafuegos para permitir operaciones de tipo permisivo sin comprometer sus puertos bajos. Recuerde también que FreeBSD le permite controlar el rango de números de puerto utilizados para asignación dinámica a través de las numerosas <code>net.inet.ip.portrange</code> de <code>sysctl</code> (<code>sysctl -a | fgrep portrange</code>), lo cual también facilita la complejidad de la configuración de su cortafuegos. Por ejemplo, puede utilizar un rango normal primero/último de 4000 ó 5000, y un rango de puerto alto de 49152 a 65535; bloquée todo por debajo de 4000 (excepto para ciertos puertos específicos accesibles desde Internet, por supuesto).</p></div><div class=paragraph><p>Otro ataque DoS común es llamado ataque "springboard": atacar un servidor de forma que genere respuestas que lo sobrecarguen, sobrecarguen la red local o alguna otra máquina. Los ataques más comunes de este tipo son los <em>ataques ICMP ping broadcast</em>. El atacante falsifica paquetes ping enviados a la dirección broadcast de su LAN simulando que la dirección IP origen es la de la máquina que desean atacar. Si sus routers de frontera no están configurados para lidiar con pings a direcciones de broadcast su LAN termina generando suficientes respuestas a la dirección origen falsificada como para saturar a la víctima, especialmente cuando el atacante utiliza el mismo truco en varias docenas de direcciones broadcast en varias docenas de redes diferentes a la vez. Se han medido ataques de broadcast de más de ciento veinte megabits. Un segundo tipo de ataque "springboard" bastante común se da contra el sistema de informe de error de ICMP. Un atacante puede saturar la conexión entrante de red de un servidor mediante la construcción de paquetes que generen respuestas de error ICMP, provocando que el servidor sature su conexión saliente de red con respuestas ICMP. Este tipo de ataque también puede tumbar el servidor agotando sus "mbufs", especialmente si el servidor no puede drenar lo suficientemente rápido las respuestas ICMP que genera. El kernel de FreeBSD tiene una opción de compilación llamada <code>ICMP_BANDLIM</code>, que limita la efectividad de este tipo de ataques. La última gran categoría de ataques "springboard" está relacionada con ciertos servicios de inetd, como el servicio de eco udp. El atacante simplemente imita un paquete UDP con el puerdo de eco del servidor A como dirección de origen, y el puerto eco del servidor B como dirección de destino, estando ambos servidores en la misma LAN. Un atacante puede sobrecargar ambos servidores y la propia LAN inyectando simplemente un par de paquetes. Existen problemas similares con el puerto chargen. Un administrador de sistemas competente apagará todos estos servicios internos de verificación de inetd.</p></div><div class=paragraph><p>Los ataques con paquetes falsificados pueden utilizarse también para sobrecargar la caché de rutas del kernel. Consulte los parámetros de <code>sysctl net.inet.ip.rtexpire</code>, <code>rtminexpire</code>, y <code>rtmaxcache</code>. Un ataque de paquetes falsificados que utiliza una dirección IP origen aleatoria provocará que el kernel genere una ruta temporal en caché en su tabla de rutas, visible con <code>netstat -rna | fgrep W3</code>. Estas rutas suelen expiran en 1600 segundos más o menos. Si el kernel detecta que la tabla de rutas en caché es ya demasiado grande reducirá dinámicamente <code>rtexpire</code>, pero nunca la reducirá a un valor que sea menor que <code>rtminexpire</code>. Esto nos presenta dos problemas:</p></div><div class="olist arabic"><ol class=arabic><li><p>El kernel no reacciona con suficiente rapidez cuando un servidor ligeramente cargado es atacado.</p></li><li><p>El <code>rtminexpire</code> no es lo suficientemente bajo para que el kernel sobreviva a un ataque sostenido.</p></li></ol></div><div class=paragraph><p>Si sus servidores están conectados a Internet mediante mediante una línea T3 o superior puede ser prudente corregir manualmente <code>rtexpire</code> y <code>rtminexpire</code> por medio de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Nunca ponga ambos parámetros a cero (a menos que desée estrellar la máquina). Configurar ambos parámetros a 2 segundos debería bastar para proteger de ataques la tabla de rutas.</p></div></div><div class=sect2><h3 id=_otros_aspectos_del_acceso_con_kerberos_y_ssh>14.3.9. Otros aspectos del acceso con Kerberos y SSH<a class=anchor href=#_otros_aspectos_del_acceso_con_kerberos_y_ssh></a></h3><div class=paragraph><p>Existen un par de detalles con respecto a Kerberos y ssh que debe analizar sy pretende usarlos. Kerberos V es un excelente protocolo de protocolo de autentificación, pero hay errores en la versión kerberizada de telnet y rlogin que las hacen inapropiadas para gestionar flujos binarios. Ademé Kerberos no cifra por defecto una sesión a menos que utilice la opción <code>-x</code>. ssh cifra todo por defecto.</p></div><div class=paragraph><p>ssh funciona bastante bien en todos los casos, con la sola salvedad de que por defecto reenvía llaves de cifrado. Esto significa que si usted tiene una estación de trabajo segura, que contiene llaves que le dan acceso al resto del sistema, y hace ssh a una máquina insegura, sus llaves se pueden utilizar. Las llaves en sí no se exponen, pero ssh crea un puerto de reenvío durante el login, y si un atacante ha comprometido el <code>root</code> de la máquina insegura, puede utilizar ese puerto para usar sus llaves y obtener acceso a cualquier otra máquina que sus llaves abran.</p></div><div class=paragraph><p>Le recomendamos que, siempre que sea posible, use ssh combinado con Kerberos en los login de su personal de administración. para logins de staff. Puede compilar ssh con soporte de Kerberos. Esto reducirá su dependencia de llaves ssh expuestas, al mismo tiempo que protege las contraseñas vía Kerberos. Las llaves ssh deben usarse sólamente para tareas automáticas desde máquinas seguras (algo que Kerberos no hace por incompatibilidad). Recomendamos también que desactive el reenvío de llaves en la configuración de ssh, o que use la opción <code>from=IP/DOMAIN</code> que ssh incluye en <span class=filename>authorized_keys</span>; así la llave sólo podrá ser utilizada por entidades que se validen desde máquinas específicas.</p></div></div></div></div><div class=sect1><h2 id=crypt>14.4. DES, MD5 y Crypt<a class=anchor href=#crypt></a></h2><div class=sectionbody><div class=paragraph><p>Cada usuario de un sistema UNIX® tiene una contraseña asociada a su cuenta. Parece obvio que estas contraseñas sólo deben ser conocidas por el usuario y por el sistema operativo. Para que estas contraseñas permanezcan en secreto se cifran con lo que se conoce como un "hash de una pasada", esto es, sólo pueden ser fácilmente cifradas pero no descifradas. En otras palabras, lo que acabamos de decir es tan obvio que ni siguiera es verdad: el propio sistema operativo no sabe cuál es <em>realmente</em> la contraseña. Lo único que conoce es la versión <em>cifrada</em> de la contrasenña. La única manera de obtener la contraseña en "texto plano" es por medio de una búsqueda de fuerza bruta en el espacio de contraseñas posibles.</p></div><div class=paragraph><p>Por desgracia la única manera segura de cifrar contraseñas cuando UNIX® empezó a hacerlo estaba basada en DES, ("Data Encryption Standard", "estándar de cifrado de datos"). Esto no era un gran problema para usuarios residentes en los EEUU, pero el código fuente de FreeBSD no se podía exportar desde los EEUU, así que FreeBSD hubo de buscar una forma de complir las leyes de EEUU y al mismo tiempo mantener la compatibilidad con otras variantes de UNIX® que que todavía utilizaban DES.</p></div><div class=paragraph><p>La solución fué dividir las bibliotecas de cifrado para que los usuarios de EEUU pudieran instalar las bibliotecas DES pero los usuarios del resto del mundo tuvieran un método de cifrado que pudiera ser exportado. Así es como FreeBSD comenzó a usar MD5 como su método de cifrado por defecto. MD5 se considera más seguro que DES, así que se mantiene la opción de poder instalar DES por motivos de compatibilidad.</p></div><div class=sect2><h3 id=_cómo_reconocer_su_mecanismo_de_cifrado>14.4.1. Cómo reconocer su mecanismo de cifrado<a class=anchor href=#_cómo_reconocer_su_mecanismo_de_cifrado></a></h3><div class=paragraph><p>En versiones anteriores a FreeBSD 4.4 <span class=filename>libcrypt.a</span> era un enlace simbólico que apuntaba a la biblioteca que se usaba para el cifrado. En FreeBSD 4.4 se cambió <span class=filename>libcrypt.a</span> para ofrecer una biblioteca hash configurable de validación de contraseñas. Actualmente la biblioteca permite funciones hash DES, MD5 y Blowfish. FreeBSD utiliza por defecto MD5 para cifrar contraseñas.</p></div><div class=paragraph><p>Es muy sencillo identificar qué método usa FreeBSD para cifrar. Una forma es examinando las contraseñas cifradas en <span class=filename>/etc/master.passwd</span>. Las contraseñas cifradas con el hash MD5 son más largas que las cifradas con el hash DES, y también comienzan por los caracteres <code>$1$</code>. Las contraseñas que comienzan por <code>$2a$</code> están cifradas con la función hash de Blowfish. Las contraseñas DES no tienen ninguna característica particular, pero son más cortas que las contraseñas MD5, y están codificadas en un alfabeto de 64 caracteres que no incluye el caracter <code>$</code>; es por esto que una cadena relativamente corta que comience con un signo de dólar es muy probablemente una contraseña DES.</p></div><div class=paragraph><p>El formato de contraseña a usar en nuevas contraseñas se define en <span class=filename>/etc/login.conf</span> mediante <code>passwd_format</code>, pudiendo tener los valores <code>des</code>, <code>md5</code> o <code>blf</code>. Consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> para más información.</p></div></div></div></div><div class=sect1><h2 id=one-time-passwords>14.5. Contraseñas de un solo uso<a class=anchor href=#one-time-passwords></a></h2><div class=sectionbody><div class=paragraph><p>S/Key es un esquema de contraseña de un solo uso basado en una función de hash de sentido único. FreeBSD utiliza el hash MD4 por compatibilidad, pero otros sistemas usan MD5 y DES-MAC. S/Key forma parte del sistema base de FreeBSD desde la versión 1.1.5 y se usa también en un número creciente de otros sistemas operativos. S/Key es una marca registrada de Bell Communications Research, Inc.</p></div><div class=paragraph><p>A partir de la versión 5.0 de FreeBSD S/Key fué reemplazado por su equivalente OPIE ("One-time Passwords In Everything", "Contraseñas de un solo uso para todo"). OPIE usa por defecto hash MD5.</p></div><div class=paragraph><p>En esta sección se explican tres tipos de contraseña. La primera es la típica contraseña al estilo UNIX® o Kerberos; las llamaremos "contraseñas UNIX®". El segundo tipo es la contraseña de un solo uso, que se genera con el programa <code>key</code> de S/Key o con <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> de OPIE, y que aceptan los programas <code>keyinit</code>, <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a>, y el prompt de login; llamaremos a esta una "contraseña de un solo uso". El último tipo de contraseña es la contraseña secreta que le da usted a los programas <code>key</code>/<code>opiekey</code> (y a veces <code>keyinit</code>/<code>opiepasswd</code>), que se usa para generar contraseñas de un solo uso; a estas las llamaremos "contraseñas secretas", o simplemente "contraseña".</p></div><div class=paragraph><p>La contraseña secreta no tiene nada que ver con su contraseña UNIX®; pueden ser la misma, pero no es recomendable. Las contraseñas secretas S/Key y OPIE no están limitadas a 8 caracteres como las contraseñas UNIX® antiguas, pueden ser tan largas como se quiera. Las contraseñas con frases de seis o siete palabras muy largas son bastante comunes. El funcionamiento del sistema S/Key o el OPIE es en gran parte completamente independiente del sistema de contraseñas UNIX®.</p></div><div class=paragraph><p>Además de la contraseña hay dos datos que son importantes para S/Key y OPIE. Uno es lo que se conoce como "semilla" o "llave", que consiste en dos letras y cinco dígitos. El otro dato importante se llama la "cuenta de iteración", que es un número entre 1 y 100. S/Key genera la contraseña de un solo uso concatenando la semilla y la contraseña secreta, aplica el hash MD4/MD5 tantas veces como especifique la cuenta de iteración y convierte el resultado en seis palabras cortas en inglés. Estas seis palabras en inglés son su contraseña de un solo uso. El sistema de autentificación (principalmente PAM) mantiene un registro del uso de contraseñas de un solo uso, y el usuario puede validarse si el hash de la contraseña que proporciona es igual a la contraseña previa. Como se utiliza un hash de sentido único es imposible generar futuras contraseñas de un solo uso si una contraseña que ya ha sido usada fuera capturada; la cuenta de iteración se reduce después de cada login correcto para sincronizar al usuario con el programa login. Cuanto la iteración llega a 1, S/Key y OPIE deben reinicializar.</p></div><div class=paragraph><p>Hay tres programas involucrados en cada uno de estos sistemas. Los programas <code>key</code> y <code>opiekey</code> aceptan una cuenta iterativa, una semilla y una contraseña secreta, y generan una contraseña de un solo uso o una lista consecutiva de contraseñas de un solo uso. Los programas <code>keyinit</code> y <code>opiepasswd</code> se usan respectivamente para inicializar S/Key y OPIE, y para cambiar contraseñas, cuentas iterativas o semillas; toman ya sea una frase secreta, o una cuenta iterativa y una contraseña de un solo uso. Los programas <code>keyinfo</code> y <code>opieinfo</code> examinan los ficheros de credenciales correspondientes (<span class=filename>/etc/skeykeys</span> o <span class=filename>/etc/opiekeys</span>) e imprimen la cuenta iterativa y semilla del usuario invocante.</p></div><div class=paragraph><p>Explicaremos cuatro tipos de operaciones diferentes. La primera es usar <code>keyinit</code> o <code>opiepasswd</code> a través de una conexión segura para configurar contraseñas de un solo uso por primera vez, o para cambiar su contraseña o semilla. La segunda operación es utilizar <code>keyinit</code> o <code>opiepasswd</code> a través de una conexión insegura, además de usar <code>key</code> u <code>opiekey</code> sobre una conexión segura para hacer lo mismo. La tercera es usar <code>key</code>/<code>opiekey</code> para conectarse a través de una conexión insegura. La cuarta es usar <code>opiekey</code> o <code>key</code> para generar numerosas llaves, que pueden ser escritas para llevarlas con usted al ir a algún lugar desde el que no se puedan hacer conexiones seguras a ningún sitio.</p></div><div class=sect2><h3 id=_inicialización_de_conexiones_seguras>14.5.1. Inicialización de conexiones seguras<a class=anchor href=#_inicialización_de_conexiones_seguras></a></h3><div class=paragraph><p>Para inicializar S/Key por primera vez cambie su contraseña, o cambie su semilla mientras está conectado a través de una conexión segura (esto es, en la consola de una máquina o vía ssh); use <code>keyinit</code> sin ningún parámetro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% keyinit
Adding unfurl:
Reminder - Only use this method <span class=k>if </span>you are directly connected.
If you are using telnet or rlogin <span class=nb>exit </span>with no password and use keyinit <span class=nt>-s</span><span class=nb>.</span>
Enter secret password:
Again secret password:

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</code></pre></div></div><div class=paragraph><p>En OPIE se utiliza <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>En <code>Enter new secret pass phrase:</code> o <code>Enter secret password:</code>, debe introducir una contraseña o frase. Recuerde que no es la contraseña que utilizará para entrar, se usará para generar sus llaves de un solo uso. La línea "ID" da los parámetros de su instancia en particular: su nombre de login, la cuenta iterativa y semilla. En el momento del login el sistema recordará estos parámetros y los presentará de nuevo para que no tenga que recordarlos. La última línea proporciona las contraseéas de un solo uso que corresponden a esos parámetros y su contraseña secreta; si fuera a hacer login de manera inmediata, debería usar esta contraseña de una sola vez.</p></div></div><div class=sect2><h3 id=_inicialización_de_conexiones_inseguras>14.5.2. Inicialización de conexiones inseguras<a class=anchor href=#_inicialización_de_conexiones_inseguras></a></h3><div class=paragraph><p>Para inicializar o cambiar su contraseña secreta a través de una conexión insegura, necesitará tener alguna conexión segura a algún lugar donde pueda ejecutar <code>key</code> u <code>opiekey</code>; puede ser gracias a un accesorio de escritorio o en una Macintosh®, o un prompt de shell en una máquina en la que confíe. Necesitará también una cuenta iterativa (100 probablemente sea un buen valor), y puede usar su propia semilla, o usar una generada aleatoriamente. Siguiendo con la conexión insegura (hacia la máquina que está inicializando), ejecute <code>keyinit -s</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% keyinit <span class=nt>-s</span>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: 100
Enter new key <span class=o>[</span>default to17759]:
s/key 100 to 17759
s/key access password:
s/key access password:CURE MIKE BANE HIM RACY GORE</code></pre></div></div><div class=paragraph><p>En OPIE debe usar <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>Para aceptar la semilla por defecto (la que el programa <code>keyinit</code> llama <code>key</code>, "llave", para terminar de complicar las cosas), pulse <kbd>Enter</kbd>. Antes de introducir una una contraseña de acceso cambie a su conexión o accesorio de escritorio S/Key y dele el mismo parámetro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key 100 to17759
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password: &lt;secret password&gt;
CURE MIKE BANE HIM RACY GORE</code></pre></div></div><div class=paragraph><p>O para OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Vuelva a la conexión insegura y copie la contraseña de un solo uso generada al programa que quiera usar.</p></div></div><div class=sect2><h3 id=_generación_una_sola_contraseña_de_un_solo_uso>14.5.3. Generación una sola contraseña de un solo uso<a class=anchor href=#_generación_una_sola_contraseña_de_un_solo_uso></a></h3><div class=paragraph><p>Una vez que ha inicializado S/Key u OPIE, cuando haga login verá un "prompt" parecido al siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet ejemplo.com
Trying 10.0.0.1...
Connected to ejemplo.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>ejemplo.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
s/key 97 fw13894
Password:</code></pre></div></div><div class=paragraph><p>O, en el caso de OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet ejemplo.com
Trying 10.0.0.1...
Connected to ejemplo.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>ejemplo.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;nombre_de_usuario&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>Como una nota aparte, el "prompt" de S/Key y OPIE cuenta con una opción útil (que no se muestra aquí): si pulsa <kbd>Enter</kbd> en el "prompt" de contraseña el "prompt" activará el eco para que pueda ver en pantalla lo que teclea. Esto puede ser extremadamente útil si está tecleando una contraseña a a mano o desde un la lista impresa.</p></div><div class=paragraph><p>Ahora necesitará generar su contraseña de un sólo uso para responder a este "prompt" de login. Debe hacerlo en un sistema digno de confianza y en el que pueda ejecutar <code>key</code> u <code>opiekey</code>. Existen versiones DOS, Windows® y también para Mac OS®. Ambos usarán la cuenta iterativa y la semilla como opciones de línea de órdenes. Puede cortarlas y pegarlas desde el "prompt" de login de la máquina en la que se está identificando.</p></div><div class=paragraph><p>En el sistema de confianza:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key 97 fw13894
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password:
WELD LIP ACTS ENDS ME HAAG</code></pre></div></div><div class=paragraph><p>Con OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Ahora que tiene su contraseña de un solo uso puede proceder con el login:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login: &lt;nombre_de_usuario&gt;
s/key 97 fw13894
Password: &lt;Enter para activar el eco&gt;
s/key 97 fw13894
Password <span class=o>[</span><span class=nb>echo </span>on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ...</code></pre></div></div></div><div class=sect2><h3 id=_generación_de_múltiples_contraseñas_de_un_solo_uso>14.5.4. Generación de múltiples contraseñas de un solo uso<a class=anchor href=#_generación_de_múltiples_contraseñas_de_un_solo_uso></a></h3><div class=paragraph><p>A veces usted hay que ir a lugares donde no hay acceso a una máquina de fiar o a una conexión segura. En estos casos, puede utilizar <code>key</code> y <code>opiekey</code> para generar previamente numerosas contraseñas de un solo uso para, una vez impresas, llevárselas a donde hagan falta. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key <span class=nt>-n</span> 5 30 zz99999
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password: &lt;secret password&gt;
26: SODA RUDE LEA LIND BUDD SILT
27: JILT SPY DUTY GLOW COWL ROT
28: THEM OW COLA RUNT BONG SCOT
29: COT MASH BARR BRIM NAN FLAG
30: CAN KNEE CAST NAME FOLK BILK</code></pre></div></div><div class=paragraph><p>O para OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</span></code></pre></div></div><div class=paragraph><p>El <code>-n 5</code> pide cinco llaves en secuencia, la opción <code>30</code> especifica que ese debe ser el último número de iteración. Observe que se imprimen en el orden <em>inverso</em> de uso. Si es realmente paranoico escriba los resultados a mano; si no, puede enviar la salida a <code>lpr</code>. Observe que cada línea muestra la cuenta iterativa y la contraseña de un solo uso; puede ir tachando las contraseñas según las vaya utilizando.</p></div></div><div class=sect2><h3 id=_restricción_del_uso_de_contraseñas_unix>14.5.5. Restricción del uso de contraseñas UNIX®<a class=anchor href=#_restricción_del_uso_de_contraseñas_unix></a></h3><div class=paragraph><p>S/Key puede implantar restricciones en el uso de contraseñas UNIX® basándose en el nombre de equipo, nombre de usuario, puerto de terminal o dirección IP de una sesión de login. Consulte el fichero de configuración <span class=filename>/etc/skey.access</span>. La página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=skey.access&amp;sektion=5&amp;format=html">skey.access(5)</a> contiene más información sobre el formato del fichero y detalla también algunas precauciones de seguridad que hay que tener en cuenta antes de basar nuestra seguridad en este fichero.</p></div><div class=paragraph><p>Si <span class=filename>/etc/skey.access</span> no existiera (por defecto es así en sistemas FreeBSD 4.X) todos los usuarios podrán disponer de contraseñas UNIX®. Si el fichero existe se exigirá a todos los usuarios el uso de S/Key, a menos que se configure de otro modo en <span class=filename>skey.access</span>. En todos los casos las contraseñas UNIX® son admiten en consola.</p></div><div class=paragraph><p>Aquí hay un ejemplo del fichero de configuración <span class=filename>skey.access</span> que muestra las tres formas más comunes de configuración:</p></div><div class="literalblock programlisting"><div class=content><pre>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</pre></div></div><div class=paragraph><p>La primera línea (<code>permit internet</code>) permite a usuarios cuyas direcciones IP origen (las cuales son vulnerables a una falsificación) concuerden con los valores y máscara especificados utilizar contraseñas UNIX®. Esto no debe usarse como mecanismo de seguridad, sino como medio de recordarle a los usuarios autorizados que están usando una red insegura y necesitan utilizar S/Key para la validación.</p></div><div class=paragraph><p>La segunda línea (<code>permit user</code>) permite al nombre de usuario especificado, en este caso <code>fnord</code>, utilizar contraseñas UNIX® en cualquier momento. Hablando en general, esto solo debe ser usado por gente que no puede usar el programa <code>key</code>, como aquellos con terminales tontas o refractarios al aprendizaje.</p></div><div class=paragraph><p>La tercera línea (<code>permit port</code>) permite a todos los usuarios validados en la línea de terminal especificada utilizar contraseñas UNIX®; esto puede usarse para usuarios que se conectan mediante "dial-ups".</p></div><div class=paragraph><p>OPIE puede restringir el uso de contraseñas UNIX® basándose en la dirección IP de una sesión de login igual que lo haría S/Key. El fichero que gestiona esto es <span class=filename>/etc/opieaccess</span>, que está incluído por defecto en sistemas FreeBSD 5.0 o posteriores. Revise <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> para más información sobre este fichero y qué consideraciones de seguridad debe tener presentes a la hora de usarlo.</p></div><div class=paragraph><p>Veamos un ejemplo de <span class=filename>opieaccess</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>Esta línea permite a usuarios cuya dirección IP de origen (vulnerable a falsificación) concuerde con los valores y máscara especificados, utilizar contraseñas UNIX® en cualquier momento.</p></div><div class=paragraph><p>Si no concuerda ninguna regla en <span class=filename>opieaccess</span> se niegan por defecto los logins no-OPIE.</p></div></div></div></div><div class=sect1><h2 id=tcpwrappers>14.6. TCP Wrappers<a class=anchor href=#tcpwrappers></a></h2><div class=sectionbody><div class=paragraph><p>Cualquiera que esté familiarizado con <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> probablemente haya oído hablar de TCP Wrappers, pero poca gente parece comprender completamente su utilidad en un entorno de red. Parece que todos quieren instalar un cortafuegos para manejar conexiones de red. Aunque un cortafuegos tiene una amplia variedad de usos hay cosas que un cortafuegos no es capaz de gestionar, como el envío de texto como respuesta al creador de la conexión. El software TCP hace esto y más. En las siguientes secciones se explicarán unas cuantas opciones de TCP Wrappers y, cuando sea necesario, se mostrarán ejemplos de configuraciones.</p></div><div class=paragraph><p>El software TCP Wrappers extiende las habilidades de <code>inetd</code> para ofrecer soporte para cada servidor dæmon bajo su control. Utilizando este método es posible proveer soporte de logs, devolver mensajes a conexiones, permitir a un dæmon aceptar solamente conexiones internas, etc. Aunque algunas de estas opciones pueden conseguirse gracias a un cortafuegos, no sólo añadirá una capa extra de seguridad, sino que irá más allá del nivel de control ue un cortafuegos puede ofrecerle.</p></div><div class=paragraph><p>Las brillantes capacidades de TCP Wrappers no deben considerarse una alternativa a un buen cortafuegos. TCP Wrappers puede usarse conjuntamente con un cortafuegos u otro sistema de de seguridad, pues ofrece una capa extra de protección para el sistema.</p></div><div class=paragraph><p>Ya que es una extensión de la configuración de <code>inetd</code>, se da por hecho que el lector ha leído la sección <a href=../advanced-networking/#network-inetd>configuración de inetd</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Aunque los programas ejecutados por <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> no son exactamente "dæmons" tradicionalmente han recibido ese nombre. Dæmon es, por tanto, el término que usaremos en esta sección.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_configuración_inicial>14.6.1. Configuración inicial<a class=anchor href=#_configuración_inicial></a></h3><div class=paragraph><p>El único requisito para usar TCP Wrappers en FreeBSD es que el servidor <code>inetd</code> se inicie desde <span class=filename>rc.conf</span> con la opción <code>-Ww</code> (es la configuración por defecto). Por descontado, se presupone que <span class=filename>/etc/hosts.allow</span> estará correctamente configurado, pero <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> enviará mensajes a los logs del sistema si no es así.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A diferencia de otras implementaciones de TCP Wrappers, se ha dejado de usar <span class=filename>hosts.deny</span>. Todas las opciones de configuración deben ir en <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En la configuración más simple las políticas de conexión de dæmons están configuradas ya sea a permitir o bloquear, dependiendo de las opciones en <span class=filename>/etc/hosts.allow</span>. La configuración por defecto en FreeBSD consiste en permitir una conexión a cada dæmon iniciado por <code>inetd</code>. Es posible modificar esta configuración, pero explicaremos cómo hacerlo después de exponer la configuración básica.</p></div><div class=paragraph><p>La configuración básica tiene la estructura <code>dæmon : dirección : acción</code>, donde <code>dæmon</code> es el nombre de dæmon que inicia <code>inetd</code>. La <code>dirección</code> puede ser un nombre de equipo válido, una dirección IP o IPv6 encerrada en corchetes ([ ]). El campo acción puede ser permitir o denegar para el dar el acceso apropiado. Tenga presente que la configuración funciona en base a la primera regla cuya semántica concuerde; esto significa que el fichero de configuración se lee en orden ascendente hasta que concuerde una regla. Cuando se encuentra una concordancia se aplica la regla y el proceso se detendrá.</p></div><div class=paragraph><p>Existen muchas otras opciones pero estas se explican en una sección posterior. Una línea de configuración simple puede generarse mediante datos así de simples. Por ejemplo, para permitir conexiones POP3 mediante el dæmon <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, añada las siguientes líneas a <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>Despues de añadir esta línea tendrá que reiniciar <code>inetd</code>. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> o use el parámetro <span class=parameter>restart</span> de <span class=filename>/etc/rc.d/inetd</span>.</p></div></div><div class=sect2><h3 id=_configuración_avanzada>14.6.2. Configuración avanzada<a class=anchor href=#_configuración_avanzada></a></h3><div class=paragraph><p>Las opciones avanzadas de TCP Wrappers le permiten un mayor control sobre la gestión de conexiones. En algunos casos puede convenir el enío de un comentario a ciertos equipos o conexiones de dæmons. En otros casos, quizás se deba registrar una entrada en un log o enviar un correo al administrador. Otro tipo de situaciones pueden requerir el uso de un servicio solamente para conexiones locales. Todo esto es posible gracias al uso de unas opciones de configuración conocidas como <code>comodines</code>, caracteres de expansión y ejecución de órdenes externas. Las siguientes dos secciones intentarán cubrir estas situaciones.</p></div><div class=sect3><h4 id=_órdenes_externas>14.6.2.1. Órdenes externas<a class=anchor href=#_órdenes_externas></a></h4><div class=paragraph><p>Imaginemos una situación en la que una conexión debe ser denegada pero se debe mandar un motivo a quien intentó establecer esa conexión. ?Cómo? Mediante la opción <code>twist</code>. Ante un intento de conexión se invoca a <code>twist</code>, que ejecuta una orden de shell o un "script". Tiene un ejemplo en el fichero <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo &#34;No se permite utilizar %d desde %h.&#34;</pre></div></div><div class=paragraph><p>Este ejemplo muestra que el mensaje, "No se permite utilizar <code>dæmon</code> desde <code>nombre de equipo</code>." se enviará en el caso de cualquier dæmon no configurado previamente en el fichero de acceso. Esto es extremadamente útil para enviar una respuesta al creador de la conexión justo después de que la conexión establecida es rechazada. Observe que cualquier mensaje que se desee enviar <em>debe ir</em> entre comillas <code>"</code>; esta regla no tiene excepciones.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es posible lanzar un ataque de denegación de servicio al servidor si un atacante o grupo de atacantes pueden llegar a sobrecargar estos dæmons con peticiones de conexión.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Otra posibilidad en estos casos es usar la opción <code>spawn</code>. Igual que <code>twist</code>, <code>spawn</code> niega implícitamente la conexión, y puede usarse para ejecutar órdenes de shell externos o "scripts". A diferencia de <code>twist</code>, <code>spawn</code> no enviará una respuesta al origen de la conexión. Veamos un ejemplo; observe la siguiente línea de configuración:</p></div><div class="literalblock programlisting"><div class=content><pre># No permitimos conexiones desde ejemplo.com:
ALL : .ejemplo.com \
	: spawn (/bin/echo %a desde %h intento acceder a %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>Esto denegará todos los intentos de conexión desde el dominio <code>*.ejemplo.com</code>; simultáneamente creará una entrada con el nombre del equipo, dirección IP y el dæmon al que intentó conectarse al fichero <span class=filename>/var/log/connections.log</span>.</p></div><div class=paragraph><p>Además de la sustitución de caracteres ya expuesta más arriba (por ejemplo %a) existen unas cuantas más. Si quiere ver la lista completa consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>.</p></div></div><div class=sect3><h4 id=_opciones_comodín>14.6.2.2. Opciones comodín<a class=anchor href=#_opciones_comodín></a></h4><div class=paragraph><p>Hasta ahora se ha usado <code>ALL</code> en todos los ejemplos, pero hay otras opciones interesantes para extender un poco más la funcionalidad. Por ejemplo, <code>ALL</code> puede usarse para concordar con cualquier instancia ya sea un dæmon, dominio o dirección IP. Otro comodín es <code>PARANOID</code>, que puede utilizarse para concordar con cualquier equipo que presente una dirección IP que pueda estar falsificada. En otras palabras, <code>paranoid</code> puede usarse para definir una acción a tomar siempre que tenga lugar una conexión desde una dirección IP que difiera de su nombre de equipo. Quizás todo se vea más claro con el siguiente ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre># Bloquear peticiones posiblemente falsificadas a sendmail:
sendmail : PARANOID : deny</pre></div></div><div class=paragraph><p>En ese ejemplo todas las peticiones de conexión a <code>sendmail</code> que tengan una dirección IP que varíe de su nombre de equipo serán denegadas.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Utilizando <code>PARANOID</code> puede bloquear el acceso a servidores si el cliente o el servidor tiene una configuración de DNS incorrecta. Recomendamos al administrador la máxima cautela en su uso.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> si quiere saber más sobre los comodines y sus posibilidades de uso.</p></div><div class=paragraph><p>Si quiere que cualquiera de los ejemplos citados funcione debe comentar la primera línea de <span class=filename>hosts.allow</span> (tal y como se dijo al principio de la sección.</p></div></div></div></div></div><div class=sect1><h2 id=kerberosIV>14.7. KerberosIV<a class=anchor href=#kerberosIV></a></h2><div class=sectionbody><div class=paragraph><p>Kerberos es un sistema/protocolo de red agregado que permite a los usuarios identificarse a través de los servicios de un servidor seguro. Los servicios como login remoto, copia remota, copias de ficheros de un sistema a otro y otras tantas tareas arriesgadas pasan a ser considerablemente seguras y más controlables.</p></div><div class=paragraph><p>Las siguientes instrucciones pueden usarse como una guía para configurar Kerberos tal y como se distribuye con FreeBSD. De todas maneras, debe consultar diversas páginas de manual para conocer todos los detalles.</p></div><div class=sect2><h3 id=_instalación_de_kerberosiv>14.7.1. Instalación de KerberosIV<a class=anchor href=#_instalación_de_kerberosiv></a></h3><div class=paragraph><p>Kerberos es un componente opcional de FreeBSD. La manera más fácil de instalar este software es seleccionando la distribución <code>krb4</code> o <code>krb5</code> en sysinstall durante la instalación inicial de FreeBSD. Desde ahí instalará la implementación de Kerberos "eBones" (KerberosIV) o "Heimdal" (Kerberos5). Estas implementaciones se incluyen porque a que han sido desarrolladas fuera de EEUU y Canadá, lo que las convertía en accesibles para administradores de sistemas del resto del mundo durante la época restrictiva de control control de exportaciones de código criptográfico desde EEUU.</p></div><div class=paragraph><p>También puede instalar la implementación de Kerberos del MIT desde la colección de ports (<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>).</p></div></div><div class=sect2><h3 id=_creación_de_la_base_de_datos_inicial>14.7.2. Creación de la base de datos inicial<a class=anchor href=#_creación_de_la_base_de_datos_inicial></a></h3><div class=paragraph><p>Esto solo debe hacerse en el servidor Kerberos. Lo primero es asegurarse de que no tiene bases de datos de Kerberos anteriores. Entre al directorio <span class=filename>/etc/kerberosIV</span> y asegúrese de que solo estén los siguientes ficheros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/kerberosIV</span>
<span class=c># ls</span>
README		krb.conf        krb.realms</code></pre></div></div><div class=paragraph><p>Si existe cualquier otro fichero (como <span class=filename>principal.*</span> o <span class=filename>master_key</span>) utilice <code>kdb_destroy</code> para destruir la base de datos antigua de Kerberos. Si Kerberos no está funcionando simplemente borre los ficheros sobrantes.</p></div><div class=paragraph><p>Edite <span class=filename>krb.conf</span> y <span class=filename>krb.realms</span> para definir su dominio Kerberos. En nuestro ejemplo el dominio será <code>EJEMPLO.COM</code> y el servidor es <code>grunt.ejemplo.com</code>. Editamos o creamos <span class=filename>krb.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.conf</span>
EJEMPLO.COM
EJEMPLO.COM grunt.ejemplo.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</code></pre></div></div><div class=paragraph><p>Los demás dominios no deben estar forzosamente en la configuración. Los hemos incluido como ejemplo de cómo puede hacerse que una máquina trabaje con múltiples dominios. Si quiere mantener todo simple puede abstenerse de incluirlos.</p></div><div class=paragraph><p>La primera línea es el dominio en el que el sistema funcionará. Las demás líneas contienen entradas dominio/equipo. El primer componente de cada línea es un dominio y el segundo es un equipo de ese dominio, que actúa como "centro de distribución de llaves". Las palabras <code>admin server</code> que siguen al nombre de equipo significan que ese equipo también ofrece un servidor de base da datos administrativo. Si quiere consultar una explicación más completa de estos términos consulte las páginas de manual de de Kerberos.</p></div><div class=paragraph><p>Ahora añadiremos <code>grunt.ejemplo.com</code> al dominio <code>EJEMPLO.COM</code> y también una entrada para poner todos los equipos en el dominio <code>.ejemplo.com</code> Kerberos <code>EJEMPLO.COM</code>. Puede actualizar su <span class=filename>krb.realms</span> del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.realms</span>
grunt.ejemplo.com EJEMPLO.COM
.ejemplo.com EJEMPLO.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</code></pre></div></div><div class=paragraph><p>Igual que en caso previo, no tiene por qué incluir los demás dominios. Se han incluido para mostrar cómo puede usar una máquina en múltiples dominios. Puede eliminarlos y simplificar la configuración.</p></div><div class=paragraph><p>La primera línea pone al sistema <em>específico</em> en el dominio nombrado. El resto de las líneas muestran cómo asignar por defecto sistemas de un subdominio a un dominio Kerberos.</p></div><div class=paragraph><p>Ya podemos crear la base de datos. Solo se ejecuta en el servidor Kerberos (o centro de distribución de llaves). Ejecute <code>kdb_init</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_init</span>
Realm name <span class=o>[</span>default  ATHENA.MIT.EDU <span class=o>]</span>: EJEMPLO.COM
You will be prompted <span class=k>for </span>the database Master Password.
It is important that you NOT FORGET this password.

Enter Kerberos master key:</code></pre></div></div><div class=paragraph><p>Ahora tendremos que guardar la llave para que los servidores en la máquina local puedan recogerla. Utilice <code>kstash</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!</code></pre></div></div><div class=paragraph><p>Esto guarda la contraseña cifrada maestra en <span class=filename>/etc/kerberosIV/master_key</span>.</p></div></div><div class=sect2><h3 id=_puesta_en_marcha_del_sistema>14.7.3. Puesta en marcha del sistema<a class=anchor href=#_puesta_en_marcha_del_sistema></a></h3><div class=paragraph><p>Tendrá que añadir a la base de datos dos entradas en concreto para <em>cada</em> sistema que vaya a usar Kerberos: <code>kpasswd</code> y <code>rcmd</code>. Se hacen para cada sistema individualmente cada sistema, y el campo "instance" es el nombre individual del sistema.</p></div><div class=paragraph><p>Estos dæmons kpasswd y rcmd permiten a otros sistemas cambiar contraseñas de Kerberos y ejecutar órdenes como <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>.</p></div><div class=paragraph><p>Ahora vamos a añadir estas entradas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: passwd
Instance: grunt

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: passwd, Instance: grunt, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> tecleo aleatorio
Verifying password

New Password: &lt;<span class=nt>----</span> tecleo aleatorio

Random password <span class=o>[</span>y] ? y

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name: rcmd
Instance: grunt

&lt;Not found&gt;, Create [y] ?

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
New Password:		&lt;---- tecleo aleatorio
Verifying password

New Password:           &lt;---- tecleo aleatorio

Random password [y] ?

Principal&#39;</span>s new key version <span class=o>=</span> 1
Expiration <span class=nb>date</span> <span class=o>(</span>enter yyyy-mm-dd<span class=o>)</span> <span class=o>[</span> 2000-01-01 <span class=o>]</span> ?
Max ticket lifetime <span class=o>(</span><span class=k>*</span>5 minutes<span class=o>)</span> <span class=o>[</span> 255 <span class=o>]</span> ?
Attributes <span class=o>[</span> 0 <span class=o>]</span> ?
Edit O.K.
Principal name:         &lt;<span class=nt>----</span> si introduce datos nulos saldrá del programa</code></pre></div></div></div><div class=sect2><h3 id=_creación_del_fichero_del_servidor>14.7.4. Creación del fichero del servidor<a class=anchor href=#_creación_del_fichero_del_servidor></a></h3><div class=paragraph><p>Ahora tendremos que extraer todas las instancias que definen los servicios en cada máquina; para ello usaremos <code>ext_srvtab</code>. Esto creará un fichero que debe ser copiado o movido <em>por medios seguros</em> al directorio <span class=filename>/etc/kerberosIV</span> de cada cliente Kerberos. Este fichero debe existir en todos los servidores y clientes dada su importancia clave para el funcionamiento de Kerberos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ext_srvtab grunt</span>
Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating <span class=s1>&#39;grunt-new-srvtab&#39;</span>....</code></pre></div></div><div class=paragraph><p>Esta orden solo genera un fichero temporal al que tendrá que cambiar el nombre a <span class=filename>srvtab</span> para que todos los servidores puedan recogerlo. Utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=mv&amp;sektion=1&amp;format=html">mv(1)</a> para moverlo al lugar correcto en el sistema original:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grunt-new-srvtab srvtab</span></code></pre></div></div><div class=paragraph><p>Si el fichero es para un sistema cliente y la red no puede considerarse segura copie el <span class=filename>cliente-new-srvtab</span> en un medio extraíble y transpórtelo por medios físicos seguros. Asegúrese de cambiar su nombre a <span class=filename>srvtab</span> en el directorio <span class=filename>/etc/kerberosIV</span> del cliente, y asegúrese también de que tiene modo 600:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grumble-new-srvtab srvtab</span>
<span class=c># chmod 600 srvtab</span></code></pre></div></div></div><div class=sect2><h3 id=_añadir_entradas_a_la_base_de_datos>14.7.5. Añadir entradas a la base de datos<a class=anchor href=#_añadir_entradas_a_la_base_de_datos></a></h3><div class=paragraph><p>Ahora tenemos que añadir entradas de usuarios a la base de datos. Primero vamos a crear una entrada para el usuario <code>jane</code>. Para ello usaremos <code>kdb_edit</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance:

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: , kdc_key_ver: 1
New Password:                &lt;<span class=nt>----</span> introduzca una constraseña segura
Verifying password

New Password:                &lt;<span class=nt>----</span> introduzca de nuevo la contraseña
Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:		   &lt;---- si introduce datos nulos saldrá del programa</span></code></pre></div></div></div><div class=sect2><h3 id=_prueba_del_sistema>14.7.6. Prueba del sistema<a class=anchor href=#_prueba_del_sistema></a></h3><div class=paragraph><p>Primero tenemos que iniciar los dæmons de Kerberos. Tenga en cuenta que si su <span class=filename>/etc/rc.conf</span> está configurado correctamente el inicio tendrá ligar cuando reinicie el sistema. Esta prueba solo es necesaria en el servidor Kerberos; los clientes Kerberos tomarán lo que necesiten automáticamente desde el directorio <span class=filename>/etc/kerberosIV</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kerberos &amp;</span>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EJEMPLO.COM
<span class=c># kadmind -n &amp;</span>
KADM Server KADM0.0A initializing
Please <span class=k>do </span>not use <span class=s1>&#39;kill -9&#39;</span> to <span class=nb>kill </span>this job, use a
regular <span class=nb>kill </span>instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</code></pre></div></div><div class=paragraph><p>Ahora podemos probar a usar <code>kinit</code> para obtener un ticket para el ID <code>jane</code> que creamos antes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit jane
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Pruebe a listar los tokens con <code>klist</code> para ver si realmente están:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Ticket file:    /tmp/tkt245
Principal:      jane@EJEMPLO.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EJEMPLO.COM@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>Ahora trate de cambiar la contraseña usando <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> para comprobar si el dæmon kpasswd está autorizado a acceder a la base de datos Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
realm EJEMPLO.COM
Old password <span class=k>for </span>jane:
New Password <span class=k>for </span>jane:
Verifying password
New Password <span class=k>for </span>jane:
Password changed.</code></pre></div></div></div><div class=sect2><h3 id=_añadir_privilegios_de_su>14.7.7. Añadir privilegios de <code>su</code><a class=anchor href=#_añadir_privilegios_de_su></a></h3><div class=paragraph><p>Kerberos nos permite dar a <em>cada</em> usuario que necesite privilegios de <code>root</code> su <em>propia</em> contraseña para <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Podemos agregar un ID que esté autorizado a ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> <code>root</code>. Esto se controla con una instancia de <code>root</code> asociada con un usuario. Vamos a crear una entrada <code>jane.root</code> en la base de datos, para lo que recurrimos a <code>kdb_edit</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance: root

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> introduzca una contraseña SEGURA
Verifying password

New Password:    	 	 &lt;<span class=nt>----</span> introduzca otra vez la constraseña

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ? 12 &lt;--- Keep this short!
Attributes [ 0 ] ?
Edit O.K.
Principal name:		         &lt;---- si introduce datos nulos saldrá del programa</span></code></pre></div></div><div class=paragraph><p>Ahora trate de obtener los tokens para comprobar que todo funciona:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kinit jane.root</span>
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane.root&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Hemos de agregar al usuario al <span class=filename>.klogin</span> de <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>Ahora trate de hacer <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:</code></pre></div></div><div class=paragraph><p>y eche un vistazo a qué tokens tenemos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># klist</span>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EJEMPLO.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EJEMPLO.COM@EJEMPLO.COM</code></pre></div></div></div><div class=sect2><h3 id=_uso_de_otras_órdenes>14.7.8. Uso de otras órdenes<a class=anchor href=#_uso_de_otras_órdenes></a></h3><div class=paragraph><p>En un ejemplo anterior creamos un usuario llamado <code>jane</code> con una instancia <code>root</code>. Nos basamos en un usuario con el mismo nombre del "principal" (<code>jane</code>), el procedimiento por defecto en Kerberos: <code>&lt;principal>.&lt;instancia></code> con la estructura <code>&lt;nombre de usuario>. root</code> permitirá que <code>&lt;nombre de usuario></code> haga <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> a <code>root</code> si existen las entradas necesarias en el <span class=filename>.klogin</span> que hay en el directorio home de <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>De la misma manera, si un usuario tiene en su directorio home lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat</span> ~/.klogin
jane@EJEMPLO.COM
jack@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>significa que cualquier usuario del dominio <code>EJEMPLO.COM</code> que se identifique como <code>jane</code> o como <code>jack</code> (vía <code>kinit</code>, ver más arriba) podrá acceder a la cuenta de <code>jane</code> o a los ficheros de este sistema (<code>grunt</code>) vía <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>.</p></div><div class=paragraph><p>Veamos por ejemplo cómo <code>jane</code> se se identifica en otro sistema mediante Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Password:
% rlogin grunt
Last login: Mon May  1 21:14:47 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div><div class=paragraph><p>Aquí <code>jack</code> se identifica con la cuenta de <code>jane</code> en la misma máquina (<code>jane</code> tiene configurado su fichero <span class=filename>.klogin</span> como se ha mostrado antes, y la persona encargada de la administración de Kerberos ha configurado un usuario principal <em>jack</em> con una instancia nula):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
% rlogin grunt <span class=nt>-l</span> jane
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Password:
Last login: Mon May  1 21:16:55 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=kerberos5>14.8. Kerberos5<a class=anchor href=#kerberos5></a></h2><div class=sectionbody><div class=paragraph><p>Cada versión de FreeBSD posterior a FreeBSD-5.1 incluye soporte solamente para Kerberos5. Por esta razón Kerberos5 es la única versión incluida. Su configuración es similar en muchos aspectos a la de KerberosIV. La siguiente información solo atañe a Kerberos5 en versiones de FreeBSD-5.0 o posteriores. Los usuarios que deséen utilizar KerberosIV pueden instalar el port <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb4/>security/krb4</a>.</p></div><div class=paragraph><p>Kerberos es un sistema/protocolo agregado para red que permite a los usuarios validar su identidad a través de los servicios de un servidor seguro. Los servicios como login remoto, copia remota, copias de fichero de un sistema a otro y otras tareas generalmente consideradas poco seguras pasan a ser considerablemente seguras y más controlables.</p></div><div class=paragraph><p>Kerberos puede describirse como un sistema proxy identificador/verificador. También puede describirse como un sistema confiable de autentificación de terceros. Kerberos solamente ofrece una función: la validación segura de usuarios a través de una red. No proporciona funciones de autorización (es decir, lo que los usuarios tienen permitido hacer) o funciones de auditoría (lo que esos usuarios hicieron). Después de que un servidor y un cliente han usado Kerberos para demostrar su identidad pueden también cifrar todas sus sus comunicaciones, asegurando de este modo su intimidad y la integridad de sus datos durante su uso del sistema.</p></div><div class=paragraph><p>Es, por tanto, altamente recomendable que se use Kerberos <em>además</em> de otros métodos de seguridad que ofrezcan servicios de autorización y auditoría.</p></div><div class=paragraph><p>Puede usar las siguientes instrucciones como una guía para configurar Kerberos tal y como se distribuye en FreeBSD. De todas maneras, debería consultar las páginas de manual adecuadas para tener toda la información.</p></div><div class=paragraph><p>Vamos a mostrar una instalación Kerberos, para lo cual usaremos los siguientes espacios de nombres:</p></div><div class=ulist><ul><li><p>El dominio DNS ("zona") será ejemplo.org.</p></li><li><p>El dominio Kerberos (realm) será EJEMPLO.ORG.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Debe utilizar nombres de dominio reales al configurar Kerberos incluso si pretende ejecutarlo internamente. Esto le evitará problemas de DNS y asegura la interoperación con otros dominios Kerberos.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_historia>14.8.1. Historia<a class=anchor href=#_historia></a></h3><div class=paragraph><p>Kerberos fué creado en el Massachusetts Institute of Technology (MIT) como una solución a los problemas de seguridad de la red. El protocolo Kerberos utiliza criptografía fuerte para que un cliente pueda demostrar su identidad en un servidor (y viceversa) a través de una conexión de red insegura.</p></div><div class=paragraph><p>Kerberos es el nombre de un protocolo de autentificación vía red y un adjetivo para describir programas que implementan el programa (Kerberos telnet, por ejemplo, conocido también como el "telnet kerberizado"). La versión actual del protocolo es la 5, descrita en RFC 1510.</p></div><div class=paragraph><p>Existen diversas implementaciones libres de este protocolo, cubriendo un amplio rango de sistemas operativos. El MIT, donde Kerberos fué desarrollado, continúa desarrollando su propio paquete Kerberos. Suele usarse en los EEUU como producto criptográfico y como tal ha sufrido las regulaciones de exportación de los EEUU. El Kerberos del MIT existe como un port en (<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>). Heimdal Kerberos es otra implementación de la versión 5, y fué desarrollada de forma intencionada fuera de los EEUU para sortear las regulaciones de exportación (y por eso puede incluirse en versiones no comerciales de UNIX®). La distribución Heimdal Kerberos está en el port (<a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a>), y se incluye una instalación mínima en el sistema base de FreeBSD.</p></div><div class=paragraph><p>Para alcanzar la mayor audiencia estas instrucciones asumen el uso de la distribución Heimdal incluída en FreeBSD.</p></div></div><div class=sect2><h3 id=_configuración_de_un_kdc_heimdal>14.8.2. Configuración de un KDC Heimdal<a class=anchor href=#_configuración_de_un_kdc_heimdal></a></h3><div class=paragraph><p>El centro de distribución de llaves (KDC, Key Distribution Center) es el servicio centralizado de validación que proporciona Kerberos: es el sistema que emite tickets Kerberos. El KDC goza del estátus de ser considerado como "confiable" por las demás computadoras del dominio Kerberos, y por eso tiene consideraciones de seguridad más elevadas.</p></div><div class=paragraph><p>Tenga en cuenta que, aunque la ejecución del servidor Kerberos requiere muy pocos recursos, se recomienda el uso de una máquina dedicada a KDC por razones de seguridad.</p></div><div class=paragraph><p>Para empezar a configurar un KDC asegúrese de que su <span class=filename>/etc/rc.conf</span> contenga la configuración adecuada para actuar como KDC (tal vez deba ajustar algunas rutas para que cuadren con su sistema):</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;
kerberos_stash=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>kerberos_stash</code> solo existe en FreeBSD 4.X.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A continuación configuraremos el fichero de configuración de Kerberos, <span class=filename>/etc/krb5.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EJEMPLO.ORG [realms]
    EXAMPLE.ORG = {
        kdc = kerberos.ejemplo.org
        admin_server = kerberos.ejemplo.org
    }
[domain_realm]
    .ejemplo.org = EJEMPLO.ORG</pre></div></div><div class=paragraph><p>Tenga en cuenta que este <span class=filename>/etc/krb5.conf</span> implica que su KDC tendrá el nombre de equipo completo calificado de <code>kerberos.ejemplo.org</code>. Necesitará añadir una entrada CNAME (alias) a su fichero de zona si su KDC tiene un nombre de equipo diferente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En grandes redes con un servidor DNSBIND bien configurado, el ejemplo de arriba puede quedar del siguiente modo:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EJEMPLO.ORG</pre></div></div><div class=paragraph><p>Con las siguientes líneas agregadas al fichero de zona <code>ejemplo.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.ejemplo.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.ejemplo.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.ejemplo.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.ejemplo.org.
_kerberos           IN  TXT     EJEMPLO.ORG</pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para que los clientes sean capaces de encontrar los servicios Kerberos <em>debe</em> tener ya sea un <span class=filename>/etc/krb5.conf</span> configurado o un <span class=filename>/etc/krb5.conf</span> configurado de forma mínima <em>y</em> un servidor DNS configurado correctamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A continuación crearemos la base de datos Kerberos. Esta base de datos contiene las llaves de todos los principales cifradas con una contraseña maestra. No es necesario que recuerde esta contraseña, pues se almacenará en <span class=filename>/var/heimdal/m-key</span>. Para crear la llave maestra ejecute <code>kstash</code> e introduzca una contraseña.</p></div><div class=paragraph><p>Una vez que se ha creado la llave maestra puede inicializar la base de datos usando el programa <code>kadmin</code> con la opción <code>-l</code> (que significa "local"). Esta opción le dice a <code>kadmin</code> que modifique los ficheros de la base de datos directamente en lugar de ir a través del servicio de red <code>kadmind</code>. Esto gestiona el problema del huevo y la gallina de tratar de conectar a la base de datos antes de que ésta exista. Una vez que tiene el "prompt" de <code>kadmin</code>, utilice <code>init</code> para crear su base de datos de dominios iniciales.</p></div><div class=paragraph><p>Para terminar, mientras está todavía en <code>kadmin</code> puede crear su primer principal mediante <code>add</code>. Utilice las opciones por defecto por ahora, más tarde puede cambiarlas mediante <code>modify</code>. Recuerde que puede usar <code>?</code> en cualquier "prompt" para consultar las opciones disponibles.</p></div><div class=paragraph><p>Veamos un ejemplo de sesión de creación de una base de datos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

<span class=c># kadmin -l</span>
kadmin&gt; init EJEMPLO.ORG
Realm max ticket life <span class=o>[</span>unlimited]:
kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Ahora puede arrancar los servicios KDC. Ejecute <code>/etc/rc.d/kerberos start</code> y <code>/etc/rc.d/kadmind start</code> para levantar dichos servicios. Recuerde que no tendrá ningún dæmon kerberizado ejecutándose pero debe poder confirmar que KDC funciona por el procedimiento de obtener y listar un boleto del principal (usuario) que acaba de crear en la línea de órdenes de KDC:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% k5init tillman
tillman@EJEMPLO.ORG<span class=s1>&#39;s Password:

% k5list
Credentials cache: FILE:/tmp/krb5cc_500
	Principal: tillman@EJEMPLO.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EJEMPLO.ORG@EJEMPLO.ORG</span></code></pre></div></div></div><div class=sect2><h3 id=_creación_de_un_servidor_kerberos_con_servicios_heimdal>14.8.3. Creación de un servidor Kerberos con servicios Heimdal<a class=anchor href=#_creación_de_un_servidor_kerberos_con_servicios_heimdal></a></h3><div class=paragraph><p>Antes de nada necesitaremos una copia del fichero de configuración de Kerberos, <span class=filename>/etc/krb5.conf</span>. Cópielo al cliente desde KDC de forma segura (mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, o usando un disquete).</p></div><div class=paragraph><p>A continuación necesitará un fichero <span class=filename>/etc/krb5.keytab</span>. Esta es la mayor diferencia entre un servidor que proporciona dæmons habilitados con Kerberos y una estación de trabajo: el servidor debe tener un fichero <span class=filename>keytab</span>. Dicho fichero contiene las llaves de equipo del servidor, las cuales le permiten a él y al KDC verificar la identidad entre ellos. Deben transmitirse al servidor de forma segura ya que la seguridad del servidor puede verse comprometida si la llave se hace pública. Por decirlo más claro, transferirla como texto plano a través de la red (por ejemplo por FTP) es una <em>pésima idea</em>.</p></div><div class=paragraph><p>Lo normal es que transmita su <span class=filename>keytab</span> al servidor mediante el programa <code>kadmin</code>. Esto es práctico porque también debe crear el principal del equipo (el KDC que aparece al final de <span class=filename>krb5.keytab</span>) usando <code>kadmin</code>.</p></div><div class=paragraph><p>Tenga en cuenta que ya debe disponer de un ticket, y que este ticket debe poder usar el interfaz <code>kadmin</code> en <span class=filename>kadmind.acl</span>. Consulte la sección "administración remota" en la página info de Heimdal (<code>info heimdal</code>), donde se exponen los detalles de diseño de las listas de control de acceso. Si no quiere habilitar acceso remoto <code>kadmin</code>, puede conectarse de forma segura al KDC (por medio de consola local, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> Kerberos) y administrar en local mediante <code>kadmin -l</code>.</p></div><div class=paragraph><p>Después de instalar el fichero <span class=filename>/etc/krb5.conf</span> puede usar <code>kadmin</code> desde el servidor Kerberos. <code>add --random-key</code> le permitirá añadir el principal del equipo servidor, y <code>ext</code> le permitirá extraer el principal del equipo servidor a su propio keybat. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.ejemplo.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext host/miservidor.ejemplo.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta que <code>ext</code> (contracción de "extract") almacena la llave extraída por defecto en en <span class=filename>/etc/krb5.keytab</span>.</p></div><div class=paragraph><p>Si no tiene <code>kadmind</code> ejecutándose en KDC (posiblemente por razones de seguridad) y por lo tanto carece de acceso remoto a <code>kadmin</code> puede añadir el principal de equipo (<code>host/miservidor.EJEMPLO.ORG</code>) directamente en el KDC y entonces extraerlo a un fichero temporal (para evitar sobreescribir <span class=filename>/etc/krb5.keytab</span> en el KDC) mediante algo parecido a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext <span class=nt>--keytab</span><span class=o>=</span>/tmp/ejemplo.keytab host/miservidor.ejemplo.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Puede entonces copiar de forma segura el keytab al servidor (usando <code>scp</code> o un diquete). Asegúrese de usar un nombre de keytab diferente para evitar sobreescribir el keytab en el KDC.</p></div><div class=paragraph><p>Su servidor puede comunicarse con el KDC (gracias a su fichero <span class=filename>krb5.conf</span>) y puede probar su propia identidad (gracias al fichero <span class=filename>krb5.keytab</span>). Ahora está listo para que usted habilite algunos servicios Kerberos. En este ejemplo habilitaremos el servicio <code>telnet</code> poniendo una línea como esta en su <span class=filename>/etc/inetd.conf</span> y reiniciando el servicio <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> con <code>/etc/rc.d/inetd restart</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</pre></div></div><div class=paragraph><p>La parte crítica es <code>-a</code>, de autentificación de usuario. Consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> para más información.</p></div></div><div class=sect2><h3 id=_kerberos_con_un_cliente_heimdal>14.8.4. Kerberos con un cliente Heimdal<a class=anchor href=#_kerberos_con_un_cliente_heimdal></a></h3><div class=paragraph><p>Configurar una computadora cliente es extremadamente fácil. Lo único que necesita es el fichero de configuración de Kerberos que encontrará en <span class=filename>/etc/krb5.conf</span>. Simplemente cópielo de forma segura a la computadora cliente desde el KDC.</p></div><div class=paragraph><p>Pruebe su computadora cliente mediante <code>kinit</code>, <code>klist</code>, y <code>kdestroy</code> desde el cliente para obtener, mostrar y luego borrar un ticket para el principal que creó antes. Debería poder usar aplicaciones Kerberos para conectarse a servidores habilitados con Kerberos, aunque si no funciona y tiene problemas al intentar obtener el boleto lo más probable es que el problema esté en el servidor y no en el cliente o el KDC.</p></div><div class=paragraph><p>Al probar una aplicación como <code>telnet</code>, trate de usar un "sniffer" de paquetes ( como <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>) para confirmar que su contraseña no viaja en claro por la red. Trate de usar <code>telnet</code> con la opción <code>-x</code>, que cifra el flujo de datos por entero (algo parecido a lo que hace <code>ssh</code>).</p></div><div class=paragraph><p>Las aplicaciones clientes Kerberos principales (llamadas tradicionalmente <code>kinit</code>, <code>klist</code>, <code>kdestroy</code> y <code>kpasswd</code>) están incluidas en la instalación base de FreeBSD. Tenga en cuenta que en las versiones de FreeBSD anteriores a 5.0 reciben los nombres de <code>k5init</code>, <code>k5list</code>, <code>k5destroy</code>, <code>k5passwd</code> y <code>k5stash</code>.</p></div><div class=paragraph><p>También se instalan por defecto diversas aplicaciones Kerberos que no entran dentro de la categoría de "imprescindibles". Es aquí donde la naturaleza "mínima" de la instalación base de Heimdal salta a la palestra: <code>telnet</code> es el único servicio Kerberos habilitado.</p></div><div class=paragraph><p>El port Heimdal añade algunas de las aplicaciones cliente que faltan: versiones Kerberos de <code>ftp</code>, <code>rsh</code>, <code>rcp</code>, <code>rlogin</code> y algunos otros programas menos comunes. El port del MIT también contiene una suite completa de aplicaciones cliente de Kerberos.</p></div></div><div class=sect2><h3 id=_ficheros_de_configuración_de_usuario_k5login_y_k5users>14.8.5. Ficheros de configuración de usuario: <span class=filename>.k5login</span> y <span class=filename>.k5users</span><a class=anchor href=#_ficheros_de_configuración_de_usuario_k5login_y_k5users></a></h3><div class=paragraph><p>Suele ser habitual que los usuarios de un dominio Kerberos (o "principales") tengan su usuario (por ejemplo <code>tillman@EJEMPLO.ORG</code>) mapeado a una cuenta de usuario local (por ejemplo un usuario llamado llamado <code>tillman</code>). Las aplicaciones cliente como <code>telnet</code> normalmente no requieren un nombre de usuario o un principal.</p></div><div class=paragraph><p>Es posible que de vez en cuando quiera dar acceso a una una cuenta de usuario local a alguien que no tiene un principal Kerberos. Por ejemplo, <code>tillman@EJEMPLO.ORG</code> puede necesitar acceso a la cuenta de usuario local <code>webdevelopers</code>. Otros principales tal vez necesiten acceso a esas cuentas locales.</p></div><div class=paragraph><p>Los ficheros <span class=filename>.k5login</span> y <span class=filename>.k5users</span>, ubicados en el directorio home del usuario, pueden usarse de un modo similar a una combinación potente de <span class=filename>.hosts</span> y <span class=filename>.rhosts</span>. Por ejemplo, si pusiera un fichero <span class=filename>.k5login</span> con el siguiente contenido</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>tillman@example.org
jdoe@example.org</code></pre></div></div><div class=paragraph><p>en el directorio home del usuario local <code>webdevelopers</code> ambos principales listados tendrían acceso a esa cuenta sin requerir una contraseña compartida.</p></div><div class=paragraph><p>Le recomendamos encarecidamente la lectura de las páginas de manual de estas órdenes. Recuerde que la página de manual de <code>ksu</code> abarca <span class=filename>.k5users</span>.</p></div></div><div class=sect2><h3 id=_kerberos_sugerencias_trucos_y_solución_de_problemas>14.8.6. Kerberos Sugerencias, trucos y solución de problemas<a class=anchor href=#_kerberos_sugerencias_trucos_y_solución_de_problemas></a></h3><div class=ulist><ul><li><p>Tanto si utiliza el port de Heimdal o el Kerberos del MIT asegúrese de que su variable de entorno <code>PATH</code> liste las versiones de Kerberos de las aplicaciones cliente antes que las versiones del sistema.</p></li><li><p>?Todas las computadoras de su dominio Kerberos tienen la hora sincronizada? Si no, la autentificación puede fallar. <a href=../advanced-networking:/#network-ntp>NTP</a> describe como sincronizar los relojes utilizando NTP.</p></li><li><p>MIT y Heimdal conviven bien, con la excepción de <code>kadmin</code>, protocolo no está estandarizado.</p></li><li><p>Si cambia su nombre de equipo debe cambiar también el "apellido" de su principal y actualizar su keytab. Esto también se aplica a entradas especiales en keytab como el principal <code>www/</code> que usa el <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a> de Apache.</p></li><li><p>Todos los equipos en su dominio Kerberos deben poder resolverse (tanto en la forma normal normal como en la inversa) en el DNS (o en <span class=filename>/etc/hosts</span> como mínimo). Los CNAME funcionarán, pero los registros A y PTR deben ser correctos y estar en su sitio. El mensaje de error que recibirá de no hacerlo así no es muy intuitivo: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Algunos sistemas operativos que puede usar como clientes de su KDC no activan los permisos para <code>ksu</code> como setuid <code>root</code>. Esto hará que <code>ksu</code> no funcione, lo cual es muy seguro pero un tanto molesto. Tenga en cuenta que no se debe a un error de KDC.</p></li><li><p>Si desea permitir que un principal tenga un ticket con una validez más larga que el valor por defecto de diez horas en Kerberos del MIT debe usar <code>modify_principal</code> en <code>kadmin</code> para cambiar "maxlife" tanto del principal en cuestión como del <code>krbtgt</code> del principal. Hecho esto, el principal puede utilizar la opción <code>-l</code> con <code>kinit</code> para solicitar un boleto con más tiempo de vida.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si ejecuta un "sniffer" de paquetes en su KDC para ayudar con la resolución de problemas y ejecuta <code>kinit</code> desde una estación de trabajo puede encontrarse con que su TGT se envía inmediatamente después de ejecutar <code>kinit</code>: <em>incluso antes de que escriba su contraseña</em> La explicación es que el servidor Kerberos transmite tranquilamente un TGT (Ticket Granting Ticket) a cualquier petición no autorizada; de todas maneras, cada TGT está cifrado en una llave derivada de la contraseña del usuario. Por tanto, cuando un usuario teclea su contraseña no la está enviando al KDC, se está usando para descifrar el TGT que <code>kinit</code> ya obtuvo. Si el proceso de descifrado termina en un ticket válido con una marca de tiempo válida, el usuario tiene credenciales Kerberos válidas. Estas credenciales incluyen una llave de sesión para establecer comunicaciones seguras con el servidor Kerberos en el futuro, así como el TGT en sí, que se cifra con la llave del propio servidor Kerberos. Esta segunda capa de cifrado es invisible para el usuario, pero es lo que permite al servidor Kerberos verificar la autenticidad de cada TGT.</p></div></td></tr></tbody></table></div><div class=ulist><ul><li><p>Si desea utilizar tickets con un tiempo largo de vida (una semana, por ejemplo) y está utilizando OpenSSH para conectarse a la máquina donde se almacena su boleto asgúrese de que Kerberos <code>TicketCleanup</code> esté configurado a <code>no</code> en su <span class=filename>sshd_config</span> o de lo contrario sus tickets serán eliminados cuando termine la sesión.</p></li><li><p>Recuerde que los principales de equipos también pueden tener tener un tiempo de vida más largo. Si su principal de usuario tiene un tiempo de vida de una semana pero el equipo al que se conecta tiene un tiempo de vida de nueve horas, tendrá un principal de equipo expirado en su caché, y la caché de ticket no funcionará como esperaba.</p></li><li><p>Cuando esté configurando un fichero <span class=filename>krb5.dict</span> pensando específicamente en prevenir el uso de contraseñas defectuosas (la página de manual de de <code>kadmind</code> trata el tema brevemente), recuerde que solamente se aplica a principales que tienen una política de contraseñas asignada. El formato de los ficheros <span class=filename>krb5.dict</span> es simple: una cadena de texto por línea. Puede serle útil crear un enlace simbólico a <span class=filename>/usr/shared/dict/words</span>.</p></li></ul></div></div><div class=sect2><h3 id=_diferencias_con_el_port_del_mit>14.8.7. Diferencias con el port del MIT<a class=anchor href=#_diferencias_con_el_port_del_mit></a></h3><div class=paragraph><p>Las diferencias más grandes entre las instalaciones MIT y Heimdal están relacionadas con <code>kadmin</code>, que tiene un conjunto diferente (pero equivalente) de órdenes y utiliza un protocolo diferente. Esto tiene implicaciones muy grandes si su KDC es MIT, ya que no podrá utilizar el programa <code>kadmin</code> de Heimdal para administrar remotamente su KDC (o viceversa).</p></div><div class=paragraph><p>Las aplicaciones cliente pueden también disponer de diferentes opciones de línea de órdenes para lograr lo mismo. Le recomendamos seguir las instrucciones de la página web de Kerberos del MIT (<a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a>). Sea cuidadoso con los parches: el port del MIT se instala por defecto en <span class=filename>/usr/local/</span>, y las aplicaciones "normales" del sistema pueden ser ejecutadas en lugar de las del MIT si su variable de entorno <code>PATH</code> lista antes los directorios del sistema.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si usa el port del MIT<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> proporcionado por FreeBSD asegúrese de leer el fichero <span class=filename>/usr/local/shared/doc/krb5/README.FreeBSD</span> instalado por el port si quiere entender por qué los login vía <code>telnetd</code> y <code>klogind</code> se comportan de un modo un tanto extraño. Más importante aún, corregir la conducta de "permisos incorrectos en el fichero caché" requiere que el binario <code>login.krb5</code> se use para la validación para que pueda cambiar correctamente los permisos de propiedad de credenciales reenviadas.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_mitigación_de_limitaciones_encontradas_en_kerberos>14.8.8. Mitigación de limitaciones encontradas en Kerberos<a class=anchor href=#_mitigación_de_limitaciones_encontradas_en_kerberos></a></h3><div class=sect3><h4 id=_kerberos_es_un_enfoque_todo_o_nada>14.8.8.1. Kerberos es un enfoque "todo o nada"<a class=anchor href=#_kerberos_es_un_enfoque_todo_o_nada></a></h4><div class=paragraph><p>Cada servicio habilitado en la red debe modificarse para funcionar con Kerberos (o debe ser asegurado contra ataques de red) o de lo contrario las credenciales de usuario pueden robarse y reutilizarse. Un ejemplo de esto podría ser que Kerberos habilite todos los shells remotos ( vía <code>rsh</code> y <code>telnet</code>, por ejemplo) pero que no cubra el servidor de correo POP3, que envía contraseñas en texto plano.</p></div></div><div class=sect3><h4 id=_kerberos_está_pensado_para_estaciones_de_trabajo_monousuario>14.8.8.2. Kerberos está pensado para estaciones de trabajo monousuario<a class=anchor href=#_kerberos_está_pensado_para_estaciones_de_trabajo_monousuario></a></h4><div class=paragraph><p>En un entorno multiusuario Kerberos es menos seguro. Esto se debe a que almacena los tickets en el directorio <span class=filename>/tmp</span>, que puede ser leído por todos los usuarios. Si un usuario está compartiendo una computadora con varias personas (esto es, si utiliza un sistema multiusuario) es posible que los tickets sean robados (copiados) por otro usuario.</p></div><div class=paragraph><p>Esto puede solventarse con la opción de línea de órdenes <code>-c</code> nombre-de-fichero o (mejor aún) la variable de entorno <code>KRB5CCNAME</code>, pero raramente se hace. Si almacena los tickets en el directorio home de los usuarios y utiliza sin mucha complicación los permisos de fichero puede mitigar este problema.</p></div></div><div class=sect3><h4 id=_el_kdc_es_el_punto_crítico_de_fallo>14.8.8.3. El KDC es el punto crítico de fallo<a class=anchor href=#_el_kdc_es_el_punto_crítico_de_fallo></a></h4><div class=paragraph><p>Por motivos de diseño el KDC es tan seguro como la base de datos principal de contraseñas que contiene. El KDC no debe ejecutar ningún otro servicio ejecutándose en él y debe ser físicamente seguro. El peligro es grande debido a que Kerberos almacena todas las contraseñas cifradas con la misma llave (la llave "maestra", que a su vez se guarda como un fichero en el KDC).</p></div><div class=paragraph><p>De todos modos una llave maestra comprometida no es algo tan terrible como parece a primera vista. La llave maestra solo se usa para cifrar la base de datos Kerberos y como semilla para el generador de números aleatorios. Mientras sea seguro el acceso a su KDC un atancante no puede hacer demasiado con la llave maestra.</p></div><div class=paragraph><p>Además, si el KDC no está disponible (quizás debido a un ataque de denegación de servicio o problemas de red) no se podrán utilizar los servicios de red ya que no se puede efectuar la validación, lo que hace que esta sea una buena forma de lanzar un ataque de denegación de servicio. Este problema puede aliviarse con múltiples KDCs (un maestro y uno o más esclavos) y con una implementación cautelosa de secundarios o autentificación de respaldo (para esto PAM es excelente).</p></div></div><div class=sect3><h4 id=_limitaciones_de_kerberos>14.8.8.4. Limitaciones de Kerberos<a class=anchor href=#_limitaciones_de_kerberos></a></h4><div class=paragraph><p>Kerberos le permite a usuarios, equipos y servicios validarse entre sí, pero no dispone de ningún mecanismo para autentificar el KDC a los usuarios, equipos o servicios. Esto significa que una versión (por ejemplo) "troyanizada" <code>kinit</code> puede grabar todos los usuarios y sus contraseñas. Puede usar <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> o alguna otra herramienta de revisión de integridad de sistemas de ficheros para intentar evitar problemas como este.</p></div></div></div><div class=sect2><h3 id=_recursos_y_más_información>14.8.9. Recursos y más información<a class=anchor href=#_recursos_y_más_información></a></h3><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>Las preguntas frecuentes (FAQ) de Kerberos</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Designing an Authentication System: a Dialog in Four Scenes</a></p></li><li><p><a href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510, The Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>Página web de Kerberos del MIT</a></p></li><li><p><a href=http://www.pdc.kth.se/heimdal/>Página web de Kerberos Heimdal</a></p></li></ul></div></div></div></div><div class=sect1><h2 id=openssl>14.9. OpenSSL<a class=anchor href=#openssl></a></h2><div class=sectionbody><div class=paragraph><p>El conjunto de herramientas OpenSSL es una característica de FreeBSD que muchos usuarios pasan por alto. OpenSSL ofrece una capa de cifrada de transporte sobre la capa normal de comunicación, permitiendo la combinación con con muchas aplicaciones y servicios de red.</p></div><div class=paragraph><p>Algunos usos de OpenSSL son la validación cifrada de clientes de correo, las transacciones basadas en web como pagos con tarjetas de crédito, etc. Muchos ports, como <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-ssl/>www/apache13-ssl</a> y <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a> ofrecen soporte de compilación para OpenSSL.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En la mayoría de los casos la colección de ports tratará de compilar el port <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> a menos que la variable de make <code>WITH_OPENSSL_BASE</code> sea puesta explícitamente a "yes".</p></div></td></tr></tbody></table></div><div class=paragraph><p>La versión de OpenSSL incluida en FreeBSD soporta los protocolos de seguridad de red Secure Sockets Layer v2/v3 (SSLv2/SSLv3) y Transport Layer Security v1 (TLSv1) y puede utilizarse como biblioteca criptográfica general.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>OpenSSL soporta el algoritmo IDEA pero estáa deshabilitado por defecto debido a patentes en vigor en los Estados Unidos. Si quiere usarlo debe revisar la licencia, y si las restricciones le parecen aceptables active la variable <code>MAKE_IDEA</code> en <span class=filename>make.conf</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Uno de los usos más comunes de OpenSSL es ofrecer certificados para usar con aplicaciones de software. Estos certificados aseguran que las credenciales de la compañia o individuo son válidos y no son fraudulentos. Si el certificado en cuestión no ha sido verificado por uno de las diversas "autoridades certificadoras" o CA, suele generarse una advertencia al respecto. Una autoridad de certificados es una compañia, como <a href=http://www.verisign.com>VeriSign</a>, que firma certificados para validar credenciales de individuos o compañias. Este proceso tiene un costo asociado y no es un requisito imprescindible para usar certificados, aunque puede darle un poco de tranquilidad a los usuarios más paranóicos.</p></div><div class=sect2><h3 id=_generación_de_certificados>14.9.1. Generación de certificados<a class=anchor href=#_generación_de_certificados></a></h3><div class=paragraph><p>Para generar un certificado ejecute lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.pem</span>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to <span class=s1>&#39;cert.pem&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:Mi compañía
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Administrador de sistemas
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.ejemplo.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:UNA CONTRASEÑA
An optional company name <span class=o>[]</span>:Otro nombre</code></pre></div></div><div class=paragraph><p>Tenga en cuenta que la respuesta directamente después de "prompt""Common Name" muestra un nombre de dominio. Este "prompt" requiere que se introduzca un nombre de servidor para usarlo en la verificación; si escribe cualquier otra cosa producirá un certificado inválido. Otras opciones, por ejemplo el tiempo de expiración, alternan algoritmos de cifrado, etc. Puede ver una lista completa en la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a>.</p></div><div class=paragraph><p>Debería tener dos ficheros en el directorio donde ha ejecutado la orden anterior. La petición de certificado, <span class=filename>req.pem</span>, es lo que debe enviar a una autoridad certificadora para que valide las credenciales que introdujo; firmará la petición y le devolverá el certificado. El segundo fichero es <span class=filename>cert.pem</span> y es la llave privada para el certificado, que debe proteger a toda costa; si cae en malas manos podrí usarse para suplantarle a usted o a sus servidores.</p></div><div class=paragraph><p>Si no necesita la firma de una CA puede crear y firmar usted mismo su certificado. Primero, genere la llave RSA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl dsaparam -rand -genkey -out myRSA.key 1024</span></code></pre></div></div><div class=paragraph><p>A continuación genere la llave CA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl gendsa -des3 -out myca.key myRSA.key</span></code></pre></div></div><div class=paragraph><p>Utilice esta llave para crear el certificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key myca.key -out new.crt</span></code></pre></div></div><div class=paragraph><p>Deberín aparecer dos nuevos ficheros en su directorio: un fichero de firma de autoridad de certificados (<span class=filename>myca.key</span>) y el certificado en sí, <span class=filename>new.crt</span>. Deben ubicarse en un directorio, que se recomienda que sea <span class=filename>/etc</span>, que es legible solo para <code>root</code>. Para terminar, es recomendable asignar permisos 0700 para el fichero con <code>chmod</code>.</p></div></div><div class=sect2><h3 id=_uso_de_certificados_un_ejemplo>14.9.2. Uso de certificados; un ejemplo<a class=anchor href=#_uso_de_certificados_un_ejemplo></a></h3><div class=paragraph><p>?Qué pueden hacer estos ficheros? Cifrar conexiones al MTASendmail es un buen sitio para usarlos. De este modo eliminará el uso de validación mediante texto en claro para los usuarios que envían correo a través del MTA local.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No es el mejor uso en el mundo, ya que algunos MUAs enviarán al usuario un mensaje de error si no tiene instalados localmente los certificados. Consulte la documentación para más datos sobre la instalación de certificados.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Debe añadir las siguientes líneas en su fichero local <span class=filename>.mc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dnl SSL Options
define(`confCACERT_PATH&#39;,`/etc/certs&#39;)dnl
define(`confCACERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_CERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_KEY&#39;,`/etc/certs/myca.key&#39;)dnl
define(`confTLS_SRV_OPTIONS&#39;, `V&#39;)dnl</pre></div></div><div class=paragraph><p><span class=filename>/etc/certs/</span> es el directorio destinado a almacenamiento de los ficheros de certificado y llave en local. El último requisito es una reconstrucción del fichero <span class=filename>.cf</span> local. Solo tiene que teclear <code>make</code><span class=parameter>install</span> en el directorio <span class=filename>/etc/mail</span>. A continuación ejecute un <code>make</code><span class=parameter>restart</span>, que debería reiniciar el dæmon Sendmail.</p></div><div class=paragraph><p>Si todo fué bien no habrá mensajes de error en el fichero <span class=filename>/var/log/maillog</span> y Sendmail aparecerá en la lista de procesos.</p></div><div class=paragraph><p>Puede probarlo todo de una forma muy sencilla; conéctese al servidor de correo mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet ejemplo.com 25</span>
Trying 192.0.34.166...
Connected to ejemplo.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 ejemplo.com ESMTP Sendmail 8.12.10/8.12.10<span class=p>;</span> Tue, 31 Aug 2004 03:41:22 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo ejemplo.com
250-ejemplo.com Hello ejemplo.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 ejemplo.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>Si la línea "STARTTLS" aparece en la salida, todo está funcionando correctamente.</p></div></div></div></div><div class=sect1><h2 id=ipsec>14.10. VPN sobre IPsec<a class=anchor href=#ipsec></a></h2><div class=sectionbody><div class=paragraph><p>Creación de una VPN entre dos redes, a través de Internet, mediante puertas de enlace ("gateways") FreeBSD.</p></div><div class=sect2><h3 id=_qué_es_ipsec>14.10.1. Qué es IPsec<a class=anchor href=#_qué_es_ipsec></a></h3><div class=paragraph><p>Esta sección le guiará a través del proceso de configuración de IPsec, y de su uso en un entorno consistente en máquinas FreeBSD y Microsoft® Windows® 2000/XP, para hacer que se comuniquen de manera segura. Para configurar IPsec es necesario que esté familiarizado con los conceptos de construcción de un kernel personalizado (consulte el <a href=../kernelconfig/#kernelconfig>Configuración del kernel de FreeBSD</a>).</p></div><div class=paragraph><p><em>IPsec</em> es un protocolo que está sobre la capa del protocolo de Internet (IP). Le permite a dos o más equipos comunicarse de forma segura (de ahí el nombre). La "pila de red" IPsec de FreeBSD se basa en la implementación <a href=http://www.kame.net/>KAME</a>, que incluye soporte para las dos familias de protocolos, IPv4 e IPv6.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X contiene una pila IPsec "acelerada por hardware", conocida como "Fast IPsec", que fué obtenida de OpenBSD. Emplea hardware criptográfico (cuando es posible) a través del subsistema <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=4&amp;format=html">crypto(4)</a> para optimizar el rendimiento de IPsec. Este subsistema es nuevo, y no soporta todas las opciones disponibles en la versión KAME de IPsec. Para poder habilitar IPsec acelerado por hardware debe añadir las siguientes opciones al fichero de configuración de su kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options	  FAST_IPSEC  <span class=c># new IPsec (cannot define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta que no es posible utilizar el subsistema "Fast IPsec" y la implementación KAME de IPsec en la misma computadora. Consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=fast_ipsec&amp;sektion=4&amp;format=html">fast_ipsec(4)</a> para más información.</p></div></td></tr></tbody></table></div><div class=paragraph><p>IPsec consta de dos sub-protocolos:</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>, que protege los datos del paquete IP de interferencias de terceros, cifrando el contenido utilizando algoritmos de criptografía simétrica (como Blowfish, 3DES).</p></li><li><p><em>Authentication Header (AH)</em>, que protege la cabecera del paquete IP de interferencias de terceros así como contra la falsificación ("spoofing"), calculando una suma de comprobación criptográfica y aplicando a los campos de cabecera IP una función hash segura. Detrás de todo esto va una cabecera adicional que contiene el hash para permitir la validación de la información que contiene el paquete.</p></li></ul></div><div class=paragraph><p>ESP y AH pueden utilizarse conjunta o separadamente, dependiendo del entorno.</p></div><div class=paragraph><p>IPsec puede utilizarse para cifrar directamente el tráfico entre dos equipos (conocido como <em>modo de transporte</em>) o para construir "túneles virtuales" entre dos subredes, que pueden usarse para comunicación segura entre dos redes corporativas (conocido como <em>modo de túnel</em>). Este último es muy conocido como una <em>red privada virtual (Virtual Private Network, o VPN)</em>. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> contiene información detallada sobre el subsistema IPsec de FreeBSD.</p></div><div class=paragraph><p>Si quiere añdir soporte IPsec a su kernel debe incluir las siguientes opciones al fichero de configuración de su kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        <span class=c>#IP security</span>
options   IPSEC_ESP    <span class=c>#IP security (crypto; define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Si quiere soporte para la depuración de errores no olvide la siguiente opción:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  <span class=c>#debug for IP security</span></code></pre></div></div></div><div class=sect2><h3 id=_el_problema>14.10.2. El Problema<a class=anchor href=#_el_problema></a></h3><div class=paragraph><p>No existe un estándar para lo que constituye una VPN. Las VPN pueden implementarse utilizando numerosas tecnologías diferentes, cada una de las cuales tiene sus pros y sus contras. Esta sección presenta un escenario, y las estrategias usadas para implementar una VPN para este escenario.</p></div></div><div class=sect2><h3 id=_el_escenario_dos_redes_conectadas_por_internet_que_queremos_que_se_comporten_como_una_sola>14.10.3. El escenario: dos redes, conectadas por Internet, que queremos que se comporten como una sola<a class=anchor href=#_el_escenario_dos_redes_conectadas_por_internet_que_queremos_que_se_comporten_como_una_sola></a></h3><div class=paragraph><p>Este es el punto de partida:</p></div><div class=ulist><ul><li><p>Usted tiene al menos dos sitios</p></li><li><p>Ambos sitios utilizan IP internamente</p></li><li><p>Ambos sitios están conectados a Internet, a través de una puerta de enlace FreeBSD.</p></li><li><p>La puerta de enlace de cada red tiene al menos una dirección IP pública.</p></li><li><p>Las direcciones internas de las dos redes pueden ser direcciones IP públicas o privadas, no importa. Puede ejecutar NAT en la máquina que hace de puerta de enlace si es necesario.</p></li><li><p>Las direcciones IP internas de las dos redes <em>no colisionan</em>. Aunque espero que sea teóricamente posible utilizar una combinación de tecnología VPN y NAT para hacer funcionar todo esto sospecho que configurarlo sería una pesadilla.</p></li></ul></div><div class=paragraph><p>Si lo que intenta es conectar dos redes y ambas usan el mismo rango de direcciones IP privadas (por ejemplo las dos usan <code>192.168.1.x</code>)debería renumerar una de las dos redes.</p></div><div class=paragraph><p>La topología de red se parecería a esto:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-network.png alt="ipsec network"></div></div><div class=paragraph><p>Observe las dos direcciones IP públicas. Usaré letras para referirme a ellas en el resto de este artículo. El cualquier lugar que vea esas letras en este artículo reemplácelas con su propia dirección IP pública. Observe también que internamente las dos máquinas que hacen de puerta de enlace tienen la dirección IP .1, y que las dos redes tienen direcciones IP privadas diferentes (<code>192.168.1.x</code> y <code>192.168.2.x</code> respectivamente). Todas las máquinas de las redes privadas están configuradas para utilizar la máquina <code>.1</code> como su puerta de enlace por defecto.</p></div><div class=paragraph><p>La intención es que, desde el punto de vista de la red, cada red debe ver las máquinas en la otra red como si estuvieran directamente conectadas al mismo router (aunque aunque sea un router ligeramente lento con una tendencia ocasional a tirar paquetes).</p></div><div class=paragraph><p>Esto significa que (por ejemplo), la máquina <code>192.168.1.20</code> debe ser capaz de ejecutar</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.34</pre></div></div><div class=paragraph><p>y recibir de forma transparente una respuesta. Las máquinas Windows® deben ser capaces de ver las máquinas de la otra red, acceder a sus ficheros compartidos, etc, exactamente igual que cuando acceden a las máquinas de la red local.</p></div><div class=paragraph><p>Y todo debe hacerse de forma segura. Esto significa que el tráfico entre las dos redes tiene que ser cifrado.</p></div><div class=paragraph><p>La creación de una VPN entre estas dos redes es un proceso que requiere varios pasos. Las etapas son estas:</p></div><div class="olist arabic"><ol class=arabic><li><p>Crear un enlace de red "virtual" entre las dos redes, a través de Internet. Probarlo usando herramientas como <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> para asegurarse de que funcione.</p></li><li><p>Aplicar políticas de seguridad para asegurarse de que el tráfico entre las dos redes sea cifrado y descifrado de forma transparente. Comprobarlo mediante herramientas como <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> para asegurarse de que el tráfico esté siendo efectivamente cifrado.</p></li><li><p>Configurar software adicional en las puertas de enlace FreeBSD para permitir a las máquinas Windows® verse entre ellas a través de la VPN.</p></li></ol></div><div class=sect3><h4 id=_paso_1_creación_y_prueba_de_un_enlace_de_red_virtual>14.10.3.1. Paso 1: Creación y prueba de un enlace de red "virtual"<a class=anchor href=#_paso_1_creación_y_prueba_de_un_enlace_de_red_virtual></a></h4><div class=paragraph><p>Suponga que está en la puerta de enlace de la red red #1 (con dirección IP pública <code>A.B.C.D</code>, dirección IP privada <code>192.168.1.1</code>), y ejecuta <code>ping 192.168.2.1</code>, que es la dirección privada de la máquina con dirección IP <code>W.X.Y.Z</code>. ?Qué hace falta para esto?</p></div><div class="olist arabic"><ol class=arabic><li><p>La puerta de enlace necesita saber cómo alcanzar a <code>192.168.2.1</code>. En otras palabras, necesita tener una ruta hasta <code>192.168.2.1</code>.</p></li><li><p>Las direcciones IP privadas, como las que están en el rango <code>192.168.x</code> no deberían aparecer en Internet. Por eso, cada paquete que mande a <code>192.168.2.1</code> necesitará encerrarse dentro de otro paquete. Este paquete debe tener todas las características de haber sido enviado desde <code>A.B.C.D</code>, y tendrá que ser enviado a <code>W.X.Y.Z</code>. Este proceso recibe el nombre de <em>encapsulado</em>.</p></li><li><p>Una vez que este paquete llega a <code>W.X.Y.Z</code> necesitará ser "desencapsulado", y entregado a <code>192.168.2.1</code>.</p></li></ol></div><div class=paragraph><p>Puede verlo como si necesitara un "túnel" entre las dos redes. Las dos "bocas del túnel" son las direcciones IP <code>A.B.C.D</code> y <code>W.X.Y.Z</code>, y debe hacer que el túnel sepa cuáles serán las direcciones IP privadas que tendrán permitido el paso a través de él. El túnel se usa para transferir tráfico con direcciones IP privadas a través de la Internet pública.</p></div><div class=paragraph><p>Este túnel se crea mediante la interfaz genérica, o dispositivo <span class=filename>gif</span> en FreeBSD. Como puede imaginarse la interfaz <span class=filename>gif</span> de cada puerta de enlace debe configurarse con cuatro direcciones IP: dos para las direcciones IP públicas, y dos para las direcciones IP privadas.</p></div><div class=paragraph><p>El soporte para el dispositivo gif debe compilarse en el kernel de FreeBSD en ambas máquinas añadiendo la línea</p></div><div class="literalblock programlisting"><div class=content><pre>device gif</pre></div></div><div class=paragraph><p>a los ficheros de configuración del kernel de ambas máquinas, compilarlo, instalarlo y reiniciar.</p></div><div class=paragraph><p>La configuración del túnel es un proceso que consta de dos partes. Primero se le debe decir al túnel cuáles son las direcciones IP exteriores (o públicas) mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a>. Después configure las direcciones IP con <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD 5.X las funciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a> se han incluido en <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En la puerta de enlace de la red #1 debe ejecutar las siguientes dos órdenes para configurar el túnel.</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff</pre></div></div><div class=paragraph><p>En la otra puerta de enlace ejecute las mismas órdenes, pero con el orden las direcciones IP invertido.</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff</pre></div></div><div class=paragraph><p>Ahora ejecute:</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig gif0</pre></div></div><div class=paragraph><p>y podrá ver la configuración. Por ejemplo, en la puerta de enlace de la red #1 vería algo parecido a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 <span class=nt>--</span><span class=o>&gt;</span> 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D <span class=nt>--</span><span class=o>&gt;</span> W.X.Y.Z</code></pre></div></div><div class=paragraph><p>Como puede ver se ha creado un túnel entre las direcciones físicas <code>A.B.C.D</code> y <code>W.X.Y.Z</code>, y el tráfico que puede pasar a través del túnel es entre <code>192.168.1.1</code> y <code>192.168.2.1</code>.</p></div><div class=paragraph><p>Esto también habrá agregado una entrada en la tabla de rutas de ambas máquinas, que puede examinar con <code>netstat -rn</code>. Esta salida es de la puerta de enlace de la red #1.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -rn</span>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...</code></pre></div></div><div class=paragraph><p>Como el valor de "Flags" lo indica, esta es una ruta de equipo, lo que significa que cada puerta de enlace sabe como alcanzar la otra puerta de enlace, pero no saben cómo llegar al resto de sus respectivas redes. Ese problema se solucionará en breve.</p></div><div class=paragraph><p>Es posible que disponga de un cortafuegos en ambas máquinas, por lo que tendrá que buscar la forma de que el tráfico de la VPN pueda entrar y salir limpiamente. Puede permitir todo el tráfico de ambas redes, o puede que quiera incluir reglas en el cortafuegos para que protejan ambos extremos de la VPN uno del otro.</p></div><div class=paragraph><p>Las pruebas se simplifican enormemente si configura el cortafuegos para permitir todo el tráfico a través de la VPN. Siempre puede ajustar las cosas después. Si utiliza <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> en las puertas de enlace una orden similar a</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div><div class=paragraph><p>permitirá todo el tráfico entre los dos extremos de la VPN, sin afectar al resto de reglas del cortafuegos. Obviamente tendrá que ejecutar esta orden en ambas puertas de enlace.</p></div><div class=paragraph><p>Esto es suficiente para permitir a cada puerta de enlace hacer un ping entre ellas. En <code>192.168.1.1</code> deberí poder ejecutar</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>y obtener una respuesta; es obvio que debería poder hacer los mismo en la otra puerte de enlace.</p></div><div class=paragraph><p>Aún no podrá acceder a las máquinas internas de las redes. El problema está en el encaminamiento: aunque las puertas de enlace saben cómo alcanzarse mútuamente no saben cómo llegar a la red que hay detrás de la otra.</p></div><div class=paragraph><p>Para resolver este problema debe añadir una ruta estática en cada puerta de enlace. La orden en la primera puerta de enlace podría ser:</p></div><div class="literalblock programlisting"><div class=content><pre>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00</pre></div></div><div class=paragraph><p>Esto significa "Para alcanzar los equipos en la red <code>192.168.2.0</code>, envía los paquetes al equipo <code>192.168.2.1</code>". Necesitará ejecutar una orden similar en la otra puerta de enlace, pero obviamente con las direcciones <code>192.168.1.x</code>.</p></div><div class=paragraph><p>El tráfico IP de equipos en una red no será capaz de alcanzar equipos en la otra red.</p></div><div class=paragraph><p>Ya tiene dos tercios de una VPN, puesto que ya es "virtual" y es una "red". Todavía no es privada. Puede comprobarlo con <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. Abra una sesión en la puerta de enlace y ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>En otra sesión en el mismo equipo ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>Verá algo muy parecido a esto:</p></div><div class="literalblock programlisting"><div class=content><pre>16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply</pre></div></div><div class=paragraph><p>Como puede ver los mensajes ICMP van y vienen sin cifrar. Si usa el parámetro <code>-s</code> en <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> para tomar más bytes de datos de estos paquetes verá más información.</p></div><div class=paragraph><p>Obviamente esto es inaceptable. La siguiente sección explicará cómo asegurar el enlace entre las dos redes para que todo el tráfico se cifre automáticamente.</p></div><div class=ulist><div class=title>Sumario:</div><ul><li><p>Configure ambos kernel con "pseudo-device gif".</p></li><li><p>Edite <span class=filename>/etc/rc.conf</span> en la puerta de enlace #1 y añada las siguientes líneas (reemplazando las direcciones IP según sea necesario).</p><div class="literalblock programlisting"><div class=content><pre>gifconfig_gif0=&#34;A.B.C.D W.X.Y.Z&#34;
ifconfig_gif0=&#34;inet 192.168.1.1 192.168.2.1 netmask 0xffffffff&#34;
static_routes=&#34;vpn&#34;
route_vpn=&#34;192.168.2.0 192.168.2.1 netmask 0xffffff00&#34;</pre></div></div></li><li><p>Edite la configuración de su cortafuegos (<span class=filename>/etc/rc.firewall</span>, o lo que corresponda) en ambos equipos y añada</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div></li><li><p>Haga los cambios oportunos en el <span class=filename>/etc/rc.conf</span> de la puerta de enlace #2, invirtiendo el orden de las direcciones IP.</p></li></ul></div></div><div class=sect3><h4 id=_paso_2_asegurar_el_enlace>14.10.3.2. Paso 2: Asegurar el enlace<a class=anchor href=#_paso_2_asegurar_el_enlace></a></h4><div class=paragraph><p>Para asegurar el enlace usaremos IPsec. IPsec ofrece un mecanismo para que dos equipos coincidan en una llave de cifrado, y usar esta llave para cifrar los datos entre los dos equipos.</p></div><div class=paragraph><p>Existen dos áreas de configuración a tener en cuenta:</p></div><div class="olist arabic"><ol class=arabic><li><p>Debe existir un mecanismo para que los dos equipos se pongan de acuerdo en el mecanismo de cifrado que van a utilizar. Una vez que los dos equipos se han puesto de acuerdo dice que existe una "asociación de seguridad" entre ellos.</p></li><li><p>Debe existir un mecanismo para especificar que tráfico debe ser cifrado. Obviamente, usted no querrá cifrar todo su tráfico saliente: solo querrá cifrar el tráfico que es parte de la VPN. Las reglas con las que determinará qué tráfico será cifrado se llaman "políticas de seguridad".</p></li></ol></div><div class=paragraph><p>Tanto las asociaciones de seguridad como las políticas de seguridad son responsabilidad del kernel, pero pueden ser modificadas desde el espacio de usuario. Antes de poder hacerlo, tendrá que configurar el kernel para que incluya IPsec y el protocolo ESP (Encapsulated Security Payload). Incluya en el fichero de configuración de su kernel lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div><div class=paragraph><p>Recompile y resintale su kernel y reinicie. Como se dijo anteriormente, tendrá que hacer lo mismo en el kernel de las dos puertas de enlace.</p></div><div class=paragraph><p>Tiene dos opciones cuando se trata de configurar asociaciones de seguridad. Puede configurarlas a mano en los dos equipos, lo que significa elegir el algoritmo de cifrado, las llaves de cifrado, etc, o puede utilizar alguno de los dæmons que implementan el protocolo de intercambio de llaves de Internet (IKE, Internet Key Exchange).</p></div><div class=paragraph><p>Le recomiendo la segunda opción. Aparte de otras consideraciones es más fácil de configurar.</p></div><div class=paragraph><p>La edición y despliegue se efectúa con <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Todo esto se entiende mejor con una analogía. <code>setkey</code> es a las tablas de políticas de seguridad del kernel lo que <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> es a las tablas de rutas del kernel. También puede usar <code>setkey</code> ver las asociaciones de seguridad en vigor, siguiendo con la analogía, igual que puede usar <code>netstat -r</code>.</p></div><div class=paragraph><p>Existen numerosos dæmons que pueden encargarse de la gestión de asociaciones de seguridad en FreeBSD. En este texto se muestra cómo usar uno de ellos, racoon (que puede instalar desde <a class=package href=https://cgit.freebsd.org/ports/tree/security/racoon/>security/racoon</a> en la colección de ports de FreeBSD.</p></div><div class=paragraph><p>El software <a class=package href=https://cgit.freebsd.org/ports/tree/security/racoon/>security/racoon</a> debe ejecutarse en las dos puertas de enlace. En cada equipo debe configurar la dirección IP del otro extremo de la VPN y una llave secreta (que usted puede y debe elegir, y debe ser la misma en ambas puertas de enlace).</p></div><div class=paragraph><p>Los dos dæmons entran en contacto uno con otro, y confirman que son quienes dicen ser (utilizando la llave secreta que usted configuró). Los dæmons generan una nueva llave secreta, y la utilizan para cifrar el tráfico que discurre a través de la VPN. Periódicamente cambian esta llave, para que incluso si un atacante comprometiera una de las llaves (lo cual es teóricamente cercano a imposible) no le serviriía de mucho: para cuando el atacante haya "crackeado" la llave los dæmons ya habrán escogido una nueva.</p></div><div class=paragraph><p>El fichero de configuración de racoon está en <span class=filename>${PREFIX}/etc/racoon</span>. No debería tener que hacer demasiados cambios a ese fichero. El otro componente de la configuración de racoon (que <em>sí</em> tendrá que modificar) es la "llave pre-compartida".</p></div><div class=paragraph><p>La configuración por defecto de racoon espera encontrarla en <span class=filename>${PREFIX}/etc/racoon/psk.txt</span>. Es importante saber que la llave precompartida <em>no</em> es la llave que se utilizará para cifrar el tráfico a través del enlace VPN; solamente es una muestra que permite a los dæmons que administran las llaves confiar el uno en el otro.</p></div><div class=paragraph><p><span class=filename>psk.txt</span> contiene una línea por cada sitio remoto con el que esté tratando. En nuestro ejemplo, donde existen dos sitios, cada fichero <span class=filename>psk.txt</span> contendrá una línea (porque cada extremo de la VPN solo está tratando con un sitio en el otro extremo).</p></div><div class=paragraph><p>En la puerta de enlace #1 esta línea debería parecerse a esta:</p></div><div class="literalblock programlisting"><div class=content><pre>W.X.Y.Z            secreto</pre></div></div><div class=paragraph><p>Esto es, la dirección IP <em>pública</em> del extremo remoto, un espacio en blanco, y una cadena de texto que es el secreto en sí. en el extremo remoto, espacio en blanco, y un texto de cadena que proporcina el secreto. Obviamente, no debe utilizar "secret" como su llave; aplique aquí las reglas y recomendaciones habituales para la elección de contraseñas.</p></div><div class=paragraph><p>En la puerta de enlace #2 la línea se parecería a esta</p></div><div class="literalblock programlisting"><div class=content><pre>A.B.C.D            secreto</pre></div></div><div class=paragraph><p>Esto es, la dirección IP pública del extremo remoto, y la misma llave secreta. <span class=filename>psk.txt</span> debe tener modo <code>0600</code> (es decir, modo de solo lectura/escritura para <code>root</code>) antes de que ejecute racoon.</p></div><div class=paragraph><p>Debe ejecutar racoon en ambas puertas de enlace. También tendrá que añadir algunas reglas a su cortafuegos para permitir el tráfico IKE, que se transporta sobre UDP al puerto ISAKMP (Internet Security Association Key Management Protocol). Esto debe estar al principio de las reglas de su cortafuegos.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp</pre></div></div><div class=paragraph><p>Una vez que ejecute racoon puede tratar de hacer un ping a una puerta de enlace desde la otra. La conexión todavía no está cifrada porque aún no se han creado las asociaciones de seguridad entre los dos equipos: esto puede llevar un poco de tiempo; es posible que advierta un pequeño retraso antes de los ping empiecen responder.</p></div><div class=paragraph><p>Una vez creadas las asociaciones de seguridad puede verlas utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>setkey -D</pre></div></div><div class=paragraph><p>en cualquiera de los equipos para comprobar la información de la asociación de seguridad.</p></div><div class=paragraph><p>Ya está resuelta la mitad del problema. La otra mitad es configurar sus políticas de seguridad.</p></div><div class=paragraph><p>Queremos crear una política de seguridad sensata, así que vamos a revisar lo que tenemos configurado hasta el momento. Esta revisión abarca ambos extremos del enlace.</p></div><div class=paragraph><p>Cada paquete IP que usted manda tiene una cabecera que contiene datos acerca del paquete. La cabecera incluye la dirección IP de destino y del origen. Como ya sabemos, las direcciones IP privadas como el rango <code>192.168.x.y</code> no deberían aparezcan en Internet. Dado que es a través de Internet por donde los queremos transmitir los debemos encapsular dentro de otro paquete. Este paquete debe contener tanto la dirección IP de destino y origen públicas sustituidas por las direcciones privadas.</p></div><div class=paragraph><p>Así que si su paquete saliente empezó pareciendose a este:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-out-pkt.png alt="ipsec out pkt"></div></div><div class=paragraph><p>tras el encapsulado se parecerá bastante a este:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-encap-pkt.png alt="ipsec encap pkt"></div></div><div class=paragraph><p>El dispositivo <span class=filename>gif</span> se encarga del encapsulado. Como puede ver el paquete tiene una dirección IP real en el exterior, y nuestro paquete original ha sido envuelto como dato dentro del paquete que enviaremos a través de Internet.</p></div><div class=paragraph><p>Obviamente, queremos que todo el tráfico entre las VPN vaya cifrado. Pongamos esto último en palabras para comprenderlo mejor:</p></div><div class=paragraph><p>"Si un paquete sale desde <code>A.B.C.D</code>, y tiene como destino <code>W.X.Y.Z</code>, cífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>"Si un paquete llega desde <code>W.X.Y.Z</code>, y tiene como destino <code>A.B.C.D</code>, descífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>Este planteamiento se aproxima bastante, pero no es exactamente lo que queremos hacer. Si lo hiciera así todo el tráfico desde y hacia <code>W.X.Y.Z</code>, incluso el tráfico que no forma parte de la VPN, será cifrado; esto no es lo que queremos. La política correcta es la siguiente:</p></div><div class=paragraph><p>"Si un paquete sale desde <code>A.B.C.D</code>, y está encapsulando a otro paquete, y tiene como destino <code>W.X.Y.Z</code>, cífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>"Si un paquete llega desde <code>W.X.Y.Z</code>, y está encapsulando a otro paquete, y tiene como destino <code>A.B.C.D</code>, descífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>Un cambio sutil, pero necesario.</p></div><div class=paragraph><p>Las políticas de seguridad también se imponen utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> proporciona un lenguaje de configuración para definir la política. Puede introducir las instrucciones de configuración a través de la entrada estándar (stdin), o puede usar la opción <code>-f</code> para especificar un fichero que contenga las instrucciones de configuración.</p></div><div class=paragraph><p>La configuración en la puerta de enlace #1 (que tiene la dirección IP pública <code>A.B.C.D</code>) para forzar que todo el tráfico saliente hacia <code>W.X.Y.Z</code> vaya cifrado es:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Ponga estas órdenes en un fichero (por ejemplo <span class=filename>/etc/ipsec.conf</span>) y ejecute</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -f /etc/ipsec.conf</span></code></pre></div></div><div class=paragraph><p><code>spdadd</code> le dice a <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> que queremos añadir una regla a la base de datos de políticas de seguridad. El resto de la línea especifica qué paquetes se ajustarán a esta política. <code>A.B.C.D/32</code> y <code>W.X.Y.Z/32</code> son las direcciones IP y máscaras de red que identifican la red o equipos a los que se aplicará esta política. En nuestro caso queremos aplicarla al tráfico entre estos dos equipos. <code>-P out</code> dice que esta política se aplica a paquetes salientes, e <code>ipsec</code> hace que el paquete sea asegurado.</p></div><div class=paragraph><p>La segunda línea especifica cómo será cifrado este paquete. <code>esp</code> es el protocolo que se utilizará, mientras que <code>tunnel</code> indica que el paquete será después encapsulado en un paquete IPsec. El uso repetido de <code>A.B.C.D</code> y <code>W.X.Y.Z</code> se utiliza para seleccionar la asociación de seguridad a usar, y por último <code>require</code> exige que los paquetes deben cifrarse si concuerdan con esta regla.</p></div><div class=paragraph><p>Esta regla solo concuerda con paquetes salientes. Necesitará una regla similar para los paquetes entrantes.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>Observe el <code>in</code> en lugar del <code>out</code> en este caso, y la inversión necesaria de las direcciones IP.</p></div><div class=paragraph><p>La otra puerta de enlace (que tiene la dirección IP pública <code>W.X.Y.Z</code>) necesitará reglas similares.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Finalmente, necesita añadir reglas a su cortafuegos para permitir la circulación de paquetes ESP e IPENCAP de ida y vuelta. Tendrá que añadir reglas como estas a ambos equipos.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div><div class=paragraph><p>Debido a que las reglas son simétricas puede utilizar las mismas reglas en ambas puertas de enlace.</p></div><div class=paragraph><p>Los paquetes salientes tendrán ahora este aspecto:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-crypt-pkt.png alt="ipsec crypt pkt"></div></div><div class=paragraph><p>Cuando los paquetes llegan al otro extremo de la VPN serán descifrados (utilizando las asociaciones de seguridad que han sido negociadas por racoon). Después entrarán al interfaz <span class=filename>gif</span>, que desenvuelve la segunda capa, hasta que nos quedamos con paquete má interno, que puede entonces viajar a la red interna.</p></div><div class=paragraph><p>Puede revisar la seguridad utilizando la misma prueba de <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> anterior. Primero, inicie una sesión en la puerta de enlace <code>A.B.C.D</code>, y ejecute:</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>En otra sesión en la misma máquina ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>Debería ver algo similar a lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>XXX tcpdump output</pre></div></div><div class=paragraph><p>ahora, como puede ver, <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> muestra los paquetes ESP. Si trata de examinarlos con la opción <code>-s</code> verá basura (aparentemente), debido al cifrado.</p></div><div class=paragraph><p>Felicidades. Acaba de configurar una VPN entre dos sitios remotos.</p></div><div class=ulist><div class=title>Sumario</div><ul><li><p>Configure ambos kernel con:</p><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div></li><li><p>Instale <a class=package href=https://cgit.freebsd.org/ports/tree/security/racoon/>security/racoon</a>. Edite <span class=filename>${PREFIX}/etc/racoon/psk.txt</span> en ambas puertas de enlace añadiendo una entrada para la dirección IP del equipo remoto y una llave secreta que ambos conozcan. Asegúrese de que este fichero esté en modo 0600.</p></li><li><p>Añada las siguientes líneas a <span class=filename>/etc/rc.conf</span> en ambos equipos:</p><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_file=&#34;/etc/ipsec.conf&#34;</pre></div></div></li><li><p>Crée en ambos equipos un <span class=filename>/etc/ipsec.conf</span> que contenga las líneas spdadd necesarias. En la puerta de enlace #1 sería:</p><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>En la puerta de enlace #2 sería:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div></li><li><p>Añada a su(s) cortafuegos las reglas necesarias para que permita(n) el paso de tráfico IKE, ESP e IPENCAP en ambos equipos:</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div></li></ul></div><div class=paragraph><p>Los dos pasos previos deben bastar para levantar la VPN. Las máquinas en cada red seán capaces de dirigirse una a otra utilizando direcciones IP, y todo el tráfico a través del enlace será cifrado de forma automática y segura.</p></div></div></div></div></div><div class=sect1><h2 id=openssh>14.11. OpenSSH<a class=anchor href=#openssh></a></h2><div class=sectionbody><div class=paragraph><p>OpenSSH es un conjunto de herramientas de conectividad que se usan para acceder a sistemas remotos de forma segura. Puede usarse como sustituto directo de <code>rlogin</code>, <code>rsh</code>, <code>rcp</code> y <code>telnet</code>. Además cualquier otra conexión TCP/IP puede reenviarse o enviarse a través de un túnel a través de SSH. OpenSSH cifra todo el tráfico para eliminar de forma efectiva el espionaje, el secuestro de conexiones, y otros ataques en la capa de red.</p></div><div class=paragraph><p>OpenSSH está a cargo del proyecto OpenBSD, y está basado en SSH v1.2.12, con todos los errores recientes corregidos y todas las actualizaciones correspondientes. Es compatible con los protocolos SSH 1 y 2. OpenSSH forma parte del sistema base desde FreeBSD 4.0.</p></div><div class=sect2><h3 id=_ventajas_de_utilizar_openssh>14.11.1. Ventajas de utilizar OpenSSH<a class=anchor href=#_ventajas_de_utilizar_openssh></a></h3><div class=paragraph><p>Normalmente, al utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> los datos se envían a través de la red en limpio, es decir, sin cifrar. Cualquier "sniffer" de red entre el cliente y el servidor puede robar la información de usuario/contraseña o los datos transferidos durante su sesión. OpenSSH ofrece diversos métodos de validación y cifrado para evitar que sucedan estas cosas.</p></div></div><div class=sect2><h3 id=_habilitar_sshd>14.11.2. Habilitar sshd<a class=anchor href=#_habilitar_sshd></a></h3><div class=paragraph><p>El dæmon sshd está habilitado por defecto FreeBSD 4.X y puede elegir habilitarlo o no durante la instalación en FreeBSD 5.X. Si quiere saber si está habilitado revise si la siguiente línea está en <span class=filename>rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Esta línea cargará <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, el programa dæmon de OpenSSH, en el arranque de su sistema. Puede ejecutar el dæmon sshd tecleando <code>sshd</code> en la línea de órdenes.</p></div></div><div class=sect2><h3 id=_cliente_ssh>14.11.3. Cliente SSH<a class=anchor href=#_cliente_ssh></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> funciona de manera similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
Host key not found from the list of known hosts.
Are you sure you want to <span class=k>continue </span>connecting <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>? <span class=nb>yes
</span>Host <span class=s1>&#39;ejemplo.com&#39;</span> added to the list of known hosts.
usuario@ejemplo.com<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>El login continuará como lo haría si fuera una sesión de <code>rlogin</code> o <code>telnet</code>. SSH utiliza un sistema de huellas de llaves para verificar la autenticidad del servidor cuando el cliente se conecta. Se le pide al usuario que introduzca <code>yes</code> solamente la primera vez que se conecta. Todos los intentos futuros de login se verifican contra la huella de la llave guardada la primera vez. El cliente SSH le alertará si la huella guardada difiere de la huella recibida en futuros intentos de acceso al sistema. Las huellas se guardan en <span class=filename>~/.ssh/known_hosts</span>, y en <span class=filename>~/.ssh/known_hosts2</span> las huellas SSH v2.</p></div><div class=paragraph><p>Por defecto las versiones recientes de los servidores OpenSSH solamente aceptan conexiones SSH v2. El cliente utilizará la versión 2 si es posible y pasará como respaldo a la versión 1. El cliente puede también ser obligado a utilizar una u otra pasándole <code>-1</code> o <code>-2</code>, respectivamente para la versión 1 y la versión 2. Se mantiene la compatibilidad del cliente con la versión 1 para mantener la compatibilidad con versiones antiguas.</p></div></div><div class=sect2><h3 id=_copia_segura>14.11.4. Copia segura<a class=anchor href=#_copia_segura></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> funciona de manera muy similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>; copia un fichero desde o hacia un sistema remoto, con la diferencia de que lo hace de una forma segura.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp usuario@ejemplo.com:/COPYRIGHT COPYRIGHT</span>
usuario@ejemplo.com<span class=s1>&#39;s password: *******
COPYRIGHT            100% |*****************************|  4735
00:00
#</span></code></pre></div></div><div class=paragraph><p>Ya que la huella se guardó en este equipo durante el ejemplo anterior se verifica ahora al utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>.</p></div><div class=paragraph><p>Los argumentos de <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> son similares a <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a>, con el fichero o ficheros como primer argumento, y el destino como segundo. Ya que el fichero se transfiere a través de la red, a través de SSH, uno o más argumentos tienen la estructura <code>user@host:&lt;ruta_al_fichero_remoto></code>.</p></div></div><div class=sect2><h3 id=_configuración>14.11.5. Configuración<a class=anchor href=#_configuración></a></h3><div class=paragraph><p>Los ficheros de configuración del sistema tanto para el dæmon OpenSSH como para el cliente están en <span class=filename>/etc/ssh</span>.</p></div><div class=paragraph><p><span class=filename>ssh_config</span> contiene las opciones del cliente, mientras que <span class=filename>sshd_config</span> configura el dæmon.</p></div><div class=paragraph><p>Además las opciones <code>sshd_program</code> (<span class=filename>/usr/sbin/sshd</span> por defecto), y <code>sshd_flags</code> de <span class=filename>rc.conf</span> ofrecer más niveles de configuración.</p></div></div><div class=sect2><h3 id=security-ssh-keygen>14.11.6. ssh-keygen<a class=anchor href=#security-ssh-keygen></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> le permite validar a un usuario sin pedirle la contraseña:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> dsa
Generating public/private dsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>:
Created directory <span class=s1>&#39;/home/user/.ssh&#39;</span><span class=nb>.</span>
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:
Enter same passphrase again:
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 usuario@host.ejemplo.com</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> creará un par de llaves pública y privada para usar en la validación. La llave privada se guarda en <span class=filename>~/.ssh/id_dsa</span> o en <span class=filename>~/.ssh/id_rsa</span>, mientras que la llave pública se guarda en <span class=filename>~/.ssh/id_dsa.pub</span> o en <span class=filename>~/.ssh/id_rsa.pub</span>, respectivamente para llaves DSA y RSA. La llave pública debe guardarse en el <span class=filename>~/.ssh/authorized_keys</span> de la máquina remota para que la configuración funcione. Las llaves RSA versión 1 deben guardarse en <span class=filename>~/.ssh/authorized_keys</span>.</p></div><div class=paragraph><p>De este modo permitirá conexiones a la máquina remota mediante llaves SSH en lugar de contraseñas.</p></div><div class=paragraph><p>Si usa una contraseña al ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>, se le pedirá al usuario una contraseña cada vez que quiera utilizar la llave privada. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> puede evitar la molestia de introducir repetidamente frases largas. esto se explica má adelante, en la <a href=#security-ssh-agent>ssh-agent y ssh-add</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Las opciones y ficheros pueden ser diferentes según la versión de OpenSSH que tenga en su sistema; para evitar problemas consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=security-ssh-agent>14.11.7. ssh-agent y ssh-add<a class=anchor href=#security-ssh-agent></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> ofrecen métodos para que las llaves SSH se puedan cargar en memoria, permitiendo eliminar la necesidad de teclear la contraseña cada vez que haga falta.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> gestionará la validación utilizando la llave (o llaves) privada que le cargue. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> se usa para lanzar otras aplicaciones. En el nivel más básico puede generar una shell o a un nivel más avanzado un gestor de ventanas.</p></div><div class=paragraph><p>Para usar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> en una shell necesitará primero ser invocado como argumento por una shell. Segundo, añada la identidad ejecutando <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> y facilitando la contraseña de la llave privada. Completados estos pasos el usuario puede hacer <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> a cualquier equipo que tenga instalada la llave pública correspondiente. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for</span> /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>
%</code></pre></div></div><div class=paragraph><p>Para utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> en X11 tendrá que incluir una llamada a <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> en <span class=filename>~/.xinitrc</span>. De este modo ofrecerá los servicios de <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> a todos los programas lanzados en X11. Veamos un ejemplo de <span class=filename>~/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>Esto lanzaría <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, que a su vez lanzaría XFCE cada vez que inicie X11. Hecho esto y una vez reiniciado X11 para aplicar los cambios puede ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> para cargar todas sus llaves SSH.</p></div></div><div class=sect2><h3 id=security-ssh-tunneling>14.11.8. Túneles SSH<a class=anchor href=#security-ssh-tunneling></a></h3><div class=paragraph><p>OpenSSH permite crear un túnel en el que encapsular otro protocolo en una sesión cifrada.</p></div><div class=paragraph><p>La siguiente orden le dice a <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> que cree un túnel para telnet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 usuario@foo.ejemplo.com
%</code></pre></div></div><div class=paragraph><p>Veamos las opciones que se le han suministrado a <code>ssh</code>:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Obliga a <code>ssh</code> a utilizar la versión 2 del protocolo. (No la use si está trabajando con servidores SSH antiguos)</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>Indica que no se ejecutará una orden remota, o solamente túnel. Si se omite, <code>ssh</code> iniciaría una sesión normal.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Obliga a <code>ssh</code> a ejecutarse en segundo plano.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Indica un túnel local según el esquema <em>puerto local:equipo remoto:puerto remoto</em>.</p></dd><dt class=hdlist1><code>usuario@foo.ejemplo.com</code></dt><dd><p>El servidor SSH remoto.</p></dd></dl></div><div class=paragraph><p>Un túnel SSH crea un socket que escucha en <code>localhost</code> en el puerto especificado. Luego reenvía cualquier conexión recibida en el puerto/equipo local vía la conexión SSH al puerto o equipo remoto especificado.</p></div><div class=paragraph><p>En el ejemplo el puerto <em>5023</em> en <code>localhost</code> se reenvía al puerto <em>23</em> del <code>localhost</code> de la máquina remota. Ya que <em>23</em> es telnet, esto crearía una sesión telnet segura a través de un túnel SSH.</p></div><div class=paragraph><p>Puede usar esto para encapsular cualquier otro protocolo TCP inseguro como SMTP, POP3, FTP, etc.</p></div><div class=exampleblock><div class=title>Ejemplo 1. Uso de SSH para crear un túnel seguro para SMTP</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 usuario@correo.ejemplo.com
usuario@correo.ejemplo.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 correo.ejemplo.com ESMTP</span></code></pre></div></div><div class=paragraph><p>Puede usar esta técnica junto con <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> y cuentas adicionales de usuario para crear un entorno más transparente, esto es, más cómodo. Puede usar llaves en lugar de teclear contraseñas y puede ejecutar los túneles de varios usuarios.</p></div></div></div><div class=sect3><h4 id=_ejemplos_prácticos_de_túneles_ssh>14.11.8.1. Ejemplos prácticos de túneles SSH<a class=anchor href=#_ejemplos_prácticos_de_túneles_ssh></a></h4><div class=sect4><h5 id=_acceso_seguro_a_un_servidor_pop3>14.11.8.1.1. Acceso seguro a un servidor POP3<a class=anchor href=#_acceso_seguro_a_un_servidor_pop3></a></h5><div class=paragraph><p>En el trabajo hay un servidor SSH que acepta conexiones desde el exterior. En la misma red de la oficina reside un servidor de correo que ejecuta un servidor POP3. La red, o ruta de red entre su casa y oficina puede o no ser completamente de fiar. Debido a esto necesita revisar su correo electrónico de forma segura. La solución es crear una conexión SSH al servidor SSH de su oficina y llegar por un túnel al servidor de correo.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:correo.ejemplo.com:110 usuario@servidor-ssh.ejemplo.com
usuario@servidor-ssh.ejemplo.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>cuando el túnel esté funcionando haga que su cliente de correo envíe peticiones POP3 a <code>localhost</code> en el puerto 2110. La conexión será reenviada de forma totalmente segura a traveés del túnel a <code>correo.ejemplo.com</code>.</p></div></div><div class=sect4><h5 id=_saltarse_un_cortafuegos_draconiano>14.11.8.1.2. Saltarse un cortafuegos draconiano<a class=anchor href=#_saltarse_un_cortafuegos_draconiano></a></h5><div class=paragraph><p>Algunos administradores de red imponen reglas de cortafuegos extremadamente draconianas, filtrando no solo las conexiones entrantes, sino también las salientes. Tal vez solo se le otorgue acceso a máquinas remotas a través de los puertos 22 y 80 para ssh y navegar en web.</p></div><div class=paragraph><p>Tal vez quiera acceder a otros servicios (que tal vez ni siquiera estén relacionados con el trabajo), como un servidor Ogg Vorbis para escuchar música. Si ese servidor Ogg Vorbis transmite en un puerto que no sea el 22 o el 80 no podrá tener acceso a él.</p></div><div class=paragraph><p>La solución es crear una conexión SSH fuera del cortafuegos de su red y utilizarla para hacer un túnel al servidor Ogg Vorbis.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:musica.ejemplo.com:8000 usuario@sistema-no-filtrado.ejemplo.org
usuario@sistema-no-filtrado.ejemplo.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Haga que el programa con el que suele escuchar música haga peticiones a <code>localhost</code> puerto 8888, que será reenviado a <code>musica.ejemplo.com</code> puerto 8000, evadiendo con éxito el cortafuegos.</p></div></div></div></div><div class=sect2><h3 id=_la_opción_de_usuarios_allowusers>14.11.9. La opción de usuarios <code>AllowUsers</code><a class=anchor href=#_la_opción_de_usuarios_allowusers></a></h3><div class=paragraph><p>Limitar qué usuarios pueden entrar y desde dónde suele ser razonable. La opción <code>AllowUsers</code> le permite configurarlo, por ejemplo, para permitir entrar solamente al usuario <code>root</code> desde <code>192.168.1.32</code>. Puede hacerlo con algo parecido a esto en <span class=filename>/etc/ssh/sshd_config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>Para permitir al usuario <code>admin</code> la entrada desde cualquier lugar, solamente introduzca el nombre de usuario:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>Puede listar múltiples usuarios en la misma línea:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es importante que incluya a cada usuario que necesite entrar a esta máquina o no podrán entrar.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Después de hacer los cambios a b <span class=filename>/etc/ssh/sshd_config</span> debe decirle a <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> que cargue de nuevo sus ficheros de configuración ejecutando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd reload</span></code></pre></div></div></div><div class=sect2><h3 id=_lecturas_complementarias>14.11.10. Lecturas complementarias<a class=anchor href=#_lecturas_complementarias></a></h3><div class=paragraph><p><a href=http://www.openssh.com/>OpenSSH</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp-server&amp;sektion=8&amp;format=html">sftp-server(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a></p></div></div></div></div><div class=sect1><h2 id=fs-acl>14.12. Listas de control de acceso a sistemas de ficheros<a class=anchor href=#fs-acl></a></h2><div class=sectionbody><div class=paragraph><p>Además de otras mejoras del sistema de ficheros como las instantáneas ("snapshots"), FreeBSD 5.0 y siguientes ofrecen las ACL ("Access Control Lists", listas de control de acceso) como un elemento más de seguridad.</p></div><div class=paragraph><p>Las listas de control de acceso extienden el modelo de permisos estándar de UNIX® de una manera altamente compatible (POSIX®.1e). Esta opción permite al administrador usar con gran provecho un modelo de seguridad más sofisticado.</p></div><div class=paragraph><p>Para habilitar soporte de ACL en sistemas de ficheros UFS la siguiente opción:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>debe ser compilada en el kernel. Si esta opción no ha sido compilada, se mostrará un mensaje de advertencia si se intenta montar un sistema de ficheros que soporte ACL. Esta opción viene incluida en el kernel <span class=filename>GENERIC</span>. Las ACL dependen de los atributos extendidos habilitados en el sistema de ficheros. Los atributos extendidos están incluidos por defecto en la nueva generación de sistemas de ficheros UNIX® UFS2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los atributos extendidos pueden usarse también en UFS1 pero requieren una carga de trabajo mucho más elevada que en UFS2. El rendimiento de los atributos extendidos es, también, notablemente mayor en UFS2. Por todo esto si quiere usar ACL le recomendamos encarecidamente que use UFS2.</p></div></td></tr></tbody></table></div><div class=paragraph><p>LasACL se habilitadan mediante una bandera administrativa durante el montaje, <code>acls</code>, en el fichero <span class=filename>/etc/fstab</span>. La bandera de montaje puede también activarse de forma permanente mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> para modificar una bandera de superbloque ACLs en la cabecera del sistema de ficheros. En general es preferible usar la bandera de superbloque por varios motivos:</p></div><div class=ulist><ul><li><p>La bandera de montaje ACL no puede cambiarse por un remontaje (<a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <code>-u</code>), sino con un completo <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> y un <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Esto significa que no se pueden habilitar las ACL en el sistema de ficheros raíz después del arranque. También significa que no se puede cambiar la disposición de un de ficheros una vez que se ha comenzado a usar.</p></li><li><p>Activar la bandera de superbloque provocará que el sistema de ficheros se monte siempre con las ACL habilitadas incluso si no existe una entrada en <span class=filename>fstab</span> o si los dispositivos se reordenan. Esto es así para prevenir un montaje accidental del sistema de ficheros sin tener las ACL habilitadas, que podría resultar en que se impongan de forma inadecuada las ACL, y en consecuencia problema de seguridad.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Podemos cambiar el comportamiento de las ACL para permitirle a la bandera ser habilitada sin un <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> completo, pero puede salirle el tiro por la culata si activa las ACL, luego las desactiva, y después las vuelve a activar sin configurar desde cero las atributos extendidos. En general, una vez que se han deshabilitado las ACL en un sistema de ficheros no deben dehabilitarse, ya que la protección de ficheros resultante puede no ser compatible las que esperan los usuarios del sistema, y al volver a activar las ACL volver a asignar las ACL a ficheros cuyos permisos hubieran sido cambiados, lo que puede desenbocar en un escenario impredecible.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Los sistemas de ficheros con ACL habilitadas tienen un signo <code>+</code> (más) al visualizar sus configuraciones de permisos. Por ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directorio1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directorio2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directorio3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>Aquí vemos que los directorios <span class=filename>directorio1</span>, <span class=filename>directorio2</span>, y <span class=filename>directorio3</span> están usando ACL. El directorio <span class=filename>public_html</span> no.</p></div><div class=sect2><h3 id=_uso_de_acl>14.12.1. Uso de ACL<a class=anchor href=#_uso_de_acl></a></h3><div class=paragraph><p>Las ACLs del sistema de ficheros pueden comprobarse con <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a>. Por ejemplo, para ver las configuraciones de ACL del fichero <span class=filename>test</span>, uno podría usar lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>Para cambiar las configuraciones de las ACL en este fichero use <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a>. Observe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>La bandera <code>-k</code> eliminará todas las ACLs definidas para un fichero o sistema ficheros. El método preferible sería utilizar <code>-b</code>, ya que deja los campos básicos imprescindibles para que las ACL sigan funcionando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>La opción <code>-m</code> se usa para modificar las entradas por defecto de las ACL. Debido a que no había entradas predefinidas puesto que fueron eliminadas por la orden anterior, restauraremos las opciones por defecto y asignará las opciones listadas. Tenga en cuenta que si añade un nuevo usuario o grupo aparecerá el error <code>Invalid argument</code> en la salida estándar <span class=filename>stdout</span>.</p></div></div></div></div><div class=sect1><h2 id=security-portaudit>14.13. Monitorización de fallos de seguridad de aplicaciones<a class=anchor href=#security-portaudit></a></h2><div class=sectionbody><div class=paragraph><p>En estos últimos años el mundo de la seguridad ha hecho grandes avances en cuanto a la gestión de las vulnerabilidades. La amenaza de asaltos a los sistemas se incrementa cuando se instalan y configuran aplicaciones de muy diversas procedencias en virtualmente cualquier sistema operativo disponible.</p></div><div class=paragraph><p>La evaluación de vulnerabilidades es un factor clave en la seguridad; aunque FreeBSD libere avisos de seguridad relacionados con el sistema base, llevar la gestión de vulnerabilidades hasta cada aplicación que se puede instalar en FreeBSD va mucho más allá de la capacidad del proyecto FreeBSD. A pesar de esto existe una forma de mitigar las vulnerabilidades de esas aplicaciones y advertir a los administradores sobre los problemas de seguridad a medida que se detectan. Portaudit existe para hacer ese trabajo.</p></div><div class=paragraph><p>El port <a class=package href=https://cgit.freebsd.org/ports/tree/security/portaudit/>security/portaudit</a> consulta una base de datos, actualizada y mantenida por el equipo de seguridad y por los desarrolladores de FreeBSD en busca de incidentes de seguridad que hayan sido detectados.</p></div><div class=paragraph><p>Si quiere usar Portaudit instálelo desde la colección de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/security/portaudit &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>Durante el proceso de instalación los ficheros de configuración de <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> se actualizan haciendo que Portaudit aparezca en el mensaje sobre la seguridad del sistema que diariamente Recuerde que ese correo (que se envia a la cuenta <code>root</code> es muy importante y debería leerlo. No hay ninguna configuración que deba modificar o crear.</p></div><div class=paragraph><p>Después de la instalación un administrador debe actualizar la base de datos alojada en local en <span class=filename>/var/db/portaudit</span> mediante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -F</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La base de datos será actualizada automáticamente durante la ejecución de <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>; así que la orden anterior es totalmente opcional. Solo se necesita para los siguientes ejemplos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si quiere comproblar si entre las aplicaciones que haya instalado desde el árbol de ports en su sistema hay problemas de seguridad sólo tiene que ejecutar lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -a</span></code></pre></div></div><div class=paragraph><p>Este es un ejemplo de la salida:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>El administrador del sistema obtendrá mucha más información sobre el problema de seguridad dirigiendo su navegador web a la URL que aparece en el mensaje. Esto incluye versiones afectadas (por versión de port de FreeBSD), junto con otros sitios web que contengan advertencias de seguridad.</p></div><div class=paragraph><p>En pocas palabras, Portaudit es un programa muy poderoso y extremadamente útil cuando se combina con el port Portupgrade.</p></div></div></div><div class=sect1><h2 id=security-advisories>14.14. FreeBSD Security Advisories<a class=anchor href=#security-advisories></a></h2><div class=sectionbody><div class=paragraph><p>Como muchos sistemas operativos con calidad de producción, FreeBSD publica "Security Advisories" (advertencias de seguridad. Estas advertencias suelen enviarse por correo a las listas de seguridad e incluidas en la Errata solamente después de que la versión apropiada haya sido corregida. Esta sección tiene como fin explicar en qué consiste una advertencia de seguridad, cómo entenderla y qué medidas hay que tomar para parchear el sistema.</p></div><div class=sect2><h3 id=_qué_aspecto_tiene_una_advertencia_de_seguridad>14.14.1. ?Qué aspecto tiene una advertencia de seguridad?<a class=anchor href=#_qué_aspecto_tiene_una_advertencia_de_seguridad></a></h3><div class=paragraph><p>Las advertencias de seguridad de FreeBSD tienen un aspecto similar a la que se muestra aquí. Fué enviada a la lista de correo <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>Lista de correo para anuncios de seguridad que afectan a FreeBSD</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem <i class=conum data-value=1></i><b>(1)</b>

Category:       core <i class=conum data-value=2></i><b>(2)</b>
Module:         sys <i class=conum data-value=3></i><b>(3)</b>
Announced:      2003-09-23 <i class=conum data-value=4></i><b>(4)</b>
Credits:        Person@EMAIL-ADDRESS <i class=conum data-value=5></i><b>(5)</b>
Affects:        All releases of FreeBSD <i class=conum data-value=6></i><b>(6)</b>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39) <i class=conum data-value=7></i><b>(7)</b>
FreeBSD only:   NO <i class=conum data-value=8></i><b>(8)</b>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background <i class=conum data-value=9></i><b>(9)</b>

II.  Problem Description <i class=conum data-value=10></i><b>(10)</b>

III. Impact <i class=conum data-value=11></i><b>(11)</b>

IV.  Workaround <i class=conum data-value=12></i><b>(12)</b>

V.   Solution <i class=conum data-value=13></i><b>(13)</b>

VI.  Correction details <i class=conum data-value=14></i><b>(14)</b>

VII. References <i class=conum data-value=15></i><b>(15)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>El campo <code>Topic</code> indica cuál es exactamente el problema. Básicamente es la introducción de la advertencia de seguridad actual e indica el uso malintencionado que puede darse a la vulnerabilidad.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td><code>Category</code> se refiere a la parte afectada del sistema, que puede ser <code>core</code>, <code>contrib</code> o <code>ports</code>. La categoría <code>core</code> significa que la vulnerabilidad afecta a un componente central del sistema operativo FreeBSD. La categoría <code>contrib</code> significa que la vulnerabilidad afecta a software que no ha sido desarrollado por el proyecto FreeBSD, como sendmail. La categoría <code>ports</code> indica que la vulnerabilidad afecta a software incluido en la colección de ports.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>El campo <code>Module</code> se refiere a la ubicación del componente, por ejemplo <code>sys</code>. En este ejemplo vemos que está afectado el módulo <code>sys</code>; por lo tanto esta vulnerabilidad afecta a componentes utilizados dentro del kernel.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El campo <code>Announced</code> refleja la fecha de publicación de la advertencia de seguridad fué publicada o anunciada al mundo. Esto significa que el equipo de seguridad ha verificado que el que el problema existe y que se ha incluido un parche que soluciona el problema en el repositorio de código fuente de FreeBSD.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>El campo <code>Credits</code> le da el crédito al individuo u organización que descubrió y reportó la vulnerabilidad.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>El campo <code>Affects</code> explica a qué versiones de FreeBSD afecta esta vulnerabilidad. En el caso del kernel una rápida revisión de la salida de <code>ident</code> en los
ficheros afectados ayudará a determinar la versión. En el caso de de los ports el número de versión aparece después del nombre del port en <span class=filename>/var/db/pkg</span>. Si el sistema no se sincroniza con el repositorio CVS de FreeBSD y se reconstruye diariamente, existe la posibilidad de que esté afectado por el problema de seguridad.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>El campo <code>Corrected</code> indica la fecha, hora, zona horaria y versión de FreeBSD en que fué corregido.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>El campo <code>FreeBSD only</code> indica si la vulnerabilidad afecta solamente a FreeBSD o si afecta también a otros sistemas operativos.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>El campo <code>Background</code> informa acerca de qué es exactamente la aplicación afectada. La mayor parte de las veces se refiere a por qué la aplicación existe en
FreeBSD, para qué se usa y un poco de información de cómo llegó llegó a ocupar el lugar que ocupa en el sistema o el árbol de ports.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>El campo <code>Problem Description</code> explica el problema de seguridad en profundidad. Puede incluir información del código erróneo, o incluso cómo puede usarse maliciosamente el error para abrir un agujero de seguridad.</td></tr><tr><td><i class=conum data-value=11></i><b>11</b></td><td>El campo <code>Impact</code> describe el tipo de impacto que el problema pueda tener en un sistema. Por ejemplo, esto puede ser desde un ataque de denegación de servicio, hasta una escalada de privilegios de usuario, o incluso ofrecer al atacante acceso de superusuario.</td></tr><tr><td><i class=conum data-value=12></i><b>12</b></td><td>El campo <code>Workaround</code> ofrece una solución temoral posible para los administradores de sistemas que tal vez no puedan actualizar el sistema. Esto puede deberse a la falta de tiempo, disponibilidad de de red, o a muchas otras razones. A pesar de todo la la seguridad no se debe tomar a la ligera y un sistema afectado debe parchearse al menos aplicar una solución temporal para el agujero de seguridad.</td></tr><tr><td><i class=conum data-value=13></i><b>13</b></td><td>El campo <code>Solution</code> ofrece instrucciones para parchear el sistema afectado. Este es un método paso a paso, probado y verificado para parchear un sistema y que trabaje seguro.</td></tr><tr><td><i class=conum data-value=14></i><b>14</b></td><td>El campo <code>Correction Details</code> despliega la rama del CVS o el nombre de la versión con los puntos cambiados a guiones bajos. También muestra el número de revisión de los ficheros afectados dentro de cada rama.</td></tr><tr><td><i class=conum data-value=15></i><b>15</b></td><td>El campo <code>References</code> suele ofrecer fuentes adicionales de información: URL, libros, listas de correo y grupos de noticias.</td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security-accounting>14.15. Contabilidad de procesos<a class=anchor href=#security-accounting></a></h2><div class=sectionbody><div class=paragraph><p>La contabilidad de procesos es un método de seguridad en el cual un administrador puede mantener un seguimiento de los recursos del sistema utilizados, su distribución entre los usuarios, ofrecer monitorización del sistema y seguir la pista mínimamente a las órdenes de usuario.</p></div><div class=paragraph><p>Esto en realidad tiene sus puntos positivos y negativos. Uno de los positivos es que una intrusión puede minimizarse en el momento de producirse. Uno negativo es la cantidad de logs generados por la contabilidad de procesos y el espacio de disco que requieren. Esta sección guiará al administrador a través de los fundamentos de la contabilidad de procesos.</p></div><div class=sect2><h3 id=_cómo_habilitar_y_utilizar_la_contabilidad_de_procesos>14.15.1. Cómo habilitar y utilizar la contabilidad de procesos<a class=anchor href=#_cómo_habilitar_y_utilizar_la_contabilidad_de_procesos></a></h3><div class=paragraph><p>Antes de poder usar la contabilidad de procesos tendrá que habilitarla. Ejecute la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/account/acct</span>

<span class=c># accton /var/account/acct</span>

<span class=c># echo &#39;accounting_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Una vez habilitada, la contabilidad de procesos empezará a seguir el rastro de estadísticas de la CPU, órdenes, etc. Todos los logs de contabilidad están en un formato ilegible para humanos, pero accesibles para <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>. Si se ejecuta sin opciones, <code>sa</code> imprimirá información sobre el número de llamadas por usuario, el tiempo total transcurrido expresado en minutos, el tiempo total de CPU y de usuario en minutos, el número medio de operaciones de E/S, etc.</p></div><div class=paragraph><p>Para ver información acerca de las órdenes que se están ejecutados puede usar la <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>. <code>lastcomm</code> imprime órdenes ejecutadas por los usuarios en <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> específicas. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls</span>
	trhodes ttyp1</code></pre></div></div><div class=paragraph><p>Imprimiría todas las veces (conocidas) que el usuario <code>trhodes</code> ha usado <code>ls</code> en la terminal ttyp1.</p></div><div class=paragraph><p>Hay muchas más opciones que pueden serle muy útiles. Si quiere conocerlas consulte las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9 de marzo de 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Anterior></i><div class=container><a href=http://172.16.201.134:1313/es/books/handbook/users class=direction>Anterior</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Inicio></i><div class=container><a href=../ class=direction>Inicio</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/es/books/handbook/jails class=direction>Siguiente</a></div><i class="fa fa-angle-right" aria-hidden=true title=Siguiente></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#security-synopsis>14.1. Sinopsis</a></li><li><a href=#security-intro>14.2. Introducción</a></li><li><a href=#securing-freebsd>14.3. Asegurar FreeBSD</a></li><li><a href=#crypt>14.4. DES, MD5 y Crypt</a></li><li><a href=#one-time-passwords>14.5. Contraseñas de un solo uso</a></li><li><a href=#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=#kerberosIV>14.7. KerberosIV</a></li><li><a href=#kerberos5>14.8. Kerberos5</a></li><li><a href=#openssl>14.9. OpenSSL</a></li><li><a href=#ipsec>14.10. VPN sobre IPsec</a></li><li><a href=#openssh>14.11. OpenSSH</a></li><li><a href=#fs-acl>14.12. Listas de control de acceso a sistemas de ficheros</a></li><li><a href=#security-portaudit>14.13. Monitorización de fallos de seguridad de aplicaciones</a></li><li><a href=#security-advisories>14.14. FreeBSD Security Advisories</a></li><li><a href=#security-accounting>14.15. Contabilidad de procesos</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/books/handbook/handbook_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/_index target=_blank>Editar esta página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/es/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>