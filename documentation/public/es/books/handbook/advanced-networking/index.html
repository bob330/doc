<!doctype html><html class=theme-light lang=es><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Redes Avanzadas en FreeBSD: conceptos básicos de gateways y rutas, CARP, cómo configurar múltiples VLANs en FreeBSD, etc"><meta name=keywords content="Advanced Networking,Handbook,gateway,routes,wireless,tethering,bluetooth,bridging,CARP,VLAN"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/es/books/handbook/advanced-networking/><title>Capítulo 34. Redes Avanzadas | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capítulo 34. Redes Avanzadas"><meta property="og:description" content="Redes Avanzadas en FreeBSD: conceptos básicos de gateways y rutas, CARP, cómo configurar múltiples VLANs en FreeBSD, etc"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="https://docs.freebsd.org/es/books/handbook/advanced-networking/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/es\/books\/handbook\/advanced-networking\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=https://docs.freebsd.org/es/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/es/books>Books</a></li><li><a href=https://docs.freebsd.org/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/preface/>Prefacio</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/preface/#preface-audience>A quién va dirigido este texto</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/preface/#preface-changes-from2>Cambios desde la segunda edición</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/preface/#preface-changes>Cambios desde la primera edición</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/preface/#preface-overview>Cómo se organiza este libro</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/preface/#preface-conv>Convenciones usadas en este libro</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/preface/#preface-acknowledgements>Agradecimientos</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/parti/>Parte I. Primeros pasos</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/introduction/>Capítulo 1. Introducción</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/introduction/#introcution-synopsis>1.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/introduction/#nutshell>1.2. Bienvenido a FreeBSD</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/introduction/#history>1.3. Acerca del Proyecto FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-6aaec170775233b7c45f6cdcfb70d466 class=toggle>
<label class="icon cursor" for=chapter-6aaec170775233b7c45f6cdcfb70d466><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/install/>Capítulo 2. Instalación de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-synopsis>2.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-hardware>2.2. Requisitos de hardware</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-pre>2.3. Tareas anteriores a la instalación</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-start>2.4. Inicio de la instalación</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#using-sysinstall>2.5. ¿Qué es sysinstall?</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-steps>2.6. Asignación de espacio en disco</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-choosing>2.7. Elección de qué instalar</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-media>2.8. Elección del medio de instalación</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-final-warning>2.9. El punto sin retorno</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-post>2.10. Después de la instalación</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-trouble>2.11. Solución de problemas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-advanced>2.12. Guía avanzada de instalación</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/install/#install-diff-media>2.13. Cómo preparar su propio medio de instalación</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/basics/>Capítulo 3. Conceptos básicos de Unix</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#basics-synopsis>3.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#consoles>3.2. Consolas virtuales y terminales</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#permissions>3.3. Permisos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#dirstructure>3.4. Estructura de directorios</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#disk-organization>3.5. Organización de disco</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#mount-unmount>3.6. Montaje y desmontaje de sistemas de ficheros</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#basics-processes>3.7. Procesos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#basics-daemons>3.8. Dæmons, señales y cómo matar procesos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#editors>3.10. Editores de texto</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#basics-devices>3.11. Dispositivos y nodos de dispositivos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#binary-formats>3.12. Formatos binarios</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/basics/#basics-more-information>3.13. Más información</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/ports/>Capítulo 4. Instalación de aplicaciones: packages y ports</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/ports/#ports-synopsis>4.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ports/#ports-overview>4.2. Aproximación a la instalación de software</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ports/#ports-finding-applications>4.3. Cómo encontrar aplicaciones</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ports/#packages-using>4.4. Uso del sistema de packages</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ports/#ports-using>4.5. Uso de la colección de ports</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ports/#ports-nextsteps>4.6. Después de instalar un port</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ports/#ports-broken>4.7. Ports que no funcionan</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/x11/>Capítulo 5. El sistema X Window</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/x11/#x11-synopsis>5.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/x11/#x-understanding>5.2. Entender X</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/x11/#x-install>5.3. Instalar X11</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/x11/#x-config>5.4. Configuración de X11</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/x11/#x-fonts>5.5. Uso de tipos en X11</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/x11/#x-xdm>5.6. El gestor de pantalla X</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/x11/#x11-wm>5.7. Entornos de escritorio</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/partii/>Parte II. Tareas comunes</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/desktop/>Capítulo 6. Aplicaciones de escritorio</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/desktop/#desktop-synopsis>6.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/desktop/#desktop-browsers>6.2. Navegadores</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/desktop/#desktop-productivity>6.3. Productividad</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/desktop/#desktop-viewers>6.4. Visores de documentos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/desktop/#desktop-finance>6.5. Finanzas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/desktop/#desktop-summary>6.6. Resumen</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/multimedia/>Capítulo 7. Multimedia</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/multimedia/#_sinopsis>7.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/multimedia/#sound-setup>7.2. Configuración de la tarjeta de sonido</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/multimedia/#sound-mp3>7.3. Sonido MP3</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/multimedia/#video-playback>7.4. Reproducción de vídeo</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/multimedia/#tvcard>7.5. Configuración de tarjetas de TV</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/multimedia/#scanners>7.6. Escáneres de imágenes</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/>Capítulo 8. Configuración del kernel de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/#_sinopsis>8.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/#_qué_razones_hay_para_compilar_un_kernel_personalizado>8.2. ¿Qué razones hay para compilar un kernel personalizado?</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Inventario de hardware del sistema</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/#kernelconfig-modules>8.4. Controladores del kernel, subsistemas y módulos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/#kernelconfig-building>8.5. Compilación e instalación de un kernel personalizado</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/#kernelconfig-config>8.6. El fichero de configuración</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/kernelconfig/#kernelconfig-trouble>8.7. Qué hacer si algo va mal</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/printing/>Capítulo 9. Imprimir</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/printing/#_sinopsis>9.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/printing/#printing-intro-spooler>9.2. Introducción</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/printing/#printing-intro-setup>9.3. Configuración básica</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/printing/#printing-advanced>9.4. Configuración avanzada de impresoras</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/printing/#printing-using>9.5. Cómo utilizar impresoras</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/printing/#printing-lpd-alternatives>9.6. Alternativas a LPD</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/printing/#printing-troubleshooting>9.7. Solución de problemas</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/>Capítulo 10. Compatibilidad binaria con Linux</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Instalación</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#linuxemu-mathematica>10.3. Instalación de Mathematica®</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#linuxemu-maple>10.4. Instalación de Maple™</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#linuxemu-matlab>10.5. Instalación de MATLAB®</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#linuxemu-oracle>10.6. Instalación de Oracle®</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#sapr3>10.7. Instalación de SAP® R/3®</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/linuxemu/#linuxemu-advanced>10.8. Temas avanzados</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/partiii/>Parte III. Administración del sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/config/>Capítulo 11. Configuración y Adaptación del Sistema</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/config/#config-network-setup>11.1. Configuración de Tarjetas de Red</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/config/#configtuning-starting-services>11.2. "Arrancar servicios"</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/config/#soft-updates>11.3. "Soft Updates"</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/config/#adding-swap-space>11.4. Añadir espacio swap</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/boot/>Capítulo 12. El proceso de arranque en FreeBSD</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/boot/#boot-synopsis>12.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/boot/#boot-introduction>12.2. El problema que representa arrancar el sistema</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/boot/#boot-blocks>12.3. El RMA y las etapas de arranque uno, dos y tres</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/boot/#boot-kernel>12.4. Interacción con el kernel durante el arranque</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/boot/#device-hints>12.5. Device Hints</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/boot/#boot-init>12.6. Init: inicialización del proceso de control</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/boot/#boot-shutdown>12.7. Secuencia de apagado</a></li></ul></li><li><input type=checkbox id=chapter-d251c21b963b5ab783e5aec225e02b5a class=toggle>
<label class="icon cursor" for=chapter-d251c21b963b5ab783e5aec225e02b5a><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/users/>Capítulo 13. Usuarios y administración básica de cuentas</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-synopsis>13.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-introduction>13.2. Introducción</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-superuser>13.3. La cuenta superusuario</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-system>13.4. Cuentas de sistema</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-user>13.5. Cuentas de usuario</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-modifying>13.6. Modificación de cuentas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-limiting>13.7. Limitar a los usuarios</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-personalizing>13.8. Personalizar a los usuarios</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/users/#users-groups>13.9. Grupos</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/security/>Capítulo 14. Seguridad</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/security/#security-synopsis>14.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#security-intro>14.2. Introducción</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#securing-freebsd>14.3. Asegurar FreeBSD</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#crypt>14.4. DES, MD5 y Crypt</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#one-time-passwords>14.5. Contraseñas de un solo uso</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#kerberosIV>14.7. KerberosIV</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#kerberos5>14.8. Kerberos5</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#openssl>14.9. OpenSSL</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#ipsec>14.10. VPN sobre IPsec</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#openssh>14.11. OpenSSH</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#fs-acl>14.12. Listas de control de acceso a sistemas de ficheros</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#security-portaudit>14.13. Monitorización de fallos de seguridad de aplicaciones</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#security-advisories>14.14. FreeBSD Security Advisories</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/security/#security-accounting>14.15. Contabilidad de procesos</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/jails/>Capítulo 15. Jaulas</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/jails/#jails-synopsis>15.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/jails/#jails-terms>15.2. Términos relacionados con las jaulas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/jails/#jails-intro>15.3. Introducción</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/jails/#jails-build>15.4. Creación y gestión de jaulas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/jails/#jails-tuning>15.5. Administración y personalización a fondo</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/jails/#jails-application>15.6. Uso de las jaulas</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/mac/>Capítulo 16. Mandatory Access Control</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-synopsis>16.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-inline-glossary>16.2. Términos clave en este capí­tulo</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-initial>16.3. Explicación de MAC</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-understandlabel>16.4. Las etiquetas MAC</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-modules>16.5. Configuración de módulos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-ifoff>16.6. El módulo MAC ifoff</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-portacl>16.7. El módulo MAC portacl</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-labelingpolicies>16.8. Polí­ticas de etiquetas MAC</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-partition>16.9. El módulo MAC partition</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-mls>16.10. El módulo de seguridad multinivel MAC</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-biba>16.11. El módulo MAC Biba</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-lomac>16.12. El módulo MAC LOMAC</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-implementing>16.13. Implementación de un entorno seguro con MAC</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#MAC-examplehttpd>16.14. Otro ejemplo: Uso de MAC para restringir un servidor web</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mac/#mac-troubleshoot>16.15. Depuración de errores en MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/audit/>Capítulo 17. Auditoría de eventos de seguridad</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/audit/#audit-synopsis>17.1. *</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/disks/>Capítulo 18. Almacenamiento</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#disks-synopsis>18.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#disks-naming>18.2. Nombres de dispositivo</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#disks-adding>18.3. Añadir discos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#raid>18.4. RAID</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#usb-disks>18.5. Dispositivos de almacenamiento USB</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#creating-cds>18.6. Creación y uso de medios ópticos (CD)</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#creating-dvds>18.7. Crear y utilizar medios ópticos (DVDs)</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#floppies>18.8. Creación y uso de disquetes (floppies)</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#backups-tapebackups>18.9. Creación y uso de cintas de datos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#backups-floppybackups>18.10. Respaldos en disquetes</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#backup-basics>18.11. Bases para respaldos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#disks-virtual>18.12. Sistemas de ficheros en red, memoria y respaldados en fichero</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#snapshots>18.13. Instantáneas ("snapshots") de sistemas de ficheros</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#quotas>18.14. Cuotas en sistemas de ficheros</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/disks/#disks-encrypting>18.15. Cifrado de particiones de disco</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/geom/>Capítulo 19. GEOM. Marco de trabajo modular de transformación de discos</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/geom/#GEOM-synopsis>19.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/geom/#GEOM-intro>19.2. Introducción a GEOM</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/geom/#GEOM-striping>19.3. RAID0 - Distribución por bandas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/geom/#GEOM-mirror>19.4. RAID1 - Replicación</a></li></ul></li><li><input type=checkbox id=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e class=toggle>
<label class="icon cursor" for=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/vinum/>Capítulo 20. El Gestor de Volúmenes Vinum</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-synopsis>20.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-intro>20.2. Los Discos son Demasiado Pequeños</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-access-bottlenecks>20.3. Cuellos de Botella en el Acceso</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-data-integrity>20.4. Integridad de Datos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-objects>20.5. Objetos Vinum</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-examples>20.6. Ejemplos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-object-naming>20.7. Esquema de Nombres de los Objetos</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-config>20.8. Configuración de Vinum</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/vinum/#vinum-root>20.9. Uso de Vinum en el Sistema de Ficheros Raíz</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/virtualization/>Capítulo 21. Virtualización</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/virtualization/#virtualization-synopsis>21.1. *</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/l10n/>Capítulo 22. Localización - Uso y configuración de I18N/L10N</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/l10n/#l10n-synopsis>22.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/l10n/#l10n-basics>22.2. Lo básico</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/l10n/#using-localization>22.3. Uso de la localización</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/l10n/#l10n-compiling>22.4. Compilación de programas con soporte para I18N</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/l10n/#lang-setup>22.5. Localización de FreeBSD a idiomas específicos</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/cutting-edge/>Capítulo 23. Lo último de lo último</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/cutting-edge/#_sinopsis>23.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/cutting-edge/#current-stable>23.2. FreeBSD-CURRENT vs. FreeBSD-STABLE</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/cutting-edge/#synching>23.3. Sincronización de su código fuente</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/cutting-edge/#makeworld>23.4. Uso de <code>make world</code></a></li><li><a href=https://docs.freebsd.org/es/books/handbook/cutting-edge/#small-lans>23.5. Redes pequeñas</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/partiv/>Parte IV. Comunicaciones en red</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/serialcomms/>Capítulo 24. Comunicaciones serie</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/serialcomms/#serial-synopsis>24.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/serialcomms/#serial>24.2. Introducción</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/serialcomms/#term>24.3. Terminales</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/serialcomms/#dialup>24.4. Servicio dial-in</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/serialcomms/#dialout>24.5. Servicio dial-out</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/serialcomms/#serialconsole-setup>24.6. Configurando la consola serie</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/ppp-and-slip/>Capítulo 25. PPP y SLIP</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/ppp-and-slip/#_sinopsis>25.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ppp-and-slip/#userppp>25.2. Uso de User PPP</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ppp-and-slip/#ppp>25.3. Uso de Kernel PPP</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ppp-and-slip/#pppoe>25.4. Uso de PPP sobre Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ppp-and-slip/#pppoa>25.5. Uso de PPP sobre ATM (PPPoA)</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/ppp-and-slip/#slip>25.6. Uso de SLIP</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/firewalls/>Capítulo 26. Cortafuegos</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/firewalls/#firewalls-intro>26.1. *</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/mail/>Capítulo 27. Correo Electrónico</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-synopsis>27.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-using>27.2. Utilización del correo electrónico</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#sendmail>27.3. Configuración de sendmail</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-changingmta>27.4. Sustitución del Agente de Transferencia de Correo</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-trouble>27.5. Depuración de Problemas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-advanced>27.6. Conceptos Avanzados</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#SMTP-UUCP>27.7. SMTP con UUCP</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#outgoing-only>27.8. Configuración para sólamente enviar correo</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#SMTP-dialup>27.9. Utilización del correo con una conexión mediante módem analógico (dial-up)</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#SMTP-Auth>27.10. Autentificación utilizando SMTP</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-agents>27.11. Agente de Correo de Usuario</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-fetchmail>27.12. Manejo de fetchmail</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mail/#mail-procmail>27.13. Uso de procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/network-servers/>Capítulo 28. Servidores de red</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/network-servers/#network-servers-synopsis>28.1. *</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/partv/>Parte V. Apéndices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/mirrors/>Apéndice A. Cómo obtener FreeBSD</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/mirrors/#mirrors-ftp>A.1. Servidores FTP</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/mirrors/#cvsup>A.2. Uso de CVSup</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/bibliography/>Apéndice B. Bibliografía</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_libros_y_revistas_específicas_sobre_freebsd>B.1. Libros y revistas específicas sobre FreeBSD</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_guías_de_usuario>B.2. Guías de usuario</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_guías_de_administrador>B.3. Guías de administrador</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_guías_de_programadores>B.4. Guías de programadores</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_el_sistema_operativo_por_dentro>B.5. El sistema operativo por dentro</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_referencia_de_seguridad>B.6. Referencia de seguridad</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_referencia_de_hardware>B.7. Referencia de hardware</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_historia_de_unix>B.8. Historia de UNIX</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/bibliography/#_diarios_y_revistas>B.9. Diarios y revistas</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/eresources/>Apéndices C. Recursos en Internet</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/eresources/#eresources-mail>C.1. Listas de correo</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/eresources/#eresources-news>C.2. Grupos de noticias de Usenet</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/eresources/#eresources-web>C.3. Servidores WWW</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/eresources/#eresources-email>C.4. Direcciones de correo electrónico</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/eresources/#eresources-shell>C.5. Cuentas shell</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/pgpkeys/>Apéndice D. PGP keys</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Responsables</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle checked>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/>Capítulo 34. Redes Avanzadas</a><ul><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#advanced-networking-synopsis>34.1. Sinopsis</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-routing>34.2. Gateways y Rutas</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#configtuning-virtual-hosts>34.3. Hosts Virtuales</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-advanced-wireless>34.4. Autenticación Inalámbrica Avanzada</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#wireless-ad-hoc-mode>34.5. Modo Ad-hoc Inalámbrico</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-usb-tethering>34.6. Tethering USB</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-bluetooth>34.7. Bluetooth</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-bridging>34.8. Bridging</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-aggregation>34.9. Agregación de Enlaces y Conmutación</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-diskless>34.10. Operación sin Disco con PXE</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#carp>34.11. Common Address Redundancy Protocol (CARP)</a></li><li><a href=https://docs.freebsd.org/es/books/handbook/advanced-networking/#network-vlan>34.12. VLANs</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Menú del libro"></i>
Menú del libro</span></label></div><h1 class=title>Capítulo 34. Redes Avanzadas</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>34.1. Sinopsis</a></li><li><a href=#network-routing>34.2. Gateways y Rutas</a></li><li><a href=#configtuning-virtual-hosts>34.3. Hosts Virtuales</a></li><li><a href=#network-advanced-wireless>34.4. Autenticación Inalámbrica Avanzada</a></li><li><a href=#wireless-ad-hoc-mode>34.5. Modo Ad-hoc Inalámbrico</a></li><li><a href=#network-usb-tethering>34.6. Tethering USB</a></li><li><a href=#network-bluetooth>34.7. Bluetooth</a></li><li><a href=#network-bridging>34.8. Bridging</a></li><li><a href=#network-aggregation>34.9. Agregación de Enlaces y Conmutación</a></li><li><a href=#network-diskless>34.10. Operación sin Disco con PXE</a></li><li><a href=#carp>34.11. Common Address Redundancy Protocol (CARP)</a></li><li><a href=#network-vlan>34.12. VLANs</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=advanced-networking-synopsis>34.1. Sinopsis<a class=anchor href=#advanced-networking-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Este capítulo cubre cierto número de temas avanzados de redes.</p></div><div class=paragraph><p>Después de leer este capítulo, sabrás:</p></div><div class=ulist><ul><li><p>Lo básico acerca de gateways y rutas.</p></li><li><p>Cómo configurar tethering por USB.</p></li><li><p>Cómo configurar dispositivos IEEE® 802.11 y Bluetooth®.</p></li><li><p>Cómo hacer que FreeBSD actúe como un puente.</p></li><li><p>Cómo configurar arranque por red PXE.</p></li><li><p>Cómo habilitar y utilizar las características del Common Address Redundancy Protocol (CARP) en FreeBSD.</p></li><li><p>Cómo configurar múltiples VLANs en FreeBSD.</p></li><li><p>Configurar unos auriculares con micrófono vía bluetooth.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo, deberías:</p></div><div class=ulist><ul><li><p>Comprender lo básico acerca de los scripts <span class=filename>/etc/rc</span>.</p></li><li><p>Estar familiarizado con la terminología básica de red.</p></li><li><p>Entendiendo la configuración básica de red en FreeBSD (<a href=../network/#network>FreeBSD network</a>).</p></li><li><p>Saber cómo configurar e instalar un nuevo kernel de FreeBSD (<a href=../kernelconfig/#kernelconfig>Configurando el Núcleo de FreeBSD</a>).</p></li><li><p>Cómo instalar software adicional de terceros (<a href=../ports/#ports>Instalando Aplicaciones: Paquetes y Ports</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=network-routing>34.2. Gateways y Rutas<a class=anchor href=#network-routing></a></h2><div class=sectionbody><div class=paragraph><p><em>Routing</em> es el mecanismo que permite a un sistema encontrar el camino de red a otro sistema. Una <em>ruta</em> es un par de direcciones definido las cuales representan el "destino" y el "gateway". La ruta indica que cuando se trata de llegar a un destino especificado, se deben enviar los paquetes a través del gateway especificado. Hay tres tipos de destinos: hosts individuales, subredes, y "default". La "ruta por defecto" se utiliza si no se puede aplicar ninguna otra ruta. También hay tres tipos de gateways: hosts individuales, interfaces, también llamados enlaces, y direcciones Ethernet (MAC). Las rutas conocidas se almacenan en una tabla de enrutamiento.</p></div><div class=paragraph><p>Esta sección proporciona una visión general de aspectos básicos de enrutado. Luego muestra cómo configurar un sistema FreeBSD como un router y proporciona algunas pistas para resolver problemas.</p></div><div class=sect2><h3 id=network-routing-default>34.2.1. Enrutamiento Básico<a class=anchor href=#network-routing-default></a></h3><div class=paragraph><p>Para ver la tabla de enrutamiento de un sistema FreeBSD, usa <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>Las entradas en este ejemplo son como sigue:</p></div><div class=dlist><dl><dt class=hdlist1>Defecto</dt><dd><p>La primera ruta en esta tabla especifica la ruta por defecto (<code>default</code>). Cuando el sistema local necesita conectarse a un host remoto, comprueba la tabla de enrutamiento para determinar si existe un camino. Si el host remoto tiene una entrada en la tabla, el sistema comprueba si puede conectar utilizando el interfaz especificado en dicha entrada.</p><div class=paragraph><p>Si el destino no tiene una entrada, o si todos los caminos conocidos fallan, el sistema utiliza la entrada para el enrutamiento por defecto. Para hosts en la red de área local, el campo <code>Gateway</code> en la ruta por defecto se establece al sistema que tiene una conexión directa a Internet. Cuando se lee esta entrada, verifica que la columna <code>Flags</code> indica que el gateway se puede usar (<code>UG</code>).</p></div><div class=paragraph><p>La ruta por defecto para una máquina que está funcionando como gateway para el mundo exterior será la máquina gateway del Proveedor de Servicio de Internet (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>La segunda ruta es <code>localhost</code>. El interfaz especificado en la columna <code>Netif</code> para <code>localhost</code> es <span class=filename>lo0</span>, también conocido como el dispositivo loopback. Esto indica que todo el tráfico para este destino debería ser interno, en lugar de enviarlo a través de la red.</p></dd><dt class=hdlist1>Dirección MAC</dt><dd><p>Las direcciones que comienzan con <code>0:e0</code> son direcciones MAC. FreeBSD identificará automáticamente cualquier host, <code>test0</code> en el ejemplo, en el Ethernet local y añadirá una ruta para ese host sobre el interfaz Ethernet, <span class=filename>re0</span>. Este tipo de ruta tiene un timeout, mostrado en la columna <code>Expire</code>, que es usado si el host no responde en un tiempo determinado. Cuando esto sucede, la ruta a este host será automáticamente borrada. Estos hosts se identifican usando el Routing Information Protocol (RIP), que calcula rutas a los hosts locales basándose en la determinación del camino más corto.</p></dd><dt class=hdlist1>subred</dt><dd><p>FreeBSD añadirá rutas para la subred local. En este ejemplo, <code>10.20.30.255</code> es la dirección de broadcast para la subred <code>10.20.30</code> y <code>example.com</code> es el nombre de dominio asociado con esa subred. La designación <code>link#1</code> hace referencia a la primera tarjeta Ethernet de la máquina.</p><div class=paragraph><p>Hosts en la red local y subredes locales tienen sus rutas configuradas automáticamente por un demonio llamado <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>. Si no se está ejecutando, sólo existirán las rutas que hayan sido configuradas estáticamente por el administrador.</p></div></dd><dt class=hdlist1>host</dt><dd><p>La línea <code>host1</code> hace referencia al host mediante su dirección Ethernet. Puesto que es el host que envía, FreeBSD sabe que tienen que usar el interfaz loopback (<span class=filename>lo0</span>) en lugar del interfaz Ethernet.</p><div class=paragraph><p>Las dos líneas <code>host2</code> representan alias que se crean utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. El símbolo <code>⇒</code> después del interfaz <span class=filename>lo0</span> indica que se ha establecido un alias además de la dirección de loopback. Estas rutas sólo se muestran en el host que suporta el alias y el resto de hosts en la red local tendrán una línea <code>link#1</code> para esas rutas.</p></div></dd><dt class=hdlist1>224</dt><dd><p>La última línea (subred de destino <code>224</code>) tiene que ver con multicasting.</p></dd></dl></div><div class=paragraph><p>Se pueden ver varios atributos para cada ruta en la columna <code>Flags</code>. <a href=#routeflags>Flags Habituales de la Tabla de Enrutado</a> resume algunos de estos flags y sus significados:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 1. Flags Habituales de la Tabla de Enrutado</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Flag</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta está activa (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta de destino es un único host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Envía cualquier cosa a este destino a través de este gateway, que averiguará a dónde enviarlo a continuación.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Esta ruta se ha configurado de forma estática.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clona una nueva ruta basada en esta ruta para que las máquinas puedan conectarse. Este tipo de ruta se usa normalmente para redes locales.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta ha sido auto configurada basada en una ruta (clonada) de una red de área local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta incluye referencias a hardware Ethernet (link).</p></td></tr></tbody></table><div class=paragraph><p>En un sistema FreeBSD, la ruta por defecto se puede configurar en <span class=filename>/etc/rc.conf</span> especificando la dirección IP del gateway por defecto:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>También es posible añadir la ruta de forma manual usando <code>route</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Date cuenta de que las rutas añadidas manualmente no persisten entre reinicios. Para más información sobre la manipulación manual de tablas de enrutamiento de red, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect2><h3 id=network-static-routes>34.2.2. Configurando un Router con Rutas Estáticas<a class=anchor href=#network-static-routes></a></h3><div class=paragraph><p>Un sistema FreeBSD se puede configurar como el gateway por defecto, o router, para una red si es un sistema "dual-homed". Un sistema "dual-homed" es una máquina que está en al menos dos redes diferentes. Típicamente cada red se conecta a un interfaz de red separada, aunque se puede usar IP aliasing para enlazar múltiples direcciones, cada una en una subred diferente, a una única interfaz física.</p></div><div class=paragraph><p>Para que el sistema pueda reenviar paquetes entre interfaces, FreeBSD debe ser configurado como un router. Los estándares de Internet y las buenas prácticas de ingeniería evitan que el Proyecto FreeBSD active esta característica por defecto, pero se puede configurar en el arranque añadiendo esta línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>Para habilitar el enrutado, establece la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>net.inet.ip.forwarding</code> a <code>1</code>. Para parar el enrutado, restablece esta variable a <code>0</code>.</p></div><div class=paragraph><p>La tabla de enrutamiento de un router necesita rutas adicionales para saber cómo llegar a otras redes. Las rutas se puede añadir manualmente utilizando rutas estáticas o se pueden aprender automáticamente usando un protocolo de enrutamiento. Las rutas estáticas son apropiadas para redes pequeñas y esta sección describe cómo añadir una ruta estática para una red pequeña.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para redes grandes, las rutas estáticas pronto se vuelven impracticables. FreeBSD incluye el demonio de enrutamiento BSD estándar <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, que proporciona los protocolos de enrutamiento RIP, versiones 1 y 2, y IRDP. Se puede instalar soporte para los protocolos de enrutado BGP y OSPFS usando el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/net/quagga/>net/quagga</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Considera la siguiente red:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>En este escenario, <code>RouterA</code> es una máquina FreeBSD que está actuando como un router para el resto de Internet. Tiene una ruta por defecto establecida a <code>10.0.0.1</code> que le permite conectarse con el mundo exterior. <code>RouterB</code> ya está configurado para utilizar <code>192.168.1.1</code> como su gateway por defecto.</p></div><div class=paragraph><p>Antes de añadir ninguna ruta estática, la tabla de enrutamiento de <code>RouterA</code> tiene este aspecto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1.0/24     <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Con la tabla de enrutamiento actual, <code>RouterA</code> no tiene una ruta a la red <code>192.168.2.0/24</code>. El siguiente comando añade la red <code>Internal Net 2</code> a la tabla de enrutamiento de <code>RouterA</code> usando <code>192.168.1.2</code> para el siguiente salto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Ahora, <code>RouterA</code> puede alcanzar cualquier host en la red <code>192.168.2.0/24</code>. Sin embargo, la información de enrutamiento no persistirá si el sistema FreeBSD se reinicia. Si una ruta estática necesita ser persistente, añádela a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>La variable de configuración <code>static_routes</code> es una lista de cadenas separadas por un espacio, donde cada cadena referencia el nombre de una ruta. La variable <code>route_internalnet2</code> contiene la ruta estática para el nombre de esa ruta.</p></div><div class=paragraph><p>Usar más de una cadena en <code>static_routes</code> crea múltiples rutas estáticas. Lo siguiente muestra un ejemplo de cómo añadir rutas estáticas para las redes <code>192.168.0.0/24</code> y <code>192.168.1.0/24</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect2><h3 id=network-routing-troubleshooting>34.2.3. Resolución de problemas<a class=anchor href=#network-routing-troubleshooting></a></h3><div class=paragraph><p>Cuando se asigna un espacio de direcciones a una red, el proveedor de servicio configura sus propias tablas de enrutamiento de forma que todo el tráfico para la red se enviará a través del enlace para el sitio. Pero ¿cómo saben los sitios externos que tienen que enviar sus paquetes al ISP de la red?</p></div><div class=paragraph><p>Hay un sistema que lleva el control de todos los espacios de direcciones asignados y define sus puntos de conexión a la red principal de Internet, o las líneas troncales que llevan el tráfico por todo el país y alrededor del mundo. Cada máquina troncal tiene una copia de un conjunto maestro de tablas, las cuales dirigen el tráfico para una red particular hacia un portador troncal específico, y de ahí bajando por la cadena de proveedores de servicio hasta que alcanza una red particular.</p></div><div class=paragraph><p>Es tarea del proveedor de servicio avisar a los sitios troncales de que son el punto de conexión, y por tanto el camino de entrada, para un sitio. Esto se conoce como propagación de ruta.</p></div><div class=paragraph><p>A veces, hay algún problema con la propagación de ruta y algunos sitios son incapaces de conectar. Quizás el comando más útil para intentar averiguar dónde se rompe la ruta es <code>traceroute</code>. Es útil cuando <code>ping</code> falla.</p></div><div class=paragraph><p>Cuando uses <code>traceroute</code>, incluye la dirección del host remoto al que conectar. La salida mostrará el gateway junto con el camino que sigue el intento, eventualmente alcanzando el destino, o terminando debido a la falta de conexión. Para más información, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect2><h3 id=network-routing-multicast>34.2.4. Consideraciones para Multicast<a class=anchor href=#network-routing-multicast></a></h3><div class=paragraph><p>FreeBSD soporta de forma nativa tanto aplicaciones multicast como enrutamiento multicast. Las aplicaciones multicast no necesitan ninguna configuración especial para ejecutarse en FreeBSD. El soporte para enrutamiento multicast requiere que la siguiente opción esté incluida en un kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>El demonio de enrutamiento multicast, mrouted se puede instalar usando el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a>. Este demonio implementa el protocolo de enrutamiento multicast DVMRP y se configura editando el fichero <span class=filename>/usr/local/etc/mrouted.conf</span> para configurar los túneles y DVMRP. La instalación de mrouted también instala map-mbone y mrinfo, así como sus páginas de manual. Consúltalas para ver ejemplos de configuración.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>DVMRP ha sido ampliamente sustituido por el protocolo PIM en muchas instalaciones multicast. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a> para más información.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>34.3. Hosts Virtuales<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>Un uso habitual para FreeBSD es el de proporcionar alojamiento virtual de sitios, donde un servidor aparece en la red como muchos servidores. Esto se consigue asignando múltiples direcciones de red a una única interfaz.</p></div><div class=paragraph><p>Una interfaz dada tiene una dirección "real", y puede tener un determinado número de direcciones "alias". Estos alias se añaden normalmente poniendo entradas alias en <span class=filename>/etc/rc.conf</span>, como se ve en este ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</span></code></pre></div></div><div class=paragraph><p>Las entradas de alias deben empezar con <code>alias<em>0</em></code> usando un número secuencial como <code>alias0</code>, <code>alias1</code>, y así sucesivamente. El proceso de configuración terminará en el primer número que falte.</p></div><div class=paragraph><p>El cálculo de las máscaras de red de los alias es importante. Para una interfaz data, debe haber una dirección que represente correctamente la máscara de la red. Cualquier otra dirección que esté en esta red tiene que tener una más cara con todo <code>1</code>s, expresada como <code>255.255.255.255</code> o <code>0xffffffff</code>.</p></div><div class=paragraph><p>Por ejemplo, considera el caso donde la interfaz <code>fxp0</code> está conectada a dos redes: <code>10.1.1.0</code> con máscara de red <code>255.255.255.0</code> y <code>202.0.75.16</code> con máscara de red`255.255.255.240`. El sistema está configurado para aparecer en los rangos <code>10.1.1.1</code> hasta <code>10.1.1.5</code> y <code>202.0.75.17</code> hasta <code>202.0.75.20</code>. Sólo la primera dirección en un rango de red dado debería tener una máscara de red real. Todas las demás (<code>10.1.1.2</code> hasta <code>10.1.1.5</code> y <code>202.0.75.18</code> hasta <code>202.0.75.20</code>) se deben configurar con máscara de red <code>255.255.255.255</code>.</p></div><div class=paragraph><p>Las siguientes entradas de <span class=filename>/etc/rc.conf</span> configuran correctamente el adaptador para este escenario:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</span></code></pre></div></div><div class=paragraph><p>Una forma más sencilla de expresar esto es con una lista de rangos de direcciones IP separadas por espacios. A la primera dirección se le asignará la máscara de subred indicada y las demás direcciones tendrán una máscara de subred de <code>255.255.255.255</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</span></code></pre></div></div></div></div><div class=sect1><h2 id=network-advanced-wireless>34.4. Autenticación Inalámbrica Avanzada<a class=anchor href=#network-advanced-wireless></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD soporta distintas formas de conectarse a una red inalámbrica. Esta sección describe como realizar autenticación avanzada en una Red Inalámbrica.</p></div><div class=paragraph><p>Para hacer una conexión y autenticación básica a una red inalámbrica la sección <a href=../network/#wireless-authentication>Conexión y Autenticación a una Red Inalámbrica</a> en el Capítulo de Red describe como hacerlo.</p></div><div class=sect2><h3 id=network-wireless-wpa-eap-tls>34.4.1. WPA with EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h3><div class=paragraph><p>La segunda forma de utilizar WPA es con un servidor de autenticación 802.1X. En este caso, WPA se llama WPA Enterprise para diferenciarlo del WPA Personal menos seguro. La autenticación en WPA Enterprise se basa en el Extensible Authentication Protocol (EAP).</p></div><div class=paragraph><p>EAP no viene con un método de encriptación. En su lugar, EAP se introduce dentro de un túnel encriptado. Hay muchos métodos de autenticación EAP, pero EAP-TLS, EAP-TTLS, y EAP-PEAP son los más comunes.</p></div><div class=paragraph><p>EAP con Transport Layer Security (EAP-TLS) es un protocolo de autenticación inalámbrica bien soportado ya que fue el primer método EAP certificado por la <a href=http://www.wi-fi.org/>Wi-Fi Alliance</a>. EAP-TLS requiere tres certificados para funcionar: el certificado de Certificate Authority (CA) instalado en todas las máquinas, el certificado de servidor para el servidor de autenticación, y un cliente de certificado para cliente inalámbrico. En este método EAP, tanto el servidor de autenticación como el cliente inalámbrico se autentican entre sí presentando sus respectivos certificados, y luego verificando que estos certificados están firmados por la CA de la organización.</p></div><div class=paragraph><p>Como antes, la configuración se hace mediante <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo indica el nombre de la red (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Este ejemplo utiliza el protocolo RSN IEEE® 802.11i también conocido como WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>La línea <code>key_mgmt</code> hace referencia al protocolo de gestión de claves que se utiliza. En este ejemplo, es WPA con autenticación EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Este campo indica el método EAP para la conexión.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>El campo <code>identity</code> contiene la cadena de identidad para EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>El campo <code>ca_cert</code> indica la ruta al fichero del certificado de CA. Este fichero es necesario para verificar el certificado de servidor.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>La línea <code>cliente_cert</code> da la ruta al fichero de certificado del cliente. Este certificado es único para cada cliente inalámbrico de la red.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>El campo <code>private_key</code> es la ruta al fichero de clave privada del certificado del cliente.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>El campo <code>private_key_passwd</code> contienen la contraseña para la clave privada.</td></tr></tbody></table></div><div class=paragraph><p>Después, añade las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>El siguiente paso es levantar la interfaz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>También es posible levantar la interfaz manualmente utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect2><h3 id=network-wireless-wpa-eap-ttls>34.4.2. WPA with EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h3><div class=paragraph><p>Con EAP-TLS, tanto la autenticación de servidor como la de cliente necesitan un certificado. Con EAP-TTLS, el certificado de cliente es opcional. Este método es similar a un servidor web que crea un tunel SSL seguro incluso cuando los visitantes no tienen certificados de cliente. EAP-TTLS utiliza un túnel encriptado con TLS para el transporte seguro de los datos de autenticación.</p></div><div class=paragraph><p>La configuración necesaria se puede añadir a <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica el método EAP para la conexión.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>El campo <code>identity</code> contiene la cadena de identidad para la autenticación EAP dentro del túnel encriptado con TLS.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>El campo <code>password</code> contiene la contraseña para la autenticación EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El campo <code>ca_cert</code> indica la ruta al fichero del certificado de CA. Este fichero es necesario para verificar el certificado de servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo especifica el método de autenticación usado en el túnel TLS encriptado. En este ejemplo, se utiliza EAP con MD5-Challenge. La fase de "autenticación interna" se llama habitualmente "phase2".</td></tr></tbody></table></div><div class=paragraph><p>Después, añade las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>El siguiente paso es levantar la interfaz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect2><h3 id=network-wireless-wpa-eap-peap>34.4.3. WPA with EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>PEAPv0/EAP-MSCHAPv2 es el método PEAP más común. En este capítulo, el término PEAP se usa para referirnos a ese método.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Protected EAP (PEAP) se diseñó como una alternativa a EAP-TTLS y es el segundo estándar EAP más usado por detrás de EAP-TLS. En una red con sistemas operativos variados, PEAP debería ser el estándar más soportado por detrás de EAP-TLS.</p></div><div class=paragraph><p>PEAP es similar a EAP-TTLS ya que utiliza un certificado de servidor para autenticar clientes mediante la creación de un túnel TLS encriptado entre el cliente y el servidor de autenticación, el cual protege el subsiguiente intercambio de información de autenticación. La autenticación PEAP es diferente de EAP-TTLS ya que emite el usuario sin encriptar y sólo la contraseña se envía por el túnel TLS encriptado. EAP-TTLS utilizará el túnel TLS tanto para el nombre de usuario como para la contraseña.</p></div><div class=paragraph><p>Añade las siguientes líneas a <span class=filename>/etc/wpa_supplicant.conf</span> para configurar los parámetros relacionados con EAP-PEAP:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica el método EAP para la conexión.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>El campo <code>identity</code> contiene la cadena de identidad para la autenticación EAP dentro del túnel encriptado con TLS.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>El campo <code>password</code> contiene la contraseña para la autenticación EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El campo <code>ca_cert</code> indica la ruta al fichero del certificado de CA. Este fichero es necesario para verificar el certificado de servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo contiene los parámetros para la primera fase de autenticación, el túnel TLS. Según el servidor de autenticación utilizado, especifica una etiqueta concreta para la autenticación. La mayoría de las veces la etiqueta será "cliente EAP encryption" que se establece usando <code>peaplabel=0</code>. Se puede encontrar más información en <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.confg&amp;sektion=5&amp;format=html">wpa_supplicant.confg(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Este campo especifica el protocolo de autenticación utilizado en el túnel encriptado con TLS. En el caso de PEAP, es <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Añade lo siguiente a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Después, levanta la interfaz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div></div><div class=sect1><h2 id=wireless-ad-hoc-mode>34.5. Modo Ad-hoc Inalámbrico<a class=anchor href=#wireless-ad-hoc-mode></a></h2><div class=sectionbody><div class=paragraph><p>El modo IBSS, también llamado modo ad-hoc, está diseñado para comunicaciones punto a punto. Por ejemplo, para establecer una red ad-hoc entre las máquinas <code>A</code> y <code>B</code>, escoge dos direcciones IP y un SSID.</p></div><div class=paragraph><p>En <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>El parámetro <code>ad-hoc</code> indica que el interfaz está funcionando en modo IBSS.</p></div><div class=paragraph><p>Ahora <code>B</code> debería ser capaz de detecta a <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>La <code>I</code> en la salida confirma que <code>A</code> está en modo ad-hoc. Ahora, configura <code>B</code> con una dirección IP diferente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Ahora <code>A</code> y <code>B</code> están listas para intercambiar información.</p></div><div class=sect2><h3 id=network-wireless-ap>34.5.1. Puntos de Acceso Host FreeBSD<a class=anchor href=#network-wireless-ap></a></h3><div class=paragraph><p>FreeBSD puede actuar como un Punto de Acceso (AP) lo que elimina la necesidad de comparar un hardware AP o montar una red ad-hoc. Esto puede ser particularmente útil cuando una máquina FreeBSD está actuando como gateway a otra red como Internet.</p></div><div class=sect3><h4 id=network-wireless-ap-basic>34.5.1.1. Configuración Básica<a class=anchor href=#network-wireless-ap-basic></a></h4><div class=paragraph><p>Antes de configurar una máquina FreeBSD como un AP, el kernel se tiene que configurar con el soporte de red apropiado para la tarjeta inalámbrica así como con los protocolos de seguridad que se utilizarán. Para más detalles, consulta <a href=#network-wireless-basic>[network-wireless-basic]</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El adaptador de controladores NDIS para controladores de Windows® actualmente no soporta operar en modo AP. Sólo los controladores inalámbricos nativos de FreeBSD soportan modo AP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez que se ha cargado el soporte para redes inalámbricas, comprueba si el dispositivo inalámbrico soporta el modo de punto de acceso basado en host, también conocido como modo hostap:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>Esta salida muestra las capacidades de la tarjeta. La palabra <code>HOSTAP</code> confirma que la tarjeta inalámbrica puede actuar como un AP. También se listan varios encriptadores soportados: WEP, TKIP, y AES. Esta información indica qué protocolos de seguridad se pueden utilizar con el AP.</p></div><div class=paragraph><p>El dispositivo inalámbrico sólo puede ser puesto en modo hostap durante la creación del pseudo-dispositivo de red, de forma que si hay una dispositivo creado anteriormente se tiene que destruir primero:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>después regenerado con la opción correcta antes de establecer otros parámetros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Usa <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> de nuevo para ver el estado de la interfaz <span class=filename>wlan0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>El parámetro <code>hostap</code> indica que el interfaz está funcionando en modo punto de acceso basado en host.</p></div><div class=paragraph><p>La configuración del interfaz se puede hacer de forma automática al arrancar añadiendo las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect3><h4 id=_punto_de_acceso_basado_en_host_sin_autenticación_o_encriptación>34.5.1.2. Punto de Acceso basado en Host Sin Autenticación o Encriptación<a class=anchor href=#_punto_de_acceso_basado_en_host_sin_autenticación_o_encriptación></a></h4><div class=paragraph><p>Aunque no se recomienda ejecutar un AP sin ninguna autenticación o encriptación, es una forma simple de comprobar que el AP funciona. Esta configuración también es importante para depurar problemas en el cliente.</p></div><div class=paragraph><p>Una vez que el AP está configurado, inicia un escaneo desde otra máquina inalámbrica para encontrar el AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>La máquina cliente ha encontrado el AP y se puede asociar con él:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect3><h4 id=network-wireless-ap-wpa>34.5.1.3. Punto de Acceso WPA2 basado en Host<a class=anchor href=#network-wireless-ap-wpa></a></h4><div class=paragraph><p>Esta sección se centra en configurar un punto de acceso FreeBSD usando el protocolo de seguridad WPA2. Se pueden encontrar más detalles acerca de WPA y de la configuración de clientes inalámbricos basados en WPA en <a href=#network-wireless-wpa>[network-wireless-wpa]</a>.</p></div><div class=paragraph><p>El demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> se usa para manejar la autenticación del cliente y la gestión de la clave en el AP con WPA2 habilitado.</p></div><div class=paragraph><p>Una máquina FreeBSD configurada como AP realiza las siguientes operaciones de configuración. Una vez que el AP está funcionando correctamente, se puede iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> durante el arranque con esta línea en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Antes de intentar configurar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>, primero configura los parámetros básicos presentados en <a href=#network-wireless-ap-basic>Configuración Básica</a>.</p></div><div class=sect4><h5 id=_wpa2_psk>34.5.1.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h5><div class=paragraph><p>WPA2-PSK está pensado para pequeñas redes donde no se puede o no es deseable utilizar un servidor de autenticación.</p></div><div class=paragraph><p>La configuración se hace en <span class=filename>/etc/hostapd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Interfaz inalámbrica utilizada para el punto de acceso.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Nivel de verbosidad utilizado durante la ejecución de <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>. Un valor de <code>1</code> representa el nivel mínimo.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Ruta del directorio utilizado por <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> para almacenar ficheros de sockets de dominio para comunicación con programas externos como <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>. En este ejemplo se usa el valor por defecto.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El grupo que tiene permitido el acceso a los ficheros de control del interfaz.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>El nombre de la red inalámbrica, o SSID, que aparecerá en los escaneos inalámbricos.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Activa WPA y especifica qué protocolo de autenticación WPA se requerirá. Un valor de <code>2</code> configura el AP para WPA2 y es el recomendado. Establécelo a <code>1</code> sólo si se necesita el obsoleto WPA.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Contraseña ASCII para la autenticación WPA.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>El protocolo de gestión de claves a usar. Este ejemplo establece WPA-PSK.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Algoritmos de encriptación aceptados por el punto de acceso. En este ejemplo, sólo se acepta el encriptador CCMP (AES). CCMP es una alternativa a TKIP y se prefiere siempre que se a posible. TKIP sólo debería permitirse cuando las estaciones con incapaces de usar CCMP.</td></tr></tbody></table></div><div class=paragraph><p>El siguiente paso es arrancar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Una vez que el AP está funcionando, los clientes se pueden asociar a él. Consulta <a href=#network-wireless-wpa>[network-wireless-wpa]</a> para más detalles. Es posible ver las estaciones asociadas con el AP usando <code>ifconfig <em>wlan0</em> list sta</code>.</p></div></div></div></div></div></div><div class=sect1><h2 id=network-usb-tethering>34.6. Tethering USB<a class=anchor href=#network-usb-tethering></a></h2><div class=sectionbody><div class=paragraph><p>Muchos teléfonos móviles proporcionan la opción de compartir su conexión de datos a través de USB (habitualmente llamado "tethering"). Esta característica usa uno de los protocolos RNDIS, CDC o el protocolo personalizado Apple® iPhone®/iPad®.</p></div><div class=ulist><ul><li><p>Los dispositivos Android™ normalmente utilizan el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a>.</p></li><li><p>Los dispositivos Apple® usan el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a>.</p></li><li><p>Dispositivos más antiguos usarán habitualmente el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a>.</p></li></ul></div><div class=paragraph><p>Antes de conectar un dispositivo, carga el controlador apropiado en el kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Una vez que el dispositivo está conectado <code>ue</code><em>0</em> estará disponible para que lo usemos como un dispositivo de red normal. Asegúrate de que el dispositivo tiene la opción "USB tethering" activada.</p></div><div class=paragraph><p>Para hacer este cambio permanente y cargar el controlador como un módulo en el arranque, escribe la línea apropiada de las siguientes en <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>if_urndis_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_cdce_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_ipheth_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div></div></div><div class=sect1><h2 id=network-bluetooth>34.7. Bluetooth<a class=anchor href=#network-bluetooth></a></h2><div class=sectionbody><div class=paragraph><p>Bluetooth es una tecnología inalámbrica para crear redes personales que operen en la banda sin licenciar de 2.4 GHz, con un rago de 10 metros. Las redes se forman normalmente como ad-hoc a partir de dispositivos portátiles como teléfonos móviles, tabletas, y portátiles. A diferencia de la tecnología inalámbrica Wi-Fi, Bluetooth ofrece perfiles de servicio de más alto nivel, como servidores de fichero tipo FTP, envío de ficheros, transporte de voz, emulación de línea serie, y más.</p></div><div class=paragraph><p>Esta sección describe el uso de un conector USB Bluetooth en un sistema FreeBSD. Después describe varias de las utilidades y protocolos de Bluetooth.</p></div><div class=sect2><h3 id=_cargando_soporte_bluetooth>34.7.1. Cargando Soporte Bluetooth<a class=anchor href=#_cargando_soporte_bluetooth></a></h3><div class=paragraph><p>La pila Bluetooth en FreeBSD está implementada utilizando el framework <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>. Una gran variedad de conectores USB Bluetooth se soporta con <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Los dispositivos Bluetooth basados en Broadcom BCM2033 se soportan mediante los controladores <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. La tarjeta 3Com Bluetooth PC Card 3CRWB60-A está soportada por el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>. Los dispositivos serie y UART Bluetooth están soportados por <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a>, y <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>.</p></div><div class=paragraph><p>Antes de conectar un dispositivo, determina cuál de los controladores anteriores utiliza, después carga el controlador. Por ejemplo, si el dispositivo utiliza el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Si el dispositivo Bluetooth se va a conectar al sistema durante el arranque, éste se puede configurar para cargar el módulo durante el arranque añadiendo el controlador a <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Una vez que el controlador está cargado, conecta el dispositivo USB. Si el controlador se cargó de forma correcta, en la consola y en <span class=filename>/var/log/messages</span> debería aparecer una salida similar a la siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>Para iniciar y parar la pila Bluetooth, utiliza su script de arranque. Es una buena idea parar la pila después de desconectar el dispositivo. Arrancar la pila bluetooth podría necesitar que se arranque <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>. Cuando se arranca la pila, la salida debería ser similar a la siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect2><h3 id=_encontrando_otros_dispositivos_bluetooth>34.7.2. Encontrando Otros Dispositivos Bluetooth<a class=anchor href=#_encontrando_otros_dispositivos_bluetooth></a></h3><div class=paragraph><p>El Host Controller Interface (HCI) proporciona un método uniforme para acceder a las capacidades de la banda base de Bluetooth. En FreeBSD, se crea un nodo HCI de netgraph para cada dispositivo Bluetooth. Para más detalles, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Una de las tareas más comunes es el descubrimiento de dispositivos Bluetooth dentro del rango de proximidad de RF. Esta operación se llama <em>inquiry</em> (pregunta). Inquiry y otras operaciones HCI relacionadas se ejecutan con <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. El ejemplo de abajo muestra cómo encontrar dispositivos Bluetooth que están dentro de rango. La lista de dispositivos debería mostrarse en unos pocos segundos. Ten en cuenta que un dispositivo remoto sólo contestará a la pregunta si está en modo <em>descubrible</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> es la dirección única de un dispositivo Bluetooth, similar a la dirección MAC de una tarjeta de red. Esta dirección es necesaria para la comunicación posterior con el dispositivo y es posible asignarle un valor que se amigable de leer. Hay información acerca de los hosts Bluetooth conocidos en <span class=filename>/etc/bluetooth/hosts</span>. El siguiente ejemplo muestra cómo obtener un nombre legible por las personas que ha sido asignado a un dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Si se realiza una pregunta a un dispositivo Bluetooth remoto, encontrará tu ordenador como "your.host.name (ubt0)". El nombre asignado al dispositivo local se puede cambiar en cualquier momento.</p></div><div class=paragraph><p>Se puede asignar alias a los dispositivos remotos en <span class=filename>/etc/bluetooth/hosts</span>. Se puede encontrar más información acerca de <span class=filename>/etc/bluetooth/hosts</span> en <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>El sistema Bluetooth proporciona conexión punto a punto entre dos unidades Bluetooth, o punto a multipunto que se comparte entre varios dispositivos Bluetooth. El siguiente ejemplo muestra cómo crear una conexión con un dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p><code>create_connection</code> acepta <code>BT_ADDR</code> así como los alias encontrados en <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>El siguiente ejemplo muestra cómo obtener la lista de conexiones activas en la banda base para el dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Un <em>manejador de conexión</em> es útil cuando se requiere la terminación de una conexión de la banda base, aunque normalmente no es necesario hacer esto a mano. La pila terminará automáticamente las conexiones de banda base inactivas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Teclea <code>hccontrol help</code> para obtener un listado completo de los comandos HCI disponibles. La mayoría de los comandos HCI no requieren privilegios de súper usuario.</p></div></div><div class=sect2><h3 id=_emparejamiento_de_dispositivos>34.7.3. Emparejamiento de Dispositivos<a class=anchor href=#_emparejamiento_de_dispositivos></a></h3><div class=paragraph><p>Por defecto, la comunicación Bluetooth no está autenticada, y cualquier dispositivo puede hablar con cualquier otro. Un dispositivo Bluetooth, como un teléfono móvil, podría decidir requerir autenticación para proporcionar un servicio particular. La autenticación Bluetooth se hacer normalmente con un <em>código PIN</em>, una cadena ASCII de hasta 16 caracteres. Se requiere que el usuario introduzca el mismo código PIN en ambos dispositivos. Una vez que el usuario ha introducido el código PIN, ambos dispositivos generarán una <em>clave de enlace</em>. Después de eso, la clave de enlace se puede almacenar en los dispositivos o en almacenamiento persistente. La siguiente vez, ambos dispositivos utilizarán las claves de enlace generadas previamente. Este procedimiento se llama <em>emparejamiento</em>. Ten en cuenta que si alguno de los dispositivos pierde la clave de enlace, se tiene que repetir el emparejamiento.</p></div><div class=paragraph><p>El demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> es el responsable de manejar las peticiones de autenticación Bluetooth. El fichero de configuración por defecto es <span class=filename>/etc/bluetooth/hcsecd.conf</span>. A continuación se muestra un ejemplo de sección para un teléfono móvil con el PIN establecido a <code>1234</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>La única limitación de los códigos PIN es la longitud. Algunos dispositivos, como los auriculares Bluetooth, podrían tener un código PIN fijo de fábrica. La opción <code>-d</code> fuerza a <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> a permanecer en primer plano, de forma que es fácil ver lo que está pasando. Establece el dispositivo remoto para que reciba emparejamientos e inicia la conexión Bluetooth con el dispositivo remoto. El dispositivo remoto debería indicar que el emparejamiento ha sido aceptado y solicitar el código PIN. Introduce el mismo código PIN listado en <span class=filename>hcsecd.conf</span>. Ahora el ordenador y el dispositivo remoto están emparejados. De forma alternativa, el emparejamiento puede ser iniciado por el dispositivo remoto.</p></div><div class=paragraph><p>Se puede añadir la siguiente línea a <span class=filename>/etc/rc.conf</span> para configurar que <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> arranque automáticamente cuando se inicia el sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Lo siguiente es una muestra de la salida del demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect2><h3 id=_acceso_a_la_red_con_perfiles_ppp>34.7.4. Acceso a la Red con Perfiles PPP<a class=anchor href=#_acceso_a_la_red_con_perfiles_ppp></a></h3><div class=paragraph><p>Es posible utilizar un perfil DUN (Dial-Up Networking) para configurar un teléfono móvil como un módem inalámbrico para conectarse a un servidor de acceso a Internet. También se puede utilizar para configurar un ordenador para recibir llamadas de datos desde un teléfono móvil.</p></div><div class=paragraph><p>Se puede usar el acceso a la red mediante un perfil PPP para proporcionar acceso LAN para uno o varios dispositivos Bluetooth. También puede proporcionar conexión PC a PC usando PPP sobre emulación de cable serie.</p></div><div class=paragraph><p>En FreeBSD, estos perfiles se implementan con <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> y el adaptador <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> que convierte la conexión Bluetooth en algo que PPP puede usar. Antes de que se pueda usar el perfile, se debe crear una nueva etiqueta PPP en <span class=filename>/etc/ppp/ppp.conf</span>. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para ver ejemplos.</p></div><div class=paragraph><p>En este ejemplo, se usa <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para abrir una conexión con un dispositivo remoto con un <code>BD_ADDR</code> de <code>00:80:37:29:19:a4</code> en un canal DUNRFCOMM:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>El número de canal real se obtendrá del dispositivo remoto usando el protocolo SDP. Es posible especificar el canal RFCOMM a mano, y en este caso <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> no realizará la consulta SDP. Usa <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> para averiguar el canal RFCOMM en el dispositivo remoto.</p></div><div class=paragraph><p>Para proporcionar acceso a la red con el servicio PPPLAN, se debe estar ejecutando <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> y se tienen que crear una nueva entrada para clientes LAN en <span class=filename>/etc/ppp/ppp.conf</span>. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para ver ejemplos. Finalmente, arrancar el servidor RFCOMMPPP en un número de canal RFCOMM válido. El servidor RFCOMMPPP registrará automáticamente el servicio LAN Bluetooth con el demonio SDP local. El ejemplo de abajo muestra cómo arrancar el servidor RFCOMMPPP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect2><h3 id=_protocolos_bluetooth>34.7.5. Protocolos Bluetooth<a class=anchor href=#_protocolos_bluetooth></a></h3><div class=paragraph><p>Esta sección proporciona un resumen de varios protocolos Bluetooth, sus funciones, y sus utilidades asociadas.</p></div><div class=sect3><h4 id=_logical_link_control_and_adaptation_protocol_l2cap>34.7.5.1. Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_logical_link_control_and_adaptation_protocol_l2cap></a></h4><div class=paragraph><p>El Logical Link Control and Adaptation Protocol (L2CAP) proporciona servicios de datos orientados a conexión así como no orientados a conexión a los protocolos de las capas superiores. L2CAP permite a los protocolos y aplicaciones de niveles más altos transmitir y recibir paquetes de datos L2CAP de hasta 64 kilobytes de longitud.</p></div><div class=paragraph><p>L2CAP se basa en el concepto de <em>canales</em>. Un canal es una conexión lógica construida sobre una conexión de banda base, donde cada canal está asociado a un sólo protocolo en una forma muchos-a-uno. Se pueden asociar múltiples canales al mismo protocolo, pero un canal no se puede asociar a múltiples protocolos. Cada paquete L2CAP recibido en un canal es redirigido al protocolo de nivel superior apropiado. Varios canales pueden compartir la misma conexión de banda base.</p></div><div class=paragraph><p>En FreeBSD, se crear un nodo L2CAP de netgraph para cada dispositivo Bluetooth. Este nodo normalmente se conecta con el nodo HCI Bluetooth inferior y los nodos socket Bluetooth superiores. El nombre por defecto para el nodo L2CAP es "devicel2cap". Para más detalles consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Un comando útil es <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, que puede ser usado para hacer ping a otros dispositivos. Algunas implementaciones Bluetooth podrían no devolver todos los datos que se les envía, de forma que los <code>0 bytes</code> en el siguiente ejemplo es algo normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>La utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> se utiliza para realizar varias operaciones sobre los nodos L2CAP. Este ejemplo muestra cómo obtener la lista de conexiones lógicas (canales) y la lista de conexiones de banda base para el dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Otra herramienta de diagnóstico es <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. Es similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, pero para estructuras de datos de red Bluetooth. El ejemplo de abajo muestra la misma conexión lógica como <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> arriba.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect3><h4 id=_comunicación_por_radio_frecuencia_rfcomm>34.7.5.2. Comunicación por Radio Frecuencia (RFCOMM)<a class=anchor href=#_comunicación_por_radio_frecuencia_rfcomm></a></h4><div class=paragraph><p>El protocolo RFCOMM proporciona emulación de puertos serie sobre el protocolo L2CAP. RFCOMM es un protocolo de transporte simple, con soporte adicional para emular los 9 circuitos de los puertos serie RS-2332 (EIATIA-232-E). Soporta hasta 60 conexiones simultáneas (canales RFCOMM) entre dos dispositivos Bluetooth.</p></div><div class=paragraph><p>Para los propósitos de RFCOMM, un camino de comunicación completo incluye dos aplicaciones ejecutándose en los extremos de la comunicación con un segmento de comunicación entre ellos. RFCOMM está pensado para cubrir aplicaciones que hace uso de los puertos serie de los dispositivos en los que se encuentra. El segmento de comunicación es una enlace de conexión Bluetooth directa desde un dispositivo a otro.</p></div><div class=paragraph><p>RFCOMM sólo se preocupa de la conexión entre los dispositivos en el caso de una conexión directa, o entre un dispositivo y un módem en el caso de red. RFCOMM puede soportar otras configuraciones, como módulos que se comunican vía tecnología inalámbrica Bluetooth en un lado y proporciona un interfaz por cable en el otro lado.</p></div><div class=paragraph><p>En FreeBSD, RFCOMM está implementado en la capa de sockets Bluetooth.</p></div></div><div class=sect3><h4 id=_protocolo_de_descubrimiento_de_servicios_sdp>34.7.5.3. Protocolo de Descubrimiento de Servicios (SDP)<a class=anchor href=#_protocolo_de_descubrimiento_de_servicios_sdp></a></h4><div class=paragraph><p>El Protocolo de Descubrimiento de Servicios (SDP) proporciona los medios para que las aplicaciones cliente descubran la existencia de servicios proporcionados por aplicaciones servidoras así como los atributos de dichos servicios. Los atributos de un servicio incluyen el tipo o clase del servicio ofrecido y el mecanismo o protocolo de información necesario para utilizarlo.</p></div><div class=paragraph><p>SDP incluye comunicación entre un servidor SDP y un cliente SDP. El servidor mantiene una lista de registros de servicio que describe las características de los servicios asociados con el servidor. Cada registro de servicio contiene información acerca de un único servicio. Un cliente puede recuperar información de un registro de servicio mantenido por el servidor SDP realizando una petición SDP. Si el cliente, o una aplicación asociada con el cliente, decide usar un servicio, debe abrir una conexión separada con el proveedor del servicio para poder utilizarlo. SDP proporciona un mecanismo para descubrir servicios y sus atributos, pero no proporciona un mecanismo para utilizar esos servicios.</p></div><div class=paragraph><p>Normalmente, un cliente SDP busca servicios basándose en alguna característica deseada de los servicios. Sin embargo, a veces es preferible descubrir qué tipos de servicios están descritos por los registros de servicio de un servidor SDP sin ninguna información previa acerca de los servicios. Este proceso de buscar cualquier servicio ofrecido se llama <em>navegación</em> (browsing).</p></div><div class=paragraph><p>El servidor SDP Bluetooth, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>, y cliente en línea de comando, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, están incluidos en la instalación estándar de FreeBSD. El siguiente ejemplo muestra cómo realizar una petición de navegación SDP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Ten en cuenta que cada servicio tiene una lista de atributos, como el canal RFCOMM. Dependiendo del servicio, el usuario podría necesitar anotar algunos de los atributos. Algunas implementaciones de Bluetooth no soportan la navegación de servicios y podrían devolver una lista vacía. En este caso, es posible buscar un servicio específico. El ejemplo inferior muestra cómo buscar el servicio OBEX Object Push (OPUSH):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Ofrecer servicios de FreeBSD a clientes Bluetooth se hace con el servidor <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>. Se puede añadir la siguiente línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>El demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> se puede arrancar con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>La aplicación servidora local que quiera proporcionar un servicio Bluetooth a clientes remotos registrará el servicio en el demonio SDP local. Un ejemplo de dicha aplicación es <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Una vez iniciado, registrará el servicio LAN Bluetooth con el demonio local SDP.</p></div><div class=paragraph><p>Se puede obtener la lista de servicios registrados en el servidor SDP local realizando una petición de navegación SDP mediante el canal de control local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect3><h4 id=_obex_object_push_opush>34.7.5.4. OBEX Object Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h4><div class=paragraph><p>Object Exchange (OBEX) es un protocolo ampliamente utilizado para transferencias de ficheros sencillas entre dispositivos móviles. Su principal uso está en la comunicación infrarroja, donde se usa para transferencias de ficheros genéricas entre portátiles o PDAs, y para enviar tarjetas de negocios o entradas de calendario entre teléfonos móviles y otros dispositivos con aplicaciones PIM (Personal Information Manager).</p></div><div class=paragraph><p>El servidor y cliente OBEX están implementados por obexapp, que se pude instalar usando el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a>.</p></div><div class=paragraph><p>El cliente OBEX es utilizado para subir y/o bajar objetos del servidor OBEX. Un objeto de ejemplo es una tarjeta de negocio o una cita. El cliente OBEX puede obtener el número de canal RFCOMM del dispositivo remoto vía SDP. Esto se puede hacer especificando el nombre del servicio en lugar del número de canal RFCOMM. Los nombres de servicios soportados son: <code>IrMC</code>, <code>FTRN</code>, y <code>OPUSH</code>. También es posible especificar el canal RFCOMM como un número. Abajo hay un ejemplo de una sesión OBEX donde el objeto de información del dispositivo se descarga desde un teléfono móvil, y un nuevo objeto, la tarjeta de negocio, se sube al directorio del teléfono.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Para proporcionar el servicio OPUSH, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> debe estar en ejecución y se debe crear una carpeta raíz donde se almacenarán todos los objetos recibidos. La ruta por defecto de la carpeta raíz es <span class=filename>/var/spool/obex</span>. Por último, inicia el servidor OBEX en un número de canal RFCOMM válido. El servidor OBEX registrará automáticamente el servicio OPUSH con el demonio SDP local. El ejemplo de abajo muestra cómo iniciar el servidor OBEX.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect3><h4 id=_perfil_de_puerto_serie_spp>34.7.5.5. Perfil de Puerto Serie (SPP)<a class=anchor href=#_perfil_de_puerto_serie_spp></a></h4><div class=paragraph><p>El Perfil de Puerto Serie (SPP) permite a los dispositivos Bluetooth realizar emulación de cable serie. Este perfile permite a aplicaciones heredadas utilizar Bluetooth como un sustituto del cable, a través de una abstracción de puerto serie.</p></div><div class=paragraph><p>En FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implementa SPP y un pseudo tty es usado como abstracción de puerto serie virtual. El ejemplo de abajo muestra cómo conectarse al servicio de puerto serie de un dispositivo remoto. No se tiene que especificar un canal RFCOMM ya que <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> puede obtenerlo del dispositivo remoto vía SDP. Para cambiar esto, especifica un canal RFCOMM en la línea de comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Una vez conectado, el pseudo tty puede ser usado como un puerto serie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>El pseudo tty se imprime en stdout y se puede leer mediante scripts:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect2><h3 id=_resolución_de_problemas>34.7.6. Resolución de problemas<a class=anchor href=#_resolución_de_problemas></a></h3><div class=paragraph><p>Por defecto, cuando FreeBSD está aceptando una nueva conexión, intenta realizar un cambio de roles y convertirse en maestro. Algunos dispositivos Bluetooth más antiguos que no soportan el cambio de roles no serán capaces de conectar. Puesto que el cambio de roles se realiza cuando se establece una nueva conexión, no es posible preguntar al dispositivo remoto si soporta el cambio de roles. Sin embargo, hay una opción HCI para deshabilitar el intercambio de roles en el lado local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>Para mostrar paquetes Bluetooht, usa el paquete de terceros hcidump, que se puede instalar mediante el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a>. Esta utilidad es similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> y se puede usar para mostrar el contenido de los paquetes Bluetooth en el terminal y para volcarlos a un fichero.</p></div></div></div></div><div class=sect1><h2 id=network-bridging>34.8. Bridging<a class=anchor href=#network-bridging></a></h2><div class=sectionbody><div class=paragraph><p>A veces es útil dividir una red, como un segmento Ethernet, en segmentos de red sin tener que crear subredes IP y utilizar un router para conectar los segmentos entre ellos. Un dispositivo que conecta dos redes juntas de esta forma se llama "bridge".</p></div><div class=paragraph><p>Un bridge funciona aprendiendo las direcciones MAC de los dispositivos en cada una de sus interfaces de red. Reenvía tráfico entre las redes sólo cuando las direcciones de origen y destino están en diferentes redes. En muchos aspectos, un bridge es como un switch Ethernet con muy pocos puertos. Un sistema FreeBSD como varias interfaces de red puede ser configurado para funcionar como un bridge.</p></div><div class=paragraph><p>Un bridge puede ser útil en las siguientes situaciones:</p></div><div class=dlist><dl><dt class=hdlist1>Conectar Redes</dt><dd><p>La operación básica de un bridge es juntar dos o más segmentos de red. Hay muchas razones para usar un bridge basado en host en lugar de un equipamiento de red, como restricciones en el cableado o los firewalls. Un bridge también puede conectar una interfaz inalámbrica funcionando en modo hostap con una red cableada y actuar como punto de acceso.</p></dd><dt class=hdlist1>Filtrado/Firewall the Modelado de Tráfico</dt><dd><p>Se puede usar un bridge cuando se necesita funcionalidad de firewall sin enrutado o traducciones de direcciones de red (NAT, Network Address Translation).</p><div class=paragraph><p>Un ejemplo es una pequeña compañía que está conectada a un ISP mediante DSL o ISDN. Hay trece direcciones IP públicas del ISP y diez ordenadores en la red. En esta situación, usar un firewall basado en un router es difícil por problemas con las subredes. Un firewall basado en bridge se puede configurar sin ningún problema con las direcciones IP.</p></div></dd><dt class=hdlist1>Network Tap</dt><dd><p>Un bridge puede unir dos segmentos de red para inspeccionar todas las tramas Ethernet que pasan entre ellos usando <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> en la interfaz bridge, o enviando una copia de todas las tramas hacia un interfaz adicional conocido como un puerto span.</p></dd><dt class=hdlist1>VPN en la Capa 2</dt><dd><p>Dos redes Ethernet se pueden unir mediante un enlace IP uniendo las redes a un túnel EtherIP o a una solución basada en <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> como OpenVPN.</p></dd><dt class=hdlist1>Redundancia en la Capa 2</dt><dd><p>Una red puede estar conectada con múltiples enlaces y usar el Spanning Tree Protocol (STP) para bloquear caminos redundantes.</p></dd></dl></div><div class=paragraph><p>Esta sección describe cómo configurar un sistema FreeBSD como un bridge usando <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>. También hay disponible un driver bridge de netgraph, y se describe en <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se pude usar filtrado de paquetes con cualquier paquete de firewall que se enganche en el framework <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a>. El bridge se puede usar como un perfilador de tráfico con <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_habilitando_el_bridge>34.8.1. Habilitando el Bridge<a class=anchor href=#_habilitando_el_bridge></a></h3><div class=paragraph><p>En FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> es un módulo del kernel que se carga automáticamente cuando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> crea un interfaz bridge. También es posible compilar soporte para bridge en un kernel personalizado añadiendo <code>device if_bridge</code> al fichero de configuración del kernel personalizado.</p></div><div class=paragraph><p>El bridge se crea clonando una interfaz. Para crear la interfaz bridge:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>Cuando se crea una interfaz bridge, se le asigna automáticamente una dirección Ethernet generada de forma aleatoria. Los parámetros <code>maxaddr</code> y <code>timeout</code> controlan cuántas direcciones MAC puede mantener el bridge en su tabla de reenvío y cuántos segundos deben pasar para eliminarla desde la última vez que han sido vistas. Los otros parámetros controlan cómo opera STP.</p></div><div class=paragraph><p>Después, especifica qué interfaces de red añadir como miembros del bridge. Para que el bridge sea capaz de reenviar paquetes, todas las interfaces y el bridge necesitan estar levantadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>El puente ahora puede reenviar tramas Ethernet entre <span class=filename>fxp0</span> y <span class=filename>fxp1</span>. Añade las siguientes líneas a <span class=filename>/etc/rc.conf</span> de forma que el bridge se cree al arrancar:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>Si la máquina bridge necesita una dirección IP, establécela en la interfaz del bridge, no en las interfaces que son miembro. La dirección puede establecerse estáticamente o vía DHCP. Este ejemplo establece una dirección IP estática:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>También es posible establecer una dirección IPv6 al interfaz del bridge. Para hacer los cambios permanentes, añade la información de la dirección a <span class=filename>/etc/rc.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cuando el filtrado de paquetes está habilitado, los paquetes que van por el bridge pasarán a través del filtro de entrada en la interfaz de origen en el interfaz del bridge, y de salida en las interfaces apropiadas. Cualquiera de las dos fases puede deshabilitarse. Cuando la dirección de un paquete es importante, es mejor aplicar el firewall en las interfaces que forman el bridge que en el bridge en sí mismo.</p></div><div class=paragraph><p>El bridge tiene varios valores configurables para pasar paquetes IP y no IP, y firewall the capa 2 con <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> para más información.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_activando_spanning_tree>34.8.2. Activando Spanning Tree<a class=anchor href=#_activando_spanning_tree></a></h3><div class=paragraph><p>Para que una red Ethernet funcione adecuadamente, sólo debe existir un camino activo entre dos dispositivos. El protocolo STP detecta bucles y pone enlaces redundantes en un estado bloqueado. Si uno de los enlaces activos fallara, STP calcula un árbol diferente y activa uno de los caminos bloqueados para restaurar la conectividad a todos los puntos de la red.</p></div><div class=paragraph><p>El protocolo Rapid Spanning Tree (RSTP o 802.1w) proporciona compatibilidad hacia atrás con el STP antiguo. RSTP proporciona una convergencia más rápida e intercambia información con switches vecinos para transicionar rápidamente a modo reenvío sin crear bycles. FreeBSD soporta como modos de operación RSTP y STP, siendo RSTP el modo por defecto.</p></div><div class=paragraph><p>Se puede activar STP en las interfaces miembro usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Para un bridge con <span class=filename>fxp0</span> y <span class=filename>fxp1</span> como interfaces actuales, activa STP con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Este bridge tiene un spanning tree con un ID de <code>00:01:02:4b:d4:50</code> y una prioridad de <code>32768</code>. Como el <code>root id</code> es el mismo, eso indica que es el bridge raíz del árbol.</p></div><div class=paragraph><p>Otro bridge en la red tiene STP activado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>La línea <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> muestra que el bridge raíz es <code>00:01:02:4b:d4:50</code> y que tiene un camino con coste <code>400000</code> desde este bridge. La ruta al brige raíz es vía <code>port 4</code> que es <span class=filename>fxp0</span>.</p></div></div><div class=sect2><h3 id=_parámetros_de_la_interfaz_del_bridge>34.8.3. Parámetros de la Interfaz del Bridge<a class=anchor href=#_parámetros_de_la_interfaz_del_bridge></a></h3><div class=paragraph><p>Varios parámetros de <code>ifconfig</code> son únicos de las interfaces del bridge. Esta sección resume algunos casos comunes para estos parámetros. <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> describe la lista completa de parámetros disponibles.</p></div><div class=dlist><dl><dt class=hdlist1>private</dt><dd><p>Una interfaz privada no reenvía nada de tráfico a otro puerto que no esté designado como una interfaz privada. El tráfico se bloquea incondicionalmente de forma que las tramas Ethernet no serán reenviadas, incluyendo los paquetes ARP. Si se necesita bloquear el tráfico de forma selectiva, se tiene que usar un firewall.</p></dd><dt class=hdlist1>span</dt><dd><p>Un puerto span transmite una copia de cada trama Ethernet recibida en el bridge. El número de puertos span configurados en el bridge es ilimitado, pero si una interfaz es designada como un puerto span, no puede ser usada también como un puerto regular en el bridge. Esto es muy útil para husmear en una red con bridge de forma pasiva en otro host conectado a uno de los puertos span del bridge. Por ejemplo, para enviar una copia de todas las tramas obtenidas de la interfaz <span class=filename>fxp4</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>Si una interfaz del bridge es marcada como sticky, las entradas de direcciones aprendidas dinámicamente se tratan como entradas estáticas en la caché de reenvío. Las entradas sticky no envejecen nunca en la caché ni son reemplazadas, incluso si la dirección es vista en otra interfaz. Esto ofrece el beneficio de las entradas de direcciones estáticas sin la necesidad de poblar la tabla de reenvío con antelación. Los clientes que se han aprendido de un segmento del bridge en particular no pueden moverse a otro segmento.</p><div class=paragraph><p>Un ejemplo de uso de direcciones sticky es combinar el bridge con VLANs para aislar redes cliente sin gastar espacio de direcciones IP. Considera que <code>CustomerA</code> está en <code>vlan100</code>, <code>CustomerB</code> está en <code>vlan101</code>, y el bridge tiene la dirección <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>En este ejemplo, ambos clientes ven <code>192.168.0.1</code> como su gateway por defecto. Puesto que la caché del bridge es sticky, un host no puede falsear la dirección MAC de otro cliente para interceptar su tráfico.</p></div><div class=paragraph><p>Cualquier comunicación entre las VLANs se puede bloquear utilizando un firewall o, como se ve en este ejemplo, usando interfaces privadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>Los clientes están completamente aislados entre sí y el rango de direcciones completo <code>/24</code> se puede reservar sin necesidad de crear subredes.</p></div><div class=paragraph><p>Se puede limitar el número direcciones MAC fuente únicas detrás de una interfaz. Una vez que se alcance el límite, los paquetes que tengan una dirección de origen desconocida serán descartados hasta que una entrada existente de caché en el host que expire o que sea eliminada.</p></div><div class=paragraph><p>El siguiente ejemplo establece el número máximo de dispositivos Ethernet a 10 para <code>CustomerA</code> en <code>vlan100</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>Las interfaces del bridge también soportan modo monitor, donde los paquetes son descartados después de haber sido procesados por <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> y no se procesan más ni se reenvían. Esto se puede usar para multiplexar la entrada de dos o más interfaces en un único flujo <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>. Esto es útil para reconstruir el tráfico de redes que transmiten las señales RX/TX hacia fuera usando dos interfaces separadas. Por ejemplo, para leer la entrada desde cuatro interfaces de red como un único flujo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect2><h3 id=_monitorización_snmp>34.8.4. Monitorización SNMP<a class=anchor href=#_monitorización_snmp></a></h3><div class=paragraph><p>El interfaz bridge y los parámetros STP se pueden monitorizar con <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> que se incluye con el sistema base FreeBSD. Las MIBs del bridge exportadas siguen el estándar IETF de forma que se puede usar cualquier cliente SNMP o paquete de monitorización para recuperar los datos.</p></div><div class=paragraph><p>Para habilitar la monitorización en el bridge, descomenta esta línea en <span class=filename>/etc/snmpd.config</span> eliminando el símbolo <code>#</code> al comienzo:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Podría ser necesario modificar en este fichero otros valores de configuración, como los nombres de la comunidad y listas de acceso. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a>. Una vez guardados los cambios, añade esta línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Después, arranca <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>Los siguientes ejemplos usan el software Net-SNMP (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>) para consultar un bridge desde un sistema cliente. También se puede usar el port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a>. Desde el cliente SNMP que está ejecutando Net-SNMP, añade las siguientes líneas a <span class=filename>$HOME/.snmp/snmp.conf</span> para importar las definiciones MIB del bridge:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>Para monitorizar un sólo bridge usando IETF BRIDGE-MIB (RFC4188):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>El valor <code>dot1dStpTopChanges.0</code> es dos, lo que indica que la topología STP ha cambiado dos veces. Un cambio de topología significa que uno o más enlaces en la red han cambiado o fallado y se ha tenido que calcular un nuevo árbol. El valor <code>dot1dStpTimeSinceTopologyChange.0</code> mostrará cuándo sucede esto.</p></div><div class=paragraph><p>Para monitorizar múltiples interfaces del bridge, se puede usar el BEGEMOT-BRIDGE-MIB privado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>Para cambiar la interfaz del bridge que está siendo monitorizada mediante el subárbol <code>mib-2.dot1dBridge</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div></div><div class=sect1><h2 id=network-aggregation>34.9. Agregación de Enlaces y Conmutación<a class=anchor href=#network-aggregation></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD proporciona la interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> que se puede usar para agregar múltiples interfaces de red en una interfaz virtual para proporcionar tolerancia a fallos ("failover") y agregación de enlaces. El failover permite que el tráfico continúe fluyendo mientras haya al menos una interfaz de red que tenga establecido un enlace. La agregación de enlaces funciona mejor en switches que soportan LACP, ya que este protocolo distribuye el tráfico de forma bidireccional a la vez que responde al fallo de enlaces individuales.</p></div><div class=paragraph><p>Los protocolos de agregación soportados por el interfaz lagg determinan qué puertos se usan para tráfico saliente y si un puerto específico acepta o no tráfico de entrada. Los siguientes protocolos están soportados por <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>:</p></div><div class=dlist><dl><dt class=hdlist1>failover</dt><dd><p>Este modo envía y recibe tráfico sólo a través del puerto maestro. Si el puerto maestro no está disponible, se usa el siguiente puerto activo. La primera interfaz añadida a la interfaz virtual es el puerto maestro y todas las interfaces añadidas posteriormente se usan como dispositivos redundantes. Si se produce un cambio a un puerto no maestro, el puerto original se convierte en maestro una vez que esté disponible de nuevo.</p></dd><dt class=hdlist1>loadbalance</dt><dd><p>Esto proporciona una configuración estática y no negocia agregación con los pares o intercambia marcos para monitorizar el enlace. Si el switch soporta LACP, se debería usar en su lugar.</p></dd><dt class=hdlist1>lacp</dt><dd><p>El protocolo IEEE® 802.3ad Link Aggregation Control Protocol (LACP) negocia un conjunto de enlaces agregables con el par en uno o más grupos "Link Aggregated Groups" (LAGs). Cada LAG se compone de puertos con la misma velocidad, conjunto de operaciones full-duplex, y el tráfico se balancea entre los puertos en el LAG con la velocidad total mayor. Típicamente, sólo hay un LAG que contiene todos los puertos. En el caso de cambios en la conectividad física, LACP convergerá rápido a una nueva configuración.</p><div class=paragraph><p>LACP balancea el tráfico de salida a lo largo de los puestos activos basándose en un hash de la cabecera de información del protocolo y acepta tráfico de entrada de cualquier puerto activo. El hash incluye la fuente Ehternet y la dirección de destino y, si está disponible, la etiqueta VLAN, y las direcciones de fuente y destino IPv4 o IPv6.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>Este modo distribuye el tráfico de salida utilizando un planificador round-robin entre todos los puertos activos y acepta tráfico de entrada desde cualquier puerto activo. Puesto que esto viola el orden de las tramas Ethernet, debería ser usado con precaución.</p></dd><dt class=hdlist1>broadcast</dt><dd><p>Este modo envía tráfico de salida a todos los puertos configurados en la interfaz lagg, y recibe tramas desde cualquier puerto.</p></dd></dl></div><div class=sect2><h3 id=_ejemplos_de_configuración>34.9.1. Ejemplos de Configuración<a class=anchor href=#_ejemplos_de_configuración></a></h3><div class=paragraph><p>Esta sección muestra cómo configurar un switch Cisco® y un sistema FreeBSD para hacer balanceado de carga LACP. Después muestra cómo configurar dos interfaces Ethernet en modo failover así como cómo configurar el modo failover entre una interfaz Ethernet y otra inalámbrica.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>Ejemplo 1. Agregación LACP con un Switch Cisco®</div><div class=content><div class=paragraph><p>Este ejemplo conecta dos interfaces Ethernet <a href="https://man.freebsd.org/cgi/man.cgi?query=fcp&amp;sektion=4&amp;format=html">fcp(4)</a> en una máquina FreeBSD con los dos primeros puertos Ethernet en un switch Cisco® como un enlace único de balanceo de carga y tolerante a fallos. Se pueden añadir más interfaces para incrementar la productividad y la tolerancia a fallos. Reemplaza los nombres de los puertos Cisco®, dispositivos Ethernet, número de grupo del canal, y dirección IP como se muestra en el ejemplo para adaptarlo a la configuración local.</p></div><div class=paragraph><p>El orden de las tramas es obligatorio en los enlaces Ethernet y cualquier tráfico entre dos estaciones siempre debe fluir por el mismo enlace físico, limitando la velocidad máxima a aquella de un interfaz. El algoritmo de transmisión intenta usar la mayor cantidad de información posible para distinguir entre distintos flujos de tráfico y balancear los flujos entre las interfaces disponibles.</p></div><div class=paragraph><p>En el switch Cisco®, añade las interfaces <em>FastEthernet0/1</em> y <em>FastEthernet0/2</em> al grupo del canal <em>1</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>En el sistema FreeBSD, crea el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> usando las interfaces físicas <em>fxp0</em> y <em>fxp1</em> y levanta las interfaces con la dirección IP <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Después, verifica el estado de la interfaz virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Los puertos marcados como <code>ACTIVE</code> forman parte del LAG que se ha negociado con el switch remoto. El tráfico será transmitido y recibido a través de estos puertos activos. Añade <code>-v</code> al comando de arriba para ver los identificadores LAG.</p></div><div class=paragraph><p>Para ver el estado del puerto en el switch Cisco®:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>Para más detalles, teclea <code>show lacp neighbor detail</code>.</p></div><div class=paragraph><p>Para mantener esta configuración entre reinicios, añade las siguientes entradas en el fichero [.filename]#/etc/rc.conf#del sistema FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>Ejemplo 2. Modo Failover</div><div class=content><div class=paragraph><p>El modo failover se puede usar para cambiar a un interfaz secundario si se pierde el enlace en el interfaz maestro. Para configurar failover, asegúrate de que las interfaces físicas están levantadas, después crea el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>. En este ejemplo, <em>fxp0</em> es la interfaz maestra, <em>fxp1</em> es la interfaz secundaria, y el interfaz virtual tiene asignada la dirección IP <em>10.0.0.15/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>La interfaz virtual debería tener un aspecto parecido a este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>El tráfico será transmitido y recibido en <em>fxp0</em>. Si se pierde el enlace en <em>fxp0</em>, <em>fxp1</em> se convertirá en el enlace activo. Si se restaura el enlace en la interfaz maestra, se convertirá de nuevo en el enlace activo.</p></div><div class=paragraph><p>Para mantener esta configuración entre reinicios, añade las siguientes entradas en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>Ejemplo 3. Modo Failover Entre Interfaces Ethernet y Wireless</div><div class=content><div class=paragraph><p>Para los usuarios de portátiles, normalmente es deseable configurar el dispositivo inalámbrico como un secundario que sólo usa cuando la conexión Ethernet no está disponible. Con <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>, es posible configurar un failover que prefiera la conexión Ethernet tanto por rendimiento como por razones de seguridad, mientras que se mantiene la posibilidad de transferir datos por la conexión inalámbrica.</p></div><div class=paragraph><p>Esto se consigue sobrescribiendo la dirección MAC del interfaz Ethernet con el de la interfaz inalámbrica.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>En teoría, cualquiera de las dos direcciones MAC (Ethernet o inalámbrica) se puede cambiar para igualarse a la otra. Sin embargo, algunas interfaces inalámbricas populares carecen del soporte para sobrescribir la dirección MAX. Por lo tanto para este propósito recomendamos sobrescribir la dirección MAC Ethernet.</p></div></div></div><div class=sidebarblock><div class=content><div class=paragraph><p>Si el controlador para el interfaz inalámbrico no está cargado en el kernel <code>GENERIC</code> o en el personalizado, y el ordenador está ejecutando FreeBSD12.1, carga el <span class=filename>.ko</span> correspondiente en <span class=filename>/boot/loader.conf</span> añadiendo <code><strong>driver_load="YES"</strong></code> a ese fichero y después reiniciando. Otra forma mejor es cargar el driver en <span class=filename>/etc/rc.conf</span> añadiéndolo a <code>kld_list</code> (consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para los detalles) en ese fichero y reiniciando. Esto es necesario porque de otra forma el controlador no está todavía cargado en el momento en el que se configura el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>.</p></div></div></div><div class=paragraph><p>En este ejemplo, el interfaz Ethernet, <em>re0</em>, es el maestro y el interfaz inalámbrico, <em>wlan0</em>, es el recambio. El interfaz <em>wlan0</em> ha sido creado a partir del interfaz inalámbrico físico <em>ath0</em>, y el interfaz Ethernet se configurará con la dirección MAC del interfaz inalámbrico. Primero, levanta el interfaz inalámbrico (reemplaza <em>FR</em> con tu código de país de dos letras), pero no establezcas una dirección IP. Reemplaza <em>wlan0</em> con el nombre del interfaz inalámbrico del sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 country FR ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Ahora puedes saber la dirección MAC del interfaz inalámbrico:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether b8:ee:65:5b:32:59
	<span class=nb>groups</span>: wlan
	ssid Bbox-A3BD2403 channel 6 <span class=o>(</span>2437 MHz 11g ht/20<span class=o>)</span> bssid 00:37:b7:56:4b:60
	regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
	deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
	protmode CTS ampdulimit 64k ampdudensity 8 shortgi <span class=nt>-stbctx</span> stbcrx
	<span class=nt>-ldpc</span> wme burst roaming MANUAL
	media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
	status: associated
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</code></pre></div></div><div class=paragraph><p>La línea <code>ether</code> contendrá la dirección MAC del interfaz especificado. Ahora, cambia la dirección MAC del interfaz Ethernet para que concuerde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 ether b8:ee:65:5b:32:59</span></code></pre></div></div><div class=paragraph><p>Asegúrate de que el interfaz <em>re0</em> está levantado, luego crea el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> con <em>re0</em> como maestro con <em>wlan0</em> como recambio:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>La interfaz virtual debería tener un aspecto parecido a este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether b8:ee:65:5b:32:59
        laggproto failover lagghash l2,l3,l4
        laggport: re0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        <span class=nb>groups</span>: lagg
        media: Ethernet autoselect
        status: active</code></pre></div></div><div class=paragraph><p>Después, arranca el cliente DHCP para obtener una dirección IP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>Para mantener esta configuración entre reinicios, añade las siguientes entradas en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_re0=&#34;ether b8:ee:65:5b:32:59&#34;
wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;country FR&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport re0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=network-diskless>34.10. Operación sin Disco con PXE<a class=anchor href=#network-diskless></a></h2><div class=sectionbody><div class=paragraph><p>El Preboot eXecution Environment (PXE) de Intel® permite a un sistema operativo arrancar por red. Por ejemplo, un sistema FreeBSD puede arrancar sobre la red y operar sin un disco local, usando sistemas de ficheros montados desde un servidor NFS. El soporte de PXE normalmente está disponible en la BIOS. Para usar PXE cuando arranca la máquina, selecciona la opción <code>Arrancar desde la red</code> en la configuración de la BIOS o teclea una tecla de función durante la inicialización del sistema.</p></div><div class=paragraph><p>Para proporcionar a un sistema operativo los ficheros necesarios para que arranque sobre la red, la configuración de PXE también necesita configurar apropiadamente DHCP, TFTP y los servidores NFS, donde:</p></div><div class=ulist><ul><li><p>Parámetros iniciales, como una dirección IP, el nombre del fichero ejecutable de arranque y su localización, el nombre del servidor, y la ruta raíz se obtienen del servidor DHCP.</p></li><li><p>El fichero del cargador del sistema operativo se obtiene mediante TFTP.</p></li><li><p>Los sistemas de ficheros se cargan usando NFS.</p></li></ul></div><div class=paragraph><p>Cuando un ordenador arranca mediante PXE, recibe información a través de DHCP sobre dónde obtener el fichero inicial del cargador de arranque. Después de que el ordenador recibe esta información, descarga el cargador de arranque vía TFTP y después ejecuta el cargador de arranque. En FreeBSD, el fichero del cargador de arranque es <span class=filename>/boot/pxeboot</span>. Después de que <span class=filename>/boot/pxeboot</span> se ejecute, se carga el kernel de FreeBSD y el resto de la secuencia de arranque de FreeBSD prosigue su curso como se describe en <a href=../boot/#boot>El Proceso de Arranque de FreeBSD</a>.</p></div><div class=paragraph><p>Esta sección describe cómo configurar estos servicios en un sistema FreeBSD de forma que otros sistemas puedan arrancar mediante PXE en FreeBSD. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> para más información.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Como se ha descrito, el sistema que proporciona estos servicios no es seguro. Debería vivir en un área protegida de la red y otros hosts no deberían confiar en él.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=network-pxe-nfs>34.10.1. Configurando el Entorno PXE<a class=anchor href=#network-pxe-nfs></a></h3><div class=paragraph><p>Las pasos que se muestran en esta sección configuran los servidores NFS y TFTP incluidos. La siguiente sección muestra cómo instalar y configurar el servidor DHCP. En este ejemplo, el dirección que contendrá los ficheros usados por los usuarios PXE es <span class=filename>/b/tftpboot/FreeBSD/install</span>. Es importante que este directorio exista y que el nombre del directorio esté configurado tanto en <span class=filename>/etc/inetd.conf</span> como en <span class=filename>/usr/local/etc/dhcpd.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los ejemplos de comandos que siguen asumen el uso del shell <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Los usuarios de <a href="https://man.freebsd.org/cgi/man.cgi?query=chs&amp;sektion=1&amp;format=html">chs(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> tendrán que iniciar un shell <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> o adaptar los comandos a la sintaxis de <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>.</p></div></td></tr></tbody></table></div><div class="olist arabic procedure"><ol class=arabic><li><p>Crea el directorio raíz que contendrá la instalación de FreeBSD que será montada por NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Activa el servidor NFS añadiendo esta línea a <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Exporta el directorio raíz del sistema sin disco vía NFS añadiendo lo siguiente a <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Arranca el servidor NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Activa <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> añadiendo la siguiente línea a <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Descomenta la siguiente línea en <span class=filename>/etc/inetd.conf</span> asegurándote de que no comienza con un símbolo <code>#</code>:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunas versiones de PXE necesitan la versión TCP de TFTP. En este caso, descomenta la segunda línea <code>tftp</code> que contiene <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Arranca <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Instala el sistema base en <span class=filename>${NFSROOTDIR}</span>, bien descomprimiendo los archivos oficiales o recompilando el kernel de FreeBSD y el espacio de usuario (consulta <a href=../cutting-edge/#makeworld>“Actualizando FreeBSD desde las Fuentes”</a> para instrucciones más detalladas, pero no olvides añadir <code>DESTDIR=<em>${NFSROOTDIR}</em></code> cuando ejecutes los comands <code>make installkernel</code> y <code>make installworld</code>.</p></li><li><p>Comprueba que el servidor TFTP funciona y que puede descargar el cargador de arranque que se obtendrá vía PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Edita <span class=filename>${NFSROOTDIR}/etc/fstab</span> y crea una entrada para montar el sistema de ficheros raíz sobre NFS:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Reemplaza <em>myhost.example.com</em> con el nombre de la máquina o la dirección IP del servidor NFS. En este ejemplo, el sistema de ficheros raíz está montado como solo lectura para evitar que los clientes NFS puedan borrar los contenidos del sistema de ficheros raíz.</p></div></li><li><p>Establece la contraseña de root en el entorno PXE para las máquinas cliente que están arrancando mediante PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>Si es necesario, habilita el inicio de sesión de root en <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> para las máquinas cliente que arrancan con PXE editando <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> y habilitando <code>PermitRootLogin</code>. Esta opción está documentada en <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a>.</p></li><li><p>Realiza cualquier otra personalización del entorno PXE en <span class=filename>${NFSROOTDIR}</span>. Estas personalizaciones podrían incluir cosas como instalación de paquetes o editar el fichero de contraseñas con <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div><div class=paragraph><p>Cuando se arranca desde un volumen raíz NFS, <span class=filename>/etc/rc</span> detecta el arranque NFS y ejecuta <span class=filename>/etc/rc.initdiskless</span>. En este caso se necesita que <span class=filename>/etc</span> y <span class=filename>/var</span> estén cargados den memoria de forma que estos directorios sean escribibles pero el directorio raíz NFS sea de sólo escritura:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>Cuando el sistema arranca, los sistemas de fichero en memoria para <span class=filename>/etc</span> y <span class=filename>/var</span> se crearán y montarán y el contenido de los ficheros <span class=filename>cpio.gz</span> se copiará dentro de ellos. Por defecto, estos sistemas de ficheros tienen una capacidad máxima de 5 megabytes. Si tus archivos no caben, que es habitualmente el caso para <span class=filename>/var</span> cuando se han instalado paquetes binarios, solicita más tamaño poniendo el número de sectores de 512 bytes necesarios (por ejemplo, 5 megabytes es 10240 sectores) en <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> y <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> para los sistemas de ficheros <span class=filename>/etc</span> y <span class=filename>/var</span> respectivamente.</p></div></div><div class=sect2><h3 id=network-pxe-setting-up-dhcp>34.10.2. Configurando el Servidor DHCP<a class=anchor href=#network-pxe-setting-up-dhcp></a></h3><div class=paragraph><p>El servidor DHCP no necesita estar en la misma máquina que los servidores de TFTP y NFS, pero necesita estar accesible en la red.</p></div><div class=paragraph><p>DHCP no es parte del sistema base de FreeBSD pero se puede instalar usando el port o paquete <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a>.</p></div><div class=paragraph><p>Una vez instalado, edita el fichero de configuración, <span class=filename>/usr/local/etc/dhcpd.conf</span>. Configura las opciones <code>next-server</code>, <code>filename</code>, y <code>root-path</code> como se ve en este ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre></div></div><div class=paragraph><p>La directiva <code>next-server</code> se usa para especificar la dirección IP del servidor TFTP.</p></div><div class=paragraph><p>La directiva <code>filename</code> define la ruta a <span class=filename>/boot/pxeboot</span>. Se usa un nombre de fichero relativo, lo que significa que <span class=filename>/b/tftpboot</span> no está incluido en la ruta.</p></div><div class=paragraph><p>La opción <code>root-path</code> define la ruta al sistema de ficheros raíz NFS.</p></div><div class=paragraph><p>Una vez salvados los cambios, activa DHCP durante el arranque añadiendo la siguiente línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Después inicia el servicio DHCP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect2><h3 id=_depurando_problemas_en_pxe>34.10.3. Depurando problemas en PXE<a class=anchor href=#_depurando_problemas_en_pxe></a></h3><div class=paragraph><p>Una vez que todos los servicios están configurados y arrancados, los clientes PXE deberían ser capaces de cargar automáticamente FreeBSD a través de la red. Si un cliente particular no es capaz de conectar, cuando ese cliente arranque, entra en el menú de configuración de la BIO y confirma que está configurado para arrancar desde la red.</p></div><div class=paragraph><p>Esta sección describe algunos consejos para resolución de problemas para aislar la fuente del problema de configuración si los clientes no fueran capaces de arrancar mediante PXE.</p></div><div class="sidebarblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Usa el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> para depurar el tráfico de red involucrado en el proceso de arranque de PXE, el cual se ilustra en el diagrama inferior.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>Figura 1. Proceso de Arranque de PXE con Punto de Montaje Raíz NFS</div></div><div class="olist arabic"><ol class=arabic><li><p>El cliente emite un mensaje DHCPDISCOVER.</p></li><li><p>El servidor DHCP responde con los valores para la dirección IP, next-server, filename y root-path.</p></li><li><p>El cliente envía una solicitud TFTP a next-server, pidiendo recuperar un nombre de archivo.</p></li><li><p>El servidor TFTP responde y envía el fichero al cliente.</p></li><li><p>El cliente ejecuta el fichero, que es pxeboot(8), que luego carga el kernel. Cuando el kernel se ejecuta, el sistema de ficheros raíz especificado por root-path es montado a través de NFS.</p></li></ol></div></li><li><p>En el servidor TFTP, lee <span class=filename>/var/log/xferlog</span> para asegurar que se está recuperando <span class=filename>pxeboot</span> desde el lugar correcto. Prueba con este ejemplo de configuración:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>La sección <code>BUGS</code> en <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a> documentan algunas limitaciones con TFTP.</p></div></li><li><p>Asegúrate de que el sistema de ficheros raíz se puede montar vía NFS. Puedes probar con esta configuración de ejemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=carp>34.11. Common Address Redundancy Protocol (CARP)<a class=anchor href=#carp></a></h2><div class=sectionbody><div class=paragraph><p>El protocolo CARP (Common Address Redundancy Protocol) permite a múltiples hosts compartir la misma dirección IP y VHID (Virtual Host ID) para proporcionar <em>alta disponibilidad</em> para uno o más servicios. Este significa que uno o más hosts pueden fallar, y los otros hosts se harán cargo de forma transparente de forma que los usuarios no verán un fallo de servicio.</p></div><div class=paragraph><p>Además de la dirección IP compartida, cada host tiene su propia dirección IP para gestión y configuración. Todas las máquinas que comparten una dirección IP tienen el mismo VHID. El VHID para cada dirección IP virtual debe ser única en el dominio broadcast del interfaz de red.</p></div><div class=paragraph><p>La alta disponibilidad con CARP está incluida en FreeBSD, aunque los pasos para configurarla varían ligeramente dependiendo de la versión de FreeBSD. Esta sección proporciona la misma configuración de ejemplo para versiones anteriores, iguales o posteriores a FreeBSD 10.</p></div><div class=paragraph><p>Este ejemplo configura soporte para failover con tres hosts, todos con una única dirección IP, pero proporcionando el mismo contenido web. Tiene dos maestros diferentes llamados <code>hosta.example.org</code> y <code>hostb.example.org</code>, con un respaldo compartido llamado <code>hostc.example.org</code>.</p></div><div class=paragraph><p>Estas máquinas están balanceadas con un DNS con figurado en Round Robin . Las máquinas maestro y el respaldo están configuradas de forma idéntica excepto por los nombres de host y las direcciones IP de gestión. Estos servidores deben tener la misma configuración y ejecutar los mismos servicios. Cuando se produce un failover, las peticiones al servicio en la dirección IP compartida sólo pueden ser contestadas correctamente si el servidor de respaldo tiene acceso al mismo contenido. La máquina de respaldo tiene dos interfaces CARP adicionales, una para cada dirección IP de los servidores maestros. Cuando ocurre un fallo, el servidor de respaldo pillará la dirección IP de la máquina del maestro que haya fallado.</p></div><div class=sect2><h3 id=carp-10x>34.11.1. Usando CARP en FreeBSD 10 y Posterior<a class=anchor href=#carp-10x></a></h3><div class=paragraph><p>Activa el soporte de CARP en el arranque añadiendo una entrada para el módulo del kernel <span class=filename>carp.ko</span> en <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para cargar el módulo ahora sin reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para los usuarios que prefieren usar un kernel personalizado, incluye la siguiente línea en el fichero de configuración del kernel personalizado y compila como se describe en <a href=../kernelconfig/#kernelconfig>Configurando el Kernel de FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>El nombre de host, dirección IP de gestión y su máscara de subred, la dirección IP compartida, y el VHID se configuran añadiendo entradas en <span class=filename>/etc/rc.conf</span>. Este ejemplo es para <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>El siguiente conjunto de entradas es para <code>hostb.example.org</code>. Puesto que representa un segundo maestro, utiliza una dirección IP compartida y VHID diferentes. Sin embargo, la contraseña especificada con <code>pass</code> debe ser idéntica ya que CARP sólo escuchará y aceptará notificaciones de las máquinas que tengan la contraseña correcta.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>La tercer máquina, <code>hostc.example.org</code>, está configurada para manejar el failover de cualquiera de los maestros. Esta máquina está configurada con dos CARPVHIDS, uno para manejar cada dirección IP virtual de cada host maestro. El desvío de notificaciones CARP, <code>advskew</code>, está configurado para asegurar que el host de respaldo notifica más tarde que el maestro, puesto que <code>advskew</code> controla el orden de precedencia cuando hay varios servidores de reemplazo.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Tener dos CARPVHIDs configurados significa que <code>hostc.example.org</code> se dará cuenta si alguno de los maestros no se encuentra disponible. Si un maestro no es capaz de notificar antes que el servidor de reemplazo, el servidor de reemplazo usará la dirección IP compartida hasta que el maestro esté disponible de nuevo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si el maestro original vuelve a estar disponible, <code>hostc.example.org</code> no liberará la dirección IP virtual automáticamente. Para que esto suceda, se tiene que habilitar la preemptividad. Esto está deshabilitado por defecto, está controlado mediante la variable <code>net.inet.carp.preempt</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. El administrador puede forzar a que el servidor de reemplazo devuelva la dirección IP al maestro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez completada la configuración, reinicia la red o reinicia cada sistema. Ahora la alta disponibilidad está habilitada.</p></div><div class=paragraph><p>La funcionalidad CARP se puede controlar mediante varias variables de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> que están documentadas en las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a>. Se pueden disparar otras acciones a partir de eventos CARP usando <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>.</p></div></div><div class=sect2><h3 id=carp-9x>34.11.2. Usando CARP en FreeBSD 9 y Anteriores<a class=anchor href=#carp-9x></a></h3><div class=paragraph><p>La configuración para estas versiones de FreeBSD es similar a la descrita en la sección previa, excepto que se tiene que crear primero un dispositivo CARP y hacer referencia a él en la configuración.</p></div><div class=paragraph><p>Activa el soporte de CARP al arrancar cargando el módulo del kernel <span class=filename>if_carp.ko</span> en <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para cargar el módulo ahora sin reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para los usuarios que prefieren usar un kernel personalizado, incluye la siguiente línea en el fichero de configuración del kernel personalizado y compila como se describe en <a href=../kernelconfig/#kernelconfig>Configurando el Kernel de FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>Después, en cada host, crea un dispositivo CARP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Establece el nombre de host, dirección IP de gestión, dirección IP compartida, y VHID añadiendo las líneas necesarias a <span class=filename>/etc/rc.conf</span>. Puesto que se usa un dispositivo CARP virtual en lugar de un alias, se usa la máscara de subred <code>/24</code> en lugar de <code>/32</code>. Aquí están las entradas para <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>En <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>La tercera máquina, <code>hostc.example.org</code>, se configura para manejar el failover de cualquiera de los hosts maestros:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La preemptividad está deshabilitada en el kernel <span class=filename>GENERIC</span> de FreeBSD. Si la preemptividad se ha habilitado con un kernel personalizado <code>hostc.example.org</code> podría no devolver la dirección IP al servidor original. El administrador puede forzar que el servidor de reemplazo devuelve al dirección IP al maestro con el comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>Esto se debería hacer en la interfaz <span class=filename>carp</span> que se corresponda con el host correcto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez completada la configuración, reinicia la red o reinicia cada sistema. Ahora la alta disponibilidad está habilitada.</p></div></div></div></div><div class=sect1><h2 id=network-vlan>34.12. VLANs<a class=anchor href=#network-vlan></a></h2><div class=sectionbody><div class=paragraph><p>VLANs son una forma de dividir una red de forma virtual en muchas subredes diferentes, también llamado segmentación. Cada segmento tendrá su dominio broadcast y está aislado de otras VLANs.</p></div><div class=paragraph><p>En FreeBSD, las VLANs tienen que estar soportadas por el controlador de la tarjeta de red. Para ver qué controladores soportan vlans, consulta la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a>.</p></div><div class=paragraph><p>Cuando se configura una VLAN, se tienen que conocer un par de datos. Primero, ¿qué interfaz de red? Segundo, ¿cuál es la etiqueta de la VLAN?</p></div><div class=paragraph><p>Para configurar una VLAN en tiempo de ejecución, con un NIC de <code>em0</code> y una etiqueta de VLAN de <code>5</code> el comando se parecería a este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>¿Te has fijado en cómo el nombre de la interfaz incluye el nombre del controlador del NIC y la etiqueta VLAN, separados por un punto? Esta es la mejor forma de mantener la configuración de la VLAN sencilla cuando hay muchas VLANs en la máquina.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para configurar VLANs en el arranque, se tiene que actualizar <span class=filename>/etc/rc.conf</span>. Para duplicar la configuración de arriba, se tiene que añadir lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>Se pueden añadir VLANs adicionales, simplemente añadiendo la etiqueta al campo <code>vlans_em0</code> y añadiendo una línea adicional configurando la red en la interfaz de esa etiqueta VLAN.</p></div><div class=paragraph><p>Es útil asignar un nombre simbólico a una interfaz de forma que cuando el hardware asociado cambie, sólo se necesiten actualizar unas pocas variables de configuración. Por ejemplo, las cámaras de seguridad necesitan ejecutarse sobre VLAN 1 en <code>em0</code>. Después, si la tarjeta <code>em0</code> es reemplazada con una tarjeta que utiliza el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a>, no habrá que cambiar a <code>ixgb0.1</code> todas las referencias a <code>em0.1</code>.</p></div><div class=paragraph><p>Para configurar la VLAN <code>5</code>, en el NIC <code>em0</code>, asigna el nombre de interfaz <code>cameras</code>, y asignar al interfaz la dirección IP <code><em>192.168.20.20</em></code> con un prefijo de <code>24</code> bits, usa este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para un interfaz llamado <code>video</code>, usa lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para aplicar los cambios en el arranque, añade las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;cameras&#34;
create_args_cameras=&#34;vlan 5&#34;
ifconfig_cameras=&#34;inet 192.168.20.20/24&#34;</pre></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9 de marzo de 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Anterior></i><div class=container><a href=https://docs.freebsd.org/es/books/handbook/firewalls class=direction>Anterior</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Inicio></i><div class=container><a href=../ class=direction>Inicio</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/es/books/handbook/partv class=direction>Siguiente</a></div><i class="fa fa-angle-right" aria-hidden=true title=Siguiente></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>34.1. Sinopsis</a></li><li><a href=#network-routing>34.2. Gateways y Rutas</a></li><li><a href=#configtuning-virtual-hosts>34.3. Hosts Virtuales</a></li><li><a href=#network-advanced-wireless>34.4. Autenticación Inalámbrica Avanzada</a></li><li><a href=#wireless-ad-hoc-mode>34.5. Modo Ad-hoc Inalámbrico</a></li><li><a href=#network-usb-tethering>34.6. Tethering USB</a></li><li><a href=#network-bluetooth>34.7. Bluetooth</a></li><li><a href=#network-bridging>34.8. Bridging</a></li><li><a href=#network-aggregation>34.9. Agregación de Enlaces y Conmutación</a></li><li><a href=#network-diskless>34.10. Operación sin Disco con PXE</a></li><li><a href=#carp>34.11. Common Address Redundancy Protocol (CARP)</a></li><li><a href=#network-vlan>34.12. VLANs</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/books/handbook/handbook_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/_index target=_blank>Editar esta página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/es/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>