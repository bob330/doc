<!doctype html><html class=theme-light lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Common Access Method SCSI Controllers"><meta name=keywords content="SCSI,Controller,Architecture"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/><title>Chapter 12. Common Access Method SCSI Controllers | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapter 12. Common Access Method SCSI Controllers"><meta property="og:description" content="Common Access Method SCSI Controllers"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="http://172.16.201.134:1313/en/books/arch-handbook/scsi/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/en\/books\/arch-handbook\/scsi\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/en/books>Books</a></li><li><a href=http://172.16.201.134:1313/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-6dcd22d99f78db2a9aacae23be13866e class=toggle>
<label for=chapter-6dcd22d99f78db2a9aacae23be13866e><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/parti/>Part I. Kernel</a></li><li><input type=checkbox id=chapter-9cc61bc35df69063dc03a5911e1ad9c9 class=toggle>
<label class="icon cursor" for=chapter-9cc61bc35df69063dc03a5911e1ad9c9><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/>Chapter 1. Bootstrapping and Kernel Initialization</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-synopsis>1.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-overview>1.2. Overview</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-bios>1.3. The BIOS</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-boot0>1.4. The Master Boot Record (<code>boot0</code>)</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-boot1>1.5. <code>boot1</code> Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#btx-server>1.6. The BTX Server</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot2>1.7. boot2 Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-loader>1.8. loader Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-kernel>1.9. Kernel Initialization</a></li></ul></li><li><input type=checkbox id=chapter-3a651b0a4b9f6238336624d3c0fa5187 class=toggle>
<label class="icon cursor" for=chapter-3a651b0a4b9f6238336624d3c0fa5187><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/>Chapter 2. Locking Notes</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-mutexes>2.1. Mutexes</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-sx>2.2. Shared Exclusive Locks</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-atomic>2.3. Atomically Protected Variables</a></li></ul></li><li><input type=checkbox id=chapter-bf0b823c107a80f3035dfd6fae09d023 class=toggle>
<label class="icon cursor" for=chapter-bf0b823c107a80f3035dfd6fae09d023><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/>Chapter 3. Kernel Objects</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-term>3.1. Terminology</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-operation>3.2. Kobj Operation</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-using>3.3. Using Kobj</a></li></ul></li><li><input type=checkbox id=chapter-41dab1afed6cf3ffa54628db4227e196 class=toggle>
<label class="icon cursor" for=chapter-41dab1afed6cf3ffa54628db4227e196><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/>Chapter 4. The Jail Subsystem</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/#jail-arch>4.1. Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/#jail-restrictions>4.2. Restrictions</a></li></ul></li><li><input type=checkbox id=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8 class=toggle>
<label class="icon cursor" for=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/>Chapter 5. The SYSINIT Framework</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-term>5.1. Terminology</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-operation>5.2. SYSINIT Operation</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-using>5.3. Using SYSINIT</a></li></ul></li><li><input type=checkbox id=chapter-8b57b16ba53538421a8fb2152b25976f class=toggle>
<label class="icon cursor" for=chapter-8b57b16ba53538421a8fb2152b25976f><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/>Chapter 6. The TrustedBSD MAC Framework</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-copyright>6.1. MAC Documentation Copyright</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-synopsis>6.2. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-introduction>6.3. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-background>6.4. Policy Background</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-framework-kernel-arch>6.5. MAC Framework Kernel Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-policy-architecture>6.6. MAC Policy Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-entry-point-reference>6.7. MAC Policy Entry Point Reference</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-userland-arch>6.8. Userland Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-conclusion>6.9. Conclusion</a></li></ul></li><li><input type=checkbox id=chapter-28609916419208e3a19d240cf7593906 class=toggle>
<label class="icon cursor" for=chapter-28609916419208e3a19d240cf7593906><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/>Chapter 7. Virtual Memory System</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-physmem>7.1. Management of Physical Memory <code>vm_page_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-cache>7.2. The Unified Buffer Cache <code>vm_object_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-fileio>7.3. Filesystem I/O <code>struct buf</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-pagetables>7.4. Mapping Page Tables <code>vm_map_t, vm_entry_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-kvm>7.5. KVM Memory Mapping</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-tuning>7.6. Tuning the FreeBSD VM System</a></li></ul></li><li><input type=checkbox id=chapter-716edd44e8ad22ea57cdf273d2578872 class=toggle>
<label class="icon cursor" for=chapter-716edd44e8ad22ea57cdf273d2578872><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/>Chapter 8. SMPng Design Document</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-intro>8.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-lock-fundamentals>8.2. Basic Tools and Locking Fundamentals</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-design>8.3. General Architecture and Design</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-lock-strategies>8.4. Specific Locking Strategies</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-implementation-notes>8.5. Implementation Notes</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-misc>8.6. Miscellaneous Topics</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-glossary>Glossary</a></li></ul></li><li><input type=checkbox id=chapter-448f803e40f97b1ff8336db9ba637745 class=toggle>
<label for=chapter-448f803e40f97b1ff8336db9ba637745><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/partii/>Part II. Device Drivers</a></li><li><input type=checkbox id=chapter-6971d35b0bbe2a0bdb005a02546cd580 class=toggle>
<label class="icon cursor" for=chapter-6971d35b0bbe2a0bdb005a02546cd580><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/>Chapter 9. Writing FreeBSD Device Drivers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-intro>9.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-kld>9.2. Dynamic Kernel Linker Facility - KLD</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-char>9.3. Character Devices</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-block>9.4. Block Devices (Are Gone)</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-net>9.5. Network Drivers</a></li></ul></li><li><input type=checkbox id=chapter-9cc7968be065b256e57086439d93e9a4 class=toggle>
<label class="icon cursor" for=chapter-9cc7968be065b256e57086439d93e9a4><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/>Chapter 10. ISA Device Drivers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-synopsis>10.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-basics>10.2. Basic Information</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-device-t>10.3. <code>device_t</code> Pointer</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-resources>10.5. Resources</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-busmem>10.6. Bus Memory Mapping</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-dma>10.7. DMA</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-probe>10.8. xxx_isa_probe</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-attach>10.9. xxx_isa_attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-detach>10.10. xxx_isa_detach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-shutdown>10.11. xxx_isa_shutdown</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-intr>10.12. xxx_intr</a></li></ul></li><li><input type=checkbox id=chapter-0b427d421e89aa3107f62d5b70f6a0f2 class=toggle>
<label class="icon cursor" for=chapter-0b427d421e89aa3107f62d5b70f6a0f2><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/>Chapter 11. PCI Devices</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/#pci-probe>11.1. Probe and Attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/#pci-bus>11.2. Bus Resources</a></li></ul></li><li><input type=checkbox id=chapter-0b7eb8d45a0ea6bc9c2882e903b93959 class=toggle checked>
<label class="icon cursor" for=chapter-0b7eb8d45a0ea6bc9c2882e903b93959><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/>Chapter 12. Common Access Method SCSI Controllers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-synopsis>12.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-general>12.2. General Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_globals_and_boilerplate>12.3. Globals and Boilerplate</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-polling>12.6. Polling xxx_poll</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-async>12.7. Asynchronous Events</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-interrupts>12.8. Interrupts</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-errors>12.9. Errors Summary</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-timeout>12.10. Timeout Handling</a></li></ul></li><li><input type=checkbox id=chapter-bdaa4909dfbdcec8d7be976fd87cb00e class=toggle>
<label class="icon cursor" for=chapter-bdaa4909dfbdcec8d7be976fd87cb00e><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/>Chapter 13. USB Devices</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-intro>13.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-hc>13.2. Host Controllers</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-dev>13.3. USB Device Information</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-devprobe>13.4. Device Probe and Attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-protocol>13.5. USB Drivers Protocol Information</a></li></ul></li><li><input type=checkbox id=chapter-5fc5c179f5014d968a5c8feec7e10e59 class=toggle>
<label class="icon cursor" for=chapter-5fc5c179f5014d968a5c8feec7e10e59><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/>Chapter 14. Newbus</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-devdrivers>14.1. Device Drivers</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-overview>14.2. Overview of Newbus</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-api>14.3. Newbus API</a></li></ul></li><li><input type=checkbox id=chapter-7d3796cced00105c77e7f87e84edd73b class=toggle>
<label class="icon cursor" for=chapter-7d3796cced00105c77e7f87e84edd73b><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/>Chapter 15. Sound Subsystem</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-intro>15.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-files>15.2. Files</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#pcm-probe-and-attach>15.3. Probing, Attaching, etc.</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-interfaces>15.4. Interfaces</a></li></ul></li><li><input type=checkbox id=chapter-41c74c3e72fcf5116f6d999c36ef185b class=toggle>
<label class="icon cursor" for=chapter-41c74c3e72fcf5116f6d999c36ef185b><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/pccard/>Chapter 16. PC Card</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pccard/#pccard-adddev>16.1. Adding a Device</a></li></ul></li><li><input type=checkbox id=chapter-2a7cf37011599a8e3d62d1e3008c3c5d class=toggle>
<label for=chapter-2a7cf37011599a8e3d62d1e3008c3c5d><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/partiii/>Part III. Appendices</a></li><li><input type=checkbox id=chapter-d4c82056f0235da9fde0d29203d44f9a class=toggle>
<label for=chapter-d4c82056f0235da9fde0d29203d44f9a><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/bibliography/>Bibliography</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapter 12. Common Access Method SCSI Controllers</h1><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#scsi-synopsis>12.1. Synopsis</a></li><li><a href=#scsi-general>12.2. General Architecture</a></li><li><a href=#_globals_and_boilerplate>12.3. Globals and Boilerplate</a></li><li><a href=#_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach</a></li><li><a href=#_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action</a></li><li><a href=#scsi-polling>12.6. Polling xxx_poll</a></li><li><a href=#scsi-async>12.7. Asynchronous Events</a></li><li><a href=#scsi-interrupts>12.8. Interrupts</a></li><li><a href=#scsi-errors>12.9. Errors Summary</a></li><li><a href=#scsi-timeout>12.10. Timeout Handling</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=scsi-synopsis>12.1. Synopsis<a class=anchor href=#scsi-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>This document assumes that the reader has a general understanding of device drivers in FreeBSD and of the SCSI protocol.
Much of the information in this document was extracted from the drivers:</p></div><div class=ulist><ul><li><p>ncr (<span class=filename>/sys/pci/ncr.c</span>) by Wolfgang Stanglmeier and Stefan Esser</p></li><li><p>sym (<span class=filename>/sys/dev/sym/sym_hipd.c</span>) by Gerard Roudier</p></li><li><p>aic7xxx (<span class=filename>/sys/dev/aic7xxx/aic7xxx.c</span>) by Justin T. Gibbs</p></li></ul></div><div class=paragraph><p>and from the CAM code itself (by Justin T. Gibbs, see <span class=filename>/sys/cam/*</span>).
When some solution looked the most logical and was essentially verbatim extracted from the code by Justin T. Gibbs, I marked it as "recommended".</p></div><div class=paragraph><p>The document is illustrated with examples in pseudo-code.
Although sometimes the examples have many details and look like real code, it is still pseudo-code.
It was written to demonstrate the concepts in an understandable way.
For a real driver other approaches may be more modular and efficient.
It also abstracts from the hardware details, as well as issues that would cloud the demonstrated concepts or that are supposed to be described in the other chapters of the developers handbook.
Such details are commonly shown as calls to functions with descriptive names, comments or pseudo-statements.
Fortunately real life full-size examples with all the details can be found in the real drivers.</p></div></div></div><div class=sect1><h2 id=scsi-general>12.2. General Architecture<a class=anchor href=#scsi-general></a></h2><div class=sectionbody><div class=paragraph><p>CAM stands for Common Access Method.
It is a generic way to address the I/O buses in a SCSI-like way.
This allows a separation of the generic device drivers from the drivers controlling the I/O bus: for example the disk driver becomes able to control disks on both SCSI, IDE, and/or any other bus so the disk driver portion does not have to be rewritten (or copied and modified) for every new I/O bus.
Thus the two most important active entities are:</p></div><div class=ulist><ul><li><p><em>Peripheral Modules</em> - a driver for peripheral devices (disk, tape, CD-ROM, etc.)</p></li><li><p><em>SCSI Interface Modules</em> (SIM) - a Host Bus Adapter drivers for connecting to an I/O bus such as SCSI or IDE.</p></li></ul></div><div class=paragraph><p>A peripheral driver receives requests from the OS, converts them to a sequence of SCSI commands and passes these SCSI commands to a SCSI Interface Module.
The SCSI Interface Module is responsible for passing these commands to the actual hardware (or if the actual hardware is not SCSI but, for example, IDE then also converting the SCSI commands to the native commands of the hardware).</p></div><div class=paragraph><p>As we are interested in writing a SCSI adapter driver here, from this point on we will consider everything from the SIM standpoint.</p></div></div></div><div class=sect1><h2 id=_globals_and_boilerplate>12.3. Globals and Boilerplate<a class=anchor href=#_globals_and_boilerplate></a></h2><div class=sectionbody><div class=paragraph><p>A typical SIM driver needs to include the following CAM-related header files:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;cam/cam.h&gt;
#include &lt;cam/cam_ccb.h&gt;
#include &lt;cam/cam_sim.h&gt;
#include &lt;cam/cam_xpt_sim.h&gt;
#include &lt;cam/cam_debug.h&gt;
#include &lt;cam/scsi/scsi_all.h&gt;</pre></div></div></div></div><div class=sect1><h2 id=_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach<a class=anchor href=#_device_configuration_xxx_attach></a></h2><div class=sectionbody><div class=paragraph><p>The first thing each SIM driver must do is register itself with the CAM subsystem.
This is done during the driver’s <code>xxx_attach()</code> function (here and further xxx_ is used to denote the unique driver name prefix).
The <code>xxx_attach()</code> function itself is called by the system bus auto-configuration code which we do not describe here.</p></div><div class=paragraph><p>This is achieved in multiple steps: first it is necessary to allocate the queue of requests associated with this SIM:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct cam_devq *devq;

    if ((devq = cam_simq_alloc(SIZE)) == NULL) {
        error; /* some code to handle the error */
    }</pre></div></div><div class=paragraph><p>Here <code>SIZE</code> is the size of the queue to be allocated, maximal number of requests it could contain.
It is the number of requests that the SIM driver can handle in parallel on one SCSI card.
Commonly it can be calculated as:</p></div><div class="literalblock programlisting"><div class=content><pre>SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET</pre></div></div><div class=paragraph><p>Next we create a descriptor of our SIM:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct cam_sim *sim;

    if ((sim = cam_sim_alloc(action_func, poll_func, driver_name,
            softc, unit, mtx, max_dev_transactions,
            max_tagged_dev_transactions, devq)) == NULL) {
        cam_simq_free(devq);
        error; /* some code to handle the error */
    }</pre></div></div><div class=paragraph><p>Note that if we are not able to create a SIM descriptor we free the <code>devq</code> also because we can do nothing else with it and we want to conserve memory.</p></div><div class=paragraph><p>If a SCSI card has multiple SCSI buses on it then each bus requires its own <code>cam_sim</code> structure.</p></div><div class=paragraph><p>An interesting question is what to do if a SCSI card has more than one SCSI bus, do we need one <code>devq</code> structure per card or per SCSI bus?
The answer given in the comments to the CAM code is: either way, as the driver’s author prefers.</p></div><div class=paragraph><p>The arguments are:</p></div><div class=ulist><ul><li><p><code>action_func</code> - pointer to the driver’s <code>xxx_action</code> function.</p></li></ul></div><div class="literalblock programlisting"><div class=content><pre>static void xxx_action(struct cam_sim *, union ccb *);</pre></div></div><div class=ulist><ul><li><p><code>poll_func</code> - pointer to the driver’s <code>xxx_poll()</code></p><div class="literalblock programlisting"><div class=content><pre>static void xxx_poll(struct cam_sim *);</pre></div></div></li><li><p>driver_name - the name of the actual driver, such as "ncr" or "wds".</p></li><li><p><code>softc</code> - pointer to the driver’s internal descriptor for this SCSI card.
This pointer will be used by the driver in future to get private data.</p></li><li><p>unit - the controller unit number, for example for controller "mps0" this number will be 0</p></li><li><p>mtx - Lock associated with this SIM.
For SIMs that don’t know about locking, pass in Giant.
For SIMs that do, pass in the lock used to guard this SIM’s data structures.
This lock will be held when xxx_action and xxx_poll are called.</p></li><li><p>max_dev_transactions - maximal number of simultaneous transactions per SCSI target in the non-tagged mode.
This value will be almost universally equal to 1, with possible exceptions only for the non-SCSI cards.
Also the drivers that hope to take advantage by preparing one transaction while another one is executed may set it to 2 but this does not seem to be worth the complexity.</p></li><li><p>max_tagged_dev_transactions - the same thing, but in the tagged mode.
Tags are the SCSI way to initiate multiple transactions on a device: each transaction is assigned a unique tag and the transaction is sent to the device.
When the device completes some transaction it sends back the result together with the tag so that the SCSI adapter (and the driver) can tell which transaction was completed.
This argument is also known as the maximal tag depth.
It depends on the abilities of the SCSI adapter.</p></li></ul></div><div class=paragraph><p>Finally we register the SCSI buses associated with our SCSI adapter:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {
        cam_sim_free(sim, /*free_devq*/ TRUE);
        error; /* some code to handle the error */
    }</pre></div></div><div class=paragraph><p>If there is one <code>devq</code> structure per SCSI bus (i.e., we consider a card with multiple buses as multiple cards with one bus each) then the bus number will always be 0, otherwise each bus on the SCSI card should be get a distinct number.
Each bus needs its own separate structure cam_sim.</p></div><div class=paragraph><p>After that our controller is completely hooked to the CAM system.
The value of <code>devq</code> can be discarded now: sim will be passed as an argument in all further calls from CAM and devq can be derived from it.</p></div><div class=paragraph><p>CAM provides the framework for such asynchronous events.
Some events originate from the lower levels (the SIM drivers), some events originate from the peripheral drivers, some events originate from the CAM subsystem itself.
Any driver can register callbacks for some types of the asynchronous events, so that it would be notified if these events occur.</p></div><div class=paragraph><p>A typical example of such an event is a device reset.
Each transaction and event identifies the devices to which it applies by the means of "path".
The target-specific events normally occur during a transaction with this device.
So the path from that transaction may be re-used to report this event (this is safe because the event path is copied in the event reporting routine but not deallocated nor passed anywhere further).
Also it is safe to allocate paths dynamically at any time including the interrupt routines, although that incurs certain overhead, and a possible problem with this approach is that there may be no free memory at that time.
For a bus reset event we need to define a wildcard path including all devices on the bus.
So we can create the path for the future bus reset events in advance and avoid problems with the future memory shortage:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct cam_path *path;

    if (xpt_create_path(&amp;path, /*periph*/NULL,
                cam_sim_path(sim), CAM_TARGET_WILDCARD,
                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {
        xpt_bus_deregister(cam_sim_path(sim));
        cam_sim_free(sim, /*free_devq*/TRUE);
        error; /* some code to handle the error */
    }

    softc-&gt;wpath = path;
    softc-&gt;sim = sim;</pre></div></div><div class=paragraph><p>As you can see the path includes:</p></div><div class=ulist><ul><li><p>ID of the peripheral driver (NULL here because we have none)</p></li><li><p>ID of the SIM driver (<code>cam_sim_path(sim)</code>)</p></li><li><p>SCSI target number of the device (CAM_TARGET_WILDCARD means "all devices")</p></li><li><p>SCSI LUN number of the subdevice (CAM_LUN_WILDCARD means "all LUNs")</p></li></ul></div><div class=paragraph><p>If the driver can not allocate this path it will not be able to work normally, so in that case we dismantle that SCSI bus.</p></div><div class=paragraph><p>And we save the path pointer in the <code>softc</code> structure for future use.
After that we save the value of sim (or we can also discard it on the exit from <code>xxx_probe()</code> if we wish).</p></div><div class=paragraph><p>That is all for a minimalistic initialization.
To do things right there is one more issue left.</p></div><div class=paragraph><p>For a SIM driver there is one particularly interesting event: when a target device is considered lost.
In this case resetting the SCSI negotiations with this device may be a good idea.
So we register a callback for this event with CAM.
The request is passed to CAM by requesting CAM action on a CAM control block for this type of request:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb_setasync csa;

    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);
    csa.ccb_h.func_code = XPT_SASYNC_CB;
    csa.event_enable = AC_LOST_DEVICE;
    csa.callback = xxx_async;
    csa.callback_arg = sim;
    xpt_action((union ccb *)&amp;csa);</pre></div></div></div></div><div class=sect1><h2 id=_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action<a class=anchor href=#_processing_cam_messages_xxx_action></a></h2><div class=sectionbody><div class="literalblock programlisting"><div class=content><pre>static void xxx_action(struct cam_sim *sim, union ccb *ccb);</pre></div></div><div class=paragraph><p>Do some action on request of the CAM subsystem.
Sim describes the SIM for the request, CCB is the request itself.
CCB stands for "CAM Control Block".
It is a union of many specific instances, each describing arguments for some type of transactions.
All of these instances share the CCB header where the common part of arguments is stored.</p></div><div class=paragraph><p>CAM supports the SCSI controllers working in both initiator ("normal") mode and target (simulating a SCSI device) mode.
Here we only consider the part relevant to the initiator mode.</p></div><div class=paragraph><p>There are a few function and macros (in other words, methods) defined to access the public data in the struct sim:</p></div><div class=ulist><ul><li><p><code>cam_sim_path(sim)</code> - the path ID (see above)</p></li><li><p><code>cam_sim_name(sim)</code> - the name of the sim</p></li><li><p><code>cam_sim_softc(sim)</code> - the pointer to the softc (driver private data) structure</p></li><li><p><code>cam_sim_unit(sim)</code> - the unit number</p></li><li><p><code>cam_sim_bus(sim)</code> - the bus ID</p></li></ul></div><div class=paragraph><p>To identify the device, <code>xxx_action()</code> can get the unit number and pointer to its structure softc using these functions.</p></div><div class=paragraph><p>The type of request is stored in <code>ccb→ccb_h.func_code</code>.
So generally <code>xxx_action()</code> consists of a big switch:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);
    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;
    int unit = cam_sim_unit(sim);
    int bus = cam_sim_bus(sim);

    switch (ccb_h-&gt;func_code) {
    case ...:
        ...
    default:
        ccb_h-&gt;status = CAM_REQ_INVALID;
        xpt_done(ccb);
        break;
    }</pre></div></div><div class=paragraph><p>As can be seen from the default case (if an unknown command was received) the return code of the command is set into <code>ccb→ccb_h.status</code> and the completed CCB is returned back to CAM by calling <code>xpt_done(ccb)</code>.</p></div><div class=paragraph><p><code>xpt_done()</code> does not have to be called from <code>xxx_action()</code>: For example an I/O request may be enqueued inside the SIM driver and/or its SCSI controller.
Then when the device would post an interrupt signaling that the processing of this request is complete <code>xpt_done()</code> may be called from the interrupt handling routine.</p></div><div class=paragraph><p>Actually, the CCB status is not only assigned as a return code but a CCB has some status all the time.
Before CCB is passed to the <code>xxx_action()</code> routine it gets the status CCB_REQ_INPROG meaning that it is in progress.
There are a surprising number of status values defined in <span class=filename>/sys/cam/cam.h</span> which should be able to represent the status of a request in great detail.
More interesting yet, the status is in fact a "bitwise or" of an enumerated status value (the lower 6 bits) and possible additional flag-like bits (the upper bits).
The enumerated values will be discussed later in more detail.
The summary of them can be found in the Errors Summary section.
The possible status flags are:</p></div><div class=ulist><ul><li><p><em>CAM_DEV_QFRZN</em> - if the SIM driver gets a serious error (for example, the device does not respond to the selection or breaks the SCSI protocol) when processing a CCB it should freeze the request queue by calling <code>xpt_freeze_simq()</code>, return the other enqueued but not processed yet CCBs for this device back to the CAM queue, then set this flag for the troublesome CCB and call <code>xpt_done()</code>.
This flag causes the CAM subsystem to unfreeze the queue after it handles the error.</p></li><li><p><em>CAM_AUTOSNS_VALID</em> - if the device returned an error condition and the flag CAM_DIS_AUTOSENSE is not set in CCB the SIM driver must execute the REQUEST SENSE command automatically to extract the sense (extended error information) data from the device.
If this attempt was successful the sense data should be saved in the CCB and this flag set.</p></li><li><p><em>CAM_RELEASE_SIMQ</em> - like CAM_DEV_QFRZN but used in case there is some problem (or resource shortage) with the SCSI controller itself.
Then all the future requests to the controller should be stopped by <code>xpt_freeze_simq()</code>.
The controller queue will be restarted after the SIM driver overcomes the shortage and informs CAM by returning some CCB with this flag set.</p></li><li><p><em>CAM_SIM_QUEUED</em> - when SIM puts a CCB into its request queue this flag should be set (and removed when this CCB gets dequeued before being returned back to CAM).
This flag is not used anywhere in the CAM code now, so its purpose is purely diagnostic.</p></li><li><p><em>CAM_QOS_VALID</em> - The QOS data is now valid.</p></li></ul></div><div class=paragraph><p>The function <code>xxx_action()</code> is not allowed to sleep, so all the synchronization for resource access must be done using SIM or device queue freezing.
Besides the aforementioned flags the CAM subsystem provides functions <code>xpt_release_simq()</code> and <code>xpt_release_devq()</code> to unfreeze the queues directly, without passing a CCB to CAM.</p></div><div class=paragraph><p>The CCB header contains the following fields:</p></div><div class=ulist><ul><li><p><em>path</em> - path ID for the request</p></li><li><p><em>target_id</em> - target device ID for the request</p></li><li><p><em>target_lun</em> - LUN ID of the target device</p></li><li><p><em>timeout</em> - timeout interval for this command, in milliseconds</p></li><li><p><em>timeout_ch</em> - a convenience place for the SIM driver to store the timeout handle (the CAM subsystem itself does not make any assumptions about it)</p></li><li><p><em>flags</em> - various bits of information about the request spriv_ptr0, spriv_ptr1 - fields reserved for private use by the SIM driver (such as linking to the SIM queues or SIM private control blocks); actually, they exist as unions: spriv_ptr0 and spriv_ptr1 have the type (void *), spriv_field0 and spriv_field1 have the type unsigned long, sim_priv.entries[0].bytes and sim_priv.entries[1].bytes are byte arrays of the size consistent with the other incarnations of the union and sim_priv.bytes is one array, twice bigger.</p></li></ul></div><div class=paragraph><p>The recommended way of using the SIM private fields of CCB is to define some meaningful names for them and use these meaningful names in the driver, like:</p></div><div class="literalblock programlisting"><div class=content><pre>#define ccb_some_meaningful_name    sim_priv.entries[0].bytes
#define ccb_hcb spriv_ptr1 /* for hardware control block */</pre></div></div><div class=paragraph><p>The most common initiator mode requests are:</p></div><div class=sect2><h3 id=_xpt_scsi_io_execute_an_io_transaction>12.5.1. <em>XPT_SCSI_IO</em> - execute an I/O transaction<a class=anchor href=#_xpt_scsi_io_execute_an_io_transaction></a></h3><div class=paragraph><p>The instance "struct ccb_scsiio csio" of the union ccb is used to transfer the arguments.
They are:</p></div><div class=ulist><ul><li><p><em>cdb_io</em> - pointer to the SCSI command buffer or the buffer itself</p></li><li><p><em>cdb_len</em> - SCSI command length</p></li><li><p><em>data_ptr</em> - pointer to the data buffer (gets a bit complicated if scatter/gather is used)</p></li><li><p><em>dxfer_len</em> - length of the data to transfer</p></li><li><p><em>sglist_cnt</em> - counter of the scatter/gather segments</p></li><li><p><em>scsi_status</em> - place to return the SCSI status</p></li><li><p><em>sense_data</em> - buffer for the SCSI sense information if the command returns an error (the SIM driver is supposed to run the REQUEST SENSE command automatically in this case if the CCB flag CAM_DIS_AUTOSENSE is not set)</p></li><li><p><em>sense_len</em> - the length of that buffer (if it happens to be higher than size of sense_data the SIM driver must silently assume the smaller value)</p></li><li><p><em>resid</em>, <em>sense_resid</em> - if the transfer of data or SCSI sense returned an error these are the returned counters of the residual (not transferred) data.
They do not seem to be especially meaningful, so in a case when they are difficult to compute (say, counting bytes in the SCSI controller’s FIFO buffer) an approximate value will do as well.
For a successfully completed transfer they must be set to zero.</p></li><li><p><em>tag_action</em> - the kind of tag to use:</p><div class=ulist><ul><li><p>CAM_TAG_ACTION_NONE - do not use tags for this transaction</p></li><li><p>MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - value equal to the appropriate tag message (see /sys/cam/scsi/scsi_message.h); this gives only the tag type, the SIM driver must assign the tag value itself</p></li></ul></div></li></ul></div><div class=paragraph><p>The general logic of handling this request is the following:</p></div><div class=paragraph><p>The first thing to do is to check for possible races, to make sure that the command did not get aborted when it was sitting in the queue:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;

    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {
        xpt_done(ccb);
        return;
    }</pre></div></div><div class=paragraph><p>Also we check that the device is supported at all by our controller:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID
    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {
        ccb_h-&gt;status = CAM_TID_INVALID;
        xpt_done(ccb);
        return;
    }
    if (ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {
        ccb_h-&gt;status = CAM_LUN_INVALID;
        xpt_done(ccb);
        return;
    }</pre></div></div><div class=paragraph><p>Then allocate whatever data structures (such as card-dependent hardware control block) we need to process this request.
If we can not then freeze the SIM queue and remember that we have a pending operation, return the CCB back and ask CAM to re-queue it.
Later when the resources become available the SIM queue must be unfrozen by returning a ccb with the <code>CAM_SIMQ_RELEASE</code> bit set in its status.
Otherwise, if all went well, link the CCB with the hardware control block (HCB) and mark it as queued.</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);

    if (hcb == NULL) {
        softc-&gt;flags |= RESOURCE_SHORTAGE;
        xpt_freeze_simq(sim, /*count*/1);
        ccb_h-&gt;status = CAM_REQUEUE_REQ;
        xpt_done(ccb);
        return;
    }

    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;
    ccb_h-&gt;status |= CAM_SIM_QUEUED;</pre></div></div><div class=paragraph><p>Extract the target data from CCB into the hardware control block.
Check if we are asked to assign a tag and if yes then generate an unique tag and build the SCSI tag messages.
The SIM driver is also responsible for negotiations with the devices to set the maximal mutually supported bus width, synchronous rate and offset.</p></div><div class="literalblock programlisting"><div class=content><pre>    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-&gt;target_lun;
    generate_identify_message(hcb);
    if (ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE)
        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);
    if (!target_negotiated(hcb))
        generate_negotiation_messages(hcb);</pre></div></div><div class=paragraph><p>Then set up the SCSI command.
The command storage may be specified in the CCB in many interesting ways, specified by the CCB flags.
The command buffer can be contained in CCB or pointed to, in the latter case the pointer may be physical or virtual.
Since the hardware commonly needs physical address we always convert the address to the physical one, typically using the busdma API.</p></div><div class=paragraph><p>In case if a physical address is requested it is OK to return the CCB with the status <code>CAM_REQ_INVALID</code>, the current drivers do that.
If necessary a physical address can be also converted or mapped back to a virtual address but with big pain, so we do not do that.</p></div><div class="literalblock programlisting"><div class=content><pre>    if (ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {
        /* CDB is a pointer */
        if (!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {
            /* CDB pointer is virtual */
            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);
        } else {
            /* CDB pointer is physical */
            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;
        }
    } else {
        /* CDB is in the ccb (buffer) */
        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);
    }
    hcb-&gt;cmdlen = csio-&gt;cdb_len;</pre></div></div><div class=paragraph><p>Now it is time to set up the data.
Again, the data storage may be specified in the CCB in many interesting ways, specified by the CCB flags.
First we get the direction of the data transfer.
The simplest case is if there is no data to transfer:</p></div><div class="literalblock programlisting"><div class=content><pre>    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);

    if (dir == CAM_DIR_NONE)
        goto end_data;</pre></div></div><div class=paragraph><p>Then we check if the data is in one chunk or in a scatter-gather list, and the addresses are physical or virtual.
The SCSI controller may be able to handle only a limited number of chunks of limited length.
If the request hits this limitation we return an error.
We use a special function to return the CCB to handle in one place the HCB resource shortages.
The functions to add chunks are driver-dependent, and here we leave them without detailed implementation.
See description of the SCSI command (CDB) handling for the details on the address-translation issues.
If some variation is too difficult or impossible to implement with a particular card it is OK to return the status <code>CAM_REQ_INVALID</code>.
Actually, it seems like the scatter-gather ability is not used anywhere in the CAM code now.
But at least the case for a single non-scattered virtual buffer must be implemented, it is actively used by CAM.</p></div><div class="literalblock programlisting"><div class=content><pre>    int rv;

    initialize_hcb_for_data(hcb);

    if ((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {
        /* single buffer */
        if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {
            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);
            }
        } else {
            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);
        }
    } else {
        int i;
        struct bus_dma_segment *segs;
        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;

        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {
            /* The SG list pointer is physical */
            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-&gt;sglist_cnt);
        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {
            /* SG buffer pointers are virtual */
            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {
                rv = add_virtual_chunk(hcb, segs[i].ds_addr,
                    segs[i].ds_len, dir);
                if (rv != CAM_REQ_CMP)
                    break;
            }
        } else {
            /* SG buffer pointers are physical */
            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {
                rv = add_physical_chunk(hcb, segs[i].ds_addr,
                    segs[i].ds_len, dir);
                if (rv != CAM_REQ_CMP)
                    break;
            }
        }
    }
    if (rv != CAM_REQ_CMP) {
        /* we expect that add_*_chunk() functions return CAM_REQ_CMP
         * if they added a chunk successfully, CAM_REQ_TOO_BIG if
         * the request is too big (too many bytes or too many chunks),
         * CAM_REQ_INVALID in case of other troubles
         */
        free_hcb_and_ccb_done(hcb, ccb, rv);
        return;
    }
    end_data:</pre></div></div><div class=paragraph><p>If disconnection is disabled for this CCB we pass this information to the hcb:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)
        hcb_disable_disconnect(hcb);</pre></div></div><div class=paragraph><p>If the controller is able to run REQUEST SENSE command all by itself then the value of the flag CAM_DIS_AUTOSENSE should also be passed to it, to prevent automatic REQUEST SENSE if the CAM subsystem does not want it.</p></div><div class=paragraph><p>The only thing left is to set up the timeout, pass our hcb to the hardware and return, the rest will be done by the interrupt handler (or timeout handler).</p></div><div class="literalblock programlisting"><div class=content><pre>    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,
        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */
    put_hcb_into_hardware_queue(hcb);
    return;</pre></div></div><div class=paragraph><p>And here is a possible implementation of the function returning CCB:</p></div><div class="literalblock programlisting"><div class=content><pre>    static void
    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t status)
    {
        struct xxx_softc *softc = hcb-&gt;softc;

        ccb-&gt;ccb_h.ccb_hcb = 0;
        if (hcb != NULL) {
            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);
            /* we&#39;re about to free a hcb, so the shortage has ended */
            if (softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {
                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;
                status |= CAM_RELEASE_SIMQ;
            }
            free_hcb(hcb); /* also removes hcb from any internal lists */
        }
        ccb-&gt;ccb_h.status = status |
            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));
        xpt_done(ccb);
    }</pre></div></div></div><div class=sect2><h3 id=_xpt_reset_dev_send_the_scsi_bus_device_reset_message_to_a_device>12.5.2. <em>XPT_RESET_DEV</em> - send the SCSI "BUS DEVICE RESET" message to a device<a class=anchor href=#_xpt_reset_dev_send_the_scsi_bus_device_reset_message_to_a_device></a></h3><div class=paragraph><p>There is no data transferred in CCB except the header and the most interesting argument of it is target_id.
Depending on the controller hardware a hardware control block just like for the XPT_SCSI_IO request may be constructed (see XPT_SCSI_IO request description) and sent to the controller or the SCSI controller may be immediately programmed to send this RESET message to the device or this request may be just not supported (and return the status <code>CAM_REQ_INVALID</code>).
Also on completion of the request all the disconnected transactions for this target must be aborted (probably in the interrupt routine).</p></div><div class=paragraph><p>Also all the current negotiations for the target are lost on reset, so they might be cleaned too.
Or they clearing may be deferred, because anyway the target would request re-negotiation on the next transaction.</p></div></div><div class=sect2><h3 id=_xpt_reset_bus_send_the_reset_signal_to_the_scsi_bus>12.5.3. <em>XPT_RESET_BUS</em> - send the RESET signal to the SCSI bus<a class=anchor href=#_xpt_reset_bus_send_the_reset_signal_to_the_scsi_bus></a></h3><div class=paragraph><p>No arguments are passed in the CCB, the only interesting argument is the SCSI bus indicated by the struct sim pointer.</p></div><div class=paragraph><p>A minimalistic implementation would forget the SCSI negotiations for all the devices on the bus and return the status CAM_REQ_CMP.</p></div><div class=paragraph><p>The proper implementation would in addition actually reset the SCSI bus (possible also reset the SCSI controller) and mark all the CCBs being processed, both those in the hardware queue and those being disconnected, as done with the status CAM_SCSI_BUS_RESET.
Like:</p></div><div class="literalblock programlisting"><div class=content><pre>    int targ, lun;
    struct xxx_hcb *h, *hh;
    struct ccb_trans_settings neg;
    struct cam_path *path;

    /* The SCSI bus reset may take a long time, in this case its completion
     * should be checked by interrupt or timeout. But for simplicity
     * we assume here that it is really fast.
     */
    reset_scsi_bus(softc);

    /* drop all enqueued CCBs */
    for (h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
        hh = h-&gt;next;
        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
    }

    /* the clean values of negotiations to report */
    neg.bus_width = 8;
    neg.sync_period = neg.sync_offset = 0;
    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);

    /* drop all disconnected CCBs and clean negotiations  */
    for (targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {
        clean_negotiations(softc, targ);

        /* report the event if possible */
        if (xpt_create_path(&amp;path, /*periph*/NULL,
                cam_sim_path(sim), targ,
                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {
            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
            xpt_free_path(path);
        }

        for (lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
            for (h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {
                hh=h-&gt;next;
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
            }
    }

    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);

    /* report the event */
    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);
    return;</pre></div></div><div class=paragraph><p>Implementing the SCSI bus reset as a function may be a good idea because it would be re-used by the timeout function as a last resort if the things go wrong.</p></div></div><div class=sect2><h3 id=_xpt_abort_abort_the_specified_ccb>12.5.4. <em>XPT_ABORT</em> - abort the specified CCB<a class=anchor href=#_xpt_abort_abort_the_specified_ccb></a></h3><div class=paragraph><p>The arguments are transferred in the instance "struct ccb_abort cab" of the union ccb.
The only argument field in it is:</p></div><div class=ulist><ul><li><p><em>abort_ccb</em> - pointer to the CCB to be aborted</p></li></ul></div><div class=paragraph><p>If the abort is not supported just return the status CAM_UA_ABORT.
This is also the easy way to minimally implement this call, return CAM_UA_ABORT in any case.</p></div><div class=paragraph><p>The hard way is to implement this request honestly.
First check that abort applies to a SCSI transaction:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb *abort_ccb;
    abort_ccb = ccb-&gt;cab.abort_ccb;

    if (abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {
        ccb-&gt;ccb_h.status = CAM_UA_ABORT;
        xpt_done(ccb);
        return;
    }</pre></div></div><div class=paragraph><p>Then it is necessary to find this CCB in our queue.
This can be done by walking the list of all our hardware control blocks in search for one associated with this CCB:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_hcb *hcb, *h;

    hcb = NULL;

    /* We assume that softc-&gt;first_hcb is the head of the list of all
     * HCBs associated with this bus, including those enqueued for
     * processing, being processed by hardware and disconnected ones.
     */
    for (h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {
        if (h-&gt;ccb == abort_ccb) {
            hcb = h;
            break;
        }
    }

    if (hcb == NULL) {
        /* no such CCB in our queue */
        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;
        xpt_done(ccb);
        return;
    }

    hcb=found_hcb;</pre></div></div><div class=paragraph><p>Now we look at the current processing status of the HCB.
It may be either sitting in the queue waiting to be sent to the SCSI bus, being transferred right now, or disconnected and waiting for the result of the command, or actually completed by hardware but not yet marked as done by software.
To make sure that we do not get in any races with hardware we mark the HCB as being aborted, so that if this HCB is about to be sent to the SCSI bus the SCSI controller will see this flag and skip it.</p></div><div class="literalblock programlisting"><div class=content><pre>    int hstatus;

    /* shown as a function, in case special action is needed to make
     * this flag visible to hardware
     */
    set_hcb_flags(hcb, HCB_BEING_ABORTED);

    abort_again:

    hstatus = get_hcb_status(hcb);
    switch (hstatus) {
    case HCB_SITTING_IN_QUEUE:
        remove_hcb_from_hardware_queue(hcb);
        /* FALLTHROUGH */
    case HCB_COMPLETED:
        /* this is an easy case */
        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);
        break;</pre></div></div><div class=paragraph><p>If the CCB is being transferred right now we would like to signal to the SCSI controller in some hardware-dependent way that we want to abort the current transfer.
The SCSI controller would set the SCSI ATTENTION signal and when the target responds to it send an ABORT message.
We also reset the timeout to make sure that the target is not sleeping forever.
If the command would not get aborted in some reasonable time like 10 seconds the timeout routine would go ahead and reset the whole SCSI bus.
Since the command will be aborted in some reasonable time we can just return the abort request now as successfully completed, and mark the aborted CCB as aborted (but not mark it as done yet).</p></div><div class="literalblock programlisting"><div class=content><pre>    case HCB_BEING_TRANSFERRED:
        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);
        abort_ccb-&gt;ccb_h.timeout_ch =
            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);
        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;
        /* ask the controller to abort that HCB, then generate
         * an interrupt and stop
         */
        if (signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {
            /* oops, we missed the race with hardware, this transaction
             * got off the bus before we aborted it, try again */
            goto abort_again;
        }

        break;</pre></div></div><div class=paragraph><p>If the CCB is in the list of disconnected then set it up as an abort request and re-queue it at the front of hardware queue.
Reset the timeout and report the abort request to be completed.</p></div><div class="literalblock programlisting"><div class=content><pre>    case HCB_DISCONNECTED:
        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);
        abort_ccb-&gt;ccb_h.timeout_ch =
            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);
        put_abort_message_into_hcb(hcb);
        put_hcb_at_the_front_of_hardware_queue(hcb);
        break;
    }
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre></div></div><div class=paragraph><p>That is all for the ABORT request, although there is one more issue.
As the ABORT message cleans all the ongoing transactions on a LUN we have to mark all the other active transactions on this LUN as aborted.
That should be done in the interrupt routine, after the transaction gets aborted.</p></div><div class=paragraph><p>Implementing the CCB abort as a function may be quite a good idea, this function can be re-used if an I/O transaction times out.
The only difference would be that the timed out transaction would return the status CAM_CMD_TIMEOUT for the timed out request.
Then the case XPT_ABORT would be small, like that:</p></div><div class="literalblock programlisting"><div class=content><pre>    case XPT_ABORT:
        struct ccb *abort_ccb;
        abort_ccb = ccb-&gt;cab.abort_ccb;

        if (abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {
            ccb-&gt;ccb_h.status = CAM_UA_ABORT;
            xpt_done(ccb);
            return;
        }
        if (xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)
            /* no such CCB in our queue */
            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;
        else
            ccb-&gt;ccb_h.status = CAM_REQ_CMP;
        xpt_done(ccb);
        return;</pre></div></div></div><div class=sect2><h3 id=_xpt_set_tran_settings_explicitly_set_values_of_scsi_transfer_settings>12.5.5. <em>XPT_SET_TRAN_SETTINGS</em> - explicitly set values of SCSI transfer settings<a class=anchor href=#_xpt_set_tran_settings_explicitly_set_values_of_scsi_transfer_settings></a></h3><div class=paragraph><p>The arguments are transferred in the instance "struct ccb_trans_setting cts" of the union ccb:</p></div><div class=ulist><ul><li><p><em>valid</em> - a bitmask showing which settings should be updated:</p><div class=ulist><ul><li><p><em>CCB_TRANS_SYNC_RATE_VALID</em> - synchronous transfer rate</p></li><li><p><em>CCB_TRANS_SYNC_OFFSET_VALID</em> - synchronous offset</p></li><li><p><em>CCB_TRANS_BUS_WIDTH_VALID</em> - bus width</p></li><li><p><em>CCB_TRANS_DISC_VALID</em> - set enable/disable disconnection</p></li><li><p><em>CCB_TRANS_TQ_VALID</em> - set enable/disable tagged queuing</p></li></ul></div></li><li><p><em>flags</em> - consists of two parts, binary arguments and identification of sub-operations.
The binary arguments are:</p><div class=ulist><ul><li><p><em>CCB_TRANS_DISC_ENB</em> - enable disconnection</p></li><li><p><em>CCB_TRANS_TAG_ENB</em> - enable tagged queuing</p></li></ul></div></li><li><p>the sub-operations are:</p><div class=ulist><ul><li><p><em>CCB_TRANS_CURRENT_SETTINGS</em> - change the current negotiations</p></li><li><p><em>CCB_TRANS_USER_SETTINGS</em> - remember the desired user values sync_period, sync_offset - self-explanatory, if sync_offset==0 then the asynchronous mode is requested bus_width - bus width, in bits (not bytes)</p></li></ul></div></li></ul></div><div class=paragraph><p>Two sets of negotiated parameters are supported, the user settings and the current settings.
The user settings are not really used much in the SIM drivers, this is mostly just a piece of memory where the upper levels can store (and later recall) its ideas about the parameters.
Setting the user parameters does not cause re-negotiation of the transfer rates.
But when the SCSI controller does a negotiation it must never set the values higher than the user parameters, so it is essentially the top boundary.</p></div><div class=paragraph><p>The current settings are, as the name says, current.
Changing them means that the parameters must be re-negotiated on the next transfer.
Again, these "new current settings" are not supposed to be forced on the device, just they are used as the initial step of negotiations.
Also they must be limited by actual capabilities of the SCSI controller: for example, if the SCSI controller has 8-bit bus and the request asks to set 16-bit wide transfers this parameter must be silently truncated to 8-bit transfers before sending it to the device.</p></div><div class=paragraph><p>One caveat is that the bus width and synchronous parameters are per target while the disconnection and tag enabling parameters are per lun.</p></div><div class=paragraph><p>The recommended implementation is to keep 3 sets of negotiated (bus width and synchronous transfer) parameters:</p></div><div class=ulist><ul><li><p><em>user</em> - the user set, as above</p></li><li><p><em>current</em> - those actually in effect</p></li><li><p><em>goal</em> - those requested by setting of the "current" parameters</p></li></ul></div><div class=paragraph><p>The code looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb_trans_settings *cts;
    int targ, lun;
    int flags;

    cts = &amp;ccb-&gt;cts;
    targ = ccb_h-&gt;target_id;
    lun = ccb_h-&gt;target_lun;
    flags = cts-&gt;flags;
    if (flags &amp; CCB_TRANS_USER_SETTINGS) {
        if (flags &amp; CCB_TRANS_SYNC_RATE_VALID)
            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;
        if (flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)
            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;
        if (flags &amp; CCB_TRANS_BUS_WIDTH_VALID)
            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;

        if (flags &amp; CCB_TRANS_DISC_VALID) {
            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;
            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;
        }
        if (flags &amp; CCB_TRANS_TQ_VALID) {
            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;
            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;
        }
    }
    if (flags &amp; CCB_TRANS_CURRENT_SETTINGS) {
        if (flags &amp; CCB_TRANS_SYNC_RATE_VALID)
            softc-&gt;goal_sync_period[targ] =
                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);
        if (flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)
            softc-&gt;goal_sync_offset[targ] =
                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);
        if (flags &amp; CCB_TRANS_BUS_WIDTH_VALID)
            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, OUR_BUS_WIDTH);

        if (flags &amp; CCB_TRANS_DISC_VALID) {
            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;
            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;
        }
        if (flags &amp; CCB_TRANS_TQ_VALID) {
            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;
            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;
        }
    }
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre></div></div><div class=paragraph><p>Then when the next I/O request will be processed it will check if it has to re-negotiate, for example by calling the function target_negotiated(hcb).
It can be implemented like this:</p></div><div class="literalblock programlisting"><div class=content><pre>    int
    target_negotiated(struct xxx_hcb *hcb)
    {
        struct softc *softc = hcb-&gt;softc;
        int targ = hcb-&gt;targ;

        if (softc-&gt;current_sync_period[targ] != softc-&gt;goal_sync_period[targ]
        || softc-&gt;current_sync_offset[targ] != softc-&gt;goal_sync_offset[targ]
        || softc-&gt;current_bus_width[targ] != softc-&gt;goal_bus_width[targ])
            return 0; /* FALSE */
        else
            return 1; /* TRUE */
    }</pre></div></div><div class=paragraph><p>After the values are re-negotiated the resulting values must be assigned to both current and goal parameters, so for future I/O transactions the current and goal parameters would be the same and <code>target_negotiated()</code> would return TRUE.
When the card is initialized (in <code>xxx_attach()</code>) the current negotiation values must be initialized to narrow asynchronous mode, the goal and current values must be initialized to the maximal values supported by controller.</p></div></div><div class=sect2><h3 id=_xpt_get_tran_settings_get_values_of_scsi_transfer_settings>12.5.6. <em>XPT_GET_TRAN_SETTINGS</em> - get values of SCSI transfer settings<a class=anchor href=#_xpt_get_tran_settings_get_values_of_scsi_transfer_settings></a></h3><div class=paragraph><p>This operations is the reverse of XPT_SET_TRAN_SETTINGS.
Fill up the CCB instance "struct ccb_trans_setting cts" with data as requested by the flags CCB_TRANS_CURRENT_SETTINGS or CCB_TRANS_USER_SETTINGS (if both are set then the existing drivers return the current settings).
Set all the bits in the valid field.</p></div></div><div class=sect2><h3 id=_xpt_calc_geometry_calculate_logical_bios_geometry_of_the_disk>12.5.7. <em>XPT_CALC_GEOMETRY</em> - calculate logical (BIOS) geometry of the disk<a class=anchor href=#_xpt_calc_geometry_calculate_logical_bios_geometry_of_the_disk></a></h3><div class=paragraph><p>The arguments are transferred in the instance "struct ccb_calc_geometry ccg" of the union ccb:</p></div><div class=ulist><ul><li><p><em>block_size</em> - input, block (A.K.A sector) size in bytes</p></li><li><p><em>volume_size</em> - input, volume size in bytes</p></li><li><p><em>cylinders</em> - output, logical cylinders</p></li><li><p><em>heads</em> - output, logical heads</p></li><li><p><em>secs_per_track</em> - output, logical sectors per track</p></li></ul></div><div class=paragraph><p>If the returned geometry differs much enough from what the SCSI controller BIOS thinks and a disk on this SCSI controller is used as bootable the system may not be able to boot.
The typical calculation example taken from the aic7xxx driver is:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct    ccb_calc_geometry *ccg;
    u_int32_t size_mb;
    u_int32_t secs_per_cylinder;
    int   extended;

    ccg = &amp;ccb-&gt;ccg;
    size_mb = ccg-&gt;volume_size
        / ((1024L * 1024L) / ccg-&gt;block_size);
    extended = check_cards_EEPROM_for_extended_geometry(softc);

    if (size_mb &gt; 1024 &amp;&amp; extended) {
        ccg-&gt;heads = 255;
        ccg-&gt;secs_per_track = 63;
    } else {
        ccg-&gt;heads = 64;
        ccg-&gt;secs_per_track = 32;
    }
    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;
    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre></div></div><div class=paragraph><p>This gives the general idea, the exact calculation depends on the quirks of the particular BIOS.
If BIOS provides no way set the "extended translation" flag in EEPROM this flag should normally be assumed equal to 1.
Other popular geometries are:</p></div><div class="literalblock programlisting"><div class=content><pre>    128 heads, 63 sectors - Symbios controllers
    16 heads, 63 sectors - old controllers</pre></div></div><div class=paragraph><p>Some system BIOSes and SCSI BIOSes fight with each other with variable success, for example a combination of Symbios 875/895 SCSI and Phoenix BIOS can give geometry 128/63 after power up and 255/63 after a hard reset or soft reboot.</p></div></div><div class=sect2><h3 id=_xpt_path_inq_path_inquiry_in_other_words_get_the_sim_driver_and_scsi_controller_also_known_as_hba_host_bus_adapter_properties>12.5.8. <em>XPT_PATH_INQ</em> - path inquiry, in other words get the SIM driver and SCSI controller (also known as HBA - Host Bus Adapter) properties<a class=anchor href=#_xpt_path_inq_path_inquiry_in_other_words_get_the_sim_driver_and_scsi_controller_also_known_as_hba_host_bus_adapter_properties></a></h3><div class=paragraph><p>The properties are returned in the instance "struct ccb_pathinq cpi" of the union ccb:</p></div><div class=ulist><ul><li><p>version_num - the SIM driver version number, now all drivers use 1</p></li><li><p>hba_inquiry - bitmask of features supported by the controller:</p><div class=ulist><ul><li><p>PI_MDP_ABLE - supports MDP message (something from SCSI3?)</p></li><li><p>PI_WIDE_32 - supports 32 bit wide SCSI</p></li><li><p>PI_WIDE_16 - supports 16 bit wide SCSI</p></li><li><p>PI_SDTR_ABLE - can negotiate synchronous transfer rate</p></li><li><p>PI_LINKED_CDB - supports linked commands</p></li><li><p>PI_TAG_ABLE - supports tagged commands</p></li><li><p>PI_SOFT_RST - supports soft reset alternative (hard reset and soft reset are mutually exclusive within a SCSI bus)</p></li></ul></div></li><li><p>target_sprt - flags for target mode support, 0 if unsupported</p></li><li><p>hba_misc - miscellaneous controller features:</p><div class=ulist><ul><li><p>PIM_SCANHILO - bus scans from high ID to low ID</p></li><li><p>PIM_NOREMOVE - removable devices not included in scan</p></li><li><p>PIM_NOINITIATOR - initiator role not supported</p></li><li><p>PIM_NOBUSRESET - user has disabled initial BUS RESET</p></li></ul></div></li><li><p>hba_eng_cnt - mysterious HBA engine count, something related to compression, now is always set to 0</p></li><li><p>vuhba_flags - vendor-unique flags, unused now</p></li><li><p>max_target - maximal supported target ID (7 for 8-bit bus, 15 for 16-bit bus, 127 for Fibre Channel)</p></li><li><p>max_lun - maximal supported LUN ID (7 for older SCSI controllers, 63 for newer ones)</p></li><li><p>async_flags - bitmask of installed Async handler, unused now</p></li><li><p>hpath_id - highest Path ID in the subsystem, unused now</p></li><li><p>unit_number - the controller unit number, cam_sim_unit(sim)</p></li><li><p>bus_id - the bus number, cam_sim_bus(sim)</p></li><li><p>initiator_id - the SCSI ID of the controller itself</p></li><li><p>base_transfer_speed - nominal transfer speed in KB/s for asynchronous narrow transfers, equals to 3300 for SCSI</p></li><li><p>sim_vid - SIM driver’s vendor id, a zero-terminated string of maximal length SIM_IDLEN including the terminating zero</p></li><li><p>hba_vid - SCSI controller’s vendor id, a zero-terminated string of maximal length HBA_IDLEN including the terminating zero</p></li><li><p>dev_name - device driver name, a zero-terminated string of maximal length DEV_IDLEN including the terminating zero, equal to cam_sim_name(sim)</p></li></ul></div><div class=paragraph><p>The recommended way of setting the string fields is using strncpy, like:</p></div><div class="literalblock programlisting"><div class=content><pre>    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);</pre></div></div><div class=paragraph><p>After setting the values set the status to CAM_REQ_CMP and mark the CCB as done.</p></div></div></div></div><div class=sect1><h2 id=scsi-polling>12.6. Polling xxx_poll<a class=anchor href=#scsi-polling></a></h2><div class=sectionbody><div class="literalblock programlisting"><div class=content><pre>static void xxx_poll(struct cam_sim *);</pre></div></div><div class=paragraph><p>The poll function is used to simulate the interrupts when the interrupt subsystem is not functioning (for example, when the system has crashed and is creating the system dump).
The CAM subsystem sets the proper interrupt level before calling the poll routine.
So all it needs to do is to call the interrupt routine (or the other way around, the poll routine may be doing the real action and the interrupt routine would just call the poll routine).
Why bother about a separate function then?
This has to do with different calling conventions.
The <code>xxx_poll</code> routine gets the struct cam_sim pointer as its argument while the PCI interrupt routine by common convention gets pointer to the struct <code>xxx_softc</code> and the ISA interrupt routine gets just the device unit number.
So the poll routine would normally look as:</p></div><div class="literalblock programlisting"><div class=content><pre>static void
xxx_poll(struct cam_sim *sim)
{
    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */
}</pre></div></div><div class=paragraph><p>or</p></div><div class="literalblock programlisting"><div class=content><pre>static void
xxx_poll(struct cam_sim *sim)
{
    xxx_intr(cam_sim_unit(sim)); /* for ISA device */
}</pre></div></div></div></div><div class=sect1><h2 id=scsi-async>12.7. Asynchronous Events<a class=anchor href=#scsi-async></a></h2><div class=sectionbody><div class=paragraph><p>If an asynchronous event callback has been set up then the callback function should be defined.</p></div><div class="literalblock programlisting"><div class=content><pre>static void
ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void *arg)</pre></div></div><div class=ulist><ul><li><p>callback_arg - the value supplied when registering the callback</p></li><li><p>code - identifies the type of event</p></li><li><p>path - identifies the devices to which the event applies</p></li><li><p>arg - event-specific argument</p></li></ul></div><div class=paragraph><p>Implementation for a single type of event, AC_LOST_DEVICE, looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_softc *softc;
    struct cam_sim *sim;
    int targ;
    struct ccb_trans_settings neg;

    sim = (struct cam_sim *)callback_arg;
    softc = (struct xxx_softc *)cam_sim_softc(sim);
    switch (code) {
    case AC_LOST_DEVICE:
        targ = xpt_path_target_id(path);
        if (targ &lt;= OUR_MAX_SUPPORTED_TARGET) {
            clean_negotiations(softc, targ);
            /* send indication to CAM */
            neg.bus_width = 8;
            neg.sync_period = neg.sync_offset = 0;
            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);
            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
        }
        break;
    default:
        break;
    }</pre></div></div></div></div><div class=sect1><h2 id=scsi-interrupts>12.8. Interrupts<a class=anchor href=#scsi-interrupts></a></h2><div class=sectionbody><div class=paragraph><p>The exact type of the interrupt routine depends on the type of the peripheral bus (PCI, ISA and so on) to which the SCSI controller is connected.</p></div><div class=paragraph><p>The interrupt routines of the SIM drivers run at the interrupt level splcam.
So <code>splcam()</code> should be used in the driver to synchronize activity between the interrupt routine and the rest of the driver (for a multiprocessor-aware driver things get yet more interesting but we ignore this case here).
The pseudo-code in this document happily ignores the problems of synchronization.
The real code must not ignore them.
A simple-minded approach is to set <code>splcam()</code> on the entry to the other routines and reset it on return thus protecting them by one big critical section.
To make sure that the interrupt level will be always restored a wrapper function can be defined, like:</p></div><div class="literalblock programlisting"><div class=content><pre>    static void
    xxx_action(struct cam_sim *sim, union ccb *ccb)
    {
        int s;
        s = splcam();
        xxx_action1(sim, ccb);
        splx(s);
    }

    static void
    xxx_action1(struct cam_sim *sim, union ccb *ccb)
    {
        ... process the request ...
    }</pre></div></div><div class=paragraph><p>This approach is simple and robust but the problem with it is that interrupts may get blocked for a relatively long time and this would negatively affect the system’s performance.
On the other hand the functions of the <code>spl()</code> family have rather high overhead, so vast amount of tiny critical sections may not be good either.</p></div><div class=paragraph><p>The conditions handled by the interrupt routine and the details depend very much on the hardware.
We consider the set of "typical" conditions.</p></div><div class=paragraph><p>First, we check if a SCSI reset was encountered on the bus (probably caused by another SCSI controller on the same SCSI bus).
If so we drop all the enqueued and disconnected requests, report the events and re-initialize our SCSI controller.
It is important that during this initialization the controller will not issue another reset or else two controllers on the same SCSI bus could ping-pong resets forever.
The case of fatal controller error/hang could be handled in the same place, but it will probably need also sending RESET signal to the SCSI bus to reset the status of the connections with the SCSI devices.</p></div><div class="literalblock programlisting"><div class=content><pre>    int fatal=0;
    struct ccb_trans_settings neg;
    struct cam_path *path;

    if (detected_scsi_reset(softc)
    || (fatal = detected_fatal_controller_error(softc))) {
        int targ, lun;
        struct xxx_hcb *h, *hh;

        /* drop all enqueued CCBs */
        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
            hh = h-&gt;next;
            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
        }

        /* the clean values of negotiations to report */
        neg.bus_width = 8;
        neg.sync_period = neg.sync_offset = 0;
        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);

        /* drop all disconnected CCBs and clean negotiations  */
        for (targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {
            clean_negotiations(softc, targ);

            /* report the event if possible */
            if (xpt_create_path(&amp;path, /*periph*/NULL,
                    cam_sim_path(sim), targ,
                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {
                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
                xpt_free_path(path);
            }

            for (lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
                for (h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {
                    hh=h-&gt;next;
                    if (fatal)
                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_UNREC_HBA_ERROR);
                    else
                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
                }
        }

        /* report the event */
        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);

        /* re-initialization may take a lot of time, in such case
         * its completion should be signaled by another interrupt or
         * checked on timeout - but for simplicity we assume here that
         * it is really fast
         */
        if (!fatal) {
            reinitialize_controller_without_scsi_reset(softc);
        } else {
            reinitialize_controller_with_scsi_reset(softc);
        }
        schedule_next_hcb(softc);
        return;
    }</pre></div></div><div class=paragraph><p>If interrupt is not caused by a controller-wide condition then probably something has happened to the current hardware control block.
Depending on the hardware there may be other non-HCB-related events, we just do not consider them here.
Then we analyze what happened to this HCB:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_hcb *hcb, *h, *hh;
    int hcb_status, scsi_status;
    int ccb_status;
    int targ;
    int lun_to_freeze;

    hcb = get_current_hcb(softc);
    if (hcb == NULL) {
        /* either stray interrupt or something went very wrong
         * or this is something hardware-dependent
         */
        handle as necessary;
        return;
    }

    targ = hcb-&gt;target;
    hcb_status = get_status_of_current_hcb(softc);</pre></div></div><div class=paragraph><p>First we check if the HCB has completed and if so we check the returned SCSI status.</p></div><div class="literalblock programlisting"><div class=content><pre>    if (hcb_status == COMPLETED) {
        scsi_status = get_completion_status(hcb);</pre></div></div><div class=paragraph><p>Then look if this status is related to the REQUEST SENSE command and if so handle it in a simple way.</p></div><div class="literalblock programlisting"><div class=content><pre>        if (hcb-&gt;flags &amp; DOING_AUTOSENSE) {
            if (scsi_status == GOOD) { /* autosense was successful */
                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;
                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);
            } else {
        autosense_failed:
                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);
            }
            schedule_next_hcb(softc);
            return;
        }</pre></div></div><div class=paragraph><p>Else the command itself has completed, pay more attention to details.
If auto-sense is not disabled for this CCB and the command has failed with sense data then run REQUEST SENSE command to receive that data.</p></div><div class="literalblock programlisting"><div class=content><pre>        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;
        calculate_residue(hcb);

        if ((hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0
        &amp;&amp; (scsi_status == CHECK_CONDITION
                || scsi_status == COMMAND_TERMINATED)) {
            /* start auto-SENSE */
            hcb-&gt;flags |= DOING_AUTOSENSE;
            setup_autosense_command_in_hcb(hcb);
            restart_current_hcb(softc);
            return;
        }
        if (scsi_status == GOOD)
            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);
        else
            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);
        schedule_next_hcb(softc);
        return;
    }</pre></div></div><div class=paragraph><p>One typical thing would be negotiation events: negotiation messages received from a SCSI target (in answer to our negotiation attempt or by target’s initiative) or the target is unable to negotiate (rejects our negotiation messages or does not answer them).</p></div><div class="literalblock programlisting"><div class=content><pre>    switch (hcb_status) {
    case TARGET_REJECTED_WIDE_NEG:
        /* revert to 8-bit bus */
        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = 8;
        /* report the event */
        neg.bus_width = 8;
        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
        continue_current_hcb(softc);
        return;
    case TARGET_ANSWERED_WIDE_NEG:
        {
            int wd;

            wd = get_target_bus_width_request(softc);
            if (wd &lt;= softc-&gt;goal_bus_width[targ]) {
                /* answer is acceptable */
                softc-&gt;current_bus_width[targ] =
                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;

                /* report the event */
                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
            } else {
                prepare_reject_message(hcb);
            }
        }
        continue_current_hcb(softc);
        return;
    case TARGET_REQUESTED_WIDE_NEG:
        {
            int wd;

            wd = get_target_bus_width_request(softc);
            wd = min (wd, OUR_BUS_WIDTH);
            wd = min (wd, softc-&gt;user_bus_width[targ]);

            if (wd != softc-&gt;current_bus_width[targ]) {
                /* the bus width has changed */
                softc-&gt;current_bus_width[targ] =
                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;

                /* report the event */
                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
            }
            prepare_width_nego_rsponse(hcb, wd);
        }
        continue_current_hcb(softc);
        return;
    }</pre></div></div><div class=paragraph><p>Then we handle any errors that could have happened during auto-sense in the same simple-minded way as before.
Otherwise we look closer at the details again.</p></div><div class="literalblock programlisting"><div class=content><pre>    if (hcb-&gt;flags &amp; DOING_AUTOSENSE)
        goto autosense_failed;

    switch (hcb_status) {</pre></div></div><div class=paragraph><p>The next event we consider is unexpected disconnect.
Which is considered normal after an ABORT or BUS DEVICE RESET message and abnormal in other cases.</p></div><div class="literalblock programlisting"><div class=content><pre>    case UNEXPECTED_DISCONNECT:
        if (requested_abort(hcb)) {
            /* abort affects all commands on that target+LUN, so
             * mark all disconnected HCBs on that target+LUN as aborted too
             */
            for (h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];
                    h != NULL; h = hh) {
                hh=h-&gt;next;
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);
            }
            ccb_status = CAM_REQ_ABORTED;
        } else if (requested_bus_device_reset(hcb)) {
            int lun;

            /* reset affects all commands on that target, so
             * mark all disconnected HCBs on that target+LUN as reset
             */

            for (lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
                for (h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];
                        h != NULL; h = hh) {
                    hh=h-&gt;next;
                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
                }

            /* send event */
            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);

            /* this was the CAM_RESET_DEV request itself, it is completed */
            ccb_status = CAM_REQ_CMP;
        } else {
            calculate_residue(hcb);
            ccb_status = CAM_UNEXP_BUSFREE;
            /* request the further code to freeze the queue */
            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
            lun_to_freeze = hcb-&gt;lun;
        }
        break;</pre></div></div><div class=paragraph><p>If the target refuses to accept tags we notify CAM about that and return back all commands for this LUN:</p></div><div class="literalblock programlisting"><div class=content><pre>    case TAGS_REJECTED:
        /* report the event */
        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;
        neg.valid = CCB_TRANS_TQ_VALID;
        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);

        ccb_status = CAM_MSG_REJECT_REC;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = hcb-&gt;lun;
        break;</pre></div></div><div class=paragraph><p>Then we check a number of other conditions, with processing basically limited to setting the CCB status:</p></div><div class="literalblock programlisting"><div class=content><pre>    case SELECTION_TIMEOUT:
        ccb_status = CAM_SEL_TIMEOUT;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = CAM_LUN_WILDCARD;
        break;
    case PARITY_ERROR:
        ccb_status = CAM_UNCOR_PARITY;
        break;
    case DATA_OVERRUN:
    case ODD_WIDE_TRANSFER:
        ccb_status = CAM_DATA_RUN_ERR;
        break;
    default:
        /* all other errors are handled in a generic way */
        ccb_status = CAM_REQ_CMP_ERR;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = CAM_LUN_WILDCARD;
        break;
    }</pre></div></div><div class=paragraph><p>Then we check if the error was serious enough to freeze the input queue until it gets proceeded and do so if it is:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {
        /* freeze the queue */
        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);

        /* re-queue all commands for this target/LUN back to CAM */

        for (h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
            hh = h-&gt;next;

            if (targ == h-&gt;targ
            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze == h-&gt;lun))
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);
        }
    }
    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);
    schedule_next_hcb(softc);
    return;</pre></div></div><div class=paragraph><p>This concludes the generic interrupt handling although specific controllers may require some additions.</p></div></div></div><div class=sect1><h2 id=scsi-errors>12.9. Errors Summary<a class=anchor href=#scsi-errors></a></h2><div class=sectionbody><div class=paragraph><p>When executing an I/O request many things may go wrong.
The reason of error can be reported in the CCB status with great detail.
Examples of use are spread throughout this document.
For completeness here is the summary of recommended responses for the typical error conditions:</p></div><div class=ulist><ul><li><p><em>CAM_RESRC_UNAVAIL</em> - some resource is temporarily unavailable and the SIM driver cannot generate an event when it will become available.
An example of this resource would be some intra-controller hardware resource for which the controller does not generate an interrupt when it becomes available.</p></li><li><p><em>CAM_UNCOR_PARITY</em> - unrecovered parity error occurred</p></li><li><p><em>CAM_DATA_RUN_ERR</em> - data overrun or unexpected data phase (going in other direction than specified in CAM_DIR_MASK) or odd transfer length for wide transfer</p></li><li><p><em>CAM_SEL_TIMEOUT</em> - selection timeout occurred (target does not respond)</p></li><li><p><em>CAM_CMD_TIMEOUT</em> - command timeout occurred (the timeout function ran)</p></li><li><p><em>CAM_SCSI_STATUS_ERROR</em> - the device returned error</p></li><li><p><em>CAM_AUTOSENSE_FAIL</em> - the device returned error and the REQUEST SENSE COMMAND failed</p></li><li><p><em>CAM_MSG_REJECT_REC</em> - MESSAGE REJECT message was received</p></li><li><p><em>CAM_SCSI_BUS_RESET</em> - received SCSI bus reset</p></li><li><p><em>CAM_REQ_CMP_ERR</em> - "impossible" SCSI phase occurred or something else as weird or just a generic error if further detail is not available</p></li><li><p><em>CAM_UNEXP_BUSFREE</em> - unexpected disconnect occurred</p></li><li><p><em>CAM_BDR_SENT</em> - BUS DEVICE RESET message was sent to the target</p></li><li><p><em>CAM_UNREC_HBA_ERROR</em> - unrecoverable Host Bus Adapter Error</p></li><li><p><em>CAM_REQ_TOO_BIG</em> - the request was too large for this controller</p></li><li><p><em>CAM_REQUEUE_REQ</em> - this request should be re-queued to preserve transaction ordering.
This typically occurs when the SIM recognizes an error that should freeze the queue and must place other queued requests for the target at the sim level back into the XPT queue.
Typical cases of such errors are selection timeouts, command timeouts and other like conditions.
In such cases the troublesome command returns the status indicating the error, the and the other commands which have not be sent to the bus yet get re-queued.</p></li><li><p><em>CAM_LUN_INVALID</em> - the LUN ID in the request is not supported by the SCSI controller</p></li><li><p><em>CAM_TID_INVALID</em> - the target ID in the request is not supported by the SCSI controller</p></li></ul></div></div></div><div class=sect1><h2 id=scsi-timeout>12.10. Timeout Handling<a class=anchor href=#scsi-timeout></a></h2><div class=sectionbody><div class=paragraph><p>When the timeout for an HCB expires that request should be aborted, just like with an XPT_ABORT request.
The only difference is that the returned status of aborted request should be CAM_CMD_TIMEOUT instead of CAM_REQ_ABORTED (that is why implementation of the abort better be done as a function).
But there is one more possible problem: what if the abort request itself will get stuck?
In this case the SCSI bus should be reset, just like with an XPT_RESET_BUS request (and the idea about implementing it as a function called from both places applies here too).
Also we should reset the whole SCSI bus if a device reset request got stuck.
So after all the timeout function would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>static void
xxx_timeout(void *arg)
{
    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;
    struct xxx_softc *softc;
    struct ccb_hdr *ccb_h;

    softc = hcb-&gt;softc;
    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;

    if (hcb-&gt;flags &amp; HCB_BEING_ABORTED || ccb_h-&gt;func_code == XPT_RESET_DEV) {
        xxx_reset_bus(softc);
    } else {
        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);
    }
}</pre></div></div><div class=paragraph><p>When we abort a request all the other disconnected requests to the same target/LUN get aborted too.
So there appears a question, should we return them with status CAM_REQ_ABORTED or CAM_CMD_TIMEOUT?
The current drivers use CAM_CMD_TIMEOUT.
This seems logical because if one request got timed out then probably something really bad is happening to the device, so if they would not be disturbed they would time out by themselves.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: March 9, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#scsi-synopsis>12.1. Synopsis</a></li><li><a href=#scsi-general>12.2. General Architecture</a></li><li><a href=#_globals_and_boilerplate>12.3. Globals and Boilerplate</a></li><li><a href=#_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach</a></li><li><a href=#_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action</a></li><li><a href=#scsi-polling>12.6. Polling xxx_poll</a></li><li><a href=#scsi-async>12.7. Asynchronous Events</a></li><li><a href=#scsi-interrupts>12.8. Interrupts</a></li><li><a href=#scsi-errors>12.9. Errors Summary</a></li><li><a href=#scsi-timeout>12.10. Timeout Handling</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/arch-handbook/arch-handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/en/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>