<!doctype html><html class=theme-light lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="For FreeBSD system developers. This book covers the architectural details of many important FreeBSD kernel subsystems"><meta name=keywords content="Arch Handbook,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/en/books/arch-handbook/book/><title>FreeBSD Architecture Handbook | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD Architecture Handbook"><meta property="og:description" content="For FreeBSD system developers. This book covers the architectural details of many important FreeBSD kernel subsystems"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="https://docs.freebsd.org/en/books/arch-handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/en\/books\/arch-handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=https://docs.freebsd.org/en/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/en/books>Books</a></li><li><a href=https://docs.freebsd.org/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD Architecture Handbook</h1><div class=copyright>Copyright © 2000-2006, 2012-2023 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. and other countries.</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries.</p><p>UNIX is a registered trademark of The Open Group in the United States and other countries.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#kernel>Part I: Kernel</a><ul><li><a href=#boot>Chapter 1. Bootstrapping and Kernel Initialization</a></li><li><a href=#locking>Chapter 2. Locking Notes</a></li><li><a href=#kernel-objects>Chapter 3. Kernel Objects</a></li><li><a href=#jail>Chapter 4. The Jail Subsystem</a></li><li><a href=#sysinit>Chapter 5. The SYSINIT Framework</a></li><li><a href=#mac>Chapter 6. The TrustedBSD MAC Framework</a></li><li><a href=#vm>Chapter 7. Virtual Memory System</a></li><li><a href=#smp>Chapter 8. SMPng Design Document</a></li></ul></li><li><a href=#devicedrivers>Part II: Device Drivers</a><ul><li><a href=#driverbasics>Chapter 9. Writing FreeBSD Device Drivers</a></li><li><a href=#isa-driver>Chapter 10. ISA Device Drivers</a></li><li><a href=#pci>Chapter 11. PCI Devices</a></li><li><a href=#scsi>Chapter 12. Common Access Method SCSI Controllers</a></li><li><a href=#usb>Chapter 13. USB Devices</a></li><li><a href=#newbus>Chapter 14. Newbus</a></li><li><a href=#oss>Chapter 15. Sound Subsystem</a></li><li><a href=#pccard>Chapter 16. PC Card</a></li></ul></li><li><a href=#appendices>Part III: Appendices</a><ul><li><a href=#bibliography>Appendix A: Bibliography</a></li></ul></li></ul></nav></div><div>[ <a href=../>Split HTML</a> / Single HTML ]</div><div class=book-content><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Abstract</p></div><div class=paragraph><p>Welcome to the FreeBSD Architecture Handbook. This manual is a <em>work in progress</em> and is the work of many individuals. Many sections do not yet exist and some of those that do exist need to be updated. If you are interested in helping with this project, send email to the <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project mailing list</a>.</p></div><div class=paragraph><p>The latest version of this document is always available from the <a href=https://www.FreeBSD.org/>FreeBSD World Wide Web server</a>. It may also be downloaded in a variety of formats and compression options from the <a href=https://download.freebsd.org/doc/>FreeBSD download server</a> or one of the numerous <a href=https://docs.freebsd.org/en/books/handbook/#mirrors>mirror sites</a>.</p></div><hr></div></div><h1 id=kernel class=sect0>Part I: Kernel<a class=anchor href=#kernel></a></h1><div class=sect1><h2 id=boot>Chapter 1. Bootstrapping and Kernel Initialization<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>1.1. Synopsis<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>This chapter is an overview of the boot and system initialization processes, starting from the BIOS (firmware) POST, to the first user process creation.
Since the initial steps of system startup are very architecture dependent, the IA-32 architecture is used as an example.
But the AMD64 and ARM64 architectures are much more important and compelling examples and should be explained in the near future according to the topic of this document.</p></div><div class=paragraph><p>The FreeBSD boot process can be surprisingly complex.
After control is passed from the BIOS, a considerable amount of low-level configuration must be done before the kernel can be loaded and executed.
This setup must be done in a simple and flexible manner, allowing the user a great deal of customization possibilities.</p></div></div><div class=sect2><h3 id=boot-overview>1.2. Overview<a class=anchor href=#boot-overview></a></h3><div class=paragraph><p>The boot process is an extremely machine-dependent activity.
Not only must code be written for every computer architecture, but there may also be multiple types of booting on the same architecture.
For example, a directory listing of <span class=filename>stand</span> reveals a great amount of architecture-dependent code.
There is a directory for each of the various supported architectures.
FreeBSD supports the CSM boot standard (Compatibility Support Module).
So CSM is supported (with both GPT and MBR partitioning support) and UEFI booting (GPT is totally supported, MBR is mostly supported).
It also supports loading files from ext2fs, MSDOS, UFS and ZFS.
FreeBSD also supports the boot environment feature of ZFS which allows the HOST OS to communicate details about what to boot that go beyond a simple partition as was possible in the past.
But UEFI is more relevant than the CSM these days.
The example that follows shows booting an x86 computer from an MBR-partitioned hard drive with the FreeBSD <span class=filename>boot0</span> multi-boot loader stored in the very first sector.
That boot code starts the FreeBSD three-stage boot process.</p></div><div class=paragraph><p>The key to understanding this process is that it is a series of stages of increasing complexity.
These stages are <span class=filename>boot1</span>, <span class=filename>boot2</span>, and <span class=filename>loader</span> (see <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> for more detail).
The boot system executes each stage in sequence.
The last stage, <span class=filename>loader</span>, is responsible for loading the FreeBSD kernel.
Each stage is examined in the following sections.</p></div><div class=paragraph><p>Here is an example of the output generated by the different boot stages.
Actual output may differ from machine to machine:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:20%><col style=width:80%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><strong>FreeBSD Component</strong></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><strong>Output (may vary)</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>boot0</code></p></td><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash>F1    FreeBSD
F2    BSD
F5    Disk 2</code></pre></div></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>boot2</code> <sup class=footnote>[<a id=_footnoteref_1 class=footnote href=#_footnotedef_1 title="View footnote.">1</a>]</sup></p></td><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=o>&gt;&gt;</span>FreeBSD/x86 BOOT
Default: 0:ad<span class=o>(</span>0p4<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>loader</span></p></td><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash>BTX loader 1.00 BTX version is 1.02
Consoles: internal video/keyboard
BIOS drive C: is disk0
BIOS 639kB/2096064kB available memory

FreeBSD/x86 bootstrap loader, Revision 1.1
Console internal video/keyboard
<span class=o>(</span>root@releng1.nyi.freebsd.org, Fri Apr  9 04:04:45 UTC 2021<span class=o>)</span>
Loading /boot/defaults/loader.conf
/boot/kernel/kernel <span class=nv>text</span><span class=o>=</span>0xed9008 <span class=nv>data</span><span class=o>=</span>0x117d28+0x176650 <span class=nv>syms</span><span class=o>=[</span>0x8+0x137988+0x8+0x1515f8]</code></pre></div></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>kernel</p></td><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash>Copyright <span class=o>(</span>c<span class=o>)</span> 1992-2021 The FreeBSD Project.
Copyright <span class=o>(</span>c<span class=o>)</span> 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
        The Regents of the University of California. All rights reserved.
FreeBSD is a registered trademark of The FreeBSD Foundation.
FreeBSD 13.0-RELEASE 0 releng/13.0-n244733-ea31abc261f: Fri Apr  9 04:04:45 UTC 2021
    root@releng1.nyi.freebsd.org:/usr/obj/usr/src/i386.i386/sys/GENERIC i386
FreeBSD clang version 11.0.1 <span class=o>(</span>git@github.com:llvm/llvm-project.git llvmorg-11.0.1-0-g43ff75f2c3fe<span class=o>)</span></code></pre></div></div></div></td></tr></tbody></table></div><div class=sect2><h3 id=boot-bios>1.3. The BIOS<a class=anchor href=#boot-bios></a></h3><div class=paragraph><p>When the computer powers on, the processor’s registers are set to some predefined values.
One of the registers is the <em>instruction pointer</em> register, and its value after a power on is well defined: it is a 32-bit value of <code>0xfffffff0</code>.
The instruction pointer register (also known as the Program Counter) points to code to be executed by the processor.
Another important register is the <code>cr0</code> 32-bit control register, and its value just after a reboot is <code>0</code>.
One of <code>cr0</code>'s bits, the PE (Protection Enabled) bit, indicates whether the processor is running in 32-bit protected mode or 16-bit real mode.
Since this bit is cleared at boot time, the processor boots in 16-bit real mode.
Real mode means, among other things, that linear and physical addresses are identical.
The reason for the processor not to start immediately in 32-bit protected mode is backwards compatibility.
In particular, the boot process relies on the services provided by the BIOS, and the BIOS itself works in legacy, 16-bit code.</p></div><div class=paragraph><p>The value of <code>0xfffffff0</code> is slightly less than 4 GB, so unless the machine has 4 GB of physical memory, it cannot point to a valid memory address.
The computer’s hardware translates this address so that it points to a BIOS memory block.</p></div><div class=paragraph><p>The BIOS (Basic Input Output System) is a chip on the motherboard that has a relatively small amount of read-only memory (ROM).
This memory contains various low-level routines that are specific to the hardware supplied with the motherboard.
The processor will first jump to the address 0xfffffff0, which really resides in the BIOS’s memory.
Usually this address contains a jump instruction to the BIOS’s POST routines.</p></div><div class=paragraph><p>The POST (Power On Self Test) is a set of routines including the memory check, system bus check, and other low-level initialization so the CPU can set up the computer properly.
The important step of this stage is determining the boot device.
Modern BIOS implementations permit the selection of a boot device, allowing booting from a floppy, CD-ROM, hard disk, or other devices.</p></div><div class=paragraph><p>The very last thing in the POST is the <code>INT 0x19</code> instruction.
The <code>INT 0x19</code> handler reads 512 bytes from the first sector of boot device into the memory at address <code>0x7c00</code>.
The term <em>first sector</em> originates from hard drive architecture, where the magnetic plate is divided into a number of cylindrical tracks.
Tracks are numbered, and every track is divided into a number (usually 64) of sectors.
Track numbers start at 0, but sector numbers start from 1.
Track 0 is the outermost on the magnetic plate, and sector 1, the first sector, has a special purpose.
It is also called the MBR, or Master Boot Record.
The remaining sectors on the first track are never used.</p></div><div class=paragraph><p>This sector is our boot-sequence starting point.
As we will see, this sector contains a copy of our <span class=filename>boot0</span> program.
A jump is made by the BIOS to address <code>0x7c00</code> so it starts executing.</p></div></div><div class=sect2><h3 id=boot-boot0>1.4. The Master Boot Record (<code>boot0</code>)<a class=anchor href=#boot-boot0></a></h3><div class=paragraph><p>After control is received from the BIOS at memory address <code>0x7c00</code>, <span class=filename>boot0</span> starts executing.
It is the first piece of code under FreeBSD control.
The task of <span class=filename>boot0</span> is quite simple: scan the partition table and let the user choose which partition to boot from.
The Partition Table is a special, standard data structure embedded in the MBR (hence embedded in <span class=filename>boot0</span>) describing the four standard PC "partitions".
<span class=filename>boot0</span> resides in the filesystem as <span class=filename>/boot/boot0</span>.
It is a small 512-byte file, and it is exactly what FreeBSD’s installation procedure wrote to the hard disk’s MBR if you chose the "bootmanager" option at installation time.
Indeed, <span class=filename>boot0</span> <em>is</em> the MBR.</p></div><div class=paragraph><p>As mentioned previously, we’re calling the BIOS <code>INT 0x19</code> to load the MBR (<span class=filename>boot0</span>) into memory at address <code>0x7c00</code>.
The source file for <span class=filename>boot0</span> can be found in <span class=filename>stand/i386/boot0/boot0.S</span> - which is an awesome piece of code written by Robert Nordier.</p></div><div class=paragraph><p>A special structure starting from offset <code>0x1be</code> in the MBR is called the <em>partition table</em>.
It has four records of 16 bytes each, called <em>partition records</em>, which represent how the hard disk is partitioned, or, in FreeBSD’s terminology, sliced.
One byte of those 16 says whether a partition (slice) is bootable or not.
Exactly one record must have that flag set, otherwise <span class=filename>boot0</span>'s code will refuse to proceed.</p></div><div class=paragraph><p>A partition record has the following fields:</p></div><div class=ulist><ul><li><p>the 1-byte filesystem type</p></li><li><p>the 1-byte bootable flag</p></li><li><p>the 6 byte descriptor in CHS format</p></li><li><p>the 8 byte descriptor in LBA format</p></li></ul></div><div class=paragraph><p>A partition record descriptor contains information about where exactly the partition resides on the drive.
Both descriptors, LBA and CHS, describe the same information, but in different ways: LBA (Logical Block Addressing) has the starting sector for the partition and the partition’s length, while CHS (Cylinder Head Sector) has coordinates for the first and last sectors of the partition.
The partition table ends with the special signature <code>0xaa55</code>.</p></div><div class=paragraph><p>The MBR must fit into 512 bytes, a single disk sector.
This program uses low-level "tricks" like taking advantage of the side effects of certain instructions and reusing register values from previous operations to make the most out of the fewest possible instructions.
Care must also be taken when handling the partition table, which is embedded in the MBR itself.
For these reasons, be very careful when modifying <span class=filename>boot0.S</span>.</p></div><div class=paragraph><p>Note that the <span class=filename>boot0.S</span> source file is assembled "as is": instructions are translated one by one to binary, with no additional information (no ELF file format, for example).
This kind of low-level control is achieved at link time through special control flags passed to the linker.
For example, the text section of the program is set to be located at address <code>0x600</code>.
In practice this means that <span class=filename>boot0</span> must be loaded to memory address <code>0x600</code> in order to function properly.</p></div><div class=paragraph><p>It is worth looking at the <span class=filename>Makefile</span> for <span class=filename>boot0</span> (<span class=filename>stand/i386/boot0/Makefile</span>), as it defines some of the run-time behavior of <span class=filename>boot0</span>.
For instance, if a terminal connected to the serial port (COM1) is used for I/O, the macro <code>SIO</code> must be defined (<code>-DSIO</code>).
<code>-DPXE</code> enables boot through PXE by pressing <kbd>F6</kbd>.
Additionally, the program defines a set of <em>flags</em> that allow further modification of its behavior.
All of this is illustrated in the <span class=filename>Makefile</span>.
For example, look at the linker directives which command the linker to start the text section at address <code>0x600</code>, and to build the output file "as is" (strip out any file formatting):</p></div><div class="literalblock programlisting"><div class=content><pre>      BOOT_BOOT0_ORG?=0x600
      ORG=${BOOT_BOOT0_ORG}</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/Makefile</span> <a id=boot-boot0-makefile-as-is></a></div><p>Let us now start our study of the MBR, or <span class=filename>boot0</span>, starting where execution begins.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some modifications have been made to some instructions in favor of better exposition.
For example, some macros are expanded, and some macro tests are omitted when the result of the test is known.
This applies to all of the code examples shown.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>start:
      cld			# String ops inc
      xorw %ax,%ax		# Zero
      movw %ax,%es		# Address
      movw %ax,%ds		#  data
      movw %ax,%ss		# Set up
      movw $LOAD,%sp		#  stack</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-entrypoint></a></div><p>This first block of code is the entry point of the program.
It is where the BIOS transfers control.
First, it makes sure that the string operations autoincrement its pointer operands (the <code>cld</code> instruction) <sup class=footnote>[<a id=_footnoteref_2 class=footnote href=#_footnotedef_2 title="View footnote.">2</a>]</sup>.
Then, as it makes no assumption about the state of the segment registers, it initializes them.
Finally, it sets the stack pointer register (<code>%sp</code>) to ($LOAD = address <code>0x7c00</code>), so we have a working stack.</p></div><div class=paragraph><p>The next block is responsible for the relocation and subsequent jump to the relocated code.</p></div><div class="literalblock programlisting"><div class=content><pre>      movw %sp,%si     # Source
      movw $start,%di		# Destination
      movw $0x100,%cx		# Word count
      rep			# Relocate
      movsw			#  code
      movw %di,%bp		# Address variables
      movb $0x8,%cl		# Words to clear
      rep			# Zero
      stosw			#  them
      incb -0xe(%di)		# Set the S field to 1
      jmp main-LOAD+ORIGIN	# Jump to relocated code</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-relocation></a></div><p>As <span class=filename>boot0</span> is loaded by the BIOS to address <code>0x7C00</code>, it copies itself to address <code>0x600</code> and then transfers control there (recall that it was linked to execute at address <code>0x600</code>).
The source address, <code>0x7c00</code>, is copied to register <code>%si</code>.
The destination address, <code>0x600</code>, to register <code>%di</code>.
The number of words to copy, <code>256</code> (the program’s size = 512 bytes), is copied to register <code>%cx</code>.
Next, the <code>rep</code> instruction repeats the instruction that follows, that is, <code>movsw</code>, the number of times dictated by the <code>%cx</code> register.
The <code>movsw</code> instruction copies the word pointed to by <code>%si</code> to the address pointed to by <code>%di</code>.
This is repeated another 255 times.
On each repetition, both the source and destination registers, <code>%si</code> and <code>%di</code>, are incremented by one.
Thus, upon completion of the 256-word (512-byte) copy, <code>%di</code> has the value <code>0x600</code>`512`= `0x800`, and `%si` has the value `0x7c00`<code>512</code>= <code>0x7e00</code>; we have thus completed the code <em>relocation</em>.
Since the last update of this document, the copy instructions have changed in the code, so instead of the movsb and stosb, movsw and stosw have been introduced, which copy 2 bytes(1 word) in one iteration.</p></div><div class=paragraph><p>Next, the destination register <code>%di</code> is copied to <code>%bp</code>.
<code>%bp</code> gets the value <code>0x800</code>.
The value <code>8</code> is copied to <code>%cl</code> in preparation for a new string operation (like our previous <code>movsw</code>).
Now, <code>stosw</code> is executed 8 times.
This instruction copies a <code>0</code> value to the address pointed to by the destination register (<code>%di</code>, which is <code>0x800</code>), and increments it.
This is repeated another 7 times, so <code>%di</code> ends up with value <code>0x810</code>.
Effectively, this clears the address range <code>0x800</code>-<code>0x80f</code>.
This range is used as a (fake) partition table for writing the MBR back to disk.
Finally, the sector field for the CHS addressing of this fake partition is given the value 1 and a jump is made to the main function from the relocated code.
Note that until this jump to the relocated code, any reference to an absolute address was avoided.</p></div><div class=paragraph><p>The following code block tests whether the drive number provided by the BIOS should be used, or the one stored in <span class=filename>boot0</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>main:
      testb $SETDRV,_FLAGS(%bp)	# Set drive number?
#ifndef CHECK_DRIVE	/* disable drive checks */
      jz save_curdrive		# no, use the default
#else
      jnz disable_update	# Yes
      testb %dl,%dl		# Drive number valid?
      js save_curdrive		# Possibly (0x80 set)
#endif</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-drivenumber></a></div><p>This code tests the <code>SETDRV</code> bit (<code>0x20</code>) in the <em>flags</em> variable.
Recall that register <code>%bp</code> points to address location <code>0x800</code>, so the test is done to the <em>flags</em> variable at address <code>0x800</code>-<code>69</code>= <code>0x7bb</code>.
This is an example of the type of modifications that can be done to <span class=filename>boot0</span>.
The <code>SETDRV</code> flag is not set by default, but it can be set in the <span class=filename>Makefile</span>.
When set, the drive number stored in the MBR is used instead of the one provided by the BIOS.
We assume the defaults, and that the BIOS provided a valid drive number, so we jump to <code>save_curdrive</code>.</p></div><div class=paragraph><p>The next block saves the drive number provided by the BIOS, and calls <code>putn</code> to print a new line on the screen.</p></div><div class="literalblock programlisting"><div class=content><pre>save_curdrive:
      movb %dl, (%bp)		# Save drive number
      pushw %dx			# Also in the stack
#ifdef	TEST	/* test code, print internal bios drive */
      rolb $1, %dl
      movw $drive, %si
      call putkey
#endif
      callw putn		# Print a newline</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-savedrivenumber></a></div><p>Note that we assume <code>TEST</code> is not defined, so the conditional code in it is not assembled and will not appear in our executable <span class=filename>boot0</span>.</p></div><div class=paragraph><p>Our next block implements the actual scanning of the partition table.
It prints to the screen the partition type for each of the four entries in the partition table.
It compares each type with a list of well-known operating system file systems.
Examples of recognized partition types are NTFS (Windows®, ID 0x7), <code>ext2fs</code> (Linux®, ID 0x83), and, of course, <code>ffs</code>/<code>ufs2</code> (FreeBSD, ID 0xa5).
The implementation is fairly simple.</p></div><div class="literalblock programlisting"><div class=content><pre>      movw $(partbl+0x4),%bx	# Partition table (+4)
      xorw %dx,%dx		# Item number

read_entry:
      movb %ch,-0x4(%bx)	# Zero active flag (ch == 0)
      btw %dx,_FLAGS(%bp)	# Entry enabled?
      jnc next_entry		# No
      movb (%bx),%al		# Load type
      test %al, %al		# skip empty partition
      jz next_entry
      movw $bootable_ids,%di	# Lookup tables
      movb $(TLEN+1),%cl	# Number of entries
      repne			# Locate
      scasb			#  type
      addw $(TLEN-1), %di	# Adjust
      movb (%di),%cl		# Partition
      addw %cx,%di		#  description
      callw putx		# Display it

next_entry:
      incw %dx			# Next item
      addb $0x10,%bl		# Next entry
      jnc read_entry		# Till done</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-partition-scan></a></div><p>It is important to note that the active flag for each entry is cleared, so after the scanning, <em>no</em> partition entry is active in our memory copy of <span class=filename>boot0</span>.
Later, the active flag will be set for the selected partition.
This ensures that only one active partition exists if the user chooses to write the changes back to disk.</p></div><div class=paragraph><p>The next block tests for other drives.
At startup, the BIOS writes the number of drives present in the computer to address <code>0x475</code>.
If there are any other drives present, <span class=filename>boot0</span> prints the current drive to screen.
The user may command <span class=filename>boot0</span> to scan partitions on another drive later.</p></div><div class="literalblock programlisting"><div class=content><pre>      popw %ax			# Drive number
      subb $0x80-0x1,%al		# Does next
      cmpb NHRDRV,%al		#  drive exist? (from BIOS?)
      jb print_drive		# Yes
      decw %ax			# Already drive 0?
      jz print_prompt		# Yes</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-test-drives></a></div><p>We make the assumption that a single drive is present, so the jump to <code>print_drive</code> is not performed.
We also assume nothing strange happened, so we jump to <code>print_prompt</code>.</p></div><div class=paragraph><p>This next block just prints out a prompt followed by the default option:</p></div><div class="literalblock programlisting"><div class=content><pre>print_prompt:
      movw $prompt,%si		# Display
      callw putstr		#  prompt
      movb _OPT(%bp),%dl	# Display
      decw %si			#  default
      callw putkey		#  key
      jmp start_input		# Skip beep</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-prompt></a></div><p>Finally, a jump is performed to <code>start_input</code>, where the BIOS services are used to start a timer and for reading user input from the keyboard; if the timer expires, the default option will be selected:</p></div><div class="literalblock programlisting"><div class=content><pre>start_input:
      xorb %ah,%ah		# BIOS: Get
      int $0x1a			#  system time
      movw %dx,%di		# Ticks when
      addw _TICKS(%bp),%di	#  timeout
read_key:
      movb $0x1,%ah		# BIOS: Check
      int $0x16			#  for keypress
      jnz got_key		# Have input
      xorb %ah,%ah		# BIOS: int 0x1a, 00
      int $0x1a			#  get system time
      cmpw %di,%dx		# Timeout?
      jb read_key		# No</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-start-input></a></div><p>An interrupt is requested with number <code>0x1a</code> and argument <code>0</code> in register <code>%ah</code>.
The BIOS has a predefined set of services, requested by applications as software-generated interrupts through the <code>int</code> instruction and receiving arguments in registers (in this case, <code>%ah</code>).
Here, particularly, we are requesting the number of clock ticks since last midnight; this value is computed by the BIOS through the RTC (Real Time Clock).
This clock can be programmed to work at frequencies ranging from 2 Hz to 8192 Hz.
The BIOS sets it to 18.2 Hz at startup.
When the request is satisfied, a 32-bit result is returned by the BIOS in registers <code>%cx</code> and <code>%dx</code> (lower bytes in <code>%dx</code>).
This result (the <code>%dx</code> part) is copied to register <code>%di</code>, and the value of the <code>TICKS</code> variable is added to <code>%di</code>.
This variable resides in <span class=filename>boot0</span> at offset <code>_TICKS</code> (a negative value) from register <code>%bp</code> (which, recall, points to <code>0x800</code>).
The default value of this variable is <code>0xb6</code> (182 in decimal).
Now, the idea is that <span class=filename>boot0</span> constantly requests the time from the BIOS, and when the value returned in register <code>%dx</code> is greater than the value stored in <code>%di</code>, the time is up and the default selection will be made.
Since the RTC ticks 18.2 times per second, this condition will be met after 10 seconds (this default behavior can be changed in the <span class=filename>Makefile</span>).
Until this time has passed, <span class=filename>boot0</span> continually asks the BIOS for any user input; this is done through <code>int 0x16</code>, argument <code>1</code> in <code>%ah</code>.</p></div><div class=paragraph><p>Whether a key was pressed or the time expired, subsequent code validates the selection.
Based on the selection, the register <code>%si</code> is set to point to the appropriate partition entry in the partition table.
This new selection overrides the previous default one.
Indeed, it becomes the new default.
Finally, the ACTIVE flag of the selected partition is set.
If it was enabled at compile time, the in-memory version of <span class=filename>boot0</span> with these modified values is written back to the MBR on disk.
We leave the details of this implementation to the reader.</p></div><div class=paragraph><p>We now end our study with the last code block from the <span class=filename>boot0</span> program:</p></div><div class="literalblock programlisting"><div class=content><pre>      movw $LOAD,%bx		# Address for read
      movb $0x2,%ah		# Read sector
      callw intx13		#  from disk
      jc beep			# If error
      cmpw $MAGIC,0x1fe(%bx)	# Bootable?
      jne beep			# No
      pushw %si			# Save ptr to selected part.
      callw putn		# Leave some space
      popw %si			# Restore, next stage uses it
      jmp *%bx			# Invoke bootstrap</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot0/boot0.S</span> <a id=boot-boot0-check-bootable></a></div><p>Recall that <code>%si</code> points to the selected partition entry.
This entry tells us where the partition begins on disk.
We assume, of course, that the partition selected is actually a FreeBSD slice.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>From now on, we will favor the use of the technically more accurate term "slice" rather than "partition".</p></div></td></tr></tbody></table></div><div class=paragraph><p>The transfer buffer is set to <code>0x7c00</code> (register <code>%bx</code>), and a read for the first sector of the FreeBSD slice is requested by calling <code>intx13</code>.
We assume that everything went okay, so a jump to <code>beep</code> is not performed.
In particular, the new sector read must end with the magic sequence <code>0xaa55</code>.
Finally, the value at <code>%si</code> (the pointer to the selected partition table) is preserved for use by the next stage, and a jump is performed to address <code>0x7c00</code>, where execution of our next stage (the just-read block) is started.</p></div></div><div class=sect2><h3 id=boot-boot1>1.5. <code>boot1</code> Stage<a class=anchor href=#boot-boot1></a></h3><div class=paragraph><p>So far we have gone through the following sequence:</p></div><div class=ulist><ul><li><p>The BIOS did some early hardware initialization, including the POST.
The MBR (<span class=filename>boot0</span>) was loaded from absolute disk sector one to address <code>0x7c00</code>.
Execution control was passed to that location.</p></li><li><p><span class=filename>boot0</span> relocated itself to the location it was linked to execute (<code>0x600</code>), followed by a jump to continue execution at the appropriate place.
Finally, <span class=filename>boot0</span> loaded the first disk sector from the FreeBSD slice to address <code>0x7c00</code>.
Execution control was passed to that location.</p></li></ul></div><div class=paragraph><p><span class=filename>boot1</span> is the next step in the boot-loading sequence.
It is the first of three boot stages.
Note that we have been dealing exclusively with disk sectors.
Indeed, the BIOS loads the absolute first sector, while <span class=filename>boot0</span> loads the first sector of the FreeBSD slice.
Both loads are to address <code>0x7c00</code>.
We can conceptually think of these disk sectors as containing the files <span class=filename>boot0</span> and <span class=filename>boot1</span>, respectively, but in reality this is not entirely true for <span class=filename>boot1</span>.
Strictly speaking, unlike <span class=filename>boot0</span>, <span class=filename>boot1</span> is not part of the boot blocks <sup class=footnote>[<a id=_footnoteref_3 class=footnote href=#_footnotedef_3 title="View footnote.">3</a>]</sup>.
Instead, a single, full-blown file, <span class=filename>boot</span> (<span class=filename>/boot/boot</span>), is what ultimately is written to disk.
This file is a combination of <span class=filename>boot1</span>, <span class=filename>boot2</span> and the <code>Boot Extender</code> (or BTX).
This single file is greater in size than a single sector (greater than 512 bytes).
Fortunately, <span class=filename>boot1</span> occupies <em>exactly</em> the first 512 bytes of this single file, so when <span class=filename>boot0</span> loads the first sector of the FreeBSD slice (512 bytes), it is actually loading <span class=filename>boot1</span> and transferring control to it.</p></div><div class=paragraph><p>The main task of <span class=filename>boot1</span> is to load the next boot stage.
This next stage is somewhat more complex.
It is composed of a server called the "Boot Extender", or BTX, and a client, called <span class=filename>boot2</span>.
As we will see, the last boot stage, <span class=filename>loader</span>, is also a client of the BTX server.</p></div><div class=paragraph><p>Let us now look in detail at what exactly is done by <span class=filename>boot1</span>, starting like we did for <span class=filename>boot0</span>, at its entry point:</p></div><div class="literalblock programlisting"><div class=content><pre>start:
	jmp main</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-entry></a></div><p>The entry point at <code>start</code> simply jumps past a special data area to the label <code>main</code>, which in turn looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>main:
      cld			# String ops inc
      xor %cx,%cx		# Zero
      mov %cx,%es		# Address
      mov %cx,%ds		#  data
      mov %cx,%ss		# Set up
      mov $start,%sp		#  stack
      mov %sp,%si		# Source
      mov $MEM_REL,%di		# Destination
      incb %ch			# Word count
      rep			# Copy
      movsw			#  code</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-main></a></div><p>Just like <span class=filename>boot0</span>, this code relocates <span class=filename>boot1</span>, this time to memory address <code>0x700</code>.
However, unlike <span class=filename>boot0</span>, it does not jump there.
<span class=filename>boot1</span> is linked to execute at address <code>0x7c00</code>, effectively where it was loaded in the first place.
The reason for this relocation will be discussed shortly.</p></div><div class=paragraph><p>Next comes a loop that looks for the FreeBSD slice.
Although <span class=filename>boot0</span> loaded <span class=filename>boot1</span> from the FreeBSD slice, no information was passed to it about this <sup class=footnote>[<a id=_footnoteref_4 class=footnote href=#_footnotedef_4 title="View footnote.">4</a>]</sup>, so <span class=filename>boot1</span> must rescan the partition table to find where the FreeBSD slice starts.
Therefore it rereads the MBR:</p></div><div class="literalblock programlisting"><div class=content><pre>      mov $part4,%si		# Partition
      cmpb $0x80,%dl		# Hard drive?
      jb main.4			# No
      movb $0x1,%dh		# Block count
      callw nread		# Read MBR</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-find-freebsd></a></div><p>In the code above, register <code>%dl</code> maintains information about the boot device.
This is passed on by the BIOS and preserved by the MBR.
Numbers <code>0x80</code> and greater tells us that we are dealing with a hard drive, so a call is made to <code>nread</code>, where the MBR is read.
Arguments to <code>nread</code> are passed through <code>%si</code> and <code>%dh</code>.
The memory address at label <code>part4</code> is copied to <code>%si</code>.
This memory address holds a "fake partition" to be used by <code>nread</code>.
The following is the data in the fake partition:</p></div><div class="literalblock programlisting"><div class=content><pre>      part4:
	.byte 0x80, 0x00, 0x01, 0x00
	.byte 0xa5, 0xfe, 0xff, 0xff
	.byte 0x00, 0x00, 0x00, 0x00
	.byte 0x50, 0xc3, 0x00, 0x00</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot2-make-fake-partition></a></div><p>In particular, the LBA for this fake partition is hardcoded to zero.
This is used as an argument to the BIOS for reading absolute sector one from the hard drive.
Alternatively, CHS addressing could be used.
In this case, the fake partition holds cylinder 0, head 0 and sector 1, which is equivalent to absolute sector one.</p></div><div class=paragraph><p>Let us now proceed to take a look at <code>nread</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>nread:
      mov $MEM_BUF,%bx		# Transfer buffer
      mov 0x8(%si),%ax		# Get
      mov 0xa(%si),%cx		#  LBA
      push %cs			# Read from
      callw xread.1		#  disk
      jnc return		# If success, return</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-nread></a></div><p>Recall that <code>%si</code> points to the fake partition.
The word <sup class=footnote>[<a id=_footnoteref_5 class=footnote href=#_footnotedef_5 title="View footnote.">5</a>]</sup> at offset <code>0x8</code> is copied to register <code>%ax</code> and word at offset <code>0xa</code> to <code>%cx</code>.
They are interpreted by the BIOS as the lower 4-byte value denoting the LBA to be read (the upper four bytes are assumed to be zero).
Register <code>%bx</code> holds the memory address where the MBR will be loaded.
The instruction pushing <code>%cs</code> onto the stack is very interesting.
In this context, it accomplishes nothing.
However, as we will see shortly, <span class=filename>boot2</span>, in conjunction with the BTX server, also uses <code>xread.1</code>.
This mechanism will be discussed in the next section.</p></div><div class=paragraph><p>The code at <code>xread.1</code> further calls the <code>read</code> function, which actually calls the BIOS asking for the disk sector:</p></div><div class="literalblock programlisting"><div class=content><pre>xread.1:
	pushl $0x0		#  absolute
	push %cx		#  block
	push %ax		#  number
	push %es		# Address of
	push %bx		#  transfer buffer
	xor %ax,%ax		# Number of
	movb %dh,%al		#  blocks to
	push %ax		#  transfer
	push $0x10		# Size of packet
	mov %sp,%bp		# Packet pointer
	callw read		# Read from disk
	lea 0x10(%bp),%sp	# Clear stack
	lret			# To far caller</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-xread1></a></div><p>Note the long return instruction at the end of this block.
This instruction pops out the <code>%cs</code> register pushed by <code>nread</code>, and returns.
Finally, <code>nread</code> also returns.</p></div><div class=paragraph><p>With the MBR loaded to memory, the actual loop for searching the FreeBSD slice begins:</p></div><div class="literalblock programlisting"><div class=content><pre>	mov $0x1,%cx		 # Two passes
main.1:
	mov $MEM_BUF+PRT_OFF,%si # Partition table
	movb $0x1,%dh		 # Partition
main.2:
	cmpb $PRT_BSD,0x4(%si)	 # Our partition type?
	jne main.3		 # No
	jcxz main.5		 # If second pass
	testb $0x80,(%si)	 # Active?
	jnz main.5		 # Yes
main.3:
	add $0x10,%si		 # Next entry
	incb %dh		 # Partition
	cmpb $0x1+PRT_NUM,%dh		 # In table?
	jb main.2		 # Yes
	dec %cx			 # Do two
	jcxz main.1		 #  passes</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-find-part></a></div><p>If a FreeBSD slice is identified, execution continues at <code>main.5</code>.
Note that when a FreeBSD slice is found <code>%si</code> points to the appropriate entry in the partition table, and <code>%dh</code> holds the partition number.
We assume that a FreeBSD slice is found, so we continue execution at <code>main.5</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>main.5:
	mov %dx,MEM_ARG			   # Save args
	movb $NSECT,%dh			   # Sector count
	callw nread			   # Read disk
	mov $MEM_BTX,%bx			   # BTX
	mov 0xa(%bx),%si		   # Get BTX length and set
	add %bx,%si			   #  %si to start of boot2.bin
	mov $MEM_USR+SIZ_PAG*2,%di			   # Client page 2
	mov $MEM_BTX+(NSECT-1)*SIZ_SEC,%cx			   # Byte
	sub %si,%cx			   #  count
	rep				   # Relocate
	movsb				   #  client</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-main5></a></div><p>Recall that at this point, register <code>%si</code> points to the FreeBSD slice entry in the MBR partition table, so a call to <code>nread</code> will effectively read sectors at the beginning of this partition.
The argument passed on register <code>%dh</code> tells <code>nread</code> to read 16 disk sectors.
Recall that the first 512 bytes, or the first sector of the FreeBSD slice, coincides with the <span class=filename>boot1</span> program.
Also recall that the file written to the beginning of the FreeBSD slice is not <span class=filename>/boot/boot1</span>, but <span class=filename>/boot/boot</span>.
Let us look at the size of these files in the filesystem:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=nt>-r--r--r--</span>  1 root  wheel   512B Jan  8 00:15 /boot/boot0
<span class=nt>-r--r--r--</span>  1 root  wheel   512B Jan  8 00:15 /boot/boot1
<span class=nt>-r--r--r--</span>  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2
<span class=nt>-r--r--r--</span>  1 root  wheel   8.0K Jan  8 00:15 /boot/boot</code></pre></div></div><div class=paragraph><p>Both <span class=filename>boot0</span> and <span class=filename>boot1</span> are 512 bytes each, so they fit <em>exactly</em> in one disk sector.
<span class=filename>boot2</span> is much bigger, holding both the BTX server and the <span class=filename>boot2</span> client.
Finally, a file called simply <span class=filename>boot</span> is 512 bytes larger than <span class=filename>boot2</span>.
This file is a concatenation of <span class=filename>boot1</span> and <span class=filename>boot2</span>.
As already noted, <span class=filename>boot0</span> is the file written to the absolute first disk sector (the MBR), and <span class=filename>boot</span> is the file written to the first sector of the FreeBSD slice; <span class=filename>boot1</span> and <span class=filename>boot2</span> are <em>not</em> written to disk.
The command used to concatenate <span class=filename>boot1</span> and <span class=filename>boot2</span> into a single <span class=filename>boot</span> is merely <code>cat boot1 boot2 > boot</code>.</p></div><div class=paragraph><p>So <span class=filename>boot1</span> occupies exactly the first 512 bytes of <span class=filename>boot</span> and, because <span class=filename>boot</span> is written to the first sector of the FreeBSD slice, <span class=filename>boot1</span> fits exactly in this first sector.
When <code>nread</code> reads the first 16 sectors of the FreeBSD slice, it effectively reads the entire <span class=filename>boot</span> file <sup class=footnote>[<a id=_footnoteref_6 class=footnote href=#_footnotedef_6 title="View footnote.">6</a>]</sup>.
We will see more details about how <span class=filename>boot</span> is formed from <span class=filename>boot1</span> and <span class=filename>boot2</span> in the next section.</p></div><div class=paragraph><p>Recall that <code>nread</code> uses memory address <code>0x8c00</code> as the transfer buffer to hold the sectors read.
This address is conveniently chosen.
Indeed, because <span class=filename>boot1</span> belongs to the first 512 bytes, it ends up in the address range <code>0x8c00</code>-<code>0x8dff</code>.
The 512 bytes that follows (range <code>0x8e00</code>-<code>0x8fff</code>) is used to store the <em>bsdlabel</em> <sup class=footnote>[<a id=_footnoteref_7 class=footnote href=#_footnotedef_7 title="View footnote.">7</a>]</sup>.</p></div><div class=paragraph><p>Starting at address <code>0x9000</code> is the beginning of the BTX server, and immediately following is the <span class=filename>boot2</span> client.
The BTX server acts as a kernel, and executes in protected mode in the most privileged level.
In contrast, the BTX clients (<span class=filename>boot2</span>, for example), execute in user mode.
We will see how this is accomplished in the next section.
The code after the call to <code>nread</code> locates the beginning of <span class=filename>boot2</span> in the memory buffer, and copies it to memory address <code>0xc000</code>.
This is because the BTX server arranges <span class=filename>boot2</span> to execute in a segment starting at <code>0xa000</code>.
We explore this in detail in the following section.</p></div><div class=paragraph><p>The last code block of <span class=filename>boot1</span> enables access to memory above 1MB <sup class=footnote>[<a id=_footnoteref_8 class=footnote href=#_footnotedef_8 title="View footnote.">8</a>]</sup> and concludes with a jump to the starting point of the BTX server:</p></div><div class="literalblock programlisting"><div class=content><pre>seta20:
	cli			# Disable interrupts
seta20.1:
	dec %cx			# Timeout?
	jz seta20.3		# Yes

	inb $0x64,%al		# Get status
	testb $0x2,%al		# Busy?
	jnz seta20.1		# Yes
	movb $0xd1,%al		# Command: Write
	outb %al,$0x64		#  output port
seta20.2:
	inb $0x64,%al		# Get status
	testb $0x2,%al		# Busy?
	jnz seta20.2		# Yes
	movb $0xdf,%al		# Enable
	outb %al,$0x60		#  A20
seta20.3:
	sti			# Enable interrupts
	jmp 0x9010		# Start BTX</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot1.S</span> <a id=boot-boot1-seta20></a></div><p>Note that right before the jump, interrupts are enabled.</p></div></div><div class=sect2><h3 id=btx-server>1.6. The BTX Server<a class=anchor href=#btx-server></a></h3><div class=paragraph><p>Next in our boot sequence is the BTX Server.
Let us quickly remember how we got here:</p></div><div class=ulist><ul><li><p>The BIOS loads the absolute sector one (the MBR, or <span class=filename>boot0</span>), to address <code>0x7c00</code> and jumps there.</p></li><li><p><span class=filename>boot0</span> relocates itself to <code>0x600</code>, the address it was linked to execute, and jumps over there.
It then reads the first sector of the FreeBSD slice (which consists of <span class=filename>boot1</span>) into address <code>0x7c00</code> and jumps over there.</p></li><li><p><span class=filename>boot1</span> loads the first 16 sectors of the FreeBSD slice into address <code>0x8c00</code>.
This 16 sectors, or 8192 bytes, is the whole file <span class=filename>boot</span>.
The file is a concatenation of <span class=filename>boot1</span> and <span class=filename>boot2</span>.
<span class=filename>boot2</span>, in turn, contains the BTX server and the <span class=filename>boot2</span> client.
Finally, a jump is made to address <code>0x9010</code>, the entry point of the BTX server.</p></li></ul></div><div class=paragraph><p>Before studying the BTX Server in detail, let us further review how the single, all-in-one <span class=filename>boot</span> file is created.
The way <span class=filename>boot</span> is built is defined in its <span class=filename>Makefile</span> (<span class=filename>stand/i386/boot2/Makefile</span>).
Let us look at the rule that creates the <span class=filename>boot</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>      boot: boot1 boot2
	cat boot1 boot2 &gt; boot</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/Makefile</span> <a id=boot-boot1-make-boot></a></div><p>This tells us that <span class=filename>boot1</span> and <span class=filename>boot2</span> are needed, and the rule simply concatenates them to produce a single file called <span class=filename>boot</span>.
The rules for creating <span class=filename>boot1</span> are also quite simple:</p></div><div class="literalblock programlisting"><div class=content><pre>      boot1: boot1.out
	${OBJCOPY} -S -O binary boot1.out ${.TARGET}

      boot1.out: boot1.o
	${LD} ${LD_FLAGS} -e start --defsym ORG=${ORG1} -T ${LDSCRIPT} -o ${.TARGET} boot1.o</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/Makefile</span> <a id=boot-boot1-make-boot1></a></div><p>To apply the rule for creating <span class=filename>boot1</span>, <span class=filename>boot1.out</span> must be resolved.
This, in turn, depends on the existence of <span class=filename>boot1.o</span>.
This last file is simply the result of assembling our familiar <span class=filename>boot1.S</span>, without linking.
Now, the rule for creating <span class=filename>boot1.out</span> is applied.
This tells us that <span class=filename>boot1.o</span> should be linked with <code>start</code> as its entry point, and starting at address <code>0x7c00</code>.
Finally, <span class=filename>boot1</span> is created from <span class=filename>boot1.out</span> applying the appropriate rule.
This rule is the <span class=filename>objcopy</span> command applied to <span class=filename>boot1.out</span>.
Note the flags passed to <span class=filename>objcopy</span>: <code>-S</code> tells it to strip all relocation and symbolic information; <code>-O binary</code> indicates the output format, that is, a simple, unformatted binary file.</p></div><div class=paragraph><p>Having <span class=filename>boot1</span>, let us take a look at how <span class=filename>boot2</span> is constructed:</p></div><div class="literalblock programlisting"><div class=content><pre>      boot2: boot2.ld
	@set -- `ls -l ${.ALLSRC}`; x=$$((${BOOT2SIZE}-$$5)); \
	    echo &#34;$$x bytes available&#34;; test $$x -ge 0
	${DD} if=${.ALLSRC} of=${.TARGET} bs=${BOOT2SIZE} conv=sync

      boot2.ld: boot2.ldr boot2.bin ${BTXKERN}
	btxld -v -E ${ORG2} -f bin -b ${BTXKERN} -l boot2.ldr \
	    -o ${.TARGET} -P 1 boot2.bin

      boot2.ldr:
	${DD} if=/dev/zero of=${.TARGET} bs=512 count=1

      boot2.bin: boot2.out
	${OBJCOPY} -S -O binary boot2.out ${.TARGET}

      boot2.out: ${BTXCRT} boot2.o sio.o ashldi3.o
	${LD} ${LD_FLAGS} --defsym ORG=${ORG2} -T ${LDSCRIPT} -o ${.TARGET} ${.ALLSRC}

      boot2.h: boot1.out
	${NM} -t d ${.ALLSRC} | awk &#39;/([0-9])+ T xread/ \
	    { x = $$1 - ORG1; \
	    printf(&#34;#define XREADORG %#x\n&#34;, REL1 + x) }&#39; \
	    ORG1=`printf &#34;%d&#34; ${ORG1}` \
	    REL1=`printf &#34;%d&#34; ${REL1}` &gt; ${.TARGET}</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/Makefile</span> <a id=boot-boot1-make-boot2></a></div><p>The mechanism for building <span class=filename>boot2</span> is far more elaborate.
Let us point out the most relevant facts.
The dependency list is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>      boot2: boot2.ld
      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}
      boot2.bin: boot2.out
      boot2.out: ${BTXDIR} boot2.o sio.o ashldi3.o
      boot2.h: boot1.out</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/Makefile</span> <a id=boot-boot1-make-boot2-more></a></div><p>Note that initially there is no header file <span class=filename>boot2.h</span>, but its creation depends on <span class=filename>boot1.out</span>, which we already have.
The rule for its creation is a bit terse, but the important thing is that the output, <span class=filename>boot2.h</span>, is something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>#define XREADORG 0x725</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/boot2/boot2.h</span> <a id=boot-boot1-make-boot2h></a></div><p>Recall that <span class=filename>boot1</span> was relocated (i.e., copied from <code>0x7c00</code> to <code>0x700</code>).
This relocation will now make sense, because as we will see, the BTX server reclaims some memory, including the space where <span class=filename>boot1</span> was originally loaded.
However, the BTX server needs access to <span class=filename>boot1</span>'s <code>xread</code> function; this function, according to the output of <span class=filename>boot2.h</span>, is at location <code>0x725</code>.
Indeed, the BTX server uses the <code>xread</code> function from <span class=filename>boot1</span>'s relocated code.
This function is now accessible from within the <span class=filename>boot2</span> client.</p></div><div class=paragraph><p>The next rule directs the linker to link various files (<span class=filename>ashldi3.o</span>, <span class=filename>boot2.o</span> and <span class=filename>sio.o</span>).
Note that the output file, <span class=filename>boot2.out</span>, is linked to execute at address <code>0x2000</code> (${ORG2}).
Recall that <span class=filename>boot2</span> will be executed in user mode, within a special user segment set up by the BTX server.
This segment starts at <code>0xa000</code>.
Also, remember that the <span class=filename>boot2</span> portion of <span class=filename>boot</span> was copied to address <code>0xc000</code>, that is, offset <code>0x2000</code> from the start of the user segment, so <span class=filename>boot2</span> will work properly when we transfer control to it.
Next, <span class=filename>boot2.bin</span> is created from <span class=filename>boot2.out</span> by stripping its symbols and format information; boot2.bin is a <em>raw</em> binary.
Now, note that a file <span class=filename>boot2.ldr</span> is created as a 512-byte file full of zeros.
This space is reserved for the bsdlabel.</p></div><div class=paragraph><p>Now that we have files <span class=filename>boot1</span>, <span class=filename>boot2.bin</span> and <span class=filename>boot2.ldr</span>, only the BTX server is missing before creating the all-in-one <span class=filename>boot</span> file.
The BTX server is located in <span class=filename>stand/i386/btx/btx</span>; it has its own <span class=filename>Makefile</span> with its own set of rules for building.
The important thing to notice is that it is also compiled as a <em>raw</em> binary, and that it is linked to execute at address <code>0x9000</code>.
The details can be found in <span class=filename>stand/i386/btx/btx/Makefile</span>.</p></div><div class=paragraph><p>Having the files that comprise the <span class=filename>boot</span> program, the final step is to <em>merge</em> them.
This is done by a special program called <span class=filename>btxld</span> (source located in <span class=filename>/usr/src/usr.sbin/btxld</span>).
Some arguments to this program include the name of the output file (<span class=filename>boot</span>), its entry point (<code>0x2000</code>) and its file format (raw binary).
The various files are finally merged by this utility into the file <span class=filename>boot</span>, which consists of <span class=filename>boot1</span>, <span class=filename>boot2</span>, the <code>bsdlabel</code> and the BTX server.
This file, which takes exactly 16 sectors, or 8192 bytes, is what is actually written to the beginning of the FreeBSD slice during installation.
Let us now proceed to study the BTX server program.</p></div><div class=paragraph><p>The BTX server prepares a simple environment and switches from 16-bit real mode to 32-bit protected mode, right before passing control to the client.
This includes initializing and updating the following data structures:</p></div><div class=ulist><ul><li><p>Modifies the <code>Interrupt Vector Table (IVT)</code>.
The IVT provides exception and interrupt handlers for Real-Mode code.</p></li><li><p>The <code>Interrupt Descriptor Table (IDT)</code> is created.
Entries are provided for processor exceptions, hardware interrupts, two system calls and V86 interface.
The IDT provides exception and interrupt handlers for Protected-Mode code.</p></li><li><p>A <code>Task-State Segment (TSS)</code> is created.
This is necessary because the processor works in the <em>least</em> privileged level when executing the client (<span class=filename>boot2</span>), but in the <em>most</em> privileged level when executing the BTX server.</p></li><li><p>The GDT (Global Descriptor Table) is set up.
Entries (descriptors) are provided for supervisor code and data, user code and data, and real-mode code and data.
<sup class=footnote>[<a id=_footnoteref_9 class=footnote href=#_footnotedef_9 title="View footnote.">9</a>]</sup></p></li></ul></div><div class=paragraph><p>Let us now start studying the actual implementation.
Recall that <span class=filename>boot1</span> made a jump to address <code>0x9010</code>, the BTX server’s entry point.
Before studying program execution there, note that the BTX server has a special header at address range <code>0x9000-0x900f</code>, right before its entry point.
This header is defined as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>start:						# Start of code
/*
 * BTX header.
 */
btx_hdr:	.byte 0xeb			# Machine ID
		.byte 0xe			# Header size
		.ascii &#34;BTX&#34;			# Magic
		.byte 0x1			# Major version
		.byte 0x2			# Minor version
		.byte BTX_FLAGS			# Flags
		.word PAG_CNT-MEM_ORG&gt;&gt;0xc	# Paging control
		.word break-start		# Text size
		.long 0x0			# Entry address</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-header></a></div><p>Note the first two bytes are <code>0xeb</code> and <code>0xe</code>.
In the IA-32 architecture, these two bytes are interpreted as a relative jump past the header into the entry point, so in theory, <span class=filename>boot1</span> could jump here (address <code>0x9000</code>) instead of address <code>0x9010</code>.
Note that the last field in the BTX header is a pointer to the client’s (<span class=filename>boot2</span>) entry pointb2.
This field is patched at link time.</p></div><div class=paragraph><p>Immediately following the header is the BTX server’s entry point:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Initialization routine.
 */
init:		cli				# Disable interrupts
		xor %ax,%ax			# Zero/segment
		mov %ax,%ss			# Set up
		mov $MEM_ESP0,%sp		#  stack
		mov %ax,%es			# Address
		mov %ax,%ds			#  data
		pushl $0x2			# Clear
		popfl				#  flags</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-init></a></div><p>This code disables interrupts, sets up a working stack (starting at address <code>0x1800</code>) and clears the flags in the EFLAGS register.
Note that the <code>popfl</code> instruction pops out a doubleword (4 bytes) from the stack and places it in the EFLAGS register.
As the value actually popped is <code>2</code>, the EFLAGS register is effectively cleared (IA-32 requires that bit 2 of the EFLAGS register always be 1).</p></div><div class=paragraph><p>Our next code block clears (sets to <code>0</code>) the memory range <code>0x5e00-0x8fff</code>.
This range is where the various data structures will be created:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Initialize memory.
 */
		mov $MEM_IDT,%di		# Memory to initialize
		mov $(MEM_ORG-MEM_IDT)/2,%cx	# Words to zero
		rep				# Zero-fill
		stosw				#  memory</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-clear-mem></a></div><p>Recall that <span class=filename>boot1</span> was originally loaded to address <code>0x7c00</code>, so, with this memory initialization, that copy effectively disappeared.
However, also recall that <span class=filename>boot1</span> was relocated to <code>0x700</code>, so <em>that</em> copy is still in memory, and the BTX server will make use of it.</p></div><div class=paragraph><p>Next, the real-mode IVT (Interrupt Vector Table is updated.
The IVT is an array of segment/offset pairs for exception and interrupt handlers.
The BIOS normally maps hardware interrupts to interrupt vectors <code>0x8</code> to <code>0xf</code> and <code>0x70</code> to <code>0x77</code> but, as will be seen, the 8259A Programmable Interrupt Controller, the chip controlling the actual mapping of hardware interrupts to interrupt vectors, is programmed to remap these interrupt vectors from <code>0x8-0xf</code> to <code>0x20-0x27</code> and from <code>0x70-0x77</code> to <code>0x28-0x2f</code>.
Thus, interrupt handlers are provided for interrupt vectors <code>0x20-0x2f</code>.
The reason the BIOS-provided handlers are not used directly is because they work in 16-bit real mode, but not 32-bit protected mode.
Processor mode will be switched to 32-bit protected mode shortly.
However, the BTX server sets up a mechanism to effectively use the handlers provided by the BIOS:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Update real mode IDT for reflecting hardware interrupts.
 */
		mov $intr20,%bx			# Address first handler
		mov $0x10,%cx			# Number of handlers
		mov $0x20*4,%di			# First real mode IDT entry
init.0:		mov %bx,(%di)			# Store IP
		inc %di				# Address next
		inc %di				#  entry
		stosw				# Store CS
		add $4,%bx			# Next handler
		loop init.0			# Next IRQ</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-ivt></a></div><p>The next block creates the IDT (Interrupt Descriptor Table).
The IDT is analogous, in protected mode, to the IVT in real mode.
That is, the IDT describes the various exception and interrupt handlers used when the processor is executing in protected mode.
In essence, it also consists of an array of segment/offset pairs, although the structure is somewhat more complex, because segments in protected mode are different than in real mode, and various protection mechanisms apply:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Create IDT.
 */
		mov $MEM_IDT,%di		# IDT&#39;s address
		mov $idtctl,%si			# Control string
init.1:		lodsb				# Get entry
		cbw				#  count
		xchg %ax,%cx			#  as word
		jcxz init.4			# If done
		lodsb				# Get segment
		xchg %ax,%dx			#  P:DPL:type
		lodsw				# Get control
		xchg %ax,%bx			#  set
		lodsw				# Get handler offset
		mov $SEL_SCODE,%dh		# Segment selector
init.2:		shr %bx				# Handle this int?
		jnc init.3			# No
		mov %ax,(%di)			# Set handler offset
		mov %dh,0x2(%di)		#  and selector
		mov %dl,0x5(%di)		# Set P:DPL:type
		add $0x4,%ax			# Next handler
init.3:		lea 0x8(%di),%di		# Next entry
		loop init.2			# Till set done
		jmp init.1			# Continue</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-idt></a></div><p>Each entry in the <code>IDT</code> is 8 bytes long.
Besides the segment/offset information, they also describe the segment type, privilege level, and whether the segment is present in memory or not.
The construction is such that interrupt vectors from <code>0</code> to <code>0xf</code> (exceptions) are handled by function <code>intx00</code>; vector <code>0x10</code> (also an exception) is handled by <code>intx10</code>; hardware interrupts, which are later configured to start at interrupt vector <code>0x20</code> all the way to interrupt vector <code>0x2f</code>, are handled by function <code>intx20</code>.
Lastly, interrupt vector <code>0x30</code>, which is used for system calls, is handled by <code>intx30</code>, and vectors <code>0x31</code> and <code>0x32</code> are handled by <code>intx31</code>.
It must be noted that only descriptors for interrupt vectors <code>0x30</code>, <code>0x31</code> and <code>0x32</code> are given privilege level 3, the same privilege level as the <span class=filename>boot2</span> client, which means the client can execute a software-generated interrupt to this vectors through the <code>int</code> instruction without failing (this is the way <span class=filename>boot2</span> use the services provided by the BTX server).
Also, note that <em>only</em> software-generated interrupts are protected from code executing in lesser privilege levels.
Hardware-generated interrupts and processor-generated exceptions are <em>always</em> handled adequately, regardless of the actual privileges involved.</p></div><div class=paragraph><p>The next step is to initialize the TSS (Task-State Segment).
The TSS is a hardware feature that helps the operating system or executive software implement multitasking functionality through process abstraction.
The IA-32 architecture demands the creation and use of <em>at least</em> one TSS if multitasking facilities are used or different privilege levels are defined.
Since the <span class=filename>boot2</span> client is executed in privilege level 3, but the BTX server runs in privilege level 0, a TSS must be defined:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Initialize TSS.
 */
init.4:		movb $_ESP0H,TSS_ESP0+1(%di)	# Set ESP0
		movb $SEL_SDATA,TSS_SS0(%di)	# Set SS0
		movb $_TSSIO,TSS_MAP(%di)	# Set I/O bit map base</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-tss></a></div><p>Note that a value is given for the Privilege Level 0 stack pointer and stack segment in the TSS.
This is needed because, if an interrupt or exception is received while executing <span class=filename>boot2</span> in Privilege Level 3, a change to Privilege Level 0 is automatically performed by the processor, so a new working stack is needed.
Finally, the I/O Map Base Address field of the TSS is given a value, which is a 16-bit offset from the beginning of the TSS to the I/O Permission Bitmap and the Interrupt Redirection Bitmap.</p></div><div class=paragraph><p>After the IDT and TSS are created, the processor is ready to switch to protected mode.
This is done in the next block:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Bring up the system.
 */
		mov $0x2820,%bx			# Set protected mode
		callw setpic			#  IRQ offsets
		lidt idtdesc			# Set IDT
		lgdt gdtdesc			# Set GDT
		mov %cr0,%eax			# Switch to protected
		inc %ax				#  mode
		mov %eax,%cr0			#
		ljmp $SEL_SCODE,$init.8		# To 32-bit code
		.code32
init.8:		xorl %ecx,%ecx			# Zero
		movb $SEL_SDATA,%cl		# To 32-bit
		movw %cx,%ss			#  stack</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-prot></a></div><p>First, a call is made to <code>setpic</code> to program the 8259A PIC (Programmable Interrupt Controller).
This chip is connected to multiple hardware interrupt sources.
Upon receiving an interrupt from a device, it signals the processor with the appropriate interrupt vector.
This can be customized so that specific interrupts are associated with specific interrupt vectors, as explained before.
Next, the IDTR (Interrupt Descriptor Table Register) and GDTR (Global Descriptor Table Register) are loaded with the instructions <code>lidt</code> and <code>lgdt</code>, respectively.
These registers are loaded with the base address and limit address for the IDT and GDT.
The following three instructions set the Protection Enable (PE) bit of the <code>%cr0</code> register.
This effectively switches the processor to 32-bit protected mode.
Next, a long jump is made to <code>init.8</code> using segment selector SEL_SCODE, which selects the Supervisor Code Segment.
The processor is effectively executing in CPL 0, the most privileged level, after this jump.
Finally, the Supervisor Data Segment is selected for the stack by assigning the segment selector SEL_SDATA to the <code>%ss</code> register.
This data segment also has a privilege level of <code>0</code>.</p></div><div class=paragraph><p>Our last code block is responsible for loading the TR (Task Register) with the segment selector for the TSS we created earlier, and setting the User Mode environment before passing execution control to the <span class=filename>boot2</span> client.</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Launch user task.
 */
		movb $SEL_TSS,%cl		# Set task
		ltr %cx				#  register
		movl $MEM_USR,%edx		# User base address
		movzwl %ss:BDA_MEM,%eax		# Get free memory
		shll $0xa,%eax			# To bytes
		subl $ARGSPACE,%eax		# Less arg space
		subl %edx,%eax			# Less base
		movb $SEL_UDATA,%cl		# User data selector
		pushl %ecx			# Set SS
		pushl %eax			# Set ESP
		push $0x202			# Set flags (IF set)
		push $SEL_UCODE			# Set CS
		pushl btx_hdr+0xc		# Set EIP
		pushl %ecx			# Set GS
		pushl %ecx			# Set FS
		pushl %ecx			# Set DS
		pushl %ecx			# Set ES
		pushl %edx			# Set EAX
		movb $0x7,%cl			# Set remaining
init.9:		push $0x0			#  general
		loop init.9			#  registers
#ifdef BTX_SERIAL
		call sio_init			# setup the serial console
#endif
		popa				#  and initialize
		popl %es			# Initialize
		popl %ds			#  user
		popl %fs			#  segment
		popl %gs			#  registers
		iret				# To user mode</pre></div></div><div class=paragraph><div class=title><span class=filename>stand/i386/btx/btx/btx.S</span> <a id=btx-end></a></div><p>Note that the client’s environment include a stack segment selector and stack pointer (registers <code>%ss</code> and <code>%esp</code>).
Indeed, once the TR is loaded with the appropriate stack segment selector (instruction <code>ltr</code>), the stack pointer is calculated and pushed onto the stack along with the stack’s segment selector.
Next, the value <code>0x202</code> is pushed onto the stack; it is the value that the EFLAGS will get when control is passed to the client.
Also, the User Mode code segment selector and the client’s entry point are pushed.
Recall that this entry point is patched in the BTX header at link time.
Finally, segment selectors (stored in register <code>%ecx</code>) for the segment registers <code>%gs, %fs, %ds and %es</code> are pushed onto the stack, along with the value at <code>%edx</code> (<code>0xa000</code>).
Keep in mind the various values that have been pushed onto the stack (they will be popped out shortly).
Next, values for the remaining general purpose registers are also pushed onto the stack (note the <code>loop</code> that pushes the value <code>0</code> seven times).
Now, values will be started to be popped out of the stack.
First, the <code>popa</code> instruction pops out of the stack the latest seven values pushed.
They are stored in the general purpose registers in order <code>%edi, %esi, %ebp, %ebx, %edx, %ecx, %eax</code>.
Then, the various segment selectors pushed are popped into the various segment registers.
Five values still remain on the stack.
They are popped when the <code>iret</code> instruction is executed.
This instruction first pops the value that was pushed from the BTX header.
This value is a pointer to <span class=filename>boot2</span>'s entry point.
It is placed in the register <code>%eip</code>, the instruction pointer register.
Next, the segment selector for the User Code Segment is popped and copied to register <code>%cs</code>.
Remember that this segment’s privilege level is 3, the least privileged level.
This means that we must provide values for the stack of this privilege level.
This is why the processor, besides further popping the value for the EFLAGS register, does two more pops out of the stack.
These values go to the stack pointer (<code>%esp</code>) and the stack segment (<code>%ss</code>).
Now, execution continues at <code>boot0</code>'s entry point.</p></div><div class=paragraph><p>It is important to note how the User Code Segment is defined.
This segment’s <em>base address</em> is set to <code>0xa000</code>.
This means that code memory addresses are <em>relative</em> to address 0xa000; if code being executed is fetched from address <code>0x2000</code>, the <em>actual</em> memory addressed is <code>0xa000+0x2000=0xc000</code>.</p></div></div><div class=sect2><h3 id=boot2>1.7. boot2 Stage<a class=anchor href=#boot2></a></h3><div class=paragraph><p><code>boot2</code> defines an important structure, <code>struct bootinfo</code>.
This structure is initialized by <code>boot2</code> and passed to the loader, and then further to the kernel.
Some nodes of this structures are set by <code>boot2</code>, the rest by the loader.
This structure, among other information, contains the kernel filename, BIOS harddisk geometry, BIOS drive number for boot device, physical memory available, <code>envp</code> pointer etc.
The definition for it is:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/machine/bootinfo.h:
struct bootinfo {
	u_int32_t	bi_version;
	u_int32_t	bi_kernelname;		/* represents a char * */
	u_int32_t	bi_nfs_diskless;	/* struct nfs_diskless * */
				/* End of fields that are always present. */
#define	bi_endcommon	bi_n_bios_used
	u_int32_t	bi_n_bios_used;
	u_int32_t	bi_bios_geom[N_BIOS_GEOM];
	u_int32_t	bi_size;
	u_int8_t	bi_memsizes_valid;
	u_int8_t	bi_bios_dev;		/* bootdev BIOS unit number */
	u_int8_t	bi_pad[2];
	u_int32_t	bi_basemem;
	u_int32_t	bi_extmem;
	u_int32_t	bi_symtab;		/* struct symtab * */
	u_int32_t	bi_esymtab;		/* struct symtab * */
				/* Items below only from advanced bootloader */
	u_int32_t	bi_kernend;		/* end of kernel space */
	u_int32_t	bi_envp;		/* environment */
	u_int32_t	bi_modulep;		/* preloaded modules */
};</pre></div></div><div class=paragraph><p><code>boot2</code> enters into an infinite loop waiting for user input, then calls <code>load()</code>.
If the user does not press anything, the loop breaks by a timeout, so <code>load()</code> will load the default file (<span class=filename>/boot/loader</span>).
Functions <code>ino_t lookup(char *filename)</code> and <code>int xfsread(ino_t inode, void *buf, size_t nbyte)</code> are used to read the content of a file into memory.
<span class=filename>/boot/loader</span> is an ELF binary, but where the ELF header is prepended with <span class=filename>a.out</span>'s <code>struct exec</code> structure.
<code>load()</code> scans the loader’s ELF header, loading the content of <span class=filename>/boot/loader</span> into memory, and passing the execution to the loader’s entry:</p></div><div class="literalblock programlisting"><div class=content><pre>stand/i386/boot2/boot2.c:
    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),
	   MAKEBOOTDEV(dev_maj[dsk.type], dsk.slice, dsk.unit, dsk.part),
	   0, 0, 0, VTOP(&amp;bootinfo));</pre></div></div></div><div class=sect2><h3 id=boot-loader>1.8. loader Stage<a class=anchor href=#boot-loader></a></h3><div class=paragraph><p>loader is a BTX client as well.
I will not describe it here in detail, there is a comprehensive man page written by Mike Smith, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.
The underlying mechanisms and BTX were discussed above.</p></div><div class=paragraph><p>The main task for the loader is to boot the kernel.
When the kernel is loaded into memory, it is being called by the loader:</p></div><div class="literalblock programlisting"><div class=content><pre>stand/common/boot.c:
    /* Call the exec handler from the loader matching the kernel */
    file_formats[fp-&gt;f_loader]-&gt;l_exec(fp);</pre></div></div></div><div class=sect2><h3 id=boot-kernel>1.9. Kernel Initialization<a class=anchor href=#boot-kernel></a></h3><div class=paragraph><p>Let us take a look at the command that links the kernel.
This will help identify the exact location where the loader passes execution to the kernel.
This location is the kernel’s actual entry point.
This command is now excluded from <span class=filename>sys/conf/Makefile.i386</span>.
The content that interests us can be found in <span class=filename>/usr/obj/usr/src/i386.i386/sys/GENERIC/</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/obj/usr/src/i386.i386/sys/GENERIC/kernel.meta:
ld -m elf_i386_fbsd -Bdynamic -T /usr/src/sys/conf/ldscript.i386 --build-id=sha1 --no-warn-mismatch \
--warn-common --export-dynamic  --dynamic-linker /red/herring -X -o kernel locore.o
&lt;lots of kernel .o files&gt;</pre></div></div><div class=paragraph><p>A few interesting things can be seen here.
First, the kernel is an ELF dynamically linked binary, but the dynamic linker for kernel is <span class=filename>/red/herring</span>, which is definitely a bogus file.
Second, taking a look at the file <span class=filename>sys/conf/ldscript.i386</span> gives an idea about what ld options are used when compiling a kernel.
Reading through the first few lines, the string</p></div><div class="literalblock programlisting"><div class=content><pre>sys/conf/ldscript.i386:
ENTRY(btext)</pre></div></div><div class=paragraph><p>says that a kernel’s entry point is the symbol <code>btext</code>.
This symbol is defined in <span class=filename>locore.s</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/locore.s:
	.text
/**********************************************************************
 *
 * This is where the bootblocks start us, set the ball rolling...
 *
 */
NON_GPROF_ENTRY(btext)</pre></div></div><div class=paragraph><p>First, the register EFLAGS is set to a predefined value of 0x00000002.
Then all the segment registers are initialized:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/locore.s:
/* Don&#39;t trust what the BIOS gives for eflags. */
	pushl	$PSL_KERNEL
	popfl

/*
 * Don&#39;t trust what the BIOS gives for %fs and %gs.  Trust the bootstrap
 * to set %cs, %ds, %es and %ss.
 */
	mov	%ds, %ax
	mov	%ax, %fs
	mov	%ax, %gs</pre></div></div><div class=paragraph><p>btext calls the routines <code>recover_bootinfo()</code>, <code>identify_cpu()</code>, which are also defined in <span class=filename>locore.s</span>.
Here is a description of what they do:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>recover_bootinfo</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This routine parses the parameters to the kernel passed from the bootstrap.
The kernel may have been booted in 3 ways: by the loader, described above, by the old disk boot blocks, or by the old diskless boot procedure.
This function determines the booting method, and stores the <code>struct bootinfo</code> structure into the kernel memory.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>identify_cpu</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This function tries to find out what CPU it is running on, storing the value found in a variable <code>_cpu</code>.</p></td></tr></tbody></table><div class=paragraph><p>The next steps are enabling VME, if the CPU supports it:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/mpboot.s:
	testl	$CPUID_VME,%edx
	jz	3f
	orl	$CR4_VME,%eax
3:	movl	%eax,%cr4</pre></div></div><div class=paragraph><p>Then, enabling paging:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/mpboot.s:
/* Now enable paging */
	movl	IdlePTD_nopae, %eax
	movl	%eax,%cr3			/* load ptd addr into mmu */
	movl	%cr0,%eax			/* get control word */
	orl	$CR0_PE|CR0_PG,%eax		/* enable paging */
	movl	%eax,%cr0			/* and let&#39;s page NOW! */</pre></div></div><div class=paragraph><p>The next three lines of code are because the paging was set, so the jump is needed to continue the execution in virtualized address space:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/mpboot.s:
	pushl	$mp_begin				/* jump to high mem */
	ret

/* now running relocated at KERNBASE where the system is linked to run */
mp_begin:	/* now running relocated at KERNBASE */</pre></div></div><div class=paragraph><p>The function <code>init386()</code> is called with a pointer to the first free physical page, after that <code>mi_startup()</code>.
<code>init386</code> is an architecture dependent initialization function, and <code>mi_startup()</code> is an architecture independent one (the 'mi_' prefix stands for Machine Independent).
The kernel never returns from <code>mi_startup()</code>, and by calling it, the kernel finishes booting:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/locore.s:
	pushl	physfree			/* value of first for init386(first) */
	call	init386				/* wire 386 chip for unix operation */
	addl	$4,%esp
	movl	%eax,%esp			/* Switch to true top of stack. */
	call	mi_startup			/* autoconfiguration, mountroot etc */
	/* NOTREACHED */</pre></div></div><div class=sect3><h4 id=_init386>1.9.1. <code>init386()</code><a class=anchor href=#_init386></a></h4><div class=paragraph><p><code>init386()</code> is defined in <span class=filename>sys/i386/i386/machdep.c</span> and performs low-level initialization specific to the i386 chip. The switch to protected mode was performed by the loader.
The loader has created the very first task, in which the kernel continues to operate.
Before looking at the code, consider the tasks the processor must complete to initialize protected mode execution:</p></div><div class=ulist><ul><li><p>Initialize the kernel tunable parameters, passed from the bootstrapping program.</p></li><li><p>Prepare the GDT.</p></li><li><p>Prepare the IDT.</p></li><li><p>Initialize the system console.</p></li><li><p>Initialize the DDB, if it is compiled into kernel.</p></li><li><p>Initialize the TSS.</p></li><li><p>Prepare the LDT.</p></li><li><p>Set up thread0’s pcb.</p></li></ul></div><div class=paragraph><p><code>init386()</code> initializes the tunable parameters passed from bootstrap by setting the environment pointer (envp) and calling <code>init_param1()</code>.
The envp pointer has been passed from loader in the <code>bootinfo</code> structure:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
	/* Init basic tunables, hz etc */
	init_param1();</pre></div></div><div class=paragraph><p><code>init_param1()</code> is defined in <span class=filename>sys/kern/subr_param.c</span>.
That file has a number of sysctls, and two functions, <code>init_param1()</code> and <code>init_param2()</code>, that are called from <code>init386()</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/subr_param.c:
	hz = -1;
	TUNABLE_INT_FETCH(&#34;kern.hz&#34;, &amp;hz);
	if (hz == -1)
		hz = vm_guest &gt; VM_GUEST_NO ? HZ_VM : HZ;</pre></div></div><div class=paragraph><p>TUNABLE_&lt;typename>_FETCH is used to fetch the value from the environment:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/sys/kernel.h:
#define	TUNABLE_INT_FETCH(path, var)	getenv_int((path), (var))</pre></div></div><div class=paragraph><p>Sysctl <code>kern.hz</code> is the system clock tick.
Additionally, these sysctls are set by <code>init_param1()</code>: <code>kern.maxswzone, kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz, kern.dflssiz, kern.maxssiz, kern.sgrowsiz</code>.</p></div><div class=paragraph><p>Then <code>init386()</code> prepares the Global Descriptors Table (GDT).
Every task on an x86 is running in its own virtual address space, and this space is addressed by a segment:offset pair.
Say, for instance, the current instruction to be executed by the processor lies at CS:EIP, then the linear virtual address for that instruction would be "the virtual address of code segment CS" + EIP.
For convenience, segments begin at virtual address 0 and end at a 4GB boundary.
Therefore, the instruction’s linear virtual address for this example would just be the value of EIP.
Segment registers such as CS, DS etc are the selectors, i.e., indexes, into GDT (to be more precise, an index is not a selector itself, but the INDEX field of a selector).
FreeBSD’s GDT holds descriptors for 15 selectors per CPU:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
union descriptor gdt0[NGDT];	/* initial global descriptor table */
union descriptor *gdt = gdt0;	/* global descriptor table */

sys/x86/include/segments.h:
/*
 * Entries in the Global Descriptor Table (GDT)
 */
#define	GNULL_SEL	0	/* Null Descriptor */
#define	GPRIV_SEL	1	/* SMP Per-Processor Private Data */
#define	GUFS_SEL	2	/* User %fs Descriptor (order critical: 1) */
#define	GUGS_SEL	3	/* User %gs Descriptor (order critical: 2) */
#define	GCODE_SEL	4	/* Kernel Code Descriptor (order critical: 1) */
#define	GDATA_SEL	5	/* Kernel Data Descriptor (order critical: 2) */
#define	GUCODE_SEL	6	/* User Code Descriptor (order critical: 3) */
#define	GUDATA_SEL	7	/* User Data Descriptor (order critical: 4) */
#define	GBIOSLOWMEM_SEL	8	/* BIOS low memory access (must be entry 8) */
#define	GPROC0_SEL	9	/* Task state process slot zero and up */
#define	GLDT_SEL	10	/* Default User LDT */
#define	GUSERLDT_SEL	11	/* User LDT */
#define	GPANIC_SEL	12	/* Task state to consider panic from */
#define	GBIOSCODE32_SEL	13	/* BIOS interface (32bit Code) */
#define	GBIOSCODE16_SEL	14	/* BIOS interface (16bit Code) */
#define	GBIOSDATA_SEL	15	/* BIOS interface (Data) */
#define	GBIOSUTIL_SEL	16	/* BIOS interface (Utility) */
#define	GBIOSARGS_SEL	17	/* BIOS interface (Arguments) */
#define	GNDIS_SEL	18	/* For the NDIS layer */
#define	NGDT		19</pre></div></div><div class=paragraph><p>Note that those #defines are not selectors themselves, but just a field INDEX of a selector, so they are exactly the indices of the GDT.
for example, an actual selector for the kernel code (GCODE_SEL) has the value 0x20.</p></div><div class=paragraph><p>The next step is to initialize the Interrupt Descriptor Table (IDT).
This table is referenced by the processor when a software or hardware interrupt occurs.
For example, to make a system call, user application issues the <code>INT 0x80</code> instruction.
This is a software interrupt, so the processor’s hardware looks up a record with index 0x80 in the IDT.
This record points to the routine that handles this interrupt, in this particular case, this will be the kernel’s syscall gate.
The IDT may have a maximum of 256 (0x100) records.
The kernel allocates NIDT records for the IDT, where NIDT is the maximum (256):</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
static struct gate_descriptor idt0[NIDT];
struct gate_descriptor *idt = &amp;idt0[0];	/* interrupt descriptor table */</pre></div></div><div class=paragraph><p>For each interrupt, an appropriate handler is set.
The syscall gate for <code>INT 0x80</code> is set as well:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
	setidt(IDT_SYSCALL, &amp;IDTVEC(int0x80_syscall),
			SDT_SYS386IGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));</pre></div></div><div class=paragraph><p>So when a userland application issues the <code>INT 0x80</code> instruction, control will transfer to the function <code>_Xint0x80_syscall</code>, which is in the kernel code segment and will be executed with supervisor privileges.</p></div><div class=paragraph><p>Console and DDB are then initialized:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
	cninit();
/* skipped */
  kdb_init();
#ifdef KDB
	if (boothowto &amp; RB_KDB)
		kdb_enter(KDB_WHY_BOOTFLAGS, &#34;Boot flags requested debugger&#34;);
#endif</pre></div></div><div class=paragraph><p>The Task State Segment is another x86 protected mode structure, the TSS is used by the hardware to store task information when a task switch occurs.</p></div><div class=paragraph><p>The Local Descriptors Table is used to reference userland code and data.
Several selectors are defined to point to the LDT, they are the system call gates and the user code and data selectors:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/x86/include/segments.h:
#define	LSYS5CALLS_SEL	0	/* forced by intel BCS */
#define	LSYS5SIGR_SEL	1
#define	LUCODE_SEL	3
#define	LUDATA_SEL	5
#define	NLDT		(LUDATA_SEL + 1)</pre></div></div><div class=paragraph><p>Next, proc0’s Process Control Block (<code>struct pcb</code>) structure is initialized.
proc0 is a <code>struct proc</code> structure that describes a kernel process.
It is always present while the kernel is running, therefore it is linked with thread0:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
register_t
init386(int first)
{
    /* ... skipped ... */

    proc_linkup0(&amp;proc0, &amp;thread0);
    /* ... skipped ... */
}</pre></div></div><div class=paragraph><p>The structure <code>struct pcb</code> is a part of a proc structure.
It is defined in <span class=filename>/usr/include/machine/pcb.h</span> and has a process’s information specific to the i386 architecture, such as registers values.</p></div></div><div class=sect3><h4 id=_mi_startup>1.9.2. <code>mi_startup()</code><a class=anchor href=#_mi_startup></a></h4><div class=paragraph><p>This function performs a bubble sort of all the system initialization objects and then calls the entry of each object one by one:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
	for (sipp = sysinit; sipp &lt; sysinit_end; sipp++) {

		/* ... skipped ... */

		/* Call function */
		(*((*sipp)-&gt;func))((*sipp)-&gt;udata);
		/* ... skipped ... */
	}</pre></div></div><div class=paragraph><p>Although the sysinit framework is described in the <a href=/books/developers-handbook>Developers' Handbook</a>, I will discuss the internals of it.</p></div><div class=paragraph><p>Every system initialization object (sysinit object) is created by calling a SYSINIT() macro.
Let us take as example an <code>announce</code> sysinit object.
This object prints the copyright message:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
static void
print_caddr_t(void *data __unused)
{
	printf(&#34;%s&#34;, (char *)data);
}
/* ... skipped ... */
SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright);</pre></div></div><div class=paragraph><p>The subsystem ID for this object is SI_SUB_COPYRIGHT (0x0800001).
So, the copyright message will be printed out first, just after the console initialization.</p></div><div class=paragraph><p>Let us take a look at what exactly the macro <code>SYSINIT()</code> does.
It expands to a <code>C_SYSINIT()</code> macro.
The <code>C_SYSINIT()</code> macro then expands to a static <code>struct sysinit</code> structure declaration with another <code>DATA_SET</code> macro call:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/kernel.h:
      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \
      static struct sysinit uniquifier ## _sys_init = { \ subsystem, \
      order, \ func, \ (ident) \ }; \ DATA_WSET(sysinit_set,uniquifier ##
      _sys_init);

#define	SYSINIT(uniquifier, subsystem, order, func, ident)	\
	C_SYSINIT(uniquifier, subsystem, order,			\
	(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)(ident))</pre></div></div><div class=paragraph><p>The <code>DATA_SET()</code> macro expands to a <code>_MAKE_SET()</code>, and that macro is the point where all the sysinit magic is hidden:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/linker_set.h:
#define TEXT_SET(set, sym) _MAKE_SET(set, sym)
#define DATA_SET(set, sym) _MAKE_SET(set, sym)</pre></div></div><div class=paragraph><p>After executing these macros, various sections were made in the kernel, including`set.sysinit_set`.
Running objdump on a kernel binary, you may notice the presence of such small sections:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash>% llvm-objdump <span class=nt>-h</span> /kernel
Sections:
Idx Name                               Size     VMA      Type
 10 set_sysctl_set                     000021d4 01827078 DATA
 16 set_kbddriver_set                  00000010 0182a4d0 DATA
 20 set_scterm_set                     0000000c 0182c75c DATA
 21 set_cons_set                       00000014 0182c768 DATA
 33 set_scrndr_set                     00000024 0182c828 DATA
 41 set_sysinit_set                    000014d8 018fabb0 DATA</code></pre></div></div><div class=paragraph><p>This screen dump shows that the size of set.sysinit_set section is 0x14d8 bytes, so <code>0x14d8/sizeof(void *)</code> sysinit objects are compiled into the kernel.
The other sections such as <code>set.sysctl_set</code> represent other linker sets.</p></div><div class=paragraph><p>By defining a variable of type <code>struct sysinit</code> the content of <code>set.sysinit_set</code> section will be "collected" into that variable:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
  SET_DECLARE(sysinit_set, struct sysinit);</pre></div></div><div class=paragraph><p>The <code>struct sysinit</code> is defined as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/sys/kernel.h:
  struct sysinit {
	enum sysinit_sub_id	subsystem;	/* subsystem identifier*/
	enum sysinit_elem_order	order;		/* init order within subsystem*/
	sysinit_cfunc_t func;			/* function		*/
	const void	*udata;			/* multiplexer/argument */
};</pre></div></div><div class=paragraph><p>Returning to the <code>mi_startup()</code> discussion, it is must be clear now, how the sysinit objects are being organized.
The <code>mi_startup()</code> function sorts them and calls each.
The very last object is the system scheduler:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/kernel.h:
enum sysinit_sub_id {
	SI_SUB_DUMMY		= 0x0000000,	/* not executed; for linker*/
	SI_SUB_DONE		= 0x0000001,	/* processed*/
	SI_SUB_TUNABLES		= 0x0700000,	/* establish tunable values */
	SI_SUB_COPYRIGHT	= 0x0800001,	/* first use of console*/
...
	SI_SUB_LAST		= 0xfffffff	/* final initialization */
};</pre></div></div><div class=paragraph><p>The system scheduler sysinit object is defined in the file <span class=filename>sys/vm/vm_glue.c</span>, and the entry point for that object is <code>scheduler()</code>.
That function is actually an infinite loop, and it represents a process with PID 0, the swapper process.
The thread0 structure, mentioned before, is used to describe it.</p></div><div class=paragraph><p>The first user process, called <em>init</em>, is created by the sysinit object <code>init</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
static void
create_init(const void *udata __unused)
{
	struct fork_req fr;
	struct ucred *newcred, *oldcred;
	struct thread *td;
	int error;

	bzero(&amp;fr, sizeof(fr));
	fr.fr_flags = RFFDG | RFPROC | RFSTOPPED;
	fr.fr_procp = &amp;initproc;
	error = fork1(&amp;thread0, &amp;fr);
	if (error)
		panic(&#34;cannot fork init: %d\n&#34;, error);
	KASSERT(initproc-&gt;p_pid == 1, (&#34;create_init: initproc-&gt;p_pid != 1&#34;));
	/* divorce init&#39;s credentials from the kernel&#39;s */
	newcred = crget();
	sx_xlock(&amp;proctree_lock);
	PROC_LOCK(initproc);
	initproc-&gt;p_flag |= P_SYSTEM | P_INMEM;
	initproc-&gt;p_treeflag |= P_TREE_REAPER;
	oldcred = initproc-&gt;p_ucred;
	crcopy(newcred, oldcred);
#ifdef MAC
	mac_cred_create_init(newcred);
#endif
#ifdef AUDIT
	audit_cred_proc1(newcred);
#endif
	proc_set_cred(initproc, newcred);
	td = FIRST_THREAD_IN_PROC(initproc);
	crcowfree(td);
	td-&gt;td_realucred = crcowget(initproc-&gt;p_ucred);
	td-&gt;td_ucred = td-&gt;td_realucred;
	PROC_UNLOCK(initproc);
	sx_xunlock(&amp;proctree_lock);
	crfree(oldcred);
	cpu_fork_kthread_handler(FIRST_THREAD_IN_PROC(initproc), start_init, NULL);
}
SYSINIT(init, SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL);</pre></div></div><div class=paragraph><p>The function <code>create_init()</code> allocates a new process by calling <code>fork1()</code>, but does not mark it runnable.
When this new process is scheduled for execution by the scheduler, the <code>start_init()</code> will be called.
That function is defined in <span class=filename>init_main.c</span>.
It tries to load and exec the <span class=filename>init</span> binary, probing <span class=filename>/sbin/init</span> first, then <span class=filename>/sbin/oinit</span>, <span class=filename>/sbin/init.bak</span>, and finally <span class=filename>/rescue/init</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
static char init_path[MAXPATHLEN] =
#ifdef	INIT_PATH
    __XSTRING(INIT_PATH);
#else
    &#34;/sbin/init:/sbin/oinit:/sbin/init.bak:/rescue/init&#34;;
#endif</pre></div></div></div></div></div></div><div class=sect1><h2 id=locking>Chapter 2. Locking Notes<a class=anchor href=#locking></a></h2><div class=sectionbody><div class=paragraph><p><em>This chapter is maintained by the FreeBSD SMP Next Generation Project.</em></p></div><div class=paragraph><p>This document outlines the locking used in the FreeBSD kernel to permit effective multi-processing within the kernel. Locking can be achieved via several means. Data structures can be protected by mutexes or <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a> locks. A few variables are protected simply by always using atomic operations to access them.</p></div><div class=sect2><h3 id=locking-mutexes>2.1. Mutexes<a class=anchor href=#locking-mutexes></a></h3><div class=paragraph><p>A mutex is simply a lock used to guarantee mutual exclusion. Specifically, a mutex may only be owned by one entity at a time. If another entity wishes to obtain a mutex that is already owned, it must wait until the mutex is released. In the FreeBSD kernel, mutexes are owned by processes.</p></div><div class=paragraph><p>Mutexes may be recursively acquired, but they are intended to be held for a short period of time. Specifically, one may not sleep while holding a mutex. If you need to hold a lock across a sleep, use a <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a> lock.</p></div><div class=paragraph><p>Each mutex has several properties of interest:</p></div><div class=dlist><dl><dt class=hdlist1>Variable Name</dt><dd><p>The name of the struct mtx variable in the kernel source.</p></dd><dt class=hdlist1>Logical Name</dt><dd><p>The name of the mutex assigned to it by <code>mtx_init</code>. This name is displayed in KTR trace messages and witness errors and warnings and is used to distinguish mutexes in the witness code.</p></dd><dt class=hdlist1>Type</dt><dd><p>The type of the mutex in terms of the <code>MTX_*</code> flags. The meaning for each flag is related to its meaning as documented in <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a>.</p><div class=dlist><dl><dt class=hdlist1><code>MTX_DEF</code></dt><dd><p>A sleep mutex</p></dd><dt class=hdlist1><code>MTX_SPIN</code></dt><dd><p>A spin mutex</p></dd><dt class=hdlist1><code>MTX_RECURSE</code></dt><dd><p>This mutex is allowed to recurse.</p></dd></dl></div></dd><dt class=hdlist1>Protectees</dt><dd><p>A list of data structures or data structure members that this entry protects. For data structure members, the name will be in the form of <code>structure name</code>.<code>member name</code>.</p></dd><dt class=hdlist1>Dependent Functions</dt><dd><p>Functions that can only be called if this mutex is held.</p></dd></dl></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Table 1. Mutex List</caption><col style=width:13.6363%><col style=width:9.0909%><col style=width:9.0909%><col style=width:50%><col style=width:18.1819%><thead><tr><th class="tableblock halign-left valign-top">Variable Name</th><th class="tableblock halign-left valign-top">Logical Name</th><th class="tableblock halign-left valign-top">Type</th><th class="tableblock halign-left valign-top">Protectees</th><th class="tableblock halign-left valign-top">Dependent Functions</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>sched_lock</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"sched lock"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>MTX_SPIN</code> | <code>MTX_RECURSE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>_gmonparam</code>, <code>cnt.v_swtch</code>, <code>cp_time</code>, <code>curpriority</code>, <code>mtx</code>.<code>mtx_blocked</code>, <code>mtx</code>.<code>mtx_contested</code>, <code>proc</code>.<code>p_procq</code>, <code>proc</code>.<code>p_slpq</code>, <code>proc</code>.<code>p_sflag</code>, <code>proc</code>.<code>p_stat</code>, <code>proc</code>.<code>p_estcpu</code>, <code>proc</code>.<code>p_cpticks</code> <code>proc</code>.<code>p_pctcpu</code>, <code>proc</code>.<code>p_wchan</code>, <code>proc</code>.<code>p_wmesg</code>, <code>proc</code>.<code>p_swtime</code>, <code>proc</code>.<code>p_slptime</code>, <code>proc</code>.<code>p_runtime</code>, <code>proc</code>.<code>p_uu</code>, <code>proc</code>.<code>p_su</code>, <code>proc</code>.<code>p_iu</code>, <code>proc</code>.<code>p_uticks</code>, <code>proc</code>.<code>p_sticks</code>, <code>proc</code>.<code>p_iticks</code>, <code>proc</code>.<code>p_oncpu</code>, <code>proc</code>.<code>p_lastcpu</code>, <code>proc</code>.<code>p_rqindex</code>, <code>proc</code>.<code>p_heldmtx</code>, <code>proc</code>.<code>p_blocked</code>, <code>proc</code>.<code>p_mtxname</code>, <code>proc</code>.<code>p_contested</code>, <code>proc</code>.<code>p_priority</code>, <code>proc</code>.<code>p_usrpri</code>, <code>proc</code>.<code>p_nativepri</code>, <code>proc</code>.<code>p_nice</code>, <code>proc</code>.<code>p_rtprio</code>, <code>pscnt</code>, <code>slpque</code>, <code>itqueuebits</code>, <code>itqueues</code>, <code>rtqueuebits</code>, <code>rtqueues</code>, <code>queuebits</code>, <code>queues</code>, <code>idqueuebits</code>, <code>idqueues</code>, <code>switchtime</code>, <code>switchticks</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>setrunqueue</code>, <code>remrunqueue</code>, <code>mi_switch</code>, <code>chooseproc</code>, <code>schedclock</code>, <code>resetpriority</code>, <code>updatepri</code>, <code>maybe_resched</code>, <code>cpu_switch</code>, <code>cpu_throw</code>, <code>need_resched</code>, <code>resched_wanted</code>, <code>clear_resched</code>, <code>aston</code>, <code>astoff</code>, <code>astpending</code>, <code>calcru</code>, <code>proc_compare</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>vm86pcb_lock</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"vm86pcb lock"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>MTX_DEF</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>vm86pcb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>vm86_bioscall</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Giant</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"Giant"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>MTX_DEF</code> | <code>MTX_RECURSE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>nearly everything</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lots</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>callout_lock</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"callout lock"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>MTX_SPIN</code> | <code>MTX_RECURSE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>callfree</code>, <code>callwheel</code>, <code>nextsoftcheck</code>, <code>proc</code>.<code>p_itcallout</code>, <code>proc</code>.<code>p_slpcallout</code>, <code>softticks</code>, <code>ticks</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table></div><div class=sect2><h3 id=locking-sx>2.2. Shared Exclusive Locks<a class=anchor href=#locking-sx></a></h3><div class=paragraph><p>These locks provide basic reader-writer type functionality and may be held by a sleeping process. Currently they are backed by <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a>.</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Table 2. Shared Exclusive Lock List</caption><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Variable Name</th><th class="tableblock halign-left valign-top">Protectees</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>allproc_lock</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>allproc</code> <code>zombproc</code> <code>pidhashtbl</code> <code>proc</code>.<code>p_list</code> <code>proc</code>.<code>p_hash</code> <code>nextpid</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>proctree_lock</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>proc</code>.<code>p_children</code> <code>proc</code>.<code>p_sibling</code></p></td></tr></tbody></table></div><div class=sect2><h3 id=locking-atomic>2.3. Atomically Protected Variables<a class=anchor href=#locking-atomic></a></h3><div class=paragraph><p>An atomically protected variable is a special variable that is not protected by an explicit lock. Instead, all data accesses to the variables use special atomic operations as described in <a href="https://man.freebsd.org/cgi/man.cgi?query=atomic&amp;sektion=9&amp;format=html">atomic(9)</a>. Very few variables are treated this way, although other synchronization primitives such as mutexes are implemented with atomically protected variables.</p></div><div class=ulist><ul><li><p><code>mtx</code>.<code>mtx_lock</code></p></li></ul></div></div></div></div><div class=sect1><h2 id=kernel-objects>Chapter 3. Kernel Objects<a class=anchor href=#kernel-objects></a></h2><div class=sectionbody><div class=paragraph><p>Kernel Objects, or <em>Kobj</em> provides an object-oriented C programming system for the kernel.
As such the data being operated on carries the description of how to operate on it.
This allows operations to be added and removed from an interface at run time and without breaking binary compatibility.</p></div><div class=sect2><h3 id=kernel-objects-term>3.1. Terminology<a class=anchor href=#kernel-objects-term></a></h3><div class=dlist><dl><dt class=hdlist1>Object</dt><dd><p>A set of data - data structure - data allocation.</p></dd><dt class=hdlist1>Method</dt><dd><p>An operation - function.</p></dd><dt class=hdlist1>Class</dt><dd><p>One or more methods.</p></dd><dt class=hdlist1>Interface</dt><dd><p>A standard set of one or more methods.</p></dd></dl></div></div><div class=sect2><h3 id=kernel-objects-operation>3.2. Kobj Operation<a class=anchor href=#kernel-objects-operation></a></h3><div class=paragraph><p>Kobj works by generating descriptions of methods.
Each description holds a unique id as well as a default function.
The description’s address is used to uniquely identify the method within a class' method table.</p></div><div class=paragraph><p>A class is built by creating a method table associating one or more functions with method descriptions.
Before use the class is compiled.
The compilation allocates a cache and associates it with the class.
A unique id is assigned to each method description within the method table of the class if not already done so by another referencing class compilation.
For every method to be used a function is generated by script to qualify arguments and automatically reference the method description for a lookup.
The generated function looks up the method by using the unique id associated with the method description as a hash into the cache associated with the object’s class.
If the method is not cached the generated function proceeds to use the class' table to find the method.
If the method is found then the associated function within the class is used; otherwise, the default function associated with the method description is used.</p></div><div class=paragraph><p>These indirections can be visualized as the following:</p></div><div class="literalblock programlisting"><div class=content><pre>object-&gt;cache&lt;-&gt;class</pre></div></div></div><div class=sect2><h3 id=kernel-objects-using>3.3. Using Kobj<a class=anchor href=#kernel-objects-using></a></h3><div class=sect3><h4 id=_structures>3.3.1. Structures<a class=anchor href=#_structures></a></h4><div class="literalblock programlisting"><div class=content><pre>struct kobj_method</pre></div></div></div><div class=sect3><h4 id=_functions>3.3.2. Functions<a class=anchor href=#_functions></a></h4><div class="literalblock programlisting"><div class=content><pre>void kobj_class_compile(kobj_class_t cls);
void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);
void kobj_class_free(kobj_class_t cls);
kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);
void kobj_init(kobj_t obj, kobj_class_t cls);
void kobj_delete(kobj_t obj, struct malloc_type *mtype);</pre></div></div></div><div class=sect3><h4 id=_macros>3.3.3. Macros<a class=anchor href=#_macros></a></h4><div class="literalblock programlisting"><div class=content><pre>KOBJ_CLASS_FIELDS
KOBJ_FIELDS
DEFINE_CLASS(name, methods, size)
KOBJMETHOD(NAME, FUNC)</pre></div></div></div><div class=sect3><h4 id=_headers>3.3.4. Headers<a class=anchor href=#_headers></a></h4><div class="literalblock programlisting"><div class=content><pre>&lt;sys/param.h&gt;
&lt;sys/kobj.h&gt;</pre></div></div></div><div class=sect3><h4 id=_creating_an_interface_template>3.3.5. Creating an Interface Template<a class=anchor href=#_creating_an_interface_template></a></h4><div class=paragraph><p>The first step in using Kobj is to create an Interface.
Creating the interface involves creating a template that the script <span class=filename>src/sys/kern/makeobjops.pl</span> can use to generate the header and code for the method declarations and method lookup functions.</p></div><div class=paragraph><p>Within this template the following keywords are used: <code>#include</code>, <code>INTERFACE</code>, <code>CODE</code>, <code>EPILOG</code>, <code>HEADER</code>, <code>METHOD</code>, <code>PROLOG</code>, <code>STATICMETHOD</code>, and <code>DEFAULT</code>.</p></div><div class=paragraph><p>The <code>#include</code> statement and what follows it is copied verbatim to the head of the generated code file.</p></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;sys/foo.h&gt;</pre></div></div><div class=paragraph><p>The <code>INTERFACE</code> keyword is used to define the interface name.
This name is concatenated with each method name as [interface name]_[method name].
Its syntax is INTERFACE [interface name];.</p></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>INTERFACE foo;</pre></div></div><div class=paragraph><p>The <code>CODE</code> keyword copies its arguments verbatim into the code file.
Its syntax is <code>CODE { [whatever] };</code></p></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>CODE {
	struct foo * foo_alloc_null(struct bar *)
	{
		return NULL;
	}
};</pre></div></div><div class=paragraph><p>The <code>HEADER</code> keyword copies its arguments verbatim into the header file.
Its syntax is <code>HEADER { [whatever] };</code></p></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>HEADER {
        struct mumble;
        struct grumble;
};</pre></div></div><div class=paragraph><p>The <code>METHOD</code> keyword describes a method.
Its syntax is <code>METHOD [return type] [method name] { [object [, arguments]] };</code></p></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>METHOD int bar {
	struct object *;
	struct foo *;
	struct bar;
};</pre></div></div><div class=paragraph><p>The <code>DEFAULT</code> keyword may follow the <code>METHOD</code> keyword.
It extends the <code>METHOD</code> key word to include the default function for method.
The extended syntax is <code>METHOD [return type] [method name] { [object; [other arguments]] }DEFAULT [default function];</code></p></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>METHOD int bar {
	struct object *;
	struct foo *;
	int bar;
} DEFAULT foo_hack;</pre></div></div><div class=paragraph><p>The <code>STATICMETHOD</code> keyword is used like the <code>METHOD</code> keyword except the kobj data is not at the head of the object structure so casting to kobj_t would be incorrect.
Instead <code>STATICMETHOD</code> relies on the Kobj data being referenced as 'ops'.
This is also useful for calling methods directly out of a class’s method table.</p></div><div class=paragraph><p>The <code>PROLOG</code> and <code>EPILOG</code> keywords sets inserts code immediately before or directly after the <code>METHOD</code> they are attached to.
This feature is used primarily for profiling situations where it’s difficult to obtain the information in another way.</p></div><div class=paragraph><p>Other complete examples:</p></div><div class="literalblock programlisting"><div class=content><pre>src/sys/kern/bus_if.m
src/sys/kern/device_if.m</pre></div></div></div><div class=sect3><h4 id=_creating_a_class>3.3.6. Creating a Class<a class=anchor href=#_creating_a_class></a></h4><div class=paragraph><p>The second step in using Kobj is to create a class.
A class consists of a name, a table of methods, and the size of objects if Kobj’s object handling facilities are used.
To create the class use the macro <code>DEFINE_CLASS()</code>.
To create the method table create an array of kobj_method_t terminated by a NULL entry.
Each non-NULL entry may be created using the macro <code>KOBJMETHOD()</code>.</p></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));

kobj_method_t foomethods[] = {
	KOBJMETHOD(bar_doo, foo_doo),
	KOBJMETHOD(bar_foo, foo_foo),
	{ NULL, NULL}
};</pre></div></div><div class=paragraph><p>The class must be "compiled".
Depending on the state of the system at the time that the class is to be initialized a statically allocated cache, "ops table" have to be used.
This can be accomplished by declaring a <code>struct kobj_ops</code> and using <code>kobj_class_compile_static();</code> otherwise, <code>kobj_class_compile()</code> should be used.</p></div></div><div class=sect3><h4 id=_creating_an_object>3.3.7. Creating an Object<a class=anchor href=#_creating_an_object></a></h4><div class=paragraph><p>The third step in using Kobj involves how to define the object.
Kobj object creation routines assume that Kobj data is at the head of an object.
If this in not appropriate you will have to allocate the object yourself and then use <code>kobj_init()</code> on the Kobj portion of it; otherwise, you may use <code>kobj_create()</code> to allocate and initialize the Kobj portion of the object automatically.
<code>kobj_init()</code> may also be used to change the class that an object uses.</p></div><div class=paragraph><p>To integrate Kobj into the object you should use the macro KOBJ_FIELDS.</p></div><div class=paragraph><p>For example</p></div><div class="literalblock programlisting"><div class=content><pre>struct foo_data {
	KOBJ_FIELDS;
	foo_foo;
	foo_bar;
};</pre></div></div></div><div class=sect3><h4 id=_calling_methods>3.3.8. Calling Methods<a class=anchor href=#_calling_methods></a></h4><div class=paragraph><p>The last step in using Kobj is to simply use the generated functions to use the desired method within the object’s class.
This is as simple as using the interface name and the method name with a few modifications.
The interface name should be concatenated with the method name using a '_' between them, all in upper case.</p></div><div class=paragraph><p>For example, if the interface name was foo and the method was bar then the call would be:</p></div><div class="literalblock programlisting"><div class=content><pre>[return value = ] FOO_BAR(object [, other parameters]);</pre></div></div></div><div class=sect3><h4 id=_cleaning_up>3.3.9. Cleaning Up<a class=anchor href=#_cleaning_up></a></h4><div class=paragraph><p>When an object allocated through <code>kobj_create()</code> is no longer needed <code>kobj_delete()</code> may be called on it, and when a class is no longer being used <code>kobj_class_free()</code> may be called on it.</p></div></div></div></div></div><div class=sect1><h2 id=jail>Chapter 4. The Jail Subsystem<a class=anchor href=#jail></a></h2><div class=sectionbody><div class=paragraph><p>On most UNIX® systems, <code>root</code> has omnipotent power. This promotes insecurity. If an attacker gained <code>root</code> on a system, he would have every function at his fingertips. In FreeBSD there are sysctls which dilute the power of <code>root</code>, in order to minimize the damage caused by an attacker. Specifically, one of these functions is called <code>secure levels</code>. Similarly, another function which is present from FreeBSD 4.0 and onward, is a utility called <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Jail chroots an environment and sets certain restrictions on processes which are forked within the jail. For example, a jailed process cannot affect processes outside the jail, utilize certain system calls, or inflict any damage on the host environment.</p></div><div class=paragraph><p>Jail is becoming the new security model. People are running potentially vulnerable servers such as Apache, BIND, and sendmail within jails, so that if an attacker gains <code>root</code> within the jail, it is only an annoyance, and not a devastation. This article mainly focuses on the internals (source code) of jail. For information on how to set up a jail see the <a href=https://docs.freebsd.org/en/books/handbook/#jails>handbook entry on jails</a>.</p></div><div class=sect2><h3 id=jail-arch>4.1. Architecture<a class=anchor href=#jail-arch></a></h3><div class=paragraph><p>Jail consists of two realms: the userland program, <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>, and the code implemented within the kernel: the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call and associated restrictions. I will be discussing the userland program and then how jail is implemented within the kernel.</p></div><div class=sect3><h4 id=_userland_code>4.1.1. Userland Code<a class=anchor href=#_userland_code></a></h4><div class=paragraph><p>The source for the userland jail is located in <span class=filename>/usr/src/usr.sbin/jail</span>, consisting of one file, <span class=filename>jail.c</span>. The program takes these arguments: the path of the jail, hostname, IP address, and the command to be executed.</p></div><div class=sect4><h5 id=_data_structures>4.1.1.1. Data Structures<a class=anchor href=#_data_structures></a></h5><div class=paragraph><p>In <span class=filename>jail.c</span>, the first thing I would note is the declaration of an important structure <code>struct jail j;</code> which was included from <span class=filename>/usr/include/sys/jail.h</span>.</p></div><div class=paragraph><p>The definition of the <code>jail</code> structure is:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/jail.h:

struct jail {
        u_int32_t       version;
        char            *path;
        char            *hostname;
        u_int32_t       ip_number;
};</pre></div></div><div class=paragraph><p>As you can see, there is an entry for each of the arguments passed to the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> program, and indeed, they are set during its execution.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/usr.sbin/jail/jail.c
char path[PATH_MAX];
...
if (realpath(argv[0], path) == NULL)
    err(1, &#34;realpath: %s&#34;, argv[0]);
if (chdir(path) != 0)
    err(1, &#34;chdir: %s&#34;, path);
memset(&amp;j, 0, sizeof(j));
j.version = 0;
j.path = path;
j.hostname = argv[1];</pre></div></div></div><div class=sect4><h5 id=_networking>4.1.1.2. Networking<a class=anchor href=#_networking></a></h5><div class=paragraph><p>One of the arguments passed to the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> program is an IP address with which the jail can be accessed over the network. <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> translates the IP address given into host byte order and then stores it in <code>j</code> (the <code>jail</code> structure).</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/usr.sbin/jail/jail.c:
struct in_addr in;
...
if (inet_aton(argv[2], &amp;in) == 0)
    errx(1, &#34;Could not make sense of ip-number: %s&#34;, argv[2]);
j.ip_number = ntohl(in.s_addr);</pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=inet_aton&amp;sektion=3&amp;format=html">inet_aton(3)</a> function "interprets the specified character string as an Internet address, placing the address into the structure provided." The <code>ip_number</code> member in the <code>jail</code> structure is set only when the IP address placed onto the <code>in</code> structure by <a href="https://man.freebsd.org/cgi/man.cgi?query=inet_aton&amp;sektion=3&amp;format=html">inet_aton(3)</a> is translated into host byte order by <a href="https://man.freebsd.org/cgi/man.cgi?query=ntohl&amp;sektion=3&amp;format=html">ntohl(3)</a>.</p></div></div><div class=sect4><h5 id=_jailing_the_process>4.1.1.3. Jailing the Process<a class=anchor href=#_jailing_the_process></a></h5><div class=paragraph><p>Finally, the userland program jails the process. Jail now becomes an imprisoned process itself and then executes the command given using <a href="https://man.freebsd.org/cgi/man.cgi?query=execv&amp;sektion=3&amp;format=html">execv(3)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/usr.sbin/jail/jail.c
i = jail(&amp;j);
...
if (execv(argv[3], argv + 3) != 0)
    err(1, &#34;execv: %s&#34;, argv[3]);</pre></div></div><div class=paragraph><p>As you can see, the <code>jail()</code> function is called, and its argument is the <code>jail</code> structure which has been filled with the arguments given to the program. Finally, the program you specify is executed. I will now discuss how jail is implemented within the kernel.</p></div></div></div><div class=sect3><h4 id=_kernel_space>4.1.2. Kernel Space<a class=anchor href=#_kernel_space></a></h4><div class=paragraph><p>We will now be looking at the file <span class=filename>/usr/src/sys/kern/kern_jail.c</span>. This is the file where the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call, appropriate sysctls, and networking functions are defined.</p></div><div class=sect4><h5 id=_sysctls>4.1.2.1. Sysctls<a class=anchor href=#_sysctls></a></h5><div class=paragraph><p>In <span class=filename>kern_jail.c</span>, the following sysctls are defined:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
int     jail_set_hostname_allowed = 1;
SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,
    &amp;jail_set_hostname_allowed, 0,
    &#34;Processes in jail can set their hostnames&#34;);

int     jail_socket_unixiproute_only = 1;
SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,
    &amp;jail_socket_unixiproute_only, 0,
    &#34;Processes in jail are limited to creating UNIX/IPv4/route sockets only&#34;);

int     jail_sysvipc_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,
    &amp;jail_sysvipc_allowed, 0,
    &#34;Processes in jail can use System V IPC primitives&#34;);

static int jail_enforce_statfs = 2;
SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,
    &amp;jail_enforce_statfs, 0,
    &#34;Processes in jail cannot see all mounted file systems&#34;);

int    jail_allow_raw_sockets = 0;
SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,
    &amp;jail_allow_raw_sockets, 0,
    &#34;Prison root can create raw sockets&#34;);

int    jail_chflags_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,
    &amp;jail_chflags_allowed, 0,
    &#34;Processes in jail can alter system file flags&#34;);

int     jail_mount_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,
    &amp;jail_mount_allowed, 0,
    &#34;Processes in jail can mount/unmount jail-friendly file systems&#34;);</pre></div></div><div class=paragraph><p>Each of these sysctls can be accessed by the user through the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> program. Throughout the kernel, these specific sysctls are recognized by their name. For example, the name of the first sysctl is <code>security.jail.set_hostname_allowed</code>.</p></div></div><div class=sect4><h5 id=_jail2_system_call>4.1.2.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> System Call<a class=anchor href=#_jail2_system_call></a></h5><div class=paragraph><p>Like all system calls, the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call takes two arguments, <code>struct thread *td</code> and <code>struct jail_args *uap</code>. <code>td</code> is a pointer to the <code>thread</code> structure which describes the calling thread. In this context, <code>uap</code> is a pointer to the structure in which a pointer to the <code>jail</code> structure passed by the userland <span class=filename>jail.c</span> is contained. When I described the userland program before, you saw that the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call was given a <code>jail</code> structure as its own argument.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
/*
 * struct jail_args {
 *  struct jail *jail;
 * };
 */
int
jail(struct thread *td, struct jail_args *uap)</pre></div></div><div class=paragraph><p>Therefore, <code>uap→jail</code> can be used to access the <code>jail</code> structure which was passed to the system call. Next, the system call copies the <code>jail</code> structure into kernel space using the <a href="https://man.freebsd.org/cgi/man.cgi?query=copyin&amp;sektion=9&amp;format=html">copyin(9)</a> function. <a href="https://man.freebsd.org/cgi/man.cgi?query=copyin&amp;sektion=9&amp;format=html">copyin(9)</a> takes three arguments: the address of the data which is to be copied into kernel space, <code>uap→jail</code>, where to store it, <code>j</code> and the size of the storage. The <code>jail</code> structure pointed by <code>uap→jail</code> is copied into kernel space and is stored in another <code>jail</code> structure, <code>j</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
error = copyin(uap-&gt;jail, &amp;j, sizeof(j));</pre></div></div><div class=paragraph><p>There is another important structure defined in <span class=filename>jail.h</span>. It is the <code>prison</code> structure. The <code>prison</code> structure is used exclusively within kernel space. Here is the definition of the <code>prison</code> structure.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/jail.h:
struct prison {
        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */
        int              pr_id;                         /* (c) prison id */
        int              pr_ref;                        /* (p) refcount */
        char             pr_path[MAXPATHLEN];           /* (c) chroot path */
        struct vnode    *pr_root;                       /* (c) vnode to rdir */
        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname */
        u_int32_t        pr_ip;                         /* (c) ip addr host */
        void            *pr_linux;                      /* (p) linux abi */
        int              pr_securelevel;                /* (p) securelevel */
        struct task      pr_task;                       /* (d) destroy task */
        struct mtx       pr_mtx;
      void            **pr_slots;                     /* (p) additional data */
};</pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call then allocates memory for a <code>prison</code> structure and copies data between the <code>jail</code> and <code>prison</code> structure.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);
...
error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);
if (error)
    goto e_killmtx;
...
error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), 0);
if (error)
     goto e_dropvnref;
pr-&gt;pr_ip = j.ip_number;</pre></div></div><div class=paragraph><p>Next, we will discuss another important system call <a href="https://man.freebsd.org/cgi/man.cgi?query=jail_attach&amp;sektion=2&amp;format=html">jail_attach(2)</a>, which implements the function to put a process into the jail.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
/*
 * struct jail_attach_args {
 *      int jid;
 * };
 */
int
jail_attach(struct thread *td, struct jail_attach_args *uap)</pre></div></div><div class=paragraph><p>This system call makes the changes that can distinguish a jailed process from those unjailed ones. To understand what <a href="https://man.freebsd.org/cgi/man.cgi?query=jail_attach&amp;sektion=2&amp;format=html">jail_attach(2)</a> does for us, certain background information is needed.</p></div><div class=paragraph><p>On FreeBSD, each kernel visible thread is identified by its <code>thread</code> structure, while the processes are described by their <code>proc</code> structures. You can find the definitions of the <code>thread</code> and <code>proc</code> structure in <span class=filename>/usr/include/sys/proc.h</span>. For example, the <code>td</code> argument in any system call is actually a pointer to the calling thread’s <code>thread</code> structure, as stated before. The <code>td_proc</code> member in the <code>thread</code> structure pointed by <code>td</code> is a pointer to the <code>proc</code> structure which represents the process that contains the thread represented by <code>td</code>. The <code>proc</code> structure contains members which can describe the owner’s identity(<code>p_ucred</code>), the process resource limits(<code>p_limit</code>), and so on. In the <code>ucred</code> structure pointed by <code>p_ucred</code> member in the <code>proc</code> structure, there is a pointer to the <code>prison</code> structure(<code>cr_prison</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/proc.h:
struct thread {
    ...
    struct proc *td_proc;
    ...
};
struct proc {
    ...
    struct ucred *p_ucred;
    ...
};
/usr/include/sys/ucred.h
struct ucred {
    ...
    struct prison *cr_prison;
    ...
};</pre></div></div><div class=paragraph><p>In <span class=filename>kern_jail.c</span>, the function <code>jail()</code> then calls function <code>jail_attach()</code> with a given <code>jid</code>. And <code>jail_attach()</code> calls function <code>change_root()</code> to change the root directory of the calling process. The <code>jail_attach()</code> then creates a new <code>ucred</code> structure, and attaches the newly created <code>ucred</code> structure to the calling process after it has successfully attached the <code>prison</code> structure to the <code>ucred</code> structure. From then on, the calling process is recognized as jailed. When the kernel routine <code>jailed()</code> is called in the kernel with the newly created <code>ucred</code> structure as its argument, it returns 1 to tell that the credential is connected with a jail. The public ancestor process of all the process forked within the jail, is the process which runs <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>, as it calls the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call. When a program is executed through <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a>, it inherits the jailed property of its parent’s <code>ucred</code> structure, therefore it has a jailed <code>ucred</code> structure.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c
int
jail(struct thread *td, struct jail_args *uap)
{
...
    struct jail_attach_args jaa;
...
    error = jail_attach(td, &amp;jaa);
    if (error)
        goto e_dropprref;
...
}

int
jail_attach(struct thread *td, struct jail_attach_args *uap)
{
    struct proc *p;
    struct ucred *newcred, *oldcred;
    struct prison *pr;
...
    p = td-&gt;td_proc;
...
    pr = prison_find(uap-&gt;jid);
...
    change_root(pr-&gt;pr_root, td);
...
    newcred-&gt;cr_prison = pr;
    p-&gt;p_ucred = newcred;
...
}</pre></div></div><div class=paragraph><p>When a process is forked from its parent process, the <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> system call uses <code>crhold()</code> to maintain the credential for the newly forked process. It inherently keep the newly forked child’s credential consistent with its parent, so the child process is also jailed.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_fork.c:
p2-&gt;p_ucred = crhold(td-&gt;td_ucred);
...
td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);</pre></div></div></div></div></div><div class=sect2><h3 id=jail-restrictions>4.2. Restrictions<a class=anchor href=#jail-restrictions></a></h3><div class=paragraph><p>Throughout the kernel there are access restrictions relating to jailed processes. Usually, these restrictions only check whether the process is jailed, and if so, returns an error. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>if (jailed(td-&gt;td_ucred))
    return (EPERM);</pre></div></div><div class=sect3><h4 id=_sysv_ipc>4.2.1. SysV IPC<a class=anchor href=#_sysv_ipc></a></h4><div class=paragraph><p>System V IPC is based on messages. Processes can send each other these messages which tell them how to act. The functions which deal with messages are: <a href="https://man.freebsd.org/cgi/man.cgi?query=msgctl&amp;sektion=3&amp;format=html">msgctl(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=msgget&amp;sektion=3&amp;format=html">msgget(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=msgsnd&amp;sektion=3&amp;format=html">msgsnd(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=msgrcv&amp;sektion=3&amp;format=html">msgrcv(3)</a>. Earlier, I mentioned that there were certain sysctls you could turn on or off in order to affect the behavior of jail. One of these sysctls was <code>security.jail.sysvipc_allowed</code>. By default, this sysctl is set to 0. If it were set to 1, it would defeat the whole purpose of having a jail; privileged users from the jail would be able to affect processes outside the jailed environment. The difference between a message and a signal is that the message only consists of the signal number.</p></div><div class=paragraph><p><span class=filename>/usr/src/sys/kern/sysv_msg.c</span>:</p></div><div class=ulist><ul><li><p><code>msgget(key, msgflg)</code>: <code>msgget</code> returns (and possibly creates) a message descriptor that designates a message queue for use in other functions.</p></li><li><p><code>msgctl(msgid, cmd, buf)</code>: Using this function, a process can query the status of a message descriptor.</p></li><li><p><code>msgsnd(msgid, msgp, msgsz, msgflg)</code>: <code>msgsnd</code> sends a message to a process.</p></li><li><p><code>msgrcv(msgid, msgp, msgsz, msgtyp, msgflg)</code>: a process receives messages using this function</p></li></ul></div><div class=paragraph><p>In each of the system calls corresponding to these functions, there is this conditional:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/sysv_msg.c:
if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))
    return (ENOSYS);</pre></div></div><div class=paragraph><p>Semaphore system calls allow processes to synchronize execution by doing a set of operations atomically on a set of semaphores. Basically semaphores provide another way for processes lock resources. However, process waiting on a semaphore, that is being used, will sleep until the resources are relinquished. The following semaphore system calls are blocked inside a jail: <a href="https://man.freebsd.org/cgi/man.cgi?query=semget&amp;sektion=2&amp;format=html">semget(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=semctl&amp;sektion=2&amp;format=html">semctl(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=semop&amp;sektion=2&amp;format=html">semop(2)</a>.</p></div><div class=paragraph><p><span class=filename>/usr/src/sys/kern/sysv_sem.c</span>:</p></div><div class=ulist><ul><li><p><code>semctl(semid, semnum, cmd, …​)</code>: <code>semctl</code> does the specified <code>cmd</code> on the semaphore queue indicated by <code>semid</code>.</p></li><li><p><code>semget(key, nsems, flag)</code>: <code>semget</code> creates an array of semaphores, corresponding to <code>key</code>.</p><div class=paragraph><p><code>key and flag take on the same meaning as they do in msgget.</code></p></div></li><li><p><code>semop(semid, array, nops)</code>: <code>semop</code> performs a group of operations indicated by <code>array</code>, to the set of semaphores identified by <code>semid</code>.</p></li></ul></div><div class=paragraph><p>System V IPC allows for processes to share memory. Processes can communicate directly with each other by sharing parts of their virtual address space and then reading and writing data stored in the shared memory. These system calls are blocked within a jailed environment: <a href="https://man.freebsd.org/cgi/man.cgi?query=shmdt&amp;sektion=2&amp;format=html">shmdt(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=shmat&amp;sektion=2&amp;format=html">shmat(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=shmctl&amp;sektion=2&amp;format=html">shmctl(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=shmget&amp;sektion=2&amp;format=html">shmget(2)</a>.</p></div><div class=paragraph><p><span class=filename>/usr/src/sys/kern/sysv_shm.c</span>:</p></div><div class=ulist><ul><li><p><code>shmctl(shmid, cmd, buf)</code>: <code>shmctl</code> does various control operations on the shared memory region identified by <code>shmid</code>.</p></li><li><p><code>shmget(key, size, flag)</code>: <code>shmget</code> accesses or creates a shared memory region of <code>size</code> bytes.</p></li><li><p><code>shmat(shmid, addr, flag)</code>: <code>shmat</code> attaches a shared memory region identified by <code>shmid</code> to the address space of a process.</p></li><li><p><code>shmdt(addr)</code>: <code>shmdt</code> detaches the shared memory region previously attached at <code>addr</code>.</p></li></ul></div></div><div class=sect3><h4 id=_sockets>4.2.2. Sockets<a class=anchor href=#_sockets></a></h4><div class=paragraph><p>Jail treats the <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> system call and related lower-level socket functions in a special manner. In order to determine whether a certain socket is allowed to be created, it first checks to see if the sysctl <code>security.jail.socket_unixiproute_only</code> is set. If set, sockets are only allowed to be created if the family specified is either <code>PF_LOCAL</code>, <code>PF_INET</code> or <code>PF_ROUTE</code>. Otherwise, it returns an error.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/uipc_socket.c:
int
socreate(int dom, struct socket **aso, int type, int proto,
    struct ucred *cred, struct thread *td)
{
    struct protosw *prp;
...
    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {
        return (EPROTONOSUPPORT);
    }
...
}</pre></div></div></div><div class=sect3><h4 id=_berkeley_packet_filter>4.2.3. Berkeley Packet Filter<a class=anchor href=#_berkeley_packet_filter></a></h4><div class=paragraph><p>The Berkeley Packet Filter provides a raw interface to data link layers in a protocol independent fashion. BPF is now controlled by the <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> whether it can be used in a jailed environment.</p></div></div><div class=sect3><h4 id=_protocols>4.2.4. Protocols<a class=anchor href=#_protocols></a></h4><div class=paragraph><p>There are certain protocols which are very common, such as TCP, UDP, IP and ICMP. IP and ICMP are on the same level: the network layer 2. There are certain precautions which are taken in order to prevent a jailed process from binding a protocol to a certain address only if the <code>nam</code> parameter is set. <code>nam</code> is a pointer to a <code>sockaddr</code> structure, which describes the address on which to bind the service. A more exact definition is that <code>sockaddr</code> "may be used as a template for referring to the identifying tag and length of each address". In the function <code>in_pcbbind_setup()</code>, <code>sin</code> is a pointer to a <code>sockaddr_in</code> structure, which contains the port, address, length and domain family of the socket which is to be bound. Basically, this disallows any processes from jail to be able to specify the address that does not belong to the jail in which the calling process exists.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/netinet/in_pcb.c:
int
in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,
    u_short *lportp, struct ucred *cred)
{
    ...
    struct sockaddr_in *sin;
    ...
    if (nam) {
        sin = (struct sockaddr_in *)nam;
        ...
        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)
            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))
                return(EINVAL);
        ...
        if (lport) {
            ...
            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))
                return (EADDRNOTAVAIL);
            ...
        }
    }
    if (lport == 0) {
        ...
        if (laddr.s_addr != INADDR_ANY)
            if (prison_ip(cred, 0, &amp;laddr.s_addr))
                return (EINVAL);
        ...
    }
...
    if (prison_ip(cred, 0, &amp;laddr.s_addr))
        return (EINVAL);
...
}</pre></div></div><div class=paragraph><p>You might be wondering what function <code>prison_ip()</code> does. <code>prison_ip()</code> is given three arguments, a pointer to the credential(represented by <code>cred</code>), any flags, and an IP address. It returns 1 if the IP address does NOT belong to the jail or 0 otherwise. As you can see from the code, if it is indeed an IP address not belonging to the jail, the protocol is not allowed to bind to that address.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
int
prison_ip(struct ucred *cred, int flag, u_int32_t *ip)
{
    u_int32_t tmp;

    if (!jailed(cred))
        return (0);
    if (flag)
        tmp = *ip;
    else
        tmp = ntohl(*ip);
    if (tmp == INADDR_ANY) {
        if (flag)
            *ip = cred-&gt;cr_prison-&gt;pr_ip;
        else
            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);
        return (0);
    }
    if (tmp == INADDR_LOOPBACK) {
        if (flag)
            *ip = cred-&gt;cr_prison-&gt;pr_ip;
        else
            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);
        return (0);
    }
    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)
        return (1);
    return (0);
}</pre></div></div></div><div class=sect3><h4 id=_filesystem>4.2.5. Filesystem<a class=anchor href=#_filesystem></a></h4><div class=paragraph><p>Even <code>root</code> users within the jail are not allowed to unset or modify any file flags, such as immutable, append-only, and undeleteable flags, if the securelevel is greater than 0.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/ufs/ufs/ufs_vnops.c:
static int
ufs_setattr(ap)
    ...
{
    ...
        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {
            if (ip-&gt;i_flags
                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {
                    error = securelevel_gt(cred, 0);
                    if (error)
                        return (error);
            }
            ...
        }
}
/usr/src/sys/kern/kern_priv.c
int
priv_check_cred(struct ucred *cred, int priv, int flags)
{
    ...
    error = prison_priv_check(cred, priv);
    if (error)
        return (error);
    ...
}
/usr/src/sys/kern/kern_jail.c
int
prison_priv_check(struct ucred *cred, int priv)
{
    ...
    switch (priv) {
    ...
    case PRIV_VFS_SYSFLAGS:
        if (jail_chflags_allowed)
            return (0);
        else
            return (EPERM);
    ...
    }
    ...
}</pre></div></div></div></div></div></div><div class=sect1><h2 id=sysinit>Chapter 5. The SYSINIT Framework<a class=anchor href=#sysinit></a></h2><div class=sectionbody><div class=paragraph><p>SYSINIT is the framework for a generic call sort and dispatch mechanism. FreeBSD currently uses it for the dynamic initialization of the kernel. SYSINIT allows FreeBSD’s kernel subsystems to be reordered, and added, removed, and replaced at kernel link time when the kernel or one of its modules is loaded without having to edit a statically ordered initialization routing and recompile the kernel. This system also allows kernel modules, currently called <em>KLD’s</em>, to be separately compiled, linked, and initialized at boot time and loaded even later while the system is already running. This is accomplished using the "kernel linker" and "linker sets".</p></div><div class=sect2><h3 id=sysinit-term>5.1. Terminology<a class=anchor href=#sysinit-term></a></h3><div class=dlist><dl><dt class=hdlist1>Linker Set</dt><dd><p>A linker technique in which the linker gathers statically declared data throughout a program’s source files into a single contiguously addressable unit of data.</p></dd></dl></div></div><div class=sect2><h3 id=sysinit-operation>5.2. SYSINIT Operation<a class=anchor href=#sysinit-operation></a></h3><div class=paragraph><p>SYSINIT relies on the ability of the linker to take static data declared at multiple locations throughout a program’s source and group it together as a single contiguous chunk of data. This linker technique is called a "linker set". SYSINIT uses two linker sets to maintain two data sets containing each consumer’s call order, function, and a pointer to the data to pass to that function.</p></div><div class=paragraph><p>SYSINIT uses two priorities when ordering the functions for execution. The first priority is a subsystem ID giving an overall order for SYSINIT’s dispatch of functions. Current predeclared ID’s are in <span class=filename>&lt;sys/kernel.h></span> in the enum list <code>sysinit_sub_id</code>. The second priority used is an element order within the subsystem. Current predeclared subsystem element orders are in <span class=filename>&lt;sys/kernel.h></span> in the enum list <code>sysinit_elem_order</code>.</p></div><div class=paragraph><p>There are currently two uses for SYSINIT. Function dispatch at system startup and kernel module loads, and function dispatch at system shutdown and kernel module unload. Kernel subsystems often use system startup SYSINIT’s to initialize data structures, for example the process scheduling subsystem uses a SYSINIT to initialize the run queue data structure. Device drivers should avoid using <code>SYSINIT()</code> directly. Instead drivers for real devices that are part of a bus structure should use <code>DRIVER_MODULE()</code> to provide a function that detects the device and, if it is present, initializes the device. It will do a few things specific to devices and then call <code>SYSINIT()</code> itself. For pseudo-devices, which are not part of a bus structure, use <code>DEV_MODULE()</code>.</p></div></div><div class=sect2><h3 id=sysinit-using>5.3. Using SYSINIT<a class=anchor href=#sysinit-using></a></h3><div class=sect3><h4 id=_interface>5.3.1. Interface<a class=anchor href=#_interface></a></h4><div class=sect4><h5 id=_headers_2>5.3.1.1. Headers<a class=anchor href=#_headers_2></a></h5><div class="literalblock programlisting"><div class=content><pre>&lt;sys/kernel.h&gt;</pre></div></div></div><div class=sect4><h5 id=_macros_2>5.3.1.2. Macros<a class=anchor href=#_macros_2></a></h5><div class="literalblock programlisting"><div class=content><pre>SYSINIT(uniquifier, subsystem, order, func, ident)
SYSUNINIT(uniquifier, subsystem, order, func, ident)</pre></div></div></div></div><div class=sect3><h4 id=_startup>5.3.2. Startup<a class=anchor href=#_startup></a></h4><div class=paragraph><p>The <code>SYSINIT()</code> macro creates the necessary SYSINIT data in SYSINIT’s startup data set for SYSINIT to sort and dispatch a function at system startup and module load. <code>SYSINIT()</code> takes a uniquifier that SYSINIT uses to identify the particular function dispatch data, the subsystem order, the subsystem element order, the function to call, and the data to pass the function. All functions must take a constant pointer argument.</p></div><div class=exampleblock><div class=title>Example 1. Example of a <code>SYSINIT()</code></div><div class=content><div class="literalblock programlisting"><div class=content><pre>#include &lt;sys/kernel.h&gt;

void foo_null(void *unused)
{
        foo_doo();
}
SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);

struct foo foo_voodoo = {
        FOO_VOODOO;
}

void foo_arg(void *vdata)
{
        struct foo *foo = (struct foo *)vdata;
        foo_data(foo);
}
SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);</pre></div></div></div></div><div class=paragraph><p>Note that <code>SI_SUB_FOO</code> and <code>SI_ORDER_FOO</code> need to be in the <code>sysinit_sub_id</code> and <code>sysinit_elem_order</code> enum’s as mentioned above. Either use existing ones or add your own to the enum’s. You can also use math for fine-tuning the order a SYSINIT will run in. This example shows a SYSINIT that needs to be run just barely before the SYSINIT’s that handle tuning kernel parameters.</p></div><div class=exampleblock><div class=title>Example 2. Example of Adjusting <code>SYSINIT()</code> Order</div><div class=content><div class="literalblock programlisting"><div class=content><pre>static void
mptable_register(void *dummy __unused)
{

	apic_register_enumerator(&amp;mptable_enumerator);
}

SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,
    mptable_register, NULL);</pre></div></div></div></div></div><div class=sect3><h4 id=_shutdown>5.3.3. Shutdown<a class=anchor href=#_shutdown></a></h4><div class=paragraph><p>The <code>SYSUNINIT()</code> macro behaves similarly to the <code>SYSINIT()</code> macro except that it adds the SYSINIT data to SYSINIT’s shutdown data set.</p></div><div class=exampleblock><div class=title>Example 3. Example of a <code>SYSUNINIT()</code></div><div class=content><div class="literalblock programlisting"><div class=content><pre>#include &lt;sys/kernel.h&gt;

void foo_cleanup(void *unused)
{
        foo_kill();
}
SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);

struct foo_stack foo_stack = {
        FOO_STACK_VOODOO;
}

void foo_flush(void *vdata)
{
}
SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);</pre></div></div></div></div></div></div></div></div><div class=sect1><h2 id=mac>Chapter 6. The TrustedBSD MAC Framework<a class=anchor href=#mac></a></h2><div class=sectionbody><div class=sect2><h3 id=mac-copyright>6.1. MAC Documentation Copyright<a class=anchor href=#mac-copyright></a></h3><div class=paragraph><p>This documentation was developed for the FreeBSD Project by Chris Costello at Safeport Network Services and Network Associates Laboratories, the Security Research Division of Network Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS research program.</p></div><div class=paragraph><p>Redistribution and use in source (SGML DocBook) and 'compiled' forms (SGML, HTML, PDF, PostScript, RTF and so forth) with or without modification, are permitted provided that the following conditions are met:</p></div><div class="olist arabic"><ol class=arabic><li><p>Redistributions of source code (SGML DocBook) must retain the above copyright notice, this list of conditions and the following disclaimer as the first lines of this file unmodified.</p></li><li><p>Redistributions in compiled form (transformed to other DTDs, converted to PDF, PostScript, RTF and other formats) must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p></li></ol></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES TECHNOLOGY, INC "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY, INC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-synopsis>6.2. Synopsis<a class=anchor href=#mac-synopsis></a></h3><div class=paragraph><p>FreeBSD includes experimental support for several mandatory access control policies, as well as a framework for kernel security extensibility, the TrustedBSD MAC Framework.
The MAC Framework is a pluggable access control framework, permitting new security policies to be easily linked into the kernel, loaded at boot, or loaded dynamically at run-time.
The framework provides a variety of features to make it easier to implement new security policies, including the ability to easily tag security labels (such as confidentiality information) onto system objects.</p></div><div class=paragraph><p>This chapter introduces the MAC policy framework and provides documentation for a sample MAC policy module.</p></div></div><div class=sect2><h3 id=mac-introduction>6.3. Introduction<a class=anchor href=#mac-introduction></a></h3><div class=paragraph><p>The TrustedBSD MAC framework provides a mechanism to allow the compile-time or run-time extension of the kernel access control model.
New system policies may be implemented as kernel modules and linked to the kernel; if multiple policy modules are present, their results will be composed.
The MAC Framework provides a variety of access control infrastructure services to assist policy writers, including support for transient and persistent policy-agnostic object security labels.
This support is currently considered experimental.</p></div><div class=paragraph><p>This chapter provides information appropriate for developers of policy modules, as well as potential consumers of MAC-enabled environments, to learn about how the MAC Framework supports access control extension of the kernel.</p></div></div><div class=sect2><h3 id=mac-background>6.4. Policy Background<a class=anchor href=#mac-background></a></h3><div class=paragraph><p>Mandatory Access Control (MAC), refers to a set of access control policies that are mandatorily enforced on users by the operating system.
MAC policies may be contrasted with Discretionary Access Control (DAC) protections, by which non-administrative users may (at their discretion) protect objects.
In traditional UNIX systems, DAC protections include file permissions and access control lists; MAC protections include process controls preventing inter-user debugging and firewalls.
A variety of MAC policies have been formulated by operating system designers and security researches, including the Multi-Level Security (MLS) confidentiality policy, the Biba integrity policy, Role-Based Access Control (RBAC), Domain and Type Enforcement (DTE), and Type Enforcement (TE).
Each model bases decisions on a variety of factors, including user identity, role, and security clearance, as well as security labels on objects representing concepts such as data sensitivity and integrity.</p></div><div class=paragraph><p>The TrustedBSD MAC Framework is capable of supporting policy modules that implement all of these policies, as well as a broad class of system hardening policies, which may use existing security attributes, such as user and group IDs, as well as extended attributes on files, and other system properties.
In addition, despite the name, the MAC Framework can also be used to implement purely discretionary policies, as policy modules are given substantial flexibility in how they authorize protections.</p></div></div><div class=sect2><h3 id=mac-framework-kernel-arch>6.5. MAC Framework Kernel Architecture<a class=anchor href=#mac-framework-kernel-arch></a></h3><div class=paragraph><p>The TrustedBSD MAC Framework permits kernel modules to extend the operating system security policy, as well as providing infrastructure functionality required by many access control modules.
If multiple policies are simultaneously loaded, the MAC Framework will usefully (for some definition of useful) compose the results of the policies.</p></div><div class=sect3><h4 id=mac-framework-kernel-arch-elements>6.5.1. Kernel Elements<a class=anchor href=#mac-framework-kernel-arch-elements></a></h4><div class=paragraph><p>The MAC Framework contains a number of kernel elements:</p></div><div class=ulist><ul><li><p>Framework management interfaces</p></li><li><p>Concurrency and synchronization primitives.</p></li><li><p>Policy registration</p></li><li><p>Extensible security label for kernel objects</p></li><li><p>Policy entry point composition operators</p></li><li><p>Label management primitives</p></li><li><p>Entry point API invoked by kernel services</p></li><li><p>Entry point API to policy modules</p></li><li><p>Entry points implementations (policy life cycle, object life cycle/label management, access control checks).</p></li><li><p>Policy-agnostic label-management system calls</p></li><li><p><code>mac_syscall()</code> multiplex system call</p></li><li><p>Various security policies implemented as MAC policy modules</p></li></ul></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-management>6.5.2. Framework Management Interfaces<a class=anchor href=#mac-framework-kernel-arch-management></a></h4><div class=paragraph><p>The TrustedBSD MAC Framework may be directly managed using sysctl’s, loader tunables, and system calls.</p></div><div class=paragraph><p>In most cases, sysctl’s and loader tunables of the same name modify the same parameters, and control behavior such as enforcement of protections relating to various kernel subsystems.
In addition, if MAC debugging support is compiled into the kernel, several counters will be maintained tracking label allocation.
It is generally advisable that per-subsystem enforcement controls not be used to control policy behavior in production environments, as they broadly impact the operation of all active policies.
Instead, per-policy controls should be preferred, as they provide greater granularity and greater operational consistency for policy modules.</p></div><div class=paragraph><p>Loading and unloading of policy modules is performed using the system module management system calls and other system interfaces, including boot loader variables; policy modules will have the opportunity to influence load and unload events, including preventing undesired unloading of the policy.</p></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-synchronization>6.5.3. Policy List Concurrency and Synchronization<a class=anchor href=#mac-framework-kernel-arch-synchronization></a></h4><div class=paragraph><p>As the set of active policies may change at run-time, and the invocation of entry points is non-atomic, synchronization is required to prevent loading or unloading of policies while an entry point invocation is in progress, freezing the set of active policies for the duration.
This is accomplished by means of a framework busy count: whenever an entry point is entered, the busy count is incremented; whenever it is exited, the busy count is decremented.
While the busy count is elevated, policy list changes are not permitted, and threads attempting to modify the policy list will sleep until the list is not busy.
The busy count is protected by a mutex, and a condition variable is used to wake up sleepers waiting on policy list modifications.
One side effect of this synchronization model is that recursion into the MAC Framework from within a policy module is permitted, although not generally used.</p></div><div class=paragraph><p>Various optimizations are used to reduce the overhead of the busy count, including avoiding the full cost of incrementing and decrementing if the list is empty or contains only static entries (policies that are loaded before the system starts, and cannot be unloaded).
A compile-time option is also provided which prevents any change in the set of loaded policies at run-time, which eliminates the mutex locking costs associated with supporting dynamically loaded and unloaded policies as synchronization is no longer required.</p></div><div class=paragraph><p>As the MAC Framework is not permitted to block in some entry points, a normal sleep lock cannot be used; as a result, it is possible for the load or unload attempt to block for a substantial period of time waiting for the framework to become idle.</p></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-label-synchronization>6.5.4. Label Synchronization<a class=anchor href=#mac-framework-kernel-arch-label-synchronization></a></h4><div class=paragraph><p>As kernel objects of interest may generally be accessed from more than one thread at a time, and simultaneous entry of more than one thread into the MAC Framework is permitted, security attribute storage maintained by the MAC Framework is carefully synchronized.
In general, existing kernel synchronization on kernel object data is used to protect MAC Framework security labels on the object: for example, MAC labels on sockets are protected using the existing socket mutex.
Likewise, semantics for concurrent access are generally identical to those of the container objects: for credentials, copy-on-write semantics are maintained for label contents as with the remainder of the credential structure.
The MAC Framework asserts necessary locks on objects when invoked with an object reference.
Policy authors must be aware of these synchronization semantics, as they will sometimes limit the types of accesses permitted on labels: for example, when a read-only reference to a credential is passed to a policy via an entry point, only read operations are permitted on the label state attached to the credential.</p></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-policy-synchronization>6.5.5. Policy Synchronization and Concurrency<a class=anchor href=#mac-framework-kernel-arch-policy-synchronization></a></h4><div class=paragraph><p>Policy modules must be written to assume that many kernel threads may simultaneously enter one more policy entry points due to the parallel and preemptive nature of the FreeBSD kernel.
If the policy module makes use of mutable state, this may require the use of synchronization primitives within the policy to prevent inconsistent views on that state resulting in incorrect operation of the policy.
Policies will generally be able to make use of existing FreeBSD synchronization primitives for this purpose, including mutexes, sleep locks, condition variables, and counting semaphores.
However, policies should be written to employ these primitives carefully, respecting existing kernel lock orders, and recognizing that some entry points are not permitted to sleep, limiting the use of primitives in those entry points to mutexes and wakeup operations.</p></div><div class=paragraph><p>When policy modules call out to other kernel subsystems, they will generally need to release any in-policy locks in order to avoid violating the kernel lock order or risking lock recursion.
This will maintain policy locks as leaf locks in the global lock order, helping to avoid deadlock.</p></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-registration>6.5.6. Policy Registration<a class=anchor href=#mac-framework-kernel-arch-registration></a></h4><div class=paragraph><p>The MAC Framework maintains two lists of active policies: a static list, and a dynamic list.
The lists differ only with regards to their locking semantics: an elevated reference count is not required to make use of the static list.
When kernel modules containing MAC Framework policies are loaded, the policy module will use <code>SYSINIT</code> to invoke a registration function; when a policy module is unloaded, <code>SYSINIT</code> will likewise invoke a de-registration function.
Registration may fail if a policy module is loaded more than once, if insufficient resources are available for the registration (for example, the policy might require labeling and insufficient labeling state might be available), or other policy prerequisites might not be met (some policies may only be loaded prior to boot).
Likewise, de-registration may fail if a policy is flagged as not unloadable.</p></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-entrypoints>6.5.7. Entry Points<a class=anchor href=#mac-framework-kernel-arch-entrypoints></a></h4><div class=paragraph><p>Kernel services interact with the MAC Framework in two ways: they invoke a series of APIs to notify the framework of relevant events, and they provide a policy-agnostic label structure pointer in security-relevant objects.
The label pointer is maintained by the MAC Framework via label management entry points, and permits the Framework to offer a labeling service to policy modules through relatively non-invasive changes to the kernel subsystem maintaining the object.
For example, label pointers have been added to processes, process credentials, sockets, pipes, vnodes, Mbufs, network interfaces, IP reassembly queues, and a variety of other security-relevant structures.
Kernel services also invoke the MAC Framework when they perform important security decisions, permitting policy modules to augment those decisions based on their own criteria (possibly including data stored in security labels).
Most of these security critical decisions will be explicit access control checks; however, some affect more general decision functions such as packet matching for sockets and label transition at program execution.</p></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-composition>6.5.8. Policy Composition<a class=anchor href=#mac-framework-kernel-arch-composition></a></h4><div class=paragraph><p>When more than one policy module is loaded into the kernel at a time, the results of the policy modules will be composed by the framework using a composition operator.
This operator is currently hard-coded, and requires that all active policies must approve a request for it to return success.
As policies may return a variety of error conditions (success, access denied, object does not exist, …​), a precedence operator selects the resulting error from the set of errors returned by policies.
In general, errors indicating that an object does not exist will be preferred to errors indicating that access to an object is denied.
While it is not guaranteed that the resulting composition will be useful or secure, we have found that it is for many useful selections of policies.
For example, traditional trusted systems often ship with two or more policies using a similar composition.</p></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-labels>6.5.9. Labeling Support<a class=anchor href=#mac-framework-kernel-arch-labels></a></h4><div class=paragraph><p>As many interesting access control extensions rely on security labels on objects, the MAC Framework provides a set of policy-agnostic label management system calls covering a variety of user-exposed objects.
Common label types include partition identifiers, sensitivity labels, integrity labels, compartments, domains, roles, and types.
By policy agnostic, we mean that policy modules are able to completely define the semantics of meta-data associated with an object.
Policy modules participate in the internalization and externalization of string-based labels provides by user applications, and can expose multiple label elements to applications if desired.</p></div><div class=paragraph><p>In-memory labels are stored in slab-allocated <code>struct label</code>, which consists of a fixed-length array of unions, each holding a <code>void *</code> pointer and a <code>long</code>.
Policies registering for label storage will be assigned a "slot" identifier, which may be used to dereference the label storage.
The semantics of the storage are left entirely up to the policy module: modules are provided with a variety of entry points associated with the kernel object life cycle, including initialization, association/creation, and destruction.
Using these interfaces, it is possible to implement reference counting and other storage models.
Direct access to the object structure is generally not required by policy modules to retrieve a label, as the MAC Framework generally passes both a pointer to the object and a direct pointer to the object’s label into entry points.
The primary exception to this rule is the process credential, which must be manually dereferenced to access the credential label.
This may change in future revisions of the MAC Framework.</p></div><div class=paragraph><p>Initialization entry points frequently include a sleeping disposition flag indicating whether or not an initialization is permitted to sleep; if sleeping is not permitted, a failure may be returned to cancel allocation of the label (and hence object).
This may occur, for example, in the network stack during interrupt handling, where sleeping is not permitted, or while the caller holds a mutex.
Due to the performance cost of maintaining labels on in-flight network packets (Mbufs), policies must specifically declare a requirement that Mbuf labels be allocated.
Dynamically loaded policies making use of labels must be able to handle the case where their init function has not been called on an object, as objects may already exist when the policy is loaded.
The MAC Framework guarantees that uninitialized label slots will hold a 0 or NULL value, which policies may use to detect uninitialized values.
However, as allocation of Mbuf labels is conditional, policies must also be able to handle a NULL label pointer for Mbufs if they have been loaded dynamically.</p></div><div class=paragraph><p>In the case of file system labels, special support is provided for the persistent storage of security labels in extended attributes.
Where available, extended attribute transactions are used to permit consistent compound updates of security labels on vnodes—​currently this support is present only in the UFS2 file system.
Policy authors may choose to implement multilabel file system object labels using one (or more) extended attributes.
For efficiency reasons, the vnode label (<code>v_label</code>) is a cache of any on-disk label; policies are able to load values into the cache when the vnode is instantiated, and update the cache as needed.
As a result, the extended attribute need not be directly accessed with every access control check.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Currently, if a labeled policy permits dynamic unloading, its state slot cannot be reclaimed, which places a strict (and relatively low) bound on the number of unload-reload operations for labeled policies.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mac-framework-kernel-arch-syscalls>6.5.10. System Calls<a class=anchor href=#mac-framework-kernel-arch-syscalls></a></h4><div class=paragraph><p>The MAC Framework implements a number of system calls: most of these calls support the policy-agnostic label retrieval and manipulation APIs exposed to user applications.</p></div><div class=paragraph><p>The label management calls accept a label description structure, <code>struct mac</code>, which contains a series of MAC label elements.
Each element contains a character string name, and character string value.
Each policy will be given the chance to claim a particular element name, permitting policies to expose multiple independent elements if desired.
Policy modules perform the internalization and externalization between kernel labels and user-provided labels via entry points, permitting a variety of semantics.
Label management system calls are generally wrapped by user library functions to perform memory allocation and error handling, simplifying user applications that must manage labels.</p></div><div class=paragraph><p>The following MAC-related system calls are present in the FreeBSD kernel:</p></div><div class=ulist><ul><li><p><code>mac_get_proc()</code> may be used to retrieve the label of the current process.</p></li><li><p><code>mac_set_proc()</code> may be used to request a change in the label of the current process.</p></li><li><p><code>mac_get_fd()</code> may be used to retrieve the label of an object (file, socket, pipe, …​) referenced by a file descriptor.</p></li><li><p><code>mac_get_file()</code> may be used to retrieve the label of an object referenced by a file system path.</p></li><li><p><code>mac_set_fd()</code> may be used to request a change in the label of an object (file, socket, pipe, …​) referenced by a file descriptor.</p></li><li><p><code>mac_set_file()</code> may be used to request a change in the label of an object referenced by a file system path.</p></li><li><p><code>mac_syscall()</code> permits policy modules to create new system calls without modifying the system call table; it accepts a target policy name, operation number, and opaque argument for use by the policy.</p></li><li><p><code>mac_get_pid()</code> may be used to request the label of another process by process id.</p></li><li><p><code>mac_get_link()</code> is identical to <code>mac_get_file()</code>, only it will not follow a symbolic link if it is the final entry in the path, so may be used to retrieve the label on a symlink.</p></li><li><p><code>mac_set_link()</code> is identical to <code>mac_set_file()</code>, only it will not follow a symbolic link if it is the final entry in a path, so may be used to manipulate the label on a symlink.</p></li><li><p><code>mac_execve()</code> is identical to the <code>execve()</code> system call, only it also accepts a requested label to set the process label to when beginning execution of a new program.
This change in label on execution is referred to as a "transition".</p></li><li><p><code>mac_get_peer()</code>, actually implemented via a socket option, retrieves the label of a remote peer on a socket, if available.</p></li></ul></div><div class=paragraph><p>In addition to these system calls, the <code>SIOCSIGMAC</code> and <code>SIOCSIFMAC</code> network interface ioctls permit the labels on network interfaces to be retrieved and set.</p></div></div></div><div class=sect2><h3 id=mac-policy-architecture>6.6. MAC Policy Architecture<a class=anchor href=#mac-policy-architecture></a></h3><div class=paragraph><p>Security policies are either linked directly into the kernel, or compiled into loadable kernel modules that may be loaded at boot, or dynamically using the module loading system calls at runtime.
Policy modules interact with the system through a set of declared entry points, providing access to a stream of system events and permitting the policy to influence access control decisions.
Each policy contains a number of elements:</p></div><div class=ulist><ul><li><p>Optional configuration parameters for policy.</p></li><li><p>Centralized implementation of the policy logic and parameters.</p></li><li><p>Optional implementation of policy life cycle events, such as initialization and destruction.</p></li><li><p>Optional support for initializing, maintaining, and destroying labels on selected kernel objects.</p></li><li><p>Optional support for user process inspection and modification of labels on selected objects.</p></li><li><p>Implementation of selected access control entry points that are of interest to the policy.</p></li><li><p>Declaration of policy identity, module entry points, and policy properties.</p></li></ul></div><div class=sect3><h4 id=mac-policy-declaration>6.6.1. Policy Declaration<a class=anchor href=#mac-policy-declaration></a></h4><div class=paragraph><p>Modules may be declared using the <code>MAC_POLICY_SET()</code> macro, which names the policy, provides a reference to the MAC entry point vector, provides load-time flags determining how the policy framework should handle the policy, and optionally requests the allocation of label state by the framework.</p></div><div class="literalblock programlisting"><div class=content><pre>static struct mac_policy_ops mac_policy_ops =
{
        .mpo_destroy = mac_policy_destroy,
        .mpo_init = mac_policy_init,
        .mpo_init_bpfdesc_label = mac_policy_init_bpfdesc_label,
        .mpo_init_cred_label = mac_policy_init_label,
/* ... */
        .mpo_check_vnode_setutimes = mac_policy_check_vnode_setutimes,
        .mpo_check_vnode_stat = mac_policy_check_vnode_stat,
        .mpo_check_vnode_write = mac_policy_check_vnode_write,
};</pre></div></div><div class=paragraph><p>The MAC policy entry point vector, <code>mac<em>policy</em>ops</code> in this example, associates functions defined in the module with specific entry points.
A complete listing of available entry points and their prototypes may be found in the MAC entry point reference section.
Of specific interest during module registration are the .mpo_destroy and .mpo_init entry points.
.mpo_init will be invoked once a policy is successfully registered with the module framework but prior to any other entry points becoming active.
This permits the policy to perform any policy-specific allocation and initialization, such as initialization of any data or locks.
.mpo_destroy will be invoked when a policy module is unloaded to permit releasing of any allocated memory and destruction of locks.
Currently, these two entry points are invoked with the MAC policy list mutex held to prevent any other entry points from being invoked: this will be changed, but in the mean time, policies should be careful about what kernel primitives they invoke so as to avoid lock ordering or sleeping problems.</p></div><div class=paragraph><p>The policy declaration’s module name field exists so that the module may be uniquely identified for the purposes of module dependencies.
An appropriate string should be selected.
The full string name of the policy is displayed to the user via the kernel log during load and unload events, and also exported when providing status information to userland processes.</p></div></div><div class=sect3><h4 id=mac-policy-flags>6.6.2. Policy Flags<a class=anchor href=#mac-policy-flags></a></h4><div class=paragraph><p>The policy declaration flags field permits the module to provide the framework with information about its capabilities at the time the module is loaded.
Currently, three flags are defined:</p></div><div class=dlist><dl><dt class=hdlist1>MPC_LOADTIME_FLAG_UNLOADOK</dt><dd><p>This flag indicates that the policy module may be unloaded.
If this flag is not provided, then the policy framework will reject requests to unload the module.
This flag might be used by modules that allocate label state and are unable to free that state at runtime.</p></dd><dt class=hdlist1>MPC_LOADTIME_FLAG_NOTLATE</dt><dd><p>This flag indicates that the policy module must be loaded and initialized early in the boot process.
If the flag is specified, attempts to register the module following boot will be rejected.
The flag may be used by policies that require pervasive labeling of all system objects, and cannot handle objects that have not been properly initialized by the policy.</p></dd><dt class=hdlist1>MPC_LOADTIME_FLAG_LABELMBUFS</dt><dd><p>This flag indicates that the policy module requires labeling of Mbufs, and that memory should always be allocated for the storage of Mbuf labels.
By default, the MAC Framework will not allocate label storage for Mbufs unless at least one loaded policy has this flag set.
This measurably improves network performance when policies do not require Mbuf labeling.
A kernel option, <code>MAC_ALWAYS_LABEL_MBUF</code>, exists to force the MAC Framework to allocate Mbuf label storage regardless of the setting of this flag, and may be useful in some environments.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Policies using the <code>MPC_LOADTIME_FLAG_LABELMBUFS</code> without the <code>MPC_LOADTIME_FLAG_NOTLATE</code> flag set must be able to correctly handle <code>NULL</code> Mbuf label pointers passed into entry points.
This is necessary as in-flight Mbufs without label storage may persist after a policy enabling Mbuf labeling has been loaded.
If a policy is loaded before the network subsystem is active (i.e., the policy is not being loaded late), then all Mbufs are guaranteed to have label storage.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mac-policy-entry-points>6.6.3. Policy Entry Points<a class=anchor href=#mac-policy-entry-points></a></h4><div class=paragraph><p>Four classes of entry points are offered to policies registered with the framework: entry points associated with the registration and management of policies, entry points denoting initialization, creation, destruction, and other life cycle events for kernel objects, events associated with access control decisions that the policy module may influence, and calls associated with the management of labels on objects.
In addition, a <code>mac_syscall()</code> entry point is provided so that policies may extend the kernel interface without registering new system calls.</p></div><div class=paragraph><p>Policy module writers should be aware of the kernel locking strategy, as well as what object locks are available during which entry points.
Writers should attempt to avoid deadlock scenarios by avoiding grabbing non-leaf locks inside of entry points, and also follow the locking protocol for object access and modification.
In particular, writers should be aware that while necessary locks to access objects and their labels are generally held, sufficient locks to modify an object or its label may not be present for all entry points.
Locking information for arguments is documented in the MAC framework entry point document.</p></div><div class=paragraph><p>Policy entry points will pass a reference to the object label along with the object itself.
This permits labeled policies to be unaware of the internals of the object yet still make decisions based on the label.
The exception to this is the process credential, which is assumed to be understood by policies as a first class security object in the kernel.</p></div></div></div><div class=sect2><h3 id=mac-entry-point-reference>6.7. MAC Policy Entry Point Reference<a class=anchor href=#mac-entry-point-reference></a></h3><div class=sect3><h4 id=mac-mpo-general>6.7.1. General-Purpose Module Entry Points<a class=anchor href=#mac-mpo-general></a></h4><div class=sect4><h5 id=mac-mpo-init>6.7.1.1. <code>mpo_init</code><a class=anchor href=#mac-mpo-init></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init</span><span class=p>(</span><span class=k>struct</span> <span class=n>mac_policy_conf</span> <span class=o>*</span><span class=n>conf</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MAC policy definition</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Policy load event.
The policy list mutex is held, so sleep operations cannot be performed, and calls out to other kernel subsystems must be made with caution.
If potentially sleeping memory allocations are required during policy initialization, they should be made using a separate module SYSINIT().</p></div></div><div class=sect4><h5 id=mpo-destroy>6.7.1.2. <code>mpo_destroy</code><a class=anchor href=#mpo-destroy></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy</span><span class=p>(</span><span class=k>struct</span> <span class=n>mac_policy_conf</span> <span class=o>*</span><span class=n>conf</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MAC policy definition</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Policy load event.
The policy list mutex is held, so caution should be applied.</p></div></div><div class=sect4><h5 id=mac-mpo-syscall>6.7.1.3. <code>mpo_syscall</code><a class=anchor href=#mac-mpo-syscall></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_syscall</span><span class=p>(</span><span class=k>struct</span> <span class=kr>thread</span> <span class=o>*</span><span class=n>td</span><span class=p>,</span> <span class=kt>int</span> <span class=n>call</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>td</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Calling thread</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>call</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy-specific syscall number</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>arg</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pointer to syscall arguments</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>This entry point provides a policy-multiplexed system call so that policies may provide additional services to user processes without registering specific system calls.
The policy name provided during registration is used to demultiplexer calls from userland, and the arguments will be forwarded to this entry point.
When implementing new services, security modules should be sure to invoke appropriate access control checks from the MAC framework as needed.
For example, if a policy implements an augmented signal functionality, it should call the necessary signal access control checks to invoke the MAC framework and other registered policies.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Modules must currently perform the <code>copyin()</code> of the syscall data on their own.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=mac-mpo-thread-userret>6.7.1.4. <code>mpo_thread_userret</code><a class=anchor href=#mac-mpo-thread-userret></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_thread_userret</span><span class=p>(</span><span class=k>struct</span> <span class=kr>thread</span> <span class=o>*</span><span class=n>td</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>td</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Returning thread</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>This entry point permits policy modules to perform MAC-related events when a thread returns to user space, via a system call return, trap return, or otherwise.
This is required for policies that have floating process labels, as it is not always possible to acquire the process lock at arbitrary points in the stack during system call processing; process labels might represent traditional authentication data, process history information, or other data.
To employ this mechanism, intended changes to the process credential label may be stored in the <code>p_label</code> protected by a per-policy spin lock, and then set the per-thread <code>TDF_ASTPENDING</code> flag and per-process <code>PS_MACPENDM</code> flag to schedule a call to the <code>userret</code> entry point.
From this entry point, the policy may create a replacement credential with less concern about the locking context.
Policy writers are cautioned that event ordering relating to scheduling an AST and the AST being performed may be complex and interlaced in multithreaded applications.</p></div></div></div><div class=sect3><h4 id=mac-label-ops>6.7.2. Label Operations<a class=anchor href=#mac-label-ops></a></h4><div class=sect4><h5 id=mac-mpo-init-bpfdesc>6.7.2.1. <code>mpo_init_bpfdesc_label</code><a class=anchor href=#mac-mpo-init-bpfdesc></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_bpfdesc_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to apply</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label on a newly instantiated bpfdesc (BPF descriptor).
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-init-cred-label>6.7.2.2. <code>mpo_init_cred_label</code><a class=anchor href=#mac-mpo-init-cred-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_cred_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to initialize</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label for a newly instantiated user credential.
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-init-devfsdirent>6.7.2.3. <code>mpo_init_devfsdirent_label</code><a class=anchor href=#mac-mpo-init-devfsdirent></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_devfsdirent_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to apply</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label on a newly instantiated devfs entry.
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-init-ifnet>6.7.2.4. <code>mpo_init_ifnet_label</code><a class=anchor href=#mac-mpo-init-ifnet></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_ifnet_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to apply</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label on a newly instantiated network interface.
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-init-ipq>6.7.2.5. <code>mpo_init_ipq_label</code><a class=anchor href=#mac-mpo-init-ipq></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_ipq_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flag</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to apply</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>flag</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sleeping/non-sleeping <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>; see below</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label on a newly instantiated IP fragment reassembly queue.
The <code>flag</code> field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> during this initialization call.
IP fragment reassembly queue allocation frequently occurs in performance sensitive environments, and the implementation should be careful to avoid sleeping or long-lived operations.
This entry point is permitted to fail resulting in the failure to allocate the IP fragment reassembly queue.</p></div></div><div class=sect4><h5 id=mac-mpo-init-mbuf>6.7.2.6. <code>mpo_init_mbuf_label</code><a class=anchor href=#mac-mpo-init-mbuf></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_mbuf_label</span><span class=p>(</span><span class=kt>int</span> <span class=n>flag</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>flag</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sleeping/non-sleeping <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>; see below</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to initialize</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label on a newly instantiated mbuf packet header (<code>mbuf</code>).
The <code>flag</code> field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> during this initialization call.
Mbuf allocation frequently occurs in performance sensitive environments, and the implementation should be careful to avoid sleeping or long-lived operations.
This entry point is permitted to fail resulting in the failure to allocate the mbuf header.</p></div></div><div class=sect4><h5 id=mac-mpo-init-mount>6.7.2.7. <code>mpo_init_mount_label</code><a class=anchor href=#mac-mpo-init-mount></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_mount_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mntlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mntlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be initialized for the mount itself</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fslabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be initialized for the file system</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the labels on a newly instantiated mount point.
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-init-mount-fs-label>6.7.2.8. <code>mpo_init_mount_fs_label</code><a class=anchor href=#mac-mpo-init-mount-fs-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_mount_fs_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be initialized</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label on a newly mounted file system.
Sleeping is permitted</p></div></div><div class=sect4><h5 id=mac-mpo-init-pipe-label>6.7.2.9. <code>mpo_init_pipe_label</code><a class=anchor href=#mac-mpo-init-pipe-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_pipe_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize a label for a newly instantiated pipe.
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-init-socket>6.7.2.10. <code>mpo_init_socket_label</code><a class=anchor href=#mac-mpo-init-socket></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_socket_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flag</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to initialize</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>flag</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> flags</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize a label for a newly instantiated socket.
The <code>flag</code> field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> during this initialization call.</p></div></div><div class=sect4><h5 id=mac-mpo-init-socket-peer-label>6.7.2.11. <code>mpo_init_socket_peer_label</code><a class=anchor href=#mac-mpo-init-socket-peer-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_socket_peer_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flag</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to initialize</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>flag</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> flags</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the peer label for a newly instantiated socket.
The <code>flag</code> field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> during this initialization call.</p></div></div><div class=sect4><h5 id=mac-mpo-init-proc-label>6.7.2.12. <code>mpo_init_proc_label</code><a class=anchor href=#mac-mpo-init-proc-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_proc_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to initialize</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label for a newly instantiated process.
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-init-vnode>6.7.2.13. <code>mpo_init_vnode_label</code><a class=anchor href=#mac-mpo-init-vnode></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_init_vnode_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New label to initialize</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Initialize the label on a newly instantiated vnode.
Sleeping is permitted.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-bpfdesc>6.7.2.14. <code>mpo_destroy_bpfdesc_label</code><a class=anchor href=#mac-mpo-destroy-bpfdesc></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_bpfdesc_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>bpfdesc label</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a BPF descriptor.
In this entry point a policy should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-cred>6.7.2.15. <code>mpo_destroy_cred_label</code><a class=anchor href=#mac-mpo-destroy-cred></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_cred_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a credential.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-devfsdirent>6.7.2.16. <code>mpo_destroy_devfsdirent_label</code><a class=anchor href=#mac-mpo-destroy-devfsdirent></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_devfsdirent_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a devfs entry.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-ifnet-label>6.7.2.17. <code>mpo_destroy_ifnet_label</code><a class=anchor href=#mac-mpo-destroy-ifnet-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_ifnet_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a removed interface.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-ipq-label>6.7.2.18. <code>mpo_destroy_ipq_label</code><a class=anchor href=#mac-mpo-destroy-ipq-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_ipq_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on an IP fragment queue.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-mbuf-label>6.7.2.19. <code>mpo_destroy_mbuf_label</code><a class=anchor href=#mac-mpo-destroy-mbuf-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_mbuf_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on an mbuf header.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-mount-label>6.7.2.20. <code>mpo_destroy_mount_label</code><a class=anchor href=#mac-mpo-destroy-mount-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_mount_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mount point label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the labels on a mount point.
In this entry point, a policy module should free the internal storage associated with <code>mntlabel</code> so that they may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-mount>6.7.2.21. <code>mpo_destroy_mount_label</code><a class=anchor href=#mac-mpo-destroy-mount></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_mount_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mntlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mntlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mount point label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fslabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File system label being destroyed></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the labels on a mount point.
In this entry point, a policy module should free the internal storage associated with <code>mntlabel</code> and <code>fslabel</code> so that they may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-socket>6.7.2.22. <code>mpo_destroy_socket_label</code><a class=anchor href=#mac-mpo-destroy-socket></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_socket_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a socket.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-socket-peer-label>6.7.2.23. <code>mpo_destroy_socket_peer_label</code><a class=anchor href=#mac-mpo-destroy-socket-peer-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_socket_peer_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>peerlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>peerlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket peer label being destroyed</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the peer label on a socket.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-pipe-label>6.7.2.24. <code>mpo_destroy_pipe_label</code><a class=anchor href=#mac-mpo-destroy-pipe-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_pipe_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe label</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a pipe.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-proc-label>6.7.2.25. <code>mpo_destroy_proc_label</code><a class=anchor href=#mac-mpo-destroy-proc-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_proc_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Process label</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a process.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-destroy-vnode-label>6.7.2.26. <code>mpo_destroy_vnode_label</code><a class=anchor href=#mac-mpo-destroy-vnode-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_destroy_vnode_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Process label</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Destroy the label on a vnode.
In this entry point, a policy module should free any internal storage associated with <code>label</code> so that it may be destroyed.</p></div></div><div class=sect4><h5 id=mac-mpo-copy-mbuf-label>6.7.2.27. <code>mpo_copy_mbuf_label</code><a class=anchor href=#mac-mpo-copy-mbuf-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_copy_mbuf_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dest</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>src</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dest</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Destination label</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Copy the label information in <code>src</code> into <code>dest</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-copy-pipe-label>6.7.2.28. <code>mpo_copy_pipe_label</code><a class=anchor href=#mac-mpo-copy-pipe-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_copy_pipe_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dest</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>src</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dest</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Destination label</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Copy the label information in <code>src</code> into <code>dest</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-copy-vnode-label>6.7.2.29. <code>mpo_copy_vnode_label</code><a class=anchor href=#mac-mpo-copy-vnode-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_copy_vnode_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dest</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>src</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dest</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Destination label</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Copy the label information in <code>src</code> into <code>dest</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-externalize-cred-label>6.7.2.30. <code>mpo_externalize_cred_label</code><a class=anchor href=#mac-mpo-externalize-cred-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_externalize_cred_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>sbuf</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>String buffer to be filled with a text representation of label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when <code>element_data</code> can be filled in.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an externalized label based on the label structure passed.
An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user.
Currently, all policies' <code>externalize</code> entry points will be called, so the implementation should check the contents of <code>element_name</code> before attempting to fill in <code>sb</code>.
If <code>element_name</code> does not match the name of your policy, simply return 0.
Only return nonzero if an error occurs while externalizing the label data.
Once the policy fills in <code>element_data</code>, <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-externalize-ifnet-label>6.7.2.31. <code>mpo_externalize_ifnet_label</code><a class=anchor href=#mac-mpo-externalize-ifnet-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_externalize_ifnet_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>sbuf</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>String buffer to be filled with a text representation of label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when <code>element_data</code> can be filled in.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an externalized label based on the label structure passed.
An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user.
Currently, all policies' <code>externalize</code> entry points will be called, so the implementation should check the contents of <code>element_name</code> before attempting to fill in <code>sb</code>.
If <code>element_name</code> does not match the name of your policy, simply return 0.
Only return nonzero if an error occurs while externalizing the label data.
Once the policy fills in <code>element_data</code>, <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-externalize-pipe-label>6.7.2.32. <code>mpo_externalize_pipe_label</code><a class=anchor href=#mac-mpo-externalize-pipe-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_externalize_pipe_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>sbuf</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>String buffer to be filled with a text representation of label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when <code>element_data</code> can be filled in.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an externalized label based on the label structure passed.
An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user.
Currently, all policies' <code>externalize</code> entry points will be called, so the implementation should check the contents of <code>element_name</code> before attempting to fill in <code>sb</code>.
If <code>element_name</code> does not match the name of your policy, simply return 0.
Only return nonzero if an error occurs while externalizing the label data.
Once the policy fills in <code>element_data</code>, <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-externalize-socket-label>6.7.2.33. <code>mpo_externalize_socket_label</code><a class=anchor href=#mac-mpo-externalize-socket-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_externalize_socket_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>sbuf</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>String buffer to be filled with a text representation of label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when <code>element_data</code> can be filled in.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an externalized label based on the label structure passed.
An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user.
Currently, all policies' <code>externalize</code> entry points will be called, so the implementation should check the contents of <code>element_name</code> before attempting to fill in <code>sb</code>.
If <code>element_name</code> does not match the name of your policy, simply return 0.
Only return nonzero if an error occurs while externalizing the label data.
Once the policy fills in <code>element_data</code>, <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-externalize-socket-peer-label>6.7.2.34. <code>mpo_externalize_socket_peer_label</code><a class=anchor href=#mac-mpo-externalize-socket-peer-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_externalize_socket_peer_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>sbuf</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>String buffer to be filled with a text representation of label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when <code>element_data</code> can be filled in.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an externalized label based on the label structure passed.
An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user.
Currently, all policies' <code>externalize</code> entry points will be called, so the implementation should check the contents of <code>element_name</code> before attempting to fill in <code>sb</code>.
If <code>element_name</code> does not match the name of your policy, simply return 0.
Only return nonzero if an error occurs while externalizing the label data.
Once the policy fills in <code>element_data</code>, <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-externalize-vnode-label>6.7.2.35. <code>mpo_externalize_vnode_label</code><a class=anchor href=#mac-mpo-externalize-vnode-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_externalize_vnode_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>sbuf</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be externalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>String buffer to be filled with a text representation of label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when <code>element_data</code> can be filled in.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an externalized label based on the label structure passed.
An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user.
Currently, all policies' <code>externalize</code> entry points will be called, so the implementation should check the contents of <code>element_name</code> before attempting to fill in <code>sb</code>.
If <code>element_name</code> does not match the name of your policy, simply return 0.
Only return nonzero if an error occurs while externalizing the label data.
Once the policy fills in <code>element_data</code>, <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-internalize-cred-label>6.7.2.36. <code>mpo_internalize_cred_label</code><a class=anchor href=#mac-mpo-internalize-cred-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_internalize_cred_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>element_data</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_data</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Text data to be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when data can be successfully internalized.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an internal label structure based on externalized label data in text format.
Currently, all policies' <code>internalize</code> entry points are called when internalization is requested, so the implementation should compare the contents of <code>element_name</code> to its own name in order to be sure it should be internalizing the data in <code>element_data</code>.
Just as in the <code>externalize</code> entry points, the entry point should return 0 if <code>element_name</code> does not match its own name, or when data can successfully be internalized, in which case <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-internalize-ifnet-label>6.7.2.37. <code>mpo_internalize_ifnet_label</code><a class=anchor href=#mac-mpo-internalize-ifnet-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_internalize_ifnet_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>element_data</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_data</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Text data to be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when data can be successfully internalized.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an internal label structure based on externalized label data in text format.
Currently, all policies' <code>internalize</code> entry points are called when internalization is requested, so the implementation should compare the contents of <code>element_name</code> to its own name in order to be sure it should be internalizing the data in <code>element_data</code>.
Just as in the <code>externalize</code> entry points, the entry point should return 0 if <code>element_name</code> does not match its own name, or when data can successfully be internalized, in which case <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-internalize-pipe-label>6.7.2.38. <code>mpo_internalize_pipe_label</code><a class=anchor href=#mac-mpo-internalize-pipe-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_internalize_pipe_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>element_data</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_data</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Text data to be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when data can be successfully internalized.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an internal label structure based on externalized label data in text format.
Currently, all policies' <code>internalize</code> entry points are called when internalization is requested, so the implementation should compare the contents of <code>element_name</code> to its own name in order to be sure it should be internalizing the data in <code>element_data</code>.
Just as in the <code>externalize</code> entry points, the entry point should return 0 if <code>element_name</code> does not match its own name, or when data can successfully be internalized, in which case <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-internalize-socket-label>6.7.2.39. <code>mpo_internalize_socket_label</code><a class=anchor href=#mac-mpo-internalize-socket-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_internalize_socket_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>element_data</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_data</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Text data to be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when data can be successfully internalized.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an internal label structure based on externalized label data in text format.
Currently, all policies' <code>internalize</code> entry points are called when internalization is requested, so the implementation should compare the contents of <code>element_name</code> to its own name in order to be sure it should be internalizing the data in <code>element_data</code>.
Just as in the <code>externalize</code> entry points, the entry point should return 0 if <code>element_name</code> does not match its own name, or when data can successfully be internalized, in which case <code>*claimed</code> should be incremented.</p></div></div><div class=sect4><h5 id=mac-mpo-internalize-vnode-label>6.7.2.40. <code>mpo_internalize_vnode_label</code><a class=anchor href=#mac-mpo-internalize-vnode-label></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_internalize_vnode_label</span><span class=p>(</span><span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>element_name</span><span class=p>,</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>element_data</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>claimed</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of the policy whose label should be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>element_data</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Text data to be internalized</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>claimed</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should be incremented when data can be successfully internalized.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Produce an internal label structure based on externalized label data in text format.
Currently, all policies' <code>internalize</code> entry points are called when internalization is requested, so the implementation should compare the contents of <code>element_name</code> to its own name in order to be sure it should be internalizing the data in <code>element_data</code>.
Just as in the <code>externalize</code> entry points, the entry point should return 0 if <code>element_name</code> does not match its own name, or when data can successfully be internalized, in which case <code>*claimed</code> should be incremented.</p></div></div></div><div class=sect3><h4 id=mac-label-events>6.7.3. Label Events<a class=anchor href=#mac-label-events></a></h4><div class=paragraph><p>This class of entry points is used by the MAC framework to permit policies to maintain label information on kernel objects.
For each labeled kernel object of interest to a MAC policy, entry points may be registered for relevant life cycle events.
All objects implement initialization, creation, and destruction hooks.
Some objects will also implement relabeling, allowing user processes to change the labels on objects.
Some objects will also implement object-specific events, such as label events associated with IP reassembly.
A typical labeled object will have the following life cycle of entry points:</p></div><div class="literalblock programlisting"><div class=content><pre>Label initialization          o
(object-specific wait)         \
Label creation                  o
                                 \
Relabel events,                   o--&lt;--.
Various object-specific,          |     |
Access control events             ~--&gt;--o
                                         \
Label destruction                         o</pre></div></div><div class=paragraph><p>Label initialization permits policies to allocate memory and set initial values for labels without context for the use of the object.
The label slot allocated to a policy will be zeroed by default, so some policies may not need to perform initialization.</p></div><div class=paragraph><p>Label creation occurs when the kernel structure is associated with an actual kernel object.
For example, Mbufs may be allocated and remain unused in a pool until they are required.
mbuf allocation causes label initialization on the mbuf to take place, but mbuf creation occurs when the mbuf is associated with a datagram.
Typically, context will be provided for a creation event, including the circumstances of the creation, and labels of other relevant objects in the creation process.
For example, when an mbuf is created from a socket, the socket and its label will be presented to registered policies in addition to the new mbuf and its label.
Memory allocation in creation events is discouraged, as it may occur in performance sensitive ports of the kernel; in addition, creation calls are not permitted to fail so a failure to allocate memory cannot be reported.</p></div><div class=paragraph><p>Object specific events do not generally fall into the other broad classes of label events, but will generally provide an opportunity to modify or update the label on an object based on additional context.
For example, the label on an IP fragment reassembly queue may be updated during the MAC_UPDATE_IPQ entry point as a result of the acceptance of an additional mbuf to that queue.</p></div><div class=paragraph><p>Access control events are discussed in detail in the following section.</p></div><div class=paragraph><p>Label destruction permits policies to release storage or state associated with a label during its association with an object so that the kernel data structures supporting the object may be reused or released.</p></div><div class=paragraph><p>In addition to labels associated with specific kernel objects, an additional class of labels exists: temporary labels.
These labels are used to store update information submitted by user processes.
These labels are initialized and destroyed as with other label types, but the creation event is MAC_INTERNALIZE, which accepts a user label to be converted to an in-kernel representation.</p></div><div class=sect4><h5 id=mac-fs-label-event-ops>6.7.3.1. File System Object Labeling Event Operations<a class=anchor href=#mac-fs-label-event-ops></a></h5><div class=sect5><h6 id=mac-mpo-associate-vnode-devfs>6.7.3.1.1. <code>mpo_associate_vnode_devfs</code><a class=anchor href=#mac-mpo-associate-vnode-devfs></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_associate_vnode_devfs</span><span class=p>(</span><span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>devfs_dirent</span> <span class=o>*</span><span class=n>de</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>delabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Devfs mount point</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fslabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Devfs file system label (<code>mp→mnt_fslabel</code>)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>de</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Devfs directory entry</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>delabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>de</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>vnode associated with <code>de</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Fill in the label (<code>vlabel</code>) for a newly created devfs vnode based on the devfs directory entry passed in <code>de</code> and its label.</p></div></div><div class=sect5><h6 id=mac-mpo-associate-vnode-extattr>6.7.3.1.2. <code>mpo_associate_vnode_extattr</code><a class=anchor href=#mac-mpo-associate-vnode-extattr></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_associate_vnode_extattr</span><span class=p>(</span><span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File system mount point</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fslabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File system label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vnode to label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Attempt to retrieve the label for <code>vp</code> from the file system extended attributes.
Upon success, the value <code>0</code> is returned.
Should extended attribute retrieval not be supported, an accepted fallback is to copy <code>fslabel</code> into <code>vlabel</code>.
In the event of an error, an appropriate value for <code>errno</code> should be returned.</p></div></div><div class=sect5><h6 id=mac-mpo-associate-vnode-singlelabel>6.7.3.1.3. <code>mpo_associate_vnode_singlelabel</code><a class=anchor href=#mac-mpo-associate-vnode-singlelabel></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_associate_vnode_singlelabel</span><span class=p>(</span><span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File system mount point</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fslabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File system label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vnode to label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>On non-multilabel file systems, this entry point is called to set the policy label for <code>vp</code> based on the file system label, <code>fslabel</code>.</p></div></div><div class=sect5><h6 id=mac-mpo-create-devfs-device>6.7.3.1.4. <code>mpo_create_devfs_device</code><a class=anchor href=#mac-mpo-create-devfs-device></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_devfs_device</span><span class=p>(</span><span class=n>dev_t</span> <span class=n>dev</span><span class=p>,</span> <span class=k>struct</span> <span class=n>devfs_dirent</span> <span class=o>*</span><span class=n>devfs_dirent</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dev</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Device corresponding with <code>devfs_dirent</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>devfs_dirent</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Devfs directory entry to be labeled.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label for <code>devfs_dirent</code> to be filled in.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Fill out the label on a devfs_dirent being created for the passed device.
This call will be made when the device file system is mounted, regenerated, or a new device is made available.</p></div></div><div class=sect5><h6 id=mac-mpo-create-devfs-directory>6.7.3.1.5. <code>mpo_create_devfs_directory</code><a class=anchor href=#mac-mpo-create-devfs-directory></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_devfs_directory</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>dirname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dirnamelen</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>devfs_dirent</span> <span class=o>*</span><span class=n>devfs_dirent</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dirname</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name of directory being created</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>namelen</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Length of string <code>dirname</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>devfs_dirent</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Devfs directory entry for directory being created.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Fill out the label on a devfs_dirent being created for the passed directory.
This call will be made when the device file system is mounted, regenerated, or a new device requiring a specific directory hierarchy is made available.</p></div></div><div class=sect5><h6 id=mac-mpo-create-devfs-symlink>6.7.3.1.6. <code>mpo_create_devfs_symlink</code><a class=anchor href=#mac-mpo-create-devfs-symlink></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_devfs_symlink</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>devfs_dirent</span> <span class=o>*</span><span class=n>dd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ddlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>devfs_dirent</span> <span class=o>*</span><span class=n>de</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>delabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Devfs mount point</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dd</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Link destination</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ddlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label associated with <code>dd</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>de</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Symlink entry</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>delabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label associated with <code>de</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Fill in the label (<code>delabel</code>) for a newly created <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> symbolic link entry.</p></div></div><div class=sect5><h6 id=mac-mpo-create-vnode-extattr>6.7.3.1.7. <code>mpo_create_vnode_extattr</code><a class=anchor href=#mac-mpo-create-vnode-extattr></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_create_vnode_extattr</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>componentname</span> <span class=o>*</span><span class=n>cnp</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mount</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File system mount point</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File system label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Parent directory vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label associated with <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Newly created vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cnp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Component name for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Write out the label for <code>vp</code> to the appropriate extended attribute.
If the write succeeds, fill in <code>vlabel</code> with the label, and return 0.
Otherwise, return an appropriate error.</p></div></div><div class=sect5><h6 id=mac-mpo-create-mount>6.7.3.1.8. <code>mpo_create_mount</code><a class=anchor href=#mac-mpo-create-mount></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mount</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mnt</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; file system being mounted</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mntlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>mp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fslabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for the file system <code>mp</code> mounts.</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Fill out the labels on the mount point being created by the passed subject credential.
This call will be made when a new file system is mounted.</p></div></div><div class=sect5><h6 id=mac-mpo-create-root-mount>6.7.3.1.9. <code>mpo_create_root_mount</code><a class=anchor href=#mac-mpo-create-root-mount></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_root_mount</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mntlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fslabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top" colspan=3><p class=tableblock>See <a href=./#mac-mpo-create-mount><code>mpo_create_mount</code></a>.</p></td></tr></tbody></table><div class=paragraph><p>Fill out the labels on the mount point being created by the passed subject credential.
This call will be made when the root file system is mounted, after <code>mpo_create_mount;</code>.</p></div></div><div class=sect5><h6 id=mac-mpo-relabel-vnode>6.7.3.1.10. <code>mpo_relabel_vnode</code><a class=anchor href=#mac-mpo-relabel-vnode></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_relabel_vnode</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vnodelabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>vnode to relabel</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vnodelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Existing policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New, possibly partial label to replace <code>vnodelabel</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Update the label on the passed vnode given the passed update vnode label and the passed subject credential.</p></div></div><div class=sect5><h6 id=mac-mpo-setlabel-vnode-extattr>6.7.3.1.11. <code>mpo_setlabel_vnode_extattr</code><a class=anchor href=#mac-mpo-setlabel-vnode-extattr></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_setlabel_vnode_extattr</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>intlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vnode for which the label is being written</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>intlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to write out</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Write out the policy from <code>intlabel</code> to an extended attribute.
This is called from <code>vop_stdcreatevnode_ea</code>.</p></div></div><div class=sect5><h6 id=mac-mpo-update-devfsdirent>6.7.3.1.12. <code>mpo_update_devfsdirent</code><a class=anchor href=#mac-mpo-update-devfsdirent></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_update_devfsdirent</span><span class=p>(</span><span class=k>struct</span> <span class=n>devfs_dirent</span> <span class=o>*</span><span class=n>devfs_dirent</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>direntlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vnodelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>devfs_dirent</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; devfs directory entry</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>direntlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>devfs_dirent</code> to be updated.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Parent vnode</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Locked</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vnodelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Update the <code>devfs_dirent</code> label from the passed devfs vnode label.
This call will be made when a devfs vnode has been successfully relabeled to commit the label change such that it lasts even if the vnode is recycled.
It will also be made when a symlink is created in devfs, following a call to <code>mac_vnode_create_from_vnode</code> to initialize the vnode label.</p></div></div></div><div class=sect4><h5 id=mac-ipc-label-ops>6.7.3.2. IPC Object Labeling Event Operations<a class=anchor href=#mac-ipc-label-ops></a></h5><div class=sect5><h6 id=mac-mpo-create-mbuf-from-socket>6.7.3.2.1. <code>mpo_create_mbuf_from_socket</code><a class=anchor href=#mac-mpo-create-mbuf-from-socket></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mbuf_from_socket</span><span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>so</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>m</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket locking WIP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>m</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; mbuf</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to fill in for <code>m</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on a newly created mbuf header from the passed socket label.
This call is made when a new datagram or message is generated by the socket and stored in the passed mbuf.</p></div></div><div class=sect5><h6 id=mac-mpo-create-pipe>6.7.3.2.2. <code>mpo_create_pipe</code><a class=anchor href=#mac-mpo-create-pipe></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_pipe</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>pipelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on a newly created pipe from the passed subject credential.
This call is made when a new pipe is created.</p></div></div><div class=sect5><h6 id=mac-mpo-create-socket>6.7.3.2.3. <code>mpo_create_socket</code><a class=anchor href=#mac-mpo-create-socket></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_socket</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>so</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>so</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; socket to label</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label to fill in for <code>so</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on a newly created socket from the passed subject credential.
This call is made when a socket is created.</p></div></div><div class=sect5><h6 id=mac-mpo-create-socket-from-socket>6.7.3.2.4. <code>mpo_create_socket_from_socket</code><a class=anchor href=#mac-mpo-create-socket-from-socket></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_socket_from_socket</span><span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>oldsocket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldsocketlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>newsocket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newsocketlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldsocket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Listening socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldsocketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>oldsocket</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newsocket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newsocketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>newsocketlabel</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Label a socket, <code>newsocket</code>, newly <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a>ed, based on the <a href="https://man.freebsd.org/cgi/man.cgi?query=listen&amp;sektion=2&amp;format=html">listen(2)</a> socket, <code>oldsocket</code>.</p></div></div><div class=sect5><h6 id=mac-mpo-relabel-pipe>6.7.3.2.5. <code>mpo_relabel_pipe</code><a class=anchor href=#mac-mpo-relabel-pipe></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_relabel_pipe</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Current policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label update to apply to <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Apply a new label, <code>newlabel</code>, to <code>pipe</code>.</p></div></div><div class=sect5><h6 id=mac-mpo-relabel-socket>6.7.3.2.6. <code>mpo_relabel_socket</code><a class=anchor href=#mac-mpo-relabel-socket></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_relabel_socket</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>so</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>so</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Current label for <code>so</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label update for <code>so</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Update the label on a socket from the passed socket label update.</p></div></div><div class=sect5><h6 id=mpo-set-socket-peer-from-mbuf>6.7.3.2.7. <code>mpo_set_socket_peer_from_mbuf</code><a class=anchor href=#mpo-set-socket-peer-from-mbuf></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_set_socket_peer_from_mbuf</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>mbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mbuflabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>First datagram received over socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label for <code>mbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Current label for the socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled out for the socket</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the peer label on a stream socket from the passed mbuf label.
This call will be made when the first datagram is received by the stream socket, with the exception of Unix domain sockets.</p></div></div><div class=sect5><h6 id=mac-mpo-set-socket-peer-from-socket>6.7.3.2.8. <code>mpo_set_socket_peer_from_socket</code><a class=anchor href=#mac-mpo-set-socket-peer-from-socket></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_set_socket_peer_from_socket</span><span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>oldsocket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldsocketlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>newsocket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newsocketpeerlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldsocket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldsocketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>oldsocket</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newsocket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peer socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newsocketpeerlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to fill in for <code>newsocket</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the peer label on a stream UNIX domain socket from the passed remote socket endpoint.
This call will be made when the socket pair is connected, and will be made for both endpoints.</p></div></div></div><div class=sect4><h5 id=mac-net-labeling-event-ops>6.7.3.3. Network Object Labeling Event Operations<a class=anchor href=#mac-net-labeling-event-ops></a></h5><div class=sect5><h6 id=mac-mpo-create-bpfdesc>6.7.3.3.1. <code>mpo_create_bpfdesc</code><a class=anchor href=#mac-mpo-create-bpfdesc></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_bpfdesc</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>bpf_d</span> <span class=o>*</span><span class=n>bpf_d</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>bpflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bpf_d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; bpf descriptor</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bpf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>bpf_d</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on a newly created BPF descriptor from the passed subject credential.
This call will be made when a BPF device node is opened by a process with the passed subject credential.</p></div></div><div class=sect5><h6 id=mac-mpo-create-ifnet>6.7.3.3.2. <code>mpo_create_ifnet</code><a class=anchor href=#mac-mpo-create-ifnet></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_ifnet</span><span class=p>(</span><span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to fill in for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on a newly created interface.
This call may be made when a new physical interface becomes available to the system, or when a pseudo-interface is instantiated during the boot or as a result of a user action.</p></div></div><div class=sect5><h6 id=mac-mpo-create-ipq>6.7.3.3.3. <code>mpo_create_ipq</code><a class=anchor href=#mac-mpo-create-ipq></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_ipq</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>fragment</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fragmentlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>ipq</span> <span class=o>*</span><span class=n>ipq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ipqlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fragment</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>First received IP fragment</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fragmentlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>fragment</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipq</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IP reassembly queue to be labeled</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipqlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>ipq</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on a newly created IP fragment reassembly queue from the mbuf header of the first received fragment.</p></div></div><div class=sect5><h6 id=mac-mpo-create-datagram-from-ipq>6.7.3.3.4. <code>mpo_create_datagram_from_ipq</code><a class=anchor href=#mac-mpo-create-datagram-from-ipq></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_create_datagram_from_ipq</span><span class=p>(</span><span class=k>struct</span> <span class=n>ipq</span> <span class=o>*</span><span class=n>ipq</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ipqlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>datagram</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>datagramlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipq</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IP reassembly queue</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipqlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ipq</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>datagram</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Datagram to be labeled</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>datagramlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>datagramlabel</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on a newly reassembled IP datagram from the IP fragment reassembly queue from which it was generated.</p></div></div><div class=sect5><h6 id=mac-mpo-create-fragment>6.7.3.3.5. <code>mpo_create_fragment</code><a class=anchor href=#mac-mpo-create-fragment></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_fragment</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>datagram</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>datagramlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>fragment</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fragmentlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>datagram</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Datagram</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>datagramlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>datagram</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fragment</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fragment to be labeled</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fragmentlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>datagram</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on the mbuf header of a newly created IP fragment from the label on the mbuf header of the datagram it was generate from.</p></div></div><div class=sect5><h6 id=mac-mpo-create-mbuf-from-mbuf>6.7.3.3.6. <code>mpo_create_mbuf_from_mbuf</code><a class=anchor href=#mac-mpo-create-mbuf-from-mbuf></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mbuf_from_mbuf</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>oldmbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldmbuflabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>newmbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newmbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldmbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Existing (source) mbuf</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldmbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>oldmbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newmbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New mbuf to be labeled</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newmbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>newmbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on the mbuf header of a newly created datagram from the mbuf header of an existing datagram.
This call may be made in a number of situations, including when an mbuf is re-allocated for alignment purposes.</p></div></div><div class=sect5><h6 id=mac-mpo-create-mbuf-linklayer>6.7.3.3.7. <code>mpo_create_mbuf_linklayer</code><a class=anchor href=#mac-mpo-create-mbuf-linklayer></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mbuf_linklayer</span><span class=p>(</span><span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>mbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>mbuf header for new datagram</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>mbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on the mbuf header of a newly created datagram generated for the purposes of a link layer response for the passed interface.
This call may be made in a number of situations, including for ARP or ND6 responses in the IPv4 and IPv6 stacks.</p></div></div><div class=sect5><h6 id=mac-mpo-create-mbuf-from-bpfdesc>6.7.3.3.8. <code>mpo_create_mbuf_from_bpfdesc</code><a class=anchor href=#mac-mpo-create-mbuf-from-bpfdesc></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mbuf_from_bpfdesc</span><span class=p>(</span><span class=k>struct</span> <span class=n>bpf_d</span> <span class=o>*</span><span class=n>bpf_d</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>bpflabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>mbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bpf_d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BPF descriptor</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bpflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>bpflabel</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New mbuf to be labeled</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to fill in for <code>mbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on the mbuf header of a newly created datagram generated using the passed BPF descriptor.
This call is made when a write is performed to the BPF device associated with the passed BPF descriptor.</p></div></div><div class=sect5><h6 id=mac-mpo-create-mbuf-from-ifnet>6.7.3.3.9. <code>mpo_create_mbuf_from_ifnet</code><a class=anchor href=#mac-mpo-create-mbuf-from-ifnet></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mbuf_from_ifnet</span><span class=p>(</span><span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>mbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>mbuf header for new datagram</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>mbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on the mbuf header of a newly created datagram generated from the passed network interface.</p></div></div><div class=sect5><h6 id=mac-mpo-create-mbuf-multicast-encap>6.7.3.3.10. <code>mpo_create_mbuf_multicast_encap</code><a class=anchor href=#mac-mpo-create-mbuf-multicast-encap></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mbuf_multicast_encap</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>oldmbuf</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldmbuflabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>newmbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newmbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldmbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>mbuf header for existing datagram</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldmbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>oldmbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newmbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>mbuf header to be labeled for new datagram</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newmbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be filled in for <code>newmbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on the mbuf header of a newly created datagram generated from the existing passed datagram when it is processed by the passed multicast encapsulation interface.
This call is made when an mbuf is to be delivered using the virtual interface.</p></div></div><div class=sect5><h6 id=mac-mpo-create-mbuf-netlayer>6.7.3.3.11. <code>mpo_create_mbuf_netlayer</code><a class=anchor href=#mac-mpo-create-mbuf-netlayer></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_mbuf_netlayer</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>oldmbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>oldmbuflabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>newmbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newmbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldmbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Received datagram</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldmbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>oldmbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newmbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Newly created datagram</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newmbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>newmbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label on the mbuf header of a newly created datagram generated by the IP stack in response to an existing received datagram (<code>oldmbuf</code>).
This call may be made in a number of situations, including when responding to ICMP request datagrams.</p></div></div><div class=sect5><h6 id=mac-mpo-fragment-match>6.7.3.3.12. <code>mpo_fragment_match</code><a class=anchor href=#mac-mpo-fragment-match></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_fragment_match</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>fragment</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fragmentlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>ipq</span> <span class=o>*</span><span class=n>ipq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ipqlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fragment</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IP datagram fragment</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fragmentlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>fragment</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipq</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IP fragment reassembly queue</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipqlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ipq</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether an mbuf header containing an IP datagram (<code>fragment</code>) fragment matches the label of the passed IP fragment reassembly queue (<code>ipq</code>).
Return (1) for a successful match, or (0) for no match.
This call is made when the IP stack attempts to find an existing fragment reassembly queue for a newly received fragment; if this fails, a new fragment reassembly queue may be instantiated for the fragment.
Policies may use this entry point to prevent the reassembly of otherwise matching IP fragments if policy does not permit them to be reassembled based on the label or other information.</p></div></div><div class=sect5><h6 id=mac-mpo-ifnet-relabel>6.7.3.3.13. <code>mpo_relabel_ifnet</code><a class=anchor href=#mac-mpo-ifnet-relabel></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_relabel_ifnet</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; Network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label update to apply to <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Update the label of network interface, <code>ifnet</code>, based on the passed update label, <code>newlabel</code>, and the passed subject credential, <code>cred</code>.</p></div></div><div class=sect5><h6 id=mac-mpo-update-ipq>6.7.3.3.14. <code>mpo_update_ipq</code><a class=anchor href=#mac-mpo-update-ipq></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_update_ipq</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>fragment</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>fragmentlabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>ipq</span> <span class=o>*</span><span class=n>ipq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ipqlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IP fragment</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>mbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipq</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IP fragment reassembly queue</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ipqlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label to be updated for <code>ipq</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Update the label on an IP fragment reassembly queue (<code>ipq</code>) based on the acceptance of the passed IP fragment mbuf header (<code>mbuf</code>).</p></div></div></div><div class=sect4><h5 id=mac-proc-labeling-event-ops>6.7.3.4. Process Labeling Event Operations<a class=anchor href=#mac-proc-labeling-event-ops></a></h5><div class=sect5><h6 id=mac-mpo-create-cred>6.7.3.4.1. <code>mpo_create_cred</code><a class=anchor href=#mac-mpo-create-cred></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_cred</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>parent_cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>child_cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>parent_cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Parent subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>child_cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Child subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Set the label of a newly created subject credential from the passed subject credential.
This call will be made when <a href="https://man.freebsd.org/cgi/man.cgi?query=crcopy&amp;sektion=9&amp;format=html">crcopy(9)</a> is invoked on a newly created <code>struct ucred</code>.
This call should not be confused with a process forking or creation event.</p></div></div><div class=sect5><h6 id=mac-mpo-execve-transition>6.7.3.4.2. <code>mpo_execve_transition</code><a class=anchor href=#mac-mpo-execve-transition></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_execve_transition</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>old</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>new</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vnodelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>old</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Existing subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>new</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>New subject credential to be labeled</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File to execute</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Locked</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vnodelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Update the label of a newly created subject credential (<code>new</code>) from the passed existing subject credential (<code>old</code>) based on a label transition caused by executing the passed vnode (<code>vp</code>).
This call occurs when a process executes the passed vnode and one of the policies returns a success from the <code>mpo_execve_will_transition</code> entry point.
Policies may choose to implement this call simply by invoking <code>mpo_create_cred</code> and passing the two subject credentials so as not to implement a transitioning event.
Policies should not leave this entry point unimplemented if they implement <code>mpo_create_cred</code>, even if they do not implement <code>mpo_execve_will_transition</code>.</p></div></div><div class=sect5><h6 id=mac-mpo-execve-will-transition>6.7.3.4.3. <code>mpo_execve_will_transition</code><a class=anchor href=#mac-mpo-execve-will-transition></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_execve_will_transition</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>old</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vnodelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>old</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential prior to <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File to execute</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vnodelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the policy will want to perform a transition event as a result of the execution of the passed vnode by the passed subject credential.
Return 1 if a transition is required, 0 if not.
Even if a policy returns 0, it should behave correctly in the presence of an unexpected invocation of <code>mpo_execve_transition</code>, as that call may happen as a result of another policy requesting a transition.</p></div></div><div class=sect5><h6 id=mac-mpo-create-proc0>6.7.3.4.4. <code>mpo_create_proc0</code><a class=anchor href=#mac-mpo-create-proc0></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_proc0</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Create the subject credential of process 0, the parent of all kernel processes.</p></div></div><div class=sect5><h6 id=mac-mpo-create-proc1>6.7.3.4.5. <code>mpo_create_proc1</code><a class=anchor href=#mac-mpo-create-proc1></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_create_proc1</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential to be filled in</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Create the subject credential of process 1, the parent of all user processes.</p></div></div><div class=sect5><h6 id=mac-mpo-relabel-cred>6.7.3.4.6. <code>mpo_relabel_cred</code><a class=anchor href=#mac-mpo-relabel-cred></a></h6><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_relabel_cred</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label update to apply to <code>cred</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Update the label on a subject credential from the passed update label.</p></div></div></div></div><div class=sect3><h4 id=mac-access-control-checks>6.7.4. Access Control Checks<a class=anchor href=#mac-access-control-checks></a></h4><div class=paragraph><p>Access control entry points permit policy modules to influence access control decisions made by the kernel.
Generally, although not always, arguments to an access control entry point will include one or more authorizing credentials, information (possibly including a label) for any other objects involved in the operation.
An access control entry point may return 0 to permit the operation, or an <a href="https://man.freebsd.org/cgi/man.cgi?query=errno&amp;sektion=2&amp;format=html">errno(2)</a> error value.
The results of invoking the entry point across various registered policy modules will be composed as follows: if all modules permit the operation to succeed, success will be returned.
If one or modules returns a failure, a failure will be returned.
If more than one module returns a failure, the errno value to return to the user will be selected using the following precedence, implemented by the <code>error_select()</code> function in <span class=filename>kern_mac.c</span>:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Most precedence</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>EDEADLK</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>EINVAL</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ESRCH</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>EACCES</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Least precedence</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>EPERM</p></td></tr></tbody></table><div class=paragraph><p>If none of the error values returned by all modules are listed in the precedence chart then an arbitrarily selected value from the set will be returned.
In general, the rules provide precedence to errors in the following order: kernel failures, invalid arguments, object not present, access not permitted, other.</p></div><div class=sect4><h5 id=mac-mpo-bpfdesc-check-receive-from-ifnet>6.7.4.1. <code>mpo_check_bpfdesc_receive</code><a class=anchor href=#mac-mpo-bpfdesc-check-receive-from-ifnet></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_bpfdesc_receive</span><span class=p>(</span><span class=k>struct</span> <span class=n>bpf_d</span> <span class=o>*</span><span class=n>bpf_d</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>bpflabel</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bpf_d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject; BPF descriptor</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bpflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>bpf_d</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the MAC framework should permit datagrams from the passed interface to be delivered to the buffers of the passed BPF descriptor.
Return (0) for success, or an <code>errno</code> value for failure Suggested failure: EACCES for label mismatches, EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-check-kenv-dump>6.7.4.2. <code>mpo_check_kenv_dump</code><a class=anchor href=#mac-mpo-check-kenv-dump></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_kenv_dump</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to retrieve the kernel environment (see <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=2&amp;format=html">kenv(2)</a>).</p></div></div><div class=sect4><h5 id=mac-mpo-check-kenv-get>6.7.4.3. <code>mpo_check_kenv_get</code><a class=anchor href=#mac-mpo-check-kenv-get></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_kenv_get</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kernel environment variable name</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to retrieve the value of the specified kernel environment variable.</p></div></div><div class=sect4><h5 id=mac-mpo-check-kenv-set>6.7.4.4. <code>mpo_check_kenv_set</code><a class=anchor href=#mac-mpo-check-kenv-set></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_kenv_set</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kernel environment variable name</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to set the specified kernel environment variable.</p></div></div><div class=sect4><h5 id=mac-mpo-check-kenv-unset>6.7.4.5. <code>mpo_check_kenv_unset</code><a class=anchor href=#mac-mpo-check-kenv-unset></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_kenv_unset</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kernel environment variable name</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to unset the specified kernel environment variable.</p></div></div><div class=sect4><h5 id=mac-mpo-check-kld-load>6.7.4.6. <code>mpo_check_kld_load</code><a class=anchor href=#mac-mpo-check-kld-load></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_kld_load</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kernel module vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to load the specified module file.</p></div></div><div class=sect4><h5 id=mac-mpo-check-kld-stat>6.7.4.7. <code>mpo_check_kld_stat</code><a class=anchor href=#mac-mpo-check-kld-stat></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_kld_stat</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to retrieve a list of loaded kernel module files and associated statistics.</p></div></div><div class=sect4><h5 id=mac-mpo-check-kld-unload>6.7.4.8. <code>mpo_check_kld_unload</code><a class=anchor href=#mac-mpo-check-kld-unload></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_kld_unload</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to unload a kernel module.</p></div></div><div class=sect4><h5 id=mac-mpo-check-pipe-ioctl>6.7.4.9. <code>mpo_check_pipe_ioctl</code><a class=anchor href=#mac-mpo-check-pipe-ioctl></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_pipe_ioctl</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>pipelabel</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cmd</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;format=html">ioctl(2)</a> command</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>data</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;format=html">ioctl(2)</a> data</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to make the specified <a href="https://man.freebsd.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;format=html">ioctl(2)</a> call.</p></div></div><div class=sect4><h5 id=mac-mpo-check-pipe-poll>6.7.4.10. <code>mpo_check_pipe_poll</code><a class=anchor href=#mac-mpo-check-pipe-poll></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_pipe_poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>pipelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to poll <code>pipe</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-pipe-read>6.7.4.11. <code>mpo_check_pipe_read</code><a class=anchor href=#mac-mpo-check-pipe-read></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_pipe_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>pipelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed read access to <code>pipe</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-pipe-relabel>6.7.4.12. <code>mpo_check_pipe_relabel</code><a class=anchor href=#mac-mpo-check-pipe-relabel></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_pipe_relabel</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>pipelabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Current policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label update to <code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to relabel <code>pipe</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-pipe-stat>6.7.4.13. <code>mpo_check_pipe_stat</code><a class=anchor href=#mac-mpo-check-pipe-stat></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_pipe_stat</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>pipelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to retrieve statistics related to <code>pipe</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-pipe-write>6.7.4.14. <code>mpo_check_pipe_write</code><a class=anchor href=#mac-mpo-check-pipe-write></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_pipe_write</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>pipe</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>pipelabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipe</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pipe</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pipelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>pipe</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to write to <code>pipe</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-socket-bind>6.7.4.15. <code>mpo_check_socket_bind</code><a class=anchor href=#mac-mpo-cred-check-socket-bind></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_bind</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>socket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>sockaddr</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket to be bound</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sockaddr</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Address of <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table></div><div class=sect4><h5 id=mac-mpo-cred-check-socket-connect>6.7.4.16. <code>mpo_check_socket_connect</code><a class=anchor href=#mac-mpo-cred-check-socket-connect></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_connect</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>socket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>sockaddr</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket to be connected</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sockaddr</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Address of <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential (<code>cred</code>) can connect the passed socket (<code>socket</code>) to the passed socket address (<code>sockaddr</code>).
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatches, EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-check-socket-receive>6.7.4.17. <code>mpo_check_socket_receive</code><a class=anchor href=#mac-mpo-check-socket-receive></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_receive</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>so</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>so</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>so</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to receive information from the socket <code>so</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-socket-send>6.7.4.18. <code>mpo_check_socket_send</code><a class=anchor href=#mac-mpo-check-socket-send></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_send</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>so</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>so</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>so</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to send information across the socket <code>so</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-cred-visible>6.7.4.19. <code>mpo_check_cred_visible</code><a class=anchor href=#mac-mpo-check-cred-visible></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_cred_visible</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>u1</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>u2</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>u1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>u2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object credential</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential <code>u1</code> can "see" other subjects with the passed subject credential <code>u2</code>.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatches, EPERM for lack of privilege, or ESRCH to hide visibility.
This call may be made in a number of situations, including inter-process status sysctl’s used by <code>ps</code>, and in procfs lookups.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-socket-visible>6.7.4.20. <code>mpo_check_socket_visible</code><a class=anchor href=#mac-mpo-cred-check-socket-visible></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_visible</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>socket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table></div><div class=sect4><h5 id=mac-mpo-cred-check-ifnet-relabel>6.7.4.21. <code>mpo_check_ifnet_relabel</code><a class=anchor href=#mac-mpo-cred-check-ifnet-relabel></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_ifnet_relabel</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Existing policy label for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label update to later be applied to <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can relabel the passed network interface to the passed label update.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-socket-relabel>6.7.4.22. <code>mpo_check_socket_relabel</code><a class=anchor href=#mac-mpo-cred-check-socket-relabel></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_relabel</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>socket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Existing policy label for <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label update to later be applied to <code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can relabel the passed socket to the passed label update.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-cred-relabel>6.7.4.23. <code>mpo_check_cred_relabel</code><a class=anchor href=#mac-mpo-cred-check-cred-relabel></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_cred_relabel</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label update to later be applied to <code>cred</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can relabel itself to the passed label update.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-relabel>6.7.4.24. <code>mpo_check_vnode_relabel</code><a class=anchor href=#mac-mpo-cred-check-vnode-relabel></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_relabel</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vnodelabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>newlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Locked</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vnodelabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Existing policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label update to later be applied to <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can relabel the passed vnode to the passed label update.</p></div></div><div class=sect4><h5 id=mpo-cred-check-mount-stat>6.7.4.25. <code>mpo_check_mount_stat</code><a class=anchor href=#mpo-cred-check-mount-stat></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_mount_stat</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mountlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; file system mount</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mountlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>mp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can see the results of a statfs performed on the file system.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatches or EPERM for lack of privilege.
This call may be made in a number of situations, including during invocations of <a href="https://man.freebsd.org/cgi/man.cgi?query=statfs&amp;sektion=2&amp;format=html">statfs(2)</a> and related calls, as well as to determine what file systems to exclude from listings of file systems, such as when <a href="https://man.freebsd.org/cgi/man.cgi?query=getfsstat&amp;sektion=2&amp;format=html">getfsstat(2)</a> is invoked.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-proc-debug>6.7.4.26. <code>mpo_check_proc_debug</code><a class=anchor href=#mac-mpo-cred-check-proc-debug></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_proc_debug</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>proc</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; process</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can debug the passed process.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, EPERM for lack of privilege, or ESRCH to hide visibility of the target.
This call may be made in a number of situations, including use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ktrace&amp;sektion=2&amp;format=html">ktrace(2)</a> APIs, as well as for some types of procfs operations.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-access>6.7.4.27. <code>mpo_check_vnode_access</code><a class=anchor href=#mac-mpo-cred-check-vnode-access></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_access</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>flags</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=access&amp;sektion=2&amp;format=html">access(2)</a> flags</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine how invocations of <a href="https://man.freebsd.org/cgi/man.cgi?query=access&amp;sektion=2&amp;format=html">access(2)</a> and related calls by the subject credential should return when performed on the passed vnode using the passed access flags.
This should generally be implemented using the same semantics used in <code>mpo_check_vnode_open</code>.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatches or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-chdir>6.7.4.28. <code>mpo_check_vnode_chdir</code><a class=anchor href=#mac-mpo-cred-check-vnode-chdir></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_chdir</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode to <a href="https://man.freebsd.org/cgi/man.cgi?query=chdir&amp;sektion=2&amp;format=html">chdir(2)</a> into</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can change the process working directory to the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-chroot>6.7.4.29. <code>mpo_check_vnode_chroot</code><a class=anchor href=#mac-mpo-check-vnode-chroot></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_chroot</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directory vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> into the specified directory (<code>dvp</code>).</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-create>6.7.4.30. <code>mpo_check_vnode_create</code><a class=anchor href=#mac-mpo-cred-check-vnode-create></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_create</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>componentname</span> <span class=o>*</span><span class=n>cnp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vattr</span> <span class=o>*</span><span class=n>vap</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cnp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Component name for <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vap</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>vnode attributes for <code>vap</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can create a vnode with the passed parent directory, passed name information, and passed attribute information.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.
This call may be made in a number of situations, including as a result of calls to <a href="https://man.freebsd.org/cgi/man.cgi?query=open&amp;sektion=2&amp;format=html">open(2)</a> with O_CREAT, <a href="https://man.freebsd.org/cgi/man.cgi?query=mkfifo&amp;sektion=2&amp;format=html">mkfifo(2)</a>, and others.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-delete>6.7.4.31. <code>mpo_check_vnode_delete</code><a class=anchor href=#mac-mpo-cred-check-vnode-delete></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>componentname</span> <span class=o>*</span><span class=n>cnp</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Parent directory vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode to delete</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cnp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Component name for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can delete a vnode from the passed parent directory and passed name information.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.
This call may be made in a number of situations, including as a result of calls to <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=2&amp;format=html">unlink(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=rmdir&amp;sektion=2&amp;format=html">rmdir(2)</a>.
Policies implementing this entry point should also implement <code>mpo_check_rename_to</code> to authorize deletion of objects as a result of being the target of a rename.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-deleteacl>6.7.4.32. <code>mpo_check_vnode_deleteacl</code><a class=anchor href=#mac-mpo-cred-check-vnode-deleteacl></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_deleteacl</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=n>acl_type_t</span> <span class=n>type</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Locked</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>type</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ACL type</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can delete the ACL of passed type from the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-exec>6.7.4.33. <code>mpo_check_vnode_exec</code><a class=anchor href=#mac-mpo-cred-check-vnode-exec></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_exec</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode to execute</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can execute the passed vnode.
Determination of execute privilege is made separately from decisions about any transitioning event.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mpo-cred-check-vnode-getacl>6.7.4.34. <code>mpo_check_vnode_getacl</code><a class=anchor href=#mpo-cred-check-vnode-getacl></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_getacl</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=n>acl_type_t</span> <span class=n>type</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>type</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ACL type</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can retrieve the ACL of passed type from the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-getextattr>6.7.4.35. <code>mpo_check_vnode_getextattr</code><a class=anchor href=#mac-mpo-cred-check-vnode-getextattr></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_getextattr</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>attrnamespace</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=k>struct</span> <span class=n>uio</span> <span class=o>*</span><span class=n>uio</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>attrnamespace</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended attribute namespace</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended attribute name</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>uio</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>I/O structure pointer; see <a href="https://man.freebsd.org/cgi/man.cgi?query=uio&amp;sektion=9&amp;format=html">uio(9)</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can retrieve the extended attribute with the passed namespace and name from the passed vnode.
Policies implementing labeling using extended attributes may be interested in special handling of operations on those extended attributes.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-link>6.7.4.36. <code>mpo_check_vnode_link</code><a class=anchor href=#mac-mpo-check-vnode-link></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_link</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>componentname</span> <span class=o>*</span><span class=n>cnp</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directory vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Link destination vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cnp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Component name for the link being created</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to create a link to the vnode <code>vp</code> with the name specified by <code>cnp</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-mmap>6.7.4.37. <code>mpo_check_vnode_mmap</code><a class=anchor href=#mac-mpo-check-vnode-mmap></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_mmap</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vnode to map</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>prot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mmap protections (see <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a>)</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to map the vnode <code>vp</code> with the protections specified in <code>prot</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-mmap-downgrade>6.7.4.38. <code>mpo_check_vnode_mmap_downgrade</code><a class=anchor href=#mac-mpo-check-vnode-mmap-downgrade></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>void</span> <span class=nf>mpo_check_vnode_mmap_downgrade</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>prot</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>See <a href=./#mac-mpo-check-vnode-mmap><code>mpo_check_vnode_mmap</code></a>.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>prot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mmap protections to be downgraded</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Downgrade the mmap protections based on the subject and object labels.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-mprotect>6.7.4.39. <code>mpo_check_vnode_mprotect</code><a class=anchor href=#mac-mpo-check-vnode-mprotect></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_mprotect</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mapped vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>prot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Memory protections</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to set the specified memory protections on memory mapped from the vnode <code>vp</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-poll>6.7.4.40. <code>mpo_check_vnode_poll</code><a class=anchor href=#mac-mpo-check-vnode-poll></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>active_cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>file_cred</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>active_cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>file_cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Credential associated with the struct file</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Polled vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to poll the vnode <code>vp</code>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-rename-from>6.7.4.41. <code>mpo_check_vnode_rename_from</code><a class=anchor href=#mac-mpo-check-vnode-rename-from></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_vnode_rename_from</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>componentname</span> <span class=o>*</span><span class=n>cnp</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directory vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vnode to be renamed</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cnp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Component name for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to rename the vnode <code>vp</code> to something else.</p></div></div><div class=sect4><h5 id=mac-mpo-check-vnode-rename-to>6.7.4.42. <code>mpo_check_vnode_rename_to</code><a class=anchor href=#mac-mpo-check-vnode-rename-to></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_rename_to</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>samedir</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>componentname</span> <span class=o>*</span><span class=n>cnp</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directory vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Overwritten vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>samedir</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Boolean; <code>1</code> if the source and destination directories are the same</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cnp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Destination component name</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to rename to the vnode <code>vp</code>, into the directory <code>dvp</code>, or to the name represented by <code>cnp</code>.
If there is no existing file to overwrite, <code>vp</code> and <code>label</code> will be NULL.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-socket-listen>6.7.4.43. <code>mpo_check_socket_listen</code><a class=anchor href=#mac-mpo-cred-check-socket-listen></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_listen</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>socket</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socket</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>socket</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can listen on the passed socket.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-lookup>6.7.4.44. <code>mpo_check_vnode_lookup</code><a class=anchor href=#mac-mpo-cred-check-vnode-lookup></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_lookup</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>componentname</span> <span class=o>*</span><span class=n>cnp</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cnp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Component name being looked up</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can perform a lookup in the passed directory vnode for the passed name.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-open>6.7.4.45. <code>mpo_check_vnode_open</code><a class=anchor href=#mac-mpo-cred-check-vnode-open></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_open</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>acc_mode</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>acc_mode</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=open&amp;sektion=2&amp;format=html">open(2)</a> access mode</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can perform an open operation on the passed vnode with the passed access mode.
Return 0 for success, or an errno value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-readdir>6.7.4.46. <code>mpo_check_vnode_readdir</code><a class=anchor href=#mac-mpo-cred-check-vnode-readdir></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_readdir</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>dvp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>dlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dvp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; directory vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>dlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>dvp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can perform a <code>readdir</code> operation on the passed directory vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-readlink>6.7.4.47. <code>mpo_check_vnode_readlink</code><a class=anchor href=#mac-mpo-cred-check-vnode-readlink></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_readlink</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can perform a <code>readlink</code> operation on the passed symlink vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.
This call may be made in a number of situations, including an explicit <code>readlink</code> call by the user process, or as a result of an implicit <code>readlink</code> during a name lookup by the process.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-revoke>6.7.4.48. <code>mpo_check_vnode_revoke</code><a class=anchor href=#mac-mpo-cred-check-vnode-revoke></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_revoke</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can revoke access to the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-setacl>6.7.4.49. <code>mpo_check_vnode_setacl</code><a class=anchor href=#mac-mpo-cred-check-vnode-setacl></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_setacl</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=n>acl_type_t</span> <span class=n>type</span><span class=p>,</span> <span class=k>struct</span> <span class=n>acl</span> <span class=o>*</span><span class=n>acl</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>type</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ACL type</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>acl</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ACL</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can set the passed ACL of passed type on the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-setextattr>6.7.4.50. <code>mpo_check_vnode_setextattr</code><a class=anchor href=#mac-mpo-cred-check-vnode-setextattr></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_setextattr</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=kt>int</span> <span class=n>attrnamespace</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=k>struct</span> <span class=n>uio</span> <span class=o>*</span><span class=n>uio</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>attrnamespace</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended attribute namespace</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended attribute name</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>uio</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>I/O structure pointer; see <a href="https://man.freebsd.org/cgi/man.cgi?query=uio&amp;sektion=9&amp;format=html">uio(9)</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can set the extended attribute of passed name and passed namespace on the passed vnode.
Policies implementing security labels backed into extended attributes may want to provide additional protections for those attributes.
Additionally, policies should avoid making decisions based on the data referenced from <code>uio</code>, as there is a potential race condition between this check and the actual operation.
The <code>uio</code> may also be <code>NULL</code> if a delete operation is being performed.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-setflags>6.7.4.51. <code>mpo_check_vnode_setflags</code><a class=anchor href=#mac-mpo-cred-check-vnode-setflags></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_setflags</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=n>u_long</span> <span class=n>flags</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>flags</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File flags; see <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can set the passed flags on the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-setmode>6.7.4.52. <code>mpo_check_vnode_setmode</code><a class=anchor href=#mac-mpo-cred-check-vnode-setmode></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_setmode</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=n>mode_t</span> <span class=n>mode</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mode</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File mode; see <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can set the passed mode on the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-setowner>6.7.4.53. <code>mpo_check_vnode_setowner</code><a class=anchor href=#mac-mpo-cred-check-vnode-setowner></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_setowner</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=n>uid_t</span> <span class=n>uid</span><span class=p>,</span> <span class=n>gid_t</span> <span class=n>gid</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>uid</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>User ID</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>gid</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Group ID</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can set the passed uid and passed gid as file uid and file gid on the passed vnode.
The IDs may be set to (<code>-1</code>) to request no update.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-setutimes>6.7.4.54. <code>mpo_check_vnode_setutimes</code><a class=anchor href=#mac-mpo-cred-check-vnode-setutimes></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_setutimes</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=n>atime</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=n>mtime</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vp</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>atime</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Access time; see <a href="https://man.freebsd.org/cgi/man.cgi?query=utimes&amp;sektion=2&amp;format=html">utimes(2)</a></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mtime</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Modification time; see <a href="https://man.freebsd.org/cgi/man.cgi?query=utimes&amp;sektion=2&amp;format=html">utimes(2)</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can set the passed access timestamps on the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-proc-sched>6.7.4.55. <code>mpo_check_proc_sched</code><a class=anchor href=#mac-mpo-cred-check-proc-sched></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_proc_sched</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>ucred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>proc</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; process</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can change the scheduling parameters of the passed process.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, EPERM for lack of privilege, or ESRCH to limit visibility.</p></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=setpriority&amp;sektion=2&amp;format=html">setpriority(2)</a> for more information.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-proc-signal>6.7.4.56. <code>mpo_check_proc_signal</code><a class=anchor href=#mac-mpo-cred-check-proc-signal></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_proc_signal</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signal</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>proc</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; process</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>signal</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Signal; see <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=2&amp;format=html">kill(2)</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can deliver the passed signal to the passed process.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, EPERM for lack of privilege, or ESRCH to limit visibility.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-vnode-stat>6.7.4.57. <code>mpo_check_vnode_stat</code><a class=anchor href=#mac-mpo-cred-check-vnode-stat></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_vnode_stat</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>label</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; vnode</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>label</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential can <code>stat</code> the passed vnode.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=stat&amp;sektion=2&amp;format=html">stat(2)</a> for more information.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-ifnet-transmit>6.7.4.58. <code>mpo_check_ifnet_transmit</code><a class=anchor href=#mac-mpo-cred-check-ifnet-transmit></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_ifnet_transmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>mbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; mbuf to be sent</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>mbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the network interface can transmit the passed mbuf.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-cred-check-socket-deliver>6.7.4.59. <code>mpo_check_socket_deliver</code><a class=anchor href=#mac-mpo-cred-check-socket-deliver></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_deliver</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>ifnet</span> <span class=o>*</span><span class=n>ifnet</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>ifnetlabel</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>mbuf</span><span class=p>,</span> <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>mbuflabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnet</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Network interface</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ifnetlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>ifnet</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; mbuf to be delivered</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mbuflabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>mbuf</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the socket may receive the datagram stored in the passed mbuf header.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failures: EACCES for label mismatch, or EPERM for lack of privilege.</p></div></div><div class=sect4><h5 id=mac-mpo-check-socket-visible>6.7.4.60. <code>mpo_check_socket_visible</code><a class=anchor href=#mac-mpo-check-socket-visible></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_socket_visible</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>so</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>socketlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Immutable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>so</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Object; socket</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>socketlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Policy label for <code>so</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject credential cred can "see" the passed socket (<code>socket</code>) using system monitoring functions, such as those employed by <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=8&amp;format=html">netstat(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=sockstat&amp;sektion=1&amp;format=html">sockstat(1)</a>.
Return 0 for success, or an <code>errno</code> value for failure.
Suggested failure: EACCES for label mismatches, EPERM for lack of privilege, or ESRCH to hide visibility.</p></div></div><div class=sect4><h5 id=mac-mpo-check-system-acct>6.7.4.61. <code>mpo_check_system_acct</code><a class=anchor href=#mac-mpo-check-system-acct></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_system_acct</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>ucred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ucred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Accounting file; <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to enable accounting, based on its label and the label of the accounting log file.</p></div></div><div class=sect4><h5 id=mac-mpo-check-system-nfsd>6.7.4.62. <code>mpo_check_system_nfsd</code><a class=anchor href=#mac-mpo-check-system-nfsd></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_system_nfsd</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to call <a href="https://man.freebsd.org/cgi/man.cgi?query=nfssvc&amp;sektion=2&amp;format=html">nfssvc(2)</a>.</p></div></div><div class=sect4><h5 id=mac-mpo-check-system-reboot>6.7.4.63. <code>mpo_check_system_reboot</code><a class=anchor href=#mac-mpo-check-system-reboot></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_system_reboot</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=kt>int</span> <span class=n>howto</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>howto</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>howto</code> parameter from <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=2&amp;format=html">reboot(2)</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to reboot the system in the specified manner.</p></div></div><div class=sect4><h5 id=mac-mpo-check-system-settime>6.7.4.64. <code>mpo_check_system_settime</code><a class=anchor href=#mac-mpo-check-system-settime></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_system_settime</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the user should be allowed to set the system clock.</p></div></div><div class=sect4><h5 id=mac-mpo-check-system-swapon>6.7.4.65. <code>mpo_check_system_swapon</code><a class=anchor href=#mac-mpo-check-system-swapon></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_system_swapon</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vnode</span> <span class=o>*</span><span class=n>vp</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>label</span> <span class=o>*</span><span class=n>vlabel</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Swap device</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>vlabel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Label associated with <code>vp</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to add <code>vp</code> as a swap device.</p></div></div><div class=sect4><h5 id=mac-mpo-check-system-sysctl>6.7.4.66. <code>mpo_check_system_sysctl</code><a class=anchor href=#mac-mpo-check-system-sysctl></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=c><span class=kt>int</span> <span class=nf>mpo_check_system_sysctl</span><span class=p>(</span><span class=k>struct</span> <span class=n>ucred</span> <span class=o>*</span><span class=n>cred</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=n>u_int</span> <span class=o>*</span><span class=n>namelen</span><span class=p>,</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>old</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>oldlenp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>inkernel</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>new</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>newlen</span><span class=p>);</span></code></pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Parameter</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Locking</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cred</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Subject credential</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>name</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>See <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>namelen</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>old</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>oldlenp</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>inkernel</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Boolean; <code>1</code> if called from kernel</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>new</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>See <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>newlen</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table><div class=paragraph><p>Determine whether the subject should be allowed to make the specified <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a> transaction.</p></div></div></div><div class=sect3><h4 id=mac-label-management>6.7.5. Label Management Calls<a class=anchor href=#mac-label-management></a></h4><div class=paragraph><p>Relabel events occur when a user process has requested that the label on an object be modified.
A two-phase update occurs: first, an access control check will be performed to determine if the update is both valid and permitted, and then the update itself is performed via a separate entry point.
Relabel entry points typically accept the object, object label reference, and an update label submitted by the process.
Memory allocation during relabel is discouraged, as relabel calls are not permitted to fail (failure should be reported earlier in the relabel check).</p></div></div></div><div class=sect2><h3 id=mac-userland-arch>6.8. Userland Architecture<a class=anchor href=#mac-userland-arch></a></h3><div class=paragraph><p>The TrustedBSD MAC Framework includes a number of policy-agnostic elements, including MAC library interfaces for abstractly managing labels, modifications to the system credential management and login libraries to support the assignment of MAC labels to users, and a set of tools to monitor and modify labels on processes, files, and network interfaces.
More details on the user architecture will be added to this section in the near future.</p></div><div class=sect3><h4 id=mac-userland-labels>6.8.1. APIs for Policy-Agnostic Label Management<a class=anchor href=#mac-userland-labels></a></h4><div class=paragraph><p>The TrustedBSD MAC Framework provides a number of library and system calls permitting applications to manage MAC labels on objects using a policy-agnostic interface.
This permits applications to manipulate labels for a variety of policies without being written to support specific policies.
These interfaces are used by general-purpose tools such as <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> to view labels on network interfaces, files, and processes.
The APIs also support MAC management tools including <a href="https://man.freebsd.org/cgi/man.cgi?query=getfmac&amp;sektion=8&amp;format=html">getfmac(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getpmac&amp;sektion=8&amp;format=html">getpmac(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=setfsmac&amp;sektion=8&amp;format=html">setfsmac(8)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a>.
The MAC APIs are documented in <a href="https://man.freebsd.org/cgi/man.cgi?query=mac&amp;sektion=3&amp;format=html">mac(3)</a>.</p></div><div class=paragraph><p>Applications handle MAC labels in two forms: an internalized form used to return and set labels on processes and objects (<code>mac_t</code>), and externalized form based on C strings appropriate for storage in configuration files, display to the user, or input from the user.
Each MAC label contains a number of elements, each consisting of a name and value pair.
Policy modules in the kernel bind to specific names and interpret the values in policy-specific ways.
In the externalized string form, labels are represented by a comma-delimited list of name and value pairs separated by the <code>/</code> character.
Labels may be directly converted to and from text using provided APIs; when retrieving labels from the kernel, internalized label storage must first be prepared for the desired label element set.
Typically, this is done in one of two ways: using <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_prepare&amp;sektion=3&amp;format=html">mac_prepare(3)</a> and an arbitrary list of desired label elements, or one of the variants of the call that loads a default element set from the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac.conf&amp;sektion=5&amp;format=html">mac.conf(5)</a> configuration file.
Per-object defaults permit application writers to usefully display labels associated with objects without being aware of the policies present in the system.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Currently, direct manipulation of label elements other than by conversion to a text string, string editing, and conversion back to an internalized label is not supported by the MAC library.
Such interfaces may be added in the future if they prove necessary for application writers.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mac-userland-credentials>6.8.2. Binding of Labels to Users<a class=anchor href=#mac-userland-credentials></a></h4><div class=paragraph><p>The standard user context management interface, <a href="https://man.freebsd.org/cgi/man.cgi?query=setusercontext&amp;sektion=3&amp;format=html">setusercontext(3)</a>, has been modified to retrieve MAC labels associated with a user’s class from <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.
These labels are then set along with other user context when either <code>LOGIN_SETALL</code> is specified, or when <code>LOGIN_SETMAC</code> is explicitly specified.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is expected that, in a future version of FreeBSD, the MAC label database will be separated from the <span class=filename>login.conf</span> user class abstraction, and be maintained in a separate database.
However, the <a href="https://man.freebsd.org/cgi/man.cgi?query=setusercontext&amp;sektion=3&amp;format=html">setusercontext(3)</a> API should remain the same following such a change.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-conclusion>6.9. Conclusion<a class=anchor href=#mac-conclusion></a></h3><div class=paragraph><p>The TrustedBSD MAC framework permits kernel modules to augment the system security policy in a highly integrated manner.
They may do this based on existing object properties, or based on label data that is maintained with the assistance of the MAC framework.
The framework is sufficiently flexible to implement a variety of policy types, including information flow security policies such as MLS and Biba, as well as policies based on existing BSD credentials or file protections.
Policy authors may wish to consult this documentation as well as existing security modules when implementing a new security service.</p></div></div></div></div><div class=sect1><h2 id=vm>Chapter 7. Virtual Memory System<a class=anchor href=#vm></a></h2><div class=sectionbody><div class=sect2><h3 id=vm-physmem>7.1. Management of Physical Memory <code>vm_page_t</code><a class=anchor href=#vm-physmem></a></h3><div class=paragraph><p>Physical memory is managed on a page-by-page basis through the <code>vm_page_t</code> structure. Pages of physical memory are categorized through the placement of their respective <code>vm_page_t</code> structures on one of several paging queues.</p></div><div class=paragraph><p>A page can be in a wired, active, inactive, cache, or free state. Except for the wired state, the page is typically placed in a doubly link list queue representing the state that it is in. Wired pages are not placed on any queue.</p></div><div class=paragraph><p>FreeBSD implements a more involved paging queue for cached and free pages in order to implement page coloring. Each of these states involves multiple queues arranged according to the size of the processor’s L1 and L2 caches. When a new page needs to be allocated, FreeBSD attempts to obtain one that is reasonably well aligned from the point of view of the L1 and L2 caches relative to the VM object the page is being allocated for.</p></div><div class=paragraph><p>Additionally, a page may be held with a reference count or locked with a busy count. The VM system also implements an "ultimate locked" state for a page using the PG_BUSY bit in the page’s flags.</p></div><div class=paragraph><p>In general terms, each of the paging queues operates in a LRU fashion. A page is typically placed in a wired or active state initially. When wired, the page is usually associated with a page table somewhere. The VM system ages the page by scanning pages in a more active paging queue (LRU) in order to move them to a less-active paging queue. Pages that get moved into the cache are still associated with a VM object but are candidates for immediate reuse. Pages in the free queue are truly free. FreeBSD attempts to minimize the number of pages in the free queue, but a certain minimum number of truly free pages must be maintained in order to accommodate page allocation at interrupt time.</p></div><div class=paragraph><p>If a process attempts to access a page that does not exist in its page table but does exist in one of the paging queues (such as the inactive or cache queues), a relatively inexpensive page reactivation fault occurs which causes the page to be reactivated. If the page does not exist in system memory at all, the process must block while the page is brought in from disk.</p></div><div class=paragraph><p>FreeBSD dynamically tunes its paging queues and attempts to maintain reasonable ratios of pages in the various queues as well as attempts to maintain a reasonable breakdown of clean versus dirty pages. The amount of rebalancing that occurs depends on the system’s memory load. This rebalancing is implemented by the pageout daemon and involves laundering dirty pages (syncing them with their backing store), noticing when pages are activity referenced (resetting their position in the LRU queues or moving them between queues), migrating pages between queues when the queues are out of balance, and so forth. FreeBSD’s VM system is willing to take a reasonable number of reactivation page faults to determine how active or how idle a page actually is. This leads to better decisions being made as to when to launder or swap-out a page.</p></div></div><div class=sect2><h3 id=vm-cache>7.2. The Unified Buffer Cache <code>vm_object_t</code><a class=anchor href=#vm-cache></a></h3><div class=paragraph><p>FreeBSD implements the idea of a generic "VM object". VM objects can be associated with backing store of various typesunbacked, swap-backed, physical device-backed, or file-backed storage. Since the filesystem uses the same VM objects to manage in-core data relating to files, the result is a unified buffer cache.</p></div><div class=paragraph><p>VM objects can be <em>shadowed</em>. That is, they can be stacked on top of each other. For example, you might have a swap-backed VM object stacked on top of a file-backed VM object in order to implement a MAP_PRIVATE mmap()ing. This stacking is also used to implement various sharing properties, including copy-on-write, for forked address spaces.</p></div><div class=paragraph><p>It should be noted that a <code>vm_page_t</code> can only be associated with one VM object at a time. The VM object shadowing implements the perceived sharing of the same page across multiple instances.</p></div></div><div class=sect2><h3 id=vm-fileio>7.3. Filesystem I/O <code>struct buf</code><a class=anchor href=#vm-fileio></a></h3><div class=paragraph><p>vnode-backed VM objects, such as file-backed objects, generally need to maintain their own clean/dirty info independent from the VM system’s idea of clean/dirty. For example, when the VM system decides to synchronize a physical page to its backing store, the VM system needs to mark the page clean before the page is actually written to its backing store. Additionally, filesystems need to be able to map portions of a file or file metadata into KVM in order to operate on it.</p></div><div class=paragraph><p>The entities used to manage this are known as filesystem buffers, <code>struct buf</code>'s, or <code>bp</code>'s. When a filesystem needs to operate on a portion of a VM object, it typically maps part of the object into a struct buf and then maps the pages in the struct buf into KVM. In the same manner, disk I/O is typically issued by mapping portions of objects into buffer structures and then issuing the I/O on the buffer structures. The underlying vm_page_t’s are typically busied for the duration of the I/O. Filesystem buffers also have their own notion of being busy, which is useful to filesystem driver code which would rather operate on filesystem buffers instead of hard VM pages.</p></div><div class=paragraph><p>FreeBSD reserves a limited amount of KVM to hold mappings from struct bufs, but it should be made clear that this KVM is used solely to hold mappings and does not limit the ability to cache data. Physical data caching is strictly a function of <code>vm_page_t</code>'s, not filesystem buffers. However, since filesystem buffers are used to placehold I/O, they do inherently limit the amount of concurrent I/O possible. However, as there are usually a few thousand filesystem buffers available, this is not usually a problem.</p></div></div><div class=sect2><h3 id=vm-pagetables>7.4. Mapping Page Tables <code>vm_map_t, vm_entry_t</code><a class=anchor href=#vm-pagetables></a></h3><div class=paragraph><p>FreeBSD separates the physical page table topology from the VM system. All hard per-process page tables can be reconstructed on the fly and are usually considered throwaway. Special page tables such as those managing KVM are typically permanently preallocated. These page tables are not throwaway.</p></div><div class=paragraph><p>FreeBSD associates portions of vm_objects with address ranges in virtual memory through <code>vm_map_t</code> and <code>vm_entry_t</code> structures. Page tables are directly synthesized from the <code>vm_map_t</code>/<code>vm_entry_t</code>/ <code>vm_object_t</code> hierarchy. Recall that I mentioned that physical pages are only directly associated with a <code>vm_object</code>; that is not quite true. <code>vm_page_t</code>'s are also linked into page tables that they are actively associated with. One <code>vm_page_t</code> can be linked into several <em>pmaps</em>, as page tables are called. However, the hierarchical association holds, so all references to the same page in the same object reference the same <code>vm_page_t</code> and thus give us buffer cache unification across the board.</p></div></div><div class=sect2><h3 id=vm-kvm>7.5. KVM Memory Mapping<a class=anchor href=#vm-kvm></a></h3><div class=paragraph><p>FreeBSD uses KVM to hold various kernel structures. The single largest entity held in KVM is the filesystem buffer cache. That is, mappings relating to <code>struct buf</code> entities.</p></div><div class=paragraph><p>Unlike Linux, FreeBSD does <em>not</em> map all of physical memory into KVM. This means that FreeBSD can handle memory configurations up to 4G on 32 bit platforms. In fact, if the mmu were capable of it, FreeBSD could theoretically handle memory configurations up to 8TB on a 32 bit platform. However, since most 32 bit platforms are only capable of mapping 4GB of ram, this is a moot point.</p></div><div class=paragraph><p>KVM is managed through several mechanisms. The main mechanism used to manage KVM is the <em>zone allocator</em>. The zone allocator takes a chunk of KVM and splits it up into constant-sized blocks of memory in order to allocate a specific type of structure. You can use <code>vmstat -m</code> to get an overview of current KVM utilization broken down by zone.</p></div></div><div class=sect2><h3 id=vm-tuning>7.6. Tuning the FreeBSD VM System<a class=anchor href=#vm-tuning></a></h3><div class=paragraph><p>A concerted effort has been made to make the FreeBSD kernel dynamically tune itself. Typically you do not need to mess with anything beyond the <code>maxusers</code> and <code>NMBCLUSTERS</code> kernel config options. That is, kernel compilation options specified in (typically) <span class=filename>/usr/src/sys/i386/conf/CONFIG_FILE</span>. A description of all available kernel configuration options can be found in <span class=filename>/usr/src/sys/i386/conf/LINT</span>.</p></div><div class=paragraph><p>In a large system configuration you may wish to increase <code>maxusers</code>. Values typically range from 10 to 128. Note that raising <code>maxusers</code> too high can cause the system to overflow available KVM resulting in unpredictable operation. It is better to leave <code>maxusers</code> at some reasonable number and add other options, such as <code>NMBCLUSTERS</code>, to increase specific resources.</p></div><div class=paragraph><p>If your system is going to use the network heavily, you may want to increase <code>NMBCLUSTERS</code>. Typical values range from 1024 to 4096.</p></div><div class=paragraph><p>The <code>NBUF</code> parameter is also traditionally used to scale the system. This parameter determines the amount of KVA the system can use to map filesystem buffers for I/O. Note that this parameter has nothing whatsoever to do with the unified buffer cache! This parameter is dynamically tuned in 3.0-CURRENT and later kernels and should generally not be adjusted manually. We recommend that you <em>not</em> try to specify an <code>NBUF</code> parameter. Let the system pick it. Too small a value can result in extremely inefficient filesystem operation while too large a value can starve the page queues by causing too many pages to become wired down.</p></div><div class=paragraph><p>By default, FreeBSD kernels are not optimized. You can set debugging and optimization flags with the <code>makeoptions</code> directive in the kernel configuration. Note that you should not use <code>-g</code> unless you can accommodate the large (typically 7 MB+) kernels that result.</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions      DEBUG=&#34;-g&#34;
makeoptions      COPTFLAGS=&#34;-O -pipe&#34;</pre></div></div><div class=paragraph><p>Sysctl provides a way to tune kernel parameters at run-time. You typically do not need to mess with any of the sysctl variables, especially the VM related ones.</p></div><div class=paragraph><p>Run time VM and system tuning is relatively straightforward. First, use Soft Updates on your UFS/FFS filesystems whenever possible. <span class=filename>/usr/src/sys/ufs/ffs/README.softupdates</span> contains instructions (and restrictions) on how to configure it.</p></div><div class=paragraph><p>Second, configure sufficient swap. You should have a swap partition configured on each physical disk, up to four, even on your "work" disks. You should have at least 2x the swap space as you have main memory, and possibly even more if you do not have a lot of memory. You should also size your swap partition based on the maximum memory configuration you ever intend to put on the machine so you do not have to repartition your disks later on. If you want to be able to accommodate a crash dump, your first swap partition must be at least as large as main memory and <span class=filename>/var/crash</span> must have sufficient free space to hold the dump.</p></div><div class=paragraph><p>NFS-based swap is perfectly acceptable on 4.X or later systems, but you must be aware that the NFS server will take the brunt of the paging load.</p></div></div></div></div><div class=sect1><h2 id=smp>Chapter 8. SMPng Design Document<a class=anchor href=#smp></a></h2><div class=sectionbody><div class=sect2><h3 id=smp-intro>8.1. Introduction<a class=anchor href=#smp-intro></a></h3><div class=paragraph><p>This document presents the current design and implementation of the SMPng Architecture. First, the basic primitives and tools are introduced. Next, a general architecture for the FreeBSD kernel’s synchronization and execution model is laid out. Then, locking strategies for specific subsystems are discussed, documenting the approaches taken to introduce fine-grained synchronization and parallelism for each subsystem. Finally, detailed implementation notes are provided to motivate design choices, and make the reader aware of important implications involving the use of specific primitives.</p></div><div class=paragraph><p>This document is a work-in-progress, and will be updated to reflect on-going design and implementation activities associated with the SMPng Project. Many sections currently exist only in outline form, but will be fleshed out as work proceeds. Updates or suggestions regarding the document may be directed to the document editors.</p></div><div class=paragraph><p>The goal of SMPng is to allow concurrency in the kernel. The kernel is basically
one rather large and complex program. To make the kernel multi-threaded we use
some of the same tools used to make other programs multi-threaded. These include
mutexes, shared/exclusive locks, semaphores, and condition variables. For the
definitions of these and other SMP-related terms, please see the <a href=./#smp-glossary>Glossary</a> section of this article.</p></div></div><div class=sect2><h3 id=smp-lock-fundamentals>8.2. Basic Tools and Locking Fundamentals<a class=anchor href=#smp-lock-fundamentals></a></h3><div class=sect3><h4 id=_atomic_instructions_and_memory_barriers>8.2.1. Atomic Instructions and Memory Barriers<a class=anchor href=#_atomic_instructions_and_memory_barriers></a></h4><div class=paragraph><p>There are several existing treatments of memory barriers and atomic instructions, so this section will not include a lot of detail. To put it simply, one can not go around reading variables without a lock if a lock is used to protect writes to that variable. This becomes obvious when you consider that memory barriers simply determine relative order of memory operations; they do not make any guarantee about timing of memory operations. That is, a memory barrier does not force the contents of a CPU’s local cache or store buffer to flush. Instead, the memory barrier at lock release simply ensures that all writes to the protected data will be visible to other CPU’s or devices if the write to release the lock is visible. The CPU is free to keep that data in its cache or store buffer as long as it wants. However, if another CPU performs an atomic instruction on the same datum, the first CPU must guarantee that the updated value is made visible to the second CPU along with any other operations that memory barriers may require.</p></div><div class=paragraph><p>For example, assuming a simple model where data is considered visible when it is in main memory (or a global cache), when an atomic instruction is triggered on one CPU, other CPU’s store buffers and caches must flush any writes to that same cache line along with any pending operations behind a memory barrier.</p></div><div class=paragraph><p>This requires one to take special care when using an item protected by atomic instructions. For example, in the sleep mutex implementation, we have to use an <code>atomic_cmpset</code> rather than an <code>atomic_set</code> to turn on the <code>MTX_CONTESTED</code> bit. The reason is that we read the value of <code>mtx_lock</code> into a variable and then make a decision based on that read. However, the value we read may be stale, or it may change while we are making our decision. Thus, when the <code>atomic_set</code> executed, it may end up setting the bit on another value than the one we made the decision on. Thus, we have to use an <code>atomic_cmpset</code> to set the value only if the value we made the decision on is up-to-date and valid.</p></div><div class=paragraph><p>Finally, atomic instructions only allow one item to be updated or read. If one needs to atomically update several items, then a lock must be used instead. For example, if two counters must be read and have values that are consistent relative to each other, then those counters must be protected by a lock rather than by separate atomic instructions.</p></div></div><div class=sect3><h4 id=_read_locks_versus_write_locks>8.2.2. Read Locks Versus Write Locks<a class=anchor href=#_read_locks_versus_write_locks></a></h4><div class=paragraph><p>Read locks do not need to be as strong as write locks. Both types of locks need to ensure that the data they are accessing is not stale. However, only write access requires exclusive access. Multiple threads can safely read a value. Using different types of locks for reads and writes can be implemented in a number of ways.</p></div><div class=paragraph><p>First, sx locks can be used in this manner by using an exclusive lock when writing and a shared lock when reading. This method is quite straightforward.</p></div><div class=paragraph><p>A second method is a bit more obscure. You can protect a datum with multiple locks. Then for reading that data you simply need to have a read lock of one of the locks. However, to write to the data, you need to have a write lock of all of the locks. This can make writing rather expensive but can be useful when data is accessed in various ways. For example, the parent process pointer is protected by both the <code>proctree_lock</code> sx lock and the per-process mutex. Sometimes the proc lock is easier as we are just checking to see who a parent of a process is that we already have locked. However, other places such as <code>inferior</code> need to walk the tree of processes via parent pointers and locking each process would be prohibitive as well as a pain to guarantee that the condition you are checking remains valid for both the check and the actions taken as a result of the check.</p></div></div><div class=sect3><h4 id=_locking_conditions_and_results>8.2.3. Locking Conditions and Results<a class=anchor href=#_locking_conditions_and_results></a></h4><div class=paragraph><p>If you need a lock to check the state of a variable so that you can take an action based on the state you read, you can not just hold the lock while reading the variable and then drop the lock before you act on the value you read. Once you drop the lock, the variable can change rendering your decision invalid. Thus, you must hold the lock both while reading the variable and while performing the action as a result of the test.</p></div></div></div><div class=sect2><h3 id=smp-design>8.3. General Architecture and Design<a class=anchor href=#smp-design></a></h3><div class=sect3><h4 id=_interrupt_handling>8.3.1. Interrupt Handling<a class=anchor href=#_interrupt_handling></a></h4><div class=paragraph><p>Following the pattern of several other multi-threaded UNIX® kernels, FreeBSD deals with interrupt handlers by giving them their own thread context. Providing a context for interrupt handlers allows them to block on locks. To help avoid latency, however, interrupt threads run at real-time kernel priority. Thus, interrupt handlers should not execute for very long to avoid starving other kernel threads. In addition, since multiple handlers may share an interrupt thread, interrupt handlers should not sleep or use a sleepable lock to avoid starving another interrupt handler.</p></div><div class=paragraph><p>The interrupt threads currently in FreeBSD are referred to as heavyweight interrupt threads. They are called this because switching to an interrupt thread involves a full context switch. In the initial implementation, the kernel was not preemptive and thus interrupts that interrupted a kernel thread would have to wait until the kernel thread blocked or returned to userland before they would have an opportunity to run.</p></div><div class=paragraph><p>To deal with the latency problems, the kernel in FreeBSD has been made preemptive. Currently, we only preempt a kernel thread when we release a sleep mutex or when an interrupt comes in. However, the plan is to make the FreeBSD kernel fully preemptive as described below.</p></div><div class=paragraph><p>Not all interrupt handlers execute in a thread context. Instead, some handlers execute directly in primary interrupt context. These interrupt handlers are currently misnamed "fast" interrupt handlers since the <code>INTR_FAST</code> flag used in earlier versions of the kernel is used to mark these handlers. The only interrupts which currently use these types of interrupt handlers are clock interrupts and serial I/O device interrupts. Since these handlers do not have their own context, they may not acquire blocking locks and thus may only use spin mutexes.</p></div><div class=paragraph><p>Finally, there is one optional optimization that can be added in MD code called lightweight context switches. Since an interrupt thread executes in a kernel context, it can borrow the vmspace of any process. Thus, in a lightweight context switch, the switch to the interrupt thread does not switch vmspaces but borrows the vmspace of the interrupted thread. In order to ensure that the vmspace of the interrupted thread does not disappear out from under us, the interrupted thread is not allowed to execute until the interrupt thread is no longer borrowing its vmspace. This can happen when the interrupt thread either blocks or finishes. If an interrupt thread blocks, then it will use its own context when it is made runnable again. Thus, it can release the interrupted thread.</p></div><div class=paragraph><p>The cons of this optimization are that they are very machine specific and complex and thus only worth the effort if their is a large performance improvement. At this point it is probably too early to tell, and in fact, will probably hurt performance as almost all interrupt handlers will immediately block on Giant and require a thread fix-up when they block. Also, an alternative method of interrupt handling has been proposed by Mike Smith that works like so:</p></div><div class="olist arabic"><ol class=arabic><li><p>Each interrupt handler has two parts: a predicate which runs in primary interrupt context and a handler which runs in its own thread context.</p></li><li><p>If an interrupt handler has a predicate, then when an interrupt is triggered, the predicate is run. If the predicate returns true then the interrupt is assumed to be fully handled and the kernel returns from the interrupt. If the predicate returns false or there is no predicate, then the threaded handler is scheduled to run.</p></li></ol></div><div class=paragraph><p>Fitting light weight context switches into this scheme might prove rather complicated. Since we may want to change to this scheme at some point in the future, it is probably best to defer work on light weight context switches until we have settled on the final interrupt handling architecture and determined how light weight context switches might or might not fit into it.</p></div></div><div class=sect3><h4 id=_kernel_preemption_and_critical_sections>8.3.2. Kernel Preemption and Critical Sections<a class=anchor href=#_kernel_preemption_and_critical_sections></a></h4><div class=sect4><h5 id=_kernel_preemption_in_a_nutshell>8.3.2.1. Kernel Preemption in a Nutshell<a class=anchor href=#_kernel_preemption_in_a_nutshell></a></h5><div class=paragraph><p>Kernel preemption is fairly simple. The basic idea is that a CPU should always be doing the highest priority work available. Well, that is the ideal at least. There are a couple of cases where the expense of achieving the ideal is not worth being perfect.</p></div><div class=paragraph><p>Implementing full kernel preemption is very straightforward: when you schedule a thread to be executed by putting it on a run queue, you check to see if its priority is higher than the currently executing thread. If so, you initiate a context switch to that thread.</p></div><div class=paragraph><p>While locks can protect most data in the case of a preemption, not all of the kernel is preemption safe. For example, if a thread holding a spin mutex preempted and the new thread attempts to grab the same spin mutex, the new thread may spin forever as the interrupted thread may never get a chance to execute. Also, some code such as the code to assign an address space number for a process during <code>exec</code> on the Alpha needs to not be preempted as it supports the actual context switch code. Preemption is disabled for these code sections by using a critical section.</p></div></div><div class=sect4><h5 id=_critical_sections>8.3.2.2. Critical Sections<a class=anchor href=#_critical_sections></a></h5><div class=paragraph><p>The responsibility of the critical section API is to prevent context switches inside of a critical section. With a fully preemptive kernel, every <code>setrunqueue</code> of a thread other than the current thread is a preemption point. One implementation is for <code>critical_enter</code> to set a per-thread flag that is cleared by its counterpart. If <code>setrunqueue</code> is called with this flag set, it does not preempt regardless of the priority of the new thread relative to the current thread. However, since critical sections are used in spin mutexes to prevent context switches and multiple spin mutexes can be acquired, the critical section API must support nesting. For this reason the current implementation uses a nesting count instead of a single per-thread flag.</p></div><div class=paragraph><p>In order to minimize latency, preemptions inside of a critical section are deferred rather than dropped. If a thread that would normally be preempted to is made runnable while the current thread is in a critical section, then a per-thread flag is set to indicate that there is a pending preemption. When the outermost critical section is exited, the flag is checked. If the flag is set, then the current thread is preempted to allow the higher priority thread to run.</p></div><div class=paragraph><p>Interrupts pose a problem with regards to spin mutexes. If a low-level interrupt handler needs a lock, it needs to not interrupt any code needing that lock to avoid possible data structure corruption. Currently, providing this mechanism is piggybacked onto critical section API by means of the <code>cpu_critical_enter</code> and <code>cpu_critical_exit</code> functions. Currently this API disables and re-enables interrupts on all of FreeBSD’s current platforms. This approach may not be purely optimal, but it is simple to understand and simple to get right. Theoretically, this second API need only be used for spin mutexes that are used in primary interrupt context. However, to make the code simpler, it is used for all spin mutexes and even all critical sections. It may be desirable to split out the MD API from the MI API and only use it in conjunction with the MI API in the spin mutex implementation. If this approach is taken, then the MD API likely would need a rename to show that it is a separate API.</p></div></div><div class=sect4><h5 id=_design_tradeoffs>8.3.2.3. Design Tradeoffs<a class=anchor href=#_design_tradeoffs></a></h5><div class=paragraph><p>As mentioned earlier, a couple of trade-offs have been made to sacrifice cases where perfect preemption may not always provide the best performance.</p></div><div class=paragraph><p>The first trade-off is that the preemption code does not take other CPUs into account. Suppose we have a two CPU’s A and B with the priority of A’s thread as 4 and the priority of B’s thread as 2. If CPU B makes a thread with priority 1 runnable, then in theory, we want CPU A to switch to the new thread so that we will be running the two highest priority runnable threads. However, the cost of determining which CPU to enforce a preemption on as well as actually signaling that CPU via an IPI along with the synchronization that would be required would be enormous. Thus, the current code would instead force CPU B to switch to the higher priority thread. Note that this still puts the system in a better position as CPU B is executing a thread of priority 1 rather than a thread of priority 2.</p></div><div class=paragraph><p>The second trade-off limits immediate kernel preemption to real-time priority kernel threads. In the simple case of preemption defined above, a thread is always preempted immediately (or as soon as a critical section is exited) if a higher priority thread is made runnable. However, many threads executing in the kernel only execute in a kernel context for a short time before either blocking or returning to userland. Thus, if the kernel preempts these threads to run another non-realtime kernel thread, the kernel may switch out the executing thread just before it is about to sleep or execute. The cache on the CPU must then adjust to the new thread. When the kernel returns to the preempted thread, it must refill all the cache information that was lost. In addition, two extra context switches are performed that could be avoided if the kernel deferred the preemption until the first thread blocked or returned to userland. Thus, by default, the preemption code will only preempt immediately if the higher priority thread is a real-time priority thread.</p></div><div class=paragraph><p>Turning on full kernel preemption for all kernel threads has value as a debugging aid since it exposes more race conditions. It is especially useful on UP systems were many races are hard to simulate otherwise. Thus, there is a kernel option <code>FULL_PREEMPTION</code> to enable preemption for all kernel threads that can be used for debugging purposes.</p></div></div></div><div class=sect3><h4 id=_thread_migration>8.3.3. Thread Migration<a class=anchor href=#_thread_migration></a></h4><div class=paragraph><p>Simply put, a thread migrates when it moves from one CPU to another. In a non-preemptive kernel this can only happen at well-defined points such as when calling <code>msleep</code> or returning to userland. However, in the preemptive kernel, an interrupt can force a preemption and possible migration at any time. This can have negative affects on per-CPU data since with the exception of <code>curthread</code> and <code>curpcb</code> the data can change whenever you migrate. Since you can potentially migrate at any time this renders unprotected per-CPU data access rather useless. Thus it is desirable to be able to disable migration for sections of code that need per-CPU data to be stable.</p></div><div class=paragraph><p>Critical sections currently prevent migration since they do not allow context switches. However, this may be too strong of a requirement to enforce in some cases since a critical section also effectively blocks interrupt threads on the current processor. As a result, another API has been provided to allow the current thread to indicate that if it preempted it should not migrate to another CPU.</p></div><div class=paragraph><p>This API is known as thread pinning and is provided by the scheduler. The API consists of two functions: <code>sched_pin</code> and <code>sched_unpin</code>. These functions manage a per-thread nesting count <code>td_pinned</code>. A thread is pinned when its nesting count is greater than zero and a thread starts off unpinned with a nesting count of zero. Each scheduler implementation is required to ensure that pinned threads are only executed on the CPU that they were executing on when the <code>sched_pin</code> was first called. Since the nesting count is only written to by the thread itself and is only read by other threads when the pinned thread is not executing but while <code>sched_lock</code> is held, then <code>td_pinned</code> does not need any locking. The <code>sched_pin</code> function increments the nesting count and <code>sched_unpin</code> decrements the nesting count. Note that these functions only operate on the current thread and bind the current thread to the CPU it is executing on at the time. To bind an arbitrary thread to a specific CPU, the <code>sched_bind</code> and <code>sched_unbind</code> functions should be used instead.</p></div></div><div class=sect3><h4 id=_callouts>8.3.4. Callouts<a class=anchor href=#_callouts></a></h4><div class=paragraph><p>The <code>timeout</code> kernel facility permits kernel services to register functions for execution as part of the <code>softclock</code> software interrupt. Events are scheduled based on a desired number of clock ticks, and callbacks to the consumer-provided function will occur at approximately the right time.</p></div><div class=paragraph><p>The global list of pending timeout events is protected by a global spin mutex, <code>callout_lock</code>; all access to the timeout list must be performed with this mutex held. When <code>softclock</code> is woken up, it scans the list of pending timeouts for those that should fire. In order to avoid lock order reversal, the <code>softclock</code> thread will release the <code>callout_lock</code> mutex when invoking the provided <code>timeout</code> callback function. If the <code>CALLOUT_MPSAFE</code> flag was not set during registration, then Giant will be grabbed before invoking the callout, and then released afterwards. The <code>callout_lock</code> mutex will be re-grabbed before proceeding. The <code>softclock</code> code is careful to leave the list in a consistent state while releasing the mutex. If <code>DIAGNOSTIC</code> is enabled, then the time taken to execute each function is measured, and a warning is generated if it exceeds a threshold.</p></div></div></div><div class=sect2><h3 id=smp-lock-strategies>8.4. Specific Locking Strategies<a class=anchor href=#smp-lock-strategies></a></h3><div class=sect3><h4 id=_credentials>8.4.1. Credentials<a class=anchor href=#_credentials></a></h4><div class=paragraph><p><code>struct ucred</code> is the kernel’s internal credential structure, and is generally used as the basis for process-driven access control within the kernel. BSD-derived systems use a "copy-on-write" model for credential data: multiple references may exist for a credential structure, and when a change needs to be made, the structure is duplicated, modified, and then the reference replaced. Due to wide-spread caching of the credential to implement access control on open, this results in substantial memory savings. With a move to fine-grained SMP, this model also saves substantially on locking operations by requiring that modification only occur on an unshared credential, avoiding the need for explicit synchronization when consuming a known-shared credential.</p></div><div class=paragraph><p>Credential structures with a single reference are considered mutable; shared credential structures must not be modified or a race condition is risked. A mutex, <code>cr_mtxp</code> protects the reference count of <code>struct ucred</code> so as to maintain consistency. Any use of the structure requires a valid reference for the duration of the use, or the structure may be released out from under the illegitimate consumer.</p></div><div class=paragraph><p>The <code>struct ucred</code> mutex is a leaf mutex and is implemented via a mutex pool for performance reasons.</p></div><div class=paragraph><p>Usually, credentials are used in a read-only manner for access control decisions, and in this case <code>td_ucred</code> is generally preferred because it requires no locking. When a process' credential is updated the <code>proc</code> lock must be held across the check and update operations thus avoid races. The process credential <code>p_ucred</code> must be used for check and update operations to prevent time-of-check, time-of-use races.</p></div><div class=paragraph><p>If system call invocations will perform access control after an update to the process credential, the value of <code>td_ucred</code> must also be refreshed to the current process value. This will prevent use of a stale credential following a change. The kernel automatically refreshes the <code>td_ucred</code> pointer in the thread structure from the process <code>p_ucred</code> whenever a process enters the kernel, permitting use of a fresh credential for kernel access control.</p></div></div><div class=sect3><h4 id=_file_descriptors_and_file_descriptor_tables>8.4.2. File Descriptors and File Descriptor Tables<a class=anchor href=#_file_descriptors_and_file_descriptor_tables></a></h4><div class=paragraph><p>Details to follow.</p></div></div><div class=sect3><h4 id=_jail_structures>8.4.3. Jail Structures<a class=anchor href=#_jail_structures></a></h4><div class=paragraph><p><code>struct prison</code> stores administrative details pertinent to the maintenance of jails created using the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> API. This includes the per-jail hostname, IP address, and related settings. This structure is reference-counted since pointers to instances of the structure are shared by many credential structures. A single mutex, <code>pr_mtx</code> protects read and write access to the reference count and all mutable variables inside the struct jail. Some variables are set only when the jail is created, and a valid reference to the <code>struct prison</code> is sufficient to read these values. The precise locking of each entry is documented via comments in <span class=filename>sys/jail.h</span>.</p></div></div><div class=sect3><h4 id=_mac_framework>8.4.4. MAC Framework<a class=anchor href=#_mac_framework></a></h4><div class=paragraph><p>The TrustedBSD MAC Framework maintains data in a variety of kernel objects, in the form of <code>struct label</code>. In general, labels in kernel objects are protected by the same lock as the remainder of the kernel object. For example, the <code>v_label</code> label in <code>struct vnode</code> is protected by the vnode lock on the vnode.</p></div><div class=paragraph><p>In addition to labels maintained in standard kernel objects, the MAC Framework also maintains a list of registered and active policies. The policy list is protected by a global mutex (<code>mac_policy_list_lock</code>) and a busy count (also protected by the mutex). Since many access control checks may occur in parallel, entry to the framework for a read-only access to the policy list requires holding the mutex while incrementing (and later decrementing) the busy count. The mutex need not be held for the duration of the MAC entry operation—​some operations, such as label operations on file system objects—​are long-lived. To modify the policy list, such as during policy registration and de-registration, the mutex must be held and the reference count must be zero, to prevent modification of the list while it is in use.</p></div><div class=paragraph><p>A condition variable, <code>mac_policy_list_not_busy</code>, is available to threads that need to wait for the list to become unbusy, but this condition variable must only be waited on if the caller is holding no other locks, or a lock order violation may be possible. The busy count, in effect, acts as a form of shared/exclusive lock over access to the framework: the difference is that, unlike with an sx lock, consumers waiting for the list to become unbusy may be starved, rather than permitting lock order problems with regards to the busy count and other locks that may be held on entry to (or inside) the MAC Framework.</p></div></div><div class=sect3><h4 id=_modules>8.4.5. Modules<a class=anchor href=#_modules></a></h4><div class=paragraph><p>For the module subsystem there exists a single lock that is used to protect the shared data. This lock is a shared/exclusive (SX) lock and has a good chance of needing to be acquired (shared or exclusively), therefore there are a few macros that have been added to make access to the lock more easy. These macros can be located in <span class=filename>sys/module.h</span> and are quite basic in terms of usage. The main structures protected under this lock are the <code>module_t</code> structures (when shared) and the global <code>modulelist_t</code> structure, modules. One should review the related source code in <span class=filename>kern/kern_module.c</span> to further understand the locking strategy.</p></div></div><div class=sect3><h4 id=_newbus_device_tree>8.4.6. Newbus Device Tree<a class=anchor href=#_newbus_device_tree></a></h4><div class=paragraph><p>The newbus system will have one sx lock. Readers will hold a shared (read) lock (<a href="https://man.freebsd.org/cgi/man.cgi?query=sx_slock&amp;sektion=9&amp;format=html">sx_slock(9)</a>) and writers will hold an exclusive (write) lock (<a href="https://man.freebsd.org/cgi/man.cgi?query=sx_xlock&amp;sektion=9&amp;format=html">sx_xlock(9)</a>). Internal functions will not do locking at all. Externally visible ones will lock as needed. Those items that do not matter if the race is won or lost will not be locked, since they tend to be read all over the place (e.g., <a href="https://man.freebsd.org/cgi/man.cgi?query=device_get_softc&amp;sektion=9&amp;format=html">device_get_softc(9)</a>). There will be relatively few changes to the newbus data structures, so a single lock should be sufficient and not impose a performance penalty.</p></div></div><div class=sect3><h4 id=_pipes>8.4.7. Pipes<a class=anchor href=#_pipes></a></h4><div class=paragraph><p>…​</p></div></div><div class=sect3><h4 id=_processes_and_threads>8.4.8. Processes and Threads<a class=anchor href=#_processes_and_threads></a></h4><div class=ulist><ul><li><p>process hierarchy</p></li><li><p>proc locks, references</p></li><li><p>thread-specific copies of proc entries to freeze during system calls, including td_ucred</p></li><li><p>inter-process operations</p></li><li><p>process groups and sessions</p></li></ul></div></div><div class=sect3><h4 id=_scheduler>8.4.9. Scheduler<a class=anchor href=#_scheduler></a></h4><div class=paragraph><p>Lots of references to <code>sched_lock</code> and notes pointing at specific primitives and related magic elsewhere in the document.</p></div></div><div class=sect3><h4 id=_select_and_poll>8.4.10. Select and Poll<a class=anchor href=#_select_and_poll></a></h4><div class=paragraph><p>The <code>select</code> and <code>poll</code> functions permit threads to block waiting on events on file descriptors—​most frequently, whether or not the file descriptors are readable or writable.</p></div><div class=paragraph><p>…​</p></div></div><div class=sect3><h4 id=_sigio>8.4.11. SIGIO<a class=anchor href=#_sigio></a></h4><div class=paragraph><p>The SIGIO service permits processes to request the delivery of a SIGIO signal to its process group when the read/write status of specified file descriptors changes. At most one process or process group is permitted to register for SIGIO from any given kernel object, and that process or group is referred to as the owner. Each object supporting SIGIO registration contains pointer field that is <code>NULL</code> if the object is not registered, or points to a <code>struct sigio</code> describing the registration. This field is protected by a global mutex, <code>sigio_lock</code>. Callers to SIGIO maintenance functions must pass in this field "by reference" so that local register copies of the field are not made when unprotected by the lock.</p></div><div class=paragraph><p>One <code>struct sigio</code> is allocated for each registered object associated with any process or process group, and contains back-pointers to the object, owner, signal information, a credential, and the general disposition of the registration. Each process or progress group contains a list of registered <code>struct sigio</code> structures, <code>p_sigiolst</code> for processes, and <code>pg_sigiolst</code> for process groups. These lists are protected by the process or process group locks respectively. Most fields in each <code>struct sigio</code> are constant for the duration of the registration, with the exception of the <code>sio_pgsigio</code> field which links the <code>struct sigio</code> into the process or process group list. Developers implementing new kernel objects supporting SIGIO will, in general, want to avoid holding structure locks while invoking SIGIO supporting functions, such as <code>fsetown</code> or <code>funsetown</code> to avoid defining a lock order between structure locks and the global SIGIO lock. This is generally possible through use of an elevated reference count on the structure, such as reliance on a file descriptor reference to a pipe during a pipe operation.</p></div></div><div class=sect3><h4 id=_sysctl>8.4.12. Sysctl<a class=anchor href=#_sysctl></a></h4><div class=paragraph><p>The <code>sysctl</code> MIB service is invoked from both within the kernel and from userland applications using a system call. At least two issues are raised in locking: first, the protection of the structures maintaining the namespace, and second, interactions with kernel variables and functions that are accessed by the sysctl interface. Since sysctl permits the direct export (and modification) of kernel statistics and configuration parameters, the sysctl mechanism must become aware of appropriate locking semantics for those variables. Currently, sysctl makes use of a single global sx lock to serialize use of <code>sysctl</code>; however, it is assumed to operate under Giant and other protections are not provided. The remainder of this section speculates on locking and semantic changes to sysctl.</p></div><div class=ulist><ul><li><p>Need to change the order of operations for sysctl’s that update values from read old, copyin and copyout, write new to copyin, lock, read old and write new, unlock, copyout. Normal sysctl’s that just copyout the old value and set a new value that they copyin may still be able to follow the old model. However, it may be cleaner to use the second model for all of the sysctl handlers to avoid lock operations.</p></li><li><p>To allow for the common case, a sysctl could embed a pointer to a mutex in the SYSCTL_FOO macros and in the struct. This would work for most sysctl’s. For values protected by sx locks, spin mutexes, or other locking strategies besides a single sleep mutex, SYSCTL_PROC nodes could be used to get the locking right.</p></li></ul></div></div><div class=sect3><h4 id=_taskqueue>8.4.13. Taskqueue<a class=anchor href=#_taskqueue></a></h4><div class=paragraph><p>The taskqueue’s interface has two basic locks associated with it in order to protect the related shared data. The <code>taskqueue_queues_mutex</code> is meant to serve as a lock to protect the <code>taskqueue_queues</code> TAILQ. The other mutex lock associated with this system is the one in the <code>struct taskqueue</code> data structure. The use of the synchronization primitive here is to protect the integrity of the data in the <code>struct taskqueue</code>. It should be noted that there are no separate macros to assist the user in locking down his/her own work since these locks are most likely not going to be used outside of <span class=filename>kern/subr_taskqueue.c</span>.</p></div></div></div><div class=sect2><h3 id=smp-implementation-notes>8.5. Implementation Notes<a class=anchor href=#smp-implementation-notes></a></h3><div class=sect3><h4 id=_sleep_queues>8.5.1. Sleep Queues<a class=anchor href=#_sleep_queues></a></h4><div class=paragraph><p>A sleep queue is a structure that holds the list of threads asleep on a wait channel. Each thread that is not asleep on a wait channel carries a sleep queue structure around with it. When a thread blocks on a wait channel, it donates its sleep queue structure to that wait channel. Sleep queues associated with a wait channel are stored in a hash table.</p></div><div class=paragraph><p>The sleep queue hash table holds sleep queues for wait channels that have at least one blocked thread. Each entry in the hash table is called a sleepqueue chain. The chain contains a linked list of sleep queues and a spin mutex. The spin mutex protects the list of sleep queues as well as the contents of the sleep queue structures on the list. Only one sleep queue is associated with a given wait channel. If multiple threads block on a wait channel than the sleep queues associated with all but the first thread are stored on a list of free sleep queues in the master sleep queue. When a thread is removed from the sleep queue it is given one of the sleep queue structures from the master queue’s free list if it is not the only thread asleep on the queue. The last thread is given the master sleep queue when it is resumed. Since threads may be removed from the sleep queue in a different order than they are added, a thread may depart from a sleep queue with a different sleep queue structure than the one it arrived with.</p></div><div class=paragraph><p>The <code>sleepq_lock</code> function locks the spin mutex of the sleep queue chain that maps to a specific wait channel. The <code>sleepq_lookup</code> function looks in the hash table for the master sleep queue associated with a given wait channel. If no master sleep queue is found, it returns <code>NULL</code>. The <code>sleepq_release</code> function unlocks the spin mutex associated with a given wait channel.</p></div><div class=paragraph><p>A thread is added to a sleep queue via the <code>sleepq_add</code>. This function accepts the wait channel, a pointer to the mutex that protects the wait channel, a wait message description string, and a mask of flags. The sleep queue chain should be locked via <code>sleepq_lock</code> before this function is called. If no mutex protects the wait channel (or it is protected by Giant), then the mutex pointer argument should be <code>NULL</code>. The flags argument contains a type field that indicates the kind of sleep queue that the thread is being added to and a flag to indicate if the sleep is interruptible (<code>SLEEPQ_INTERRUPTIBLE</code>). Currently there are only two types of sleep queues: traditional sleep queues managed via the <code>msleep</code> and <code>wakeup</code> functions (<code>SLEEPQ_MSLEEP</code>) and condition variable sleep queues (<code>SLEEPQ_CONDVAR</code>). The sleep queue type and lock pointer argument are used solely for internal assertion checking. Code that calls <code>sleepq_add</code> should explicitly unlock any interlock protecting the wait channel after the associated sleepqueue chain has been locked via <code>sleepq_lock</code> and before blocking on the sleep queue via one of the waiting functions.</p></div><div class=paragraph><p>A timeout for a sleep is set by invoking <code>sleepq_set_timeout</code>. The function accepts the wait channel and the timeout time as a relative tick count as its arguments. If a sleep should be interrupted by arriving signals, the <code>sleepq_catch_signals</code> function should be called as well. This function accepts the wait channel as its only parameter. If there is already a signal pending for this thread, then <code>sleepq_catch_signals</code> will return a signal number; otherwise, it will return 0.</p></div><div class=paragraph><p>Once a thread has been added to a sleep queue, it blocks using one of the <code>sleepq_wait</code> functions. There are four wait functions depending on whether or not the caller wishes to use a timeout or have the sleep aborted by caught signals or an interrupt from the userland thread scheduler. The <code>sleepq_wait</code> function simply waits until the current thread is explicitly resumed by one of the wakeup functions. The <code>sleepq_timedwait</code> function waits until either the thread is explicitly resumed or the timeout set by an earlier call to <code>sleepq_set_timeout</code> expires. The <code>sleepq_wait_sig</code> function waits until either the thread is explicitly resumed or its sleep is aborted. The <code>sleepq_timedwait_sig</code> function waits until either the thread is explicitly resumed, the timeout set by an earlier call to <code>sleepq_set_timeout</code> expires, or the thread’s sleep is aborted. All of the wait functions accept the wait channel as their first parameter. In addition, the <code>sleepq_timedwait_sig</code> function accepts a second boolean parameter to indicate if the earlier call to <code>sleepq_catch_signals</code> found a pending signal.</p></div><div class=paragraph><p>If the thread is explicitly resumed or is aborted by a signal, then a value of zero is returned by the wait function to indicate a successful sleep. If the thread is resumed by either a timeout or an interrupt from the userland thread scheduler then an appropriate errno value is returned instead. Note that since <code>sleepq_wait</code> can only return 0 it does not return anything and the caller should assume a successful sleep. Also, if a thread’s sleep times out and is aborted simultaneously then <code>sleepq_timedwait_sig</code> will return an error indicating that a timeout occurred. If an error value of 0 is returned and either <code>sleepq_wait_sig</code> or <code>sleepq_timedwait_sig</code> was used to block, then the function <code>sleepq_calc_signal_retval</code> should be called to check for any pending signals and calculate an appropriate return value if any are found. The signal number returned by the earlier call to <code>sleepq_catch_signals</code> should be passed as the sole argument to <code>sleepq_calc_signal_retval</code>.</p></div><div class=paragraph><p>Threads asleep on a wait channel are explicitly resumed by the <code>sleepq_broadcast</code> and <code>sleepq_signal</code> functions. Both functions accept the wait channel from which to resume threads, a priority to raise resumed threads to, and a flags argument to indicate which type of sleep queue is being resumed. The priority argument is treated as a minimum priority. If a thread being resumed already has a higher priority (numerically lower) than the priority argument then its priority is not adjusted. The flags argument is used for internal assertions to ensure that sleep queues are not being treated as the wrong type. For example, the condition variable functions should not resume threads on a traditional sleep queue. The <code>sleepq_broadcast</code> function resumes all threads that are blocked on the specified wait channel while <code>sleepq_signal</code> only resumes the highest priority thread blocked on the wait channel. The sleep queue chain should first be locked via the <code>sleepq_lock</code> function before calling these functions.</p></div><div class=paragraph><p>A sleeping thread may have its sleep interrupted by calling the <code>sleepq_abort</code> function. This function must be called with <code>sched_lock</code> held and the thread must be queued on a sleep queue. A thread may also be removed from a specific sleep queue via the <code>sleepq_remove</code> function. This function accepts both a thread and a wait channel as an argument and only awakens the thread if it is on the sleep queue for the specified wait channel. If the thread is not on a sleep queue or it is on a sleep queue for a different wait channel, then this function does nothing.</p></div></div><div class=sect3><h4 id=_turnstiles>8.5.2. Turnstiles<a class=anchor href=#_turnstiles></a></h4><div class=ulist><ul><li><p>Compare/contrast with sleep queues.</p></li><li><p>Lookup/wait/release. - Describe TDF_TSNOBLOCK race.</p></li><li><p>Priority propagation.</p></li></ul></div></div><div class=sect3><h4 id=_details_of_the_mutex_implementation>8.5.3. Details of the Mutex Implementation<a class=anchor href=#_details_of_the_mutex_implementation></a></h4><div class=ulist><ul><li><p>Should we require mutexes to be owned for mtx_destroy() since we can not safely assert that they are unowned by anyone else otherwise?</p></li></ul></div><div class=sect4><h5 id=_spin_mutexes>8.5.3.1. Spin Mutexes<a class=anchor href=#_spin_mutexes></a></h5><div class=ulist><ul><li><p>Use a critical section…​</p></li></ul></div></div><div class=sect4><h5 id=_sleep_mutexes>8.5.3.2. Sleep Mutexes<a class=anchor href=#_sleep_mutexes></a></h5><div class=ulist><ul><li><p>Describe the races with contested mutexes</p></li><li><p>Why it is safe to read mtx_lock of a contested mutex when holding the turnstile chain lock.</p></li></ul></div></div></div><div class=sect3><h4 id=_witness>8.5.4. Witness<a class=anchor href=#_witness></a></h4><div class=ulist><ul><li><p>What does it do</p></li><li><p>How does it work</p></li></ul></div></div></div><div class=sect2><h3 id=smp-misc>8.6. Miscellaneous Topics<a class=anchor href=#smp-misc></a></h3><div class=sect3><h4 id=_interrupt_source_and_icu_abstractions>8.6.1. Interrupt Source and ICU Abstractions<a class=anchor href=#_interrupt_source_and_icu_abstractions></a></h4><div class=ulist><ul><li><p>struct isrc</p></li><li><p>pic drivers</p></li></ul></div></div><div class=sect3><h4 id=_other_random_questionstopics>8.6.2. Other Random Questions/Topics<a class=anchor href=#_other_random_questionstopics></a></h4><div class=ulist><ul><li><p>Should we pass an interlock into <code>sema_wait</code>?</p></li><li><p>Should we have non-sleepable sx locks?</p></li><li><p>Add some info about proper use of reference counts.</p></li></ul></div></div></div><div class=sect2><h3 id=smp-glossary>Glossary<a class=anchor href=#smp-glossary></a></h3><div class="dlist glosslist"><dl><dt class=hdlist1>atomic</dt><dd><p>An operation is atomic if all of its effects are visible to other CPUs together when the proper access protocol is followed. In the degenerate case are atomic instructions provided directly by machine architectures. At a higher level, if several members of a structure are protected by a lock, then a set of operations are atomic if they are all performed while holding the lock without releasing the lock in between any of the operations.</p><div class=paragraph><p>See Also operation.</p></div></dd><dt class=hdlist1>block</dt><dd><p>A thread is blocked when it is waiting on a lock, resource, or condition. Unfortunately this term is a bit overloaded as a result.</p><div class=paragraph><p>See Also sleep.</p></div></dd><dt class=hdlist1>critical section</dt><dd><p>A section of code that is not allowed to be preempted. A critical section is entered and exited using the <a href="https://man.freebsd.org/cgi/man.cgi?query=critical_enter&amp;sektion=9&amp;format=html">critical_enter(9)</a> API.</p></dd><dt class=hdlist1>MD</dt><dd><p>Machine dependent.</p><div class=paragraph><p>See Also MI.</p></div></dd><dt class=hdlist1>memory operation</dt><dd><p>A memory operation reads and/or writes to a memory location.</p></dd><dt class=hdlist1>MI</dt><dd><p>Machine independent.</p><div class=paragraph><p>See Also MD.</p></div></dd><dt class=hdlist1>operation</dt><dd><p>See memory operation.</p></dd><dt class=hdlist1>primary interrupt context</dt><dd><p>Primary interrupt context refers to the code that runs when an interrupt occurs. This code can either run an interrupt handler directly or schedule an asynchronous interrupt thread to execute the interrupt handlers for a given interrupt source.</p></dd><dt class=hdlist1>realtime kernel thread</dt><dd><p>A high priority kernel thread. Currently, the only realtime priority kernel threads are interrupt threads.</p><div class=paragraph><p>See Also thread.</p></div></dd><dt class=hdlist1>sleep</dt><dd><p>A thread is asleep when it is blocked on a condition variable or a sleep queue via msleep or tsleep.</p><div class=paragraph><p>See Also block.</p></div></dd><dt class=hdlist1>sleepable lock</dt><dd><p>A sleepable lock is a lock that can be held by a thread which is asleep. Lockmgr locks and sx locks are currently the only sleepable locks in FreeBSD. Eventually, some sx locks such as the allproc and proctree locks may become non-sleepable locks.</p><div class=paragraph><p>See Also sleep.</p></div></dd><dt class=hdlist1>thread</dt><dd><p>A kernel thread represented by a struct thread. Threads own locks and hold a single execution context.</p></dd><dt class=hdlist1>wait channel</dt><dd><p>A kernel virtual address that threads may sleep on.</p></dd></dl></div></div></div></div><h1 id=devicedrivers class=sect0>Part II: Device Drivers<a class=anchor href=#devicedrivers></a></h1><div class=sect1><h2 id=driverbasics>Chapter 9. Writing FreeBSD Device Drivers<a class=anchor href=#driverbasics></a></h2><div class=sectionbody><div class=sect2><h3 id=driverbasics-intro>9.1. Introduction<a class=anchor href=#driverbasics-intro></a></h3><div class=paragraph><p>This chapter provides a brief introduction to writing device drivers for FreeBSD. A device in this context is a term used mostly for hardware-related stuff that belongs to the system, like disks, printers, or a graphics display with its keyboard. A device driver is the software component of the operating system that controls a specific device. There are also so-called pseudo-devices where a device driver emulates the behavior of a device in software without any particular underlying hardware. Device drivers can be compiled into the system statically or loaded on demand through the dynamic kernel linker facility `kld'.</p></div><div class=paragraph><p>Most devices in a UNIX®-like operating system are accessed through device-nodes, sometimes also called special files. These files are usually located under the directory <span class=filename>/dev</span> in the filesystem hierarchy.</p></div><div class=paragraph><p>Device drivers can roughly be broken down into two categories; character and network device drivers.</p></div></div><div class=sect2><h3 id=driverbasics-kld>9.2. Dynamic Kernel Linker Facility - KLD<a class=anchor href=#driverbasics-kld></a></h3><div class=paragraph><p>The kld interface allows system administrators to dynamically add and remove functionality from a running system. This allows device driver writers to load their new changes into a running kernel without constantly rebooting to test changes.</p></div><div class=paragraph><p>The kld interface is used through:</p></div><div class=ulist><ul><li><p><code>kldload</code> - loads a new kernel module</p></li><li><p><code>kldunload</code> - unloads a kernel module</p></li><li><p><code>kldstat</code> - lists loaded modules</p></li></ul></div><div class=paragraph><p>Skeleton Layout of a kernel module</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * KLD Skeleton
 * Inspired by Andrew Reiter&#39;s Daemonnews article
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/module.h&gt;
#include &lt;sys/kernel.h&gt; /* types used in module initialization */

/*
 * Load handler that deals with the loading and unloading of a KLD.
 */

static int
skel_loader(struct module *m, int what, void *arg)
{
	int err = 0;

	switch (what) {
	case MOD_LOAD:                /* kldload */
		uprintf(&#34;Skeleton KLD loaded.\n&#34;);
		break;
	case MOD_UNLOAD:
		uprintf(&#34;Skeleton KLD unloaded.\n&#34;);
		break;
	default:
		err = EOPNOTSUPP;
		break;
	}
	return(err);
}

/* Declare this module to the rest of the kernel */

static moduledata_t skel_mod = {
	&#34;skel&#34;,
	skel_loader,
	NULL
};

DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);</pre></div></div><div class=sect3><h4 id=_makefile>9.2.1. Makefile<a class=anchor href=#_makefile></a></h4><div class=paragraph><p>FreeBSD provides a system makefile to simplify compiling a kernel module.</p></div><div class="literalblock programlisting"><div class=content><pre>SRCS=skeleton.c
KMOD=skeleton

.include &lt;bsd.kmod.mk&gt;</pre></div></div><div class=paragraph><p>Running <code>make</code> with this makefile will create a file <span class=filename>skeleton.ko</span> that can be loaded into the kernel by typing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># kldload -v ./skeleton.ko</span></code></pre></div></div></div></div><div class=sect2><h3 id=driverbasics-char>9.3. Character Devices<a class=anchor href=#driverbasics-char></a></h3><div class=paragraph><p>A character device driver is one that transfers data directly to and from a user process. This is the most common type of device driver and there are plenty of simple examples in the source tree.</p></div><div class=paragraph><p>This simple example pseudo-device remembers whatever values are written to it and can then echo them back when read.</p></div><div class=exampleblock><div class=title>Example 4. Example of a Sample Echo Pseudo-Device Driver for FreeBSD 10.X - 12.X</div><div class=content><div class="literalblock programlisting"><div class=content><pre>/*
 * Simple Echo pseudo-device KLD
 *
 * Murray Stokely
 * Søren (Xride) Straarup
 * Eitan Adler
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/module.h&gt;
#include &lt;sys/kernel.h&gt; /* types used in module initialization */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;

#define BUFFERSIZE 255

/* Function prototypes */
static d_open_t      echo_open;
static d_close_t     echo_close;
static d_read_t      echo_read;
static d_write_t     echo_write;

/* Character device entry points */
static struct cdevsw echo_cdevsw = {
	.d_version = D_VERSION,
	.d_open = echo_open,
	.d_close = echo_close,
	.d_read = echo_read,
	.d_write = echo_write,
	.d_name = &#34;echo&#34;,
};

struct s_echo {
	char msg[BUFFERSIZE + 1];
	int len;
};

/* vars */
static struct cdev *echo_dev;
static struct s_echo *echomsg;

MALLOC_DECLARE(M_ECHOBUF);
MALLOC_DEFINE(M_ECHOBUF, &#34;echobuffer&#34;, &#34;buffer for echo module&#34;);

/*
 * This function is called by the kld[un]load(2) system calls to
 * determine what actions to take when a module is loaded or unloaded.
 */
static int
echo_loader(struct module *m __unused, int what, void *arg __unused)
{
	int error = 0;

	switch (what) {
	case MOD_LOAD:                /* kldload */
		error = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,
		    &amp;echo_dev,
		    &amp;echo_cdevsw,
		    0,
		    UID_ROOT,
		    GID_WHEEL,
		    0600,
		    &#34;echo&#34;);
		if (error != 0)
			break;

		echomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |
		    M_ZERO);
		printf(&#34;Echo device loaded.\n&#34;);
		break;
	case MOD_UNLOAD:
		destroy_dev(echo_dev);
		free(echomsg, M_ECHOBUF);
		printf(&#34;Echo device unloaded.\n&#34;);
		break;
	default:
		error = EOPNOTSUPP;
		break;
	}
	return (error);
}

static int
echo_open(struct cdev *dev __unused, int oflags __unused, int devtype __unused,
    struct thread *td __unused)
{
	int error = 0;

	uprintf(&#34;Opened device \&#34;echo\&#34; successfully.\n&#34;);
	return (error);
}

static int
echo_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,
    struct thread *td __unused)
{

	uprintf(&#34;Closing device \&#34;echo\&#34;.\n&#34;);
	return (0);
}

/*
 * The read function just takes the buf that was saved via
 * echo_write() and returns it to userland for accessing.
 * uio(9)
 */
static int
echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
{
	size_t amt;
	int error;

	/*
	 * How big is this read operation?  Either as big as the user wants,
	 * or as big as the remaining data.  Note that the &#39;len&#39; does not
	 * include the trailing null character.
	 */
	amt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 ? 0 :
	    echomsg-&gt;len + 1 - uio-&gt;uio_offset);

	if ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)
		uprintf(&#34;uiomove failed!\n&#34;);

	return (error);
}

/*
 * echo_write takes in a character string and saves it
 * to buf for later accessing.
 */
static int
echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
{
	size_t amt;
	int error;

	/*
	 * We either write from the beginning or are appending -- do
	 * not allow random access.
	 */
	if (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-&gt;len))
		return (EINVAL);

	/* This is a new message, reset length */
	if (uio-&gt;uio_offset == 0)
		echomsg-&gt;len = 0;

	/* Copy the string in from user memory to kernel memory */
	amt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));

	error = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);

	/* Now we need to null terminate and record the length */
	echomsg-&gt;len = uio-&gt;uio_offset;
	echomsg-&gt;msg[echomsg-&gt;len] = 0;

	if (error != 0)
		uprintf(&#34;Write failed: bad address!\n&#34;);
	return (error);
}

DEV_MODULE(echo, echo_loader, NULL);</pre></div></div></div></div><div class=paragraph><p>With this driver loaded try:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># echo -n &#34;Test Data&#34; &gt; /dev/echo</span>
<span class=c># cat /dev/echo</span>
Opened device <span class=s2>&#34;echo&#34;</span> successfully.
Test Data
Closing device <span class=s2>&#34;echo&#34;</span>.</code></pre></div></div><div class=paragraph><p>Real hardware devices are described in the next chapter.</p></div></div><div class=sect2><h3 id=driverbasics-block>9.4. Block Devices (Are Gone)<a class=anchor href=#driverbasics-block></a></h3><div class=paragraph><p>Other UNIX® systems may support a second type of disk device known as block devices. Block devices are disk devices for which the kernel provides caching. This caching makes block-devices almost unusable, or at least dangerously unreliable. The caching will reorder the sequence of write operations, depriving the application of the ability to know the exact disk contents at any one instant in time.</p></div><div class=paragraph><p>This makes predictable and reliable crash recovery of on-disk data structures (filesystems, databases, etc.) impossible. Since writes may be delayed, there is no way the kernel can report to the application which particular write operation encountered a write error, this further compounds the consistency problem.</p></div><div class=paragraph><p>For this reason, no serious applications rely on block devices, and in fact, almost all applications which access disks directly take great pains to specify that character (or "raw") devices should always be used. As the implementation of the aliasing of each disk (partition) to two devices with different semantics significantly complicated the relevant kernel code, FreeBSD dropped support for cached disk devices as part of the modernization of the disk I/O infrastructure.</p></div></div><div class=sect2><h3 id=driverbasics-net>9.5. Network Drivers<a class=anchor href=#driverbasics-net></a></h3><div class=paragraph><p>Drivers for network devices do not use device nodes in order to be accessed. Their selection is based on other decisions made inside the kernel and instead of calling open(), use of a network device is generally introduced by using the system call socket(2).</p></div><div class=paragraph><p>For more information see ifnet(9), the source of the loopback device, and Bill Paul’s network drivers.</p></div></div></div></div><div class=sect1><h2 id=isa-driver>Chapter 10. ISA Device Drivers<a class=anchor href=#isa-driver></a></h2><div class=sectionbody><div class=sect2><h3 id=isa-driver-synopsis>10.1. Synopsis<a class=anchor href=#isa-driver-synopsis></a></h3><div class=paragraph><p>This chapter introduces the issues relevant to writing a driver for an ISA device. The pseudo-code presented here is rather detailed and reminiscent of the real code but is still only pseudo-code. It avoids the details irrelevant to the subject of the discussion. The real-life examples can be found in the source code of real drivers. In particular the drivers <code>ep</code> and <code>aha</code> are good sources of information.</p></div></div><div class=sect2><h3 id=isa-driver-basics>10.2. Basic Information<a class=anchor href=#isa-driver-basics></a></h3><div class=paragraph><p>A typical ISA driver would need the following include files:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;sys/module.h&gt;
#include &lt;sys/bus.h&gt;
#include &lt;machine/bus.h&gt;
#include &lt;machine/resource.h&gt;
#include &lt;sys/rman.h&gt;

#include &lt;isa/isavar.h&gt;
#include &lt;isa/pnpvar.h&gt;</pre></div></div><div class=paragraph><p>They describe the things specific to the ISA and generic bus subsystem.</p></div><div class=paragraph><p>The bus subsystem is implemented in an object-oriented fashion, its main structures are accessed by associated method functions.</p></div><div class=paragraph><p>The list of bus methods implemented by an ISA driver is like one for any other bus. For a hypothetical driver named "xxx" they would be:</p></div><div class=ulist><ul><li><p><code>static void xxx_isa_identify (driver_t *, device_t);</code> Normally used for bus drivers, not device drivers. But for ISA devices this method may have special use: if the device provides some device-specific (non-PnP) way to auto-detect devices this routine may implement it.</p></li><li><p><code>static int xxx_isa_probe (device_t dev);</code> Probe for a device at a known (or PnP) location. This routine can also accommodate device-specific auto-detection of parameters for partially configured devices.</p></li><li><p><code>static int xxx_isa_attach (device_t dev);</code> Attach and initialize device.</p></li><li><p><code>static int xxx_isa_detach (device_t dev);</code> Detach device before unloading the driver module.</p></li><li><p><code>static int xxx_isa_shutdown (device_t dev);</code> Execute shutdown of the device before system shutdown.</p></li><li><p><code>static int xxx_isa_suspend (device_t dev);</code> Suspend the device before the system goes to the power-save state. May also abort transition to the power-save state.</p></li><li><p><code>static int xxx_isa_resume (device_t dev);</code> Resume the device activity after return from power-save state.</p></li></ul></div><div class=paragraph><p><code>xxx_isa_probe()</code> and <code>xxx_isa_attach()</code> are mandatory, the rest of the routines are optional, depending on the device’s needs.</p></div><div class=paragraph><p>The driver is linked to the system with the following set of descriptions.</p></div><div class="literalblock programlisting"><div class=content><pre>    /* table of supported bus methods */
    static device_method_t xxx_isa_methods[] = {
        /* list all the bus method functions supported by the driver */
        /* omit the unsupported methods */
        DEVMETHOD(device_identify,  xxx_isa_identify),
        DEVMETHOD(device_probe,     xxx_isa_probe),
        DEVMETHOD(device_attach,    xxx_isa_attach),
        DEVMETHOD(device_detach,    xxx_isa_detach),
        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),
        DEVMETHOD(device_suspend,   xxx_isa_suspend),
        DEVMETHOD(device_resume,    xxx_isa_resume),

	DEVMETHOD_END
    };

    static driver_t xxx_isa_driver = {
        &#34;xxx&#34;,
        xxx_isa_methods,
        sizeof(struct xxx_softc),
    };

    static devclass_t xxx_devclass;

    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,
        load_function, load_argument);</pre></div></div><div class=paragraph><p>Here struct <code>xxx_softc</code> is a device-specific structure that contains private driver data and descriptors for the driver’s resources. The bus code automatically allocates one softc descriptor per device as needed.</p></div><div class=paragraph><p>If the driver is implemented as a loadable module then <code>load_function()</code> is called to do driver-specific initialization or clean-up when the driver is loaded or unloaded and load_argument is passed as one of its arguments. If the driver does not support dynamic loading (in other words it must always be linked into the kernel) then these values should be set to 0 and the last definition would look like:</p></div><div class="literalblock programlisting"><div class=content><pre> DRIVER_MODULE(xxx, isa, xxx_isa_driver,
       xxx_devclass, 0, 0);</pre></div></div><div class=paragraph><p>If the driver is for a device which supports PnP then a table of supported PnP IDs must be defined. The table consists of a list of PnP IDs supported by this driver and human-readable descriptions of the hardware types and models having these IDs. It looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>    static struct isa_pnp_id xxx_pnp_ids[] = {
        /* a line for each supported PnP ID */
        { 0x12345678,   &#34;Our device model 1234A&#34; },
        { 0x12345679,   &#34;Our device model 1234B&#34; },
        { 0,        NULL }, /* end of table */
    };</pre></div></div><div class=paragraph><p>If the driver does not support PnP devices it still needs an empty PnP ID table, like:</p></div><div class="literalblock programlisting"><div class=content><pre>    static struct isa_pnp_id xxx_pnp_ids[] = {
        { 0,        NULL }, /* end of table */
    };</pre></div></div></div><div class=sect2><h3 id=isa-driver-device-t>10.3. <code>device_t</code> Pointer<a class=anchor href=#isa-driver-device-t></a></h3><div class=paragraph><p><code>device_t</code> is the pointer type for the device structure. Here we consider only the methods interesting from the device driver writer’s standpoint. The methods to manipulate values in the device structure are:</p></div><div class=ulist><ul><li><p><code>device_t device_get_parent(dev)</code> Get the parent bus of a device.</p></li><li><p><code>driver_t device_get_driver(dev)</code> Get pointer to its driver structure.</p></li><li><p><code>char *device_get_name(dev)</code> Get the driver name, such as <code>"xxx"</code> for our example.</p></li><li><p><code>int device_get_unit(dev)</code> Get the unit number (units are numbered from 0 for the devices associated with each driver).</p></li><li><p><code>char *device_get_nameunit(dev)</code> Get the device name including the unit number, such as "xxx0", "xxx1" and so on.</p></li><li><p><code>char *device_get_desc(dev)</code> Get the device description. Normally it describes the exact model of device in human-readable form.</p></li><li><p><code>device_set_desc(dev, desc)</code> Set the description. This makes the device description point to the string desc which may not be deallocated or changed after that.</p></li><li><p><code>device_set_desc_copy(dev, desc)</code> Set the description. The description is copied into an internal dynamically allocated buffer, so the string desc may be changed afterwards without adverse effects.</p></li><li><p><code>void *device_get_softc(dev)</code> Get pointer to the device descriptor (struct <code>xxx_softc</code>) associated with this device.</p></li><li><p><code>u_int32_t device_get_flags(dev)</code> Get the flags specified for the device in the configuration file.</p></li></ul></div><div class=paragraph><p>A convenience function <code>device_printf(dev, fmt, …​)</code> may be used to print the messages from the device driver. It automatically prepends the unitname and colon to the message.</p></div><div class=paragraph><p>The device_t methods are implemented in the file <span class=filename>kern/bus_subr.c</span>.</p></div></div><div class=sect2><h3 id=isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration<a class=anchor href=#isa-driver-config></a></h3><div class=paragraph><p>The ISA devices are described in the kernel configuration file like:</p></div><div class="literalblock programlisting"><div class=content><pre>device xxx0 at isa? port 0x300 irq 10 drq 5
       iomem 0xd0000 flags 0x1 sensitive</pre></div></div><div class=paragraph><p>The values of port, IRQ and so on are converted to the resource values associated with the device. They are optional, depending on the device’s needs and abilities for auto-configuration. For example, some devices do not need DRQ at all and some allow the driver to read the IRQ setting from the device configuration ports. If a machine has multiple ISA buses the exact bus may be specified in the configuration line, like <code>isa0</code> or <code>isa1</code>, otherwise the device would be searched for on all the ISA buses.</p></div><div class=paragraph><p><code>sensitive</code> is a resource requesting that this device must be probed before all non-sensitive devices. It is supported but does not seem to be used in any current driver.</p></div><div class=paragraph><p>For legacy ISA devices in many cases the drivers are still able to detect the configuration parameters. But each device to be configured in the system must have a config line. If two devices of some type are installed in the system but there is only one configuration line for the corresponding driver, ie:</p></div><div class="literalblock programlisting"><div class=content><pre>device xxx0 at isa?</pre></div></div><div class=literalblock><div class=content><pre>then only one device will be configured.</pre></div></div><div class=paragraph><p>But for the devices supporting automatic identification by the means of Plug-n-Play or some proprietary protocol one configuration line is enough to configure all the devices in the system, like the one above or just simply:</p></div><div class="literalblock programlisting"><div class=content><pre>device xxx at isa?</pre></div></div><div class=paragraph><p>If a driver supports both auto-identified and legacy devices and both kinds are installed at once in one machine then it is enough to describe in the config file the legacy devices only. The auto-identified devices will be added automatically.</p></div><div class=paragraph><p>When an ISA bus is auto-configured the events happen as follows:</p></div><div class=paragraph><p>All the drivers' identify routines (including the PnP identify routine which identifies all the PnP devices) are called in random order. As they identify the devices they add them to the list on the ISA bus. Normally the drivers' identify routines associate their drivers with the new devices. The PnP identify routine does not know about the other drivers yet so it does not associate any with the new devices it adds.</p></div><div class=paragraph><p>The PnP devices are put to sleep using the PnP protocol to prevent them from being probed as legacy devices.</p></div><div class=paragraph><p>The probe routines of non-PnP devices marked as <code>sensitive</code> are called. If probe for a device went successfully, the attach routine is called for it.</p></div><div class=paragraph><p>The probe and attach routines of all non-PNP devices are called likewise.</p></div><div class=paragraph><p>The PnP devices are brought back from the sleep state and assigned the resources they request: I/O and memory address ranges, IRQs and DRQs, all of them not conflicting with the attached legacy devices.</p></div><div class=paragraph><p>Then for each PnP device the probe routines of all the present ISA drivers are called. The first one that claims the device gets attached. It is possible that multiple drivers would claim the device with different priority; in this case, the highest-priority driver wins. The probe routines must call <code>ISA_PNP_PROBE()</code> to compare the actual PnP ID with the list of the IDs supported by the driver and if the ID is not in the table return failure. That means that absolutely every driver, even the ones not supporting any PnP devices must call <code>ISA_PNP_PROBE()</code>, at least with an empty PnP ID table to return failure on unknown PnP devices.</p></div><div class=paragraph><p>The probe routine returns a positive value (the error code) on error, zero or negative value on success.</p></div><div class=paragraph><p>The negative return values are used when a PnP device supports multiple interfaces. For example, an older compatibility interface and a newer advanced interface which are supported by different drivers. Then both drivers would detect the device. The driver which returns a higher value in the probe routine takes precedence (in other words, the driver returning 0 has highest precedence, returning -1 is next, returning -2 is after it and so on). In result the devices which support only the old interface will be handled by the old driver (which should return -1 from the probe routine) while the devices supporting the new interface as well will be handled by the new driver (which should return 0 from the probe routine). If multiple drivers return the same value then the one called first wins. So if a driver returns value 0 it may be sure that it won the priority arbitration.</p></div><div class=paragraph><p>The device-specific identify routines can also assign not a driver but a class of drivers to the device. Then all the drivers in the class are probed for this device, like the case with PnP. This feature is not implemented in any existing driver and is not considered further in this document.</p></div><div class=paragraph><p>As the PnP devices are disabled when probing the legacy devices they will not be attached twice (once as legacy and once as PnP). But in case of device-dependent identify routines it is the responsibility of the driver to make sure that the same device will not be attached by the driver twice: once as legacy user-configured and once as auto-identified.</p></div><div class=paragraph><p>Another practical consequence for the auto-identified devices (both PnP and device-specific) is that the flags can not be passed to them from the kernel configuration file. So they must either not use the flags at all or use the flags from the device unit 0 for all the auto-identified devices or use the sysctl interface instead of flags.</p></div><div class=paragraph><p>Other unusual configurations may be accommodated by accessing the configuration resources directly with functions of families <code>resource_query_*()</code> and <code>resource_*_value()</code>. Their implementations are located in <span class=filename>kern/subr_bus.c</span>. The old IDE disk driver <span class=filename>i386/isa/wd.c</span> contains examples of such use. But the standard means of configuration must always be preferred. Leave parsing the configuration resources to the bus configuration code.</p></div></div><div class=sect2><h3 id=isa-driver-resources>10.5. Resources<a class=anchor href=#isa-driver-resources></a></h3><div class=paragraph><p>The information that a user enters into the kernel configuration file is processed and passed to the kernel as configuration resources. This information is parsed by the bus configuration code and transformed into a value of structure device_t and the bus resources associated with it. The drivers may access the configuration resources directly using functions <code>resource_*</code> for more complex cases of configuration. However, generally this is neither needed nor recommended, so this issue is not discussed further here.</p></div><div class=paragraph><p>The bus resources are associated with each device. They are identified by type and number within the type. For the ISA bus the following types are defined:</p></div><div class=ulist><ul><li><p><em>SYS_RES_IRQ</em> - interrupt number</p></li><li><p><em>SYS_RES_DRQ</em> - ISA DMA channel number</p></li><li><p><em>SYS_RES_MEMORY</em> - range of device memory mapped into the system memory space</p></li><li><p><em>SYS_RES_IOPORT</em> - range of device I/O registers</p></li></ul></div><div class=paragraph><p>The enumeration within types starts from 0, so if a device has two memory regions it would have resources of type <code>SYS_RES_MEMORY</code> numbered 0 and 1. The resource type has nothing to do with the C language type, all the resource values have the C language type <code>unsigned long</code> and must be cast as necessary. The resource numbers do not have to be contiguous, although for ISA they normally would be. The permitted resource numbers for ISA devices are:</p></div><div class="literalblock programlisting"><div class=content><pre>          IRQ: 0-1
          DRQ: 0-1
          MEMORY: 0-3
          IOPORT: 0-7</pre></div></div><div class=paragraph><p>All the resources are represented as ranges, with a start value and count. For IRQ and DRQ resources the count would normally be equal to 1. The values for memory refer to the physical addresses.</p></div><div class=paragraph><p>Three types of activities can be performed on resources:</p></div><div class=ulist><ul><li><p>set/get</p></li><li><p>allocate/release</p></li><li><p>activate/deactivate</p></li></ul></div><div class=paragraph><p>Setting sets the range used by the resource. Allocation reserves the requested range that no other driver would be able to reserve it (and checking that no other driver reserved this range already). Activation makes the resource accessible to the driver by doing whatever is necessary for that (for example, for memory it would be mapping into the kernel virtual address space).</p></div><div class=paragraph><p>The functions to manipulate resources are:</p></div><div class=ulist><ul><li><p><code>int bus_set_resource(device_t dev, int type, int rid, u_long start, u_long count)</code></p><div class=paragraph><p>Set a range for a resource. Returns 0 if successful, error code otherwise. Normally, this function will return an error only if one of <code>type</code>, <code>rid</code>, <code>start</code> or <code>count</code> has a value that falls out of the permitted range.</p></div><div class=ulist><ul><li><p>dev - driver’s device</p></li><li><p>type - type of resource, SYS_RES_*</p></li><li><p>rid - resource number (ID) within type</p></li><li><p>start, count - resource range</p></li></ul></div></li><li><p><code>int bus_get_resource(device_t dev, int type, int rid, u_long *startp, u_long *countp)</code></p><div class=paragraph><p>Get the range of resource. Returns 0 if successful, error code if the resource is not defined yet.</p></div></li><li><p><code>u_long bus_get_resource_start(device_t dev, int type, int rid) u_long bus_get_resource_count (device_t dev, int type, int rid)</code></p><div class=paragraph><p>Convenience functions to get only the start or count. Return 0 in case of error, so if the resource start has 0 among the legitimate values it would be impossible to tell if the value is 0 or an error occurred. Luckily, no ISA resources for add-on drivers may have a start value equal to 0.</p></div></li><li><p><code>void bus_delete_resource(device_t dev, int type, int rid)</code></p><div class=paragraph><p>Delete a resource, make it undefined.</p></div></li><li><p><code>struct resource * bus_alloc_resource(device_t dev, int type, int *rid, u_long start, u_long end, u_long count, u_int flags)</code></p><div class=paragraph><p>Allocate a resource as a range of count values not allocated by anyone else, somewhere between start and end. Alas, alignment is not supported. If the resource was not set yet it is automatically created. The special values of start 0 and end ~0 (all ones) means that the fixed values previously set by <code>bus_set_resource()</code> must be used instead: start and count as themselves and end=(start+count), in this case if the resource was not defined before then an error is returned. Although rid is passed by reference it is not set anywhere by the resource allocation code of the ISA bus. (The other buses may use a different approach and modify it).</p></div></li></ul></div><div class=paragraph><p>Flags are a bitmap, the flags interesting for the caller are:</p></div><div class=ulist><ul><li><p><em>RF_ACTIVE</em> - causes the resource to be automatically activated after allocation.</p></li><li><p><em>RF_SHAREABLE</em> - resource may be shared at the same time by multiple drivers.</p></li><li><p><em>RF_TIMESHARE</em> - resource may be time-shared by multiple drivers, i.e., allocated at the same time by many but activated only by one at any given moment of time.</p></li><li><p>Returns 0 on error. The allocated values may be obtained from the returned handle using methods <code>rhand_*()</code>.</p></li><li><p><code>int bus_release_resource(device_t dev, int type, int rid, struct resource *r)</code></p></li><li><p>Release the resource, r is the handle returned by <code>bus_alloc_resource()</code>. Returns 0 on success, error code otherwise.</p></li><li><p><code>int bus_activate_resource(device_t dev, int type, int rid, struct resource *r) int bus_deactivate_resource(device_t dev, int type, int rid, struct resource *r)</code></p></li><li><p>Activate or deactivate resource. Return 0 on success, error code otherwise. If the resource is time-shared and currently activated by another driver then <code>EBUSY</code> is returned.</p></li><li><p><code>int bus_setup_intr(device_t dev, struct resource *r, int flags, driver_intr_t *handler, void *arg, void **cookiep) int bus_teardown_intr(device_t dev, struct resource *r, void *cookie)</code></p></li><li><p>Associate or de-associate the interrupt handler with a device. Return 0 on success, error code otherwise.</p></li><li><p>r - the activated resource handler describing the IRQ</p><div class=paragraph><p>flags - the interrupt priority level, one of:</p></div><div class=ulist><ul><li><p><code>INTR_TYPE_TTY</code> - terminals and other likewise character-type devices. To mask them use <code>spltty()</code>.</p></li><li><p><code>(INTR_TYPE_TTY | INTR_TYPE_FAST)</code> - terminal type devices with small input buffer, critical to the data loss on input (such as the old-fashioned serial ports). To mask them use <code>spltty()</code>.</p></li><li><p><code>INTR_TYPE_BIO</code> - block-type devices, except those on the CAM controllers. To mask them use <code>splbio()</code>.</p></li><li><p><code>INTR_TYPE_CAM</code> - CAM (Common Access Method) bus controllers. To mask them use <code>splcam()</code>.</p></li><li><p><code>INTR_TYPE_NET</code> - network interface controllers. To mask them use <code>splimp()</code>.</p></li><li><p><code>INTR_TYPE_MISC</code> - miscellaneous devices. There is no other way to mask them than by <code>splhigh()</code> which masks all interrupts.</p></li></ul></div></li></ul></div><div class=paragraph><p>When an interrupt handler executes all the other interrupts matching its priority level will be masked. The only exception is the MISC level for which no other interrupts are masked and which is not masked by any other interrupt.</p></div><div class=ulist><ul><li><p><em>handler</em> - pointer to the handler function, the type driver_intr_t is defined as <code>void driver_intr_t(void *)</code></p></li><li><p><em>arg</em> - the argument passed to the handler to identify this particular device. It is cast from void* to any real type by the handler. The old convention for the ISA interrupt handlers was to use the unit number as argument, the new (recommended) convention is using a pointer to the device softc structure.</p></li><li><p><em>cookie[p]</em> - the value received from <code>setup()</code> is used to identify the handler when passed to <code>teardown()</code></p></li></ul></div><div class=paragraph><p>A number of methods are defined to operate on the resource handlers (struct resource *). Those of interest to the device driver writers are:</p></div><div class=ulist><ul><li><p><code>u_long rman_get_start(r) u_long rman_get_end(r)</code> Get the start and end of allocated resource range.</p></li><li><p><code>void *rman_get_virtual(r)</code> Get the virtual address of activated memory resource.</p></li></ul></div></div><div class=sect2><h3 id=isa-driver-busmem>10.6. Bus Memory Mapping<a class=anchor href=#isa-driver-busmem></a></h3><div class=paragraph><p>In many cases data is exchanged between the driver and the device through the memory. Two variants are possible:</p></div><div class=paragraph><p>(a) memory is located on the device card</p></div><div class=paragraph><p>(b) memory is the main memory of the computer</p></div><div class=paragraph><p>In case (a) the driver always copies the data back and forth between the on-card memory and the main memory as necessary. To map the on-card memory into the kernel virtual address space the physical address and length of the on-card memory must be defined as a <code>SYS_RES_MEMORY</code> resource. That resource can then be allocated and activated, and its virtual address obtained using <code>rman_get_virtual()</code>. The older drivers used the function <code>pmap_mapdev()</code> for this purpose, which should not be used directly any more. Now it is one of the internal steps of resource activation.</p></div><div class=paragraph><p>Most of the ISA cards will have their memory configured for physical location somewhere in range 640KB-1MB. Some of the ISA cards require larger memory ranges which should be placed somewhere under 16MB (because of the 24-bit address limitation on the ISA bus). In that case if the machine has more memory than the start address of the device memory (in other words, they overlap) a memory hole must be configured at the address range used by devices. Many BIOSes allow configuration of a memory hole of 1MB starting at 14MB or 15MB. FreeBSD can handle the memory holes properly if the BIOS reports them properly (this feature may be broken on old BIOSes).</p></div><div class=paragraph><p>In case (b) just the address of the data is sent to the device, and the device uses DMA to actually access the data in the main memory. Two limitations are present: First, ISA cards can only access memory below 16MB. Second, the contiguous pages in virtual address space may not be contiguous in physical address space, so the device may have to do scatter/gather operations. The bus subsystem provides ready solutions for some of these problems, the rest has to be done by the drivers themselves.</p></div><div class=paragraph><p>Two structures are used for DMA memory allocation, <code>bus_dma_tag_t</code> and <code>bus_dmamap_t</code>. Tag describes the properties required for the DMA memory. Map represents a memory block allocated according to these properties. Multiple maps may be associated with the same tag.</p></div><div class=paragraph><p>Tags are organized into a tree-like hierarchy with inheritance of the properties. A child tag inherits all the requirements of its parent tag, and may make them more strict but never more loose.</p></div><div class=paragraph><p>Normally one top-level tag (with no parent) is created for each device unit. If multiple memory areas with different requirements are needed for each device then a tag for each of them may be created as a child of the parent tag.</p></div><div class=paragraph><p>The tags can be used to create a map in two ways.</p></div><div class=paragraph><p>First, a chunk of contiguous memory conformant with the tag requirements may be allocated (and later may be freed). This is normally used to allocate relatively long-living areas of memory for communication with the device. Loading of such memory into a map is trivial: it is always considered as one chunk in the appropriate physical memory range.</p></div><div class=paragraph><p>Second, an arbitrary area of virtual memory may be loaded into a map. Each page of this memory will be checked for conformance to the map requirement. If it conforms then it is left at its original location. If it is not then a fresh conformant "bounce page" is allocated and used as intermediate storage. When writing the data from the non-conformant original pages they will be copied to their bounce pages first and then transferred from the bounce pages to the device. When reading the data would go from the device to the bounce pages and then copied to their non-conformant original pages. The process of copying between the original and bounce pages is called synchronization. This is normally used on a per-transfer basis: buffer for each transfer would be loaded, transfer done and buffer unloaded.</p></div><div class=paragraph><p>The functions working on the DMA memory are:</p></div><div class=ulist><ul><li><p><code>int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)</code></p><div class=paragraph><p>Create a new tag. Returns 0 on success, the error code otherwise.</p></div><div class=ulist><ul><li><p><em>parent</em> - parent tag, or NULL to create a top-level tag.</p></li><li><p><em>alignment</em> - required physical alignment of the memory area to be allocated for this tag. Use value 1 for "no specific alignment". Applies only to the future <code>bus_dmamem_alloc()</code> but not <code>bus_dmamap_create()</code> calls.</p></li><li><p><em>boundary</em> - physical address boundary that must not be crossed when allocating the memory. Use value 0 for "no boundary". Applies only to the future <code>bus_dmamem_alloc()</code> but not <code>bus_dmamap_create()</code> calls. Must be power of 2. If the memory is planned to be used in non-cascaded DMA mode (i.e., the DMA addresses will be supplied not by the device itself but by the ISA DMA controller) then the boundary must be no larger than 64KB (64*1024) due to the limitations of the DMA hardware.</p></li><li><p><em>lowaddr, highaddr</em> - the names are slightly misleading; these values are used to limit the permitted range of physical addresses used to allocate the memory. The exact meaning varies depending on the planned future use:</p><div class=ulist><ul><li><p>For <code>bus_dmamem_alloc()</code> all the addresses from 0 to lowaddr-1 are considered permitted, the higher ones are forbidden.</p></li><li><p>For <code>bus_dmamap_create()</code> all the addresses outside the inclusive range [lowaddr; highaddr] are considered accessible. The addresses of pages inside the range are passed to the filter function which decides if they are accessible. If no filter function is supplied then all the range is considered unaccessible.</p></li><li><p>For the ISA devices the normal values (with no filter function) are:</p><div class=paragraph><p>lowaddr = BUS_SPACE_MAXADDR_24BIT</p></div><div class=paragraph><p>highaddr = BUS_SPACE_MAXADDR</p></div></li></ul></div></li><li><p><em>filter, filterarg</em> - the filter function and its argument. If NULL is passed for filter then the whole range [lowaddr, highaddr] is considered unaccessible when doing <code>bus_dmamap_create()</code>. Otherwise the physical address of each attempted page in range [lowaddr; highaddr] is passed to the filter function which decides if it is accessible. The prototype of the filter function is: <code>int filterfunc(void *arg, bus_addr_t paddr)</code>. It must return 0 if the page is accessible, non-zero otherwise.</p></li><li><p><em>maxsize</em> - the maximal size of memory (in bytes) that may be allocated through this tag. In case it is difficult to estimate or could be arbitrarily big, the value for ISA devices would be <code>BUS_SPACE_MAXSIZE_24BIT</code>.</p></li><li><p><em>nsegments</em> - maximal number of scatter-gather segments supported by the device. If unrestricted then the value <code>BUS_SPACE_UNRESTRICTED</code> should be used. This value is recommended for the parent tags, the actual restrictions would then be specified for the descendant tags. Tags with nsegments equal to <code>BUS_SPACE_UNRESTRICTED</code> may not be used to actually load maps, they may be used only as parent tags. The practical limit for nsegments seems to be about 250-300, higher values will cause kernel stack overflow (the hardware can not normally support that many scatter-gather buffers anyway).</p></li><li><p><em>maxsegsz</em> - maximal size of a scatter-gather segment supported by the device. The maximal value for ISA device would be <code>BUS_SPACE_MAXSIZE_24BIT</code>.</p></li><li><p><em>flags</em> - a bitmap of flags. The only interesting flag is:</p><div class=ulist><ul><li><p><em>BUS_DMA_ALLOCNOW</em> - requests to allocate all the potentially needed bounce pages when creating the tag.</p></li></ul></div></li><li><p><em>dmat</em> - pointer to the storage for the new tag to be returned.</p></li></ul></div></li><li><p><code>int bus_dma_tag_destroy(bus_dma_tag_t dmat)</code></p><div class=paragraph><p>Destroy a tag. Returns 0 on success, the error code otherwise.</p></div><div class=paragraph><p>dmat - the tag to be destroyed.</p></div></li><li><p><code>int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, bus_dmamap_t *mapp)</code></p><div class=paragraph><p>Allocate an area of contiguous memory described by the tag. The size of memory to be allocated is tag’s maxsize. Returns 0 on success, the error code otherwise. The result still has to be loaded by <code>bus_dmamap_load()</code> before being used to get the physical address of the memory.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>vaddr</em> - pointer to the storage for the kernel virtual address of the allocated area to be returned.</p></li><li><p>flags - a bitmap of flags. The only interesting flag is:</p><div class=ulist><ul><li><p><em>BUS_DMA_NOWAIT</em> - if the memory is not immediately available return the error. If this flag is not set then the routine is allowed to sleep until the memory becomes available.</p></li></ul></div></li><li><p><em>mapp</em> - pointer to the storage for the new map to be returned.</p></li></ul></div></li><li><p><code>void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map)</code></p><div class=paragraph><p>Free the memory allocated by <code>bus_dmamem_alloc()</code>. At present, freeing of the memory allocated with ISA restrictions is not implemented. Due to this the recommended model of use is to keep and re-use the allocated areas for as long as possible. Do not lightly free some area and then shortly allocate it again. That does not mean that <code>bus_dmamem_free()</code> should not be used at all: hopefully it will be properly implemented soon.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>vaddr</em> - the kernel virtual address of the memory</p></li><li><p><em>map</em> - the map of the memory (as returned from <code>bus_dmamem_alloc()</code>)</p></li></ul></div></li><li><p><code>int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp)</code></p><div class=paragraph><p>Create a map for the tag, to be used in <code>bus_dmamap_load()</code> later. Returns 0 on success, the error code otherwise.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>flags</em> - theoretically, a bit map of flags. But no flags are defined yet, so at present it will be always 0.</p></li><li><p><em>mapp</em> - pointer to the storage for the new map to be returned</p></li></ul></div></li><li><p><code>int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</code></p><div class=paragraph><p>Destroy a map. Returns 0 on success, the error code otherwise.</p></div><div class=ulist><ul><li><p>dmat - the tag to which the map is associated</p></li><li><p>map - the map to be destroyed</p></li></ul></div></li><li><p><code>int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf, bus_size_t buflen, bus_dmamap_callback_t *callback, void *callback_arg, int flags)</code></p><div class=paragraph><p>Load a buffer into the map (the map must be previously created by <code>bus_dmamap_create()</code> or <code>bus_dmamem_alloc()</code>). All the pages of the buffer are checked for conformance to the tag requirements and for those not conformant the bounce pages are allocated. An array of physical segment descriptors is built and passed to the callback routine. This callback routine is then expected to handle it in some way. The number of bounce buffers in the system is limited, so if the bounce buffers are needed but not immediately available the request will be queued and the callback will be called when the bounce buffers will become available. Returns 0 if the callback was executed immediately or <code>EINPROGRESS</code> if the request was queued for future execution. In the latter case the synchronization with queued callback routine is the responsibility of the driver.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>map</em> - the map</p></li><li><p><em>buf</em> - kernel virtual address of the buffer</p></li><li><p><em>buflen</em> - length of the buffer</p></li><li><p><em>callback</em>, <code>callback_arg</code> - the callback function and its argument</p><div class=paragraph><p>The prototype of callback function is: <code>void callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)</code></p></div></li><li><p><em>arg</em> - the same as callback_arg passed to <code>bus_dmamap_load()</code></p></li><li><p><em>seg</em> - array of the segment descriptors</p></li><li><p><em>nseg</em> - number of descriptors in array</p></li><li><p><em>error</em> - indication of the segment number overflow: if it is set to <code>EFBIG</code> then the buffer did not fit into the maximal number of segments permitted by the tag. In this case only the permitted number of descriptors will be in the array. Handling of this situation is up to the driver: depending on the desired semantics it can either consider this an error or split the buffer in two and handle the second part separately</p><div class=paragraph><p>Each entry in the segments array contains the fields:</p></div></li><li><p><em>ds_addr</em> - physical bus address of the segment</p></li><li><p><em>ds_len</em> - length of the segment</p></li></ul></div></li><li><p><code>void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</code></p><div class=paragraph><p>unload the map.</p></div><div class=ulist><ul><li><p><em>dmat</em> - tag</p></li><li><p><em>map</em> - loaded map</p></li></ul></div></li><li><p><code>void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, bus_dmasync_op_t op)</code></p><div class=paragraph><p>Synchronise a loaded buffer with its bounce pages before and after physical transfer to or from device. This is the function that does all the necessary copying of data between the original buffer and its mapped version. The buffers must be synchronized both before and after doing the transfer.</p></div><div class=ulist><ul><li><p><em>dmat</em> - tag</p></li><li><p><em>map</em> - loaded map</p></li><li><p><em>op</em> - type of synchronization operation to perform:</p></li><li><p><code>BUS_DMASYNC_PREREAD</code> - before reading from device into buffer</p></li><li><p><code>BUS_DMASYNC_POSTREAD</code> - after reading from device into buffer</p></li><li><p><code>BUS_DMASYNC_PREWRITE</code> - before writing the buffer to device</p></li><li><p><code>BUS_DMASYNC_POSTWRITE</code> - after writing the buffer to device</p></li></ul></div></li></ul></div><div class=paragraph><p>As of now PREREAD and POSTWRITE are null operations but that may change in the future, so they must not be ignored in the driver. Synchronization is not needed for the memory obtained from <code>bus_dmamem_alloc()</code>.</p></div><div class=paragraph><p>Before calling the callback function from <code>bus_dmamap_load()</code> the segment array is stored in the stack. And it gets pre-allocated for the maximal number of segments allowed by the tag. As a result of this the practical limit for the number of segments on i386 architecture is about 250-300 (the kernel stack is 4KB minus the size of the user structure, size of a segment array entry is 8 bytes, and some space must be left). Since the array is allocated based on the maximal number this value must not be set higher than really needed. Fortunately, for most of hardware the maximal supported number of segments is much lower. But if the driver wants to handle buffers with a very large number of scatter-gather segments it should do that in portions: load part of the buffer, transfer it to the device, load next part of the buffer, and so on.</p></div><div class=paragraph><p>Another practical consequence is that the number of segments may limit the size of the buffer. If all the pages in the buffer happen to be physically non-contiguous then the maximal supported buffer size for that fragmented case would be (nsegments * page_size). For example, if a maximal number of 10 segments is supported then on i386 maximal guaranteed supported buffer size would be 40K. If a higher size is desired then special tricks should be used in the driver.</p></div><div class=paragraph><p>If the hardware does not support scatter-gather at all or the driver wants to support some buffer size even if it is heavily fragmented then the solution is to allocate a contiguous buffer in the driver and use it as intermediate storage if the original buffer does not fit.</p></div><div class=paragraph><p>Below are the typical call sequences when using a map depend on the use of the map. The characters → are used to show the flow of time.</p></div><div class=paragraph><p>For a buffer which stays practically fixed during all the time between attachment and detachment of a device:</p></div><div class=paragraph><p>bus_dmamem_alloc → bus_dmamap_load → …​use buffer…​ → → bus_dmamap_unload → bus_dmamem_free</p></div><div class=paragraph><p>For a buffer that changes frequently and is passed from outside the driver:</p></div><div class="literalblock programlisting"><div class=content><pre>          bus_dmamap_create -&gt;
          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;
          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;
          ...
          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;
          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;
          -&gt; bus_dmamap_destroy</pre></div></div><div class=paragraph><p>When loading a map created by <code>bus_dmamem_alloc()</code> the passed address and size of the buffer must be the same as used in <code>bus_dmamem_alloc()</code>. In this case it is guaranteed that the whole buffer will be mapped as one segment (so the callback may be based on this assumption) and the request will be executed immediately (EINPROGRESS will never be returned). All the callback needs to do in this case is to save the physical address.</p></div><div class=paragraph><p>A typical example would be:</p></div><div class="literalblock programlisting"><div class=content><pre>          static void
        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)
        {
          *(bus_addr_t *)arg = seg[0].ds_addr;
        }

          ...
          int error;
          struct somedata {
            ....
          };
          struct somedata *vsomedata; /* virtual address */
          bus_addr_t psomedata; /* physical bus-relative address */
          bus_dma_tag_t tag_somedata;
          bus_dmamap_t map_somedata;
          ...

          error=bus_dma_tag_create(parent_tag, alignment,
           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,
           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,
           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,
           &amp;tag_somedata);
          if(error)
          return error;

          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ 0,
             &amp;map_somedata);
          if(error)
             return error;

          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,
             sizeof (struct somedata), alloc_callback,
             (void *) &amp;psomedata, /*flags*/0);</pre></div></div><div class=paragraph><p>Looks a bit long and complicated but that is the way to do it. The practical consequence is: if multiple memory areas are allocated always together it would be a really good idea to combine them all into one structure and allocate as one (if the alignment and boundary limitations permit).</p></div><div class=paragraph><p>When loading an arbitrary buffer into the map created by <code>bus_dmamap_create()</code> special measures must be taken to synchronize with the callback in case it would be delayed. The code would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>          {
           int s;
           int error;

           s = splsoftvm();
           error = bus_dmamap_load(
               dmat,
               dmamap,
               buffer_ptr,
               buffer_len,
               callback,
               /*callback_arg*/ buffer_descriptor,
               /*flags*/0);
           if (error == EINPROGRESS) {
               /*
                * Do whatever is needed to ensure synchronization
                * with callback. Callback is guaranteed not to be started
                * until we do splx() or tsleep().
                */
              }
           splx(s);
          }</pre></div></div><div class=paragraph><p>Two possible approaches for the processing of requests are:</p></div><div class="olist arabic"><ol class=arabic><li><p>If requests are completed by marking them explicitly as done (such as the CAM requests) then it would be simpler to put all the further processing into the callback driver which would mark the request when it is done. Then not much extra synchronization is needed. For the flow control reasons it may be a good idea to freeze the request queue until this request gets completed.</p></li><li><p>If requests are completed when the function returns (such as classic read or write requests on character devices) then a synchronization flag should be set in the buffer descriptor and <code>tsleep()</code> called. Later when the callback gets called it will do its processing and check this synchronization flag. If it is set then the callback should issue a wakeup. In this approach the callback function could either do all the needed processing (just like the previous case) or simply save the segments array in the buffer descriptor. Then after callback completes the calling function could use this saved segments array and do all the processing.</p></li></ol></div></div><div class=sect2><h3 id=isa-driver-dma>10.7. DMA<a class=anchor href=#isa-driver-dma></a></h3><div class=paragraph><p>The Direct Memory Access (DMA) is implemented in the ISA bus through the DMA controller (actually, two of them but that is an irrelevant detail). To make the early ISA devices simple and cheap the logic of the bus control and address generation was concentrated in the DMA controller. Fortunately, FreeBSD provides a set of functions that mostly hide the annoying details of the DMA controller from the device drivers.</p></div><div class=paragraph><p>The simplest case is for the fairly intelligent devices. Like the bus master devices on PCI they can generate the bus cycles and memory addresses all by themselves. The only thing they really need from the DMA controller is bus arbitration. So for this purpose they pretend to be cascaded slave DMA controllers. And the only thing needed from the system DMA controller is to enable the cascaded mode on a DMA channel by calling the following function when attaching the driver:</p></div><div class=paragraph><p><code>void isa_dmacascade(int channel_number)</code></p></div><div class=paragraph><p>All the further activity is done by programming the device. When detaching the driver no DMA-related functions need to be called.</p></div><div class=paragraph><p>For the simpler devices things get more complicated. The functions used are:</p></div><div class=ulist><ul><li><p><code>int isa_dma_acquire(int chanel_number)</code></p><div class=paragraph><p>Reserve a DMA channel. Returns 0 on success or EBUSY if the channel was already reserved by this or a different driver. Most of the ISA devices are not able to share DMA channels anyway, so normally this function is called when attaching a device. This reservation was made redundant by the modern interface of bus resources but still must be used in addition to the latter. If not used then later, other DMA routines will panic.</p></div></li><li><p><code>int isa_dma_release(int chanel_number)</code></p><div class=paragraph><p>Release a previously reserved DMA channel. No transfers must be in progress when the channel is released (in addition the device must not try to initiate transfer after the channel is released).</p></div></li><li><p><code>void isa_dmainit(int chan, u_int bouncebufsize)</code></p><div class=paragraph><p>Allocate a bounce buffer for use with the specified channel. The requested size of the buffer can not exceed 64KB. This bounce buffer will be automatically used later if a transfer buffer happens to be not physically contiguous or outside of the memory accessible by the ISA bus or crossing the 64KB boundary. If the transfers will be always done from buffers which conform to these conditions (such as those allocated by <code>bus_dmamem_alloc()</code> with proper limitations) then <code>isa_dmainit()</code> does not have to be called. But it is quite convenient to transfer arbitrary data using the DMA controller. The bounce buffer will automatically care of the scatter-gather issues.</p></div><div class=ulist><ul><li><p><em>chan</em> - channel number</p></li><li><p><em>bouncebufsize</em> - size of the bounce buffer in bytes</p></li></ul></div></li><li><p><code>void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int chan)</code></p><div class=paragraph><p>Prepare to start a DMA transfer. This function must be called to set up the DMA controller before actually starting transfer on the device. It checks that the buffer is contiguous and falls into the ISA memory range, if not then the bounce buffer is automatically used. If bounce buffer is required but not set up by <code>isa_dmainit()</code> or too small for the requested transfer size then the system will panic. In case of a write request with bounce buffer the data will be automatically copied to the bounce buffer.</p></div></li><li><p>flags - a bitmask determining the type of operation to be done. The direction bits B_READ and B_WRITE are mutually exclusive.</p><div class=ulist><ul><li><p>B_READ - read from the ISA bus into memory</p></li><li><p>B_WRITE - write from the memory to the ISA bus</p></li><li><p>B_RAW - if set then the DMA controller will remember the buffer and after the end of transfer will automatically re-initialize itself to repeat transfer of the same buffer again (of course, the driver may change the data in the buffer before initiating another transfer in the device). If not set then the parameters will work only for one transfer, and <code>isa_dmastart()</code> will have to be called again before initiating the next transfer. Using B_RAW makes sense only if the bounce buffer is not used.</p></li></ul></div></li><li><p>addr - virtual address of the buffer</p></li><li><p>nbytes - length of the buffer. Must be less or equal to 64KB. Length of 0 is not allowed: the DMA controller will understand it as 64KB while the kernel code will understand it as 0 and that would cause unpredictable effects. For channels number 4 and higher the length must be even because these channels transfer 2 bytes at a time. In case of an odd length the last byte will not be transferred.</p></li><li><p>chan - channel number</p></li><li><p><code>void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)</code></p><div class=paragraph><p>Synchronize the memory after device reports that transfer is done. If that was a read operation with a bounce buffer then the data will be copied from the bounce buffer to the original buffer. Arguments are the same as for <code>isa_dmastart()</code>. Flag B_RAW is permitted but it does not affect <code>isa_dmadone()</code> in any way.</p></div></li><li><p><code>int isa_dmastatus(int channel_number)</code></p><div class=paragraph><p>Returns the number of bytes left in the current transfer to be transferred. In case the flag B_READ was set in <code>isa_dmastart()</code> the number returned will never be equal to zero. At the end of transfer it will be automatically reset back to the length of buffer. The normal use is to check the number of bytes left after the device signals that the transfer is completed. If the number of bytes is not 0 then something probably went wrong with that transfer.</p></div></li><li><p><code>int isa_dmastop(int channel_number)</code></p><div class=paragraph><p>Aborts the current transfer and returns the number of bytes left untransferred.</p></div></li></ul></div></div><div class=sect2><h3 id=isa-driver-probe>10.8. xxx_isa_probe<a class=anchor href=#isa-driver-probe></a></h3><div class=paragraph><p>This function probes if a device is present. If the driver supports auto-detection of some part of device configuration (such as interrupt vector or memory address) this auto-detection must be done in this routine.</p></div><div class=paragraph><p>As for any other bus, if the device cannot be detected or is detected but failed the self-test or some other problem happened then it returns a positive value of error. The value <code>ENXIO</code> must be returned if the device is not present. Other error values may mean other conditions. Zero or negative values mean success. Most of the drivers return zero as success.</p></div><div class=paragraph><p>The negative return values are used when a PnP device supports multiple interfaces. For example, an older compatibility interface and a newer advanced interface which are supported by different drivers. Then both drivers would detect the device. The driver which returns a higher value in the probe routine takes precedence (in other words, the driver returning 0 has highest precedence, one returning -1 is next, one returning -2 is after it and so on). In result the devices which support only the old interface will be handled by the old driver (which should return -1 from the probe routine) while the devices supporting the new interface as well will be handled by the new driver (which should return 0 from the probe routine).</p></div><div class=paragraph><p>The device descriptor struct xxx_softc is allocated by the system before calling the probe routine. If the probe routine returns an error the descriptor will be automatically deallocated by the system. So if a probing error occurs the driver must make sure that all the resources it used during probe are deallocated and that nothing keeps the descriptor from being safely deallocated. If the probe completes successfully the descriptor will be preserved by the system and later passed to the routine <code>xxx_isa_attach()</code>. If a driver returns a negative value it can not be sure that it will have the highest priority and its attach routine will be called. So in this case it also must release all the resources before returning and if necessary allocate them again in the attach routine. When <code>xxx_isa_probe()</code> returns 0 releasing the resources before returning is also a good idea and a well-behaved driver should do so. But in cases where there is some problem with releasing the resources the driver is allowed to keep resources between returning 0 from the probe routine and execution of the attach routine.</p></div><div class=paragraph><p>A typical probe routine starts with getting the device descriptor and unit:</p></div><div class="literalblock programlisting"><div class=content><pre>         struct xxx_softc *sc = device_get_softc(dev);
          int unit = device_get_unit(dev);
          int pnperror;
          int error = 0;

          sc-&gt;dev = dev; /* link it back */
          sc-&gt;unit = unit;</pre></div></div><div class=paragraph><p>Then check for the PnP devices. The check is carried out by a table containing the list of PnP IDs supported by this driver and human-readable descriptions of the device models corresponding to these IDs.</p></div><div class="literalblock programlisting"><div class=content><pre>        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,
        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;</pre></div></div><div class=paragraph><p>The logic of ISA_PNP_PROBE is the following: If this card (device unit) was not detected as PnP then ENOENT will be returned. If it was detected as PnP but its detected ID does not match any of the IDs in the table then ENXIO is returned. Finally, if it has PnP support and it matches on of the IDs in the table, 0 is returned and the appropriate description from the table is set by <code>device_set_desc()</code>.</p></div><div class=paragraph><p>If a driver supports only PnP devices then the condition would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>          if(pnperror != 0)
              return pnperror;</pre></div></div><div class=paragraph><p>No special treatment is required for the drivers which do not support PnP because they pass an empty PnP ID table and will always get ENXIO if called on a PnP card.</p></div><div class=paragraph><p>The probe routine normally needs at least some minimal set of resources, such as I/O port number to find the card and probe it. Depending on the hardware the driver may be able to discover the other necessary resources automatically. The PnP devices have all the resources pre-set by the PnP subsystem, so the driver does not need to discover them by itself.</p></div><div class=paragraph><p>Typically the minimal information required to get access to the device is the I/O port number. Then some devices allow to get the rest of information from the device configuration registers (though not all devices do that). So first we try to get the port start value:</p></div><div class="literalblock programlisting"><div class=content><pre> sc-&gt;port0 = bus_get_resource_start(dev,
        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;</pre></div></div><div class=paragraph><p>The base port address is saved in the structure softc for future use. If it will be used very often then calling the resource function each time would be prohibitively slow. If we do not get a port we just return an error. Some device drivers can instead be clever and try to probe all the possible ports, like this:</p></div><div class="literalblock programlisting"><div class=content><pre>          /* table of all possible base I/O port addresses for this device */
          static struct xxx_allports {
              u_short port; /* port address */
              short used; /* flag: if this port is already used by some unit */
          } xxx_allports = {
              { 0x300, 0 },
              { 0x320, 0 },
              { 0x340, 0 },
              { 0, 0 } /* end of table */
          };

          ...
          int port, i;
          ...

          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);
          if(port !=0 ) {
              for(i=0; xxx_allports[i].port!=0; i++) {
                  if(xxx_allports[i].used || xxx_allports[i].port != port)
                      continue;

                  /* found it */
                  xxx_allports[i].used = 1;
                  /* do probe on a known port */
                  return xxx_really_probe(dev, port);
              }
              return ENXIO; /* port is unknown or already used */
          }

          /* we get here only if we need to guess the port */
          for(i=0; xxx_allports[i].port!=0; i++) {
              if(xxx_allports[i].used)
                  continue;

              /* mark as used - even if we find nothing at this port
               * at least we won&#39;t probe it in future
               */
               xxx_allports[i].used = 1;

              error = xxx_really_probe(dev, xxx_allports[i].port);
              if(error == 0) /* found a device at that port */
                  return 0;
          }
          /* probed all possible addresses, none worked */
          return ENXIO;</pre></div></div><div class=paragraph><p>Of course, normally the driver’s <code>identify()</code> routine should be used for such things. But there may be one valid reason why it may be better to be done in <code>probe()</code>: if this probe would drive some other sensitive device crazy. The probe routines are ordered with consideration of the <code>sensitive</code> flag: the sensitive devices get probed first and the rest of the devices later. But the <code>identify()</code> routines are called before any probes, so they show no respect to the sensitive devices and may upset them.</p></div><div class=paragraph><p>Now, after we got the starting port we need to set the port count (except for PnP devices) because the kernel does not have this information in the configuration file.</p></div><div class="literalblock programlisting"><div class=content><pre>         if(pnperror /* only for non-PnP devices */
         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,
         XXX_PORT_COUNT)&lt;0)
             return ENXIO;</pre></div></div><div class=paragraph><p>Finally allocate and activate a piece of port address space (special values of start and end mean "use those we set by <code>bus_set_resource()</code>"):</p></div><div class="literalblock programlisting"><div class=content><pre>          sc-&gt;port0_rid = 0;
          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,
          &amp;sc-&gt;port0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;port0_r == NULL)
              return ENXIO;</pre></div></div><div class=paragraph><p>Now having access to the port-mapped registers we can poke the device in some way and check if it reacts like it is expected to. If it does not then there is probably some other device or no device at all at this address.</p></div><div class=paragraph><p>Normally drivers do not set up the interrupt handlers until the attach routine. Instead they do probes in the polling mode using the <code>DELAY()</code> function for timeout. The probe routine must never hang forever, all the waits for the device must be done with timeouts. If the device does not respond within the time it is probably broken or misconfigured and the driver must return error. When determining the timeout interval give the device some extra time to be on the safe side: although <code>DELAY()</code> is supposed to delay for the same amount of time on any machine it has some margin of error, depending on the exact CPU.</p></div><div class=paragraph><p>If the probe routine really wants to check that the interrupts really work it may configure and probe the interrupts too. But that is not recommended.</p></div><div class="literalblock programlisting"><div class=content><pre>          /* implemented in some very device-specific way */
          if(error = xxx_probe_ports(sc))
              goto bad; /* will deallocate the resources before returning */</pre></div></div><div class=paragraph><p>The function <code>xxx_probe_ports()</code> may also set the device description depending on the exact model of device it discovers. But if there is only one supported device model this can be as well done in a hardcoded way. Of course, for the PnP devices the PnP support sets the description from the table automatically.</p></div><div class="literalblock programlisting"><div class=content><pre>          if(pnperror)
              device_set_desc(dev, &#34;Our device model 1234&#34;);</pre></div></div><div class=paragraph><p>Then the probe routine should either discover the ranges of all the resources by reading the device configuration registers or make sure that they were set explicitly by the user. We will consider it with an example of on-board memory. The probe routine should be as non-intrusive as possible, so allocation and check of functionality of the rest of resources (besides the ports) would be better left to the attach routine.</p></div><div class=paragraph><p>The memory address may be specified in the kernel configuration file or on some devices it may be pre-configured in non-volatile configuration registers. If both sources are available and different, which one should be used? Probably if the user bothered to set the address explicitly in the kernel configuration file they know what they are doing and this one should take precedence. An example of implementation could be:</p></div><div class="literalblock programlisting"><div class=content><pre>          /* try to find out the config address first */
          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);
          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */
              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);

          if(sc-&gt;mem0_p == 0)
                  /* can&#39;t get it from device config registers either */
                  goto bad;
          } else {
              if(xxx_set_mem0_address_on_device(sc) &lt; 0)
                  goto bad; /* device does not support that address */
          }

          /* just like the port, set the memory size,
           * for some devices the memory size would not be constant
           * but should be read from the device configuration registers instead
           * to accommodate different models of devices. Another option would
           * be to let the user set the memory size as &#34;msize&#34; configuration
           * resource which will be automatically handled by the ISA bus.
           */
           if(pnperror) { /* only for non-PnP devices */
              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);
              if(sc-&gt;mem0_size == 0) /* not specified by user */
                  sc-&gt;mem0_size = xxx_read_mem0_size_from_device_config(sc);

              if(sc-&gt;mem0_size == 0) {
                  /* suppose this is a very old model of device without
                   * auto-configuration features and the user gave no preference,
                   * so assume the minimalistic case
                   * (of course, the real value will vary with the driver)
                   */
                  sc-&gt;mem0_size = 8*1024;
              }

              if(xxx_set_mem0_size_on_device(sc) &lt; 0)
                  goto bad; /* device does not support that size */

              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,
                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)
                  goto bad;
          } else {
              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);
          }</pre></div></div><div class=paragraph><p>Resources for IRQ and DRQ are easy to check by analogy.</p></div><div class=paragraph><p>If all went well then release all the resources and return success.</p></div><div class="literalblock programlisting"><div class=content><pre>          xxx_free_resources(sc);
          return 0;</pre></div></div><div class=paragraph><p>Finally, handle the troublesome situations. All the resources should be deallocated before returning. We make use of the fact that before the structure softc is passed to us it gets zeroed out, so we can find out if some resource was allocated: then its descriptor is non-zero.</p></div><div class="literalblock programlisting"><div class=content><pre>          bad:

          xxx_free_resources(sc);
          if(error)
                return error;
          else /* exact error is unknown */
              return ENXIO;</pre></div></div><div class=paragraph><p>That would be all for the probe routine. Freeing of resources is done from multiple places, so it is moved to a function which may look like:</p></div><div class="literalblock programlisting"><div class=content><pre>static void
           xxx_free_resources(sc)
              struct xxx_softc *sc;
          {
              /* check every resource and free if not zero */

              /* interrupt handler */
              if(sc-&gt;intr_r) {
                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-&gt;intr_cookie);
                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-&gt;intr_rid,
                      sc-&gt;intr_r);
                  sc-&gt;intr_r = 0;
              }

              /* all kinds of memory maps we could have allocated */
              if(sc-&gt;data_p) {
                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);
                  sc-&gt;data_p = 0;
              }
               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately equal to 0 */
                  /* the map will also be freed */
                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-&gt;data_map);
                  sc-&gt;data = 0;
              }
              if(sc-&gt;data_tag) {
                  bus_dma_tag_destroy(sc-&gt;data_tag);
                  sc-&gt;data_tag = 0;
              }

              ... free other maps and tags if we have them ...

              if(sc-&gt;parent_tag) {
                  bus_dma_tag_destroy(sc-&gt;parent_tag);
                  sc-&gt;parent_tag = 0;
              }

              /* release all the bus resources */
              if(sc-&gt;mem0_r) {
                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-&gt;mem0_rid,
                      sc-&gt;mem0_r);
                  sc-&gt;mem0_r = 0;
              }
              ...
              if(sc-&gt;port0_r) {
                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-&gt;port0_rid,
                      sc-&gt;port0_r);
                  sc-&gt;port0_r = 0;
              }
          }</pre></div></div></div><div class=sect2><h3 id=isa-driver-attach>10.9. xxx_isa_attach<a class=anchor href=#isa-driver-attach></a></h3><div class=paragraph><p>The attach routine actually connects the driver to the system if the probe routine returned success and the system had chosen to attach that driver. If the probe routine returned 0 then the attach routine may expect to receive the device structure softc intact, as it was set by the probe routine. Also if the probe routine returns 0 it may expect that the attach routine for this device shall be called at some point in the future. If the probe routine returns a negative value then the driver may make none of these assumptions.</p></div><div class=paragraph><p>The attach routine returns 0 if it completed successfully or error code otherwise.</p></div><div class=paragraph><p>The attach routine starts just like the probe routine, with getting some frequently used data into more accessible variables.</p></div><div class="literalblock programlisting"><div class=content><pre>          struct xxx_softc *sc = device_get_softc(dev);
          int unit = device_get_unit(dev);
          int error = 0;</pre></div></div><div class=paragraph><p>Then allocate and activate all the necessary resources. As normally the port range will be released before returning from probe, it has to be allocated again. We expect that the probe routine had properly set all the resource ranges, as well as saved them in the structure softc. If the probe routine had left some resource allocated then it does not need to be allocated again (which would be considered an error).</p></div><div class="literalblock programlisting"><div class=content><pre>          sc-&gt;port0_rid = 0;
          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-&gt;port0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;port0_r == NULL)
               return ENXIO;

          /* on-board memory */
          sc-&gt;mem0_rid = 0;
          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;mem0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;mem0_r == NULL)
                goto bad;

          /* get its virtual address */
          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);</pre></div></div><div class=paragraph><p>The DMA request channel (DRQ) is allocated likewise. To initialize it use functions of the <code>isa_dma*()</code> family. For example:</p></div><div class=paragraph><p><code>isa_dmacascade(sc→drq0);</code></p></div><div class=paragraph><p>The interrupt request line (IRQ) is a bit special. Besides allocation the driver’s interrupt handler should be associated with it. Historically in the old ISA drivers the argument passed by the system to the interrupt handler was the device unit number. But in modern drivers the convention suggests passing the pointer to structure softc. The important reason is that when the structures softc are allocated dynamically then getting the unit number from softc is easy while getting softc from the unit number is difficult. Also this convention makes the drivers for different buses look more uniform and allows them to share the code: each bus gets its own probe, attach, detach and other bus-specific routines while the bulk of the driver code may be shared among them.</p></div><div class="literalblock programlisting"><div class=content><pre>          sc-&gt;intr_rid = 0;
          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;intr_rid,
                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;intr_r == NULL)
              goto bad;

          /*
           * XXX_INTR_TYPE is supposed to be defined depending on the type of
           * the driver, for example as INTR_TYPE_CAM for a CAM driver
           */
          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,
              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-&gt;intr_cookie);
          if(error)
              goto bad;</pre></div></div><div class=paragraph><p>If the device needs to make DMA to the main memory then this memory should be allocated like described before:</p></div><div class="literalblock programlisting"><div class=content><pre>          error=bus_dma_tag_create(NULL, /*alignment*/ 4,
              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,
              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,
              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,
              /*nsegments*/ BUS_SPACE_UNRESTRICTED,
              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,
              &amp;sc-&gt;parent_tag);
          if(error)
              goto bad;

          /* many things get inherited from the parent tag
           * sc-&gt;data is supposed to point to the structure with the shared data,
           * for example for a ring buffer it could be:
           * struct {
           *   u_short rd_pos;
           *   u_short wr_pos;
           *   char    bf[XXX_RING_BUFFER_SIZE]
           * } *data;
           */
          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,
              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,
              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,
              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,
              &amp;sc-&gt;data_tag);
          if(error)
              goto bad;

          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* flags*/ 0,
              &amp;sc-&gt;data_map);
          if(error)
               goto bad;

          /* xxx_alloc_callback() just saves the physical address at
           * the pointer passed as its argument, in this case &amp;sc-&gt;data_p.
           * See details in the section on bus memory mapping.
           * It can be implemented like:
           *
           * static void
           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,
           *     int nseg, int error)
           * {
           *    *(bus_addr_t *)arg = seg[0].ds_addr;
           * }
           */
          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-&gt;data,
              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-&gt;data_p,
              /*flags*/0);</pre></div></div><div class=paragraph><p>After all the necessary resources are allocated the device should be initialized. The initialization may include testing that all the expected features are functional.</p></div><div class="literalblock programlisting"><div class=content><pre>          if(xxx_initialize(sc) &lt; 0)
               goto bad;</pre></div></div><div class=paragraph><p>The bus subsystem will automatically print on the console the device description set by probe. But if the driver wants to print some extra information about the device it may do so, for example:</p></div><div class="literalblock programlisting"><div class=content><pre>        device_printf(dev, &#34;has on-card FIFO buffer of %d bytes\n&#34;, sc-&gt;fifosize);</pre></div></div><div class=paragraph><p>If the initialization routine experiences any problems then printing messages about them before returning error is also recommended.</p></div><div class=paragraph><p>The final step of the attach routine is attaching the device to its functional subsystem in the kernel. The exact way to do it depends on the type of the driver: a character device, a block device, a network device, a CAM SCSI bus device and so on.</p></div><div class=paragraph><p>If all went well then return success.</p></div><div class="literalblock programlisting"><div class=content><pre>          error = xxx_attach_subsystem(sc);
          if(error)
              goto bad;

          return 0;</pre></div></div><div class=paragraph><p>Finally, handle the troublesome situations. All the resources should be deallocated before returning an error. We make use of the fact that before the structure softc is passed to us it gets zeroed out, so we can find out if some resource was allocated: then its descriptor is non-zero.</p></div><div class="literalblock programlisting"><div class=content><pre>          bad:

          xxx_free_resources(sc);
          if(error)
              return error;
          else /* exact error is unknown */
              return ENXIO;</pre></div></div><div class=paragraph><p>That would be all for the attach routine.</p></div></div><div class=sect2><h3 id=isa-driver-detach>10.10. xxx_isa_detach<a class=anchor href=#isa-driver-detach></a></h3><div class=paragraph><p>If this function is present in the driver and the driver is compiled as a loadable module then the driver gets the ability to be unloaded. This is an important feature if the hardware supports hot plug. But the ISA bus does not support hot plug, so this feature is not particularly important for the ISA devices. The ability to unload a driver may be useful when debugging it, but in many cases installation of the new version of the driver would be required only after the old version somehow wedges the system and a reboot will be needed anyway, so the efforts spent on writing the detach routine may not be worth it. Another argument that unloading would allow upgrading the drivers on a production machine seems to be mostly theoretical. Installing a new version of a driver is a dangerous operation which should never be performed on a production machine (and which is not permitted when the system is running in secure mode). Still, the detach routine may be provided for the sake of completeness.</p></div><div class=paragraph><p>The detach routine returns 0 if the driver was successfully detached or the error code otherwise.</p></div><div class=paragraph><p>The logic of detach is a mirror of the attach. The first thing to do is to detach the driver from its kernel subsystem. If the device is currently open then the driver has two choices: refuse to be detached or forcibly close and proceed with detach. The choice used depends on the ability of the particular kernel subsystem to do a forced close and on the preferences of the driver’s author. Generally the forced close seems to be the preferred alternative.</p></div><div class="literalblock programlisting"><div class=content><pre>          struct xxx_softc *sc = device_get_softc(dev);
          int error;

          error = xxx_detach_subsystem(sc);
          if(error)
              return error;</pre></div></div><div class=paragraph><p>Next the driver may want to reset the hardware to some consistent state. That includes stopping any ongoing transfers, disabling the DMA channels and interrupts to avoid memory corruption by the device. For most of the drivers this is exactly what the shutdown routine does, so if it is included in the driver we can just call it.</p></div><div class=paragraph><p><code>xxx_isa_shutdown(dev);</code></p></div><div class=paragraph><p>And finally release all the resources and return success.</p></div><div class="literalblock programlisting"><div class=content><pre>          xxx_free_resources(sc);
          return 0;</pre></div></div></div><div class=sect2><h3 id=isa-driver-shutdown>10.11. xxx_isa_shutdown<a class=anchor href=#isa-driver-shutdown></a></h3><div class=paragraph><p>This routine is called when the system is about to be shut down. It is expected to bring the hardware to some consistent state. For most of the ISA devices no special action is required, so the function is not really necessary because the device will be re-initialized on reboot anyway. But some devices have to be shut down with a special procedure, to make sure that they will be properly detected after soft reboot (this is especially true for many devices with proprietary identification protocols). In any case disabling DMA and interrupts in the device registers and stopping any ongoing transfers is a good idea. The exact action depends on the hardware, so we do not consider it here in any detail.</p></div></div><div class=sect2><h3 id=isa-driver-intr>10.12. xxx_intr<a class=anchor href=#isa-driver-intr></a></h3><div class=paragraph><p>The interrupt handler is called when an interrupt is received which may be from this particular device. The ISA bus does not support interrupt sharing (except in some special cases) so in practice if the interrupt handler is called then the interrupt almost for sure came from its device. Still, the interrupt handler must poll the device registers and make sure that the interrupt was generated by its device. If not it should just return.</p></div><div class=paragraph><p>The old convention for the ISA drivers was getting the device unit number as an argument. This is obsolete, and the new drivers receive whatever argument was specified for them in the attach routine when calling <code>bus_setup_intr()</code>. By the new convention it should be the pointer to the structure softc. So the interrupt handler commonly starts as:</p></div><div class="literalblock programlisting"><div class=content><pre>          static void
          xxx_intr(struct xxx_softc *sc)
          {</pre></div></div><div class=paragraph><p>It runs at the interrupt priority level specified by the interrupt type parameter of <code>bus_setup_intr()</code>. That means that all the other interrupts of the same type as well as all the software interrupts are disabled.</p></div><div class=paragraph><p>To avoid races it is commonly written as a loop:</p></div><div class="literalblock programlisting"><div class=content><pre>          while(xxx_interrupt_pending(sc)) {
              xxx_process_interrupt(sc);
              xxx_acknowledge_interrupt(sc);
          }</pre></div></div><div class=paragraph><p>The interrupt handler has to acknowledge interrupt to the device only but not to the interrupt controller, the system takes care of the latter.</p></div></div></div></div><div class=sect1><h2 id=pci>Chapter 11. PCI Devices<a class=anchor href=#pci></a></h2><div class=sectionbody><div class=paragraph><p>This chapter will talk about the FreeBSD mechanisms for writing a device driver for a device on a PCI bus.</p></div><div class=sect2><h3 id=pci-probe>11.1. Probe and Attach<a class=anchor href=#pci-probe></a></h3><div class=paragraph><p>Information here about how the PCI bus code iterates through the unattached devices and see if a newly loaded kld will attach to any of them.</p></div><div class=sect3><h4 id=_sample_driver_source_mypci_c>11.1.1. Sample Driver Source (<span class=filename>mypci.c</span>)<a class=anchor href=#_sample_driver_source_mypci_c></a></h4><div class="literalblock programlisting"><div class=content><pre>/*
 * Simple KLD to play with the PCI functions.
 *
 * Murray Stokely
 */

#include &lt;sys/param.h&gt;		/* defines used in kernel.h */
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/kernel.h&gt;		/* types used in module initialization */
#include &lt;sys/conf.h&gt;		/* cdevsw struct */
#include &lt;sys/uio.h&gt;		/* uio struct */
#include &lt;sys/malloc.h&gt;
#include &lt;sys/bus.h&gt;		/* structs, prototypes for pci bus stuff and DEVMETHOD macros! */

#include &lt;machine/bus.h&gt;
#include &lt;sys/rman.h&gt;
#include &lt;machine/resource.h&gt;

#include &lt;dev/pci/pcivar.h&gt;	/* For pci_get macros! */
#include &lt;dev/pci/pcireg.h&gt;

/* The softc holds our per-instance data. */
struct mypci_softc {
	device_t	my_dev;
	struct cdev	*my_cdev;
};

/* Function prototypes */
static d_open_t		mypci_open;
static d_close_t	mypci_close;
static d_read_t		mypci_read;
static d_write_t	mypci_write;

/* Character device entry points */

static struct cdevsw mypci_cdevsw = {
	.d_version =	D_VERSION,
	.d_open =	mypci_open,
	.d_close =	mypci_close,
	.d_read =	mypci_read,
	.d_write =	mypci_write,
	.d_name =	&#34;mypci&#34;,
};

/*
 * In the cdevsw routines, we find our softc by using the si_drv1 member
 * of struct cdev.  We set this variable to point to our softc in our
 * attach routine when we create the /dev entry.
 */

int
mypci_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, &#34;Opened successfully.\n&#34;);
	return (0);
}

int
mypci_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, &#34;Closed.\n&#34;);
	return (0);
}

int
mypci_read(struct cdev *dev, struct uio *uio, int ioflag)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, &#34;Asked to read %zd bytes.\n&#34;, uio-&gt;uio_resid);
	return (0);
}

int
mypci_write(struct cdev *dev, struct uio *uio, int ioflag)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, &#34;Asked to write %zd bytes.\n&#34;, uio-&gt;uio_resid);
	return (0);
}

/* PCI Support Functions */

/*
 * Compare the device ID of this device against the IDs that this driver
 * supports.  If there is a match, set the description and return success.
 */
static int
mypci_probe(device_t dev)
{

	device_printf(dev, &#34;MyPCI Probe\nVendor ID : 0x%x\nDevice ID : 0x%x\n&#34;,
	    pci_get_vendor(dev), pci_get_device(dev));

	if (pci_get_vendor(dev) == 0x11c1) {
		printf(&#34;We&#39;ve got the Winmodem, probe successful!\n&#34;);
		device_set_desc(dev, &#34;WinModem&#34;);
		return (BUS_PROBE_DEFAULT);
	}
	return (ENXIO);
}

/* Attach function is only called if the probe is successful. */

static int
mypci_attach(device_t dev)
{
	struct mypci_softc *sc;

	printf(&#34;MyPCI Attach for : deviceID : 0x%x\n&#34;, pci_get_devid(dev));

	/* Look up our softc and initialize its fields. */
	sc = device_get_softc(dev);
	sc-&gt;my_dev = dev;

	/*
	 * Create a /dev entry for this device.  The kernel will assign us
	 * a major number automatically.  We use the unit number of this
	 * device as the minor number and name the character device
	 * &#34;mypci&lt;unit&gt;&#34;.
	 */
	sc-&gt;my_cdev = make_dev(&amp;mypci_cdevsw, device_get_unit(dev),
	    UID_ROOT, GID_WHEEL, 0600, &#34;mypci%u&#34;, device_get_unit(dev));
	sc-&gt;my_cdev-&gt;si_drv1 = sc;
	printf(&#34;Mypci device loaded.\n&#34;);
	return (0);
}

/* Detach device. */

static int
mypci_detach(device_t dev)
{
	struct mypci_softc *sc;

	/* Teardown the state in our softc created in our attach routine. */
	sc = device_get_softc(dev);
	destroy_dev(sc-&gt;my_cdev);
	printf(&#34;Mypci detach!\n&#34;);
	return (0);
}

/* Called during system shutdown after sync. */

static int
mypci_shutdown(device_t dev)
{

	printf(&#34;Mypci shutdown!\n&#34;);
	return (0);
}

/*
 * Device suspend routine.
 */
static int
mypci_suspend(device_t dev)
{

	printf(&#34;Mypci suspend!\n&#34;);
	return (0);
}

/*
 * Device resume routine.
 */
static int
mypci_resume(device_t dev)
{

	printf(&#34;Mypci resume!\n&#34;);
	return (0);
}

static device_method_t mypci_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		mypci_probe),
	DEVMETHOD(device_attach,	mypci_attach),
	DEVMETHOD(device_detach,	mypci_detach),
	DEVMETHOD(device_shutdown,	mypci_shutdown),
	DEVMETHOD(device_suspend,	mypci_suspend),
	DEVMETHOD(device_resume,	mypci_resume),

	DEVMETHOD_END
};

static devclass_t mypci_devclass;

DEFINE_CLASS_0(mypci, mypci_driver, mypci_methods, sizeof(struct mypci_softc));
DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);</pre></div></div></div><div class=sect3><h4 id=_makefile_for_sample_driver>11.1.2. <span class=filename>Makefile</span> for Sample Driver<a class=anchor href=#_makefile_for_sample_driver></a></h4><div class="literalblock programlisting"><div class=content><pre># Makefile for mypci driver

KMOD=	mypci
SRCS=	mypci.c
SRCS+=	device_if.h bus_if.h pci_if.h

.include &lt;bsd.kmod.mk&gt;</pre></div></div><div class=paragraph><p>If you place the above source file and <span class=filename>Makefile</span> into a directory, you may run <code>make</code> to compile the sample driver. Additionally, you may run <code>make load</code> to load the driver into the currently running kernel and <code>make unload</code> to unload the driver after it is loaded.</p></div></div><div class=sect3><h4 id=_additional_resources>11.1.3. Additional Resources<a class=anchor href=#_additional_resources></a></h4><div class=ulist><ul><li><p><a href=http://www.pcisig.org/>PCI Special Interest Group</a></p></li><li><p>PCI System Architecture, Fourth Edition by Tom Shanley, et al.</p></li></ul></div></div></div><div class=sect2><h3 id=pci-bus>11.2. Bus Resources<a class=anchor href=#pci-bus></a></h3><div class=paragraph><p>FreeBSD provides an object-oriented mechanism for requesting resources from a parent bus. Almost all devices will be a child member of some sort of bus (PCI, ISA, USB, SCSI, etc) and these devices need to acquire resources from their parent bus (such as memory segments, interrupt lines, or DMA channels).</p></div><div class=sect3><h4 id=_base_address_registers>11.2.1. Base Address Registers<a class=anchor href=#_base_address_registers></a></h4><div class=paragraph><p>To do anything particularly useful with a PCI device you will need to obtain the <em>Base Address Registers</em> (BARs) from the PCI Configuration space. The PCI-specific details of obtaining the BAR are abstracted in the <code>bus_alloc_resource()</code> function.</p></div><div class=paragraph><p>For example, a typical driver might have something similar to this in the <code>attach()</code> function:</p></div><div class="literalblock programlisting"><div class=content><pre>    sc-&gt;bar0id = PCIR_BAR(0);
    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar0id,
				  0, ~0, 1, RF_ACTIVE);
    if (sc-&gt;bar0res == NULL) {
        printf(&#34;Memory allocation of PCI base register 0 failed!\n&#34;);
        error = ENXIO;
        goto fail1;
    }

    sc-&gt;bar1id = PCIR_BAR(1);
    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar1id,
				  0, ~0, 1, RF_ACTIVE);
    if (sc-&gt;bar1res == NULL) {
        printf(&#34;Memory allocation of PCI base register 1 failed!\n&#34;);
        error =  ENXIO;
        goto fail2;
    }
    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);
    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);
    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);
    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);</pre></div></div><div class=paragraph><p>Handles for each base address register are kept in the <code>softc</code> structure so that they can be used to write to the device later.</p></div><div class=paragraph><p>These handles can then be used to read or write from the device registers with the <code>bus_space_*</code> functions. For example, a driver might contain a shorthand function to read from a board specific register like this:</p></div><div class="literalblock programlisting"><div class=content><pre>uint16_t
board_read(struct ni_softc *sc, uint16_t address)
{
    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);
}</pre></div></div><div class=paragraph><p>Similarly, one could write to the registers with:</p></div><div class="literalblock programlisting"><div class=content><pre>void
board_write(struct ni_softc *sc, uint16_t address, uint16_t value)
{
    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);
}</pre></div></div><div class=paragraph><p>These functions exist in 8bit, 16bit, and 32bit versions and you should use <code>bus_space_{read|write}_{1|2|4}</code> accordingly.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In FreeBSD 7.0 and later, you can use the <code>bus_*</code> functions instead of <code>bus_space_*</code>. The <code>bus_*</code> functions take a struct resource * pointer instead of a bus tag and handle. Thus, you could drop the bus tag and bus handle members from the <code>softc</code> and rewrite the <code>board_read()</code> function as:</p></div><div class="literalblock programlisting"><div class=content><pre>uint16_t
board_read(struct ni_softc *sc, uint16_t address)
{
	return (bus_read(sc-&gt;bar1res, address));
}</pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_interrupts>11.2.2. Interrupts<a class=anchor href=#_interrupts></a></h4><div class=paragraph><p>Interrupts are allocated from the object-oriented bus code in a way similar to the memory resources. First an IRQ resource must be allocated from the parent bus, and then the interrupt handler must be set up to deal with this IRQ.</p></div><div class=paragraph><p>Again, a sample from a device <code>attach()</code> function says more than words.</p></div><div class="literalblock programlisting"><div class=content><pre>/* Get the IRQ resource */

    sc-&gt;irqid = 0x0;
    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),
				  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);
    if (sc-&gt;irqres == NULL) {
	printf(&#34;IRQ allocation failed!\n&#34;);
	error = ENXIO;
	goto fail3;
    }

    /* Now we should set up the interrupt handler */

    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,
			   my_handler, sc, &amp;(sc-&gt;handler));
    if (error) {
	printf(&#34;Couldn&#39;t set up irq\n&#34;);
	goto fail4;
    }</pre></div></div><div class=paragraph><p>Some care must be taken in the detach routine of the driver. You must quiesce the device’s interrupt stream, and remove the interrupt handler. Once <code>bus_teardown_intr()</code> has returned, you know that your interrupt handler will no longer be called and that all threads that might have been executing this interrupt handler have returned. Since this function can sleep, you must not hold any mutexes when calling this function.</p></div></div><div class=sect3><h4 id=_dma>11.2.3. DMA<a class=anchor href=#_dma></a></h4><div class=paragraph><p>This section is obsolete, and present only for historical reasons. The proper methods for dealing with these issues is to use the <code>bus_space_dma*()</code> functions instead. This paragraph can be removed when this section is updated to reflect that usage. However, at the moment, the API is in a bit of flux, so once that settles down, it would be good to update this section to reflect that.</p></div><div class=paragraph><p>On the PC, peripherals that want to do bus-mastering DMA must deal with physical addresses. This is a problem since FreeBSD uses virtual memory and deals almost exclusively with virtual addresses. Fortunately, there is a function, <code>vtophys()</code> to help.</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;vm/vm.h&gt;
#include &lt;vm/pmap.h&gt;

#define vtophys(virtual_address) (...)</pre></div></div><div class=paragraph><p>The solution is a bit different on the alpha however, and what we really want is a function called <code>vtobus()</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>#if defined(__alpha__)
#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)
#else
#define vtobus(va)      vtophys(va)
#endif</pre></div></div></div><div class=sect3><h4 id=_deallocating_resources>11.2.4. Deallocating Resources<a class=anchor href=#_deallocating_resources></a></h4><div class=paragraph><p>It is very important to deallocate all of the resources that were allocated during <code>attach()</code>. Care must be taken to deallocate the correct stuff even on a failure condition so that the system will remain usable while your driver dies.</p></div></div></div></div></div><div class=sect1><h2 id=scsi>Chapter 12. Common Access Method SCSI Controllers<a class=anchor href=#scsi></a></h2><div class=sectionbody><div class=sect2><h3 id=scsi-synopsis>12.1. Synopsis<a class=anchor href=#scsi-synopsis></a></h3><div class=paragraph><p>This document assumes that the reader has a general understanding of device drivers in FreeBSD and of the SCSI protocol.
Much of the information in this document was extracted from the drivers:</p></div><div class=ulist><ul><li><p>ncr (<span class=filename>/sys/pci/ncr.c</span>) by Wolfgang Stanglmeier and Stefan Esser</p></li><li><p>sym (<span class=filename>/sys/dev/sym/sym_hipd.c</span>) by Gerard Roudier</p></li><li><p>aic7xxx (<span class=filename>/sys/dev/aic7xxx/aic7xxx.c</span>) by Justin T. Gibbs</p></li></ul></div><div class=paragraph><p>and from the CAM code itself (by Justin T. Gibbs, see <span class=filename>/sys/cam/*</span>).
When some solution looked the most logical and was essentially verbatim extracted from the code by Justin T. Gibbs, I marked it as "recommended".</p></div><div class=paragraph><p>The document is illustrated with examples in pseudo-code.
Although sometimes the examples have many details and look like real code, it is still pseudo-code.
It was written to demonstrate the concepts in an understandable way.
For a real driver other approaches may be more modular and efficient.
It also abstracts from the hardware details, as well as issues that would cloud the demonstrated concepts or that are supposed to be described in the other chapters of the developers handbook.
Such details are commonly shown as calls to functions with descriptive names, comments or pseudo-statements.
Fortunately real life full-size examples with all the details can be found in the real drivers.</p></div></div><div class=sect2><h3 id=scsi-general>12.2. General Architecture<a class=anchor href=#scsi-general></a></h3><div class=paragraph><p>CAM stands for Common Access Method.
It is a generic way to address the I/O buses in a SCSI-like way.
This allows a separation of the generic device drivers from the drivers controlling the I/O bus: for example the disk driver becomes able to control disks on both SCSI, IDE, and/or any other bus so the disk driver portion does not have to be rewritten (or copied and modified) for every new I/O bus.
Thus the two most important active entities are:</p></div><div class=ulist><ul><li><p><em>Peripheral Modules</em> - a driver for peripheral devices (disk, tape, CD-ROM, etc.)</p></li><li><p><em>SCSI Interface Modules</em> (SIM) - a Host Bus Adapter drivers for connecting to an I/O bus such as SCSI or IDE.</p></li></ul></div><div class=paragraph><p>A peripheral driver receives requests from the OS, converts them to a sequence of SCSI commands and passes these SCSI commands to a SCSI Interface Module.
The SCSI Interface Module is responsible for passing these commands to the actual hardware (or if the actual hardware is not SCSI but, for example, IDE then also converting the SCSI commands to the native commands of the hardware).</p></div><div class=paragraph><p>As we are interested in writing a SCSI adapter driver here, from this point on we will consider everything from the SIM standpoint.</p></div></div><div class=sect2><h3 id=_globals_and_boilerplate>12.3. Globals and Boilerplate<a class=anchor href=#_globals_and_boilerplate></a></h3><div class=paragraph><p>A typical SIM driver needs to include the following CAM-related header files:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;cam/cam.h&gt;
#include &lt;cam/cam_ccb.h&gt;
#include &lt;cam/cam_sim.h&gt;
#include &lt;cam/cam_xpt_sim.h&gt;
#include &lt;cam/cam_debug.h&gt;
#include &lt;cam/scsi/scsi_all.h&gt;</pre></div></div></div><div class=sect2><h3 id=_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach<a class=anchor href=#_device_configuration_xxx_attach></a></h3><div class=paragraph><p>The first thing each SIM driver must do is register itself with the CAM subsystem.
This is done during the driver’s <code>xxx_attach()</code> function (here and further xxx_ is used to denote the unique driver name prefix).
The <code>xxx_attach()</code> function itself is called by the system bus auto-configuration code which we do not describe here.</p></div><div class=paragraph><p>This is achieved in multiple steps: first it is necessary to allocate the queue of requests associated with this SIM:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct cam_devq *devq;

    if ((devq = cam_simq_alloc(SIZE)) == NULL) {
        error; /* some code to handle the error */
    }</pre></div></div><div class=paragraph><p>Here <code>SIZE</code> is the size of the queue to be allocated, maximal number of requests it could contain.
It is the number of requests that the SIM driver can handle in parallel on one SCSI card.
Commonly it can be calculated as:</p></div><div class="literalblock programlisting"><div class=content><pre>SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET</pre></div></div><div class=paragraph><p>Next we create a descriptor of our SIM:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct cam_sim *sim;

    if ((sim = cam_sim_alloc(action_func, poll_func, driver_name,
            softc, unit, mtx, max_dev_transactions,
            max_tagged_dev_transactions, devq)) == NULL) {
        cam_simq_free(devq);
        error; /* some code to handle the error */
    }</pre></div></div><div class=paragraph><p>Note that if we are not able to create a SIM descriptor we free the <code>devq</code> also because we can do nothing else with it and we want to conserve memory.</p></div><div class=paragraph><p>If a SCSI card has multiple SCSI buses on it then each bus requires its own <code>cam_sim</code> structure.</p></div><div class=paragraph><p>An interesting question is what to do if a SCSI card has more than one SCSI bus, do we need one <code>devq</code> structure per card or per SCSI bus?
The answer given in the comments to the CAM code is: either way, as the driver’s author prefers.</p></div><div class=paragraph><p>The arguments are:</p></div><div class=ulist><ul><li><p><code>action_func</code> - pointer to the driver’s <code>xxx_action</code> function.</p></li></ul></div><div class="literalblock programlisting"><div class=content><pre>static void xxx_action(struct cam_sim *, union ccb *);</pre></div></div><div class=ulist><ul><li><p><code>poll_func</code> - pointer to the driver’s <code>xxx_poll()</code></p><div class="literalblock programlisting"><div class=content><pre>static void xxx_poll(struct cam_sim *);</pre></div></div></li><li><p>driver_name - the name of the actual driver, such as "ncr" or "wds".</p></li><li><p><code>softc</code> - pointer to the driver’s internal descriptor for this SCSI card.
This pointer will be used by the driver in future to get private data.</p></li><li><p>unit - the controller unit number, for example for controller "mps0" this number will be 0</p></li><li><p>mtx - Lock associated with this SIM.
For SIMs that don’t know about locking, pass in Giant.
For SIMs that do, pass in the lock used to guard this SIM’s data structures.
This lock will be held when xxx_action and xxx_poll are called.</p></li><li><p>max_dev_transactions - maximal number of simultaneous transactions per SCSI target in the non-tagged mode.
This value will be almost universally equal to 1, with possible exceptions only for the non-SCSI cards.
Also the drivers that hope to take advantage by preparing one transaction while another one is executed may set it to 2 but this does not seem to be worth the complexity.</p></li><li><p>max_tagged_dev_transactions - the same thing, but in the tagged mode.
Tags are the SCSI way to initiate multiple transactions on a device: each transaction is assigned a unique tag and the transaction is sent to the device.
When the device completes some transaction it sends back the result together with the tag so that the SCSI adapter (and the driver) can tell which transaction was completed.
This argument is also known as the maximal tag depth.
It depends on the abilities of the SCSI adapter.</p></li></ul></div><div class=paragraph><p>Finally we register the SCSI buses associated with our SCSI adapter:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {
        cam_sim_free(sim, /*free_devq*/ TRUE);
        error; /* some code to handle the error */
    }</pre></div></div><div class=paragraph><p>If there is one <code>devq</code> structure per SCSI bus (i.e., we consider a card with multiple buses as multiple cards with one bus each) then the bus number will always be 0, otherwise each bus on the SCSI card should be get a distinct number.
Each bus needs its own separate structure cam_sim.</p></div><div class=paragraph><p>After that our controller is completely hooked to the CAM system.
The value of <code>devq</code> can be discarded now: sim will be passed as an argument in all further calls from CAM and devq can be derived from it.</p></div><div class=paragraph><p>CAM provides the framework for such asynchronous events.
Some events originate from the lower levels (the SIM drivers), some events originate from the peripheral drivers, some events originate from the CAM subsystem itself.
Any driver can register callbacks for some types of the asynchronous events, so that it would be notified if these events occur.</p></div><div class=paragraph><p>A typical example of such an event is a device reset.
Each transaction and event identifies the devices to which it applies by the means of "path".
The target-specific events normally occur during a transaction with this device.
So the path from that transaction may be re-used to report this event (this is safe because the event path is copied in the event reporting routine but not deallocated nor passed anywhere further).
Also it is safe to allocate paths dynamically at any time including the interrupt routines, although that incurs certain overhead, and a possible problem with this approach is that there may be no free memory at that time.
For a bus reset event we need to define a wildcard path including all devices on the bus.
So we can create the path for the future bus reset events in advance and avoid problems with the future memory shortage:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct cam_path *path;

    if (xpt_create_path(&amp;path, /*periph*/NULL,
                cam_sim_path(sim), CAM_TARGET_WILDCARD,
                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {
        xpt_bus_deregister(cam_sim_path(sim));
        cam_sim_free(sim, /*free_devq*/TRUE);
        error; /* some code to handle the error */
    }

    softc-&gt;wpath = path;
    softc-&gt;sim = sim;</pre></div></div><div class=paragraph><p>As you can see the path includes:</p></div><div class=ulist><ul><li><p>ID of the peripheral driver (NULL here because we have none)</p></li><li><p>ID of the SIM driver (<code>cam_sim_path(sim)</code>)</p></li><li><p>SCSI target number of the device (CAM_TARGET_WILDCARD means "all devices")</p></li><li><p>SCSI LUN number of the subdevice (CAM_LUN_WILDCARD means "all LUNs")</p></li></ul></div><div class=paragraph><p>If the driver can not allocate this path it will not be able to work normally, so in that case we dismantle that SCSI bus.</p></div><div class=paragraph><p>And we save the path pointer in the <code>softc</code> structure for future use.
After that we save the value of sim (or we can also discard it on the exit from <code>xxx_probe()</code> if we wish).</p></div><div class=paragraph><p>That is all for a minimalistic initialization.
To do things right there is one more issue left.</p></div><div class=paragraph><p>For a SIM driver there is one particularly interesting event: when a target device is considered lost.
In this case resetting the SCSI negotiations with this device may be a good idea.
So we register a callback for this event with CAM.
The request is passed to CAM by requesting CAM action on a CAM control block for this type of request:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb_setasync csa;

    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);
    csa.ccb_h.func_code = XPT_SASYNC_CB;
    csa.event_enable = AC_LOST_DEVICE;
    csa.callback = xxx_async;
    csa.callback_arg = sim;
    xpt_action((union ccb *)&amp;csa);</pre></div></div></div><div class=sect2><h3 id=_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action<a class=anchor href=#_processing_cam_messages_xxx_action></a></h3><div class="literalblock programlisting"><div class=content><pre>static void xxx_action(struct cam_sim *sim, union ccb *ccb);</pre></div></div><div class=paragraph><p>Do some action on request of the CAM subsystem.
Sim describes the SIM for the request, CCB is the request itself.
CCB stands for "CAM Control Block".
It is a union of many specific instances, each describing arguments for some type of transactions.
All of these instances share the CCB header where the common part of arguments is stored.</p></div><div class=paragraph><p>CAM supports the SCSI controllers working in both initiator ("normal") mode and target (simulating a SCSI device) mode.
Here we only consider the part relevant to the initiator mode.</p></div><div class=paragraph><p>There are a few function and macros (in other words, methods) defined to access the public data in the struct sim:</p></div><div class=ulist><ul><li><p><code>cam_sim_path(sim)</code> - the path ID (see above)</p></li><li><p><code>cam_sim_name(sim)</code> - the name of the sim</p></li><li><p><code>cam_sim_softc(sim)</code> - the pointer to the softc (driver private data) structure</p></li><li><p><code>cam_sim_unit(sim)</code> - the unit number</p></li><li><p><code>cam_sim_bus(sim)</code> - the bus ID</p></li></ul></div><div class=paragraph><p>To identify the device, <code>xxx_action()</code> can get the unit number and pointer to its structure softc using these functions.</p></div><div class=paragraph><p>The type of request is stored in <code>ccb→ccb_h.func_code</code>.
So generally <code>xxx_action()</code> consists of a big switch:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);
    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;
    int unit = cam_sim_unit(sim);
    int bus = cam_sim_bus(sim);

    switch (ccb_h-&gt;func_code) {
    case ...:
        ...
    default:
        ccb_h-&gt;status = CAM_REQ_INVALID;
        xpt_done(ccb);
        break;
    }</pre></div></div><div class=paragraph><p>As can be seen from the default case (if an unknown command was received) the return code of the command is set into <code>ccb→ccb_h.status</code> and the completed CCB is returned back to CAM by calling <code>xpt_done(ccb)</code>.</p></div><div class=paragraph><p><code>xpt_done()</code> does not have to be called from <code>xxx_action()</code>: For example an I/O request may be enqueued inside the SIM driver and/or its SCSI controller.
Then when the device would post an interrupt signaling that the processing of this request is complete <code>xpt_done()</code> may be called from the interrupt handling routine.</p></div><div class=paragraph><p>Actually, the CCB status is not only assigned as a return code but a CCB has some status all the time.
Before CCB is passed to the <code>xxx_action()</code> routine it gets the status CCB_REQ_INPROG meaning that it is in progress.
There are a surprising number of status values defined in <span class=filename>/sys/cam/cam.h</span> which should be able to represent the status of a request in great detail.
More interesting yet, the status is in fact a "bitwise or" of an enumerated status value (the lower 6 bits) and possible additional flag-like bits (the upper bits).
The enumerated values will be discussed later in more detail.
The summary of them can be found in the Errors Summary section.
The possible status flags are:</p></div><div class=ulist><ul><li><p><em>CAM_DEV_QFRZN</em> - if the SIM driver gets a serious error (for example, the device does not respond to the selection or breaks the SCSI protocol) when processing a CCB it should freeze the request queue by calling <code>xpt_freeze_simq()</code>, return the other enqueued but not processed yet CCBs for this device back to the CAM queue, then set this flag for the troublesome CCB and call <code>xpt_done()</code>.
This flag causes the CAM subsystem to unfreeze the queue after it handles the error.</p></li><li><p><em>CAM_AUTOSNS_VALID</em> - if the device returned an error condition and the flag CAM_DIS_AUTOSENSE is not set in CCB the SIM driver must execute the REQUEST SENSE command automatically to extract the sense (extended error information) data from the device.
If this attempt was successful the sense data should be saved in the CCB and this flag set.</p></li><li><p><em>CAM_RELEASE_SIMQ</em> - like CAM_DEV_QFRZN but used in case there is some problem (or resource shortage) with the SCSI controller itself.
Then all the future requests to the controller should be stopped by <code>xpt_freeze_simq()</code>.
The controller queue will be restarted after the SIM driver overcomes the shortage and informs CAM by returning some CCB with this flag set.</p></li><li><p><em>CAM_SIM_QUEUED</em> - when SIM puts a CCB into its request queue this flag should be set (and removed when this CCB gets dequeued before being returned back to CAM).
This flag is not used anywhere in the CAM code now, so its purpose is purely diagnostic.</p></li><li><p><em>CAM_QOS_VALID</em> - The QOS data is now valid.</p></li></ul></div><div class=paragraph><p>The function <code>xxx_action()</code> is not allowed to sleep, so all the synchronization for resource access must be done using SIM or device queue freezing.
Besides the aforementioned flags the CAM subsystem provides functions <code>xpt_release_simq()</code> and <code>xpt_release_devq()</code> to unfreeze the queues directly, without passing a CCB to CAM.</p></div><div class=paragraph><p>The CCB header contains the following fields:</p></div><div class=ulist><ul><li><p><em>path</em> - path ID for the request</p></li><li><p><em>target_id</em> - target device ID for the request</p></li><li><p><em>target_lun</em> - LUN ID of the target device</p></li><li><p><em>timeout</em> - timeout interval for this command, in milliseconds</p></li><li><p><em>timeout_ch</em> - a convenience place for the SIM driver to store the timeout handle (the CAM subsystem itself does not make any assumptions about it)</p></li><li><p><em>flags</em> - various bits of information about the request spriv_ptr0, spriv_ptr1 - fields reserved for private use by the SIM driver (such as linking to the SIM queues or SIM private control blocks); actually, they exist as unions: spriv_ptr0 and spriv_ptr1 have the type (void *), spriv_field0 and spriv_field1 have the type unsigned long, sim_priv.entries[0].bytes and sim_priv.entries[1].bytes are byte arrays of the size consistent with the other incarnations of the union and sim_priv.bytes is one array, twice bigger.</p></li></ul></div><div class=paragraph><p>The recommended way of using the SIM private fields of CCB is to define some meaningful names for them and use these meaningful names in the driver, like:</p></div><div class="literalblock programlisting"><div class=content><pre>#define ccb_some_meaningful_name    sim_priv.entries[0].bytes
#define ccb_hcb spriv_ptr1 /* for hardware control block */</pre></div></div><div class=paragraph><p>The most common initiator mode requests are:</p></div><div class=sect3><h4 id=_xpt_scsi_io_execute_an_io_transaction>12.5.1. <em>XPT_SCSI_IO</em> - execute an I/O transaction<a class=anchor href=#_xpt_scsi_io_execute_an_io_transaction></a></h4><div class=paragraph><p>The instance "struct ccb_scsiio csio" of the union ccb is used to transfer the arguments.
They are:</p></div><div class=ulist><ul><li><p><em>cdb_io</em> - pointer to the SCSI command buffer or the buffer itself</p></li><li><p><em>cdb_len</em> - SCSI command length</p></li><li><p><em>data_ptr</em> - pointer to the data buffer (gets a bit complicated if scatter/gather is used)</p></li><li><p><em>dxfer_len</em> - length of the data to transfer</p></li><li><p><em>sglist_cnt</em> - counter of the scatter/gather segments</p></li><li><p><em>scsi_status</em> - place to return the SCSI status</p></li><li><p><em>sense_data</em> - buffer for the SCSI sense information if the command returns an error (the SIM driver is supposed to run the REQUEST SENSE command automatically in this case if the CCB flag CAM_DIS_AUTOSENSE is not set)</p></li><li><p><em>sense_len</em> - the length of that buffer (if it happens to be higher than size of sense_data the SIM driver must silently assume the smaller value)</p></li><li><p><em>resid</em>, <em>sense_resid</em> - if the transfer of data or SCSI sense returned an error these are the returned counters of the residual (not transferred) data.
They do not seem to be especially meaningful, so in a case when they are difficult to compute (say, counting bytes in the SCSI controller’s FIFO buffer) an approximate value will do as well.
For a successfully completed transfer they must be set to zero.</p></li><li><p><em>tag_action</em> - the kind of tag to use:</p><div class=ulist><ul><li><p>CAM_TAG_ACTION_NONE - do not use tags for this transaction</p></li><li><p>MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - value equal to the appropriate tag message (see /sys/cam/scsi/scsi_message.h); this gives only the tag type, the SIM driver must assign the tag value itself</p></li></ul></div></li></ul></div><div class=paragraph><p>The general logic of handling this request is the following:</p></div><div class=paragraph><p>The first thing to do is to check for possible races, to make sure that the command did not get aborted when it was sitting in the queue:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;

    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {
        xpt_done(ccb);
        return;
    }</pre></div></div><div class=paragraph><p>Also we check that the device is supported at all by our controller:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID
    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {
        ccb_h-&gt;status = CAM_TID_INVALID;
        xpt_done(ccb);
        return;
    }
    if (ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {
        ccb_h-&gt;status = CAM_LUN_INVALID;
        xpt_done(ccb);
        return;
    }</pre></div></div><div class=paragraph><p>Then allocate whatever data structures (such as card-dependent hardware control block) we need to process this request.
If we can not then freeze the SIM queue and remember that we have a pending operation, return the CCB back and ask CAM to re-queue it.
Later when the resources become available the SIM queue must be unfrozen by returning a ccb with the <code>CAM_SIMQ_RELEASE</code> bit set in its status.
Otherwise, if all went well, link the CCB with the hardware control block (HCB) and mark it as queued.</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);

    if (hcb == NULL) {
        softc-&gt;flags |= RESOURCE_SHORTAGE;
        xpt_freeze_simq(sim, /*count*/1);
        ccb_h-&gt;status = CAM_REQUEUE_REQ;
        xpt_done(ccb);
        return;
    }

    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;
    ccb_h-&gt;status |= CAM_SIM_QUEUED;</pre></div></div><div class=paragraph><p>Extract the target data from CCB into the hardware control block.
Check if we are asked to assign a tag and if yes then generate an unique tag and build the SCSI tag messages.
The SIM driver is also responsible for negotiations with the devices to set the maximal mutually supported bus width, synchronous rate and offset.</p></div><div class="literalblock programlisting"><div class=content><pre>    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-&gt;target_lun;
    generate_identify_message(hcb);
    if (ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE)
        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);
    if (!target_negotiated(hcb))
        generate_negotiation_messages(hcb);</pre></div></div><div class=paragraph><p>Then set up the SCSI command.
The command storage may be specified in the CCB in many interesting ways, specified by the CCB flags.
The command buffer can be contained in CCB or pointed to, in the latter case the pointer may be physical or virtual.
Since the hardware commonly needs physical address we always convert the address to the physical one, typically using the busdma API.</p></div><div class=paragraph><p>In case if a physical address is requested it is OK to return the CCB with the status <code>CAM_REQ_INVALID</code>, the current drivers do that.
If necessary a physical address can be also converted or mapped back to a virtual address but with big pain, so we do not do that.</p></div><div class="literalblock programlisting"><div class=content><pre>    if (ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {
        /* CDB is a pointer */
        if (!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {
            /* CDB pointer is virtual */
            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);
        } else {
            /* CDB pointer is physical */
            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;
        }
    } else {
        /* CDB is in the ccb (buffer) */
        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);
    }
    hcb-&gt;cmdlen = csio-&gt;cdb_len;</pre></div></div><div class=paragraph><p>Now it is time to set up the data.
Again, the data storage may be specified in the CCB in many interesting ways, specified by the CCB flags.
First we get the direction of the data transfer.
The simplest case is if there is no data to transfer:</p></div><div class="literalblock programlisting"><div class=content><pre>    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);

    if (dir == CAM_DIR_NONE)
        goto end_data;</pre></div></div><div class=paragraph><p>Then we check if the data is in one chunk or in a scatter-gather list, and the addresses are physical or virtual.
The SCSI controller may be able to handle only a limited number of chunks of limited length.
If the request hits this limitation we return an error.
We use a special function to return the CCB to handle in one place the HCB resource shortages.
The functions to add chunks are driver-dependent, and here we leave them without detailed implementation.
See description of the SCSI command (CDB) handling for the details on the address-translation issues.
If some variation is too difficult or impossible to implement with a particular card it is OK to return the status <code>CAM_REQ_INVALID</code>.
Actually, it seems like the scatter-gather ability is not used anywhere in the CAM code now.
But at least the case for a single non-scattered virtual buffer must be implemented, it is actively used by CAM.</p></div><div class="literalblock programlisting"><div class=content><pre>    int rv;

    initialize_hcb_for_data(hcb);

    if ((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {
        /* single buffer */
        if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {
            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);
            }
        } else {
            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);
        }
    } else {
        int i;
        struct bus_dma_segment *segs;
        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;

        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {
            /* The SG list pointer is physical */
            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-&gt;sglist_cnt);
        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {
            /* SG buffer pointers are virtual */
            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {
                rv = add_virtual_chunk(hcb, segs[i].ds_addr,
                    segs[i].ds_len, dir);
                if (rv != CAM_REQ_CMP)
                    break;
            }
        } else {
            /* SG buffer pointers are physical */
            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {
                rv = add_physical_chunk(hcb, segs[i].ds_addr,
                    segs[i].ds_len, dir);
                if (rv != CAM_REQ_CMP)
                    break;
            }
        }
    }
    if (rv != CAM_REQ_CMP) {
        /* we expect that add_*_chunk() functions return CAM_REQ_CMP
         * if they added a chunk successfully, CAM_REQ_TOO_BIG if
         * the request is too big (too many bytes or too many chunks),
         * CAM_REQ_INVALID in case of other troubles
         */
        free_hcb_and_ccb_done(hcb, ccb, rv);
        return;
    }
    end_data:</pre></div></div><div class=paragraph><p>If disconnection is disabled for this CCB we pass this information to the hcb:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)
        hcb_disable_disconnect(hcb);</pre></div></div><div class=paragraph><p>If the controller is able to run REQUEST SENSE command all by itself then the value of the flag CAM_DIS_AUTOSENSE should also be passed to it, to prevent automatic REQUEST SENSE if the CAM subsystem does not want it.</p></div><div class=paragraph><p>The only thing left is to set up the timeout, pass our hcb to the hardware and return, the rest will be done by the interrupt handler (or timeout handler).</p></div><div class="literalblock programlisting"><div class=content><pre>    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,
        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */
    put_hcb_into_hardware_queue(hcb);
    return;</pre></div></div><div class=paragraph><p>And here is a possible implementation of the function returning CCB:</p></div><div class="literalblock programlisting"><div class=content><pre>    static void
    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t status)
    {
        struct xxx_softc *softc = hcb-&gt;softc;

        ccb-&gt;ccb_h.ccb_hcb = 0;
        if (hcb != NULL) {
            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);
            /* we&#39;re about to free a hcb, so the shortage has ended */
            if (softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {
                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;
                status |= CAM_RELEASE_SIMQ;
            }
            free_hcb(hcb); /* also removes hcb from any internal lists */
        }
        ccb-&gt;ccb_h.status = status |
            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));
        xpt_done(ccb);
    }</pre></div></div></div><div class=sect3><h4 id=_xpt_reset_dev_send_the_scsi_bus_device_reset_message_to_a_device>12.5.2. <em>XPT_RESET_DEV</em> - send the SCSI "BUS DEVICE RESET" message to a device<a class=anchor href=#_xpt_reset_dev_send_the_scsi_bus_device_reset_message_to_a_device></a></h4><div class=paragraph><p>There is no data transferred in CCB except the header and the most interesting argument of it is target_id.
Depending on the controller hardware a hardware control block just like for the XPT_SCSI_IO request may be constructed (see XPT_SCSI_IO request description) and sent to the controller or the SCSI controller may be immediately programmed to send this RESET message to the device or this request may be just not supported (and return the status <code>CAM_REQ_INVALID</code>).
Also on completion of the request all the disconnected transactions for this target must be aborted (probably in the interrupt routine).</p></div><div class=paragraph><p>Also all the current negotiations for the target are lost on reset, so they might be cleaned too.
Or they clearing may be deferred, because anyway the target would request re-negotiation on the next transaction.</p></div></div><div class=sect3><h4 id=_xpt_reset_bus_send_the_reset_signal_to_the_scsi_bus>12.5.3. <em>XPT_RESET_BUS</em> - send the RESET signal to the SCSI bus<a class=anchor href=#_xpt_reset_bus_send_the_reset_signal_to_the_scsi_bus></a></h4><div class=paragraph><p>No arguments are passed in the CCB, the only interesting argument is the SCSI bus indicated by the struct sim pointer.</p></div><div class=paragraph><p>A minimalistic implementation would forget the SCSI negotiations for all the devices on the bus and return the status CAM_REQ_CMP.</p></div><div class=paragraph><p>The proper implementation would in addition actually reset the SCSI bus (possible also reset the SCSI controller) and mark all the CCBs being processed, both those in the hardware queue and those being disconnected, as done with the status CAM_SCSI_BUS_RESET.
Like:</p></div><div class="literalblock programlisting"><div class=content><pre>    int targ, lun;
    struct xxx_hcb *h, *hh;
    struct ccb_trans_settings neg;
    struct cam_path *path;

    /* The SCSI bus reset may take a long time, in this case its completion
     * should be checked by interrupt or timeout. But for simplicity
     * we assume here that it is really fast.
     */
    reset_scsi_bus(softc);

    /* drop all enqueued CCBs */
    for (h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
        hh = h-&gt;next;
        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
    }

    /* the clean values of negotiations to report */
    neg.bus_width = 8;
    neg.sync_period = neg.sync_offset = 0;
    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);

    /* drop all disconnected CCBs and clean negotiations  */
    for (targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {
        clean_negotiations(softc, targ);

        /* report the event if possible */
        if (xpt_create_path(&amp;path, /*periph*/NULL,
                cam_sim_path(sim), targ,
                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {
            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
            xpt_free_path(path);
        }

        for (lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
            for (h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {
                hh=h-&gt;next;
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
            }
    }

    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);

    /* report the event */
    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);
    return;</pre></div></div><div class=paragraph><p>Implementing the SCSI bus reset as a function may be a good idea because it would be re-used by the timeout function as a last resort if the things go wrong.</p></div></div><div class=sect3><h4 id=_xpt_abort_abort_the_specified_ccb>12.5.4. <em>XPT_ABORT</em> - abort the specified CCB<a class=anchor href=#_xpt_abort_abort_the_specified_ccb></a></h4><div class=paragraph><p>The arguments are transferred in the instance "struct ccb_abort cab" of the union ccb.
The only argument field in it is:</p></div><div class=ulist><ul><li><p><em>abort_ccb</em> - pointer to the CCB to be aborted</p></li></ul></div><div class=paragraph><p>If the abort is not supported just return the status CAM_UA_ABORT.
This is also the easy way to minimally implement this call, return CAM_UA_ABORT in any case.</p></div><div class=paragraph><p>The hard way is to implement this request honestly.
First check that abort applies to a SCSI transaction:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb *abort_ccb;
    abort_ccb = ccb-&gt;cab.abort_ccb;

    if (abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {
        ccb-&gt;ccb_h.status = CAM_UA_ABORT;
        xpt_done(ccb);
        return;
    }</pre></div></div><div class=paragraph><p>Then it is necessary to find this CCB in our queue.
This can be done by walking the list of all our hardware control blocks in search for one associated with this CCB:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_hcb *hcb, *h;

    hcb = NULL;

    /* We assume that softc-&gt;first_hcb is the head of the list of all
     * HCBs associated with this bus, including those enqueued for
     * processing, being processed by hardware and disconnected ones.
     */
    for (h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {
        if (h-&gt;ccb == abort_ccb) {
            hcb = h;
            break;
        }
    }

    if (hcb == NULL) {
        /* no such CCB in our queue */
        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;
        xpt_done(ccb);
        return;
    }

    hcb=found_hcb;</pre></div></div><div class=paragraph><p>Now we look at the current processing status of the HCB.
It may be either sitting in the queue waiting to be sent to the SCSI bus, being transferred right now, or disconnected and waiting for the result of the command, or actually completed by hardware but not yet marked as done by software.
To make sure that we do not get in any races with hardware we mark the HCB as being aborted, so that if this HCB is about to be sent to the SCSI bus the SCSI controller will see this flag and skip it.</p></div><div class="literalblock programlisting"><div class=content><pre>    int hstatus;

    /* shown as a function, in case special action is needed to make
     * this flag visible to hardware
     */
    set_hcb_flags(hcb, HCB_BEING_ABORTED);

    abort_again:

    hstatus = get_hcb_status(hcb);
    switch (hstatus) {
    case HCB_SITTING_IN_QUEUE:
        remove_hcb_from_hardware_queue(hcb);
        /* FALLTHROUGH */
    case HCB_COMPLETED:
        /* this is an easy case */
        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);
        break;</pre></div></div><div class=paragraph><p>If the CCB is being transferred right now we would like to signal to the SCSI controller in some hardware-dependent way that we want to abort the current transfer.
The SCSI controller would set the SCSI ATTENTION signal and when the target responds to it send an ABORT message.
We also reset the timeout to make sure that the target is not sleeping forever.
If the command would not get aborted in some reasonable time like 10 seconds the timeout routine would go ahead and reset the whole SCSI bus.
Since the command will be aborted in some reasonable time we can just return the abort request now as successfully completed, and mark the aborted CCB as aborted (but not mark it as done yet).</p></div><div class="literalblock programlisting"><div class=content><pre>    case HCB_BEING_TRANSFERRED:
        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);
        abort_ccb-&gt;ccb_h.timeout_ch =
            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);
        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;
        /* ask the controller to abort that HCB, then generate
         * an interrupt and stop
         */
        if (signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {
            /* oops, we missed the race with hardware, this transaction
             * got off the bus before we aborted it, try again */
            goto abort_again;
        }

        break;</pre></div></div><div class=paragraph><p>If the CCB is in the list of disconnected then set it up as an abort request and re-queue it at the front of hardware queue.
Reset the timeout and report the abort request to be completed.</p></div><div class="literalblock programlisting"><div class=content><pre>    case HCB_DISCONNECTED:
        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);
        abort_ccb-&gt;ccb_h.timeout_ch =
            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);
        put_abort_message_into_hcb(hcb);
        put_hcb_at_the_front_of_hardware_queue(hcb);
        break;
    }
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre></div></div><div class=paragraph><p>That is all for the ABORT request, although there is one more issue.
As the ABORT message cleans all the ongoing transactions on a LUN we have to mark all the other active transactions on this LUN as aborted.
That should be done in the interrupt routine, after the transaction gets aborted.</p></div><div class=paragraph><p>Implementing the CCB abort as a function may be quite a good idea, this function can be re-used if an I/O transaction times out.
The only difference would be that the timed out transaction would return the status CAM_CMD_TIMEOUT for the timed out request.
Then the case XPT_ABORT would be small, like that:</p></div><div class="literalblock programlisting"><div class=content><pre>    case XPT_ABORT:
        struct ccb *abort_ccb;
        abort_ccb = ccb-&gt;cab.abort_ccb;

        if (abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {
            ccb-&gt;ccb_h.status = CAM_UA_ABORT;
            xpt_done(ccb);
            return;
        }
        if (xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)
            /* no such CCB in our queue */
            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;
        else
            ccb-&gt;ccb_h.status = CAM_REQ_CMP;
        xpt_done(ccb);
        return;</pre></div></div></div><div class=sect3><h4 id=_xpt_set_tran_settings_explicitly_set_values_of_scsi_transfer_settings>12.5.5. <em>XPT_SET_TRAN_SETTINGS</em> - explicitly set values of SCSI transfer settings<a class=anchor href=#_xpt_set_tran_settings_explicitly_set_values_of_scsi_transfer_settings></a></h4><div class=paragraph><p>The arguments are transferred in the instance "struct ccb_trans_setting cts" of the union ccb:</p></div><div class=ulist><ul><li><p><em>valid</em> - a bitmask showing which settings should be updated:</p><div class=ulist><ul><li><p><em>CCB_TRANS_SYNC_RATE_VALID</em> - synchronous transfer rate</p></li><li><p><em>CCB_TRANS_SYNC_OFFSET_VALID</em> - synchronous offset</p></li><li><p><em>CCB_TRANS_BUS_WIDTH_VALID</em> - bus width</p></li><li><p><em>CCB_TRANS_DISC_VALID</em> - set enable/disable disconnection</p></li><li><p><em>CCB_TRANS_TQ_VALID</em> - set enable/disable tagged queuing</p></li></ul></div></li><li><p><em>flags</em> - consists of two parts, binary arguments and identification of sub-operations.
The binary arguments are:</p><div class=ulist><ul><li><p><em>CCB_TRANS_DISC_ENB</em> - enable disconnection</p></li><li><p><em>CCB_TRANS_TAG_ENB</em> - enable tagged queuing</p></li></ul></div></li><li><p>the sub-operations are:</p><div class=ulist><ul><li><p><em>CCB_TRANS_CURRENT_SETTINGS</em> - change the current negotiations</p></li><li><p><em>CCB_TRANS_USER_SETTINGS</em> - remember the desired user values sync_period, sync_offset - self-explanatory, if sync_offset==0 then the asynchronous mode is requested bus_width - bus width, in bits (not bytes)</p></li></ul></div></li></ul></div><div class=paragraph><p>Two sets of negotiated parameters are supported, the user settings and the current settings.
The user settings are not really used much in the SIM drivers, this is mostly just a piece of memory where the upper levels can store (and later recall) its ideas about the parameters.
Setting the user parameters does not cause re-negotiation of the transfer rates.
But when the SCSI controller does a negotiation it must never set the values higher than the user parameters, so it is essentially the top boundary.</p></div><div class=paragraph><p>The current settings are, as the name says, current.
Changing them means that the parameters must be re-negotiated on the next transfer.
Again, these "new current settings" are not supposed to be forced on the device, just they are used as the initial step of negotiations.
Also they must be limited by actual capabilities of the SCSI controller: for example, if the SCSI controller has 8-bit bus and the request asks to set 16-bit wide transfers this parameter must be silently truncated to 8-bit transfers before sending it to the device.</p></div><div class=paragraph><p>One caveat is that the bus width and synchronous parameters are per target while the disconnection and tag enabling parameters are per lun.</p></div><div class=paragraph><p>The recommended implementation is to keep 3 sets of negotiated (bus width and synchronous transfer) parameters:</p></div><div class=ulist><ul><li><p><em>user</em> - the user set, as above</p></li><li><p><em>current</em> - those actually in effect</p></li><li><p><em>goal</em> - those requested by setting of the "current" parameters</p></li></ul></div><div class=paragraph><p>The code looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct ccb_trans_settings *cts;
    int targ, lun;
    int flags;

    cts = &amp;ccb-&gt;cts;
    targ = ccb_h-&gt;target_id;
    lun = ccb_h-&gt;target_lun;
    flags = cts-&gt;flags;
    if (flags &amp; CCB_TRANS_USER_SETTINGS) {
        if (flags &amp; CCB_TRANS_SYNC_RATE_VALID)
            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;
        if (flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)
            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;
        if (flags &amp; CCB_TRANS_BUS_WIDTH_VALID)
            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;

        if (flags &amp; CCB_TRANS_DISC_VALID) {
            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;
            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;
        }
        if (flags &amp; CCB_TRANS_TQ_VALID) {
            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;
            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;
        }
    }
    if (flags &amp; CCB_TRANS_CURRENT_SETTINGS) {
        if (flags &amp; CCB_TRANS_SYNC_RATE_VALID)
            softc-&gt;goal_sync_period[targ] =
                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);
        if (flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)
            softc-&gt;goal_sync_offset[targ] =
                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);
        if (flags &amp; CCB_TRANS_BUS_WIDTH_VALID)
            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, OUR_BUS_WIDTH);

        if (flags &amp; CCB_TRANS_DISC_VALID) {
            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;
            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;
        }
        if (flags &amp; CCB_TRANS_TQ_VALID) {
            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;
            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;
        }
    }
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre></div></div><div class=paragraph><p>Then when the next I/O request will be processed it will check if it has to re-negotiate, for example by calling the function target_negotiated(hcb).
It can be implemented like this:</p></div><div class="literalblock programlisting"><div class=content><pre>    int
    target_negotiated(struct xxx_hcb *hcb)
    {
        struct softc *softc = hcb-&gt;softc;
        int targ = hcb-&gt;targ;

        if (softc-&gt;current_sync_period[targ] != softc-&gt;goal_sync_period[targ]
        || softc-&gt;current_sync_offset[targ] != softc-&gt;goal_sync_offset[targ]
        || softc-&gt;current_bus_width[targ] != softc-&gt;goal_bus_width[targ])
            return 0; /* FALSE */
        else
            return 1; /* TRUE */
    }</pre></div></div><div class=paragraph><p>After the values are re-negotiated the resulting values must be assigned to both current and goal parameters, so for future I/O transactions the current and goal parameters would be the same and <code>target_negotiated()</code> would return TRUE.
When the card is initialized (in <code>xxx_attach()</code>) the current negotiation values must be initialized to narrow asynchronous mode, the goal and current values must be initialized to the maximal values supported by controller.</p></div></div><div class=sect3><h4 id=_xpt_get_tran_settings_get_values_of_scsi_transfer_settings>12.5.6. <em>XPT_GET_TRAN_SETTINGS</em> - get values of SCSI transfer settings<a class=anchor href=#_xpt_get_tran_settings_get_values_of_scsi_transfer_settings></a></h4><div class=paragraph><p>This operations is the reverse of XPT_SET_TRAN_SETTINGS.
Fill up the CCB instance "struct ccb_trans_setting cts" with data as requested by the flags CCB_TRANS_CURRENT_SETTINGS or CCB_TRANS_USER_SETTINGS (if both are set then the existing drivers return the current settings).
Set all the bits in the valid field.</p></div></div><div class=sect3><h4 id=_xpt_calc_geometry_calculate_logical_bios_geometry_of_the_disk>12.5.7. <em>XPT_CALC_GEOMETRY</em> - calculate logical (BIOS) geometry of the disk<a class=anchor href=#_xpt_calc_geometry_calculate_logical_bios_geometry_of_the_disk></a></h4><div class=paragraph><p>The arguments are transferred in the instance "struct ccb_calc_geometry ccg" of the union ccb:</p></div><div class=ulist><ul><li><p><em>block_size</em> - input, block (A.K.A sector) size in bytes</p></li><li><p><em>volume_size</em> - input, volume size in bytes</p></li><li><p><em>cylinders</em> - output, logical cylinders</p></li><li><p><em>heads</em> - output, logical heads</p></li><li><p><em>secs_per_track</em> - output, logical sectors per track</p></li></ul></div><div class=paragraph><p>If the returned geometry differs much enough from what the SCSI controller BIOS thinks and a disk on this SCSI controller is used as bootable the system may not be able to boot.
The typical calculation example taken from the aic7xxx driver is:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct    ccb_calc_geometry *ccg;
    u_int32_t size_mb;
    u_int32_t secs_per_cylinder;
    int   extended;

    ccg = &amp;ccb-&gt;ccg;
    size_mb = ccg-&gt;volume_size
        / ((1024L * 1024L) / ccg-&gt;block_size);
    extended = check_cards_EEPROM_for_extended_geometry(softc);

    if (size_mb &gt; 1024 &amp;&amp; extended) {
        ccg-&gt;heads = 255;
        ccg-&gt;secs_per_track = 63;
    } else {
        ccg-&gt;heads = 64;
        ccg-&gt;secs_per_track = 32;
    }
    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;
    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre></div></div><div class=paragraph><p>This gives the general idea, the exact calculation depends on the quirks of the particular BIOS.
If BIOS provides no way set the "extended translation" flag in EEPROM this flag should normally be assumed equal to 1.
Other popular geometries are:</p></div><div class="literalblock programlisting"><div class=content><pre>    128 heads, 63 sectors - Symbios controllers
    16 heads, 63 sectors - old controllers</pre></div></div><div class=paragraph><p>Some system BIOSes and SCSI BIOSes fight with each other with variable success, for example a combination of Symbios 875/895 SCSI and Phoenix BIOS can give geometry 128/63 after power up and 255/63 after a hard reset or soft reboot.</p></div></div><div class=sect3><h4 id=_xpt_path_inq_path_inquiry_in_other_words_get_the_sim_driver_and_scsi_controller_also_known_as_hba_host_bus_adapter_properties>12.5.8. <em>XPT_PATH_INQ</em> - path inquiry, in other words get the SIM driver and SCSI controller (also known as HBA - Host Bus Adapter) properties<a class=anchor href=#_xpt_path_inq_path_inquiry_in_other_words_get_the_sim_driver_and_scsi_controller_also_known_as_hba_host_bus_adapter_properties></a></h4><div class=paragraph><p>The properties are returned in the instance "struct ccb_pathinq cpi" of the union ccb:</p></div><div class=ulist><ul><li><p>version_num - the SIM driver version number, now all drivers use 1</p></li><li><p>hba_inquiry - bitmask of features supported by the controller:</p><div class=ulist><ul><li><p>PI_MDP_ABLE - supports MDP message (something from SCSI3?)</p></li><li><p>PI_WIDE_32 - supports 32 bit wide SCSI</p></li><li><p>PI_WIDE_16 - supports 16 bit wide SCSI</p></li><li><p>PI_SDTR_ABLE - can negotiate synchronous transfer rate</p></li><li><p>PI_LINKED_CDB - supports linked commands</p></li><li><p>PI_TAG_ABLE - supports tagged commands</p></li><li><p>PI_SOFT_RST - supports soft reset alternative (hard reset and soft reset are mutually exclusive within a SCSI bus)</p></li></ul></div></li><li><p>target_sprt - flags for target mode support, 0 if unsupported</p></li><li><p>hba_misc - miscellaneous controller features:</p><div class=ulist><ul><li><p>PIM_SCANHILO - bus scans from high ID to low ID</p></li><li><p>PIM_NOREMOVE - removable devices not included in scan</p></li><li><p>PIM_NOINITIATOR - initiator role not supported</p></li><li><p>PIM_NOBUSRESET - user has disabled initial BUS RESET</p></li></ul></div></li><li><p>hba_eng_cnt - mysterious HBA engine count, something related to compression, now is always set to 0</p></li><li><p>vuhba_flags - vendor-unique flags, unused now</p></li><li><p>max_target - maximal supported target ID (7 for 8-bit bus, 15 for 16-bit bus, 127 for Fibre Channel)</p></li><li><p>max_lun - maximal supported LUN ID (7 for older SCSI controllers, 63 for newer ones)</p></li><li><p>async_flags - bitmask of installed Async handler, unused now</p></li><li><p>hpath_id - highest Path ID in the subsystem, unused now</p></li><li><p>unit_number - the controller unit number, cam_sim_unit(sim)</p></li><li><p>bus_id - the bus number, cam_sim_bus(sim)</p></li><li><p>initiator_id - the SCSI ID of the controller itself</p></li><li><p>base_transfer_speed - nominal transfer speed in KB/s for asynchronous narrow transfers, equals to 3300 for SCSI</p></li><li><p>sim_vid - SIM driver’s vendor id, a zero-terminated string of maximal length SIM_IDLEN including the terminating zero</p></li><li><p>hba_vid - SCSI controller’s vendor id, a zero-terminated string of maximal length HBA_IDLEN including the terminating zero</p></li><li><p>dev_name - device driver name, a zero-terminated string of maximal length DEV_IDLEN including the terminating zero, equal to cam_sim_name(sim)</p></li></ul></div><div class=paragraph><p>The recommended way of setting the string fields is using strncpy, like:</p></div><div class="literalblock programlisting"><div class=content><pre>    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);</pre></div></div><div class=paragraph><p>After setting the values set the status to CAM_REQ_CMP and mark the CCB as done.</p></div></div></div><div class=sect2><h3 id=scsi-polling>12.6. Polling xxx_poll<a class=anchor href=#scsi-polling></a></h3><div class="literalblock programlisting"><div class=content><pre>static void xxx_poll(struct cam_sim *);</pre></div></div><div class=paragraph><p>The poll function is used to simulate the interrupts when the interrupt subsystem is not functioning (for example, when the system has crashed and is creating the system dump).
The CAM subsystem sets the proper interrupt level before calling the poll routine.
So all it needs to do is to call the interrupt routine (or the other way around, the poll routine may be doing the real action and the interrupt routine would just call the poll routine).
Why bother about a separate function then?
This has to do with different calling conventions.
The <code>xxx_poll</code> routine gets the struct cam_sim pointer as its argument while the PCI interrupt routine by common convention gets pointer to the struct <code>xxx_softc</code> and the ISA interrupt routine gets just the device unit number.
So the poll routine would normally look as:</p></div><div class="literalblock programlisting"><div class=content><pre>static void
xxx_poll(struct cam_sim *sim)
{
    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */
}</pre></div></div><div class=paragraph><p>or</p></div><div class="literalblock programlisting"><div class=content><pre>static void
xxx_poll(struct cam_sim *sim)
{
    xxx_intr(cam_sim_unit(sim)); /* for ISA device */
}</pre></div></div></div><div class=sect2><h3 id=scsi-async>12.7. Asynchronous Events<a class=anchor href=#scsi-async></a></h3><div class=paragraph><p>If an asynchronous event callback has been set up then the callback function should be defined.</p></div><div class="literalblock programlisting"><div class=content><pre>static void
ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void *arg)</pre></div></div><div class=ulist><ul><li><p>callback_arg - the value supplied when registering the callback</p></li><li><p>code - identifies the type of event</p></li><li><p>path - identifies the devices to which the event applies</p></li><li><p>arg - event-specific argument</p></li></ul></div><div class=paragraph><p>Implementation for a single type of event, AC_LOST_DEVICE, looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_softc *softc;
    struct cam_sim *sim;
    int targ;
    struct ccb_trans_settings neg;

    sim = (struct cam_sim *)callback_arg;
    softc = (struct xxx_softc *)cam_sim_softc(sim);
    switch (code) {
    case AC_LOST_DEVICE:
        targ = xpt_path_target_id(path);
        if (targ &lt;= OUR_MAX_SUPPORTED_TARGET) {
            clean_negotiations(softc, targ);
            /* send indication to CAM */
            neg.bus_width = 8;
            neg.sync_period = neg.sync_offset = 0;
            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);
            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
        }
        break;
    default:
        break;
    }</pre></div></div></div><div class=sect2><h3 id=scsi-interrupts>12.8. Interrupts<a class=anchor href=#scsi-interrupts></a></h3><div class=paragraph><p>The exact type of the interrupt routine depends on the type of the peripheral bus (PCI, ISA and so on) to which the SCSI controller is connected.</p></div><div class=paragraph><p>The interrupt routines of the SIM drivers run at the interrupt level splcam.
So <code>splcam()</code> should be used in the driver to synchronize activity between the interrupt routine and the rest of the driver (for a multiprocessor-aware driver things get yet more interesting but we ignore this case here).
The pseudo-code in this document happily ignores the problems of synchronization.
The real code must not ignore them.
A simple-minded approach is to set <code>splcam()</code> on the entry to the other routines and reset it on return thus protecting them by one big critical section.
To make sure that the interrupt level will be always restored a wrapper function can be defined, like:</p></div><div class="literalblock programlisting"><div class=content><pre>    static void
    xxx_action(struct cam_sim *sim, union ccb *ccb)
    {
        int s;
        s = splcam();
        xxx_action1(sim, ccb);
        splx(s);
    }

    static void
    xxx_action1(struct cam_sim *sim, union ccb *ccb)
    {
        ... process the request ...
    }</pre></div></div><div class=paragraph><p>This approach is simple and robust but the problem with it is that interrupts may get blocked for a relatively long time and this would negatively affect the system’s performance.
On the other hand the functions of the <code>spl()</code> family have rather high overhead, so vast amount of tiny critical sections may not be good either.</p></div><div class=paragraph><p>The conditions handled by the interrupt routine and the details depend very much on the hardware.
We consider the set of "typical" conditions.</p></div><div class=paragraph><p>First, we check if a SCSI reset was encountered on the bus (probably caused by another SCSI controller on the same SCSI bus).
If so we drop all the enqueued and disconnected requests, report the events and re-initialize our SCSI controller.
It is important that during this initialization the controller will not issue another reset or else two controllers on the same SCSI bus could ping-pong resets forever.
The case of fatal controller error/hang could be handled in the same place, but it will probably need also sending RESET signal to the SCSI bus to reset the status of the connections with the SCSI devices.</p></div><div class="literalblock programlisting"><div class=content><pre>    int fatal=0;
    struct ccb_trans_settings neg;
    struct cam_path *path;

    if (detected_scsi_reset(softc)
    || (fatal = detected_fatal_controller_error(softc))) {
        int targ, lun;
        struct xxx_hcb *h, *hh;

        /* drop all enqueued CCBs */
        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
            hh = h-&gt;next;
            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
        }

        /* the clean values of negotiations to report */
        neg.bus_width = 8;
        neg.sync_period = neg.sync_offset = 0;
        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);

        /* drop all disconnected CCBs and clean negotiations  */
        for (targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {
            clean_negotiations(softc, targ);

            /* report the event if possible */
            if (xpt_create_path(&amp;path, /*periph*/NULL,
                    cam_sim_path(sim), targ,
                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {
                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
                xpt_free_path(path);
            }

            for (lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
                for (h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {
                    hh=h-&gt;next;
                    if (fatal)
                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_UNREC_HBA_ERROR);
                    else
                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
                }
        }

        /* report the event */
        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);

        /* re-initialization may take a lot of time, in such case
         * its completion should be signaled by another interrupt or
         * checked on timeout - but for simplicity we assume here that
         * it is really fast
         */
        if (!fatal) {
            reinitialize_controller_without_scsi_reset(softc);
        } else {
            reinitialize_controller_with_scsi_reset(softc);
        }
        schedule_next_hcb(softc);
        return;
    }</pre></div></div><div class=paragraph><p>If interrupt is not caused by a controller-wide condition then probably something has happened to the current hardware control block.
Depending on the hardware there may be other non-HCB-related events, we just do not consider them here.
Then we analyze what happened to this HCB:</p></div><div class="literalblock programlisting"><div class=content><pre>    struct xxx_hcb *hcb, *h, *hh;
    int hcb_status, scsi_status;
    int ccb_status;
    int targ;
    int lun_to_freeze;

    hcb = get_current_hcb(softc);
    if (hcb == NULL) {
        /* either stray interrupt or something went very wrong
         * or this is something hardware-dependent
         */
        handle as necessary;
        return;
    }

    targ = hcb-&gt;target;
    hcb_status = get_status_of_current_hcb(softc);</pre></div></div><div class=paragraph><p>First we check if the HCB has completed and if so we check the returned SCSI status.</p></div><div class="literalblock programlisting"><div class=content><pre>    if (hcb_status == COMPLETED) {
        scsi_status = get_completion_status(hcb);</pre></div></div><div class=paragraph><p>Then look if this status is related to the REQUEST SENSE command and if so handle it in a simple way.</p></div><div class="literalblock programlisting"><div class=content><pre>        if (hcb-&gt;flags &amp; DOING_AUTOSENSE) {
            if (scsi_status == GOOD) { /* autosense was successful */
                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;
                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);
            } else {
        autosense_failed:
                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);
            }
            schedule_next_hcb(softc);
            return;
        }</pre></div></div><div class=paragraph><p>Else the command itself has completed, pay more attention to details.
If auto-sense is not disabled for this CCB and the command has failed with sense data then run REQUEST SENSE command to receive that data.</p></div><div class="literalblock programlisting"><div class=content><pre>        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;
        calculate_residue(hcb);

        if ((hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0
        &amp;&amp; (scsi_status == CHECK_CONDITION
                || scsi_status == COMMAND_TERMINATED)) {
            /* start auto-SENSE */
            hcb-&gt;flags |= DOING_AUTOSENSE;
            setup_autosense_command_in_hcb(hcb);
            restart_current_hcb(softc);
            return;
        }
        if (scsi_status == GOOD)
            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);
        else
            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);
        schedule_next_hcb(softc);
        return;
    }</pre></div></div><div class=paragraph><p>One typical thing would be negotiation events: negotiation messages received from a SCSI target (in answer to our negotiation attempt or by target’s initiative) or the target is unable to negotiate (rejects our negotiation messages or does not answer them).</p></div><div class="literalblock programlisting"><div class=content><pre>    switch (hcb_status) {
    case TARGET_REJECTED_WIDE_NEG:
        /* revert to 8-bit bus */
        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = 8;
        /* report the event */
        neg.bus_width = 8;
        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
        continue_current_hcb(softc);
        return;
    case TARGET_ANSWERED_WIDE_NEG:
        {
            int wd;

            wd = get_target_bus_width_request(softc);
            if (wd &lt;= softc-&gt;goal_bus_width[targ]) {
                /* answer is acceptable */
                softc-&gt;current_bus_width[targ] =
                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;

                /* report the event */
                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
            } else {
                prepare_reject_message(hcb);
            }
        }
        continue_current_hcb(softc);
        return;
    case TARGET_REQUESTED_WIDE_NEG:
        {
            int wd;

            wd = get_target_bus_width_request(softc);
            wd = min (wd, OUR_BUS_WIDTH);
            wd = min (wd, softc-&gt;user_bus_width[targ]);

            if (wd != softc-&gt;current_bus_width[targ]) {
                /* the bus width has changed */
                softc-&gt;current_bus_width[targ] =
                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;

                /* report the event */
                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
            }
            prepare_width_nego_rsponse(hcb, wd);
        }
        continue_current_hcb(softc);
        return;
    }</pre></div></div><div class=paragraph><p>Then we handle any errors that could have happened during auto-sense in the same simple-minded way as before.
Otherwise we look closer at the details again.</p></div><div class="literalblock programlisting"><div class=content><pre>    if (hcb-&gt;flags &amp; DOING_AUTOSENSE)
        goto autosense_failed;

    switch (hcb_status) {</pre></div></div><div class=paragraph><p>The next event we consider is unexpected disconnect.
Which is considered normal after an ABORT or BUS DEVICE RESET message and abnormal in other cases.</p></div><div class="literalblock programlisting"><div class=content><pre>    case UNEXPECTED_DISCONNECT:
        if (requested_abort(hcb)) {
            /* abort affects all commands on that target+LUN, so
             * mark all disconnected HCBs on that target+LUN as aborted too
             */
            for (h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];
                    h != NULL; h = hh) {
                hh=h-&gt;next;
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);
            }
            ccb_status = CAM_REQ_ABORTED;
        } else if (requested_bus_device_reset(hcb)) {
            int lun;

            /* reset affects all commands on that target, so
             * mark all disconnected HCBs on that target+LUN as reset
             */

            for (lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
                for (h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];
                        h != NULL; h = hh) {
                    hh=h-&gt;next;
                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
                }

            /* send event */
            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);

            /* this was the CAM_RESET_DEV request itself, it is completed */
            ccb_status = CAM_REQ_CMP;
        } else {
            calculate_residue(hcb);
            ccb_status = CAM_UNEXP_BUSFREE;
            /* request the further code to freeze the queue */
            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
            lun_to_freeze = hcb-&gt;lun;
        }
        break;</pre></div></div><div class=paragraph><p>If the target refuses to accept tags we notify CAM about that and return back all commands for this LUN:</p></div><div class="literalblock programlisting"><div class=content><pre>    case TAGS_REJECTED:
        /* report the event */
        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;
        neg.valid = CCB_TRANS_TQ_VALID;
        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);

        ccb_status = CAM_MSG_REJECT_REC;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = hcb-&gt;lun;
        break;</pre></div></div><div class=paragraph><p>Then we check a number of other conditions, with processing basically limited to setting the CCB status:</p></div><div class="literalblock programlisting"><div class=content><pre>    case SELECTION_TIMEOUT:
        ccb_status = CAM_SEL_TIMEOUT;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = CAM_LUN_WILDCARD;
        break;
    case PARITY_ERROR:
        ccb_status = CAM_UNCOR_PARITY;
        break;
    case DATA_OVERRUN:
    case ODD_WIDE_TRANSFER:
        ccb_status = CAM_DATA_RUN_ERR;
        break;
    default:
        /* all other errors are handled in a generic way */
        ccb_status = CAM_REQ_CMP_ERR;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = CAM_LUN_WILDCARD;
        break;
    }</pre></div></div><div class=paragraph><p>Then we check if the error was serious enough to freeze the input queue until it gets proceeded and do so if it is:</p></div><div class="literalblock programlisting"><div class=content><pre>    if (hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {
        /* freeze the queue */
        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);

        /* re-queue all commands for this target/LUN back to CAM */

        for (h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
            hh = h-&gt;next;

            if (targ == h-&gt;targ
            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze == h-&gt;lun))
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);
        }
    }
    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);
    schedule_next_hcb(softc);
    return;</pre></div></div><div class=paragraph><p>This concludes the generic interrupt handling although specific controllers may require some additions.</p></div></div><div class=sect2><h3 id=scsi-errors>12.9. Errors Summary<a class=anchor href=#scsi-errors></a></h3><div class=paragraph><p>When executing an I/O request many things may go wrong.
The reason of error can be reported in the CCB status with great detail.
Examples of use are spread throughout this document.
For completeness here is the summary of recommended responses for the typical error conditions:</p></div><div class=ulist><ul><li><p><em>CAM_RESRC_UNAVAIL</em> - some resource is temporarily unavailable and the SIM driver cannot generate an event when it will become available.
An example of this resource would be some intra-controller hardware resource for which the controller does not generate an interrupt when it becomes available.</p></li><li><p><em>CAM_UNCOR_PARITY</em> - unrecovered parity error occurred</p></li><li><p><em>CAM_DATA_RUN_ERR</em> - data overrun or unexpected data phase (going in other direction than specified in CAM_DIR_MASK) or odd transfer length for wide transfer</p></li><li><p><em>CAM_SEL_TIMEOUT</em> - selection timeout occurred (target does not respond)</p></li><li><p><em>CAM_CMD_TIMEOUT</em> - command timeout occurred (the timeout function ran)</p></li><li><p><em>CAM_SCSI_STATUS_ERROR</em> - the device returned error</p></li><li><p><em>CAM_AUTOSENSE_FAIL</em> - the device returned error and the REQUEST SENSE COMMAND failed</p></li><li><p><em>CAM_MSG_REJECT_REC</em> - MESSAGE REJECT message was received</p></li><li><p><em>CAM_SCSI_BUS_RESET</em> - received SCSI bus reset</p></li><li><p><em>CAM_REQ_CMP_ERR</em> - "impossible" SCSI phase occurred or something else as weird or just a generic error if further detail is not available</p></li><li><p><em>CAM_UNEXP_BUSFREE</em> - unexpected disconnect occurred</p></li><li><p><em>CAM_BDR_SENT</em> - BUS DEVICE RESET message was sent to the target</p></li><li><p><em>CAM_UNREC_HBA_ERROR</em> - unrecoverable Host Bus Adapter Error</p></li><li><p><em>CAM_REQ_TOO_BIG</em> - the request was too large for this controller</p></li><li><p><em>CAM_REQUEUE_REQ</em> - this request should be re-queued to preserve transaction ordering.
This typically occurs when the SIM recognizes an error that should freeze the queue and must place other queued requests for the target at the sim level back into the XPT queue.
Typical cases of such errors are selection timeouts, command timeouts and other like conditions.
In such cases the troublesome command returns the status indicating the error, the and the other commands which have not be sent to the bus yet get re-queued.</p></li><li><p><em>CAM_LUN_INVALID</em> - the LUN ID in the request is not supported by the SCSI controller</p></li><li><p><em>CAM_TID_INVALID</em> - the target ID in the request is not supported by the SCSI controller</p></li></ul></div></div><div class=sect2><h3 id=scsi-timeout>12.10. Timeout Handling<a class=anchor href=#scsi-timeout></a></h3><div class=paragraph><p>When the timeout for an HCB expires that request should be aborted, just like with an XPT_ABORT request.
The only difference is that the returned status of aborted request should be CAM_CMD_TIMEOUT instead of CAM_REQ_ABORTED (that is why implementation of the abort better be done as a function).
But there is one more possible problem: what if the abort request itself will get stuck?
In this case the SCSI bus should be reset, just like with an XPT_RESET_BUS request (and the idea about implementing it as a function called from both places applies here too).
Also we should reset the whole SCSI bus if a device reset request got stuck.
So after all the timeout function would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>static void
xxx_timeout(void *arg)
{
    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;
    struct xxx_softc *softc;
    struct ccb_hdr *ccb_h;

    softc = hcb-&gt;softc;
    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;

    if (hcb-&gt;flags &amp; HCB_BEING_ABORTED || ccb_h-&gt;func_code == XPT_RESET_DEV) {
        xxx_reset_bus(softc);
    } else {
        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);
    }
}</pre></div></div><div class=paragraph><p>When we abort a request all the other disconnected requests to the same target/LUN get aborted too.
So there appears a question, should we return them with status CAM_REQ_ABORTED or CAM_CMD_TIMEOUT?
The current drivers use CAM_CMD_TIMEOUT.
This seems logical because if one request got timed out then probably something really bad is happening to the device, so if they would not be disturbed they would time out by themselves.</p></div></div></div></div><div class=sect1><h2 id=usb>Chapter 13. USB Devices<a class=anchor href=#usb></a></h2><div class=sectionbody><div class=sect2><h3 id=usb-intro>13.1. Introduction<a class=anchor href=#usb-intro></a></h3><div class=paragraph><p>The Universal Serial Bus (USB) is a new way of attaching devices to personal computers. The bus architecture features two-way communication and has been developed as a response to devices becoming smarter and requiring more interaction with the host. USB support is included in all current PC chipsets and is therefore available in all recently built PCs. Apple’s introduction of the USB-only iMac has been a major incentive for hardware manufacturers to produce USB versions of their devices. The future PC specifications specify that all legacy connectors on PCs should be replaced by one or more USB connectors, providing generic plug and play capabilities. Support for USB hardware was available at a very early stage in NetBSD and was developed by Lennart Augustsson for the NetBSD project. The code has been ported to FreeBSD and we are currently maintaining a shared code base. For the implementation of the USB subsystem a number of features of USB are important.</p></div><div class=paragraph><p><em>Lennart Augustsson has done most of the implementation of the USB support for the NetBSD project. Many thanks for this incredible amount of work. Many thanks also to Ardy and Dirk for their comments and proofreading of this paper.</em></p></div><div class=ulist><ul><li><p>Devices connect to ports on the computer directly or on devices called hubs, forming a treelike device structure.</p></li><li><p>The devices can be connected and disconnected at run time.</p></li><li><p>Devices can suspend themselves and trigger resumes of the host system</p></li><li><p>As the devices can be powered from the bus, the host software has to keep track of power budgets for each hub.</p></li><li><p>Different quality of service requirements by the different device types together with the maximum of 126 devices that can be connected to the same bus, require proper scheduling of transfers on the shared bus to take full advantage of the 12Mbps bandwidth available. (over 400Mbps with USB 2.0)</p></li><li><p>Devices are intelligent and contain easily accessible information about themselves</p></li></ul></div><div class=paragraph><p>The development of drivers for the USB subsystem and devices connected to it is supported by the specifications that have been developed and will be developed. These specifications are publicly available from the USB home pages. Apple has been very strong in pushing for standards based drivers, by making drivers for the generic classes available in their operating system MacOS and discouraging the use of separate drivers for each new device. This chapter tries to collate essential information for a basic understanding of the USB 2.0 implementation stack in FreeBSD/NetBSD. It is recommended however to read it together with the relevant 2.0 specifications and other developer resources:</p></div><div class=ulist><ul><li><p>USB 2.0 Specification (<a href=http://www.usb.org/developers/docs/usb20_docs/>http://www.usb.org/developers/docs/usb20_docs/</a>)</p></li><li><p>Universal Host Controller Interface (UHCI) Specification (<a href=ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf>ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf)</a></p></li><li><p>Open Host Controller Interface (OHCI) Specification(<a href=ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf>ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf</a>)</p></li><li><p>Developer section of USB home page (<a href=http://www.usb.org/developers/>http://www.usb.org/developers/</a>)</p></li></ul></div><div class=sect3><h4 id=_structure_of_the_usb_stack>13.1.1. Structure of the USB Stack<a class=anchor href=#_structure_of_the_usb_stack></a></h4><div class=paragraph><p>The USB support in FreeBSD can be split into three layers. The lowest layer contains the host controller driver, providing a generic interface to the hardware and its scheduling facilities. It supports initialisation of the hardware, scheduling of transfers and handling of completed and/or failed transfers. Each host controller driver implements a virtual hub providing hardware independent access to the registers controlling the root ports on the back of the machine.</p></div><div class=paragraph><p>The middle layer handles the device connection and disconnection, basic initialisation of the device, driver selection, the communication channels (pipes) and does resource management. This services layer also controls the default pipes and the device requests transferred over them.</p></div><div class=paragraph><p>The top layer contains the individual drivers supporting specific (classes of) devices. These drivers implement the protocol that is used over the pipes other than the default pipe. They also implement additional functionality to make the device available to other parts of the kernel or userland. They use the USB driver interface (USBDI) exposed by the services layer.</p></div></div></div><div class=sect2><h3 id=usb-hc>13.2. Host Controllers<a class=anchor href=#usb-hc></a></h3><div class=paragraph><p>The host controller (HC) controls the transmission of packets on the bus. Frames of 1 millisecond are used. At the start of each frame the host controller generates a Start of Frame (SOF) packet.</p></div><div class=paragraph><p>The SOF packet is used to synchronise to the start of the frame and to keep track of the frame number. Within each frame packets are transferred, either from host to device (out) or from device to host (in). Transfers are always initiated by the host (polled transfers). Therefore there can only be one host per USB bus. Each transfer of a packet has a status stage in which the recipient of the data can return either ACK (acknowledge reception), NAK (retry), STALL (error condition) or nothing (garbled data stage, device not available or disconnected). Section 8.5 of the USB 2.0 Specification explains the details of packets in more detail. Four different types of transfers can occur on a USB bus: control, bulk, interrupt and isochronous. The types of transfers and their characteristics are described below.</p></div><div class=paragraph><p>Large transfers between the device on the USB bus and the device driver are split up into multiple packets by the host controller or the HC driver.</p></div><div class=paragraph><p>Device requests (control transfers) to the default endpoints are special. They consist of two or three phases: SETUP, DATA (optional) and STATUS. The set-up packet is sent to the device. If there is a data phase, the direction of the data packet(s) is given in the set-up packet. The direction in the status phase is the opposite of the direction during the data phase, or IN if there was no data phase. The host controller hardware also provides registers with the current status of the root ports and the changes that have occurred since the last reset of the status change register. Access to these registers is provided through a virtualised hub as suggested in the USB specification. The virtual hub must comply with the hub device class given in chapter 11 of that specification. It must provide a default pipe through which device requests can be sent to it. It returns the standard andhub class specific set of descriptors. It should also provide an interrupt pipe that reports changes happening at its ports. There are currently two specifications for host controllers available: Universal Host Controller Interface (UHCI) from Intel and Open Host Controller Interface (OHCI) from Compaq, Microsoft, and National Semiconductor. The UHCI specification has been designed to reduce hardware complexity by requiring the host controller driver to supply a complete schedule of the transfers for each frame. OHCI type controllers are much more independent by providing a more abstract interface doing a lot of work themselves.</p></div><div class=sect3><h4 id=_uhci>13.2.1. UHCI<a class=anchor href=#_uhci></a></h4><div class=paragraph><p>The UHCI host controller maintains a framelist with 1024 pointers to per frame data structures. It understands two different data types: transfer descriptors (TD) and queue heads (QH). Each TD represents a packet to be communicated to or from a device endpoint. QHs are a means to groupTDs (and QHs) together.</p></div><div class=paragraph><p>Each transfer consists of one or more packets. The UHCI driver splits large transfers into multiple packets. For every transfer, apart from isochronous transfers, a QH is allocated. For every type of transfer these QHs are collected at a QH for that type. Isochronous transfers have to be executed first because of the fixed latency requirement and are directly referred to by the pointer in the framelist. The last isochronous TD refers to the QH for interrupt transfers for that frame. All QHs for interrupt transfers point at the QH for control transfers, which in turn points at the QH for bulk transfers. The following diagram gives a graphical overview of this:</p></div><div class=paragraph><p>This results in the following schedule being run in each frame. After fetching the pointer for the current frame from the framelist the controller first executes the TDs for all the isochronous packets in that frame. The last of these TDs refers to the QH for the interrupt transfers for that frame. The host controller will then descend from that QH to the QHs for the individual interrupt transfers. After finishing that queue, the QH for the interrupt transfers will refer the controller to the QH for all control transfers. It will execute all the subqueues scheduled there, followed by all the transfers queued at the bulk QH. To facilitate the handling of finished or failed transfers different types of interrupts are generated by the hardware at the end of each frame. In the last TD for a transfer the Interrupt-On Completion bit is set by the HC driver to flag an interrupt when the transfer has completed. An error interrupt is flagged if a TD reaches its maximum error count. If the short packet detect bit is set in a TD and less than the set packet length is transferred this interrupt is flagged to notify the controller driver of the completed transfer. It is the host controller driver’s task to find out which transfer has completed or produced an error. When called the interrupt service routine will locate all the finished transfers and call their callbacks.</p></div><div class=paragraph><p>Refer to the UHCI Specification for a more elaborate description.</p></div></div><div class=sect3><h4 id=_ohci>13.2.2. OHCI<a class=anchor href=#_ohci></a></h4><div class=paragraph><p>Programming an OHCI host controller is much simpler. The controller assumes that a set of endpoints is available, and is aware of scheduling priorities and the ordering of the types of transfers in a frame. The main data structure used by the host controller is the endpoint descriptor (ED) to which a queue of transfer descriptors (TDs) is attached. The ED contains the maximum packet size allowed for an endpoint and the controller hardware does the splitting into packets. The pointers to the data buffers are updated after each transfer and when the start and end pointer are equal, the TD is retired to the done-queue. The four types of endpoints (interrupt, isochronous, control, and bulk) have their own queues. Control and bulk endpoints are queued each at their own queue. Interrupt EDs are queued in a tree, with the level in the tree defining the frequency at which they run.</p></div><div class=paragraph><p>The schedule being run by the host controller in each frame looks as follows. The controller will first run the non-periodic control and bulk queues, up to a time limit set by the HC driver. Then the interrupt transfers for that frame number are run, by using the lower five bits of the frame number as an index into level 0 of the tree of interrupts EDs. At the end of this tree the isochronous EDs are connected and these are traversed subsequently. The isochronous TDs contain the frame number of the first frame the transfer should be run in. After all the periodic transfers have been run, the control and bulk queues are traversed again. Periodically the interrupt service routine is called to process the done queue and call the callbacks for each transfer and reschedule interrupt and isochronous endpoints.</p></div><div class=paragraph><p>See the UHCI Specification for a more elaborate description. The middle layer provides access to the device in a controlled way and maintains resources in use by the different drivers and the services layer. The layer takes care of the following aspects:</p></div><div class=ulist><ul><li><p>The device configuration information</p></li><li><p>The pipes to communicate with a device</p></li><li><p>Probing and attaching and detaching form a device.</p></li></ul></div></div></div><div class=sect2><h3 id=usb-dev>13.3. USB Device Information<a class=anchor href=#usb-dev></a></h3><div class=sect3><h4 id=_device_configuration_information>13.3.1. Device Configuration Information<a class=anchor href=#_device_configuration_information></a></h4><div class=paragraph><p>Each device provides different levels of configuration information. Each device has one or more configurations, of which one is selected during probe/attach. A configuration provides power and bandwidth requirements. Within each configuration there can be multiple interfaces. A device interface is a collection of endpoints. For example USB speakers can have an interface for the audio data (Audio Class) and an interface for the knobs, dials and buttons (HID Class). All interfaces in a configuration are active at the same time and can be attached to by different drivers. Each interface can have alternates, providing different quality of service parameters. In for example cameras this is used to provide different frame sizes and numbers of frames per second.</p></div><div class=paragraph><p>Within each interface, 0 or more endpoints can be specified. Endpoints are the unidirectional access points for communicating with a device. They provide buffers to temporarily store incoming or outgoing data from the device. Each endpoint has a unique address within a configuration, the endpoint’s number plus its direction. The default endpoint, endpoint 0, is not part of any interface and available in all configurations. It is managed by the services layer and not directly available to device drivers.</p></div><div class=paragraph><p>This hierarchical configuration information is described in the device by a standard set of descriptors (see section 9.6 of the USB specification). They can be requested through the Get Descriptor Request. The services layer caches these descriptors to avoid unnecessary transfers on the USB bus. Access to the descriptors is provided through function calls.</p></div><div class=ulist><ul><li><p>Device descriptors: General information about the device, like Vendor, Product and Revision Id, supported device class, subclass and protocol if applicable, maximum packet size for the default endpoint, etc.</p></li><li><p>Configuration descriptors: The number of interfaces in this configuration, suspend and resume functionality supported and power requirements.</p></li><li><p>Interface descriptors: interface class, subclass and protocol if applicable, number of alternate settings for the interface and the number of endpoints.</p></li><li><p>Endpoint descriptors: Endpoint address, direction and type, maximum packet size supported and polling frequency if type is interrupt endpoint. There is no descriptor for the default endpoint (endpoint 0) and it is never counted in an interface descriptor.</p></li><li><p>String descriptors: In the other descriptors string indices are supplied for some fields.These can be used to retrieve descriptive strings, possibly in multiple languages.</p></li></ul></div><div class=paragraph><p>Class specifications can add their own descriptor types that are available through the GetDescriptor Request.</p></div><div class=paragraph><p>Pipes Communication to end points on a device flows through so-called pipes. Drivers submit transfers to endpoints to a pipe and provide a callback to be called on completion or failure of the transfer (asynchronous transfers) or wait for completion (synchronous transfer). Transfers to an endpoint are serialised in the pipe. A transfer can either complete, fail or time-out (if a time-out has been set). There are two types of time-outs for transfers. Time-outs can happen due to time-out on the USBbus (milliseconds). These time-outs are seen as failures and can be due to disconnection of the device. A second form of time-out is implemented in software and is triggered when a transfer does not complete within a specified amount of time (seconds). These are caused by a device acknowledging negatively (NAK) the transferred packets. The cause for this is the device not being ready to receive data, buffer under- or overrun or protocol errors.</p></div><div class=paragraph><p>If a transfer over a pipe is larger than the maximum packet size specified in the associated endpoint descriptor, the host controller (OHCI) or the HC driver (UHCI) will split the transfer into packets of maximum packet size, with the last packet possibly smaller than the maximum packet size.</p></div><div class=paragraph><p>Sometimes it is not a problem for a device to return less data than requested. For example abulk-in-transfer to a modem might request 200 bytes of data, but the modem has only 5 bytes available at that time. The driver can set the short packet (SPD) flag. It allows the host controller to accept a packet even if the amount of data transferred is less than requested. This flag is only valid for in-transfers, as the amount of data to be sent to a device is always known beforehand. If an unrecoverable error occurs in a device during a transfer the pipe is stalled. Before any more data is accepted or sent the driver needs to resolve the cause of the stall and clear the endpoint stall condition through send the clear endpoint halt device request over the default pipe. The default endpoint should never stall.</p></div><div class=paragraph><p>There are four different types of endpoints and corresponding pipes: - Control pipe / default pipe: There is one control pipe per device, connected to the default endpoint (endpoint 0). The pipe carries the device requests and associated data. The difference between transfers over the default pipe and other pipes is that the protocol for the transfers is described in the USB specification. These requests are used to reset and configure the device. A basic set of commands that must be supported by each device is provided in chapter 9 of the USB specification. The commands supported on this pipe can be extended by a device class specification to support additional functionality.</p></div><div class=ulist><ul><li><p>Bulk pipe: This is the USB equivalent to a raw transmission medium.</p></li><li><p>Interrupt pipe: The host sends a request for data to the device and if the device has nothing to send, it will NAK the data packet. Interrupt transfers are scheduled at a frequency specified when creating the pipe.</p></li><li><p>Isochronous pipe: These pipes are intended for isochronous data, for example video or audio streams, with fixed latency, but no guaranteed delivery. Some support for pipes of this type is available in the current implementation. Packets in control, bulk and interrupt transfers are retried if an error occurs during transmission or the device acknowledges the packet negatively (NAK) due to for example lack of buffer space to store the incoming data. Isochronous packets are however not retried in case of failed delivery or NAK of a packet as this might violate the timing constraints.</p></li></ul></div><div class=paragraph><p>The availability of the necessary bandwidth is calculated during the creation of the pipe. Transfers are scheduled within frames of 1 millisecond. The bandwidth allocation within a frame is prescribed by the USB specification, section 5.6 [ 2]. Isochronous and interrupt transfers are allowed to consume up to 90% of the bandwidth within a frame. Packets for control and bulk transfers are scheduled after all isochronous and interrupt packets and will consume all the remaining bandwidth.</p></div><div class=paragraph><p>More information on scheduling of transfers and bandwidth reclamation can be found in chapter 5 of the USB specification, section 1.3 of the UHCI specification, and section 3.4.2 of the OHCI specification.</p></div></div></div><div class=sect2><h3 id=usb-devprobe>13.4. Device Probe and Attach<a class=anchor href=#usb-devprobe></a></h3><div class=paragraph><p>After the notification by the hub that a new device has been connected, the service layer switches on the port, providing the device with 100 mA of current. At this point the device is in its default state and listening to device address 0. The services layer will proceed to retrieve the various descriptors through the default pipe. After that it will send a Set Address request to move the device away from the default device address (address 0). Multiple device drivers might be able to support the device. For example a modem driver might be able to support an ISDN TA through the AT compatibility interface. A driver for that specific model of the ISDN adapter might however be able to provide much better support for this device. To support this flexibility, the probes return priorities indicating their level of support. Support for a specific revision of a product ranks the highest and the generic driver the lowest priority. It might also be that multiple drivers could attach to one device if there are multiple interfaces within one configuration. Each driver only needs to support a subset of the interfaces.</p></div><div class=paragraph><p>The probing for a driver for a newly attached device checks first for device specific drivers. If not found, the probe code iterates over all supported configurations until a driver attaches in a configuration. To support devices with multiple drivers on different interfaces, the probe iterates over all interfaces in a configuration that have not yet been claimed by a driver. Configurations that exceed the power budget for the hub are ignored. During attach the driver should initialise the device to its proper state, but not reset it, as this will make the device disconnect itself from the bus and restart the probing process for it. To avoid consuming unnecessary bandwidth should not claim the interrupt pipe at attach time, but should postpone allocating the pipe until the file is opened and the data is actually used. When the file is closed the pipe should be closed again, even though the device might still be attached.</p></div><div class=sect3><h4 id=_device_disconnect_and_detach>13.4.1. Device Disconnect and Detach<a class=anchor href=#_device_disconnect_and_detach></a></h4><div class=paragraph><p>A device driver should expect to receive errors during any transaction with the device. The design of USB supports and encourages the disconnection of devices at any point in time. Drivers should make sure that they do the right thing when the device disappears.</p></div><div class=paragraph><p>Furthermore a device that has been disconnected and reconnected will not be reattached at the same device instance. This might change in the future when more devices support serial numbers (see the device descriptor) or other means of defining an identity for a device have been developed.</p></div><div class=paragraph><p>The disconnection of a device is signaled by a hub in the interrupt packet delivered to the hub driver. The status change information indicates which port has seen a connection change. The device detach method for all device drivers for the device connected on that port are called and the structures cleaned up. If the port status indicates that in the mean time a device has been connected to that port, the procedure for probing and attaching the device will be started. A device reset will produce a disconnect-connect sequence on the hub and will be handled as described above.</p></div></div></div><div class=sect2><h3 id=usb-protocol>13.5. USB Drivers Protocol Information<a class=anchor href=#usb-protocol></a></h3><div class=paragraph><p>The protocol used over pipes other than the default pipe is undefined by the USB specification. Information on this can be found from various sources. The most accurate source is the developer’s section on the USB home pages. From these pages, a growing number of deviceclass specifications are available. These specifications specify what a compliant device should look like from a driver perspective, basic functionality it needs to provide and the protocol that is to be used over the communication channels. The USB specification includes the description of the Hub Class. A class specification for Human Interface Devices (HID) has been created to cater for keyboards, tablets, bar-code readers, buttons, knobs, switches, etc. A third example is the class specification for mass storage devices. For a full list of device classes see the developers section on the USB home pages.</p></div><div class=paragraph><p>For many devices the protocol information has not yet been published however. Information on the protocol being used might be available from the company making the device. Some companies will require you to sign a Non -Disclosure Agreement (NDA) before giving you the specifications. This in most cases precludes making the driver open source.</p></div><div class=paragraph><p>Another good source of information is the Linux driver sources, as a number of companies have started to provide drivers for Linux for their devices. It is always a good idea to contact the authors of those drivers for their source of information.</p></div><div class=paragraph><p>Example: Human Interface Devices The specification for the Human Interface Devices like keyboards, mice, tablets, buttons, dials,etc. is referred to in other device class specifications and is used in many devices.</p></div><div class=paragraph><p>For example audio speakers provide endpoints to the digital to analogue converters and possibly an extra pipe for a microphone. They also provide a HID endpoint in a separate interface for the buttons and dials on the front of the device. The same is true for the monitor control class. It is straightforward to build support for these interfaces through the available kernel and userland libraries together with the HID class driver or the generic driver. Another device that serves as an example for interfaces within one configuration driven by different device drivers is a cheap keyboard with built-in legacy mouse port. To avoid having the cost of including the hardware for a USB hub in the device, manufacturers combined the mouse data received from the PS/2 port on the back of the keyboard and the key presses from the keyboard into two separate interfaces in the same configuration. The mouse and keyboard drivers each attach to the appropriate interface and allocate the pipes to the two independent endpoints.</p></div><div class=paragraph><p>Example: Firmware download Many devices that have been developed are based on a general purpose processor with an additional USB core added to it. Since the development of drivers and firmware for USB devices is still very new, many devices require the downloading of the firmware after they have been connected.</p></div><div class=paragraph><p>The procedure followed is straightforward. The device identifies itself through a vendor and product Id. The first driver probes and attaches to it and downloads the firmware into it. After that the device soft resets itself and the driver is detached. After a short pause the device announces its presence on the bus. The device will have changed its vendor/product/revision Id to reflect the fact that it has been supplied with firmware and as a consequence a second driver will probe it and attach to it.</p></div><div class=paragraph><p>An example of these types of devices is the ActiveWire I/O board, based on the EZ-USB chip. For this chip a generic firmware downloader is available. The firmware downloaded into the ActiveWire board changes the revision Id. It will then perform a soft reset of the USB part of the EZ-USB chip to disconnect from the USB bus and again reconnect.</p></div><div class=paragraph><p>Example: Mass Storage Devices Support for mass storage devices is mainly built around existing protocols. The Iomega USB Zipdrive is based on the SCSI version of their drive. The SCSI commands and status messages are wrapped in blocks and transferred over the bulk pipes to and from the device, emulating a SCSI controller over the USB wire. ATAPI and UFI commands are supported in a similar fashion.</p></div><div class=paragraph><p>The Mass Storage Specification supports 2 different types of wrapping of the command block.The initial attempt was based on sending the command and status through the default pipe and using bulk transfers for the data to be moved between the host and the device. Based on experience a second approach was designed that was based on wrapping the command and status blocks and sending them over the bulk out and in endpoint. The specification specifies exactly what has to happen when and what has to be done in case an error condition is encountered. The biggest challenge when writing drivers for these devices is to fit USB based protocol into the existing support for mass storage devices. CAM provides hooks to do this in a fairly straight forward way. ATAPI is less simple as historically the IDE interface has never had many different appearances.</p></div><div class=paragraph><p>The support for the USB floppy from Y-E Data is again less straightforward as a new command set has been designed.</p></div></div></div></div><div class=sect1><h2 id=newbus>Chapter 14. Newbus<a class=anchor href=#newbus></a></h2><div class=sectionbody><div class=paragraph><p><em>Special thanks to Matthew N. Dodd, Warner Losh, Bill Paul, Doug Rabson, Mike Smith, Peter Wemm and Scott Long</em>.</p></div><div class=paragraph><p>This chapter explains the Newbus device framework in detail.</p></div><div class=sect2><h3 id=newbus-devdrivers>14.1. Device Drivers<a class=anchor href=#newbus-devdrivers></a></h3><div class=sect3><h4 id=_purpose_of_a_device_driver>14.1.1. Purpose of a Device Driver<a class=anchor href=#_purpose_of_a_device_driver></a></h4><div class=paragraph><p>A device driver is a software component which provides the interface between the kernel’s generic view of a peripheral (e.g., disk, network adapter) and the actual implementation of the peripheral. The <em>device driver interface (DDI)</em> is the defined interface between the kernel and the device driver component.</p></div></div><div class=sect3><h4 id=_types_of_device_drivers>14.1.2. Types of Device Drivers<a class=anchor href=#_types_of_device_drivers></a></h4><div class=paragraph><p>There used to be days in UNIX®, and thus FreeBSD, in which there were four types of devices defined:</p></div><div class=ulist><ul><li><p>block device drivers</p></li><li><p>character device drivers</p></li><li><p>network device drivers</p></li><li><p>pseudo-device drivers</p></li></ul></div><div class=paragraph><p><em>Block devices</em> performed in a way that used fixed size blocks [of data]. This type of driver depended on the so-called <em>buffer cache</em>, which had cached accessed blocks of data in a dedicated part of memory. Often this buffer cache was based on write-behind, which meant that when data was modified in memory it got synced to disk whenever the system did its periodical disk flushing, thus optimizing writes.</p></div></div><div class=sect3><h4 id=_character_devices>14.1.3. Character Devices<a class=anchor href=#_character_devices></a></h4><div class=paragraph><p>However, in the versions of FreeBSD 4.0 and onward the distinction between block and character devices became non-existent.</p></div></div></div><div class=sect2><h3 id=newbus-overview>14.2. Overview of Newbus<a class=anchor href=#newbus-overview></a></h3><div class=paragraph><p><em>Newbus</em> is the implementation of a new bus architecture based on abstraction layers which saw its introduction in FreeBSD 3.0 when the Alpha port was imported into the source tree. It was not until 4.0 before it became the default system to use for device drivers. Its goals are to provide a more object-oriented means of interconnecting the various busses and devices which a host system provides to the <em>Operating System</em>.</p></div><div class=paragraph><p>Its main features include amongst others:</p></div><div class=ulist><ul><li><p>dynamic attaching</p></li><li><p>easy modularization of drivers</p></li><li><p>pseudo-busses</p></li></ul></div><div class=paragraph><p>One of the most prominent changes is the migration from the flat and ad-hoc system to a device tree layout.</p></div><div class=paragraph><p>At the top level resides the <em>"root"</em> device which is the parent to hang all other devices on. For each architecture, there is typically a single child of "root" which has such things as <em>host-to-PCI bridges</em>, etc. attached to it. For x86, this "root" device is the <em>"nexus"</em> device. For Alpha, various different models of Alpha have different top-level devices corresponding to the different hardware chipsets, including <em>lca</em>, <em>apecs</em>, <em>cia</em> and <em>tsunami</em>.</p></div><div class=paragraph><p>A device in the Newbus context represents a single hardware entity in the system. For instance each PCI device is represented by a Newbus device. Any device in the system can have children; a device which has children is often called a <em>"bus"</em>. Examples of common busses in the system are ISA and PCI, which manage lists of devices attached to ISA and PCI busses respectively.</p></div><div class=paragraph><p>Often, a connection between different kinds of bus is represented by a <em>"bridge"</em> device, which normally has one child for the attached bus. An example of this is a <em>PCI-to-PCI bridge</em> which is represented by a device <em><span class=filename>pcibN</span></em> on the parent PCI bus and has a child <em><span class=filename>pciN</span></em> for the attached bus. This layout simplifies the implementation of the PCI bus tree, allowing common code to be used for both top-level and bridged busses.</p></div><div class=paragraph><p>Each device in the Newbus architecture asks its parent to map its resources. The parent then asks its own parent until the nexus is reached. So, basically the nexus is the only part of the Newbus system which knows about all resources.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>An ISA device might want to map its IO port at <code>0x230</code>, so it asks its parent, in this case the ISA bus. The ISA bus hands it over to the PCI-to-ISA bridge which in its turn asks the PCI bus, which reaches the host-to-PCI bridge and finally the nexus. The beauty of this transition upwards is that there is room to translate the requests. For example, the <code>0x230</code> IO port request might become memory-mapped at <code>0xb0000230</code> on a MIPS box by the PCI bridge.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Resource allocation can be controlled at any place in the device tree. For instance on many Alpha platforms, ISA interrupts are managed separately from PCI interrupts and resource allocations for ISA interrupts are managed by the Alpha’s ISA bus device. On IA-32, ISA and PCI interrupts are both managed by the top-level nexus device. For both ports, memory and port address space is managed by a single entity - nexus for IA-32 and the relevant chipset driver on Alpha (e.g., CIA or tsunami).</p></div><div class=paragraph><p>In order to normalize access to memory and port mapped resources, Newbus integrates the <code>bus_space</code> APIs from NetBSD. These provide a single API to replace inb/outb and direct memory reads/writes. The advantage of this is that a single driver can easily use either memory-mapped registers or port-mapped registers (some hardware supports both).</p></div><div class=paragraph><p>This support is integrated into the resource allocation mechanism. When a resource is allocated, a driver can retrieve the associated <code>bus_space_tag_t</code> and <code>bus_space_handle_t</code> from the resource.</p></div><div class=paragraph><p>Newbus also allows for definitions of interface methods in files dedicated to this purpose. These are the <span class=filename>.m</span> files that are found under the <span class=filename>src/sys</span> hierarchy.</p></div><div class=paragraph><p>The core of the Newbus system is an extensible "object-based programming" model. Each device in the system has a table of methods which it supports. The system and other devices uses those methods to control the device and request services. The different methods supported by a device are defined by a number of "interfaces". An "interface" is simply a group of related methods which can be implemented by a device.</p></div><div class=paragraph><p>In the Newbus system, the methods for a device are provided by the various device drivers in the system. When a device is attached to a driver during <em>auto-configuration</em>, it uses the method table declared by the driver. A device can later <em>detach</em> from its driver and <em>re-attach</em> to a new driver with a new method table. This allows dynamic replacement of drivers which can be useful for driver development.</p></div><div class=paragraph><p>The interfaces are described by an interface definition language similar to the language used to define vnode operations for file systems. The interface would be stored in a methods file (which would normally be named <span class=filename>foo_if.m</span>).</p></div><div class=exampleblock><div class=title>Example 5. Newbus Methods</div><div class=content><div class="literalblock programlisting"><div class=content><pre>      # Foo subsystem/driver (a comment...)

	  INTERFACE foo

	METHOD int doit {
		device_t dev;
	};

	# DEFAULT is the method that will be used, if a method was not
	# provided via: DEVMETHOD()

	METHOD void doit_to_child {
		device_t dev;
		driver_t child;
	} DEFAULT doit_generic_to_child;</pre></div></div></div></div><div class=paragraph><p>When this interface is compiled, it generates a header file "<span class=filename>foo_if.h</span>" which contains function declarations:</p></div><div class="literalblock programlisting"><div class=content><pre>      int FOO_DOIT(device_t dev);
      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);</pre></div></div><div class=paragraph><p>A source file, "<span class=filename>foo_if.c</span>" is also created to accompany the automatically generated header file; it contains implementations of those functions which look up the location of the relevant functions in the object’s method table and call that function.</p></div><div class=paragraph><p>The system defines two main interfaces. The first fundamental interface is called <em>"device"</em> and includes methods which are relevant to all devices. Methods in the <em>"device"</em> interface include <em>"probe"</em>, <em>"attach"</em> and <em>"detach"</em> to control detection of hardware and <em>"shutdown"</em>, <em>"suspend"</em> and <em>"resume"</em> for critical event notification.</p></div><div class=paragraph><p>The second, more complex interface is <em>"bus"</em>. This interface contains methods suitable for devices which have children, including methods to access bus specific per-device information <sup class=footnote>[<a id=_footnoteref_10 class=footnote href=#_footnotedef_10 title="View footnote.">10</a>]</sup>, event notification (<code><em>child_detached</em></code>, <code><em>driver_added</em></code>) and resource management (<code><em>alloc_resource</em></code>, <code><em>activate_resource</em></code>, <code><em>deactivate_resource</em></code>, <code><em>release_resource</em></code>).</p></div><div class=paragraph><p>Many methods in the "bus" interface are performing services for some child of the bus device. These methods would normally use the first two arguments to specify the bus providing the service and the child device which is requesting the service. To simplify driver code, many of these methods have accessor functions which lookup the parent and call a method on the parent. For instance the method <code>BUS_TEARDOWN_INTR(device_t dev, device_t child, …​)</code> can be called using the function <code>bus_teardown_intr(device_t child, …​)</code>.</p></div><div class=paragraph><p>Some bus types in the system define additional interfaces to provide access to bus-specific functionality. For instance, the PCI bus driver defines the "pci" interface which has two methods <code><em>read_config</em></code> and <code><em>write_config</em></code> for accessing the configuration registers of a PCI device.</p></div></div><div class=sect2><h3 id=newbus-api>14.3. Newbus API<a class=anchor href=#newbus-api></a></h3><div class=paragraph><p>As the Newbus API is huge, this section makes some effort at documenting it. More information to come in the next revision of this document.</p></div><div class=sect3><h4 id=_important_locations_in_the_source_hierarchy>14.3.1. Important Locations in the Source Hierarchy<a class=anchor href=#_important_locations_in_the_source_hierarchy></a></h4><div class=paragraph><p><span class=filename>src/sys/[arch]/[arch]</span> - Kernel code for a specific machine architecture resides in this directory. For example, the <code>i386</code> architecture, or the <code>SPARC64</code> architecture.</p></div><div class=paragraph><p><span class=filename>src/sys/dev/[bus]</span> - device support for a specific <code>[bus]</code> resides in this directory.</p></div><div class=paragraph><p><span class=filename>src/sys/dev/pci</span> - PCI bus support code resides in this directory.</p></div><div class=paragraph><p><span class=filename>src/sys/[isa|pci]</span> - PCI/ISA device drivers reside in this directory. The PCI/ISA bus support code used to exist in this directory in FreeBSD version <code>4.0</code>.</p></div></div><div class=sect3><h4 id=_important_structures_and_type_definitions>14.3.2. Important Structures and Type Definitions<a class=anchor href=#_important_structures_and_type_definitions></a></h4><div class=paragraph><p><code>devclass_t</code> - This is a type definition of a pointer to a <code>struct devclass</code>.</p></div><div class=paragraph><p><code>device_method_t</code> - This is the same as <code>kobj_method_t</code> (see <span class=filename>src/sys/kobj.h</span>).</p></div><div class=paragraph><p><code>device_t</code> - This is a type definition of a pointer to a <code>struct device</code>. <code>device_t</code> represents a device in the system. It is a kernel object. See <span class=filename>src/sys/sys/bus_private.h</span> for implementation details.</p></div><div class=paragraph><p><code>driver_t</code> - This is a type definition which references <code>struct driver</code>. The <code>driver</code> struct is a class of the <code>device</code> kernel object; it also holds data private to the driver.</p></div><div class=paragraph><p><strong><em>driver_t</em> Implementation</strong></p></div><div class="literalblock programlisting"><div class=content><pre>	  struct driver {
		KOBJ_CLASS_FIELDS;
		void	*priv;			/* driver private data */
	  };</pre></div></div><div class=paragraph><p>A <code>device_state_t</code> type, which is an enumeration, <code>device_state</code>. It contains the possible states of a Newbus device before and after the autoconfiguration process.</p></div><div class=paragraph><p><strong>Device States _device_state_t</strong></p></div><div class="literalblock programlisting"><div class=content><pre>	  /*
	   * src/sys/sys/bus.h
	   */
	  typedef enum device_state {
		DS_NOTPRESENT,	/* not probed or probe failed */
		DS_ALIVE,		/* probe succeeded */
		DS_ATTACHED,	/* attach method called */
		DS_BUSY			/* device is open */
	  } device_state_t;</pre></div></div></div></div></div></div><div class=sect1><h2 id=oss>Chapter 15. Sound Subsystem<a class=anchor href=#oss></a></h2><div class=sectionbody><div class=sect2><h3 id=oss-intro>15.1. Introduction<a class=anchor href=#oss-intro></a></h3><div class=paragraph><p>The FreeBSD sound subsystem cleanly separates generic sound handling issues from device-specific ones. This makes it easier to add support for new hardware.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> framework is the central piece of the sound subsystem. It mainly implements the following elements:</p></div><div class=ulist><ul><li><p>A system call interface (read, write, ioctls) to digitized sound and mixer functions. The ioctl command set is compatible with the legacy <em>OSS</em> or <em>Voxware</em> interface, allowing common multimedia applications to be ported without modification.</p></li><li><p>Common code for processing sound data (format conversions, virtual channels).</p></li><li><p>A uniform software interface to hardware-specific audio interface modules.</p></li><li><p>Additional support for some common hardware interfaces (ac97), or shared hardware-specific code (ex: ISA DMA routines).</p></li></ul></div><div class=paragraph><p>The support for specific sound cards is implemented by hardware-specific drivers, which provide channel and mixer interfaces to plug into the generic <span class=filename>pcm</span> code.</p></div><div class=paragraph><p>In this chapter, the term <span class=filename>pcm</span> will refer to the central, common part of the sound driver, as opposed to the hardware-specific modules.</p></div><div class=paragraph><p>The prospective driver writer will of course want to start from an existing module and use the code as the ultimate reference. But, while the sound code is nice and clean, it is also mostly devoid of comments. This document tries to give an overview of the framework interface and answer some questions that may arise while adapting the existing code.</p></div><div class=paragraph><p>As an alternative, or in addition to starting from a working example, you can find a commented driver template at <a href=https://people.FreeBSD.org/~cg/template.c>https://people.FreeBSD.org/~cg/template.c</a></p></div></div><div class=sect2><h3 id=oss-files>15.2. Files<a class=anchor href=#oss-files></a></h3><div class=paragraph><p>All the relevant code lives in <span class=filename>/usr/src/sys/dev/sound/</span>, except for the public ioctl interface definitions, found in <span class=filename>/usr/src/sys/sys/soundcard.h</span></p></div><div class=paragraph><p>Under <span class=filename>/usr/src/sys/dev/sound/</span>, the <span class=filename>pcm/</span> directory holds the central code, while the <span class=filename>pci/</span>, <span class=filename>isa/</span> and <span class=filename>usb/</span> directories have the drivers for PCI and ISA boards, and for USB audio devices.</p></div></div><div class=sect2><h3 id=pcm-probe-and-attach>15.3. Probing, Attaching, etc.<a class=anchor href=#pcm-probe-and-attach></a></h3><div class=paragraph><p>Sound drivers probe and attach in almost the same way as any hardware driver module. You might want to look at the <a href=./#isa-driver>ISA</a> or <a href=./#pci>PCI</a> specific sections of the handbook for more information.</p></div><div class=paragraph><p>However, sound drivers differ in some ways:</p></div><div class=ulist><ul><li><p>They declare themselves as <span class=filename>pcm</span> class devices, with a <code>struct snddev_info</code> device private structure:</p><div class="literalblock programlisting"><div class=content><pre>          static driver_t xxx_driver = {
              &#34;pcm&#34;,
              xxx_methods,
              sizeof(struct snddev_info)
          };

          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);
          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);</pre></div></div><div class=paragraph><p>Most sound drivers need to store additional private information about their device. A private data structure is usually allocated in the attach routine. Its address is passed to <span class=filename>pcm</span> by the calls to <code>pcm_register()</code> and <code>mixer_init()</code>. <span class=filename>pcm</span> later passes back this address as a parameter in calls to the sound driver interfaces.</p></div></li><li><p>The sound driver attach routine should declare its MIXER or AC97 interface to
<span class=filename>pcm</span> by calling <code>mixer_init()</code>. For a MIXER interface, this causes
in turn a call to <a href=./#xxxmixer-init><code>xxxmixer_init()</code></a>.</p></li><li><p>The sound driver attach routine declares its general CHANNEL configuration to <span class=filename>pcm</span> by calling <code>pcm_register(dev, sc, nplay, nrec)</code>, where <code>sc</code> is the address for the device data structure, used in further calls from <span class=filename>pcm</span>, and <code>nplay</code> and <code>nrec</code> are the number of play and record channels.</p></li><li><p>The sound driver attach routine declares each of its channel objects by calls
to <code>pcm_addchan()</code>. This sets up the channel glue in <span class=filename>pcm</span> and
causes in turn a call to <a href=./#xxxchannel-init><code>xxxchannel_init()</code></a>.</p></li><li><p>The sound driver detach routine should call <code>pcm_unregister()</code> before releasing its resources.</p></li></ul></div><div class=paragraph><p>There are two possible methods to handle non-PnP devices:</p></div><div class=ulist><ul><li><p>Use a <code>device_identify()</code> method (example: <span class=filename>sound/isa/es1888.c</span>). The <code>device_identify()</code> method probes for the hardware at known addresses and, if it finds a supported device, creates a new pcm device which is then passed to probe/attach.</p></li><li><p>Use a custom kernel configuration with appropriate hints for pcm devices (example: <span class=filename>sound/isa/mss.c</span>).</p></li></ul></div><div class=paragraph><p><span class=filename>pcm</span> drivers should implement <code>device_suspend</code>, <code>device_resume</code> and <code>device_shutdown</code> routines, so that power management and module unloading function correctly.</p></div></div><div class=sect2><h3 id=oss-interfaces>15.4. Interfaces<a class=anchor href=#oss-interfaces></a></h3><div class=paragraph><p>The interface between the <span class=filename>pcm</span> core and the sound drivers is defined
in terms of <a href=./#kernel-objects>kernel objects</a>.</p></div><div class=paragraph><p>There are two main interfaces that a sound driver will usually provide: <em>CHANNEL</em> and either <em>MIXER</em> or <em>AC97</em>.</p></div><div class=paragraph><p>The <em>AC97</em> interface is a very small hardware access (register read/write) interface, implemented by drivers for hardware with an AC97 codec. In this case, the actual MIXER interface is provided by the shared AC97 code in <span class=filename>pcm</span>.</p></div><div class=sect3><h4 id=_the_channel_interface>15.4.1. The CHANNEL Interface<a class=anchor href=#_the_channel_interface></a></h4><div class=sect4><h5 id=_common_notes_for_function_parameters>15.4.1.1. Common Notes for Function Parameters<a class=anchor href=#_common_notes_for_function_parameters></a></h5><div class=paragraph><p>Sound drivers usually have a private data structure to describe their device, and one structure for each play and record data channel that it supports.</p></div><div class=paragraph><p>For all CHANNEL interface functions, the first parameter is an opaque pointer.</p></div><div class=paragraph><p>The second parameter is a pointer to the private channel data structure, except for <code>channel_init()</code> which has a pointer to the private device structure (and returns the channel pointer for further use by <span class=filename>pcm</span>).</p></div></div><div class=sect4><h5 id=_overview_of_data_transfer_operations>15.4.1.2. Overview of Data Transfer Operations<a class=anchor href=#_overview_of_data_transfer_operations></a></h5><div class=paragraph><p>For sound data transfers, the <span class=filename>pcm</span> core and the sound drivers communicate through a shared memory area, described by a <code>struct snd_dbuf</code>.</p></div><div class=paragraph><p><code>struct snd_dbuf</code> is private to <span class=filename>pcm</span>, and sound drivers obtain values of interest by calls to accessor functions (<code>sndbuf_getxxx()</code>).</p></div><div class=paragraph><p>The shared memory area has a size of <code>sndbuf_getsize()</code> and is divided into fixed size blocks of <code>sndbuf_getblksz()</code> bytes.</p></div><div class=paragraph><p>When playing, the general transfer mechanism is as follows (reverse the idea for recording):</p></div><div class=ulist><ul><li><p><span class=filename>pcm</span> initially fills up the buffer, then calls the sound driver’s
<a href=./#channel-trigger><code>xxxchannel_trigger()</code></a> function with a parameter of PCMTRIG_START.</p></li><li><p>The sound driver then arranges to repeatedly transfer the whole memory area (<code>sndbuf_getbuf()</code>, <code>sndbuf_getsize()</code>) to the device, in blocks of <code>sndbuf_getblksz()</code> bytes. It calls back the <code>chn_intr()</code><span class=filename>pcm</span> function for each transferred block (this will typically happen at interrupt time).</p></li><li><p><code>chn_intr()</code> arranges to copy new data to the area that was transferred to the device (now free), and make appropriate updates to the <code>snd_dbuf</code> structure.</p></li></ul></div></div><div class=sect4><h5 id=xxxchannel-init>15.4.1.3. channel_init<a class=anchor href=#xxxchannel-init></a></h5><div class=paragraph><p><code>xxxchannel_init()</code> is called to initialize each of the play or record channels.
The calls are initiated from the sound driver attach routine. (See the crossref:sound[pcm-probe-and-attach,probe and attach section).</p></div><div class="literalblock programlisting"><div class=content><pre>          static void *
          xxxchannel_init(kobj_t obj, void *data,
             struct snd_dbuf *b, struct pcm_channel *c, int dir) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_info *sc = data;
              struct xxx_chinfo *ch;
               ...
              return ch; <i class=conum data-value=2></i><b>(2)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>b</code> is the address for the channel <code>struct snd_dbuf</code>. It should be initialized in the function by calling <code>sndbuf_alloc()</code>. The buffer size to use is normally a small multiple of the 'typical' unit transfer size for your device.<code>c</code> is the <span class=filename>pcm</span> channel control structure pointer. This is an opaque object. The function should store it in the local channel structure, to be used in later calls to <span class=filename>pcm</span> (ie: <code>chn_intr(c)</code>).<code>dir</code> indicates the channel direction (<code>PCMDIR_PLAY</code> or <code>PCMDIR_REC</code>).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The function should return a pointer to the private area used to control this channel. This will be passed as a parameter to other channel interface calls.</td></tr></tbody></table></div></div><div class=sect4><h5 id=_channel_setformat>15.4.1.4. channel_setformat<a class=anchor href=#_channel_setformat></a></h5><div class=paragraph><p><code>xxxchannel_setformat()</code> should set up the hardware for the specified channel for the specified sound format.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_chinfo *ch = data;
               ...
              return 0;
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>format</code> is specified as an <code>AFMT_XXX value</code> (<span class=filename>soundcard.h</span>).</td></tr></tbody></table></div></div><div class=sect4><h5 id=_channel_setspeed>15.4.1.5. channel_setspeed<a class=anchor href=#_channel_setspeed></a></h5><div class=paragraph><p><code>xxxchannel_setspeed()</code> sets up the channel hardware for the specified sampling speed, and returns the possibly adjusted speed.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)
          {
              struct xxx_chinfo *ch = data;
               ...
              return speed;
           }</pre></div></div></div><div class=sect4><h5 id=_channel_setblocksize>15.4.1.6. channel_setblocksize<a class=anchor href=#_channel_setblocksize></a></h5><div class=paragraph><p><code>xxxchannel_setblocksize()</code> sets the block size, which is the size of unit transactions between <span class=filename>pcm</span> and the sound driver, and between the sound driver and the device. Typically, this would be the number of bytes transferred before an interrupt occurs. During a transfer, the sound driver should call <span class=filename>pcm</span>'s <code>chn_intr()</code> every time this size has been transferred.</p></div><div class=paragraph><p>Most sound drivers only take note of the block size here, to be used when an actual transfer will be started.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)
          {
              struct xxx_chinfo *ch = data;
                ...
              return blocksize; <i class=conum data-value=1></i><b>(1)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The function returns the possibly adjusted block size. In case the block size is indeed changed, <code>sndbuf_resize()</code> should be called to adjust the buffer.</td></tr></tbody></table></div></div><div class=sect4><h5 id=channel-trigger>15.4.1.7. channel_trigger<a class=anchor href=#channel-trigger></a></h5><div class=paragraph><p><code>xxxchannel_trigger()</code> is called by <span class=filename>pcm</span> to control data transfer operations in the driver.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_trigger(kobj_t obj, void *data, int go) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_chinfo *ch = data;
               ...
              return 0;
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>go</code> defines the action for the current call. The possible values are:</td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the driver uses ISA DMA, <code>sndbuf_isadma()</code> should be called before performing actions on the device, and will take care of the DMA chip side of things.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_channel_getptr>15.4.1.8. channel_getptr<a class=anchor href=#_channel_getptr></a></h5><div class=paragraph><p><code>xxxchannel_getptr()</code> returns the current offset in the transfer buffer. This will typically be called by <code>chn_intr()</code>, and this is how <span class=filename>pcm</span> knows where it can transfer new data.</p></div></div><div class=sect4><h5 id=_channel_free>15.4.1.9. channel_free<a class=anchor href=#_channel_free></a></h5><div class=paragraph><p><code>xxxchannel_free()</code> is called to free up channel resources, for example when the driver is unloaded, and should be implemented if the channel data structures are dynamically allocated or if <code>sndbuf_alloc()</code> was not used for buffer allocation.</p></div></div><div class=sect4><h5 id=_channel_getcaps>15.4.1.10. channel_getcaps<a class=anchor href=#_channel_getcaps></a></h5><div class="literalblock programlisting"><div class=content><pre>          struct pcmchan_caps *
          xxxchannel_getcaps(kobj_t obj, void *data)
          {
              return &amp;xxx_caps; <i class=conum data-value=1></i><b>(1)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The routine returns a pointer to a (usually statically-defined) <code>pcmchan_caps</code> structure (defined in <span class=filename>sound/pcm/channel.h</span>. The structure holds the minimum and maximum sampling frequencies, and the accepted sound formats. Look at any sound driver for an example.</td></tr></tbody></table></div></div><div class=sect4><h5 id=_more_functions>15.4.1.11. More Functions<a class=anchor href=#_more_functions></a></h5><div class=paragraph><p><code>channel_reset()</code>, <code>channel_resetdone()</code>, and <code>channel_notify()</code> are for special purposes and should not be implemented in a driver without discussing it on the <a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>FreeBSD multimedia mailing list</a>.</p></div><div class=paragraph><p><code>channel_setdir()</code> is deprecated.</p></div></div></div><div class=sect3><h4 id=_the_mixer_interface>15.4.2. The MIXER Interface<a class=anchor href=#_the_mixer_interface></a></h4><div class=sect4><h5 id=xxxmixer-init>15.4.2.1. mixer_init<a class=anchor href=#xxxmixer-init></a></h5><div class=paragraph><p><code>xxxmixer_init()</code> initializes the hardware and tells <span class=filename>pcm</span> what mixer devices are available for playing and recording</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxmixer_init(struct snd_mixer *m)
          {
              struct xxx_info   *sc = mix_getdevinfo(m);
              u_int32_t v;

              [Initialize hardware]

              [Set appropriate bits in v for play mixers] <i class=conum data-value=1></i><b>(1)</b>
              mix_setdevs(m, v);
              [Set appropriate bits in v for record mixers]
              mix_setrecdevs(m, v)

              return 0;
          }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Set bits in an integer value and call <code>mix_setdevs()</code> and <code>mix_setrecdevs()</code> to tell <span class=filename>pcm</span> what devices exist.</td></tr></tbody></table></div><div class=paragraph><p>Mixer bits definitions can be found in <span class=filename>soundcard.h</span> (<code>SOUND_MASK_XXX</code> values and <code>SOUND_MIXER_XXX</code> bit shifts).</p></div></div><div class=sect4><h5 id=_mixer_set>15.4.2.2. mixer_set<a class=anchor href=#_mixer_set></a></h5><div class=paragraph><p><code>xxxmixer_set()</code> sets the volume level for one mixer device.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxmixer_set(struct snd_mixer *m, unsigned dev,
                           unsigned left, unsigned right) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct sc_info *sc = mix_getdevinfo(m);
              [set volume level]
              return left | (right &lt;&lt; 8); <i class=conum data-value=2></i><b>(2)</b>
          }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The device is specified as a <code>SOUND_MIXER_XXX</code> value. The volume values are specified in range [0-100]. A value of zero should mute the device.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>As the hardware levels probably will not match the input scale, and some rounding will occur, the routine returns the actual level values (in range 0-100) as shown.</td></tr></tbody></table></div></div><div class=sect4><h5 id=_mixer_setrecsrc>15.4.2.3. mixer_setrecsrc<a class=anchor href=#_mixer_setrecsrc></a></h5><div class=paragraph><p><code>xxxmixer_setrecsrc()</code> sets the recording source device.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_info *sc = mix_getdevinfo(m);

              [look for non zero bit(s) in src, set up hardware]

              [update src to reflect actual action]
              return src; <i class=conum data-value=2></i><b>(2)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The desired recording devices are specified as a bit field</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The actual devices set for recording are returned. Some drivers can only set one device for recording. The function should return -1 if an error occurs.</td></tr></tbody></table></div></div><div class=sect4><h5 id=_mixer_uninit_mixer_reinit>15.4.2.4. mixer_uninit, mixer_reinit<a class=anchor href=#_mixer_uninit_mixer_reinit></a></h5><div class=paragraph><p><code>xxxmixer_uninit()</code> should ensure that all sound is muted and if possible mixer hardware should be powered down.</p></div><div class=paragraph><p><code>xxxmixer_reinit()</code> should ensure that the mixer hardware is powered up and any settings not controlled by <code>mixer_set()</code> or <code>mixer_setrecsrc()</code> are restored.</p></div></div></div><div class=sect3><h4 id=_the_ac97_interface>15.4.3. The AC97 Interface<a class=anchor href=#_the_ac97_interface></a></h4><div class=paragraph><p>The <em>AC97</em> interface is implemented by drivers with an AC97 codec. It only has three methods:</p></div><div class=ulist><ul><li><p><code>xxxac97_init()</code> returns the number of ac97 codecs found.</p></li><li><p><code>ac97_read()</code> and <code>ac97_write()</code> read or write a specified register.</p></li></ul></div><div class=paragraph><p>The <em>AC97</em> interface is used by the AC97 code in <span class=filename>pcm</span> to perform higher level operations. Look at <span class=filename>sound/pci/maestro3.c</span> or many others under <span class=filename>sound/pci/</span> for an example.</p></div></div></div></div></div><div class=sect1><h2 id=pccard>Chapter 16. PC Card<a class=anchor href=#pccard></a></h2><div class=sectionbody><div class=paragraph><p>This chapter will talk about the FreeBSD mechanisms for writing a device driver for a PC Card or CardBus device. However, at present it just documents how to add a new device to an existing pccard driver.</p></div><div class=sect2><h3 id=pccard-adddev>16.1. Adding a Device<a class=anchor href=#pccard-adddev></a></h3><div class=paragraph><p>Device drivers know what devices they support. There is a table of supported devices in the kernel that drivers use to attach to a device.</p></div><div class=sect3><h4 id=pccard-overview>16.1.1. Overview<a class=anchor href=#pccard-overview></a></h4><div class=paragraph><p>PC Cards are identified in one of two ways, both based on the <em>Card Information Structure</em> (CIS) stored on the card. The first method is to use numeric manufacturer and product numbers. The second method is to use the human readable strings that are also contained in the CIS. The PC Card bus uses a centralized database and some macros to facilitate a design pattern to help the driver writer match devices to his driver.</p></div><div class=paragraph><p>Original equipment manufacturers (OEMs) often develop a reference design for a PC Card product, then sell this design to other companies to market. Those companies refine the design, market the product to their target audience or geographic area, and put their own name plate onto the card. The refinements to the physical card are typically very minor, if any changes are made at all. To strengthen their brand, these vendors place their company name in the human readable strings in the CIS space, but leave the manufacturer and product IDs unchanged.</p></div><div class=paragraph><p>Due to this practice, FreeBSD drivers usually rely on numeric IDs for device identification. Using numeric IDs and a centralized database complicates adding IDs and support for cards to the system. One must carefully check to see who really made the card, especially when it appears that the vendor who made the card might already have a different manufacturer ID listed in the central database. Linksys, D-Link, and NetGear are a number of US manufacturers of LAN hardware that often sell the same design. These same designs can be sold in Japan under names such as Buffalo and Corega. Often, these devices will all have the same manufacturer and product IDs.</p></div><div class=paragraph><p>The PC Card bus code keeps a central database of card information, but not which driver is associated with them, in <span class=filename>/sys/dev/pccard/pccarddevs</span>. It also provides a set of macros that allow one to easily construct simple entries in the table the driver uses to claim devices.</p></div><div class=paragraph><p>Finally, some really low end devices do not contain manufacturer identification at all. These devices must be detected by matching the human readable CIS strings. While it would be nice if we did not need this method as a fallback, it is necessary for some very low end CD-ROM players and Ethernet cards. This method should generally be avoided, but a number of devices are listed in this section because they were added prior to the recognition of the OEM nature of the PC Card business. When adding new devices, prefer using the numeric method.</p></div></div><div class=sect3><h4 id=pccard-pccarddevs>16.1.2. Format of <span class=filename>pccarddevs</span><a class=anchor href=#pccard-pccarddevs></a></h4><div class=paragraph><p>There are four sections in the <span class=filename>pccarddevs</span> files. The first section lists the manufacturer numbers for vendors that use them. This section is sorted in numerical order. The next section has all of the products that are used by these vendors, along with their product ID numbers and a description string. The description string typically is not used (instead we set the device’s description based on the human readable CIS, even if we match on the numeric version). These two sections are then repeated for devices that use the string matching method. Finally, C-style comments enclosed in <code>/<strong></strong></code><strong> and <code></code></strong><code>/</code> characters are allowed anywhere in the file.</p></div><div class=paragraph><p>The first section of the file contains the vendor IDs. Please keep this list sorted in numeric order. Also, please coordinate changes to this file because we share it with NetBSD to help facilitate a common clearing house for this information. For example, here are the first few vendor IDs:</p></div><div class="literalblock programlisting"><div class=content><pre>vendor FUJITSU			0x0004  Fujitsu Corporation
vendor NETGEAR_2		0x000b  Netgear
vendor PANASONIC		0x0032	Matsushita Electric Industrial Co.
vendor SANDISK			0x0045	Sandisk Corporation</pre></div></div><div class=paragraph><p>Chances are very good that the <code>NETGEAR_2</code> entry is really an OEM that NETGEAR purchased cards from and the author of support for those cards was unaware at the time that Netgear was using someone else’s ID. These entries are fairly straightforward. The vendor keyword denotes the kind of line that this is, followed by the name of the vendor. This name will be repeated later in <span class=filename>pccarddevs</span>, as well as used in the driver’s match tables, so keep it short and a valid C identifier. A numeric ID in hex identifies the manufacturer. Do not add IDs of the form <code>0xffffffff</code> or <code>0xffff</code> because these are reserved IDs (the former is "no ID set" while the latter is sometimes seen in extremely poor quality cards to try to indicate "none"). Finally there is a string description of the company that makes the card. This string is not used in FreeBSD for anything but commentary purposes.</p></div><div class=paragraph><p>The second section of the file contains the products. As shown in this example, the format is similar to the vendor lines:</p></div><div class="literalblock programlisting"><div class=content><pre>/* Allied Telesis K.K. */
product ALLIEDTELESIS LA_PCM	0x0002 Allied Telesis LA-PCM

/* Archos */
product	ARCHOS ARC_ATAPI	0x0043 MiniCD</pre></div></div><div class=paragraph><p>The <code>product</code> keyword is followed by the vendor name, repeated from above. This is followed by the product name, which is used by the driver and should be a valid C identifier, but may also start with a number. As with the vendors, the hex product ID for this card follows the same convention for <code>0xffffffff</code> and <code>0xffff</code>. Finally, there is a string description of the device itself. This string typically is not used in FreeBSD, since FreeBSD’s pccard bus driver will construct a string from the human readable CIS entries, but it can be used in the rare cases where this is somehow insufficient. The products are in alphabetical order by manufacturer, then numerical order by product ID. They have a C comment before each manufacturer’s entries and there is a blank line between entries.</p></div><div class=paragraph><p>The third section is like the previous vendor section, but with all of the manufacturer numeric IDs set to <code>-1</code>, meaning "match anything found" in the FreeBSD pccard bus code. Since these are C identifiers, their names must be unique. Otherwise the format is identical to the first section of the file.</p></div><div class=paragraph><p>The final section contains the entries for those cards that must be identified by string entries. This section’s format is a little different from the generic section:</p></div><div class="literalblock programlisting"><div class=content><pre>product ADDTRON AWP100		{ &#34;Addtron&#34;, &#34;AWP-100&amp;spWireless&amp;spPCMCIA&#34;, &#34;Version&amp;sp01.02&#34;, NULL }
product ALLIEDTELESIS WR211PCM	{ &#34;Allied&amp;spTelesis&amp;spK.K.&#34;, &#34;WR211PCM&#34;, NULL, NULL } Allied Telesis WR211PCM</pre></div></div><div class=paragraph><p>The familiar <code>product</code> keyword is followed by the vendor name and the card name, just as in the second section of the file. Here the format deviates from that used earlier. There is a {} grouping, followed by a number of strings. These strings correspond to the vendor, product, and extra information that is defined in a CIS_INFO tuple. These strings are filtered by the program that generates <span class=filename>pccarddevs.h</span> to replace &amp;sp with a real space. NULL strings mean that the corresponding part of the entry should be ignored. The example shown here contains a bad entry. It should not contain the version number unless that is critical for the operation of the card. Sometimes vendors will have many different versions of the card in the field that all work, in which case that information only makes it harder for someone with a similar card to use it with FreeBSD. Sometimes it is necessary when a vendor wishes to sell many different parts under the same brand due to market considerations (availability, price, and so forth). Then it can be critical to disambiguating the card in those rare cases where the vendor kept the same manufacturer/product pair. Regular expression matching is not available at this time.</p></div></div><div class=sect3><h4 id=pccard-probe>16.1.3. Sample Probe Routine<a class=anchor href=#pccard-probe></a></h4><div class=paragraph><p>To understand how to add a device to the list of supported devices, one must understand the probe and/or match routines that many drivers have. It is complicated a little in FreeBSD 5.x because there is a compatibility layer for OLDCARD present as well. Since only the window-dressing is different, an idealized version will be presented here.</p></div><div class="literalblock programlisting"><div class=content><pre>static const struct pccard_product wi_pccard_products[] = {
	PCMCIA_CARD(3COM, 3CRWE737A, 0),
	PCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),
	PCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),
	PCMCIA_CARD(TDK, LAK_CD011WL, 0),
	{ NULL }
};

static int
wi_pccard_probe(dev)
	device_t	dev;
{
	const struct pccard_product *pp;

	if ((pp = pccard_product_lookup(dev, wi_pccard_products,
	    sizeof(wi_pccard_products[0]), NULL)) != NULL) {
		if (pp-&gt;pp_name != NULL)
			device_set_desc(dev, pp-&gt;pp_name);
		return (0);
	}
	return (ENXIO);
}</pre></div></div><div class=paragraph><p>Here we have a simple pccard probe routine that matches a few devices. As stated above, the name may vary (if it is not <code>foo_pccard_probe()</code> it will be <code>foo_pccard_match()</code>). The function <code>pccard_product_lookup()</code> is a generalized function that walks the table and returns a pointer to the first entry that it matches. Some drivers may use this mechanism to convey additional information about some cards to the rest of the driver, so there may be some variance in the table. The only requirement is that each row of the table must have a <code>struct pccard_product</code> as the first element.</p></div><div class=paragraph><p>Looking at the table <code>wi_pccard_products</code>, one notices that all the entries are of the form <code>PCMCIA_CARD(<em>foo</em>, <em>bar</em>, <em>baz</em>)</code>. The <em>foo</em> part is the manufacturer ID from <span class=filename>pccarddevs</span>. The <em>bar</em> part is the product ID. <em>baz</em> is the expected function number for this card. Many pccards can have multiple functions, and some way to disambiguate function 1 from function 0 is needed. You may see <code>PCMCIA_CARD_D</code>, which includes the device description from <span class=filename>pccarddevs</span>. You may also see <code>PCMCIA_CARD2</code> and <code>PCMCIA_CARD2_D</code> which are used when you need to match both CIS strings and manufacturer numbers, in the "use the default description" and "take the description from pccarddevs" flavors.</p></div></div><div class=sect3><h4 id=pccard-add>16.1.4. Putting it All Together<a class=anchor href=#pccard-add></a></h4><div class=paragraph><p>To add a new device, one must first obtain the identification information from the device. The easiest way to do this is to insert the device into a PC Card or CF slot and issue <code>devinfo -v</code>. Sample output:</p></div><div class="literalblock programlisting"><div class=content><pre>        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice=0x0300 class=0x060700 at slot=10 function=1
          cardbus1
          pccard1
            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor=&#34;BUFFALO&#34; cisproduct=&#34;WLI2-CF-S11&#34; function_type=6 at function=0</pre></div></div><div class=paragraph><p><code>manufacturer</code> and <code>product</code> are the numeric IDs for this product, while <code>cisvendor</code> and <code>cisproduct</code> are the product description strings from the CIS.</p></div><div class=paragraph><p>Since we first want to prefer the numeric option, first try to construct an entry based on that. The above card has been slightly fictionalized for the purpose of this example. The vendor is BUFFALO, which we see already has an entry:</p></div><div class="literalblock programlisting"><div class=content><pre>vendor BUFFALO			0x026f	BUFFALO (Melco Corporation)</pre></div></div><div class=paragraph><p>But there is no entry for this particular card. Instead we find:</p></div><div class="literalblock programlisting"><div class=content><pre>/* BUFFALO */
product BUFFALO WLI_PCM_S11	0x0305	BUFFALO AirStation 11Mbps WLAN
product BUFFALO LPC_CF_CLT	0x0307	BUFFALO LPC-CF-CLT
product	BUFFALO	LPC3_CLT	0x030a	BUFFALO LPC3-CLT Ethernet Adapter
product BUFFALO WLI_CF_S11G	0x030b	BUFFALO AirStation 11Mbps CF WLAN</pre></div></div><div class=paragraph><p>To add the device, we can just add this entry to <span class=filename>pccarddevs</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>product BUFFALO WLI2_CF_S11G	0x030c	BUFFALO AirStation ultra 802.11b CF</pre></div></div><div class=paragraph><p>Once these steps are complete, the card can be added to the driver. That is a simple operation of adding one line:</p></div><div class="literalblock programlisting"><div class=content><pre>static const struct pccard_product wi_pccard_products[] = {
	PCMCIA_CARD(3COM, 3CRWE737A, 0),
	PCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),
	PCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),
+	PCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),
	PCMCIA_CARD(TDK, LAK_CD011WL, 0),
	{ NULL }
};</pre></div></div><div class=paragraph><p>Note that I have included a ‘+’ in the line before the line that I added, but that is simply to highlight the line. Do not add it to the actual driver. Once you have added the line, you can recompile your kernel or module and test it. If the device is recognized and works, please submit a patch. If it does not work, please figure out what is needed to make it work and submit a patch. If the device is not recognized at all, you have done something wrong and should recheck each step.</p></div><div class=paragraph><p>If you are a FreeBSD src committer, and everything appears to be working, then you can commit the changes to the tree. However, there are some minor tricky things to be considered. <span class=filename>pccarddevs</span> must be committed to the tree first. Then <span class=filename>pccarddevs.h</span> must be regenerated and committed as a second step, ensuring that the right $FreeBSD$ tag is in the latter file. Finally, commit the additions to the driver.</p></div></div><div class=sect3><h4 id=pccard-pr>16.1.5. Submitting a New Device<a class=anchor href=#pccard-pr></a></h4><div class=paragraph><p>Please do not send entries for new devices to the author directly. Instead, submit them as a PR and send the author the PR number for his records. This ensures that entries are not lost. When submitting a PR, it is unnecessary to include the <span class=filename>pccardevs.h</span> diffs in the patch, since those will be regenerated. It is necessary to include a description of the device, as well as the patches to the client driver. If you do not know the name, use OEM99 as the name, and the author will adjust OEM99 accordingly after investigation. Committers should not commit OEM99, but instead find the highest OEM entry and commit one more than that.</p></div></div></div></div></div><h1 id=appendices class=sect0>Part III: Appendices<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=bibliography>Appendix A: Bibliography<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>[1] <em>Marshall Kirk McKusick, Keith Bostic, Michael J Karels, and John S Quarterman.</em> Copyright © 1996 Addison-Wesley Publishing Company, Inc.. 0-201-54979-4. Addison-Wesley Publishing Company, Inc.. The Design and Implementation of the 4.4 BSD Operating System. 1-2.</p></div></div></div><div id=footnotes><hr><div class=footnote id=_footnotedef_1><a href=#_footnoteref_1>1</a>. This prompt will appear if the user presses a key just after selecting an OS to boot at the boot0 stage.</div><div class=footnote id=_footnotedef_2><a href=#_footnoteref_2>2</a>. When in doubt, we refer the reader to the official Intel manuals, which describe the exact semantics for each instruction: .</div><div class=footnote id=_footnotedef_3><a href=#_footnoteref_3>3</a>. There is a file /boot/boot1, but it is not the written to the beginning of the FreeBSD slice. Instead, it is concatenated with boot2 to form boot, which is written to the beginning of the FreeBSD slice and read at boot time.</div><div class=footnote id=_footnotedef_4><a href=#_footnoteref_4>4</a>. Actually we did pass a pointer to the slice entry in register %si. However, boot1 does not assume that it was loaded by boot0 (perhaps some other MBR loaded it, and did not pass this information), so it assumes nothing.</div><div class=footnote id=_footnotedef_5><a href=#_footnoteref_5>5</a>. In the context of 16-bit real mode, a word is 2 bytes.</div><div class=footnote id=_footnotedef_6><a href=#_footnoteref_6>6</a>. 512*16=8192 bytes, exactly the size of boot</div><div class=footnote id=_footnotedef_7><a href=#_footnoteref_7>7</a>. Historically known as disklabel. If you ever wondered where FreeBSD stored this information, it is in this region - see <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a></div><div class=footnote id=_footnotedef_8><a href=#_footnoteref_8>8</a>. This is necessary for legacy reasons. Interested readers should see .</div><div class=footnote id=_footnotedef_9><a href=#_footnoteref_9>9</a>. Real-mode code and data are necessary when switching back to real mode from protected mode, as suggested by the Intel manuals.</div><div class=footnote id=_footnotedef_10><a href=#_footnoteref_10>10</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=bus_generic_read_ivar&amp;sektion=9&amp;format=html">bus_generic_read_ivar(9)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=bus_generic_write_ivar&amp;sektion=9&amp;format=html">bus_generic_write_ivar(9)</a></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: October 1, 2023 by <a href="https://cgit.freebsd.org/doc/commit/?id=03eb27a31b" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#kernel>Part I: Kernel</a><ul><li><a href=#boot>Chapter 1. Bootstrapping and Kernel Initialization</a></li><li><a href=#locking>Chapter 2. Locking Notes</a></li><li><a href=#kernel-objects>Chapter 3. Kernel Objects</a></li><li><a href=#jail>Chapter 4. The Jail Subsystem</a></li><li><a href=#sysinit>Chapter 5. The SYSINIT Framework</a></li><li><a href=#mac>Chapter 6. The TrustedBSD MAC Framework</a></li><li><a href=#vm>Chapter 7. Virtual Memory System</a></li><li><a href=#smp>Chapter 8. SMPng Design Document</a></li></ul></li><li><a href=#devicedrivers>Part II: Device Drivers</a><ul><li><a href=#driverbasics>Chapter 9. Writing FreeBSD Device Drivers</a></li><li><a href=#isa-driver>Chapter 10. ISA Device Drivers</a></li><li><a href=#pci>Chapter 11. PCI Devices</a></li><li><a href=#scsi>Chapter 12. Common Access Method SCSI Controllers</a></li><li><a href=#usb>Chapter 13. USB Devices</a></li><li><a href=#newbus>Chapter 14. Newbus</a></li><li><a href=#oss>Chapter 15. Sound Subsystem</a></li><li><a href=#pccard>Chapter 16. PC Card</a></li></ul></li><li><a href=#appendices>Part III: Appendices</a><ul><li><a href=#bibliography>Appendix A: Bibliography</a></li></ul></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/arch-handbook/arch-handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/book target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/en/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>