<!doctype html><html class=theme-light lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The Jail Subsystem"><meta name=keywords content="jail,architecture,networking,kernel"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/en/books/arch-handbook/jail/><title>Chapter 4. The Jail Subsystem | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapter 4. The Jail Subsystem"><meta property="og:description" content="The Jail Subsystem"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="http://172.16.201.134:1313/en/books/arch-handbook/jail/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/en\/books\/arch-handbook\/jail\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/en/books>Books</a></li><li><a href=http://172.16.201.134:1313/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>â™¥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-6dcd22d99f78db2a9aacae23be13866e class=toggle>
<label for=chapter-6dcd22d99f78db2a9aacae23be13866e><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/parti/>Part I. Kernel</a></li><li><input type=checkbox id=chapter-9cc61bc35df69063dc03a5911e1ad9c9 class=toggle>
<label class="icon cursor" for=chapter-9cc61bc35df69063dc03a5911e1ad9c9><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/>Chapter 1. Bootstrapping and Kernel Initialization</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-synopsis>1.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-overview>1.2. Overview</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-bios>1.3. The BIOS</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-boot0>1.4. The Master Boot Record (<code>boot0</code>)</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-boot1>1.5. <code>boot1</code> Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#btx-server>1.6. The BTX Server</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot2>1.7. boot2 Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-loader>1.8. loader Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-kernel>1.9. Kernel Initialization</a></li></ul></li><li><input type=checkbox id=chapter-3a651b0a4b9f6238336624d3c0fa5187 class=toggle>
<label class="icon cursor" for=chapter-3a651b0a4b9f6238336624d3c0fa5187><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/>Chapter 2. Locking Notes</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-mutexes>2.1. Mutexes</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-sx>2.2. Shared Exclusive Locks</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-atomic>2.3. Atomically Protected Variables</a></li></ul></li><li><input type=checkbox id=chapter-bf0b823c107a80f3035dfd6fae09d023 class=toggle>
<label class="icon cursor" for=chapter-bf0b823c107a80f3035dfd6fae09d023><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/>Chapter 3. Kernel Objects</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-term>3.1. Terminology</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-operation>3.2. Kobj Operation</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-using>3.3. Using Kobj</a></li></ul></li><li><input type=checkbox id=chapter-41dab1afed6cf3ffa54628db4227e196 class=toggle checked>
<label class="icon cursor" for=chapter-41dab1afed6cf3ffa54628db4227e196><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/>Chapter 4. The Jail Subsystem</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/#jail-arch>4.1. Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/#jail-restrictions>4.2. Restrictions</a></li></ul></li><li><input type=checkbox id=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8 class=toggle>
<label class="icon cursor" for=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/>Chapter 5. The SYSINIT Framework</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-term>5.1. Terminology</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-operation>5.2. SYSINIT Operation</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-using>5.3. Using SYSINIT</a></li></ul></li><li><input type=checkbox id=chapter-8b57b16ba53538421a8fb2152b25976f class=toggle>
<label class="icon cursor" for=chapter-8b57b16ba53538421a8fb2152b25976f><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/>Chapter 6. The TrustedBSD MAC Framework</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-copyright>6.1. MAC Documentation Copyright</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-synopsis>6.2. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-introduction>6.3. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-background>6.4. Policy Background</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-framework-kernel-arch>6.5. MAC Framework Kernel Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-policy-architecture>6.6. MAC Policy Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-entry-point-reference>6.7. MAC Policy Entry Point Reference</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-userland-arch>6.8. Userland Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-conclusion>6.9. Conclusion</a></li></ul></li><li><input type=checkbox id=chapter-28609916419208e3a19d240cf7593906 class=toggle>
<label class="icon cursor" for=chapter-28609916419208e3a19d240cf7593906><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/>Chapter 7. Virtual Memory System</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-physmem>7.1. Management of Physical Memory <code>vm_page_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-cache>7.2. The Unified Buffer Cache <code>vm_object_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-fileio>7.3. Filesystem I/O <code>struct buf</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-pagetables>7.4. Mapping Page Tables <code>vm_map_t, vm_entry_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-kvm>7.5. KVM Memory Mapping</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-tuning>7.6. Tuning the FreeBSD VM System</a></li></ul></li><li><input type=checkbox id=chapter-716edd44e8ad22ea57cdf273d2578872 class=toggle>
<label class="icon cursor" for=chapter-716edd44e8ad22ea57cdf273d2578872><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/>Chapter 8. SMPng Design Document</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-intro>8.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-lock-fundamentals>8.2. Basic Tools and Locking Fundamentals</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-design>8.3. General Architecture and Design</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-lock-strategies>8.4. Specific Locking Strategies</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-implementation-notes>8.5. Implementation Notes</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-misc>8.6. Miscellaneous Topics</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-glossary>Glossary</a></li></ul></li><li><input type=checkbox id=chapter-448f803e40f97b1ff8336db9ba637745 class=toggle>
<label for=chapter-448f803e40f97b1ff8336db9ba637745><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/partii/>Part II. Device Drivers</a></li><li><input type=checkbox id=chapter-6971d35b0bbe2a0bdb005a02546cd580 class=toggle>
<label class="icon cursor" for=chapter-6971d35b0bbe2a0bdb005a02546cd580><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/>Chapter 9. Writing FreeBSD Device Drivers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-intro>9.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-kld>9.2. Dynamic Kernel Linker Facility - KLD</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-char>9.3. Character Devices</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-block>9.4. Block Devices (Are Gone)</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-net>9.5. Network Drivers</a></li></ul></li><li><input type=checkbox id=chapter-9cc7968be065b256e57086439d93e9a4 class=toggle>
<label class="icon cursor" for=chapter-9cc7968be065b256e57086439d93e9a4><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/>Chapter 10. ISA Device Drivers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-synopsis>10.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-basics>10.2. Basic Information</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-device-t>10.3. <code>device_t</code> Pointer</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-resources>10.5. Resources</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-busmem>10.6. Bus Memory Mapping</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-dma>10.7. DMA</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-probe>10.8. xxx_isa_probe</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-attach>10.9. xxx_isa_attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-detach>10.10. xxx_isa_detach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-shutdown>10.11. xxx_isa_shutdown</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-intr>10.12. xxx_intr</a></li></ul></li><li><input type=checkbox id=chapter-0b427d421e89aa3107f62d5b70f6a0f2 class=toggle>
<label class="icon cursor" for=chapter-0b427d421e89aa3107f62d5b70f6a0f2><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/>Chapter 11. PCI Devices</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/#pci-probe>11.1. Probe and Attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/#pci-bus>11.2. Bus Resources</a></li></ul></li><li><input type=checkbox id=chapter-0b7eb8d45a0ea6bc9c2882e903b93959 class=toggle>
<label class="icon cursor" for=chapter-0b7eb8d45a0ea6bc9c2882e903b93959><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/>Chapter 12. Common Access Method SCSI Controllers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-synopsis>12.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-general>12.2. General Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_globals_and_boilerplate>12.3. Globals and Boilerplate</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-polling>12.6. Polling xxx_poll</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-async>12.7. Asynchronous Events</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-interrupts>12.8. Interrupts</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-errors>12.9. Errors Summary</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-timeout>12.10. Timeout Handling</a></li></ul></li><li><input type=checkbox id=chapter-bdaa4909dfbdcec8d7be976fd87cb00e class=toggle>
<label class="icon cursor" for=chapter-bdaa4909dfbdcec8d7be976fd87cb00e><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/>Chapter 13. USB Devices</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-intro>13.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-hc>13.2. Host Controllers</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-dev>13.3. USB Device Information</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-devprobe>13.4. Device Probe and Attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-protocol>13.5. USB Drivers Protocol Information</a></li></ul></li><li><input type=checkbox id=chapter-5fc5c179f5014d968a5c8feec7e10e59 class=toggle>
<label class="icon cursor" for=chapter-5fc5c179f5014d968a5c8feec7e10e59><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/>Chapter 14. Newbus</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-devdrivers>14.1. Device Drivers</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-overview>14.2. Overview of Newbus</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-api>14.3. Newbus API</a></li></ul></li><li><input type=checkbox id=chapter-7d3796cced00105c77e7f87e84edd73b class=toggle>
<label class="icon cursor" for=chapter-7d3796cced00105c77e7f87e84edd73b><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/>Chapter 15. Sound Subsystem</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-intro>15.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-files>15.2. Files</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#pcm-probe-and-attach>15.3. Probing, Attaching, etc.</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-interfaces>15.4. Interfaces</a></li></ul></li><li><input type=checkbox id=chapter-41c74c3e72fcf5116f6d999c36ef185b class=toggle>
<label class="icon cursor" for=chapter-41c74c3e72fcf5116f6d999c36ef185b><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/pccard/>Chapter 16. PC Card</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pccard/#pccard-adddev>16.1. Adding a Device</a></li></ul></li><li><input type=checkbox id=chapter-2a7cf37011599a8e3d62d1e3008c3c5d class=toggle>
<label for=chapter-2a7cf37011599a8e3d62d1e3008c3c5d><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/partiii/>Part III. Appendices</a></li><li><input type=checkbox id=chapter-d4c82056f0235da9fde0d29203d44f9a class=toggle>
<label for=chapter-d4c82056f0235da9fde0d29203d44f9a><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/bibliography/>Bibliography</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapter 4. The Jail Subsystem</h1><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#jail-arch>4.1. Architecture</a></li><li><a href=#jail-restrictions>4.2. Restrictions</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class=paragraph><p>On most UNIXÂ® systems, <code>root</code> has omnipotent power. This promotes insecurity. If an attacker gained <code>root</code> on a system, he would have every function at his fingertips. In FreeBSD there are sysctls which dilute the power of <code>root</code>, in order to minimize the damage caused by an attacker. Specifically, one of these functions is called <code>secure levels</code>. Similarly, another function which is present from FreeBSD 4.0 and onward, is a utility called <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Jail chroots an environment and sets certain restrictions on processes which are forked within the jail. For example, a jailed process cannot affect processes outside the jail, utilize certain system calls, or inflict any damage on the host environment.</p></div><div class=paragraph><p>Jail is becoming the new security model. People are running potentially vulnerable servers such as Apache, BIND, and sendmail within jails, so that if an attacker gains <code>root</code> within the jail, it is only an annoyance, and not a devastation. This article mainly focuses on the internals (source code) of jail. For information on how to set up a jail see the <a href=https://docs.freebsd.org/en/books/handbook/#jails>handbook entry on jails</a>.</p></div></div></div><div class=sect1><h2 id=jail-arch>4.1. Architecture<a class=anchor href=#jail-arch></a></h2><div class=sectionbody><div class=paragraph><p>Jail consists of two realms: the userland program, <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>, and the code implemented within the kernel: the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call and associated restrictions. I will be discussing the userland program and then how jail is implemented within the kernel.</p></div><div class=sect2><h3 id=_userland_code>4.1.1. Userland Code<a class=anchor href=#_userland_code></a></h3><div class=paragraph><p>The source for the userland jail is located in <span class=filename>/usr/src/usr.sbin/jail</span>, consisting of one file, <span class=filename>jail.c</span>. The program takes these arguments: the path of the jail, hostname, IP address, and the command to be executed.</p></div><div class=sect3><h4 id=_data_structures>4.1.1.1. Data Structures<a class=anchor href=#_data_structures></a></h4><div class=paragraph><p>In <span class=filename>jail.c</span>, the first thing I would note is the declaration of an important structure <code>struct jail j;</code> which was included from <span class=filename>/usr/include/sys/jail.h</span>.</p></div><div class=paragraph><p>The definition of the <code>jail</code> structure is:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/jail.h:

struct jail {
        u_int32_t       version;
        char            *path;
        char            *hostname;
        u_int32_t       ip_number;
};</pre></div></div><div class=paragraph><p>As you can see, there is an entry for each of the arguments passed to the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> program, and indeed, they are set during its execution.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/usr.sbin/jail/jail.c
char path[PATH_MAX];
...
if (realpath(argv[0], path) == NULL)
    err(1, &#34;realpath: %s&#34;, argv[0]);
if (chdir(path) != 0)
    err(1, &#34;chdir: %s&#34;, path);
memset(&amp;j, 0, sizeof(j));
j.version = 0;
j.path = path;
j.hostname = argv[1];</pre></div></div></div><div class=sect3><h4 id=_networking>4.1.1.2. Networking<a class=anchor href=#_networking></a></h4><div class=paragraph><p>One of the arguments passed to the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> program is an IP address with which the jail can be accessed over the network. <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> translates the IP address given into host byte order and then stores it in <code>j</code> (the <code>jail</code> structure).</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/usr.sbin/jail/jail.c:
struct in_addr in;
...
if (inet_aton(argv[2], &amp;in) == 0)
    errx(1, &#34;Could not make sense of ip-number: %s&#34;, argv[2]);
j.ip_number = ntohl(in.s_addr);</pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=inet_aton&amp;sektion=3&amp;format=html">inet_aton(3)</a> function "interprets the specified character string as an Internet address, placing the address into the structure provided." The <code>ip_number</code> member in the <code>jail</code> structure is set only when the IP address placed onto the <code>in</code> structure by <a href="https://man.freebsd.org/cgi/man.cgi?query=inet_aton&amp;sektion=3&amp;format=html">inet_aton(3)</a> is translated into host byte order by <a href="https://man.freebsd.org/cgi/man.cgi?query=ntohl&amp;sektion=3&amp;format=html">ntohl(3)</a>.</p></div></div><div class=sect3><h4 id=_jailing_the_process>4.1.1.3. Jailing the Process<a class=anchor href=#_jailing_the_process></a></h4><div class=paragraph><p>Finally, the userland program jails the process. Jail now becomes an imprisoned process itself and then executes the command given using <a href="https://man.freebsd.org/cgi/man.cgi?query=execv&amp;sektion=3&amp;format=html">execv(3)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/usr.sbin/jail/jail.c
i = jail(&amp;j);
...
if (execv(argv[3], argv + 3) != 0)
    err(1, &#34;execv: %s&#34;, argv[3]);</pre></div></div><div class=paragraph><p>As you can see, the <code>jail()</code> function is called, and its argument is the <code>jail</code> structure which has been filled with the arguments given to the program. Finally, the program you specify is executed. I will now discuss how jail is implemented within the kernel.</p></div></div></div><div class=sect2><h3 id=_kernel_space>4.1.2. Kernel Space<a class=anchor href=#_kernel_space></a></h3><div class=paragraph><p>We will now be looking at the file <span class=filename>/usr/src/sys/kern/kern_jail.c</span>. This is the file where the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call, appropriate sysctls, and networking functions are defined.</p></div><div class=sect3><h4 id=_sysctls>4.1.2.1. Sysctls<a class=anchor href=#_sysctls></a></h4><div class=paragraph><p>In <span class=filename>kern_jail.c</span>, the following sysctls are defined:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
int     jail_set_hostname_allowed = 1;
SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,
    &amp;jail_set_hostname_allowed, 0,
    &#34;Processes in jail can set their hostnames&#34;);

int     jail_socket_unixiproute_only = 1;
SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,
    &amp;jail_socket_unixiproute_only, 0,
    &#34;Processes in jail are limited to creating UNIX/IPv4/route sockets only&#34;);

int     jail_sysvipc_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,
    &amp;jail_sysvipc_allowed, 0,
    &#34;Processes in jail can use System V IPC primitives&#34;);

static int jail_enforce_statfs = 2;
SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,
    &amp;jail_enforce_statfs, 0,
    &#34;Processes in jail cannot see all mounted file systems&#34;);

int    jail_allow_raw_sockets = 0;
SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,
    &amp;jail_allow_raw_sockets, 0,
    &#34;Prison root can create raw sockets&#34;);

int    jail_chflags_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,
    &amp;jail_chflags_allowed, 0,
    &#34;Processes in jail can alter system file flags&#34;);

int     jail_mount_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,
    &amp;jail_mount_allowed, 0,
    &#34;Processes in jail can mount/unmount jail-friendly file systems&#34;);</pre></div></div><div class=paragraph><p>Each of these sysctls can be accessed by the user through the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> program. Throughout the kernel, these specific sysctls are recognized by their name. For example, the name of the first sysctl is <code>security.jail.set_hostname_allowed</code>.</p></div></div><div class=sect3><h4 id=_jail2_system_call>4.1.2.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> System Call<a class=anchor href=#_jail2_system_call></a></h4><div class=paragraph><p>Like all system calls, the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call takes two arguments, <code>struct thread *td</code> and <code>struct jail_args *uap</code>. <code>td</code> is a pointer to the <code>thread</code> structure which describes the calling thread. In this context, <code>uap</code> is a pointer to the structure in which a pointer to the <code>jail</code> structure passed by the userland <span class=filename>jail.c</span> is contained. When I described the userland program before, you saw that the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call was given a <code>jail</code> structure as its own argument.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
/*
 * struct jail_args {
 *  struct jail *jail;
 * };
 */
int
jail(struct thread *td, struct jail_args *uap)</pre></div></div><div class=paragraph><p>Therefore, <code>uapâ†’jail</code> can be used to access the <code>jail</code> structure which was passed to the system call. Next, the system call copies the <code>jail</code> structure into kernel space using the <a href="https://man.freebsd.org/cgi/man.cgi?query=copyin&amp;sektion=9&amp;format=html">copyin(9)</a> function. <a href="https://man.freebsd.org/cgi/man.cgi?query=copyin&amp;sektion=9&amp;format=html">copyin(9)</a> takes three arguments: the address of the data which is to be copied into kernel space, <code>uapâ†’jail</code>, where to store it, <code>j</code> and the size of the storage. The <code>jail</code> structure pointed by <code>uapâ†’jail</code> is copied into kernel space and is stored in another <code>jail</code> structure, <code>j</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
error = copyin(uap-&gt;jail, &amp;j, sizeof(j));</pre></div></div><div class=paragraph><p>There is another important structure defined in <span class=filename>jail.h</span>. It is the <code>prison</code> structure. The <code>prison</code> structure is used exclusively within kernel space. Here is the definition of the <code>prison</code> structure.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/jail.h:
struct prison {
        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */
        int              pr_id;                         /* (c) prison id */
        int              pr_ref;                        /* (p) refcount */
        char             pr_path[MAXPATHLEN];           /* (c) chroot path */
        struct vnode    *pr_root;                       /* (c) vnode to rdir */
        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname */
        u_int32_t        pr_ip;                         /* (c) ip addr host */
        void            *pr_linux;                      /* (p) linux abi */
        int              pr_securelevel;                /* (p) securelevel */
        struct task      pr_task;                       /* (d) destroy task */
        struct mtx       pr_mtx;
      void            **pr_slots;                     /* (p) additional data */
};</pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call then allocates memory for a <code>prison</code> structure and copies data between the <code>jail</code> and <code>prison</code> structure.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);
...
error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);
if (error)
    goto e_killmtx;
...
error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), 0);
if (error)
     goto e_dropvnref;
pr-&gt;pr_ip = j.ip_number;</pre></div></div><div class=paragraph><p>Next, we will discuss another important system call <a href="https://man.freebsd.org/cgi/man.cgi?query=jail_attach&amp;sektion=2&amp;format=html">jail_attach(2)</a>, which implements the function to put a process into the jail.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
/*
 * struct jail_attach_args {
 *      int jid;
 * };
 */
int
jail_attach(struct thread *td, struct jail_attach_args *uap)</pre></div></div><div class=paragraph><p>This system call makes the changes that can distinguish a jailed process from those unjailed ones. To understand what <a href="https://man.freebsd.org/cgi/man.cgi?query=jail_attach&amp;sektion=2&amp;format=html">jail_attach(2)</a> does for us, certain background information is needed.</p></div><div class=paragraph><p>On FreeBSD, each kernel visible thread is identified by its <code>thread</code> structure, while the processes are described by their <code>proc</code> structures. You can find the definitions of the <code>thread</code> and <code>proc</code> structure in <span class=filename>/usr/include/sys/proc.h</span>. For example, the <code>td</code> argument in any system call is actually a pointer to the calling threadâ€™s <code>thread</code> structure, as stated before. The <code>td_proc</code> member in the <code>thread</code> structure pointed by <code>td</code> is a pointer to the <code>proc</code> structure which represents the process that contains the thread represented by <code>td</code>. The <code>proc</code> structure contains members which can describe the ownerâ€™s identity(<code>p_ucred</code>), the process resource limits(<code>p_limit</code>), and so on. In the <code>ucred</code> structure pointed by <code>p_ucred</code> member in the <code>proc</code> structure, there is a pointer to the <code>prison</code> structure(<code>cr_prison</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/proc.h:
struct thread {
    ...
    struct proc *td_proc;
    ...
};
struct proc {
    ...
    struct ucred *p_ucred;
    ...
};
/usr/include/sys/ucred.h
struct ucred {
    ...
    struct prison *cr_prison;
    ...
};</pre></div></div><div class=paragraph><p>In <span class=filename>kern_jail.c</span>, the function <code>jail()</code> then calls function <code>jail_attach()</code> with a given <code>jid</code>. And <code>jail_attach()</code> calls function <code>change_root()</code> to change the root directory of the calling process. The <code>jail_attach()</code> then creates a new <code>ucred</code> structure, and attaches the newly created <code>ucred</code> structure to the calling process after it has successfully attached the <code>prison</code> structure to the <code>ucred</code> structure. From then on, the calling process is recognized as jailed. When the kernel routine <code>jailed()</code> is called in the kernel with the newly created <code>ucred</code> structure as its argument, it returns 1 to tell that the credential is connected with a jail. The public ancestor process of all the process forked within the jail, is the process which runs <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>, as it calls the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;format=html">jail(2)</a> system call. When a program is executed through <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a>, it inherits the jailed property of its parentâ€™s <code>ucred</code> structure, therefore it has a jailed <code>ucred</code> structure.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c
int
jail(struct thread *td, struct jail_args *uap)
{
...
    struct jail_attach_args jaa;
...
    error = jail_attach(td, &amp;jaa);
    if (error)
        goto e_dropprref;
...
}

int
jail_attach(struct thread *td, struct jail_attach_args *uap)
{
    struct proc *p;
    struct ucred *newcred, *oldcred;
    struct prison *pr;
...
    p = td-&gt;td_proc;
...
    pr = prison_find(uap-&gt;jid);
...
    change_root(pr-&gt;pr_root, td);
...
    newcred-&gt;cr_prison = pr;
    p-&gt;p_ucred = newcred;
...
}</pre></div></div><div class=paragraph><p>When a process is forked from its parent process, the <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> system call uses <code>crhold()</code> to maintain the credential for the newly forked process. It inherently keep the newly forked childâ€™s credential consistent with its parent, so the child process is also jailed.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_fork.c:
p2-&gt;p_ucred = crhold(td-&gt;td_ucred);
...
td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);</pre></div></div></div></div></div></div><div class=sect1><h2 id=jail-restrictions>4.2. Restrictions<a class=anchor href=#jail-restrictions></a></h2><div class=sectionbody><div class=paragraph><p>Throughout the kernel there are access restrictions relating to jailed processes. Usually, these restrictions only check whether the process is jailed, and if so, returns an error. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>if (jailed(td-&gt;td_ucred))
    return (EPERM);</pre></div></div><div class=sect2><h3 id=_sysv_ipc>4.2.1. SysV IPC<a class=anchor href=#_sysv_ipc></a></h3><div class=paragraph><p>System V IPC is based on messages. Processes can send each other these messages which tell them how to act. The functions which deal with messages are: <a href="https://man.freebsd.org/cgi/man.cgi?query=msgctl&amp;sektion=3&amp;format=html">msgctl(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=msgget&amp;sektion=3&amp;format=html">msgget(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=msgsnd&amp;sektion=3&amp;format=html">msgsnd(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=msgrcv&amp;sektion=3&amp;format=html">msgrcv(3)</a>. Earlier, I mentioned that there were certain sysctls you could turn on or off in order to affect the behavior of jail. One of these sysctls was <code>security.jail.sysvipc_allowed</code>. By default, this sysctl is set to 0. If it were set to 1, it would defeat the whole purpose of having a jail; privileged users from the jail would be able to affect processes outside the jailed environment. The difference between a message and a signal is that the message only consists of the signal number.</p></div><div class=paragraph><p><span class=filename>/usr/src/sys/kern/sysv_msg.c</span>:</p></div><div class=ulist><ul><li><p><code>msgget(key, msgflg)</code>: <code>msgget</code> returns (and possibly creates) a message descriptor that designates a message queue for use in other functions.</p></li><li><p><code>msgctl(msgid, cmd, buf)</code>: Using this function, a process can query the status of a message descriptor.</p></li><li><p><code>msgsnd(msgid, msgp, msgsz, msgflg)</code>: <code>msgsnd</code> sends a message to a process.</p></li><li><p><code>msgrcv(msgid, msgp, msgsz, msgtyp, msgflg)</code>: a process receives messages using this function</p></li></ul></div><div class=paragraph><p>In each of the system calls corresponding to these functions, there is this conditional:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/sysv_msg.c:
if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))
    return (ENOSYS);</pre></div></div><div class=paragraph><p>Semaphore system calls allow processes to synchronize execution by doing a set of operations atomically on a set of semaphores. Basically semaphores provide another way for processes lock resources. However, process waiting on a semaphore, that is being used, will sleep until the resources are relinquished. The following semaphore system calls are blocked inside a jail: <a href="https://man.freebsd.org/cgi/man.cgi?query=semget&amp;sektion=2&amp;format=html">semget(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=semctl&amp;sektion=2&amp;format=html">semctl(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=semop&amp;sektion=2&amp;format=html">semop(2)</a>.</p></div><div class=paragraph><p><span class=filename>/usr/src/sys/kern/sysv_sem.c</span>:</p></div><div class=ulist><ul><li><p><code>semctl(semid, semnum, cmd, â€¦â€‹)</code>: <code>semctl</code> does the specified <code>cmd</code> on the semaphore queue indicated by <code>semid</code>.</p></li><li><p><code>semget(key, nsems, flag)</code>: <code>semget</code> creates an array of semaphores, corresponding to <code>key</code>.</p><div class=paragraph><p><code>key and flag take on the same meaning as they do in msgget.</code></p></div></li><li><p><code>semop(semid, array, nops)</code>: <code>semop</code> performs a group of operations indicated by <code>array</code>, to the set of semaphores identified by <code>semid</code>.</p></li></ul></div><div class=paragraph><p>System V IPC allows for processes to share memory. Processes can communicate directly with each other by sharing parts of their virtual address space and then reading and writing data stored in the shared memory. These system calls are blocked within a jailed environment: <a href="https://man.freebsd.org/cgi/man.cgi?query=shmdt&amp;sektion=2&amp;format=html">shmdt(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=shmat&amp;sektion=2&amp;format=html">shmat(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=shmctl&amp;sektion=2&amp;format=html">shmctl(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=shmget&amp;sektion=2&amp;format=html">shmget(2)</a>.</p></div><div class=paragraph><p><span class=filename>/usr/src/sys/kern/sysv_shm.c</span>:</p></div><div class=ulist><ul><li><p><code>shmctl(shmid, cmd, buf)</code>: <code>shmctl</code> does various control operations on the shared memory region identified by <code>shmid</code>.</p></li><li><p><code>shmget(key, size, flag)</code>: <code>shmget</code> accesses or creates a shared memory region of <code>size</code> bytes.</p></li><li><p><code>shmat(shmid, addr, flag)</code>: <code>shmat</code> attaches a shared memory region identified by <code>shmid</code> to the address space of a process.</p></li><li><p><code>shmdt(addr)</code>: <code>shmdt</code> detaches the shared memory region previously attached at <code>addr</code>.</p></li></ul></div></div><div class=sect2><h3 id=_sockets>4.2.2. Sockets<a class=anchor href=#_sockets></a></h3><div class=paragraph><p>Jail treats the <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> system call and related lower-level socket functions in a special manner. In order to determine whether a certain socket is allowed to be created, it first checks to see if the sysctl <code>security.jail.socket_unixiproute_only</code> is set. If set, sockets are only allowed to be created if the family specified is either <code>PF_LOCAL</code>, <code>PF_INET</code> or <code>PF_ROUTE</code>. Otherwise, it returns an error.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/uipc_socket.c:
int
socreate(int dom, struct socket **aso, int type, int proto,
    struct ucred *cred, struct thread *td)
{
    struct protosw *prp;
...
    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {
        return (EPROTONOSUPPORT);
    }
...
}</pre></div></div></div><div class=sect2><h3 id=_berkeley_packet_filter>4.2.3. Berkeley Packet Filter<a class=anchor href=#_berkeley_packet_filter></a></h3><div class=paragraph><p>The Berkeley Packet Filter provides a raw interface to data link layers in a protocol independent fashion. BPF is now controlled by the <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> whether it can be used in a jailed environment.</p></div></div><div class=sect2><h3 id=_protocols>4.2.4. Protocols<a class=anchor href=#_protocols></a></h3><div class=paragraph><p>There are certain protocols which are very common, such as TCP, UDP, IP and ICMP. IP and ICMP are on the same level: the network layer 2. There are certain precautions which are taken in order to prevent a jailed process from binding a protocol to a certain address only if the <code>nam</code> parameter is set. <code>nam</code> is a pointer to a <code>sockaddr</code> structure, which describes the address on which to bind the service. A more exact definition is that <code>sockaddr</code> "may be used as a template for referring to the identifying tag and length of each address". In the function <code>in_pcbbind_setup()</code>, <code>sin</code> is a pointer to a <code>sockaddr_in</code> structure, which contains the port, address, length and domain family of the socket which is to be bound. Basically, this disallows any processes from jail to be able to specify the address that does not belong to the jail in which the calling process exists.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/netinet/in_pcb.c:
int
in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,
    u_short *lportp, struct ucred *cred)
{
    ...
    struct sockaddr_in *sin;
    ...
    if (nam) {
        sin = (struct sockaddr_in *)nam;
        ...
        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)
            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))
                return(EINVAL);
        ...
        if (lport) {
            ...
            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))
                return (EADDRNOTAVAIL);
            ...
        }
    }
    if (lport == 0) {
        ...
        if (laddr.s_addr != INADDR_ANY)
            if (prison_ip(cred, 0, &amp;laddr.s_addr))
                return (EINVAL);
        ...
    }
...
    if (prison_ip(cred, 0, &amp;laddr.s_addr))
        return (EINVAL);
...
}</pre></div></div><div class=paragraph><p>You might be wondering what function <code>prison_ip()</code> does. <code>prison_ip()</code> is given three arguments, a pointer to the credential(represented by <code>cred</code>), any flags, and an IP address. It returns 1 if the IP address does NOT belong to the jail or 0 otherwise. As you can see from the code, if it is indeed an IP address not belonging to the jail, the protocol is not allowed to bind to that address.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/kern/kern_jail.c:
int
prison_ip(struct ucred *cred, int flag, u_int32_t *ip)
{
    u_int32_t tmp;

    if (!jailed(cred))
        return (0);
    if (flag)
        tmp = *ip;
    else
        tmp = ntohl(*ip);
    if (tmp == INADDR_ANY) {
        if (flag)
            *ip = cred-&gt;cr_prison-&gt;pr_ip;
        else
            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);
        return (0);
    }
    if (tmp == INADDR_LOOPBACK) {
        if (flag)
            *ip = cred-&gt;cr_prison-&gt;pr_ip;
        else
            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);
        return (0);
    }
    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)
        return (1);
    return (0);
}</pre></div></div></div><div class=sect2><h3 id=_filesystem>4.2.5. Filesystem<a class=anchor href=#_filesystem></a></h3><div class=paragraph><p>Even <code>root</code> users within the jail are not allowed to unset or modify any file flags, such as immutable, append-only, and undeleteable flags, if the securelevel is greater than 0.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/ufs/ufs/ufs_vnops.c:
static int
ufs_setattr(ap)
    ...
{
    ...
        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {
            if (ip-&gt;i_flags
                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {
                    error = securelevel_gt(cred, 0);
                    if (error)
                        return (error);
            }
            ...
        }
}
/usr/src/sys/kern/kern_priv.c
int
priv_check_cred(struct ucred *cred, int priv, int flags)
{
    ...
    error = prison_priv_check(cred, priv);
    if (error)
        return (error);
    ...
}
/usr/src/sys/kern/kern_jail.c
int
prison_priv_check(struct ucred *cred, int priv)
{
    ...
    switch (priv) {
    ...
    case PRIV_VFS_SYSFLAGS:
        if (jail_chflags_allowed)
            return (0);
        else
            return (EPERM);
    ...
    }
    ...
}</pre></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: March 9, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#jail-arch>4.1. Architecture</a></li><li><a href=#jail-restrictions>4.2. Restrictions</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/arch-handbook/arch-handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/en/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>â™¥</span> by the FreeBSD Community</span></section></div></footer></body></html>