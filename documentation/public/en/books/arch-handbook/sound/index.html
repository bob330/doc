<!doctype html><html class=theme-light lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="FreeBSD Sound Subsystem"><meta name=keywords content="Sound,OSS,pcm,mixer"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/en/books/arch-handbook/sound/><title>Chapter 15. Sound Subsystem | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapter 15. Sound Subsystem"><meta property="og:description" content="FreeBSD Sound Subsystem"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="https://docs.freebsd.org/en/books/arch-handbook/sound/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/en\/books\/arch-handbook\/sound\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=https://docs.freebsd.org/en/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/en/books>Books</a></li><li><a href=https://docs.freebsd.org/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-6dcd22d99f78db2a9aacae23be13866e class=toggle>
<label for=chapter-6dcd22d99f78db2a9aacae23be13866e><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/parti/>Part I. Kernel</a></li><li><input type=checkbox id=chapter-9cc61bc35df69063dc03a5911e1ad9c9 class=toggle>
<label class="icon cursor" for=chapter-9cc61bc35df69063dc03a5911e1ad9c9><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/>Chapter 1. Bootstrapping and Kernel Initialization</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot-synopsis>1.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot-overview>1.2. Overview</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot-bios>1.3. The BIOS</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot-boot0>1.4. The Master Boot Record (<code>boot0</code>)</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot-boot1>1.5. <code>boot1</code> Stage</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#btx-server>1.6. The BTX Server</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot2>1.7. boot2 Stage</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot-loader>1.8. loader Stage</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/boot/#boot-kernel>1.9. Kernel Initialization</a></li></ul></li><li><input type=checkbox id=chapter-3a651b0a4b9f6238336624d3c0fa5187 class=toggle>
<label class="icon cursor" for=chapter-3a651b0a4b9f6238336624d3c0fa5187><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/locking/>Chapter 2. Locking Notes</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/locking/#locking-mutexes>2.1. Mutexes</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/locking/#locking-sx>2.2. Shared Exclusive Locks</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/locking/#locking-atomic>2.3. Atomically Protected Variables</a></li></ul></li><li><input type=checkbox id=chapter-bf0b823c107a80f3035dfd6fae09d023 class=toggle>
<label class="icon cursor" for=chapter-bf0b823c107a80f3035dfd6fae09d023><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/kobj/>Chapter 3. Kernel Objects</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/kobj/#kernel-objects-term>3.1. Terminology</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/kobj/#kernel-objects-operation>3.2. Kobj Operation</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/kobj/#kernel-objects-using>3.3. Using Kobj</a></li></ul></li><li><input type=checkbox id=chapter-41dab1afed6cf3ffa54628db4227e196 class=toggle>
<label class="icon cursor" for=chapter-41dab1afed6cf3ffa54628db4227e196><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/jail/>Chapter 4. The Jail Subsystem</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/jail/#jail-arch>4.1. Architecture</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/jail/#jail-restrictions>4.2. Restrictions</a></li></ul></li><li><input type=checkbox id=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8 class=toggle>
<label class="icon cursor" for=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/sysinit/>Chapter 5. The SYSINIT Framework</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/sysinit/#sysinit-term>5.1. Terminology</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/sysinit/#sysinit-operation>5.2. SYSINIT Operation</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/sysinit/#sysinit-using>5.3. Using SYSINIT</a></li></ul></li><li><input type=checkbox id=chapter-8b57b16ba53538421a8fb2152b25976f class=toggle>
<label class="icon cursor" for=chapter-8b57b16ba53538421a8fb2152b25976f><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/>Chapter 6. The TrustedBSD MAC Framework</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-copyright>6.1. MAC Documentation Copyright</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-synopsis>6.2. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-introduction>6.3. Introduction</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-background>6.4. Policy Background</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-framework-kernel-arch>6.5. MAC Framework Kernel Architecture</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-policy-architecture>6.6. MAC Policy Architecture</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-entry-point-reference>6.7. MAC Policy Entry Point Reference</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-userland-arch>6.8. Userland Architecture</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/mac/#mac-conclusion>6.9. Conclusion</a></li></ul></li><li><input type=checkbox id=chapter-28609916419208e3a19d240cf7593906 class=toggle>
<label class="icon cursor" for=chapter-28609916419208e3a19d240cf7593906><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/vm/>Chapter 7. Virtual Memory System</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/vm/#vm-physmem>7.1. Management of Physical Memory <code>vm_page_t</code></a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/vm/#vm-cache>7.2. The Unified Buffer Cache <code>vm_object_t</code></a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/vm/#vm-fileio>7.3. Filesystem I/O <code>struct buf</code></a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/vm/#vm-pagetables>7.4. Mapping Page Tables <code>vm_map_t, vm_entry_t</code></a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/vm/#vm-kvm>7.5. KVM Memory Mapping</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/vm/#vm-tuning>7.6. Tuning the FreeBSD VM System</a></li></ul></li><li><input type=checkbox id=chapter-716edd44e8ad22ea57cdf273d2578872 class=toggle>
<label class="icon cursor" for=chapter-716edd44e8ad22ea57cdf273d2578872><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/>Chapter 8. SMPng Design Document</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/#smp-intro>8.1. Introduction</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/#smp-lock-fundamentals>8.2. Basic Tools and Locking Fundamentals</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/#smp-design>8.3. General Architecture and Design</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/#smp-lock-strategies>8.4. Specific Locking Strategies</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/#smp-implementation-notes>8.5. Implementation Notes</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/#smp-misc>8.6. Miscellaneous Topics</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/smp/#smp-glossary>Glossary</a></li></ul></li><li><input type=checkbox id=chapter-448f803e40f97b1ff8336db9ba637745 class=toggle>
<label for=chapter-448f803e40f97b1ff8336db9ba637745><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/partii/>Part II. Device Drivers</a></li><li><input type=checkbox id=chapter-6971d35b0bbe2a0bdb005a02546cd580 class=toggle>
<label class="icon cursor" for=chapter-6971d35b0bbe2a0bdb005a02546cd580><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/driverbasics/>Chapter 9. Writing FreeBSD Device Drivers</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/driverbasics/#driverbasics-intro>9.1. Introduction</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/driverbasics/#driverbasics-kld>9.2. Dynamic Kernel Linker Facility - KLD</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/driverbasics/#driverbasics-char>9.3. Character Devices</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/driverbasics/#driverbasics-block>9.4. Block Devices (Are Gone)</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/driverbasics/#driverbasics-net>9.5. Network Drivers</a></li></ul></li><li><input type=checkbox id=chapter-9cc7968be065b256e57086439d93e9a4 class=toggle>
<label class="icon cursor" for=chapter-9cc7968be065b256e57086439d93e9a4><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/>Chapter 10. ISA Device Drivers</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-synopsis>10.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-basics>10.2. Basic Information</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-device-t>10.3. <code>device_t</code> Pointer</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-resources>10.5. Resources</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-busmem>10.6. Bus Memory Mapping</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-dma>10.7. DMA</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-probe>10.8. xxx_isa_probe</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-attach>10.9. xxx_isa_attach</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-detach>10.10. xxx_isa_detach</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-shutdown>10.11. xxx_isa_shutdown</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/isa/#isa-driver-intr>10.12. xxx_intr</a></li></ul></li><li><input type=checkbox id=chapter-0b427d421e89aa3107f62d5b70f6a0f2 class=toggle>
<label class="icon cursor" for=chapter-0b427d421e89aa3107f62d5b70f6a0f2><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/pci/>Chapter 11. PCI Devices</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/pci/#pci-probe>11.1. Probe and Attach</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/pci/#pci-bus>11.2. Bus Resources</a></li></ul></li><li><input type=checkbox id=chapter-0b7eb8d45a0ea6bc9c2882e903b93959 class=toggle>
<label class="icon cursor" for=chapter-0b7eb8d45a0ea6bc9c2882e903b93959><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/>Chapter 12. Common Access Method SCSI Controllers</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#scsi-synopsis>12.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#scsi-general>12.2. General Architecture</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#_globals_and_boilerplate>12.3. Globals and Boilerplate</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#scsi-polling>12.6. Polling xxx_poll</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#scsi-async>12.7. Asynchronous Events</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#scsi-interrupts>12.8. Interrupts</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#scsi-errors>12.9. Errors Summary</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/scsi/#scsi-timeout>12.10. Timeout Handling</a></li></ul></li><li><input type=checkbox id=chapter-bdaa4909dfbdcec8d7be976fd87cb00e class=toggle>
<label class="icon cursor" for=chapter-bdaa4909dfbdcec8d7be976fd87cb00e><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/usb/>Chapter 13. USB Devices</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/usb/#usb-intro>13.1. Introduction</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/usb/#usb-hc>13.2. Host Controllers</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/usb/#usb-dev>13.3. USB Device Information</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/usb/#usb-devprobe>13.4. Device Probe and Attach</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/usb/#usb-protocol>13.5. USB Drivers Protocol Information</a></li></ul></li><li><input type=checkbox id=chapter-5fc5c179f5014d968a5c8feec7e10e59 class=toggle>
<label class="icon cursor" for=chapter-5fc5c179f5014d968a5c8feec7e10e59><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/newbus/>Chapter 14. Newbus</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/newbus/#newbus-devdrivers>14.1. Device Drivers</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/newbus/#newbus-overview>14.2. Overview of Newbus</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/newbus/#newbus-api>14.3. Newbus API</a></li></ul></li><li><input type=checkbox id=chapter-7d3796cced00105c77e7f87e84edd73b class=toggle checked>
<label class="icon cursor" for=chapter-7d3796cced00105c77e7f87e84edd73b><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/sound/>Chapter 15. Sound Subsystem</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/sound/#oss-intro>15.1. Introduction</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/sound/#oss-files>15.2. Files</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/sound/#pcm-probe-and-attach>15.3. Probing, Attaching, etc.</a></li><li><a href=https://docs.freebsd.org/en/books/arch-handbook/sound/#oss-interfaces>15.4. Interfaces</a></li></ul></li><li><input type=checkbox id=chapter-41c74c3e72fcf5116f6d999c36ef185b class=toggle>
<label class="icon cursor" for=chapter-41c74c3e72fcf5116f6d999c36ef185b><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/pccard/>Chapter 16. PC Card</a><ul><li><a href=https://docs.freebsd.org/en/books/arch-handbook/pccard/#pccard-adddev>16.1. Adding a Device</a></li></ul></li><li><input type=checkbox id=chapter-2a7cf37011599a8e3d62d1e3008c3c5d class=toggle>
<label for=chapter-2a7cf37011599a8e3d62d1e3008c3c5d><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/partiii/>Part III. Appendices</a></li><li><input type=checkbox id=chapter-d4c82056f0235da9fde0d29203d44f9a class=toggle>
<label for=chapter-d4c82056f0235da9fde0d29203d44f9a><a role=button></a></label><a href=https://docs.freebsd.org/en/books/arch-handbook/bibliography/>Bibliography</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapter 15. Sound Subsystem</h1><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#oss-intro>15.1. Introduction</a></li><li><a href=#oss-files>15.2. Files</a></li><li><a href=#pcm-probe-and-attach>15.3. Probing, Attaching, etc.</a></li><li><a href=#oss-interfaces>15.4. Interfaces</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=oss-intro>15.1. Introduction<a class=anchor href=#oss-intro></a></h2><div class=sectionbody><div class=paragraph><p>The FreeBSD sound subsystem cleanly separates generic sound handling issues from device-specific ones. This makes it easier to add support for new hardware.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> framework is the central piece of the sound subsystem. It mainly implements the following elements:</p></div><div class=ulist><ul><li><p>A system call interface (read, write, ioctls) to digitized sound and mixer functions. The ioctl command set is compatible with the legacy <em>OSS</em> or <em>Voxware</em> interface, allowing common multimedia applications to be ported without modification.</p></li><li><p>Common code for processing sound data (format conversions, virtual channels).</p></li><li><p>A uniform software interface to hardware-specific audio interface modules.</p></li><li><p>Additional support for some common hardware interfaces (ac97), or shared hardware-specific code (ex: ISA DMA routines).</p></li></ul></div><div class=paragraph><p>The support for specific sound cards is implemented by hardware-specific drivers, which provide channel and mixer interfaces to plug into the generic <span class=filename>pcm</span> code.</p></div><div class=paragraph><p>In this chapter, the term <span class=filename>pcm</span> will refer to the central, common part of the sound driver, as opposed to the hardware-specific modules.</p></div><div class=paragraph><p>The prospective driver writer will of course want to start from an existing module and use the code as the ultimate reference. But, while the sound code is nice and clean, it is also mostly devoid of comments. This document tries to give an overview of the framework interface and answer some questions that may arise while adapting the existing code.</p></div><div class=paragraph><p>As an alternative, or in addition to starting from a working example, you can find a commented driver template at <a href=https://people.FreeBSD.org/~cg/template.c>https://people.FreeBSD.org/~cg/template.c</a></p></div></div></div><div class=sect1><h2 id=oss-files>15.2. Files<a class=anchor href=#oss-files></a></h2><div class=sectionbody><div class=paragraph><p>All the relevant code lives in <span class=filename>/usr/src/sys/dev/sound/</span>, except for the public ioctl interface definitions, found in <span class=filename>/usr/src/sys/sys/soundcard.h</span></p></div><div class=paragraph><p>Under <span class=filename>/usr/src/sys/dev/sound/</span>, the <span class=filename>pcm/</span> directory holds the central code, while the <span class=filename>pci/</span>, <span class=filename>isa/</span> and <span class=filename>usb/</span> directories have the drivers for PCI and ISA boards, and for USB audio devices.</p></div></div></div><div class=sect1><h2 id=pcm-probe-and-attach>15.3. Probing, Attaching, etc.<a class=anchor href=#pcm-probe-and-attach></a></h2><div class=sectionbody><div class=paragraph><p>Sound drivers probe and attach in almost the same way as any hardware driver module. You might want to look at the <a href=../isa-driver/#isa-driver>ISA</a> or <a href=../pci/#pci>PCI</a> specific sections of the handbook for more information.</p></div><div class=paragraph><p>However, sound drivers differ in some ways:</p></div><div class=ulist><ul><li><p>They declare themselves as <span class=filename>pcm</span> class devices, with a <code>struct snddev_info</code> device private structure:</p><div class="literalblock programlisting"><div class=content><pre>          static driver_t xxx_driver = {
              &#34;pcm&#34;,
              xxx_methods,
              sizeof(struct snddev_info)
          };

          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);
          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);</pre></div></div><div class=paragraph><p>Most sound drivers need to store additional private information about their device. A private data structure is usually allocated in the attach routine. Its address is passed to <span class=filename>pcm</span> by the calls to <code>pcm_register()</code> and <code>mixer_init()</code>. <span class=filename>pcm</span> later passes back this address as a parameter in calls to the sound driver interfaces.</p></div></li><li><p>The sound driver attach routine should declare its MIXER or AC97 interface to
<span class=filename>pcm</span> by calling <code>mixer_init()</code>. For a MIXER interface, this causes
in turn a call to <a href=../sound/#xxxmixer-init><code>xxxmixer_init()</code></a>.</p></li><li><p>The sound driver attach routine declares its general CHANNEL configuration to <span class=filename>pcm</span> by calling <code>pcm_register(dev, sc, nplay, nrec)</code>, where <code>sc</code> is the address for the device data structure, used in further calls from <span class=filename>pcm</span>, and <code>nplay</code> and <code>nrec</code> are the number of play and record channels.</p></li><li><p>The sound driver attach routine declares each of its channel objects by calls
to <code>pcm_addchan()</code>. This sets up the channel glue in <span class=filename>pcm</span> and
causes in turn a call to <a href=../sound/#xxxchannel-init><code>xxxchannel_init()</code></a>.</p></li><li><p>The sound driver detach routine should call <code>pcm_unregister()</code> before releasing its resources.</p></li></ul></div><div class=paragraph><p>There are two possible methods to handle non-PnP devices:</p></div><div class=ulist><ul><li><p>Use a <code>device_identify()</code> method (example: <span class=filename>sound/isa/es1888.c</span>). The <code>device_identify()</code> method probes for the hardware at known addresses and, if it finds a supported device, creates a new pcm device which is then passed to probe/attach.</p></li><li><p>Use a custom kernel configuration with appropriate hints for pcm devices (example: <span class=filename>sound/isa/mss.c</span>).</p></li></ul></div><div class=paragraph><p><span class=filename>pcm</span> drivers should implement <code>device_suspend</code>, <code>device_resume</code> and <code>device_shutdown</code> routines, so that power management and module unloading function correctly.</p></div></div></div><div class=sect1><h2 id=oss-interfaces>15.4. Interfaces<a class=anchor href=#oss-interfaces></a></h2><div class=sectionbody><div class=paragraph><p>The interface between the <span class=filename>pcm</span> core and the sound drivers is defined
in terms of <a href=../kobj/#kernel-objects>kernel objects</a>.</p></div><div class=paragraph><p>There are two main interfaces that a sound driver will usually provide: <em>CHANNEL</em> and either <em>MIXER</em> or <em>AC97</em>.</p></div><div class=paragraph><p>The <em>AC97</em> interface is a very small hardware access (register read/write) interface, implemented by drivers for hardware with an AC97 codec. In this case, the actual MIXER interface is provided by the shared AC97 code in <span class=filename>pcm</span>.</p></div><div class=sect2><h3 id=_the_channel_interface>15.4.1. The CHANNEL Interface<a class=anchor href=#_the_channel_interface></a></h3><div class=sect3><h4 id=_common_notes_for_function_parameters>15.4.1.1. Common Notes for Function Parameters<a class=anchor href=#_common_notes_for_function_parameters></a></h4><div class=paragraph><p>Sound drivers usually have a private data structure to describe their device, and one structure for each play and record data channel that it supports.</p></div><div class=paragraph><p>For all CHANNEL interface functions, the first parameter is an opaque pointer.</p></div><div class=paragraph><p>The second parameter is a pointer to the private channel data structure, except for <code>channel_init()</code> which has a pointer to the private device structure (and returns the channel pointer for further use by <span class=filename>pcm</span>).</p></div></div><div class=sect3><h4 id=_overview_of_data_transfer_operations>15.4.1.2. Overview of Data Transfer Operations<a class=anchor href=#_overview_of_data_transfer_operations></a></h4><div class=paragraph><p>For sound data transfers, the <span class=filename>pcm</span> core and the sound drivers communicate through a shared memory area, described by a <code>struct snd_dbuf</code>.</p></div><div class=paragraph><p><code>struct snd_dbuf</code> is private to <span class=filename>pcm</span>, and sound drivers obtain values of interest by calls to accessor functions (<code>sndbuf_getxxx()</code>).</p></div><div class=paragraph><p>The shared memory area has a size of <code>sndbuf_getsize()</code> and is divided into fixed size blocks of <code>sndbuf_getblksz()</code> bytes.</p></div><div class=paragraph><p>When playing, the general transfer mechanism is as follows (reverse the idea for recording):</p></div><div class=ulist><ul><li><p><span class=filename>pcm</span> initially fills up the buffer, then calls the sound driver’s
<a href=../sound/#channel-trigger><code>xxxchannel_trigger()</code></a> function with a parameter of PCMTRIG_START.</p></li><li><p>The sound driver then arranges to repeatedly transfer the whole memory area (<code>sndbuf_getbuf()</code>, <code>sndbuf_getsize()</code>) to the device, in blocks of <code>sndbuf_getblksz()</code> bytes. It calls back the <code>chn_intr()</code><span class=filename>pcm</span> function for each transferred block (this will typically happen at interrupt time).</p></li><li><p><code>chn_intr()</code> arranges to copy new data to the area that was transferred to the device (now free), and make appropriate updates to the <code>snd_dbuf</code> structure.</p></li></ul></div></div><div class=sect3><h4 id=xxxchannel-init>15.4.1.3. channel_init<a class=anchor href=#xxxchannel-init></a></h4><div class=paragraph><p><code>xxxchannel_init()</code> is called to initialize each of the play or record channels.
The calls are initiated from the sound driver attach routine. (See the crossref:sound[pcm-probe-and-attach,probe and attach section).</p></div><div class="literalblock programlisting"><div class=content><pre>          static void *
          xxxchannel_init(kobj_t obj, void *data,
             struct snd_dbuf *b, struct pcm_channel *c, int dir) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_info *sc = data;
              struct xxx_chinfo *ch;
               ...
              return ch; <i class=conum data-value=2></i><b>(2)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>b</code> is the address for the channel <code>struct snd_dbuf</code>. It should be initialized in the function by calling <code>sndbuf_alloc()</code>. The buffer size to use is normally a small multiple of the 'typical' unit transfer size for your device.<code>c</code> is the <span class=filename>pcm</span> channel control structure pointer. This is an opaque object. The function should store it in the local channel structure, to be used in later calls to <span class=filename>pcm</span> (ie: <code>chn_intr(c)</code>).<code>dir</code> indicates the channel direction (<code>PCMDIR_PLAY</code> or <code>PCMDIR_REC</code>).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The function should return a pointer to the private area used to control this channel. This will be passed as a parameter to other channel interface calls.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_channel_setformat>15.4.1.4. channel_setformat<a class=anchor href=#_channel_setformat></a></h4><div class=paragraph><p><code>xxxchannel_setformat()</code> should set up the hardware for the specified channel for the specified sound format.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_chinfo *ch = data;
               ...
              return 0;
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>format</code> is specified as an <code>AFMT_XXX value</code> (<span class=filename>soundcard.h</span>).</td></tr></tbody></table></div></div><div class=sect3><h4 id=_channel_setspeed>15.4.1.5. channel_setspeed<a class=anchor href=#_channel_setspeed></a></h4><div class=paragraph><p><code>xxxchannel_setspeed()</code> sets up the channel hardware for the specified sampling speed, and returns the possibly adjusted speed.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)
          {
              struct xxx_chinfo *ch = data;
               ...
              return speed;
           }</pre></div></div></div><div class=sect3><h4 id=_channel_setblocksize>15.4.1.6. channel_setblocksize<a class=anchor href=#_channel_setblocksize></a></h4><div class=paragraph><p><code>xxxchannel_setblocksize()</code> sets the block size, which is the size of unit transactions between <span class=filename>pcm</span> and the sound driver, and between the sound driver and the device. Typically, this would be the number of bytes transferred before an interrupt occurs. During a transfer, the sound driver should call <span class=filename>pcm</span>'s <code>chn_intr()</code> every time this size has been transferred.</p></div><div class=paragraph><p>Most sound drivers only take note of the block size here, to be used when an actual transfer will be started.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)
          {
              struct xxx_chinfo *ch = data;
                ...
              return blocksize; <i class=conum data-value=1></i><b>(1)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The function returns the possibly adjusted block size. In case the block size is indeed changed, <code>sndbuf_resize()</code> should be called to adjust the buffer.</td></tr></tbody></table></div></div><div class=sect3><h4 id=channel-trigger>15.4.1.7. channel_trigger<a class=anchor href=#channel-trigger></a></h4><div class=paragraph><p><code>xxxchannel_trigger()</code> is called by <span class=filename>pcm</span> to control data transfer operations in the driver.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxchannel_trigger(kobj_t obj, void *data, int go) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_chinfo *ch = data;
               ...
              return 0;
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>go</code> defines the action for the current call. The possible values are:</td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the driver uses ISA DMA, <code>sndbuf_isadma()</code> should be called before performing actions on the device, and will take care of the DMA chip side of things.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_channel_getptr>15.4.1.8. channel_getptr<a class=anchor href=#_channel_getptr></a></h4><div class=paragraph><p><code>xxxchannel_getptr()</code> returns the current offset in the transfer buffer. This will typically be called by <code>chn_intr()</code>, and this is how <span class=filename>pcm</span> knows where it can transfer new data.</p></div></div><div class=sect3><h4 id=_channel_free>15.4.1.9. channel_free<a class=anchor href=#_channel_free></a></h4><div class=paragraph><p><code>xxxchannel_free()</code> is called to free up channel resources, for example when the driver is unloaded, and should be implemented if the channel data structures are dynamically allocated or if <code>sndbuf_alloc()</code> was not used for buffer allocation.</p></div></div><div class=sect3><h4 id=_channel_getcaps>15.4.1.10. channel_getcaps<a class=anchor href=#_channel_getcaps></a></h4><div class="literalblock programlisting"><div class=content><pre>          struct pcmchan_caps *
          xxxchannel_getcaps(kobj_t obj, void *data)
          {
              return &amp;xxx_caps; <i class=conum data-value=1></i><b>(1)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The routine returns a pointer to a (usually statically-defined) <code>pcmchan_caps</code> structure (defined in <span class=filename>sound/pcm/channel.h</span>. The structure holds the minimum and maximum sampling frequencies, and the accepted sound formats. Look at any sound driver for an example.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_more_functions>15.4.1.11. More Functions<a class=anchor href=#_more_functions></a></h4><div class=paragraph><p><code>channel_reset()</code>, <code>channel_resetdone()</code>, and <code>channel_notify()</code> are for special purposes and should not be implemented in a driver without discussing it on the <a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>FreeBSD multimedia mailing list</a>.</p></div><div class=paragraph><p><code>channel_setdir()</code> is deprecated.</p></div></div></div><div class=sect2><h3 id=_the_mixer_interface>15.4.2. The MIXER Interface<a class=anchor href=#_the_mixer_interface></a></h3><div class=sect3><h4 id=xxxmixer-init>15.4.2.1. mixer_init<a class=anchor href=#xxxmixer-init></a></h4><div class=paragraph><p><code>xxxmixer_init()</code> initializes the hardware and tells <span class=filename>pcm</span> what mixer devices are available for playing and recording</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxmixer_init(struct snd_mixer *m)
          {
              struct xxx_info   *sc = mix_getdevinfo(m);
              u_int32_t v;

              [Initialize hardware]

              [Set appropriate bits in v for play mixers] <i class=conum data-value=1></i><b>(1)</b>
              mix_setdevs(m, v);
              [Set appropriate bits in v for record mixers]
              mix_setrecdevs(m, v)

              return 0;
          }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Set bits in an integer value and call <code>mix_setdevs()</code> and <code>mix_setrecdevs()</code> to tell <span class=filename>pcm</span> what devices exist.</td></tr></tbody></table></div><div class=paragraph><p>Mixer bits definitions can be found in <span class=filename>soundcard.h</span> (<code>SOUND_MASK_XXX</code> values and <code>SOUND_MIXER_XXX</code> bit shifts).</p></div></div><div class=sect3><h4 id=_mixer_set>15.4.2.2. mixer_set<a class=anchor href=#_mixer_set></a></h4><div class=paragraph><p><code>xxxmixer_set()</code> sets the volume level for one mixer device.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxmixer_set(struct snd_mixer *m, unsigned dev,
                           unsigned left, unsigned right) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct sc_info *sc = mix_getdevinfo(m);
              [set volume level]
              return left | (right &lt;&lt; 8); <i class=conum data-value=2></i><b>(2)</b>
          }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The device is specified as a <code>SOUND_MIXER_XXX</code> value. The volume values are specified in range [0-100]. A value of zero should mute the device.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>As the hardware levels probably will not match the input scale, and some rounding will occur, the routine returns the actual level values (in range 0-100) as shown.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_mixer_setrecsrc>15.4.2.3. mixer_setrecsrc<a class=anchor href=#_mixer_setrecsrc></a></h4><div class=paragraph><p><code>xxxmixer_setrecsrc()</code> sets the recording source device.</p></div><div class="literalblock programlisting"><div class=content><pre>          static int
          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src) <i class=conum data-value=1></i><b>(1)</b>
          {
              struct xxx_info *sc = mix_getdevinfo(m);

              [look for non zero bit(s) in src, set up hardware]

              [update src to reflect actual action]
              return src; <i class=conum data-value=2></i><b>(2)</b>
           }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The desired recording devices are specified as a bit field</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The actual devices set for recording are returned. Some drivers can only set one device for recording. The function should return -1 if an error occurs.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_mixer_uninit_mixer_reinit>15.4.2.4. mixer_uninit, mixer_reinit<a class=anchor href=#_mixer_uninit_mixer_reinit></a></h4><div class=paragraph><p><code>xxxmixer_uninit()</code> should ensure that all sound is muted and if possible mixer hardware should be powered down.</p></div><div class=paragraph><p><code>xxxmixer_reinit()</code> should ensure that the mixer hardware is powered up and any settings not controlled by <code>mixer_set()</code> or <code>mixer_setrecsrc()</code> are restored.</p></div></div></div><div class=sect2><h3 id=_the_ac97_interface>15.4.3. The AC97 Interface<a class=anchor href=#_the_ac97_interface></a></h3><div class=paragraph><p>The <em>AC97</em> interface is implemented by drivers with an AC97 codec. It only has three methods:</p></div><div class=ulist><ul><li><p><code>xxxac97_init()</code> returns the number of ac97 codecs found.</p></li><li><p><code>ac97_read()</code> and <code>ac97_write()</code> read or write a specified register.</p></li></ul></div><div class=paragraph><p>The <em>AC97</em> interface is used by the AC97 code in <span class=filename>pcm</span> to perform higher level operations. Look at <span class=filename>sound/pci/maestro3.c</span> or many others under <span class=filename>sound/pci/</span> for an example.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: August 11, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=557464e66e" target=_blank>Fernando Apesteguía</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/en/books/arch-handbook/newbus class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/en/books/arch-handbook/pccard class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#oss-intro>15.1. Introduction</a></li><li><a href=#oss-files>15.2. Files</a></li><li><a href=#pcm-probe-and-attach>15.3. Probing, Attaching, etc.</a></li><li><a href=#oss-interfaces>15.4. Interfaces</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/arch-handbook/arch-handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/en/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>