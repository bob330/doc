<!doctype html><html class=theme-light lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="ISA Device Drivers"><meta name=keywords content="ISA,device drivers,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/en/books/arch-handbook/isa/><title>Chapter 10. ISA Device Drivers | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapter 10. ISA Device Drivers"><meta property="og:description" content="ISA Device Drivers"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="http://172.16.201.134:1313/en/books/arch-handbook/isa/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/en\/books\/arch-handbook\/isa\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/en/books>Books</a></li><li><a href=http://172.16.201.134:1313/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>â™¥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-6dcd22d99f78db2a9aacae23be13866e class=toggle>
<label for=chapter-6dcd22d99f78db2a9aacae23be13866e><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/parti/>Part I. Kernel</a></li><li><input type=checkbox id=chapter-9cc61bc35df69063dc03a5911e1ad9c9 class=toggle>
<label class="icon cursor" for=chapter-9cc61bc35df69063dc03a5911e1ad9c9><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/>Chapter 1. Bootstrapping and Kernel Initialization</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-synopsis>1.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-overview>1.2. Overview</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-bios>1.3. The BIOS</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-boot0>1.4. The Master Boot Record (<code>boot0</code>)</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-boot1>1.5. <code>boot1</code> Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#btx-server>1.6. The BTX Server</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot2>1.7. boot2 Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-loader>1.8. loader Stage</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/boot/#boot-kernel>1.9. Kernel Initialization</a></li></ul></li><li><input type=checkbox id=chapter-3a651b0a4b9f6238336624d3c0fa5187 class=toggle>
<label class="icon cursor" for=chapter-3a651b0a4b9f6238336624d3c0fa5187><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/>Chapter 2. Locking Notes</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-mutexes>2.1. Mutexes</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-sx>2.2. Shared Exclusive Locks</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/locking/#locking-atomic>2.3. Atomically Protected Variables</a></li></ul></li><li><input type=checkbox id=chapter-bf0b823c107a80f3035dfd6fae09d023 class=toggle>
<label class="icon cursor" for=chapter-bf0b823c107a80f3035dfd6fae09d023><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/>Chapter 3. Kernel Objects</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-term>3.1. Terminology</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-operation>3.2. Kobj Operation</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/kobj/#kernel-objects-using>3.3. Using Kobj</a></li></ul></li><li><input type=checkbox id=chapter-41dab1afed6cf3ffa54628db4227e196 class=toggle>
<label class="icon cursor" for=chapter-41dab1afed6cf3ffa54628db4227e196><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/>Chapter 4. The Jail Subsystem</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/#jail-arch>4.1. Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/jail/#jail-restrictions>4.2. Restrictions</a></li></ul></li><li><input type=checkbox id=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8 class=toggle>
<label class="icon cursor" for=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/>Chapter 5. The SYSINIT Framework</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-term>5.1. Terminology</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-operation>5.2. SYSINIT Operation</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sysinit/#sysinit-using>5.3. Using SYSINIT</a></li></ul></li><li><input type=checkbox id=chapter-8b57b16ba53538421a8fb2152b25976f class=toggle>
<label class="icon cursor" for=chapter-8b57b16ba53538421a8fb2152b25976f><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/>Chapter 6. The TrustedBSD MAC Framework</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-copyright>6.1. MAC Documentation Copyright</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-synopsis>6.2. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-introduction>6.3. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-background>6.4. Policy Background</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-framework-kernel-arch>6.5. MAC Framework Kernel Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-policy-architecture>6.6. MAC Policy Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-entry-point-reference>6.7. MAC Policy Entry Point Reference</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-userland-arch>6.8. Userland Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/mac/#mac-conclusion>6.9. Conclusion</a></li></ul></li><li><input type=checkbox id=chapter-28609916419208e3a19d240cf7593906 class=toggle>
<label class="icon cursor" for=chapter-28609916419208e3a19d240cf7593906><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/>Chapter 7. Virtual Memory System</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-physmem>7.1. Management of Physical Memory <code>vm_page_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-cache>7.2. The Unified Buffer Cache <code>vm_object_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-fileio>7.3. Filesystem I/O <code>struct buf</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-pagetables>7.4. Mapping Page Tables <code>vm_map_t, vm_entry_t</code></a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-kvm>7.5. KVM Memory Mapping</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/vm/#vm-tuning>7.6. Tuning the FreeBSD VM System</a></li></ul></li><li><input type=checkbox id=chapter-716edd44e8ad22ea57cdf273d2578872 class=toggle>
<label class="icon cursor" for=chapter-716edd44e8ad22ea57cdf273d2578872><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/>Chapter 8. SMPng Design Document</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-intro>8.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-lock-fundamentals>8.2. Basic Tools and Locking Fundamentals</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-design>8.3. General Architecture and Design</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-lock-strategies>8.4. Specific Locking Strategies</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-implementation-notes>8.5. Implementation Notes</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-misc>8.6. Miscellaneous Topics</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/smp/#smp-glossary>Glossary</a></li></ul></li><li><input type=checkbox id=chapter-448f803e40f97b1ff8336db9ba637745 class=toggle>
<label for=chapter-448f803e40f97b1ff8336db9ba637745><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/partii/>Part II. Device Drivers</a></li><li><input type=checkbox id=chapter-6971d35b0bbe2a0bdb005a02546cd580 class=toggle>
<label class="icon cursor" for=chapter-6971d35b0bbe2a0bdb005a02546cd580><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/>Chapter 9. Writing FreeBSD Device Drivers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-intro>9.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-kld>9.2. Dynamic Kernel Linker Facility - KLD</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-char>9.3. Character Devices</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-block>9.4. Block Devices (Are Gone)</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics/#driverbasics-net>9.5. Network Drivers</a></li></ul></li><li><input type=checkbox id=chapter-9cc7968be065b256e57086439d93e9a4 class=toggle checked>
<label class="icon cursor" for=chapter-9cc7968be065b256e57086439d93e9a4><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/>Chapter 10. ISA Device Drivers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-synopsis>10.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-basics>10.2. Basic Information</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-device-t>10.3. <code>device_t</code> Pointer</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-resources>10.5. Resources</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-busmem>10.6. Bus Memory Mapping</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-dma>10.7. DMA</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-probe>10.8. xxx_isa_probe</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-attach>10.9. xxx_isa_attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-detach>10.10. xxx_isa_detach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-shutdown>10.11. xxx_isa_shutdown</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/isa/#isa-driver-intr>10.12. xxx_intr</a></li></ul></li><li><input type=checkbox id=chapter-0b427d421e89aa3107f62d5b70f6a0f2 class=toggle>
<label class="icon cursor" for=chapter-0b427d421e89aa3107f62d5b70f6a0f2><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/>Chapter 11. PCI Devices</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/#pci-probe>11.1. Probe and Attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci/#pci-bus>11.2. Bus Resources</a></li></ul></li><li><input type=checkbox id=chapter-0b7eb8d45a0ea6bc9c2882e903b93959 class=toggle>
<label class="icon cursor" for=chapter-0b7eb8d45a0ea6bc9c2882e903b93959><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/>Chapter 12. Common Access Method SCSI Controllers</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-synopsis>12.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-general>12.2. General Architecture</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_globals_and_boilerplate>12.3. Globals and Boilerplate</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_device_configuration_xxx_attach>12.4. Device configuration: xxx_attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#_processing_cam_messages_xxx_action>12.5. Processing CAM messages: xxx_action</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-polling>12.6. Polling xxx_poll</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-async>12.7. Asynchronous Events</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-interrupts>12.8. Interrupts</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-errors>12.9. Errors Summary</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/scsi/#scsi-timeout>12.10. Timeout Handling</a></li></ul></li><li><input type=checkbox id=chapter-bdaa4909dfbdcec8d7be976fd87cb00e class=toggle>
<label class="icon cursor" for=chapter-bdaa4909dfbdcec8d7be976fd87cb00e><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/>Chapter 13. USB Devices</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-intro>13.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-hc>13.2. Host Controllers</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-dev>13.3. USB Device Information</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-devprobe>13.4. Device Probe and Attach</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/usb/#usb-protocol>13.5. USB Drivers Protocol Information</a></li></ul></li><li><input type=checkbox id=chapter-5fc5c179f5014d968a5c8feec7e10e59 class=toggle>
<label class="icon cursor" for=chapter-5fc5c179f5014d968a5c8feec7e10e59><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/>Chapter 14. Newbus</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-devdrivers>14.1. Device Drivers</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-overview>14.2. Overview of Newbus</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/newbus/#newbus-api>14.3. Newbus API</a></li></ul></li><li><input type=checkbox id=chapter-7d3796cced00105c77e7f87e84edd73b class=toggle>
<label class="icon cursor" for=chapter-7d3796cced00105c77e7f87e84edd73b><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/>Chapter 15. Sound Subsystem</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-intro>15.1. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-files>15.2. Files</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#pcm-probe-and-attach>15.3. Probing, Attaching, etc.</a></li><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/sound/#oss-interfaces>15.4. Interfaces</a></li></ul></li><li><input type=checkbox id=chapter-41c74c3e72fcf5116f6d999c36ef185b class=toggle>
<label class="icon cursor" for=chapter-41c74c3e72fcf5116f6d999c36ef185b><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/pccard/>Chapter 16. PC Card</a><ul><li><a href=http://172.16.201.134:1313/en/books/arch-handbook/pccard/#pccard-adddev>16.1. Adding a Device</a></li></ul></li><li><input type=checkbox id=chapter-2a7cf37011599a8e3d62d1e3008c3c5d class=toggle>
<label for=chapter-2a7cf37011599a8e3d62d1e3008c3c5d><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/partiii/>Part III. Appendices</a></li><li><input type=checkbox id=chapter-d4c82056f0235da9fde0d29203d44f9a class=toggle>
<label for=chapter-d4c82056f0235da9fde0d29203d44f9a><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/arch-handbook/bibliography/>Bibliography</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapter 10. ISA Device Drivers</h1><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#isa-driver-synopsis>10.1. Synopsis</a></li><li><a href=#isa-driver-basics>10.2. Basic Information</a></li><li><a href=#isa-driver-device-t>10.3. <code>device_t</code> Pointer</a></li><li><a href=#isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration</a></li><li><a href=#isa-driver-resources>10.5. Resources</a></li><li><a href=#isa-driver-busmem>10.6. Bus Memory Mapping</a></li><li><a href=#isa-driver-dma>10.7. DMA</a></li><li><a href=#isa-driver-probe>10.8. xxx_isa_probe</a></li><li><a href=#isa-driver-attach>10.9. xxx_isa_attach</a></li><li><a href=#isa-driver-detach>10.10. xxx_isa_detach</a></li><li><a href=#isa-driver-shutdown>10.11. xxx_isa_shutdown</a></li><li><a href=#isa-driver-intr>10.12. xxx_intr</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=isa-driver-synopsis>10.1. Synopsis<a class=anchor href=#isa-driver-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>This chapter introduces the issues relevant to writing a driver for an ISA device. The pseudo-code presented here is rather detailed and reminiscent of the real code but is still only pseudo-code. It avoids the details irrelevant to the subject of the discussion. The real-life examples can be found in the source code of real drivers. In particular the drivers <code>ep</code> and <code>aha</code> are good sources of information.</p></div></div></div><div class=sect1><h2 id=isa-driver-basics>10.2. Basic Information<a class=anchor href=#isa-driver-basics></a></h2><div class=sectionbody><div class=paragraph><p>A typical ISA driver would need the following include files:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;sys/module.h&gt;
#include &lt;sys/bus.h&gt;
#include &lt;machine/bus.h&gt;
#include &lt;machine/resource.h&gt;
#include &lt;sys/rman.h&gt;

#include &lt;isa/isavar.h&gt;
#include &lt;isa/pnpvar.h&gt;</pre></div></div><div class=paragraph><p>They describe the things specific to the ISA and generic bus subsystem.</p></div><div class=paragraph><p>The bus subsystem is implemented in an object-oriented fashion, its main structures are accessed by associated method functions.</p></div><div class=paragraph><p>The list of bus methods implemented by an ISA driver is like one for any other bus. For a hypothetical driver named "xxx" they would be:</p></div><div class=ulist><ul><li><p><code>static void xxx_isa_identify (driver_t *, device_t);</code> Normally used for bus drivers, not device drivers. But for ISA devices this method may have special use: if the device provides some device-specific (non-PnP) way to auto-detect devices this routine may implement it.</p></li><li><p><code>static int xxx_isa_probe (device_t dev);</code> Probe for a device at a known (or PnP) location. This routine can also accommodate device-specific auto-detection of parameters for partially configured devices.</p></li><li><p><code>static int xxx_isa_attach (device_t dev);</code> Attach and initialize device.</p></li><li><p><code>static int xxx_isa_detach (device_t dev);</code> Detach device before unloading the driver module.</p></li><li><p><code>static int xxx_isa_shutdown (device_t dev);</code> Execute shutdown of the device before system shutdown.</p></li><li><p><code>static int xxx_isa_suspend (device_t dev);</code> Suspend the device before the system goes to the power-save state. May also abort transition to the power-save state.</p></li><li><p><code>static int xxx_isa_resume (device_t dev);</code> Resume the device activity after return from power-save state.</p></li></ul></div><div class=paragraph><p><code>xxx_isa_probe()</code> and <code>xxx_isa_attach()</code> are mandatory, the rest of the routines are optional, depending on the deviceâ€™s needs.</p></div><div class=paragraph><p>The driver is linked to the system with the following set of descriptions.</p></div><div class="literalblock programlisting"><div class=content><pre>    /* table of supported bus methods */
    static device_method_t xxx_isa_methods[] = {
        /* list all the bus method functions supported by the driver */
        /* omit the unsupported methods */
        DEVMETHOD(device_identify,  xxx_isa_identify),
        DEVMETHOD(device_probe,     xxx_isa_probe),
        DEVMETHOD(device_attach,    xxx_isa_attach),
        DEVMETHOD(device_detach,    xxx_isa_detach),
        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),
        DEVMETHOD(device_suspend,   xxx_isa_suspend),
        DEVMETHOD(device_resume,    xxx_isa_resume),

	DEVMETHOD_END
    };

    static driver_t xxx_isa_driver = {
        &#34;xxx&#34;,
        xxx_isa_methods,
        sizeof(struct xxx_softc),
    };

    static devclass_t xxx_devclass;

    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,
        load_function, load_argument);</pre></div></div><div class=paragraph><p>Here struct <code>xxx_softc</code> is a device-specific structure that contains private driver data and descriptors for the driverâ€™s resources. The bus code automatically allocates one softc descriptor per device as needed.</p></div><div class=paragraph><p>If the driver is implemented as a loadable module then <code>load_function()</code> is called to do driver-specific initialization or clean-up when the driver is loaded or unloaded and load_argument is passed as one of its arguments. If the driver does not support dynamic loading (in other words it must always be linked into the kernel) then these values should be set to 0 and the last definition would look like:</p></div><div class="literalblock programlisting"><div class=content><pre> DRIVER_MODULE(xxx, isa, xxx_isa_driver,
       xxx_devclass, 0, 0);</pre></div></div><div class=paragraph><p>If the driver is for a device which supports PnP then a table of supported PnP IDs must be defined. The table consists of a list of PnP IDs supported by this driver and human-readable descriptions of the hardware types and models having these IDs. It looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>    static struct isa_pnp_id xxx_pnp_ids[] = {
        /* a line for each supported PnP ID */
        { 0x12345678,   &#34;Our device model 1234A&#34; },
        { 0x12345679,   &#34;Our device model 1234B&#34; },
        { 0,        NULL }, /* end of table */
    };</pre></div></div><div class=paragraph><p>If the driver does not support PnP devices it still needs an empty PnP ID table, like:</p></div><div class="literalblock programlisting"><div class=content><pre>    static struct isa_pnp_id xxx_pnp_ids[] = {
        { 0,        NULL }, /* end of table */
    };</pre></div></div></div></div><div class=sect1><h2 id=isa-driver-device-t>10.3. <code>device_t</code> Pointer<a class=anchor href=#isa-driver-device-t></a></h2><div class=sectionbody><div class=paragraph><p><code>device_t</code> is the pointer type for the device structure. Here we consider only the methods interesting from the device driver writerâ€™s standpoint. The methods to manipulate values in the device structure are:</p></div><div class=ulist><ul><li><p><code>device_t device_get_parent(dev)</code> Get the parent bus of a device.</p></li><li><p><code>driver_t device_get_driver(dev)</code> Get pointer to its driver structure.</p></li><li><p><code>char *device_get_name(dev)</code> Get the driver name, such as <code>"xxx"</code> for our example.</p></li><li><p><code>int device_get_unit(dev)</code> Get the unit number (units are numbered from 0 for the devices associated with each driver).</p></li><li><p><code>char *device_get_nameunit(dev)</code> Get the device name including the unit number, such as "xxx0", "xxx1" and so on.</p></li><li><p><code>char *device_get_desc(dev)</code> Get the device description. Normally it describes the exact model of device in human-readable form.</p></li><li><p><code>device_set_desc(dev, desc)</code> Set the description. This makes the device description point to the string desc which may not be deallocated or changed after that.</p></li><li><p><code>device_set_desc_copy(dev, desc)</code> Set the description. The description is copied into an internal dynamically allocated buffer, so the string desc may be changed afterwards without adverse effects.</p></li><li><p><code>void *device_get_softc(dev)</code> Get pointer to the device descriptor (struct <code>xxx_softc</code>) associated with this device.</p></li><li><p><code>u_int32_t device_get_flags(dev)</code> Get the flags specified for the device in the configuration file.</p></li></ul></div><div class=paragraph><p>A convenience function <code>device_printf(dev, fmt, â€¦â€‹)</code> may be used to print the messages from the device driver. It automatically prepends the unitname and colon to the message.</p></div><div class=paragraph><p>The device_t methods are implemented in the file <span class=filename>kern/bus_subr.c</span>.</p></div></div></div><div class=sect1><h2 id=isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration<a class=anchor href=#isa-driver-config></a></h2><div class=sectionbody><div class=paragraph><p>The ISA devices are described in the kernel configuration file like:</p></div><div class="literalblock programlisting"><div class=content><pre>device xxx0 at isa? port 0x300 irq 10 drq 5
       iomem 0xd0000 flags 0x1 sensitive</pre></div></div><div class=paragraph><p>The values of port, IRQ and so on are converted to the resource values associated with the device. They are optional, depending on the deviceâ€™s needs and abilities for auto-configuration. For example, some devices do not need DRQ at all and some allow the driver to read the IRQ setting from the device configuration ports. If a machine has multiple ISA buses the exact bus may be specified in the configuration line, like <code>isa0</code> or <code>isa1</code>, otherwise the device would be searched for on all the ISA buses.</p></div><div class=paragraph><p><code>sensitive</code> is a resource requesting that this device must be probed before all non-sensitive devices. It is supported but does not seem to be used in any current driver.</p></div><div class=paragraph><p>For legacy ISA devices in many cases the drivers are still able to detect the configuration parameters. But each device to be configured in the system must have a config line. If two devices of some type are installed in the system but there is only one configuration line for the corresponding driver, ie:</p></div><div class="literalblock programlisting"><div class=content><pre>device xxx0 at isa?</pre></div></div><div class=literalblock><div class=content><pre>then only one device will be configured.</pre></div></div><div class=paragraph><p>But for the devices supporting automatic identification by the means of Plug-n-Play or some proprietary protocol one configuration line is enough to configure all the devices in the system, like the one above or just simply:</p></div><div class="literalblock programlisting"><div class=content><pre>device xxx at isa?</pre></div></div><div class=paragraph><p>If a driver supports both auto-identified and legacy devices and both kinds are installed at once in one machine then it is enough to describe in the config file the legacy devices only. The auto-identified devices will be added automatically.</p></div><div class=paragraph><p>When an ISA bus is auto-configured the events happen as follows:</p></div><div class=paragraph><p>All the drivers' identify routines (including the PnP identify routine which identifies all the PnP devices) are called in random order. As they identify the devices they add them to the list on the ISA bus. Normally the drivers' identify routines associate their drivers with the new devices. The PnP identify routine does not know about the other drivers yet so it does not associate any with the new devices it adds.</p></div><div class=paragraph><p>The PnP devices are put to sleep using the PnP protocol to prevent them from being probed as legacy devices.</p></div><div class=paragraph><p>The probe routines of non-PnP devices marked as <code>sensitive</code> are called. If probe for a device went successfully, the attach routine is called for it.</p></div><div class=paragraph><p>The probe and attach routines of all non-PNP devices are called likewise.</p></div><div class=paragraph><p>The PnP devices are brought back from the sleep state and assigned the resources they request: I/O and memory address ranges, IRQs and DRQs, all of them not conflicting with the attached legacy devices.</p></div><div class=paragraph><p>Then for each PnP device the probe routines of all the present ISA drivers are called. The first one that claims the device gets attached. It is possible that multiple drivers would claim the device with different priority; in this case, the highest-priority driver wins. The probe routines must call <code>ISA_PNP_PROBE()</code> to compare the actual PnP ID with the list of the IDs supported by the driver and if the ID is not in the table return failure. That means that absolutely every driver, even the ones not supporting any PnP devices must call <code>ISA_PNP_PROBE()</code>, at least with an empty PnP ID table to return failure on unknown PnP devices.</p></div><div class=paragraph><p>The probe routine returns a positive value (the error code) on error, zero or negative value on success.</p></div><div class=paragraph><p>The negative return values are used when a PnP device supports multiple interfaces. For example, an older compatibility interface and a newer advanced interface which are supported by different drivers. Then both drivers would detect the device. The driver which returns a higher value in the probe routine takes precedence (in other words, the driver returning 0 has highest precedence, returning -1 is next, returning -2 is after it and so on). In result the devices which support only the old interface will be handled by the old driver (which should return -1 from the probe routine) while the devices supporting the new interface as well will be handled by the new driver (which should return 0 from the probe routine). If multiple drivers return the same value then the one called first wins. So if a driver returns value 0 it may be sure that it won the priority arbitration.</p></div><div class=paragraph><p>The device-specific identify routines can also assign not a driver but a class of drivers to the device. Then all the drivers in the class are probed for this device, like the case with PnP. This feature is not implemented in any existing driver and is not considered further in this document.</p></div><div class=paragraph><p>As the PnP devices are disabled when probing the legacy devices they will not be attached twice (once as legacy and once as PnP). But in case of device-dependent identify routines it is the responsibility of the driver to make sure that the same device will not be attached by the driver twice: once as legacy user-configured and once as auto-identified.</p></div><div class=paragraph><p>Another practical consequence for the auto-identified devices (both PnP and device-specific) is that the flags can not be passed to them from the kernel configuration file. So they must either not use the flags at all or use the flags from the device unit 0 for all the auto-identified devices or use the sysctl interface instead of flags.</p></div><div class=paragraph><p>Other unusual configurations may be accommodated by accessing the configuration resources directly with functions of families <code>resource_query_*()</code> and <code>resource_*_value()</code>. Their implementations are located in <span class=filename>kern/subr_bus.c</span>. The old IDE disk driver <span class=filename>i386/isa/wd.c</span> contains examples of such use. But the standard means of configuration must always be preferred. Leave parsing the configuration resources to the bus configuration code.</p></div></div></div><div class=sect1><h2 id=isa-driver-resources>10.5. Resources<a class=anchor href=#isa-driver-resources></a></h2><div class=sectionbody><div class=paragraph><p>The information that a user enters into the kernel configuration file is processed and passed to the kernel as configuration resources. This information is parsed by the bus configuration code and transformed into a value of structure device_t and the bus resources associated with it. The drivers may access the configuration resources directly using functions <code>resource_*</code> for more complex cases of configuration. However, generally this is neither needed nor recommended, so this issue is not discussed further here.</p></div><div class=paragraph><p>The bus resources are associated with each device. They are identified by type and number within the type. For the ISA bus the following types are defined:</p></div><div class=ulist><ul><li><p><em>SYS_RES_IRQ</em> - interrupt number</p></li><li><p><em>SYS_RES_DRQ</em> - ISA DMA channel number</p></li><li><p><em>SYS_RES_MEMORY</em> - range of device memory mapped into the system memory space</p></li><li><p><em>SYS_RES_IOPORT</em> - range of device I/O registers</p></li></ul></div><div class=paragraph><p>The enumeration within types starts from 0, so if a device has two memory regions it would have resources of type <code>SYS_RES_MEMORY</code> numbered 0 and 1. The resource type has nothing to do with the C language type, all the resource values have the C language type <code>unsigned long</code> and must be cast as necessary. The resource numbers do not have to be contiguous, although for ISA they normally would be. The permitted resource numbers for ISA devices are:</p></div><div class="literalblock programlisting"><div class=content><pre>          IRQ: 0-1
          DRQ: 0-1
          MEMORY: 0-3
          IOPORT: 0-7</pre></div></div><div class=paragraph><p>All the resources are represented as ranges, with a start value and count. For IRQ and DRQ resources the count would normally be equal to 1. The values for memory refer to the physical addresses.</p></div><div class=paragraph><p>Three types of activities can be performed on resources:</p></div><div class=ulist><ul><li><p>set/get</p></li><li><p>allocate/release</p></li><li><p>activate/deactivate</p></li></ul></div><div class=paragraph><p>Setting sets the range used by the resource. Allocation reserves the requested range that no other driver would be able to reserve it (and checking that no other driver reserved this range already). Activation makes the resource accessible to the driver by doing whatever is necessary for that (for example, for memory it would be mapping into the kernel virtual address space).</p></div><div class=paragraph><p>The functions to manipulate resources are:</p></div><div class=ulist><ul><li><p><code>int bus_set_resource(device_t dev, int type, int rid, u_long start, u_long count)</code></p><div class=paragraph><p>Set a range for a resource. Returns 0 if successful, error code otherwise. Normally, this function will return an error only if one of <code>type</code>, <code>rid</code>, <code>start</code> or <code>count</code> has a value that falls out of the permitted range.</p></div><div class=ulist><ul><li><p>dev - driverâ€™s device</p></li><li><p>type - type of resource, SYS_RES_*</p></li><li><p>rid - resource number (ID) within type</p></li><li><p>start, count - resource range</p></li></ul></div></li><li><p><code>int bus_get_resource(device_t dev, int type, int rid, u_long *startp, u_long *countp)</code></p><div class=paragraph><p>Get the range of resource. Returns 0 if successful, error code if the resource is not defined yet.</p></div></li><li><p><code>u_long bus_get_resource_start(device_t dev, int type, int rid) u_long bus_get_resource_count (device_t dev, int type, int rid)</code></p><div class=paragraph><p>Convenience functions to get only the start or count. Return 0 in case of error, so if the resource start has 0 among the legitimate values it would be impossible to tell if the value is 0 or an error occurred. Luckily, no ISA resources for add-on drivers may have a start value equal to 0.</p></div></li><li><p><code>void bus_delete_resource(device_t dev, int type, int rid)</code></p><div class=paragraph><p>Delete a resource, make it undefined.</p></div></li><li><p><code>struct resource * bus_alloc_resource(device_t dev, int type, int *rid, u_long start, u_long end, u_long count, u_int flags)</code></p><div class=paragraph><p>Allocate a resource as a range of count values not allocated by anyone else, somewhere between start and end. Alas, alignment is not supported. If the resource was not set yet it is automatically created. The special values of start 0 and end ~0 (all ones) means that the fixed values previously set by <code>bus_set_resource()</code> must be used instead: start and count as themselves and end=(start+count), in this case if the resource was not defined before then an error is returned. Although rid is passed by reference it is not set anywhere by the resource allocation code of the ISA bus. (The other buses may use a different approach and modify it).</p></div></li></ul></div><div class=paragraph><p>Flags are a bitmap, the flags interesting for the caller are:</p></div><div class=ulist><ul><li><p><em>RF_ACTIVE</em> - causes the resource to be automatically activated after allocation.</p></li><li><p><em>RF_SHAREABLE</em> - resource may be shared at the same time by multiple drivers.</p></li><li><p><em>RF_TIMESHARE</em> - resource may be time-shared by multiple drivers, i.e., allocated at the same time by many but activated only by one at any given moment of time.</p></li><li><p>Returns 0 on error. The allocated values may be obtained from the returned handle using methods <code>rhand_*()</code>.</p></li><li><p><code>int bus_release_resource(device_t dev, int type, int rid, struct resource *r)</code></p></li><li><p>Release the resource, r is the handle returned by <code>bus_alloc_resource()</code>. Returns 0 on success, error code otherwise.</p></li><li><p><code>int bus_activate_resource(device_t dev, int type, int rid, struct resource *r) int bus_deactivate_resource(device_t dev, int type, int rid, struct resource *r)</code></p></li><li><p>Activate or deactivate resource. Return 0 on success, error code otherwise. If the resource is time-shared and currently activated by another driver then <code>EBUSY</code> is returned.</p></li><li><p><code>int bus_setup_intr(device_t dev, struct resource *r, int flags, driver_intr_t *handler, void *arg, void **cookiep) int bus_teardown_intr(device_t dev, struct resource *r, void *cookie)</code></p></li><li><p>Associate or de-associate the interrupt handler with a device. Return 0 on success, error code otherwise.</p></li><li><p>r - the activated resource handler describing the IRQ</p><div class=paragraph><p>flags - the interrupt priority level, one of:</p></div><div class=ulist><ul><li><p><code>INTR_TYPE_TTY</code> - terminals and other likewise character-type devices. To mask them use <code>spltty()</code>.</p></li><li><p><code>(INTR_TYPE_TTY | INTR_TYPE_FAST)</code> - terminal type devices with small input buffer, critical to the data loss on input (such as the old-fashioned serial ports). To mask them use <code>spltty()</code>.</p></li><li><p><code>INTR_TYPE_BIO</code> - block-type devices, except those on the CAM controllers. To mask them use <code>splbio()</code>.</p></li><li><p><code>INTR_TYPE_CAM</code> - CAM (Common Access Method) bus controllers. To mask them use <code>splcam()</code>.</p></li><li><p><code>INTR_TYPE_NET</code> - network interface controllers. To mask them use <code>splimp()</code>.</p></li><li><p><code>INTR_TYPE_MISC</code> - miscellaneous devices. There is no other way to mask them than by <code>splhigh()</code> which masks all interrupts.</p></li></ul></div></li></ul></div><div class=paragraph><p>When an interrupt handler executes all the other interrupts matching its priority level will be masked. The only exception is the MISC level for which no other interrupts are masked and which is not masked by any other interrupt.</p></div><div class=ulist><ul><li><p><em>handler</em> - pointer to the handler function, the type driver_intr_t is defined as <code>void driver_intr_t(void *)</code></p></li><li><p><em>arg</em> - the argument passed to the handler to identify this particular device. It is cast from void* to any real type by the handler. The old convention for the ISA interrupt handlers was to use the unit number as argument, the new (recommended) convention is using a pointer to the device softc structure.</p></li><li><p><em>cookie[p]</em> - the value received from <code>setup()</code> is used to identify the handler when passed to <code>teardown()</code></p></li></ul></div><div class=paragraph><p>A number of methods are defined to operate on the resource handlers (struct resource *). Those of interest to the device driver writers are:</p></div><div class=ulist><ul><li><p><code>u_long rman_get_start(r) u_long rman_get_end(r)</code> Get the start and end of allocated resource range.</p></li><li><p><code>void *rman_get_virtual(r)</code> Get the virtual address of activated memory resource.</p></li></ul></div></div></div><div class=sect1><h2 id=isa-driver-busmem>10.6. Bus Memory Mapping<a class=anchor href=#isa-driver-busmem></a></h2><div class=sectionbody><div class=paragraph><p>In many cases data is exchanged between the driver and the device through the memory. Two variants are possible:</p></div><div class=paragraph><p>(a) memory is located on the device card</p></div><div class=paragraph><p>(b) memory is the main memory of the computer</p></div><div class=paragraph><p>In case (a) the driver always copies the data back and forth between the on-card memory and the main memory as necessary. To map the on-card memory into the kernel virtual address space the physical address and length of the on-card memory must be defined as a <code>SYS_RES_MEMORY</code> resource. That resource can then be allocated and activated, and its virtual address obtained using <code>rman_get_virtual()</code>. The older drivers used the function <code>pmap_mapdev()</code> for this purpose, which should not be used directly any more. Now it is one of the internal steps of resource activation.</p></div><div class=paragraph><p>Most of the ISA cards will have their memory configured for physical location somewhere in range 640KB-1MB. Some of the ISA cards require larger memory ranges which should be placed somewhere under 16MB (because of the 24-bit address limitation on the ISA bus). In that case if the machine has more memory than the start address of the device memory (in other words, they overlap) a memory hole must be configured at the address range used by devices. Many BIOSes allow configuration of a memory hole of 1MB starting at 14MB or 15MB. FreeBSD can handle the memory holes properly if the BIOS reports them properly (this feature may be broken on old BIOSes).</p></div><div class=paragraph><p>In case (b) just the address of the data is sent to the device, and the device uses DMA to actually access the data in the main memory. Two limitations are present: First, ISA cards can only access memory below 16MB. Second, the contiguous pages in virtual address space may not be contiguous in physical address space, so the device may have to do scatter/gather operations. The bus subsystem provides ready solutions for some of these problems, the rest has to be done by the drivers themselves.</p></div><div class=paragraph><p>Two structures are used for DMA memory allocation, <code>bus_dma_tag_t</code> and <code>bus_dmamap_t</code>. Tag describes the properties required for the DMA memory. Map represents a memory block allocated according to these properties. Multiple maps may be associated with the same tag.</p></div><div class=paragraph><p>Tags are organized into a tree-like hierarchy with inheritance of the properties. A child tag inherits all the requirements of its parent tag, and may make them more strict but never more loose.</p></div><div class=paragraph><p>Normally one top-level tag (with no parent) is created for each device unit. If multiple memory areas with different requirements are needed for each device then a tag for each of them may be created as a child of the parent tag.</p></div><div class=paragraph><p>The tags can be used to create a map in two ways.</p></div><div class=paragraph><p>First, a chunk of contiguous memory conformant with the tag requirements may be allocated (and later may be freed). This is normally used to allocate relatively long-living areas of memory for communication with the device. Loading of such memory into a map is trivial: it is always considered as one chunk in the appropriate physical memory range.</p></div><div class=paragraph><p>Second, an arbitrary area of virtual memory may be loaded into a map. Each page of this memory will be checked for conformance to the map requirement. If it conforms then it is left at its original location. If it is not then a fresh conformant "bounce page" is allocated and used as intermediate storage. When writing the data from the non-conformant original pages they will be copied to their bounce pages first and then transferred from the bounce pages to the device. When reading the data would go from the device to the bounce pages and then copied to their non-conformant original pages. The process of copying between the original and bounce pages is called synchronization. This is normally used on a per-transfer basis: buffer for each transfer would be loaded, transfer done and buffer unloaded.</p></div><div class=paragraph><p>The functions working on the DMA memory are:</p></div><div class=ulist><ul><li><p><code>int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)</code></p><div class=paragraph><p>Create a new tag. Returns 0 on success, the error code otherwise.</p></div><div class=ulist><ul><li><p><em>parent</em> - parent tag, or NULL to create a top-level tag.</p></li><li><p><em>alignment</em> - required physical alignment of the memory area to be allocated for this tag. Use value 1 for "no specific alignment". Applies only to the future <code>bus_dmamem_alloc()</code> but not <code>bus_dmamap_create()</code> calls.</p></li><li><p><em>boundary</em> - physical address boundary that must not be crossed when allocating the memory. Use value 0 for "no boundary". Applies only to the future <code>bus_dmamem_alloc()</code> but not <code>bus_dmamap_create()</code> calls. Must be power of 2. If the memory is planned to be used in non-cascaded DMA mode (i.e., the DMA addresses will be supplied not by the device itself but by the ISA DMA controller) then the boundary must be no larger than 64KB (64*1024) due to the limitations of the DMA hardware.</p></li><li><p><em>lowaddr, highaddr</em> - the names are slightly misleading; these values are used to limit the permitted range of physical addresses used to allocate the memory. The exact meaning varies depending on the planned future use:</p><div class=ulist><ul><li><p>For <code>bus_dmamem_alloc()</code> all the addresses from 0 to lowaddr-1 are considered permitted, the higher ones are forbidden.</p></li><li><p>For <code>bus_dmamap_create()</code> all the addresses outside the inclusive range [lowaddr; highaddr] are considered accessible. The addresses of pages inside the range are passed to the filter function which decides if they are accessible. If no filter function is supplied then all the range is considered unaccessible.</p></li><li><p>For the ISA devices the normal values (with no filter function) are:</p><div class=paragraph><p>lowaddr = BUS_SPACE_MAXADDR_24BIT</p></div><div class=paragraph><p>highaddr = BUS_SPACE_MAXADDR</p></div></li></ul></div></li><li><p><em>filter, filterarg</em> - the filter function and its argument. If NULL is passed for filter then the whole range [lowaddr, highaddr] is considered unaccessible when doing <code>bus_dmamap_create()</code>. Otherwise the physical address of each attempted page in range [lowaddr; highaddr] is passed to the filter function which decides if it is accessible. The prototype of the filter function is: <code>int filterfunc(void *arg, bus_addr_t paddr)</code>. It must return 0 if the page is accessible, non-zero otherwise.</p></li><li><p><em>maxsize</em> - the maximal size of memory (in bytes) that may be allocated through this tag. In case it is difficult to estimate or could be arbitrarily big, the value for ISA devices would be <code>BUS_SPACE_MAXSIZE_24BIT</code>.</p></li><li><p><em>nsegments</em> - maximal number of scatter-gather segments supported by the device. If unrestricted then the value <code>BUS_SPACE_UNRESTRICTED</code> should be used. This value is recommended for the parent tags, the actual restrictions would then be specified for the descendant tags. Tags with nsegments equal to <code>BUS_SPACE_UNRESTRICTED</code> may not be used to actually load maps, they may be used only as parent tags. The practical limit for nsegments seems to be about 250-300, higher values will cause kernel stack overflow (the hardware can not normally support that many scatter-gather buffers anyway).</p></li><li><p><em>maxsegsz</em> - maximal size of a scatter-gather segment supported by the device. The maximal value for ISA device would be <code>BUS_SPACE_MAXSIZE_24BIT</code>.</p></li><li><p><em>flags</em> - a bitmap of flags. The only interesting flag is:</p><div class=ulist><ul><li><p><em>BUS_DMA_ALLOCNOW</em> - requests to allocate all the potentially needed bounce pages when creating the tag.</p></li></ul></div></li><li><p><em>dmat</em> - pointer to the storage for the new tag to be returned.</p></li></ul></div></li><li><p><code>int bus_dma_tag_destroy(bus_dma_tag_t dmat)</code></p><div class=paragraph><p>Destroy a tag. Returns 0 on success, the error code otherwise.</p></div><div class=paragraph><p>dmat - the tag to be destroyed.</p></div></li><li><p><code>int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, bus_dmamap_t *mapp)</code></p><div class=paragraph><p>Allocate an area of contiguous memory described by the tag. The size of memory to be allocated is tagâ€™s maxsize. Returns 0 on success, the error code otherwise. The result still has to be loaded by <code>bus_dmamap_load()</code> before being used to get the physical address of the memory.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>vaddr</em> - pointer to the storage for the kernel virtual address of the allocated area to be returned.</p></li><li><p>flags - a bitmap of flags. The only interesting flag is:</p><div class=ulist><ul><li><p><em>BUS_DMA_NOWAIT</em> - if the memory is not immediately available return the error. If this flag is not set then the routine is allowed to sleep until the memory becomes available.</p></li></ul></div></li><li><p><em>mapp</em> - pointer to the storage for the new map to be returned.</p></li></ul></div></li><li><p><code>void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map)</code></p><div class=paragraph><p>Free the memory allocated by <code>bus_dmamem_alloc()</code>. At present, freeing of the memory allocated with ISA restrictions is not implemented. Due to this the recommended model of use is to keep and re-use the allocated areas for as long as possible. Do not lightly free some area and then shortly allocate it again. That does not mean that <code>bus_dmamem_free()</code> should not be used at all: hopefully it will be properly implemented soon.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>vaddr</em> - the kernel virtual address of the memory</p></li><li><p><em>map</em> - the map of the memory (as returned from <code>bus_dmamem_alloc()</code>)</p></li></ul></div></li><li><p><code>int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp)</code></p><div class=paragraph><p>Create a map for the tag, to be used in <code>bus_dmamap_load()</code> later. Returns 0 on success, the error code otherwise.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>flags</em> - theoretically, a bit map of flags. But no flags are defined yet, so at present it will be always 0.</p></li><li><p><em>mapp</em> - pointer to the storage for the new map to be returned</p></li></ul></div></li><li><p><code>int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</code></p><div class=paragraph><p>Destroy a map. Returns 0 on success, the error code otherwise.</p></div><div class=ulist><ul><li><p>dmat - the tag to which the map is associated</p></li><li><p>map - the map to be destroyed</p></li></ul></div></li><li><p><code>int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf, bus_size_t buflen, bus_dmamap_callback_t *callback, void *callback_arg, int flags)</code></p><div class=paragraph><p>Load a buffer into the map (the map must be previously created by <code>bus_dmamap_create()</code> or <code>bus_dmamem_alloc()</code>). All the pages of the buffer are checked for conformance to the tag requirements and for those not conformant the bounce pages are allocated. An array of physical segment descriptors is built and passed to the callback routine. This callback routine is then expected to handle it in some way. The number of bounce buffers in the system is limited, so if the bounce buffers are needed but not immediately available the request will be queued and the callback will be called when the bounce buffers will become available. Returns 0 if the callback was executed immediately or <code>EINPROGRESS</code> if the request was queued for future execution. In the latter case the synchronization with queued callback routine is the responsibility of the driver.</p></div><div class=ulist><ul><li><p><em>dmat</em> - the tag</p></li><li><p><em>map</em> - the map</p></li><li><p><em>buf</em> - kernel virtual address of the buffer</p></li><li><p><em>buflen</em> - length of the buffer</p></li><li><p><em>callback</em>, <code>callback_arg</code> - the callback function and its argument</p><div class=paragraph><p>The prototype of callback function is: <code>void callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)</code></p></div></li><li><p><em>arg</em> - the same as callback_arg passed to <code>bus_dmamap_load()</code></p></li><li><p><em>seg</em> - array of the segment descriptors</p></li><li><p><em>nseg</em> - number of descriptors in array</p></li><li><p><em>error</em> - indication of the segment number overflow: if it is set to <code>EFBIG</code> then the buffer did not fit into the maximal number of segments permitted by the tag. In this case only the permitted number of descriptors will be in the array. Handling of this situation is up to the driver: depending on the desired semantics it can either consider this an error or split the buffer in two and handle the second part separately</p><div class=paragraph><p>Each entry in the segments array contains the fields:</p></div></li><li><p><em>ds_addr</em> - physical bus address of the segment</p></li><li><p><em>ds_len</em> - length of the segment</p></li></ul></div></li><li><p><code>void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</code></p><div class=paragraph><p>unload the map.</p></div><div class=ulist><ul><li><p><em>dmat</em> - tag</p></li><li><p><em>map</em> - loaded map</p></li></ul></div></li><li><p><code>void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, bus_dmasync_op_t op)</code></p><div class=paragraph><p>Synchronise a loaded buffer with its bounce pages before and after physical transfer to or from device. This is the function that does all the necessary copying of data between the original buffer and its mapped version. The buffers must be synchronized both before and after doing the transfer.</p></div><div class=ulist><ul><li><p><em>dmat</em> - tag</p></li><li><p><em>map</em> - loaded map</p></li><li><p><em>op</em> - type of synchronization operation to perform:</p></li><li><p><code>BUS_DMASYNC_PREREAD</code> - before reading from device into buffer</p></li><li><p><code>BUS_DMASYNC_POSTREAD</code> - after reading from device into buffer</p></li><li><p><code>BUS_DMASYNC_PREWRITE</code> - before writing the buffer to device</p></li><li><p><code>BUS_DMASYNC_POSTWRITE</code> - after writing the buffer to device</p></li></ul></div></li></ul></div><div class=paragraph><p>As of now PREREAD and POSTWRITE are null operations but that may change in the future, so they must not be ignored in the driver. Synchronization is not needed for the memory obtained from <code>bus_dmamem_alloc()</code>.</p></div><div class=paragraph><p>Before calling the callback function from <code>bus_dmamap_load()</code> the segment array is stored in the stack. And it gets pre-allocated for the maximal number of segments allowed by the tag. As a result of this the practical limit for the number of segments on i386 architecture is about 250-300 (the kernel stack is 4KB minus the size of the user structure, size of a segment array entry is 8 bytes, and some space must be left). Since the array is allocated based on the maximal number this value must not be set higher than really needed. Fortunately, for most of hardware the maximal supported number of segments is much lower. But if the driver wants to handle buffers with a very large number of scatter-gather segments it should do that in portions: load part of the buffer, transfer it to the device, load next part of the buffer, and so on.</p></div><div class=paragraph><p>Another practical consequence is that the number of segments may limit the size of the buffer. If all the pages in the buffer happen to be physically non-contiguous then the maximal supported buffer size for that fragmented case would be (nsegments * page_size). For example, if a maximal number of 10 segments is supported then on i386 maximal guaranteed supported buffer size would be 40K. If a higher size is desired then special tricks should be used in the driver.</p></div><div class=paragraph><p>If the hardware does not support scatter-gather at all or the driver wants to support some buffer size even if it is heavily fragmented then the solution is to allocate a contiguous buffer in the driver and use it as intermediate storage if the original buffer does not fit.</p></div><div class=paragraph><p>Below are the typical call sequences when using a map depend on the use of the map. The characters â†’ are used to show the flow of time.</p></div><div class=paragraph><p>For a buffer which stays practically fixed during all the time between attachment and detachment of a device:</p></div><div class=paragraph><p>bus_dmamem_alloc â†’ bus_dmamap_load â†’ â€¦â€‹use bufferâ€¦â€‹ â†’ â†’ bus_dmamap_unload â†’ bus_dmamem_free</p></div><div class=paragraph><p>For a buffer that changes frequently and is passed from outside the driver:</p></div><div class="literalblock programlisting"><div class=content><pre>          bus_dmamap_create -&gt;
          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;
          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;
          ...
          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;
          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;
          -&gt; bus_dmamap_destroy</pre></div></div><div class=paragraph><p>When loading a map created by <code>bus_dmamem_alloc()</code> the passed address and size of the buffer must be the same as used in <code>bus_dmamem_alloc()</code>. In this case it is guaranteed that the whole buffer will be mapped as one segment (so the callback may be based on this assumption) and the request will be executed immediately (EINPROGRESS will never be returned). All the callback needs to do in this case is to save the physical address.</p></div><div class=paragraph><p>A typical example would be:</p></div><div class="literalblock programlisting"><div class=content><pre>          static void
        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)
        {
          *(bus_addr_t *)arg = seg[0].ds_addr;
        }

          ...
          int error;
          struct somedata {
            ....
          };
          struct somedata *vsomedata; /* virtual address */
          bus_addr_t psomedata; /* physical bus-relative address */
          bus_dma_tag_t tag_somedata;
          bus_dmamap_t map_somedata;
          ...

          error=bus_dma_tag_create(parent_tag, alignment,
           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,
           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,
           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,
           &amp;tag_somedata);
          if(error)
          return error;

          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ 0,
             &amp;map_somedata);
          if(error)
             return error;

          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,
             sizeof (struct somedata), alloc_callback,
             (void *) &amp;psomedata, /*flags*/0);</pre></div></div><div class=paragraph><p>Looks a bit long and complicated but that is the way to do it. The practical consequence is: if multiple memory areas are allocated always together it would be a really good idea to combine them all into one structure and allocate as one (if the alignment and boundary limitations permit).</p></div><div class=paragraph><p>When loading an arbitrary buffer into the map created by <code>bus_dmamap_create()</code> special measures must be taken to synchronize with the callback in case it would be delayed. The code would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>          {
           int s;
           int error;

           s = splsoftvm();
           error = bus_dmamap_load(
               dmat,
               dmamap,
               buffer_ptr,
               buffer_len,
               callback,
               /*callback_arg*/ buffer_descriptor,
               /*flags*/0);
           if (error == EINPROGRESS) {
               /*
                * Do whatever is needed to ensure synchronization
                * with callback. Callback is guaranteed not to be started
                * until we do splx() or tsleep().
                */
              }
           splx(s);
          }</pre></div></div><div class=paragraph><p>Two possible approaches for the processing of requests are:</p></div><div class="olist arabic"><ol class=arabic><li><p>If requests are completed by marking them explicitly as done (such as the CAM requests) then it would be simpler to put all the further processing into the callback driver which would mark the request when it is done. Then not much extra synchronization is needed. For the flow control reasons it may be a good idea to freeze the request queue until this request gets completed.</p></li><li><p>If requests are completed when the function returns (such as classic read or write requests on character devices) then a synchronization flag should be set in the buffer descriptor and <code>tsleep()</code> called. Later when the callback gets called it will do its processing and check this synchronization flag. If it is set then the callback should issue a wakeup. In this approach the callback function could either do all the needed processing (just like the previous case) or simply save the segments array in the buffer descriptor. Then after callback completes the calling function could use this saved segments array and do all the processing.</p></li></ol></div></div></div><div class=sect1><h2 id=isa-driver-dma>10.7. DMA<a class=anchor href=#isa-driver-dma></a></h2><div class=sectionbody><div class=paragraph><p>The Direct Memory Access (DMA) is implemented in the ISA bus through the DMA controller (actually, two of them but that is an irrelevant detail). To make the early ISA devices simple and cheap the logic of the bus control and address generation was concentrated in the DMA controller. Fortunately, FreeBSD provides a set of functions that mostly hide the annoying details of the DMA controller from the device drivers.</p></div><div class=paragraph><p>The simplest case is for the fairly intelligent devices. Like the bus master devices on PCI they can generate the bus cycles and memory addresses all by themselves. The only thing they really need from the DMA controller is bus arbitration. So for this purpose they pretend to be cascaded slave DMA controllers. And the only thing needed from the system DMA controller is to enable the cascaded mode on a DMA channel by calling the following function when attaching the driver:</p></div><div class=paragraph><p><code>void isa_dmacascade(int channel_number)</code></p></div><div class=paragraph><p>All the further activity is done by programming the device. When detaching the driver no DMA-related functions need to be called.</p></div><div class=paragraph><p>For the simpler devices things get more complicated. The functions used are:</p></div><div class=ulist><ul><li><p><code>int isa_dma_acquire(int chanel_number)</code></p><div class=paragraph><p>Reserve a DMA channel. Returns 0 on success or EBUSY if the channel was already reserved by this or a different driver. Most of the ISA devices are not able to share DMA channels anyway, so normally this function is called when attaching a device. This reservation was made redundant by the modern interface of bus resources but still must be used in addition to the latter. If not used then later, other DMA routines will panic.</p></div></li><li><p><code>int isa_dma_release(int chanel_number)</code></p><div class=paragraph><p>Release a previously reserved DMA channel. No transfers must be in progress when the channel is released (in addition the device must not try to initiate transfer after the channel is released).</p></div></li><li><p><code>void isa_dmainit(int chan, u_int bouncebufsize)</code></p><div class=paragraph><p>Allocate a bounce buffer for use with the specified channel. The requested size of the buffer can not exceed 64KB. This bounce buffer will be automatically used later if a transfer buffer happens to be not physically contiguous or outside of the memory accessible by the ISA bus or crossing the 64KB boundary. If the transfers will be always done from buffers which conform to these conditions (such as those allocated by <code>bus_dmamem_alloc()</code> with proper limitations) then <code>isa_dmainit()</code> does not have to be called. But it is quite convenient to transfer arbitrary data using the DMA controller. The bounce buffer will automatically care of the scatter-gather issues.</p></div><div class=ulist><ul><li><p><em>chan</em> - channel number</p></li><li><p><em>bouncebufsize</em> - size of the bounce buffer in bytes</p></li></ul></div></li><li><p><code>void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int chan)</code></p><div class=paragraph><p>Prepare to start a DMA transfer. This function must be called to set up the DMA controller before actually starting transfer on the device. It checks that the buffer is contiguous and falls into the ISA memory range, if not then the bounce buffer is automatically used. If bounce buffer is required but not set up by <code>isa_dmainit()</code> or too small for the requested transfer size then the system will panic. In case of a write request with bounce buffer the data will be automatically copied to the bounce buffer.</p></div></li><li><p>flags - a bitmask determining the type of operation to be done. The direction bits B_READ and B_WRITE are mutually exclusive.</p><div class=ulist><ul><li><p>B_READ - read from the ISA bus into memory</p></li><li><p>B_WRITE - write from the memory to the ISA bus</p></li><li><p>B_RAW - if set then the DMA controller will remember the buffer and after the end of transfer will automatically re-initialize itself to repeat transfer of the same buffer again (of course, the driver may change the data in the buffer before initiating another transfer in the device). If not set then the parameters will work only for one transfer, and <code>isa_dmastart()</code> will have to be called again before initiating the next transfer. Using B_RAW makes sense only if the bounce buffer is not used.</p></li></ul></div></li><li><p>addr - virtual address of the buffer</p></li><li><p>nbytes - length of the buffer. Must be less or equal to 64KB. Length of 0 is not allowed: the DMA controller will understand it as 64KB while the kernel code will understand it as 0 and that would cause unpredictable effects. For channels number 4 and higher the length must be even because these channels transfer 2 bytes at a time. In case of an odd length the last byte will not be transferred.</p></li><li><p>chan - channel number</p></li><li><p><code>void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)</code></p><div class=paragraph><p>Synchronize the memory after device reports that transfer is done. If that was a read operation with a bounce buffer then the data will be copied from the bounce buffer to the original buffer. Arguments are the same as for <code>isa_dmastart()</code>. Flag B_RAW is permitted but it does not affect <code>isa_dmadone()</code> in any way.</p></div></li><li><p><code>int isa_dmastatus(int channel_number)</code></p><div class=paragraph><p>Returns the number of bytes left in the current transfer to be transferred. In case the flag B_READ was set in <code>isa_dmastart()</code> the number returned will never be equal to zero. At the end of transfer it will be automatically reset back to the length of buffer. The normal use is to check the number of bytes left after the device signals that the transfer is completed. If the number of bytes is not 0 then something probably went wrong with that transfer.</p></div></li><li><p><code>int isa_dmastop(int channel_number)</code></p><div class=paragraph><p>Aborts the current transfer and returns the number of bytes left untransferred.</p></div></li></ul></div></div></div><div class=sect1><h2 id=isa-driver-probe>10.8. xxx_isa_probe<a class=anchor href=#isa-driver-probe></a></h2><div class=sectionbody><div class=paragraph><p>This function probes if a device is present. If the driver supports auto-detection of some part of device configuration (such as interrupt vector or memory address) this auto-detection must be done in this routine.</p></div><div class=paragraph><p>As for any other bus, if the device cannot be detected or is detected but failed the self-test or some other problem happened then it returns a positive value of error. The value <code>ENXIO</code> must be returned if the device is not present. Other error values may mean other conditions. Zero or negative values mean success. Most of the drivers return zero as success.</p></div><div class=paragraph><p>The negative return values are used when a PnP device supports multiple interfaces. For example, an older compatibility interface and a newer advanced interface which are supported by different drivers. Then both drivers would detect the device. The driver which returns a higher value in the probe routine takes precedence (in other words, the driver returning 0 has highest precedence, one returning -1 is next, one returning -2 is after it and so on). In result the devices which support only the old interface will be handled by the old driver (which should return -1 from the probe routine) while the devices supporting the new interface as well will be handled by the new driver (which should return 0 from the probe routine).</p></div><div class=paragraph><p>The device descriptor struct xxx_softc is allocated by the system before calling the probe routine. If the probe routine returns an error the descriptor will be automatically deallocated by the system. So if a probing error occurs the driver must make sure that all the resources it used during probe are deallocated and that nothing keeps the descriptor from being safely deallocated. If the probe completes successfully the descriptor will be preserved by the system and later passed to the routine <code>xxx_isa_attach()</code>. If a driver returns a negative value it can not be sure that it will have the highest priority and its attach routine will be called. So in this case it also must release all the resources before returning and if necessary allocate them again in the attach routine. When <code>xxx_isa_probe()</code> returns 0 releasing the resources before returning is also a good idea and a well-behaved driver should do so. But in cases where there is some problem with releasing the resources the driver is allowed to keep resources between returning 0 from the probe routine and execution of the attach routine.</p></div><div class=paragraph><p>A typical probe routine starts with getting the device descriptor and unit:</p></div><div class="literalblock programlisting"><div class=content><pre>         struct xxx_softc *sc = device_get_softc(dev);
          int unit = device_get_unit(dev);
          int pnperror;
          int error = 0;

          sc-&gt;dev = dev; /* link it back */
          sc-&gt;unit = unit;</pre></div></div><div class=paragraph><p>Then check for the PnP devices. The check is carried out by a table containing the list of PnP IDs supported by this driver and human-readable descriptions of the device models corresponding to these IDs.</p></div><div class="literalblock programlisting"><div class=content><pre>        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,
        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;</pre></div></div><div class=paragraph><p>The logic of ISA_PNP_PROBE is the following: If this card (device unit) was not detected as PnP then ENOENT will be returned. If it was detected as PnP but its detected ID does not match any of the IDs in the table then ENXIO is returned. Finally, if it has PnP support and it matches on of the IDs in the table, 0 is returned and the appropriate description from the table is set by <code>device_set_desc()</code>.</p></div><div class=paragraph><p>If a driver supports only PnP devices then the condition would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>          if(pnperror != 0)
              return pnperror;</pre></div></div><div class=paragraph><p>No special treatment is required for the drivers which do not support PnP because they pass an empty PnP ID table and will always get ENXIO if called on a PnP card.</p></div><div class=paragraph><p>The probe routine normally needs at least some minimal set of resources, such as I/O port number to find the card and probe it. Depending on the hardware the driver may be able to discover the other necessary resources automatically. The PnP devices have all the resources pre-set by the PnP subsystem, so the driver does not need to discover them by itself.</p></div><div class=paragraph><p>Typically the minimal information required to get access to the device is the I/O port number. Then some devices allow to get the rest of information from the device configuration registers (though not all devices do that). So first we try to get the port start value:</p></div><div class="literalblock programlisting"><div class=content><pre> sc-&gt;port0 = bus_get_resource_start(dev,
        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;</pre></div></div><div class=paragraph><p>The base port address is saved in the structure softc for future use. If it will be used very often then calling the resource function each time would be prohibitively slow. If we do not get a port we just return an error. Some device drivers can instead be clever and try to probe all the possible ports, like this:</p></div><div class="literalblock programlisting"><div class=content><pre>          /* table of all possible base I/O port addresses for this device */
          static struct xxx_allports {
              u_short port; /* port address */
              short used; /* flag: if this port is already used by some unit */
          } xxx_allports = {
              { 0x300, 0 },
              { 0x320, 0 },
              { 0x340, 0 },
              { 0, 0 } /* end of table */
          };

          ...
          int port, i;
          ...

          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);
          if(port !=0 ) {
              for(i=0; xxx_allports[i].port!=0; i++) {
                  if(xxx_allports[i].used || xxx_allports[i].port != port)
                      continue;

                  /* found it */
                  xxx_allports[i].used = 1;
                  /* do probe on a known port */
                  return xxx_really_probe(dev, port);
              }
              return ENXIO; /* port is unknown or already used */
          }

          /* we get here only if we need to guess the port */
          for(i=0; xxx_allports[i].port!=0; i++) {
              if(xxx_allports[i].used)
                  continue;

              /* mark as used - even if we find nothing at this port
               * at least we won&#39;t probe it in future
               */
               xxx_allports[i].used = 1;

              error = xxx_really_probe(dev, xxx_allports[i].port);
              if(error == 0) /* found a device at that port */
                  return 0;
          }
          /* probed all possible addresses, none worked */
          return ENXIO;</pre></div></div><div class=paragraph><p>Of course, normally the driverâ€™s <code>identify()</code> routine should be used for such things. But there may be one valid reason why it may be better to be done in <code>probe()</code>: if this probe would drive some other sensitive device crazy. The probe routines are ordered with consideration of the <code>sensitive</code> flag: the sensitive devices get probed first and the rest of the devices later. But the <code>identify()</code> routines are called before any probes, so they show no respect to the sensitive devices and may upset them.</p></div><div class=paragraph><p>Now, after we got the starting port we need to set the port count (except for PnP devices) because the kernel does not have this information in the configuration file.</p></div><div class="literalblock programlisting"><div class=content><pre>         if(pnperror /* only for non-PnP devices */
         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,
         XXX_PORT_COUNT)&lt;0)
             return ENXIO;</pre></div></div><div class=paragraph><p>Finally allocate and activate a piece of port address space (special values of start and end mean "use those we set by <code>bus_set_resource()</code>"):</p></div><div class="literalblock programlisting"><div class=content><pre>          sc-&gt;port0_rid = 0;
          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,
          &amp;sc-&gt;port0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;port0_r == NULL)
              return ENXIO;</pre></div></div><div class=paragraph><p>Now having access to the port-mapped registers we can poke the device in some way and check if it reacts like it is expected to. If it does not then there is probably some other device or no device at all at this address.</p></div><div class=paragraph><p>Normally drivers do not set up the interrupt handlers until the attach routine. Instead they do probes in the polling mode using the <code>DELAY()</code> function for timeout. The probe routine must never hang forever, all the waits for the device must be done with timeouts. If the device does not respond within the time it is probably broken or misconfigured and the driver must return error. When determining the timeout interval give the device some extra time to be on the safe side: although <code>DELAY()</code> is supposed to delay for the same amount of time on any machine it has some margin of error, depending on the exact CPU.</p></div><div class=paragraph><p>If the probe routine really wants to check that the interrupts really work it may configure and probe the interrupts too. But that is not recommended.</p></div><div class="literalblock programlisting"><div class=content><pre>          /* implemented in some very device-specific way */
          if(error = xxx_probe_ports(sc))
              goto bad; /* will deallocate the resources before returning */</pre></div></div><div class=paragraph><p>The function <code>xxx_probe_ports()</code> may also set the device description depending on the exact model of device it discovers. But if there is only one supported device model this can be as well done in a hardcoded way. Of course, for the PnP devices the PnP support sets the description from the table automatically.</p></div><div class="literalblock programlisting"><div class=content><pre>          if(pnperror)
              device_set_desc(dev, &#34;Our device model 1234&#34;);</pre></div></div><div class=paragraph><p>Then the probe routine should either discover the ranges of all the resources by reading the device configuration registers or make sure that they were set explicitly by the user. We will consider it with an example of on-board memory. The probe routine should be as non-intrusive as possible, so allocation and check of functionality of the rest of resources (besides the ports) would be better left to the attach routine.</p></div><div class=paragraph><p>The memory address may be specified in the kernel configuration file or on some devices it may be pre-configured in non-volatile configuration registers. If both sources are available and different, which one should be used? Probably if the user bothered to set the address explicitly in the kernel configuration file they know what they are doing and this one should take precedence. An example of implementation could be:</p></div><div class="literalblock programlisting"><div class=content><pre>          /* try to find out the config address first */
          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);
          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */
              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);

          if(sc-&gt;mem0_p == 0)
                  /* can&#39;t get it from device config registers either */
                  goto bad;
          } else {
              if(xxx_set_mem0_address_on_device(sc) &lt; 0)
                  goto bad; /* device does not support that address */
          }

          /* just like the port, set the memory size,
           * for some devices the memory size would not be constant
           * but should be read from the device configuration registers instead
           * to accommodate different models of devices. Another option would
           * be to let the user set the memory size as &#34;msize&#34; configuration
           * resource which will be automatically handled by the ISA bus.
           */
           if(pnperror) { /* only for non-PnP devices */
              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);
              if(sc-&gt;mem0_size == 0) /* not specified by user */
                  sc-&gt;mem0_size = xxx_read_mem0_size_from_device_config(sc);

              if(sc-&gt;mem0_size == 0) {
                  /* suppose this is a very old model of device without
                   * auto-configuration features and the user gave no preference,
                   * so assume the minimalistic case
                   * (of course, the real value will vary with the driver)
                   */
                  sc-&gt;mem0_size = 8*1024;
              }

              if(xxx_set_mem0_size_on_device(sc) &lt; 0)
                  goto bad; /* device does not support that size */

              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,
                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)
                  goto bad;
          } else {
              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);
          }</pre></div></div><div class=paragraph><p>Resources for IRQ and DRQ are easy to check by analogy.</p></div><div class=paragraph><p>If all went well then release all the resources and return success.</p></div><div class="literalblock programlisting"><div class=content><pre>          xxx_free_resources(sc);
          return 0;</pre></div></div><div class=paragraph><p>Finally, handle the troublesome situations. All the resources should be deallocated before returning. We make use of the fact that before the structure softc is passed to us it gets zeroed out, so we can find out if some resource was allocated: then its descriptor is non-zero.</p></div><div class="literalblock programlisting"><div class=content><pre>          bad:

          xxx_free_resources(sc);
          if(error)
                return error;
          else /* exact error is unknown */
              return ENXIO;</pre></div></div><div class=paragraph><p>That would be all for the probe routine. Freeing of resources is done from multiple places, so it is moved to a function which may look like:</p></div><div class="literalblock programlisting"><div class=content><pre>static void
           xxx_free_resources(sc)
              struct xxx_softc *sc;
          {
              /* check every resource and free if not zero */

              /* interrupt handler */
              if(sc-&gt;intr_r) {
                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-&gt;intr_cookie);
                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-&gt;intr_rid,
                      sc-&gt;intr_r);
                  sc-&gt;intr_r = 0;
              }

              /* all kinds of memory maps we could have allocated */
              if(sc-&gt;data_p) {
                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);
                  sc-&gt;data_p = 0;
              }
               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately equal to 0 */
                  /* the map will also be freed */
                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-&gt;data_map);
                  sc-&gt;data = 0;
              }
              if(sc-&gt;data_tag) {
                  bus_dma_tag_destroy(sc-&gt;data_tag);
                  sc-&gt;data_tag = 0;
              }

              ... free other maps and tags if we have them ...

              if(sc-&gt;parent_tag) {
                  bus_dma_tag_destroy(sc-&gt;parent_tag);
                  sc-&gt;parent_tag = 0;
              }

              /* release all the bus resources */
              if(sc-&gt;mem0_r) {
                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-&gt;mem0_rid,
                      sc-&gt;mem0_r);
                  sc-&gt;mem0_r = 0;
              }
              ...
              if(sc-&gt;port0_r) {
                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-&gt;port0_rid,
                      sc-&gt;port0_r);
                  sc-&gt;port0_r = 0;
              }
          }</pre></div></div></div></div><div class=sect1><h2 id=isa-driver-attach>10.9. xxx_isa_attach<a class=anchor href=#isa-driver-attach></a></h2><div class=sectionbody><div class=paragraph><p>The attach routine actually connects the driver to the system if the probe routine returned success and the system had chosen to attach that driver. If the probe routine returned 0 then the attach routine may expect to receive the device structure softc intact, as it was set by the probe routine. Also if the probe routine returns 0 it may expect that the attach routine for this device shall be called at some point in the future. If the probe routine returns a negative value then the driver may make none of these assumptions.</p></div><div class=paragraph><p>The attach routine returns 0 if it completed successfully or error code otherwise.</p></div><div class=paragraph><p>The attach routine starts just like the probe routine, with getting some frequently used data into more accessible variables.</p></div><div class="literalblock programlisting"><div class=content><pre>          struct xxx_softc *sc = device_get_softc(dev);
          int unit = device_get_unit(dev);
          int error = 0;</pre></div></div><div class=paragraph><p>Then allocate and activate all the necessary resources. As normally the port range will be released before returning from probe, it has to be allocated again. We expect that the probe routine had properly set all the resource ranges, as well as saved them in the structure softc. If the probe routine had left some resource allocated then it does not need to be allocated again (which would be considered an error).</p></div><div class="literalblock programlisting"><div class=content><pre>          sc-&gt;port0_rid = 0;
          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-&gt;port0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;port0_r == NULL)
               return ENXIO;

          /* on-board memory */
          sc-&gt;mem0_rid = 0;
          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;mem0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;mem0_r == NULL)
                goto bad;

          /* get its virtual address */
          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);</pre></div></div><div class=paragraph><p>The DMA request channel (DRQ) is allocated likewise. To initialize it use functions of the <code>isa_dma*()</code> family. For example:</p></div><div class=paragraph><p><code>isa_dmacascade(scâ†’drq0);</code></p></div><div class=paragraph><p>The interrupt request line (IRQ) is a bit special. Besides allocation the driverâ€™s interrupt handler should be associated with it. Historically in the old ISA drivers the argument passed by the system to the interrupt handler was the device unit number. But in modern drivers the convention suggests passing the pointer to structure softc. The important reason is that when the structures softc are allocated dynamically then getting the unit number from softc is easy while getting softc from the unit number is difficult. Also this convention makes the drivers for different buses look more uniform and allows them to share the code: each bus gets its own probe, attach, detach and other bus-specific routines while the bulk of the driver code may be shared among them.</p></div><div class="literalblock programlisting"><div class=content><pre>          sc-&gt;intr_rid = 0;
          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;intr_rid,
                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;intr_r == NULL)
              goto bad;

          /*
           * XXX_INTR_TYPE is supposed to be defined depending on the type of
           * the driver, for example as INTR_TYPE_CAM for a CAM driver
           */
          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,
              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-&gt;intr_cookie);
          if(error)
              goto bad;</pre></div></div><div class=paragraph><p>If the device needs to make DMA to the main memory then this memory should be allocated like described before:</p></div><div class="literalblock programlisting"><div class=content><pre>          error=bus_dma_tag_create(NULL, /*alignment*/ 4,
              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,
              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,
              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,
              /*nsegments*/ BUS_SPACE_UNRESTRICTED,
              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,
              &amp;sc-&gt;parent_tag);
          if(error)
              goto bad;

          /* many things get inherited from the parent tag
           * sc-&gt;data is supposed to point to the structure with the shared data,
           * for example for a ring buffer it could be:
           * struct {
           *   u_short rd_pos;
           *   u_short wr_pos;
           *   char    bf[XXX_RING_BUFFER_SIZE]
           * } *data;
           */
          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,
              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,
              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,
              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,
              &amp;sc-&gt;data_tag);
          if(error)
              goto bad;

          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* flags*/ 0,
              &amp;sc-&gt;data_map);
          if(error)
               goto bad;

          /* xxx_alloc_callback() just saves the physical address at
           * the pointer passed as its argument, in this case &amp;sc-&gt;data_p.
           * See details in the section on bus memory mapping.
           * It can be implemented like:
           *
           * static void
           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,
           *     int nseg, int error)
           * {
           *    *(bus_addr_t *)arg = seg[0].ds_addr;
           * }
           */
          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-&gt;data,
              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-&gt;data_p,
              /*flags*/0);</pre></div></div><div class=paragraph><p>After all the necessary resources are allocated the device should be initialized. The initialization may include testing that all the expected features are functional.</p></div><div class="literalblock programlisting"><div class=content><pre>          if(xxx_initialize(sc) &lt; 0)
               goto bad;</pre></div></div><div class=paragraph><p>The bus subsystem will automatically print on the console the device description set by probe. But if the driver wants to print some extra information about the device it may do so, for example:</p></div><div class="literalblock programlisting"><div class=content><pre>        device_printf(dev, &#34;has on-card FIFO buffer of %d bytes\n&#34;, sc-&gt;fifosize);</pre></div></div><div class=paragraph><p>If the initialization routine experiences any problems then printing messages about them before returning error is also recommended.</p></div><div class=paragraph><p>The final step of the attach routine is attaching the device to its functional subsystem in the kernel. The exact way to do it depends on the type of the driver: a character device, a block device, a network device, a CAM SCSI bus device and so on.</p></div><div class=paragraph><p>If all went well then return success.</p></div><div class="literalblock programlisting"><div class=content><pre>          error = xxx_attach_subsystem(sc);
          if(error)
              goto bad;

          return 0;</pre></div></div><div class=paragraph><p>Finally, handle the troublesome situations. All the resources should be deallocated before returning an error. We make use of the fact that before the structure softc is passed to us it gets zeroed out, so we can find out if some resource was allocated: then its descriptor is non-zero.</p></div><div class="literalblock programlisting"><div class=content><pre>          bad:

          xxx_free_resources(sc);
          if(error)
              return error;
          else /* exact error is unknown */
              return ENXIO;</pre></div></div><div class=paragraph><p>That would be all for the attach routine.</p></div></div></div><div class=sect1><h2 id=isa-driver-detach>10.10. xxx_isa_detach<a class=anchor href=#isa-driver-detach></a></h2><div class=sectionbody><div class=paragraph><p>If this function is present in the driver and the driver is compiled as a loadable module then the driver gets the ability to be unloaded. This is an important feature if the hardware supports hot plug. But the ISA bus does not support hot plug, so this feature is not particularly important for the ISA devices. The ability to unload a driver may be useful when debugging it, but in many cases installation of the new version of the driver would be required only after the old version somehow wedges the system and a reboot will be needed anyway, so the efforts spent on writing the detach routine may not be worth it. Another argument that unloading would allow upgrading the drivers on a production machine seems to be mostly theoretical. Installing a new version of a driver is a dangerous operation which should never be performed on a production machine (and which is not permitted when the system is running in secure mode). Still, the detach routine may be provided for the sake of completeness.</p></div><div class=paragraph><p>The detach routine returns 0 if the driver was successfully detached or the error code otherwise.</p></div><div class=paragraph><p>The logic of detach is a mirror of the attach. The first thing to do is to detach the driver from its kernel subsystem. If the device is currently open then the driver has two choices: refuse to be detached or forcibly close and proceed with detach. The choice used depends on the ability of the particular kernel subsystem to do a forced close and on the preferences of the driverâ€™s author. Generally the forced close seems to be the preferred alternative.</p></div><div class="literalblock programlisting"><div class=content><pre>          struct xxx_softc *sc = device_get_softc(dev);
          int error;

          error = xxx_detach_subsystem(sc);
          if(error)
              return error;</pre></div></div><div class=paragraph><p>Next the driver may want to reset the hardware to some consistent state. That includes stopping any ongoing transfers, disabling the DMA channels and interrupts to avoid memory corruption by the device. For most of the drivers this is exactly what the shutdown routine does, so if it is included in the driver we can just call it.</p></div><div class=paragraph><p><code>xxx_isa_shutdown(dev);</code></p></div><div class=paragraph><p>And finally release all the resources and return success.</p></div><div class="literalblock programlisting"><div class=content><pre>          xxx_free_resources(sc);
          return 0;</pre></div></div></div></div><div class=sect1><h2 id=isa-driver-shutdown>10.11. xxx_isa_shutdown<a class=anchor href=#isa-driver-shutdown></a></h2><div class=sectionbody><div class=paragraph><p>This routine is called when the system is about to be shut down. It is expected to bring the hardware to some consistent state. For most of the ISA devices no special action is required, so the function is not really necessary because the device will be re-initialized on reboot anyway. But some devices have to be shut down with a special procedure, to make sure that they will be properly detected after soft reboot (this is especially true for many devices with proprietary identification protocols). In any case disabling DMA and interrupts in the device registers and stopping any ongoing transfers is a good idea. The exact action depends on the hardware, so we do not consider it here in any detail.</p></div></div></div><div class=sect1><h2 id=isa-driver-intr>10.12. xxx_intr<a class=anchor href=#isa-driver-intr></a></h2><div class=sectionbody><div class=paragraph><p>The interrupt handler is called when an interrupt is received which may be from this particular device. The ISA bus does not support interrupt sharing (except in some special cases) so in practice if the interrupt handler is called then the interrupt almost for sure came from its device. Still, the interrupt handler must poll the device registers and make sure that the interrupt was generated by its device. If not it should just return.</p></div><div class=paragraph><p>The old convention for the ISA drivers was getting the device unit number as an argument. This is obsolete, and the new drivers receive whatever argument was specified for them in the attach routine when calling <code>bus_setup_intr()</code>. By the new convention it should be the pointer to the structure softc. So the interrupt handler commonly starts as:</p></div><div class="literalblock programlisting"><div class=content><pre>          static void
          xxx_intr(struct xxx_softc *sc)
          {</pre></div></div><div class=paragraph><p>It runs at the interrupt priority level specified by the interrupt type parameter of <code>bus_setup_intr()</code>. That means that all the other interrupts of the same type as well as all the software interrupts are disabled.</p></div><div class=paragraph><p>To avoid races it is commonly written as a loop:</p></div><div class="literalblock programlisting"><div class=content><pre>          while(xxx_interrupt_pending(sc)) {
              xxx_process_interrupt(sc);
              xxx_acknowledge_interrupt(sc);
          }</pre></div></div><div class=paragraph><p>The interrupt handler has to acknowledge interrupt to the device only but not to the interrupt controller, the system takes care of the latter.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: March 9, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/en/books/arch-handbook/driverbasics class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/en/books/arch-handbook/pci class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#isa-driver-synopsis>10.1. Synopsis</a></li><li><a href=#isa-driver-basics>10.2. Basic Information</a></li><li><a href=#isa-driver-device-t>10.3. <code>device_t</code> Pointer</a></li><li><a href=#isa-driver-config>10.4. Configuration File and the Order of Identifying and Probing During Auto-Configuration</a></li><li><a href=#isa-driver-resources>10.5. Resources</a></li><li><a href=#isa-driver-busmem>10.6. Bus Memory Mapping</a></li><li><a href=#isa-driver-dma>10.7. DMA</a></li><li><a href=#isa-driver-probe>10.8. xxx_isa_probe</a></li><li><a href=#isa-driver-attach>10.9. xxx_isa_attach</a></li><li><a href=#isa-driver-detach>10.10. xxx_isa_detach</a></li><li><a href=#isa-driver-shutdown>10.11. xxx_isa_shutdown</a></li><li><a href=#isa-driver-intr>10.12. xxx_intr</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/arch-handbook/arch-handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/en/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>â™¥</span> by the FreeBSD Community</span></section></div></footer></body></html>