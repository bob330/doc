<!doctype html><html class=theme-light lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="x86 Assembly Language Programming"><meta name=keywords content="x86,guide"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/en/books/developers-handbook/x86/><title>Chapter 11. x86 Assembly Language Programming | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapter 11. x86 Assembly Language Programming"><meta property="og:description" content="x86 Assembly Language Programming"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="http://172.16.201.134:1313/en/books/developers-handbook/x86/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/en\/books\/developers-handbook\/x86\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/en/books>Books</a></li><li><a href=http://172.16.201.134:1313/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/parti/>Part I. Basics</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/introduction/>Chapter 1. Introduction</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/introduction/#introduction-devel>1.1. Developing on FreeBSD</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/introduction/#introduction-bsdvision>1.2. The BSD Vision</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/introduction/#introduction-archguide>1.3. Architectural Guidelines</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/introduction/#introduction-layout>1.4. The Layout of /usr/src</a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/>Chapter 2. Programming Tools</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#tools-synopsis>2.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#tools-intro>2.2. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#tools-programming>2.3. Introduction to Programming</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#tools-compiling>2.4. Compiling with <code>cc</code></a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#debugging>2.6. Debugging</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#emacs>2.7. Using Emacs as a Development Environment</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/tools/#tools-reading>2.8. Further Reading</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/>Chapter 3. Secure Programming</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/#secure-synopsis>3.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/#secure-philosophy>3.2. Secure Design Methodology</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/#secure-bufferov>3.3. Buffer Overflows</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/#secure-setuid>3.4. SetUID issues</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/#secure-chroot>3.5. Limiting your program’s environment</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/#secure-trust>3.6. Trust</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/secure/#secure-race-conditions>3.7. Race Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/l10n/>Chapter 4. Localization and Internationalization - L10N and I18N</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/l10n/#l10n-programming>4.1. Programming I18N Compliant Applications</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/l10n/#posix-nls>4.2. Localized Messages with POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/policies/>Chapter 5. Source Tree Guidelines and Policies</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/policies/#policies-style>5.1. Style Guidelines</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> on Makefiles</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/policies/#policies-contributed>5.3. Contributed Software</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/policies/#policies-encumbered>5.4. Encumbered Files</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/policies/#policies-shlib>5.5. Shared Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/testing/>Chapter 6. Regression and Performance Testing</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Micro Benchmark Checklist</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/testing/#testing-tinderbox>6.2. The FreeBSD Source Tinderbox</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/testing/#_the_index_cgi_script>6.3. The index.cgi Script</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/testing/#_official_build_servers>6.4. Official Build Servers</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/testing/#_official_summary_site>6.5. Official Summary Site</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/partii/>Part II. Interprocess Communication</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle>
<label class="icon cursor" for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/>Chapter 7. Sockets</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/#sockets-synopsis>7.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/#sockets-diversity>7.2. Networking and Diversity</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/#sockets-protocols>7.3. Protocols</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/#sockets-model>7.4. The Sockets Model</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/#sockets-essential-functions>7.5. Essential Socket Functions</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/#sockets-helper-functions>7.6. Helper Functions</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/sockets/#sockets-concurrent-servers>7.7. Concurrent Servers</a></li></ul></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/ipv6/>Chapter 8. IPv6 Internals</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec Implementation</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/partiii/>Part III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/kernelbuild/>Chapter 9. Building and Installing a FreeBSD Kernel</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Building the Faster but Brittle Way</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/>Chapter 10. Kernel Debugging</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code></a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-console>10.5. Debugging a Console Driver</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.6. Debugging Deadlocks</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-dcons>10.7. Kernel debugging with Dcons</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossary of Kernel Options for Debugging</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/partiv/>Part IV. Architectures</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle checked>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/>Chapter 11. x86 Assembly Language Programming</a><ul><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-intro>A.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-the-tools>A.2. The Tools</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-system-calls>A.3. System Calls</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-return-values>A.4. Return Values</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-portable-code>A.5. Creating Portable Code</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-first-program>A.6. Our First Program</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-unix-filters>A.7. Writing UNIX® Filters</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-buffered-io>A.8. Buffered Input and Output</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-command-line>A.9. Command Line Arguments</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-environment>A.10. UNIX® Environment</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-files>A.11. Working with Files</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-one-pointed-mind>A.12. One-Pointed Mind</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-fpu>A.13. Using the FPU</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-caveats>A.14. Caveats</a></li><li><a href=http://172.16.201.134:1313/en/books/developers-handbook/x86/#x86-acknowledgements>A.15. Acknowledgements</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/partv/>Part V. Appendices</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/developers-handbook/bibliography/>Bibliography</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapter 11. x86 Assembly Language Programming</h1><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#x86-intro>A.1. Synopsis</a></li><li><a href=#x86-the-tools>A.2. The Tools</a></li><li><a href=#x86-system-calls>A.3. System Calls</a></li><li><a href=#x86-return-values>A.4. Return Values</a></li><li><a href=#x86-portable-code>A.5. Creating Portable Code</a></li><li><a href=#x86-first-program>A.6. Our First Program</a></li><li><a href=#x86-unix-filters>A.7. Writing UNIX® Filters</a></li><li><a href=#x86-buffered-io>A.8. Buffered Input and Output</a></li><li><a href=#x86-command-line>A.9. Command Line Arguments</a></li><li><a href=#x86-environment>A.10. UNIX® Environment</a></li><li><a href=#x86-files>A.11. Working with Files</a></li><li><a href=#x86-one-pointed-mind>A.12. One-Pointed Mind</a></li><li><a href=#x86-fpu>A.13. Using the FPU</a></li><li><a href=#x86-caveats>A.14. Caveats</a></li><li><a href=#x86-acknowledgements>A.15. Acknowledgements</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class=paragraph><p><em>This chapter was written by G. Adam Stanislav &lt;<a href=mailto:adam@redprince.net>adam@redprince.net</a>>.</em></p></div></div></div><div class=sect1><h2 id=x86-intro>A.1. Synopsis<a class=anchor href=#x86-intro></a></h2><div class=sectionbody><div class=paragraph><p>Assembly language programming under UNIX® is highly undocumented.
It is generally assumed that no one would ever want to use it because various UNIX® systems run on different microprocessors, so everything should be written in C for portability.</p></div><div class=paragraph><p>In reality, C portability is quite a myth.
Even C programs need to be modified when ported from one UNIX® to another, regardless of what processor each runs on.
Typically, such a program is full of conditional statements depending on the system it is compiled for.</p></div><div class=paragraph><p>Even if we believe that all of UNIX® software should be written in C, or some other high-level language, we still need assembly language programmers: Who else would write the section of C library that accesses the kernel?</p></div><div class=paragraph><p>In this chapter I will attempt to show you how you can use assembly language writing UNIX® programs, specifically under FreeBSD.</p></div><div class=paragraph><p>This chapter does not explain the basics of assembly language.
There are enough resources about that (for a complete online course in assembly language, see Randall Hyde’s <a href=http://webster.cs.ucr.edu/>Art of Assembly Language</a>;
or if you prefer a printed book, take a look at Jeff Duntemann’s Assembly Language Step-by-Step (ISBN: 0471375233).
However, once the chapter is finished, any assembly language programmer will be able to write programs for FreeBSD quickly and efficiently.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. All rights reserved.</p></div></div></div><div class=sect1><h2 id=x86-the-tools>A.2. The Tools<a class=anchor href=#x86-the-tools></a></h2><div class=sectionbody><div class=sect2><h3 id=x86-the-assembler>A.2.1. The Assembler<a class=anchor href=#x86-the-assembler></a></h3><div class=paragraph><p>The most important tool for assembly language programming is the assembler, the software that converts assembly language code into machine language.</p></div><div class=paragraph><p>Three very different assemblers are available for FreeBSD.
Both <a href="https://man.freebsd.org/cgi/man.cgi?query=llvm-as&amp;sektion=1&amp;format=html">llvm-as(1)</a> (included in <a class=package href=https://cgit.freebsd.org/ports/tree/devel/llvm/>devel/llvm</a>) and <a href="https://man.freebsd.org/cgi/man.cgi?query=as&amp;sektion=1&amp;format=html">as(1)</a> (included in <a class=package href=https://cgit.freebsd.org/ports/tree/devel/binutils/>devel/binutils</a>) use the traditional UNIX® assembly language syntax.</p></div><div class=paragraph><p>On the other hand, <a href="https://man.freebsd.org/cgi/man.cgi?query=nasm&amp;sektion=1&amp;format=html">nasm(1)</a> (installed through <a class=package href=https://cgit.freebsd.org/ports/tree/devel/nasm/>devel/nasm</a>) uses the Intel syntax.
Its main advantage is that it can assemble code for many operating systems.</p></div><div class=paragraph><p>This chapter uses nasm syntax because most assembly language programmers coming to FreeBSD from other operating systems will find it easier to understand.
And, because, quite frankly, that is what I am used to.</p></div></div><div class=sect2><h3 id=x86-the-linker>A.2.2. The Linker<a class=anchor href=#x86-the-linker></a></h3><div class=paragraph><p>The output of the assembler, like that of any compiler, needs to be linked to form an executable file.</p></div><div class=paragraph><p>The standard <a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a> linker comes with FreeBSD.
It works with the code assembled with either assembler.</p></div></div></div></div><div class=sect1><h2 id=x86-system-calls>A.3. System Calls<a class=anchor href=#x86-system-calls></a></h2><div class=sectionbody><div class=sect2><h3 id=x86-default-calling-convention>A.3.1. Default Calling Convention<a class=anchor href=#x86-default-calling-convention></a></h3><div class=paragraph><p>By default, the FreeBSD kernel uses the C calling convention.
Further, although the kernel is accessed using <code>int 80h</code>, it is assumed the program will call a function that issues <code>int 80h</code>, rather than issuing <code>int 80h</code> directly.</p></div><div class=paragraph><p>This convention is very convenient, and quite superior to the Microsoft® convention used by MS-DOS®.
Why? Because the UNIX® convention allows any program written in any language to access the kernel.</p></div><div class=paragraph><p>An assembly language program can do that as well.
For example, we could open a file:</p></div><div class="literalblock programlisting"><div class=content><pre>kernel:
	int	80h	; Call kernel
	ret

open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	call	kernel
	add	esp, byte 12
	ret</pre></div></div><div class=paragraph><p>This is a very clean and portable way of coding.
If you need to port the code to a UNIX® system which uses a different interrupt, or a different way of passing parameters, all you need to change is the kernel procedure.</p></div><div class=paragraph><p>But assembly language programmers like to shave off cycles.
The above example requires a <code>call/ret</code> combination.
We can eliminate it by <code>push</code>ing an extra dword:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	push	eax		; Or any other dword
	int	80h
	add	esp, byte 16</pre></div></div><div class=paragraph><p>The <code>5</code> that we have placed in <code>EAX</code> identifies the kernel function, in this case <code>open</code>.</p></div></div><div class=sect2><h3 id=x86-alternate-calling-convention>A.3.2. Alternate Calling Convention<a class=anchor href=#x86-alternate-calling-convention></a></h3><div class=paragraph><p>FreeBSD is an extremely flexible system.
It offers other ways of calling the kernel.
For it to work, however, the system must have Linux emulation installed.</p></div><div class=paragraph><p>Linux is a UNIX® like system.
However, its kernel uses the same system-call convention of passing parameters in registers MS-DOS® does.
As with the UNIX® convention, the function number is placed in <code>EAX</code>.
The parameters, however, are not passed on the stack but in <code>EBX, ECX, EDX, ESI, EDI, EBP</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	mov	eax, 5
	mov	ebx, path
	mov	ecx, flags
	mov	edx, mode
	int	80h</pre></div></div><div class=paragraph><p>This convention has a great disadvantage over the UNIX® way, at least as far as assembly language programming is concerned:
Every time you make a kernel call you must <code>push</code> the registers, then <code>pop</code> them later.
This makes your code bulkier and slower.
Nevertheless, FreeBSD gives you a choice.</p></div><div class=paragraph><p>If you do choose the Linux convention, you must let the system know about it.
After your program is assembled and linked, you need to brand the executable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux filename</code></pre></div></div></div><div class=sect2><h3 id=x86-use-geneva>A.3.3. Which Convention Should You Use?<a class=anchor href=#x86-use-geneva></a></h3><div class=paragraph><p>If you are coding specifically for FreeBSD, you should always use the UNIX® convention:
It is faster, you can store global variables in registers, you do not have to brand the executable,
and you do not impose the installation of the Linux emulation package on the target system.</p></div><div class=paragraph><p>If you want to create portable code that can also run on Linux, you will probably still want to give the FreeBSD users as efficient a code as possible.
I will show you how you can accomplish that after I have explained the basics.</p></div></div><div class=sect2><h3 id=x86-call-numbers>A.3.4. Call Numbers<a class=anchor href=#x86-call-numbers></a></h3><div class=paragraph><p>To tell the kernel which system service you are calling, place its number in <code>EAX</code>.
Of course, you need to know what the number is.</p></div><div class=sect3><h4 id=x86-the-syscalls-file>A.3.4.1. The <span class=filename>syscalls</span> File<a class=anchor href=#x86-the-syscalls-file></a></h4><div class=paragraph><p>The numbers are listed in <span class=filename>syscalls</span>.
<code>locate syscalls</code> finds this file in several different formats, all produced automatically from <span class=filename>syscalls.master</span>.</p></div><div class=paragraph><p>You can find the master file for the default UNIX® calling convention in <span class=filename>/usr/src/sys/kern/syscalls.master</span>.
If you need to use the other convention implemented in the Linux emulation mode, read <span class=filename>/usr/src/sys/i386/linux/syscalls.master</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Not only do FreeBSD and Linux use different calling conventions, they sometimes use different numbers for the same functions.</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>syscalls.master</span> describes how the call is to be made:</p></div><div class="literalblock programlisting"><div class=content><pre>0	STD	NOHIDE	{ int nosys(void); } syscall nosys_args int
1	STD	NOHIDE	{ void exit(int rval); } exit rexit_args void
2	STD	POSIX	{ int fork(void); }
3	STD	POSIX	{ ssize_t read(int fd, void *buf, size_t nbyte); }
4	STD	POSIX	{ ssize_t write(int fd, const void *buf, size_t nbyte); }
5	STD	POSIX	{ int open(char *path, int flags, int mode); }
6	STD	POSIX	{ int close(int fd); }
etc...</pre></div></div><div class=paragraph><p>It is the leftmost column that tells us the number to place in <code>EAX</code>.</p></div><div class=paragraph><p>The rightmost column tells us what parameters to <code>push</code>.
They are <code>push</code>ed <em>from right to left</em>.</p></div><div class=paragraph><p>For example, to <code>open</code> a file, we need to <code>push</code> the <code>mode</code> first, then <code>flags</code>, then the address at which the <code>path</code> is stored.</p></div></div></div></div></div><div class=sect1><h2 id=x86-return-values>A.4. Return Values<a class=anchor href=#x86-return-values></a></h2><div class=sectionbody><div class=paragraph><p>A system call would not be useful most of the time if it did not return some kind of a value:
The file descriptor of an open file, the number of bytes read to a buffer, the system time, etc.</p></div><div class=paragraph><p>Additionally, the system needs to inform us if an error occurs:
A file does not exist, system resources are exhausted, we passed an invalid parameter, etc.</p></div><div class=sect2><h3 id=x86-man-pages>A.4.1. Man Pages<a class=anchor href=#x86-man-pages></a></h3><div class=paragraph><p>The traditional place to look for information about various system calls under UNIX® systems are the manual pages.
FreeBSD describes its system calls in section 2, sometimes in section 3.</p></div><div class=paragraph><p>For example, <a href="https://man.freebsd.org/cgi/man.cgi?query=open&amp;sektion=2&amp;format=html">open(2)</a> says:</p></div><div class="paragraph blockquote"><p>If successful, <code>open()</code> returns a non-negative integer, termed a file descriptor.
It returns <code>-1</code> on failure, and sets <code>errno</code> to indicate the error.</p></div><div class=paragraph><p>The assembly language programmer new to UNIX® and FreeBSD will immediately ask the puzzling question: Where is <code>errno</code> and how do I get to it?</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The information presented in the manual pages applies to C programs.
The assembly language programmer needs additional information.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-where-return-values>A.4.2. Where Are the Return Values?<a class=anchor href=#x86-where-return-values></a></h3><div class=paragraph><p>Unfortunately, it depends…​ For most system calls it is in <code>EAX</code>, but not for all.
A good rule of thumb, when working with a system call for the first time, is to look for the return value in <code>EAX</code>.
If it is not there, you need further research.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>I am aware of one system call that returns the value in <code>EDX</code>: <code>SYS_fork</code>.
All others I have worked with use <code>EAX</code>.
But I have not worked with them all yet.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If you cannot find the answer here or anywhere else, study libc source code and see how it interfaces with the kernel.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-where-errno>A.4.3. Where Is <code>errno</code>?<a class=anchor href=#x86-where-errno></a></h3><div class=paragraph><p>Actually, nowhere…​</p></div><div class=paragraph><p><code>errno</code> is part of the C language, not the UNIX® kernel.
When accessing kernel services directly, the error code is returned in <code>EAX</code>, the same register the proper return value generally ends up in.</p></div><div class=paragraph><p>This makes perfect sense. If there is no error, there is no error code.
If there is an error, there is no return value.
One register can contain either.</p></div></div><div class=sect2><h3 id=x86-how-to-know-error>A.4.4. Determining an Error Occurred<a class=anchor href=#x86-how-to-know-error></a></h3><div class=paragraph><p>When using the standard FreeBSD calling convention, the <code>carry flag</code> is cleared upon success, set upon failure.</p></div><div class=paragraph><p>When using the Linux emulation mode, the signed value in <code>EAX</code> is non-negative upon success, and contains the return value.
In case of an error, the value is negative, i.e., <code>-errno</code>.</p></div></div></div></div><div class=sect1><h2 id=x86-portable-code>A.5. Creating Portable Code<a class=anchor href=#x86-portable-code></a></h2><div class=sectionbody><div class=paragraph><p>Portability is generally not one of the strengths of assembly language.
Yet, writing assembly language programs for different platforms is possible, especially with nasm.
I have written assembly language libraries that can be assembled for such different operating systems as Windows® and FreeBSD.</p></div><div class=paragraph><p>It is all the more possible when you want your code to run on two platforms which, while different, are based on similar architectures.</p></div><div class=paragraph><p>For example, FreeBSD is UNIX®, Linux is UNIX® like.
I only mentioned three differences between them (from an assembly language programmer’s perspective):
The calling convention, the function numbers, and the way of returning values.</p></div><div class=sect2><h3 id=x86-deal-with-function-numbers>A.5.1. Dealing with Function Numbers<a class=anchor href=#x86-deal-with-function-numbers></a></h3><div class=paragraph><p>In many cases the function numbers are the same.
However, even when they are not, the problem is easy to deal with:
Instead of using numbers in your code, use constants which you have declared differently depending on the target architecture:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX
%define	SYS_execve	11
%else
%define	SYS_execve	59
%endif</pre></div></div></div><div class=sect2><h3 id=x86-deal-with-geneva>A.5.2. Dealing with Conventions<a class=anchor href=#x86-deal-with-geneva></a></h3><div class=paragraph><p>Both, the calling convention, and the return value (the <code>errno</code> problem) can be resolved with macros:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX

%macro	system	0
	call	kernel
%endmacro

align 4
kernel:
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp

	mov	ebx, [esp+32]
	mov	ecx, [esp+36]
	mov	edx, [esp+40]
	mov	esi, [esp+44]
	mov	ebp, [esp+48]
	int	80h

	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx

	or	eax, eax
	js	.errno
	clc
	ret

.errno:
	neg	eax
	stc
	ret

%else

%macro	system	0
	int	80h
%endmacro

%endif</pre></div></div></div><div class=sect2><h3 id=x86-deal-with-other-portability>A.5.3. Dealing with Other Portability Issues<a class=anchor href=#x86-deal-with-other-portability></a></h3><div class=paragraph><p>The above solutions can handle most cases of writing code portable between FreeBSD and Linux.
Nevertheless, with some kernel services the differences are deeper.</p></div><div class=paragraph><p>In that case, you need to write two different handlers for those particular system calls, and use conditional assembly.
Luckily, most of your code does something other than calling the kernel, so usually you will only need a few such conditional sections in your code.</p></div></div><div class=sect2><h3 id=x86-portable-library>A.5.4. Using a Library<a class=anchor href=#x86-portable-library></a></h3><div class=paragraph><p>You can avoid portability issues in your main code altogether by writing a library of system calls.
Create a separate library for FreeBSD, a different one for Linux, and yet other libraries for more operating systems.</p></div><div class=paragraph><p>In your library, write a separate function (or procedure, if you prefer the traditional assembly language terminology) for each system call.
Use the C calling convention of passing parameters.
But still use <code>EAX</code> to pass the call number in.
In that case, your FreeBSD library can be very simple, as many seemingly different functions can be just labels to the same code:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.open:
sys.close:
[etc...]
	int	80h
	ret</pre></div></div><div class=paragraph><p>Your Linux library will require more different functions.
But even here you can group system calls using the same number of parameters:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.exit:
sys.close:
[etc... one-parameter functions]
	push	ebx
	mov	ebx, [esp+12]
	int	80h
	pop	ebx
	jmp	sys.return

...

sys.return:
	or	eax, eax
	js	sys.err
	clc
	ret

sys.err:
	neg	eax
	stc
	ret</pre></div></div><div class=paragraph><p>The library approach may seem inconvenient at first because it requires you to produce a separate file your code depends on.
But it has many advantages: For one, you only need to write it once and can use it for all your programs.
You can even let other assembly language programmers use it, or perhaps use one written by someone else.
But perhaps the greatest advantage of the library is that your code can be ported to other systems,
even by other programmers, by simply writing a new library without any changes to your code.</p></div><div class=paragraph><p>If you do not like the idea of having a library, you can at least place all your system calls in a separate assembly language file and link it with your main program. Here, again, all porters have to do is create a new object file to link with your main program.</p></div></div><div class=sect2><h3 id=x86-portable-include>A.5.5. Using an Include File<a class=anchor href=#x86-portable-include></a></h3><div class=paragraph><p>If you are releasing your software as (or with) source code, you can use macros and place them in a separate file, which you include in your code.</p></div><div class=paragraph><p>Porters of your software will simply write a new include file.
No library or external object file is necessary, yet your code is portable without any need to edit the code.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This is the approach we will use throughout this chapter.
We will name our include file <span class=filename>system.inc</span>, and add to it whenever we deal with a new system call.</p></div></td></tr></tbody></table></div><div class=paragraph><p>We can start our <span class=filename>system.inc</span> by declaring the standard file descriptors:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	stdin	0
%define	stdout	1
%define	stderr	2</pre></div></div><div class=paragraph><p>Next, we create a symbolic name for each system call:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_nosys	0
%define	SYS_exit	1
%define	SYS_fork	2
%define	SYS_read	3
%define	SYS_write	4
; [etc...]</pre></div></div><div class=paragraph><p>We add a short, non-global procedure with a long name, so we do not accidentally reuse the name in our code:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.text
align 4
access.the.bsd.kernel:
	int	80h
	ret</pre></div></div><div class=paragraph><p>We create a macro which takes one argument, the syscall number:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	system	1
	mov	eax, %1
	call	access.the.bsd.kernel
%endmacro</pre></div></div><div class=paragraph><p>Finally, we create macros for each syscall.
These macros take no arguments.</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.exit	0
	system	SYS_exit
%endmacro

%macro	sys.fork	0
	system	SYS_fork
%endmacro

%macro	sys.read	0
	system	SYS_read
%endmacro

%macro	sys.write	0
	system	SYS_write
%endmacro

; [etc...]</pre></div></div><div class=paragraph><p>Go ahead, enter it into your editor and save it as <span class=filename>system.inc</span>.
We will add more to it as we discuss more syscalls.</p></div></div></div></div><div class=sect1><h2 id=x86-first-program>A.6. Our First Program<a class=anchor href=#x86-first-program></a></h2><div class=sectionbody><div class=paragraph><p>We are now ready for our first program, the mandatory Hello, World!</p></div><div class="literalblock programlisting"><div class=content><pre>	%include	&#39;system.inc&#39;

	section	.data
	hello	db	&#39;Hello, World!&#39;, 0Ah
	hbytes	equ	$-hello

	section	.text
	global	_start
_start:
	push	dword hbytes
	push	dword hello
	push	dword stdout
	sys.write

	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>Here is what it does: Line 1 includes the defines, the macros, and the code from <span class=filename>system.inc</span>.</p></div><div class=paragraph><p>Lines 3-5 are the data: Line 3 starts the data section/segment.
Line 4 contains the string "Hello, World!" followed by a new line (<code>0Ah</code>).
Line 5 creates a constant that contains the length of the string from line 4 in bytes.</p></div><div class=paragraph><p>Lines 7-16 contain the code.
Note that FreeBSD uses the <em>elf</em> file format for its executables, which requires every program to start at the point labeled <code>_start</code> (or, more precisely, the linker expects that).
This label has to be global.</p></div><div class=paragraph><p>Lines 10-13 ask the system to write <code>hbytes</code> bytes of the <code>hello</code> string to <code>stdout</code>.</p></div><div class=paragraph><p>Lines 15-16 ask the system to end the program with the return value of <code>0</code>.
The <code>SYS_exit</code> syscall never returns, so the code ends there.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you have come to UNIX® from MS-DOS® assembly language background, you may be used to writing directly to the video hardware.
You will never have to worry about this in FreeBSD, or any other flavor of UNIX®.
As far as you are concerned, you are writing to a file known as <span class=filename>stdout</span>.
This can be the video screen, or a telnet terminal, or an actual file, or even the input of another program.
Which one it is, is for the system to figure out.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=x86-assemble-1>A.6.1. Assembling the Code<a class=anchor href=#x86-assemble-1></a></h3><div class=paragraph><p>Type the code in an editor, and save it in a file named <span class=filename>hello.asm</span>.
You need nasm to assemble it.</p></div><div class=sect3><h4 id=x86-get-nasm>A.6.1.1. Installing nasm<a class=anchor href=#x86-get-nasm></a></h4><div class=paragraph><p>If you do not have nasm, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:your root password
<span class=c># cd /usr/ports/devel/nasm</span>
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div><div class=paragraph><p>You may type <code>make install clean</code> instead of just <code>make install</code> if you do not want to keep nasm source code.</p></div><div class=paragraph><p>Either way, FreeBSD will automatically download nasm from the Internet, compile it, and install it on your system.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If your system is not FreeBSD, you need to get nasm from its <a href=https://sourceforge.net/projects/nasm>home page</a>.
You can still use it to assemble FreeBSD code.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Now you can assemble, link, and run the code:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hello.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hello hello.o
% ./hello
Hello, World!
%</code></pre></div></div></div></div></div></div><div class=sect1><h2 id=x86-unix-filters>A.7. Writing UNIX® Filters<a class=anchor href=#x86-unix-filters></a></h2><div class=sectionbody><div class=paragraph><p>A common type of UNIX® application is a filter-a program that reads data from the <span class=filename>stdin</span>, processes it somehow, then writes the result to <span class=filename>stdout</span>.</p></div><div class=paragraph><p>In this chapter, we shall develop a simple filter, and learn how to read from <span class=filename>stdin</span> and write to <span class=filename>stdout</span>.
This filter will convert each byte of its input into a hexadecimal number followed by a blank space.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short _start

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>In the data section we create an array called <code>hex</code>.
It contains the 16 hexadecimal digits in ascending order.
The array is followed by a buffer which we will use for both input and output.
The first two bytes of the buffer are initially set to <code>0</code>.
This is where we will write the two hexadecimal digits (the first byte also is where we will read the input).
The third byte is a space.</p></div><div class=paragraph><p>The code section consists of four parts: Reading the byte, converting it to a hexadecimal number, writing the result, and eventually exiting the program.</p></div><div class=paragraph><p>To read the byte, we ask the system to read one byte from <span class=filename>stdin</span>, and store it in the first byte of the <code>buffer</code>.
The system returns the number of bytes read in <code>EAX</code>.
This will be <code>1</code> while data is coming, or <code>0</code>, when no more input data is available.
Therefore, we check the value of <code>EAX</code>.
If it is <code>0</code>, we jump to <code>.done</code>, otherwise we continue.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For simplicity sake, we are ignoring the possibility of an error condition at this time.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The hexadecimal conversion reads the byte from the <code>buffer</code> into <code>EAX</code>, or actually just <code>AL</code>, while clearing the remaining bits of <code>EAX</code> to zeros.
We also copy the byte to <code>EDX</code> because we need to convert the upper four bits (nibble) separately from the lower four bits.
We store the result in the first two bytes of the buffer.</p></div><div class=paragraph><p>Next, we ask the system to write the three bytes of the buffer, i.e., the two hexadecimal digits and the blank space, to <span class=filename>stdout</span>.
We then jump back to the beginning of the program and process the next byte.</p></div><div class=paragraph><p>Once there is no more input left, we ask the system to exit our program, returning a zero, which is the traditional value meaning the program was successful.</p></div><div class=paragraph><p>Go ahead, and save the code in a file named <span class=filename>hex.asm</span>, then type the following (the <code>^D</code> means press the control key and type <code>D</code> while holding the control key down):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A ^D %</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you are migrating to UNIX® from MS-DOS®, you may be wondering why each line ends with <code>0A</code> instead of <code>0D 0A</code>.
This is because UNIX® does not use the cr/lf convention, but a "new line" convention, which is <code>0A</code> in hexadecimal.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Can we improve this? Well, for one, it is a bit confusing because once we have converted a line of text,
our input no longer starts at the beginning of the line.
We can modify it to print a new line instead of a space after each <code>0A</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	mov	cl, &#39; &#39;

.loop:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	[buffer+2], cl
	cmp	al, 0Ah
	jne	.hex
	mov	[buffer+2], al

.hex:
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short .loop

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>We have stored the space in the <code>CL</code> register.
We can do this safely because, unlike Microsoft® Windows®, UNIX® system calls do not modify the value of any register they do not use to return a value in.</p></div><div class=paragraph><p>That means we only need to set <code>CL</code> once.
We have, therefore, added a new label <code>.loop</code> and jump to it for the next byte instead of jumping at <code>_start</code>.
We have also added the <code>.hex</code> label so we can either have a blank space or a new line as the third byte of the <code>buffer</code>.</p></div><div class=paragraph><p>Once you have changed <span class=filename>hex.asm</span> to reflect these changes, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>That looks better.
But this code is quite inefficient! We are making a system call for every single byte twice (once to read it, another time to write the output).</p></div></div></div><div class=sect1><h2 id=x86-buffered-io>A.8. Buffered Input and Output<a class=anchor href=#x86-buffered-io></a></h2><div class=sectionbody><div class=paragraph><p>We can improve the efficiency of our code by buffering our input and output.
We create an input buffer and read a whole sequence of bytes at one time.
Then we fetch them one by one from the buffer.</p></div><div class=paragraph><p>We also create an output buffer. We store our output in it until it is full.
At that time we ask the kernel to write the contents of the buffer to <span class=filename>stdout</span>.</p></div><div class=paragraph><p>The program ends when there is no more input.
But we still need to ask the kernel to write the contents of our output buffer to <span class=filename>stdout</span> one last time, otherwise some of our output would make it to the output buffer, but never be sent out.
Do not forget that, or you will be wondering why some of your output is missing.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>We now have a third section in the source code, named <code>.bss</code>.
This section is not included in our executable file, and, therefore, cannot be initialized.
We use <code>resb</code> instead of <code>db</code>.
It simply reserves the requested size of uninitialized memory for our use.</p></div><div class=paragraph><p>We take advantage of the fact that the system does not modify the registers:
We use registers for what, otherwise, would have to be global variables stored in the <code>.data</code> section.
This is also why the UNIX® convention of passing parameters to system calls on the stack is superior to the Microsoft convention of passing them in the registers: We can keep the registers for our own use.</p></div><div class=paragraph><p>We use <code>EDI</code> and <code>ESI</code> as pointers to the next byte to be read from or written to.
We use <code>EBX</code> and <code>ECX</code> to keep count of the number of bytes in the two buffers,
so we know when to dump the output to, or read more input from, the system.</p></div><div class=paragraph><p>Let us see how it works now:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
Here I come!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Not what you expected? The program did not print the output until we pressed <code>^D</code>.
That is easy to fix by inserting three lines of code to write the output every time we have converted a new line to <code>0A</code>.
I have marked the three lines with > (do not copy the > in your <span class=filename>hex.asm</span>).</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
&gt;	cmp	al, 0Ah
&gt;	jne	.loop
&gt;	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>Now, let us see how it works:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Not bad for a 644-byte executable, is it!</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This approach to buffered input/output still contains a hidden danger.
I will discuss-and fix-it later, when I talk about the <a href=../x86/#x86-buffered-dark-side>dark side of buffering</a>.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=x86-ungetc>A.8.1. How to Unread a Character<a class=anchor href=#x86-ungetc></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>This may be a somewhat advanced topic, mostly of interest to programmers familiar with the theory of compilers.
If you wish, you may <a href=../x86/#x86-command-line>skip to the next section</a>, and perhaps read this later.</p></div></td></tr></tbody></table></div><div class=paragraph><p>While our sample program does not require it, more sophisticated filters often need to look ahead.
In other words, they may need to see what the next character is (or even several characters).
If the next character is of a certain value, it is part of the token currently being processed.
Otherwise, it is not.</p></div><div class=paragraph><p>For example, you may be parsing the input stream for a textual string (e.g., when implementing a language compiler):
If a character is followed by another character, or perhaps a digit, it is part of the token you are processing.
If it is followed by white space, or some other value, then it is not part of the current token.</p></div><div class=paragraph><p>This presents an interesting problem: How to return the next character back to the input stream, so it can be read again later?</p></div><div class=paragraph><p>One possible solution is to store it in a character variable, then set a flag.
We can modify <code>getchar</code> to check the flag, and if it is set, fetch the byte from that variable instead of the input buffer, and reset the flag.
But, of course, that slows us down.</p></div><div class=paragraph><p>The C language has an <code>ungetc()</code> function, just for that purpose.
Is there a quick way to implement it in our code?
I would like you to scroll back up and take a look at the <code>getchar</code> procedure and see if you can find a nice and fast solution before reading the next paragraph.
Then come back here and see my own solution.</p></div><div class=paragraph><p>The key to returning a character back to the stream is in how we are getting the characters to start with:</p></div><div class=paragraph><p>First we check if the buffer is empty by testing the value of <code>EBX</code>.
If it is zero, we call the <code>read</code> procedure.</p></div><div class=paragraph><p>If we do have a character available, we use <code>lodsb</code>, then decrease the value of <code>EBX</code>.
The <code>lodsb</code> instruction is effectively identical to:</p></div><div class="literalblock programlisting"><div class=content><pre>mov	al, [esi]
	inc	esi</pre></div></div><div class=paragraph><p>The byte we have fetched remains in the buffer until the next time <code>read</code> is called.
We do not know when that happens, but we do know it will not happen until the next call to <code>getchar</code>.
Hence, to "return" the last-read byte back to the stream, all we have to do is decrease the value of <code>ESI</code> and increase the value of <code>EBX</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	dec	esi
	inc	ebx
	ret</pre></div></div><div class=paragraph><p>But, be careful! We are perfectly safe doing this if our look-ahead is at most one character at a time.
If we are examining more than one upcoming character and call <code>ungetc</code> several times in a row, it will work most of the time, but not all the time (and will be tough to debug). Why?</p></div><div class=paragraph><p>Because as long as <code>getchar</code> does not have to call <code>read</code>, all of the pre-read bytes are still in the buffer, and our <code>ungetc</code> works without a glitch.
But the moment <code>getchar</code> calls <code>read</code>, the contents of the buffer change.</p></div><div class=paragraph><p>We can always rely on <code>ungetc</code> working properly on the last character we have read with <code>getchar</code>, but not on anything we have read before that.</p></div><div class=paragraph><p>If your program reads more than one byte ahead, you have at least two choices:</p></div><div class=paragraph><p>If possible, modify the program so it only reads one byte ahead.
This is the simplest solution.</p></div><div class=paragraph><p>If that option is not available, first of all determine the maximum number of characters your program needs to return to the input stream at one time.
Increase that number slightly, just to be sure, preferably to a multiple of 16-so it aligns nicely.
Then modify the <code>.bss</code> section of your code, and create a small "spare" buffer right before your input buffer, something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.bss
	resb	16	; or whatever the value you came up with
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE</pre></div></div><div class=paragraph><p>You also need to modify your <code>ungetc</code> to pass the value of the byte to unget in <code>AL</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	dec	esi
	inc	ebx
	mov	[esi], al
	ret</pre></div></div><div class=paragraph><p>With this modification, you can call <code>ungetc</code> up to 17 times in a row safely (the first call will still be within the buffer, the remaining 16 may be either within the buffer or within the "spare").</p></div></div></div></div><div class=sect1><h2 id=x86-command-line>A.9. Command Line Arguments<a class=anchor href=#x86-command-line></a></h2><div class=sectionbody><div class=paragraph><p>Our hex program will be more useful if it can read the names of an input and output file from its command line, i.e., if it can process the command line arguments.
But…​ Where are they?</p></div><div class=paragraph><p>Before a UNIX® system starts a program, it <code>push</code>es some data on the stack, then jumps at the <code>_start</code> label of the program.
Yes, I said jumps, not calls.
That means the data can be accessed by reading <code>[esp+offset]</code>, or by simply <code>pop</code>ping it.</p></div><div class=paragraph><p>The value at the top of the stack contains the number of command line arguments.
It is traditionally called <code>argc</code>, for "argument count."</p></div><div class=paragraph><p>Command line arguments follow next, all <code>argc</code> of them.
These are typically referred to as <code>argv</code>, for "argument value(s)." That is, we get <code>argv[0]</code>, <code>argv[1]</code>, <code>…​</code>, <code>argv[argc-1]</code>.
These are not the actual arguments, but pointers to arguments, i.e., memory addresses of the actual arguments.
The arguments themselves are NUL-terminated character strings.</p></div><div class=paragraph><p>The <code>argv</code> list is followed by a NULL pointer, which is simply a <code>0</code>. There is more, but this is enough for our purposes right now.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you have come from the MS-DOS® programming environment, the main difference is that each argument is in a separate string.
The second difference is that there is no practical limit on how many arguments there can be.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Armed with this knowledge, we are almost ready for the next version of <span class=filename>hex.asm</span>.
First, however, we need to add a few lines to <span class=filename>system.inc</span>:</p></div><div class=paragraph><p>First, we need to add two new entries to our list of system call numbers:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_open	5
%define	SYS_close	6</pre></div></div><div class=paragraph><p>Then we add two new macros at the end of the file:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.open	0
	system	SYS_open
%endmacro

%macro	sys.close	0
	system	SYS_close
%endmacro</pre></div></div><div class=paragraph><p>Here, then, is our modified source code:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
err:
	push	dword 1		; return failure
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to input file
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	err		; open failed

	add	esp, byte 8
	mov	[fd.in], eax

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to output file
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	err

	add	esp, byte 12
	mov	[fd.out], eax

.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from input file or stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	cmp	al, dl
	jne	.loop
	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>In our <code>.data</code> section we now have two new variables, <code>fd.in</code> and <code>fd.out</code>.
We store the input and output file descriptors here.</p></div><div class=paragraph><p>In the <code>.text</code> section we have replaced the references to <code>stdin</code> and <code>stdout</code> with <code>[fd.in]</code> and <code>[fd.out]</code>.</p></div><div class=paragraph><p>The <code>.text</code> section now starts with a simple error handler, which does nothing but exit the program with a return value of <code>1</code>.
The error handler is before <code>_start</code> so we are within a short distance from where the errors occur.</p></div><div class=paragraph><p>Naturally, the program execution still begins at <code>_start</code>.
First, we remove <code>argc</code> and <code>argv[0]</code> from the stack: They are of no interest to us (in this program, that is).</p></div><div class=paragraph><p>We pop <code>argv[1]</code> to <code>ECX</code>.
This register is particularly suited for pointers, as we can handle NULL pointers with <code>jecxz</code>.
If <code>argv[1]</code> is not NULL, we try to open the file named in the first argument.
Otherwise, we continue the program as before: Reading from <code>stdin</code>, writing to <code>stdout</code>.
If we fail to open the input file (e.g., it does not exist), we jump to the error handler and quit.</p></div><div class=paragraph><p>If all went well, we now check for the second argument.
If it is there, we open the output file.
Otherwise, we send the output to <code>stdout</code>.
If we fail to open the output file (e.g., it exists and we do not have the write permission), we, again, jump to the error handler.</p></div><div class=paragraph><p>The rest of the code is the same as before, except we close the input and output files before exiting, and, as mentioned, we use <code>[fd.in]</code> and <code>[fd.out]</code>.</p></div><div class=paragraph><p>Our executable is now a whopping 768 bytes long.</p></div><div class=paragraph><p>Can we still improve it? Of course! Every program can be improved.
Here are a few ideas of what we could do:</p></div><div class=ulist><ul><li><p>Have our error handler print a message to <code>stderr</code>.</p></li><li><p>Add error handlers to the <code>read</code> and <code>write</code> functions.</p></li><li><p>Close <code>stdin</code> when we open an input file, <code>stdout</code> when we open an output file.</p></li><li><p>Add command line switches, such as <code>-i</code> and <code>-o</code>, so we can list the input and output files in any order, or perhaps read from <code>stdin</code> and write to a file.</p></li><li><p>Print a usage message if command line arguments are incorrect.</p></li></ul></div><div class=paragraph><p>I shall leave these enhancements as an exercise to the reader: You already know everything you need to know to implement them.</p></div></div></div><div class=sect1><h2 id=x86-environment>A.10. UNIX® Environment<a class=anchor href=#x86-environment></a></h2><div class=sectionbody><div class=paragraph><p>An important UNIX® concept is the environment, which is defined by <em>environment variables</em>.
Some are set by the system, others by you, yet others by the shell, or any program that loads another program.</p></div><div class=sect2><h3 id=x86-find-environment>A.10.1. How to Find Environment Variables<a class=anchor href=#x86-find-environment></a></h3><div class=paragraph><p>I said earlier that when a program starts executing, the stack contains <code>argc</code> followed by the NULL-terminated <code>argv</code> array, followed by something else.
The "something else" is the <em>environment</em>, or, to be more precise, a NULL-terminated array of pointers to <em>environment variables</em>.
This is often referred to as <code>env</code>.</p></div><div class=paragraph><p>The structure of <code>env</code> is the same as that of <code>argv</code>, a list of memory addresses followed by a NULL (<code>0</code>).
In this case, there is no <code>"envc"</code>-we figure out where the array ends by searching for the final NULL.</p></div><div class=paragraph><p>The variables usually come in the <code>name=value</code> format, but sometimes the <code>=value</code> part may be missing.
We need to account for that possibility.</p></div></div><div class=sect2><h3 id=x86-webvar>A.10.2. webvars<a class=anchor href=#x86-webvar></a></h3><div class=paragraph><p>I could just show you some code that prints the environment the same way the UNIX® env command does.
But I thought it would be more interesting to write a simple assembly language CGI utility.</p></div><div class=sect3><h4 id=x86-cgi>A.10.2.1. CGI: a Quick Overview<a class=anchor href=#x86-cgi></a></h4><div class=paragraph><p>I have a <a href=http://www.whizkidtech.redprince.net/cgi-bin/tutorial>detailed CGI tutorial</a> on my web site, but here is a very quick overview of CGI:</p></div><div class=ulist><ul><li><p>The web server communicates with the CGI program by setting <em>environment variables</em>.</p></li><li><p>The CGI program sends its output to <span class=filename>stdout</span>. The web server reads it from there.</p></li><li><p>It must start with an HTTP header followed by two blank lines.</p></li><li><p>It then prints the HTML code, or whatever other type of data it is producing.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While certain <em>environment variables</em> use standard names, others vary, depending on the web server.
That makes webvars quite a useful diagnostic tool.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-webvars-the-code>A.10.2.2. The Code<a class=anchor href=#x86-webvars-the-code></a></h4><div class=paragraph><p>Our webvars program, then, must send out the HTTP header followed by some HTML mark-up.
It then must read the <em>environment variables</em> one by one and send them out as part of the HTML page.</p></div><div class=paragraph><p>The code follows.
I placed comments and explanations right inside the code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; webvars.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2000 G. Adam Stanislav
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
; SUCH DAMAGE.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Version 1.0
;
; Started:	 8-Dec-2000
; Updated:	 8-Dec-2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
http	db	&#39;Content-type: text/html&#39;, 0Ah, 0Ah
	db	&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;&#39;, 0Ah
	db	&#39;&lt;!DOCTYPE html PUBLIC &#34;-//W3C/DTD XHTML Strict//EN&#34; &#39;
	db	&#39;&#34;DTD/xhtml1-strict.dtd&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;html xmlns=&#34;http://www.w3.org/1999/xhtml&#34; &#39;
	db	&#39;xml.lang=&#34;en&#34; lang=&#34;en&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;head&gt;&#39;, 0Ah
	db	&#39;&lt;title&gt;Web Environment&lt;/title&gt;&#39;, 0Ah
	db	&#39;&lt;meta name=&#34;author&#34; content=&#34;G. Adam Stanislav&#34; /&gt;&#39;, 0Ah
	db	&#39;&lt;/head&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;body bgcolor=&#34;#ffffff&#34; text=&#34;#000000&#34; link=&#34;#0000ff&#34; &#39;
	db	&#39;vlink=&#34;#840084&#34; alink=&#34;#0000ff&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;div class=&#34;webvars&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;h1&gt;Web Environment&lt;/h1&gt;&#39;, 0Ah
	db	&#39;&lt;p&gt;The following &lt;b&gt;environment variables&lt;/b&gt; are defined &#39;
	db	&#39;on this web server:&lt;/p&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;table align=&#34;center&#34; width=&#34;80&#34; border=&#34;0&#34; cellpadding=&#34;10&#34; &#39;
	db	&#39;cellspacing=&#34;0&#34; class=&#34;webvars&#34;&gt;&#39;, 0Ah
httplen	equ	$-http
left	db	&#39;&lt;tr&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;name&#34;&gt;&lt;tt&gt;&#39;
leftlen	equ	$-left
middle	db	&#39;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;value&#34;&gt;&lt;tt&gt;&lt;b&gt;&#39;
midlen	equ	$-middle
undef	db	&#39;&lt;i&gt;(undefined)&lt;/i&gt;&#39;
undeflen	equ	$-undef
right	db	&#39;&lt;/b&gt;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;/tr&gt;&#39;, 0Ah
rightlen	equ	$-right
wrap	db	&#39;&lt;/table&gt;&#39;, 0Ah
	db	&#39;&lt;/div&gt;&#39;, 0Ah
	db	&#39;&lt;/body&gt;&#39;, 0Ah
	db	&#39;&lt;/html&gt;&#39;, 0Ah, 0Ah
wraplen	equ	$-wrap

section	.text
global	_start
_start:
	; First, send out all the http and xhtml stuff that is
	; needed before we start showing the environment
	push	dword httplen
	push	dword http
	push	dword stdout
	sys.write

	; Now find how far on the stack the environment pointers
	; are. We have 12 bytes we have pushed before &#34;argc&#34;
	mov	eax, [esp+12]

	; We need to remove the following from the stack:
	;
	;	The 12 bytes we pushed for sys.write
	;	The  4 bytes of argc
	;	The EAX*4 bytes of argv
	;	The  4 bytes of the NULL after argv
	;
	; Total:
	;	20 + eax * 4
	;
	; Because stack grows down, we need to ADD that many bytes
	; to ESP.
	lea	esp, [esp+20+eax*4]
	cld		; This should already be the case, but let&#39;s be sure.

	; Loop through the environment, printing it out
.loop:
	pop	edi
	or	edi, edi	; Done yet?
	je	near .wrap

	; Print the left part of HTML
	push	dword leftlen
	push	dword left
	push	dword stdout
	sys.write

	; It may be tempting to search for the &#39;=&#39; in the env string next.
	; But it is possible there is no &#39;=&#39;, so we search for the
	; terminating NUL first.
	mov	esi, edi	; Save start of string
	sub	ecx, ecx
	not	ecx		; ECX = FFFFFFFF
	sub	eax, eax
repne	scasb
	not	ecx		; ECX = string length + 1
	mov	ebx, ecx	; Save it in EBX

	; Now is the time to find &#39;=&#39;
	mov	edi, esi	; Start of string
	mov	al, &#39;=&#39;
repne	scasb
	not	ecx
	add	ecx, ebx	; Length of name

	push	ecx
	push	esi
	push	dword stdout
	sys.write

	; Print the middle part of HTML table code
	push	dword midlen
	push	dword middle
	push	dword stdout
	sys.write

	; Find the length of the value
	not	ecx
	lea	ebx, [ebx+ecx-1]

	; Print &#34;undefined&#34; if 0
	or	ebx, ebx
	jne	.value

	mov	ebx, undeflen
	mov	edi, undef

.value:
	push	ebx
	push	edi
	push	dword stdout
	sys.write

	; Print the right part of the table row
	push	dword rightlen
	push	dword right
	push	dword stdout
	sys.write

	; Get rid of the 60 bytes we have pushed
	add	esp, byte 60

	; Get the next variable
	jmp	.loop

.wrap:
	; Print the rest of HTML
	push	dword wraplen
	push	dword wrap
	push	dword stdout
	sys.write

	; Return success
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>This code produces a 1,396-byte executable.
Most of it is data, i.e., the HTML mark-up we need to send out.</p></div><div class=paragraph><p>Assemble and link it as usual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf webvars.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> webvars webvars.o</code></pre></div></div><div class=paragraph><p>To use it, you need to upload <span class=filename>webvars</span> to your web server.
Depending on how your web server is set up, you may have to store it in a special <span class=filename>cgi-bin</span> directory, or perhaps rename it with a <span class=filename>.cgi</span> extension.</p></div><div class=paragraph><p>Then you need to use your browser to view its output.
To see its output on my web server, please go to <a href=http://www.int80h.org/webvars/>http://www.int80h.org/webvars/</a>.
If curious about the additional environment variables present in a password protected web directory, go to <a href=http://www.int80h.org/private/>http://www.int80h.org/private/</a>, using the name <code>asm</code> and password <code>programmer</code>.</p></div></div></div></div></div><div class=sect1><h2 id=x86-files>A.11. Working with Files<a class=anchor href=#x86-files></a></h2><div class=sectionbody><div class=paragraph><p>We have already done some basic file work: We know how to open and close them, how to read and write them using buffers.
But UNIX® offers much more functionality when it comes to files.
We will examine some of it in this section, and end up with a nice file conversion utility.</p></div><div class=paragraph><p>Indeed, let us start at the end, that is, with the file conversion utility.
It always makes programming easier when we know from the start what the end product is supposed to do.</p></div><div class=paragraph><p>One of the first programs I wrote for UNIX® was <a href=ftp://ftp.int80h.org/unix/tuc/>tuc</a>, a text-to-UNIX® file converter.
It converts a text file from other operating systems to a UNIX® text file.
In other words, it changes from different kind of line endings to the newline convention of UNIX®.
It saves the output in a different file.
Optionally, it converts a UNIX® text file to a DOS text file.</p></div><div class=paragraph><p>I have used tuc extensively, but always only to convert from some other OS to UNIX®, never the other way.
I have always wished it would just overwrite the file instead of me having to send the output to a different file.
Most of the time, I end up using it like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% tuc myfile tempfile
% <span class=nb>mv </span>tempfile myfile</code></pre></div></div><div class=paragraph><p>It would be nice to have a ftuc, i.e., <em>fast tuc</em>, and use it like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftuc myfile</code></pre></div></div><div class=paragraph><p>In this chapter, then, we will write ftuc in assembly language (the original tuc is in C), and study various file-oriented kernel services in the process.</p></div><div class=paragraph><p>At first sight, such a file conversion is very simple: All you have to do is strip the carriage returns, right?</p></div><div class=paragraph><p>If you answered yes, think again: That approach will work most of the time (at least with MS DOS text files), but will fail occasionally.</p></div><div class=paragraph><p>The problem is that not all non UNIX® text files end their line with the carriage return / line feed sequence.
Some use carriage returns without line feeds.
Others combine several blank lines into a single carriage return followed by several line feeds.
And so on.</p></div><div class=paragraph><p>A text file converter, then, must be able to handle any possible line endings:</p></div><div class=ulist><ul><li><p>carriage return / line feed</p></li><li><p>carriage return</p></li><li><p>line feed / carriage return</p></li><li><p>line feed</p></li></ul></div><div class=paragraph><p>It should also handle files that use some kind of a combination of the above (e.g., carriage return followed by several line feeds).</p></div><div class=sect2><h3 id=x86-finite-state-machine>A.11.1. Finite State Machine<a class=anchor href=#x86-finite-state-machine></a></h3><div class=paragraph><p>The problem is easily solved by the use of a technique called <em>finite state machine</em>, originally developed by the designers of digital electronic circuits.
A <em>finite state machine</em> is a digital circuit whose output is dependent not only on its input but on its previous input, i.e., on its state.
The microprocessor is an example of a <em>finite state machine</em>: Our assembly language code is assembled to machine language in which some assembly language code produces a single byte of machine language, while others produce several bytes.
As the microprocessor fetches the bytes from the memory one by one, some of them simply change its state rather than produce some output.
When all the bytes of the op code are fetched, the microprocessor produces some output, or changes the value of a register, etc.</p></div><div class=paragraph><p>Because of that, all software is essentially a sequence of state instructions for the microprocessor.
Nevertheless, the concept of <em>finite state machine</em> is useful in software design as well.</p></div><div class=paragraph><p>Our text file converter can be designer as a <em>finite state machine</em> with three possible states.
We could call them states 0-2, but it will make our life easier if we give them symbolic names:</p></div><div class=ulist><ul><li><p>ordinary</p></li><li><p>cr</p></li><li><p>lf</p></li></ul></div><div class=paragraph><p>Our program will start in the ordinary state. During this state, the program action depends on its input as follows:</p></div><div class=ulist><ul><li><p>If the input is anything other than a carriage return or line feed, the input is simply passed on to the output.
The state remains unchanged.</p></li><li><p>If the input is a carriage return, the state is changed to cr.
The input is then discarded, i.e., no output is made.</p></li><li><p>If the input is a line feed, the state is changed to lf.
The input is then discarded.</p></li></ul></div><div class=paragraph><p>Whenever we are in the cr state, it is because the last input was a carriage return, which was unprocessed.
What our software does in this state again depends on the current input:</p></div><div class=ulist><ul><li><p>If the input is anything other than a carriage return or line feed, output a line feed, then output the input, then change the state to ordinary.</p></li><li><p>If the input is a carriage return, we have received two (or more) carriage returns in a row. We discard the input, we output a line feed, and leave the state unchanged.</p></li><li><p>If the input is a line feed, we output the line feed and change the state to ordinary. Note that this is not the same as the first case above - if we tried to combine them, we would be outputting two line feeds instead of one.</p></li></ul></div><div class=paragraph><p>Finally, we are in the lf state after we have received a line feed that was not preceded by a carriage return.
This will happen when our file already is in UNIX® format, or whenever several lines in a row are expressed by a single carriage return followed by several line feeds, or when line ends with a line feed / carriage return sequence.
Here is how we need to handle our input in this state:</p></div><div class=ulist><ul><li><p>If the input is anything other than a carriage return or line feed, we output a line feed, then output the input, then change the state to ordinary. This is exactly the same action as in the cr state upon receiving the same kind of input.</p></li><li><p>If the input is a carriage return, we discard the input, we output a line feed, then change the state to ordinary.</p></li><li><p>If the input is a line feed, we output the line feed, and leave the state unchanged.</p></li></ul></div><div class=sect3><h4 id=x86-final-state>A.11.1.1. The Final State<a class=anchor href=#x86-final-state></a></h4><div class=paragraph><p>The above <em>finite state machine</em> works for the entire file, but leaves the possibility that the final line end will be ignored.
That will happen whenever the file ends with a single carriage return or a single line feed.
I did not think of it when I wrote tuc, just to discover that occasionally it strips the last line ending.</p></div><div class=paragraph><p>This problem is easily fixed by checking the state after the entire file was processed.
If the state is not ordinary, we simply need to output one last line feed.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Now that we have expressed our algorithm as a <em>finite state machine</em>,
we could easily design a dedicated digital electronic circuit (a "chip") to do the conversion for us.
Of course, doing so would be considerably more expensive than writing an assembly language program.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-tuc-counter>A.11.1.2. The Output Counter<a class=anchor href=#x86-tuc-counter></a></h4><div class=paragraph><p>Because our file conversion program may be combining two characters into one, we need to use an output counter.
We initialize it to <code>0</code>, and increase it every time we send a character to the output.
At the end of the program, the counter will tell us what size we need to set the file to.</p></div></div></div><div class=sect2><h3 id=x86-software-fsm>A.11.2. Implementing FSM in Software<a class=anchor href=#x86-software-fsm></a></h3><div class=paragraph><p>The hardest part of working with a <em>finite state machine</em> is analyzing the problem and expressing it as a <em>finite state machine</em>.
That accomplished, the software almost writes itself.</p></div><div class=paragraph><p>In a high-level language, such as C, there are several main approaches.
One is to use a <code>switch</code> statement which chooses what function should be run. For example,</p></div><div class="literalblock programlisting"><div class=content><pre>switch (state) {
	default:
	case REGULAR:
		regular(inputchar);
		break;
	case CR:
		cr(inputchar);
		break;
	case LF:
		lf(inputchar);
		break;
	}</pre></div></div><div class=paragraph><p>Another approach is by using an array of function pointers, something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>(output[state])(inputchar);</pre></div></div><div class=paragraph><p>Yet another is to have <code>state</code> be a function pointer, set to point at the appropriate function:</p></div><div class="literalblock programlisting"><div class=content><pre>(*state)(inputchar);</pre></div></div><div class=paragraph><p>This is the approach we will use in our program because it is very easy to do in assembly language, and very fast, too.
We will simply keep the address of the right procedure in <code>EBX</code>, and then just issue:</p></div><div class="literalblock programlisting"><div class=content><pre>call	ebx</pre></div></div><div class=paragraph><p>This is possibly faster than hardcoding the address in the code because the microprocessor does not have to fetch the address from the memory-it is already stored in one of its registers.
I said <em>possibly</em> because with the caching modern microprocessors do, either way may be equally fast.</p></div></div><div class=sect2><h3 id=memory-mapped-files>A.11.3. Memory Mapped Files<a class=anchor href=#memory-mapped-files></a></h3><div class=paragraph><p>Because our program works on a single file, we cannot use the approach that worked for us before, i.e.,
to read from an input file and to write to an output file.</p></div><div class=paragraph><p>UNIX® allows us to map a file, or a section of a file, into memory.
To do that, we first need to open the file with the appropriate read/write flags.
Then we use the <code>mmap</code> system call to map it into the memory.
One nice thing about <code>mmap</code> is that it automatically works with virtual memory:
We can map more of the file into the memory than we have physical memory available, yet still access it through regular memory op codes, such as <code>mov</code>, <code>lods</code>, and <code>stos</code>.
Whatever changes we make to the memory image of the file will be written to the file by the system.
We do not even have to keep the file open: As long as it stays mapped, we can read from it and write to it.</p></div><div class=paragraph><p>The 32-bit Intel microprocessors can access up to four gigabytes of memory - physical or virtual.
The FreeBSD system allows us to use up to a half of it for file mapping.</p></div><div class=paragraph><p>For simplicity sake, in this tutorial we will only convert files that can be mapped into the memory in their entirety.
There are probably not too many text files that exceed two gigabytes in size.
If our program encounters one, it will simply display a message suggesting we use the original tuc instead.</p></div><div class=paragraph><p>If you examine your copy of <span class=filename>syscalls.master</span>, you will find two separate syscalls named <code>mmap</code>.
This is because of evolution of UNIX®: There was the traditional BSD <code>mmap</code>, syscall 71.
That one was superseded by the POSIX® <code>mmap</code>, syscall 197.
The FreeBSD system supports both because older programs were written by using the original BSD version.
But new software uses the POSIX® version, which is what we will use.</p></div><div class=paragraph><p>The <span class=filename>syscalls.master</span> lists the POSIX® version like this:</p></div><div class="literalblock programlisting"><div class=content><pre>197	STD	BSD	{ caddr_t mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }</pre></div></div><div class=paragraph><p>This differs slightly from what <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> says.
That is because <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> describes the C version.</p></div><div class=paragraph><p>The difference is in the <code>long pad</code> argument, which is not present in the C version.
However, the FreeBSD syscalls add a 32-bit pad after <code>push</code>ing a 64-bit argument.
In this case, <code>off_t</code> is a 64-bit value.</p></div><div class=paragraph><p>When we are finished working with a memory-mapped file, we unmap it with the <code>munmap</code> syscall:</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>For an in-depth treatment of <code>mmap</code>, see W. Richard Stevens' <a href="http://www.int80h.org/cgi-bin/isbn?isbn=0130810819">Unix Network Programming, Volume 2, Chapter 12</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-file-size>A.11.4. Determining File Size<a class=anchor href=#x86-file-size></a></h3><div class=paragraph><p>Because we need to tell <code>mmap</code> how many bytes of the file to map into the memory, and because we want to map the entire file, we need to determine the size of the file.</p></div><div class=paragraph><p>We can use the <code>fstat</code> syscall to get all the information about an open file that the system can give us.
That includes the file size.</p></div><div class=paragraph><p>Again, <span class=filename>syscalls.master</span> lists two versions of <code>fstat</code>, a traditional one (syscall 62), and a POSIX® one (syscall 189).
Naturally, we will use the POSIX® version:</p></div><div class="literalblock programlisting"><div class=content><pre>189	STD	POSIX	{ int fstat(int fd, struct stat *sb); }</pre></div></div><div class=paragraph><p>This is a very straightforward call: We pass to it the address of a <code>stat</code> structure and the descriptor of an open file.
It will fill out the contents of the <code>stat</code> structure.</p></div><div class=paragraph><p>I do, however, have to say that I tried to declare the <code>stat</code> structure in the <code>.bss</code> section, and <code>fstat</code> did not like it: It set the carry flag indicating an error.
After I changed the code to allocate the structure on the stack, everything was working fine.</p></div></div><div class=sect2><h3 id=x86-ftruncate>A.11.5. Changing the File Size<a class=anchor href=#x86-ftruncate></a></h3><div class=paragraph><p>Because our program may combine carriage return / line feed sequences into straight line feeds, our output may be smaller than our input.
However, since we are placing our output into the same file we read the input from, we may have to change the size of the file.</p></div><div class=paragraph><p>The <code>ftruncate</code> system call allows us to do just that.
Despite its somewhat misleading name, the <code>ftruncate</code> system call can be used to both truncate the file (make it smaller) and to grow it.</p></div><div class=paragraph><p>And yes, we will find two versions of <code>ftruncate</code> in <span class=filename>syscalls.master</span>, an older one (130), and a newer one (201).
We will use the newer one:</p></div><div class="literalblock programlisting"><div class=content><pre>201	STD	BSD	{ int ftruncate(int fd, int pad, off_t length); }</pre></div></div><div class=paragraph><p>Please note that this one contains a <code>int pad</code> again.</p></div></div><div class=sect2><h3 id=x86-ftuc>A.11.6. ftuc<a class=anchor href=#x86-ftuc></a></h3><div class=paragraph><p>We now know everything we need to write ftuc.
We start by adding some new lines in <span class=filename>system.inc</span>.
First, we define some constants and structures, somewhere at or near the beginning of the file:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; open flags
%define	O_RDONLY	0
%define	O_WRONLY	1
%define	O_RDWR	2

;;;;;;; mmap flags
%define	PROT_NONE	0
%define	PROT_READ	1
%define	PROT_WRITE	2
%define	PROT_EXEC	4
;;
%define	MAP_SHARED	0001h
%define	MAP_PRIVATE	0002h

;;;;;;; stat structure
struc	stat
st_dev		resd	1	; = 0
st_ino		resd	1	; = 4
st_mode		resw	1	; = 8, size is 16 bits
st_nlink	resw	1	; = 10, ditto
st_uid		resd	1	; = 12
st_gid		resd	1	; = 16
st_rdev		resd	1	; = 20
st_atime	resd	1	; = 24
st_atimensec	resd	1	; = 28
st_mtime	resd	1	; = 32
st_mtimensec	resd	1	; = 36
st_ctime	resd	1	; = 40
st_ctimensec	resd	1	; = 44
st_size		resd	2	; = 48, size is 64 bits
st_blocks	resd	2	; = 56, ditto
st_blksize	resd	1	; = 64
st_flags	resd	1	; = 68
st_gen		resd	1	; = 72
st_lspare	resd	1	; = 76
st_qspare	resd	4	; = 80
endstruc</pre></div></div><div class=paragraph><p>We define the new syscalls:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_mmap	197
%define	SYS_munmap	73
%define	SYS_fstat	189
%define	SYS_ftruncate	201</pre></div></div><div class=paragraph><p>We add the macros for their use:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.mmap	0
	system	SYS_mmap
%endmacro

%macro	sys.munmap	0
	system	SYS_munmap
%endmacro

%macro	sys.ftruncate	0
	system	SYS_ftruncate
%endmacro

%macro	sys.fstat	0
	system	SYS_fstat
%endmacro</pre></div></div><div class=paragraph><p>And here is our code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; Fast Text-to-Unix Conversion (ftuc.asm) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Started:	21-Dec-2000
;; Updated:	22-Dec-2000
;;
;; Copyright 2000 G. Adam Stanislav.
;; All rights reserved.
;;
;;;;;;; v.1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
	db	&#39;Copyright 2000 G. Adam Stanislav.&#39;, 0Ah
	db	&#39;All rights reserved.&#39;, 0Ah
usg	db	&#39;Usage: ftuc filename&#39;, 0Ah
usglen	equ	$-usg
co	db	&#34;ftuc: Can&#39;t open file.&#34;, 0Ah
colen	equ	$-co
fae	db	&#39;ftuc: File access error.&#39;, 0Ah
faelen	equ	$-fae
ftl	db	&#39;ftuc: File too long, use regular tuc instead.&#39;, 0Ah
ftllen	equ	$-ftl
mae	db	&#39;ftuc: Memory allocation error.&#39;, 0Ah
maelen	equ	$-mae

section	.text

align 4
memerr:
	push	dword maelen
	push	dword mae
	jmp	short error

align 4
toolong:
	push	dword ftllen
	push	dword ftl
	jmp	short error

align 4
facerr:
	push	dword faelen
	push	dword fae
	jmp	short error

align 4
cantopen:
	push	dword colen
	push	dword co
	jmp	short error

align 4
usage:
	push	dword usglen
	push	dword usg

error:
	push	dword stderr
	sys.write

	push	dword 1
	sys.exit

align 4
global	_start
_start:
	pop	eax		; argc
	pop	eax		; program name
	pop	ecx		; file to convert
	jecxz	usage

	pop	eax
	or	eax, eax	; Too many arguments?
	jne	usage

	; Open the file
	push	dword O_RDWR
	push	ecx
	sys.open
	jc	cantopen

	mov	ebp, eax	; Save fd

	sub	esp, byte stat_size
	mov	ebx, esp

	; Find file size
	push	ebx
	push	ebp		; fd
	sys.fstat
	jc	facerr

	mov	edx, [ebx + st_size + 4]

	; File is too long if EDX != 0 ...
	or	edx, edx
	jne	near toolong
	mov	ecx, [ebx + st_size]
	; ... or if it is above 2 GB
	or	ecx, ecx
	js	near toolong

	; Do nothing if the file is 0 bytes in size
	jecxz	.quit

	; Map the entire file in memory
	push	edx
	push	edx		; starting at offset 0
	push	edx		; pad
	push	ebp		; fd
	push	dword MAP_SHARED
	push	dword PROT_READ | PROT_WRITE
	push	ecx		; entire file size
	push	edx		; let system decide on the address
	sys.mmap
	jc	near memerr

	mov	edi, eax
	mov	esi, eax
	push	ecx		; for SYS_munmap
	push	edi

	; Use EBX for state machine
	mov	ebx, ordinary
	mov	ah, 0Ah
	cld

.loop:
	lodsb
	call	ebx
	loop	.loop

	cmp	ebx, ordinary
	je	.filesize

	; Output final lf
	mov	al, ah
	stosb
	inc	edx

.filesize:
	; truncate file to new size
	push	dword 0		; high dword
	push	edx		; low dword
	push	eax		; pad
	push	ebp
	sys.ftruncate

	; close it (ebp still pushed)
	sys.close

	add	esp, byte 16
	sys.munmap

.quit:
	push	dword 0
	sys.exit

align 4
ordinary:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	stosb
	inc	edx
	ret

align 4
.cr:
	mov	ebx, cr
	ret

align 4
.lf:
	mov	ebx, lf
	ret

align 4
cr:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	al, ah
	stosb
	inc	edx
	ret

align 4
lf:
	cmp	al, ah
	je	.lf

	cmp	al, 0Dh
	je	.cr

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	ebx, ordinary
	mov	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	ret</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Do not use this program on files stored on a disk formatted by MS-DOS® or Windows®.
There seems to be a subtle bug in the FreeBSD code when using <code>mmap</code> on these drives mounted under FreeBSD:
If the file is over a certain size, <code>mmap</code> will just fill the memory with zeros, and then copy them to the file overwriting its contents.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=x86-one-pointed-mind>A.12. One-Pointed Mind<a class=anchor href=#x86-one-pointed-mind></a></h2><div class=sectionbody><div class=paragraph><p>As a student of Zen, I like the idea of a one-pointed mind: Do one thing at a time, and do it well.</p></div><div class=paragraph><p>This, indeed, is very much how UNIX® works as well.
While a typical Windows® application is attempting to do everything imaginable (and is, therefore, riddled with bugs), a typical UNIX® program does only one thing, and it does it well.</p></div><div class=paragraph><p>The typical UNIX® user then essentially assembles his own applications by writing a shell script which combines the various existing programs by piping the output of one program to the input of another.</p></div><div class=paragraph><p>When writing your own UNIX® software, it is generally a good idea to see what parts of the problem you need to solve can be handled by existing programs, and only write your own programs for that part of the problem that you do not have an existing solution for.</p></div><div class=sect2><h3 id=x86-csv>A.12.1. CSV<a class=anchor href=#x86-csv></a></h3><div class=paragraph><p>I will illustrate this principle with a specific real-life example I was faced with recently:</p></div><div class=paragraph><p>I needed to extract the 11th field of each record from a database I downloaded from a web site.
The database was a CSV file, i.e., a list of <em>comma-separated values</em>.
That is quite a standard format for sharing data among people who may be using different database software.</p></div><div class=paragraph><p>The first line of the file contains the list of various fields separated by commas.
The rest of the file contains the data listed line by line, with values separated by commas.</p></div><div class=paragraph><p>I tried awk, using the comma as a separator. But because several lines contained a quoted comma, awk was extracting the wrong field from those lines.</p></div><div class=paragraph><p>Therefore, I needed to write my own software to extract the 11th field from the CSV file.
However, going with the UNIX® spirit, I only needed to write a simple filter that would do the following:</p></div><div class=ulist><ul><li><p>Remove the first line from the file;</p></li><li><p>Change all unquoted commas to a different character;</p></li><li><p>Remove all quotation marks.</p></li></ul></div><div class=paragraph><p>Strictly speaking, I could use sed to remove the first line from the file, but doing so in my own program was very easy, so I decided to do it and reduce the size of the pipeline.</p></div><div class=paragraph><p>At any rate, writing a program like this took me about 20 minutes.
Writing a program that extracts the 11th field from the CSV file would take a lot longer,
and I could not reuse it to extract some other field from some other database.</p></div><div class=paragraph><p>This time I decided to let it do a little more work than a typical tutorial program would:</p></div><div class=ulist><ul><li><p>It parses its command line for options;</p></li><li><p>It displays proper usage if it finds wrong arguments;</p></li><li><p>It produces meaningful error messages.</p></li></ul></div><div class=paragraph><p>Here is its usage message:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Usage: csv <span class=o>[</span><span class=nt>-t</span>&lt;delim&gt;] <span class=o>[</span><span class=nt>-c</span>&lt;comma&gt;] <span class=o>[</span><span class=nt>-p</span><span class=o>]</span> <span class=o>[</span><span class=nt>-o</span> &lt;outfile&gt;] <span class=o>[</span><span class=nt>-i</span> &lt;infile&gt;]</code></pre></div></div><div class=paragraph><p>All parameters are optional, and can appear in any order.</p></div><div class=paragraph><p>The <code>-t</code> parameter declares what to replace the commas with.
The <code>tab</code> is the default here.
For example, <code>-t;</code> will replace all unquoted commas with semicolons.</p></div><div class=paragraph><p>I did not need the <code>-c</code> option, but it may come in handy in the future.
It lets me declare that I want a character other than a comma replaced with something else.
For example, <code>-c@</code> will replace all at signs (useful if you want to split a list of email addresses to their user names and domains).</p></div><div class=paragraph><p>The <code>-p</code> option preserves the first line, i.e., it does not delete it.
By default, we delete the first line because in a CSV file it contains the field names rather than data.</p></div><div class=paragraph><p>The <code>-i</code> and <code>-o</code> options let me specify the input and the output files.
Defaults are <span class=filename>stdin</span> and <span class=filename>stdout</span>, so this is a regular UNIX® filter.</p></div><div class=paragraph><p>I made sure that both <code>-i filename</code> and <code>-ifilename</code> are accepted.
I also made sure that only one input and one output files may be specified.</p></div><div class=paragraph><p>To get the 11th field of each record, I can now do:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% csv <span class=s1>&#39;-t;&#39;</span> data.csv | <span class=nb>awk</span> <span class=s1>&#39;-F;&#39;</span> <span class=s1>&#39;{print $11}&#39;</span></code></pre></div></div><div class=paragraph><p>The code stores the options (except for the file descriptors) in <code>EDX</code>: The comma in <code>DH</code>, the new separator in <code>DL</code>, and the flag for the <code>-p</code> option in the highest bit of <code>EDX</code>, so a check for its sign will give us a quick decision what to do.</p></div><div class=paragraph><p>Here is the code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; csv.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Convert a comma-separated file to a something-else separated file.
;
; Started:	31-May-2001
; Updated:	 1-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
usg	db	&#39;Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;csv: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;csv: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	mov	edx, (&#39;,&#39; &lt;&lt; 8) | 9

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .init		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	inc	ecx
	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	inc	ecx
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.t
	or	ah, ah
	jne	near usage
	or	edx, 1 &lt;&lt; 31
	jmp	.arg

.t:
	cmp	al, &#39;t&#39;		; redefine output delimiter
	jne	.c
	or	ah, ah
	je	near usage
	mov	dl, ah
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	near usage
	or	ah, ah
	je	near usage
	mov	dh, ah
	jmp	.arg

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

	; See if we are to preserve the first line
	or	edx, edx
	js	.loop

.firstline:
	; get rid of the first line
	call	getchar
	cmp	al, 0Ah
	jne	.firstline

.loop:
	; read a byte from stdin
	call	getchar

	; is it a comma (or whatever the user asked for)?
	cmp	al, dh
	jne	.quote

	; Replace the comma with a tab (or whatever the user wants)
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

.quote:
	cmp	al, &#39;&#34;&#39;
	jne	.put

	; Print everything until you get another quote or EOL. If it
	; is a quote, skip it. If it is EOL, print it.
.qloop:
	call	getchar
	cmp	al, &#39;&#34;&#39;
	je	.loop

	cmp	al, 0Ah
	je	.put

	call	putchar
	jmp	short .qloop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret</pre></div></div><div class=paragraph><p>Much of it is taken from <span class=filename>hex.asm</span> above.
But there is one important difference: I no longer call <code>write</code> whenever I am outputting a line feed.
Yet, the code can be used interactively.</p></div><div class=paragraph><p>I have found a better solution for the interactive problem since I first started writing this chapter.
I wanted to make sure each line is printed out separately only when needed.
After all, there is no need to flush out every line when used non-interactively.</p></div><div class=paragraph><p>The new solution I use now is to call <code>write</code> every time I find the input buffer empty.
That way, when running in the interactive mode, the program reads one line from the user’s keyboard, processes it, and sees its input buffer is empty.
It flushes its output and reads the next line.</p></div><div class=sect3><h4 id=x86-buffered-dark-side>A.12.1.1. The Dark Side of Buffering<a class=anchor href=#x86-buffered-dark-side></a></h4><div class=paragraph><p>This change prevents a mysterious lockup in a very specific case.
I refer to it as the <em>dark side of buffering</em>, mostly because it presents a danger that is not quite obvious.</p></div><div class=paragraph><p>It is unlikely to happen with a program like the csv above, so let us consider yet another filter:
In this case we expect our input to be raw data representing color values, such as the <em>red</em>, <em>green</em>, and <em>blue</em> intensities of a pixel.
Our output will be the negative of our input.</p></div><div class=paragraph><p>Such a filter would be very simple to write.
Most of it would look just like all the other filters we have written so far, so I am only going to show you its inner loop:</p></div><div class="literalblock programlisting"><div class=content><pre>.loop:
	call	getchar
	not	al		; Create a negative
	call	putchar
	jmp	short .loop</pre></div></div><div class=paragraph><p>Because this filter works with raw data, it is unlikely to be used interactively.</p></div><div class=paragraph><p>But it could be called by image manipulation software.
And, unless it calls <code>write</code> before each call to <code>read</code>, chances are it will lock up.</p></div><div class=paragraph><p>Here is what might happen:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>The image editor will load our filter using the C function <code>popen()</code>.</p></li><li><p>It will read the first row of pixels from a bitmap or pixmap.</p></li><li><p>It will write the first row of pixels to the <em>pipe</em> leading to the <code>fd.in</code> of our filter.</p></li><li><p>Our filter will read each pixel from its input, turn it to a negative, and write it to its output buffer.</p></li><li><p>Our filter will call <code>getchar</code> to fetch the next pixel.</p></li><li><p><code>getchar</code> will find an empty input buffer, so it will call <code>read</code>.</p></li><li><p><code>read</code> will call the <code>SYS_read</code> system call.</p></li><li><p>The <em>kernel</em> will suspend our filter until the image editor sends more data to the pipe.</p></li><li><p>The image editor will read from the other pipe, connected to the <code>fd.out</code> of our filter so it can set the first row of the output image <em>before</em> it sends us the second row of the input.</p></li><li><p>The <em>kernel</em> suspends the image editor until it receives some output from our filter, so it can pass it on to the image editor.</p></li></ol></div><div class=paragraph><p>At this point our filter waits for the image editor to send it more data to process,
while the image editor is waiting for our filter to send it the result of the processing of the first row.
But the result sits in our output buffer.</p></div><div class=paragraph><p>The filter and the image editor will continue waiting for each other forever (or, at least, until they are killed).
Our software has just entered a <a href=../secure/#secure-race-conditions>race condition</a>.</p></div><div class=paragraph><p>This problem does not exist if our filter flushes its output buffer <em>before</em> asking the <em>kernel</em> for more input data.</p></div></div></div></div></div><div class=sect1><h2 id=x86-fpu>A.13. Using the FPU<a class=anchor href=#x86-fpu></a></h2><div class=sectionbody><div class=paragraph><p>Strangely enough, most of assembly language literature does not even mention the existence of the FPU, or <em>floating point unit</em>, let alone discuss programming it.</p></div><div class=paragraph><p>Yet, never does assembly language shine more than when we create highly optimized FPU code by doing things that can be done <em>only</em> in assembly language.</p></div><div class=sect2><h3 id=x86-fpu-organization>A.13.1. Organization of the FPU<a class=anchor href=#x86-fpu-organization></a></h3><div class=paragraph><p>The FPU consists of 8 80-bit floating-point registers.
These are organized in a stack fashion-you can <code>push</code> a value on TOS (<em>top of stack</em>) and you can <code>pop</code> it.</p></div><div class=paragraph><p>That said, the assembly language op codes are not <code>push</code> and <code>pop</code> because those are already taken.</p></div><div class=paragraph><p>You can <code>push</code> a value on TOS by using <code>fld</code>, <code>fild</code>, and <code>fbld</code>.
Several other op codes let you <code>push</code> many common <em>constants</em>-such as <em>pi</em>-on the TOS.</p></div><div class=paragraph><p>Similarly, you can <code>pop</code> a value by using <code>fst</code>, <code>fstp</code>, <code>fist</code>, <code>fistp</code>, and <code>fbstp</code>.
Actually, only the op codes that end with a <em>p</em> will literally <code>pop</code> the value, the rest will <code>store</code> it somewhere else without removing it from the TOS.</p></div><div class=paragraph><p>We can transfer the data between the TOS and the computer memory either as a 32-bit, 64-bit, or 80-bit <em>real</em>, a 16-bit, 32-bit, or 64-bit <em>integer</em>, or an 80-bit <em>packed decimal</em>.</p></div><div class=paragraph><p>The 80-bit <em>packed decimal</em> is a special case of <em>binary coded decimal</em> which is very convenient when converting between the ASCII representation of data and the internal data of the FPU.
It allows us to use 18 significant digits.</p></div><div class=paragraph><p>No matter how we represent data in the memory, the FPU always stores it in the 80-bit <em>real</em> format in its registers.</p></div><div class=paragraph><p>Its internal precision is at least 19 decimal digits, so even if we choose to display results as ASCII in the full 18-digit precision, we are still showing correct results.</p></div><div class=paragraph><p>We can perform mathematical operations on the TOS: We can calculate its <em>sine</em>, we can <em>scale</em> it (i.e., we can multiply or divide it by a power of 2), we can calculate its base-2 <em>logarithm</em>, and many other things.</p></div><div class=paragraph><p>We can also <em>multiply</em> or <em>divide</em> it by, <em>add</em> it to, or <em>subtract</em> it from, any of the FPU registers (including itself).</p></div><div class=paragraph><p>The official Intel op code for the TOS is <code>st</code>, and for the <em>registers</em> <code>st(0)</code>-<code>st(7)</code>.
<code>st</code> and <code>st(0)</code>, then, refer to the same register.</p></div><div class=paragraph><p>For whatever reasons, the original author of nasm has decided to use different op codes, namely <code>st0</code>-<code>st7</code>.
In other words, there are no parentheses, and the TOS is always <code>st0</code>, never just <code>st</code>.</p></div><div class=sect3><h4 id=x86-fpu-packed-decimal>A.13.1.1. The Packed Decimal Format<a class=anchor href=#x86-fpu-packed-decimal></a></h4><div class=paragraph><p>The <em>packed decimal</em> format uses 10 bytes (80 bits) of memory to represent 18 digits.
The number represented there is always an <em>integer</em>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>You can use it to get decimal places by multiplying the TOS by a power of 10 first.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The highest bit of the highest byte (byte 9) is the <em>sign bit</em>: If it is set, the number is <em>negative</em>, otherwise, it is <em>positive</em>.
The rest of the bits of this byte are unused/ignored.</p></div><div class=paragraph><p>The remaining 9 bytes store the 18 digits of the number: 2 digits per byte.</p></div><div class=paragraph><p>The <em>more significant digit</em> is stored in the high <em>nibble</em> (4 bits), the <em>less significant digit</em> in the low <em>nibble</em>.</p></div><div class=paragraph><p>That said, you might think that <code>-1234567</code> would be stored in the memory like this (using hexadecimal notation):</p></div><div class="literalblock programlisting"><div class=content><pre>80 00 00 00 00 00 01 23 45 67</pre></div></div><div class=paragraph><p>Alas it is not! As with everything else of Intel make, even the <em>packed decimal</em> is <em>little-endian</em>.</p></div><div class=paragraph><p>That means our <code>-1234567</code> is stored like this:</p></div><div class="literalblock programlisting"><div class=content><pre>67 45 23 01 00 00 00 00 00 80</pre></div></div><div class=paragraph><p>Remember that, or you will be pulling your hair out in desperation!</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The book to read-if you can find it-is Richard Startz' <a href=http://www.amazon.com/exec/obidos/ASIN/013246604X/whizkidtechnomag>8087/80287/80387 for the IBM PC & Compatibles</a>.
Though it does seem to take the fact about the little-endian storage of the <em>packed decimal</em> for granted.
I kid you not about the desperation of trying to figure out what was wrong with the filter I show below <em>before</em> it occurred to me I should try the little-endian order even for this type of data.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x86-pinhole-photography>A.13.2. Excursion to Pinhole Photography<a class=anchor href=#x86-pinhole-photography></a></h3><div class=paragraph><p>To write meaningful software, we must not only understand our programming tools, but also the field we are creating software for.</p></div><div class=paragraph><p>Our next filter will help us whenever we want to build a <em>pinhole camera</em>, so, we need some background in <em>pinhole photography</em> before we can continue.</p></div><div class=sect3><h4 id=x86-camera>A.13.2.1. The Camera<a class=anchor href=#x86-camera></a></h4><div class=paragraph><p>The easiest way to describe any camera ever built is as some empty space enclosed in some lightproof material, with a small hole in the enclosure.</p></div><div class=paragraph><p>The enclosure is usually sturdy (e.g., a box), though sometimes it is flexible (the bellows).
It is quite dark inside the camera.
However, the hole lets light rays in through a single point (though in some cases there may be several).
These light rays form an image, a representation of whatever is outside the camera, in front of the hole.</p></div><div class=paragraph><p>If some light sensitive material (such as film) is placed inside the camera, it can capture the image.</p></div><div class=paragraph><p>The hole often contains a <em>lens</em>, or a lens assembly, often called the <em>objective</em>.</p></div></div><div class=sect3><h4 id=x86-the-pinhole>A.13.2.2. The Pinhole<a class=anchor href=#x86-the-pinhole></a></h4><div class=paragraph><p>But, strictly speaking, the lens is not necessary: The original cameras did not use a lens but a <em>pinhole</em>.
Even today, <em>pinholes</em> are used, both as a tool to study how cameras work, and to achieve a special kind of image.</p></div><div class=paragraph><p>The image produced by the <em>pinhole</em> is all equally sharp.
Or <em>blurred</em>.
There is an ideal size for a pinhole: If it is either larger or smaller, the image loses its sharpness.</p></div></div><div class=sect3><h4 id=x86-focal-length>A.13.2.3. Focal Length<a class=anchor href=#x86-focal-length></a></h4><div class=paragraph><p>This ideal pinhole diameter is a function of the square root of <em>focal length</em>, which is the distance of the pinhole from the film.</p></div><div class="literalblock programlisting"><div class=content><pre>D = PC * sqrt(FL)</pre></div></div><div class=paragraph><p>In here, <code>D</code> is the ideal diameter of the pinhole, <code>FL</code> is the focal length, and <code>PC</code> is a pinhole constant.
According to Jay Bender, its value is <code>0.04</code>, while Kenneth Connors has determined it to be <code>0.037</code>.
Others have proposed other values.
Plus, this value is for the daylight only: Other types of light will require a different constant, whose value can only be determined by experimentation.</p></div></div><div class=sect3><h4 id=x86-f-number>A.13.2.4. The F-Number<a class=anchor href=#x86-f-number></a></h4><div class=paragraph><p>The f-number is a very useful measure of how much light reaches the film.
A light meter can determine that, for example, to expose a film of specific sensitivity with f5.6 mkay require the exposure to last 1/1000 sec.</p></div><div class=paragraph><p>It does not matter whether it is a 35-mm camera, or a 6x9cm camera, etc.
As long as we know the f-number, we can determine the proper exposure.</p></div><div class=paragraph><p>The f-number is easy to calculate:</p></div><div class="literalblock programlisting"><div class=content><pre>F = FL / D</pre></div></div><div class=paragraph><p>In other words, the f-number equals the focal length divided by the diameter of the pinhole.
It also means a higher f-number either implies a smaller pinhole or a larger focal distance, or both.
That, in turn, implies, the higher the f-number, the longer the exposure has to be.</p></div><div class=paragraph><p>Furthermore, while pinhole diameter and focal distance are one-dimensional measurements, both, the film and the pinhole, are two-dimensional.
That means that if you have measured the exposure at f-number <code>A</code> as <code>t</code>, then the exposure at f-number <code>B</code> is:</p></div><div class="literalblock programlisting"><div class=content><pre>t * (B / A)²</pre></div></div></div><div class=sect3><h4 id=x86-normalized-f-number>A.13.2.5. Normalized F-Number<a class=anchor href=#x86-normalized-f-number></a></h4><div class=paragraph><p>While many modern cameras can change the diameter of their pinhole, and thus their f-number, quite smoothly and gradually, such was not always the case.</p></div><div class=paragraph><p>To allow for different f-numbers, cameras typically contained a metal plate with several holes of different sizes drilled to them.</p></div><div class=paragraph><p>Their sizes were chosen according to the above formula in such a way that the resultant f-number was one of standard f-numbers used on all cameras everywhere.
For example, a very old Kodak Duaflex IV camera in my possession has three such holes for f-numbers 8, 11, and 16.</p></div><div class=paragraph><p>A more recently made camera may offer f-numbers of 2.8, 4, 5.6, 8, 11, 16, 22, and 32 (as well as others).
These numbers were not chosen arbitrarily: They all are powers of the square root of 2, though they may be rounded somewha.</p></div></div><div class=sect3><h4 id=x86-f-stop>A.13.2.6. The F-Stop<a class=anchor href=#x86-f-stop></a></h4><div class=paragraph><p>A typical camera is designed in such a way that setting any of the normalized f-numbers changes the feel of the dial.
It will naturally <em>stop</em> in that position. Because of that, these positions of the dial are called f-stops.</p></div><div class=paragraph><p>Since the f-numbers at each stop are powers of the square root of 2, moving the dial by 1 stop will double the amount of light required for proper exposure.
Moving it by 2 stops will quadruple the required exposure.
Moving the dial by 3 stops will require the increase in exposure 8 times, etc.</p></div></div></div><div class=sect2><h3 id=x86-pinhole-software>A.13.3. Designing the Pinhole Software<a class=anchor href=#x86-pinhole-software></a></h3><div class=paragraph><p>We are now ready to decide what exactly we want our pinhole software to do.</p></div><div class=sect3><h4 id=xpinhole-processing-input>A.13.3.1. Processing Program Input<a class=anchor href=#xpinhole-processing-input></a></h4><div class=paragraph><p>Since its main purpose is to help us design a working pinhole camera, we will use the <em>focal length</em> as the input to the program.
This is something we can determine without software: Proper focal length is determined by the size of the film and by the need to shoot "regular" pictures, wide angle pictures, or telephoto pictures.</p></div><div class=paragraph><p>Most of the programs we have written so far worked with individual characters, or bytes, as their input: The hex program converted individual bytes into a hexadecimal number, the csv program either let a character through, or deleted it, or changed it to a different character, etc.</p></div><div class=paragraph><p>One program, ftuc used the state machine to consider at most two input bytes at a time.</p></div><div class=paragraph><p>But our pinhole program cannot just work with individual characters, it has to deal with larger syntactic units.</p></div><div class=paragraph><p>For example, if we want the program to calculate the pinhole diameter (and other values we will discuss later) at the focal lengths of <code>100 mm</code>, <code>150 mm</code>, and <code>210 mm</code>, we may want to enter something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 100, 150, 210</code></pre></div></div><div class=paragraph><p>Our program needs to consider more than a single byte of input at a time.
When it sees the first <code>1</code>, it must understand it is seeing the first digit of a decimal number.
When it sees the <code>0</code> and the other <code>0</code>, it must know it is seeing more digits of the same number.</p></div><div class=paragraph><p>When it encounters the first comma, it must know it is no longer receiving the digits of the first number.
It must be able to convert the digits of the first number into the value of <code>100</code>.
And the digits of the second number into the value of <code>150</code>.
And, of course, the digits of the third number into the numeric value of <code>210</code>.</p></div><div class=paragraph><p>We need to decide what delimiters to accept: Do the input numbers have to be separated by a comma? If so, how do we treat two numbers separated by something else?</p></div><div class=paragraph><p>Personally, I like to keep it simple. Something either is a number, so I process it.
Or it is not a number, so I discard it.
I do not like the computer complaining about me typing in an extra character when it is <em>obvious</em> that it is an extra character.
Duh!</p></div><div class=paragraph><p>Plus, it allows me to break up the monotony of computing and type in a query instead of just a number:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>What is the best pinhole diameter <span class=k>for </span>the
	    focal length of 150?</code></pre></div></div><div class=paragraph><p>There is no reason for the computer to spit out a number of complaints:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Syntax error: What
Syntax error: is
Syntax error: the
Syntax error: best</code></pre></div></div><div class=paragraph><p>Et cetera, et cetera, et cetera.</p></div><div class=paragraph><p>Secondly, I like the <code>#</code> character to denote the start of a comment which extends to the end of the line.
This does not take too much effort to code, and lets me treat input files for my software as executable scripts.</p></div><div class=paragraph><p>In our case, we also need to decide what units the input should come in: We choose <em>millimeters</em> because that is how most photographers measure the focus length.</p></div><div class=paragraph><p>Finally, we need to decide whether to allow the use of the decimal point (in which case we must also consider the fact that much of the world uses a decimal <em>comma</em>).</p></div><div class=paragraph><p>In our case allowing for the decimal point/comma would offer a false sense of precision: There is little if any noticeable difference between the focus lengths of <code>50</code> and <code>51</code>, so allowing the user to input something like <code>50.5</code> is not a good idea.
This is my opinion, mind you, but I am the one writing this program.
You can make other choices in yours, of course.</p></div></div><div class=sect3><h4 id=x86-pinhole-options>A.13.3.2. Offering Options<a class=anchor href=#x86-pinhole-options></a></h4><div class=paragraph><p>The most important thing we need to know when building a pinhole camera is the diameter of the pinhole.
Since we want to shoot sharp images, we will use the above formula to calculate the pinhole diameter from focal length.
As experts are offering several different values for the <code>PC</code> constant, we will need to have the choice.</p></div><div class=paragraph><p>It is traditional in UNIX® programming to have two main ways of choosing program parameters, plus to have a default for the time the user does not make a choice.</p></div><div class=paragraph><p>Why have two ways of choosing?</p></div><div class=paragraph><p>One is to allow a (relatively) <em>permanent</em> choice that applies automatically each time the software is run without us having to tell it over and over what we want it to do.</p></div><div class=paragraph><p>The permanent choices may be stored in a configuration file, typically found in the user’s home directory.
The file usually has the same name as the application but is started with a dot.
Often <em>"rc"</em> is added to the file name.
So, ours could be <span class=filename>~/.pinhole</span> or <span class=filename>~/.pinholerc</span>. (The <span class=filename>~/</span> means current user’s home directory.)</p></div><div class=paragraph><p>The configuration file is used mostly by programs that have many configurable parameters.
Those that have only one (or a few) often use a different method:
They expect to find the parameter in an <em>environment variable</em>.
In our case, we might look at an environment variable named <code>PINHOLE</code>.</p></div><div class=paragraph><p>Usually, a program uses one or the other of the above methods.
Otherwise, if a configuration file said one thing, but an environment variable another, the program might get confused (or just too complicated).</p></div><div class=paragraph><p>Because we only need to choose <em>one</em> such parameter, we will go with the second method and search the environment for a variable named <code>PINHOLE</code>.</p></div><div class=paragraph><p>The other way allows us to make <em>ad hoc</em> decisions: <em>"Though I usually want you to use 0.039, this time I want 0.03872."</em>
In other words, it allows us to <em>override</em> the permanent choice.</p></div><div class=paragraph><p>This type of choice is usually done with command line parameters.</p></div><div class=paragraph><p>Finally, a program <em>always</em> needs a <em>default</em>.
The user may not make any choices.
Perhaps he does not know what to choose.
Perhaps he is "just browsing."
Preferably, the default will be the value most users would choose anyway.
That way they do not need to choose.
Or, rather, they can choose the default without an additional effort.</p></div><div class=paragraph><p>Given this system, the program may find conflicting options, and handle them this way:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>If it finds an <em>ad hoc</em> choice (e.g., command line parameter), it should accept that choice. It must ignore any permanent choice and any default.</p></li><li><p><em>Otherwise</em>, if it finds a permanent option (e.g., an environment variable), it should accept it, and ignore the default.</p></li><li><p><em>Otherwise</em>, it should use the default.</p></li></ol></div><div class=paragraph><p>We also need to decide what <em>format</em> our <code>PC</code> option should have.</p></div><div class=paragraph><p>At first site, it seems obvious to use the <code>PINHOLE=0.04</code> format for the environment variable, and <code>-p0.04</code> for the command line.</p></div><div class=paragraph><p>Allowing that is actually a security risk. The <code>PC</code> constant is a very small number.
Naturally, we will test our software using various small values of <code>PC</code>.
But what will happen if someone runs the program choosing a huge value?</p></div><div class=paragraph><p>It may crash the program because we have not designed it to handle huge numbers.</p></div><div class=paragraph><p>Or, we may spend more time on the program so it can handle huge numbers.
We might do that if we were writing commercial software for computer illiterate audience.</p></div><div class=paragraph><p>Or, we might say, <em>"Tough! The user should know better.""</em></p></div><div class=paragraph><p>Or, we just may make it impossible for the user to enter a huge number.
This is the approach we will take: We will use an <em>implied 0.</em> prefix.</p></div><div class=paragraph><p>In other words, if the user wants <code>0.04</code>, we will expect him to type <code>-p04</code>, or set <code>PINHOLE=04</code> in his environment.
So, if he says <code>-p9999999</code>, we will interpret it as <code>0.9999999</code>-still ridiculous but at least safer.</p></div><div class=paragraph><p>Secondly, many users will just want to go with either Bender’s constant or Connors' constant.
To make it easier on them, we will interpret <code>-b</code> as identical to <code>-p04</code>, and <code>-c</code> as identical to <code>-p037</code>.</p></div></div><div class=sect3><h4 id=x86-pinhole-output>A.13.3.3. The Output<a class=anchor href=#x86-pinhole-output></a></h4><div class=paragraph><p>We need to decide what we want our software to send to the output, and in what format.</p></div><div class=paragraph><p>Since our input allows for an unspecified number of focal length entries, it makes sense to use a traditional database-style output of showing the result of the calculation for each focal length on a separate line, while separating all values on one line by a <code>tab</code> character.</p></div><div class=paragraph><p>Optionally, we should also allow the user to specify the use of the CSV format we have studied earlier.
In this case, we will print out a line of comma-separated names describing each field of every line, then show our results as before, but substituting a <code>comma</code> for the <code>tab</code>.</p></div><div class=paragraph><p>We need a command line option for the CSV format.
We cannot use <code>-c</code> because that already means <em>use Connors' constant</em>.
For some strange reason, many web sites refer to CSV files as <em>"Excel spreadsheet"</em> (though the CSV format predates Excel).
We will, therefore, use the <code>-e</code> switch to inform our software we want the output in the CSV format.</p></div><div class=paragraph><p>We will start each line of the output with the focal length.
This may sound repetitious at first, especially in the interactive mode:
The user types in the focal length, and we are repeating it.</p></div><div class=paragraph><p>But the user can type several focal lengths on one line.
The input can also come in from a file or from the output of another program.
In that case the user does not see the input at all.</p></div><div class=paragraph><p>By the same token, the output can go to a file which we will want to examine later, or it could go to the printer, or become the input of another program.</p></div><div class=paragraph><p>So, it makes perfect sense to start each line with the focal length as entered by the user.</p></div><div class=paragraph><p>No, wait! Not as entered by the user.
What if the user types in something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 00000000150</code></pre></div></div><div class=paragraph><p>Clearly, we need to strip those leading zeros.</p></div><div class=paragraph><p>So, we might consider reading the user input as is, converting it to binary inside the FPU, and printing it out from there.</p></div><div class=paragraph><p>But…​</p></div><div class=paragraph><p>What if the user types something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 17459765723452353453534535353530530534563507309676764423</code></pre></div></div><div class=paragraph><p>Ha! The packed decimal FPU format lets us input 18-digit numbers.
But the user has entered more than 18 digits.
How do we handle that?</p></div><div class=paragraph><p>Well, we <em>could</em> modify our code to read the first 18 digits, enter it to the FPU, then read more, multiply what we already have on the TOS by 10 raised to the number of additional digits, then <code>add</code> to it.</p></div><div class=paragraph><p>Yes, we could do that.
But in <em>this</em> program it would be ridiculous (in a different one it may be just the thing to do): Even the circumference of the Earth expressed in millimeters only takes 11 digits.
Clearly, we cannot build a camera that large (not yet, anyway).</p></div><div class=paragraph><p>So, if the user enters such a huge number, he is either bored, or testing us, or trying to break into the system, or playing games-doing anything but designing a pinhole camera.</p></div><div class=paragraph><p>What will we do?</p></div><div class=paragraph><p>We will slap him in the face, in a manner of speaking:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>17459765723452353453534535353530530534563507309676764423	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>To achieve that, we will simply ignore any leading zeros.
Once we find a non-zero digit, we will initialize a counter to <code>0</code> and start taking three steps:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Send the digit to the output.</p></li><li><p>Append the digit to a buffer we will use later to produce the packed decimal we can send to the FPU.</p></li><li><p>Increase the counter.</p></li></ol></div><div class=paragraph><p>Now, while we are taking these three steps, we also need to watch out for one of two conditions:</p></div><div class=ulist><ul><li><p>If the counter grows above 18, we stop appending to the buffer. We continue reading the digits and sending them to the output.</p></li><li><p>If, or rather <em>when</em>, the next input character is not a digit, we are done inputting for now.</p><div class=paragraph><p>Incidentally, we can simply discard the non-digit, unless it is a <code>#</code>, which we must return to the input stream.
It starts a comment, so we must see it after we are done producing output and start looking for more input.</p></div></li></ul></div><div class=paragraph><p>That still leaves one possibility uncovered: If all the user enters is a zero (or several zeros), we will never find a non-zero to display.</p></div><div class=paragraph><p>We can determine this has happened whenever our counter stays at <code>0</code>.
In that case we need to send <code>0</code> to the output, and perform another "slap in the face":</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>0	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>Once we have displayed the focal length and determined it is valid (greater than <code>0</code> but not exceeding 18 digits), we can calculate the pinhole diameter.</p></div><div class=paragraph><p>It is not by coincidence that <em>pinhole</em> contains the word <em>pin</em>.
Indeed, many a pinhole literally is a <em>pin hole</em>, a hole carefully punched with the tip of a pin.</p></div><div class=paragraph><p>That is because a typical pinhole is very small. Our formula gets the result in millimeters.
We will multiply it by <code>1000</code>, so we can output the result in <em>microns</em>.</p></div><div class=paragraph><p>At this point we have yet another trap to face: <em>Too much precision.</em></p></div><div class=paragraph><p>Yes, the FPU was designed for high precision mathematics.
But we are not dealing with high precision mathematics.
We are dealing with physics (optics, specifically).</p></div><div class=paragraph><p>Suppose we want to convert a truck into a pinhole camera (we would not be the first ones to do that!).
Suppose its box is <code>12</code> meters long, so we have the focal length of <code>12000</code>.
Well, using Bender’s constant, it gives us square root of <code>12000</code> multiplied by <code>0.04</code>, which is <code>4.381780460</code> millimeters, or <code>4381.780460</code> microns.</p></div><div class=paragraph><p>Put either way, the result is absurdly precise.
Our truck is not <em>exactly</em> <code>12000</code> millimeters long.
We did not measure its length with such a precision, so stating we need a pinhole with the diameter of <code>4.381780460</code> millimeters is, well, deceiving.
<code>4.4</code> millimeters would do just fine.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>I "only" used ten digits in the above example.
Imagine the absurdity of going for all 18!</p></div></td></tr></tbody></table></div><div class=paragraph><p>We need to limit the number of significant digits of our result.
One way of doing it is by using an integer representing microns.
So, our truck would need a pinhole with the diameter of <code>4382</code> microns.
Looking at that number, we still decide that <code>4400</code> microns, or <code>4.4</code> millimeters is close enough.</p></div><div class=paragraph><p>Additionally, we can decide that no matter how big a result we get, we only want to display four significant digits (or any other number of them, of course).
Alas, the FPU does not offer rounding to a specific number of digits (after all, it does not view the numbers as decimal but as binary).</p></div><div class=paragraph><p>We, therefore, must devise an algorithm to reduce the number of significant digits.</p></div><div class=paragraph><p>Here is mine (I think it is awkward-if you know a better one, <em>please</em>, let me know):</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Initialize a counter to <code>0</code>.</p></li><li><p>While the number is greater than or equal to <code>10000</code>, divide it by <code>10</code> and increase the counter.</p></li><li><p>Output the result.</p></li><li><p>While the counter is greater than <code>0</code>, output <code>0</code> and decrease the counter.</p></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>10000</code> is only good if you want <em>four</em> significant digits.
For any other number of significant digits, replace <code>10000</code> with <code>10</code> raised to the number of significant digits.</p></div></td></tr></tbody></table></div><div class=paragraph><p>We will, then, output the pinhole diameter in microns, rounded off to four significant digits.</p></div><div class=paragraph><p>At this point, we know the <em>focal length</em> and the <em>pinhole diameter</em>.
That means we have enough information to also calculate the <em>f-number</em>.</p></div><div class=paragraph><p>We will display the f-number, rounded to four significant digits.
Chances are the f-number will tell us very little.
To make it more meaningful, we can find the nearest <em>normalized f-number</em>, i.e., the nearest power of the square root of 2.</p></div><div class=paragraph><p>We do that by multiplying the actual f-number by itself, which, of course, will give us its <code>square</code>.
We will then calculate its base-2 logarithm, which is much easier to do than calculating the base-square-root-of-2 logarithm! We will round the result to the nearest integer.
Next, we will raise 2 to the result.
Actually, the FPU gives us a good shortcut to do that: We can use the <code>fscale</code> op code to "scale" 1, which is analogous to <code>shift</code>ing an integer left.
Finally, we calculate the square root of it all, and we have the nearest normalized f-number.</p></div><div class=paragraph><p>If all that sounds overwhelming-or too much work, perhaps-it may become much clearer if you see the code.
It takes 9 op codes altogether:</p></div><div class="literalblock programlisting"><div class=content><pre>fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1</pre></div></div><div class=paragraph><p>The first line, <code>fmul st0, st0</code>, squares the contents of the TOS (top of the stack, same as <code>st</code>, called <code>st0</code> by nasm).
The <code>fld1</code> pushes <code>1</code> on the TOS.</p></div><div class=paragraph><p>The next line, <code>fld st1</code>, pushes the square back to the TOS.
At this point the square is both in <code>st</code> and <code>st(2)</code> (it will become clear why we leave a second copy on the stack in a moment).
<code>st(1)</code> contains <code>1</code>.</p></div><div class=paragraph><p>Next, <code>fyl2x</code> calculates base-2 logarithm of <code>st</code> multiplied by <code>st(1)</code>.
That is why we placed <code>1</code> on <code>st(1)</code> before.</p></div><div class=paragraph><p>At this point, <code>st</code> contains the logarithm we have just calculated, <code>st(1)</code> contains the square of the actual f-number we saved for later.</p></div><div class=paragraph><p><code>frndint</code> rounds the TOS to the nearest integer.
<code>fld1</code> pushes a <code>1</code>.
<code>fscale</code> shifts the <code>1</code> we have on the TOS by the value in <code>st(1)</code>, effectively raising 2 to <code>st(1)</code>.</p></div><div class=paragraph><p>Finally, <code>fsqrt</code> calculates the square root of the result, i.e., the nearest normalized f-number.</p></div><div class=paragraph><p>We now have the nearest normalized f-number on the TOS, the base-2 logarithm rounded to the nearest integer in <code>st(1)</code>, and the square of the actual f-number in <code>st(2)</code>.
We are saving the value in <code>st(2)</code> for later.</p></div><div class=paragraph><p>But we do not need the contents of <code>st(1)</code> anymore.
The last line, <code>fstp st1</code>, places the contents of <code>st</code> to <code>st(1)</code>, and pops.
As a result, what was <code>st(1)</code> is now <code>st</code>, what was <code>st(2)</code> is now <code>st(1)</code>, etc.
The new <code>st</code> contains the normalized f-number.
The new <code>st(1)</code> contains the square of the actual f-number we have stored there for posterity.</p></div><div class=paragraph><p>At this point, we are ready to output the normalized f-number.
Because it is normalized, we will not round it off to four significant digits, but will send it out in its full precision.</p></div><div class=paragraph><p>The normalized f-number is useful as long as it is reasonably small and can be found on our light meter.
Otherwise we need a different method of determining proper exposure.</p></div><div class=paragraph><p>Earlier we have figured out the formula of calculating proper exposure at an arbitrary f-number from that measured at a different f-number.</p></div><div class=paragraph><p>Every light meter I have ever seen can determine proper exposure at f5.6.
We will, therefore, calculate an <em>"f5.6 multiplier,"</em> i.e., by how much we need to multiply the exposure measured at f5.6 to determine the proper exposure for our pinhole camera.</p></div><div class=paragraph><p>From the above formula we know this factor can be calculated by dividing our f-number (the actual one, not the normalized one) by <code>5.6</code>, and squaring the result.</p></div><div class=paragraph><p>Mathematically, dividing the square of our f-number by the square of <code>5.6</code> will give us the same result.</p></div><div class=paragraph><p>Computationally, we do not want to square two numbers when we can only square one.
So, the first solution seems better at first.</p></div><div class=paragraph><p>But…​</p></div><div class=paragraph><p><code>5.6</code> is a <em>constant</em>.
We do not have to have our FPU waste precious cycles.
We can just tell it to divide the square of the f-number by whatever <code>5.6²</code> equals to.
Or we can divide the f-number by <code>5.6</code>, and then square the result.
The two ways now seem equal.</p></div><div class=paragraph><p>But, they are not!</p></div><div class=paragraph><p>Having studied the principles of photography above, we remember that the <code>5.6</code> is actually square root of 2 raised to the fifth power.
An <em>irrational</em> number.
The square of this number is <em>exactly</em> <code>32</code>.</p></div><div class=paragraph><p>Not only is <code>32</code> an integer, it is a power of 2.
We do not need to divide the square of the f-number by <code>32</code>.
We only need to use <code>fscale</code> to shift it right by five positions.
In the FPU lingo it means we will <code>fscale</code> it with <code>st(1)</code> equal to <code>-5</code>.
That is <em>much faster</em> than a division.</p></div><div class=paragraph><p>So, now it has become clear why we have saved the square of the f-number on the top of the FPU stack.
The calculation of the f5.6 multiplier is the easiest calculation of this entire program! We will output it rounded to four significant digits.</p></div><div class=paragraph><p>There is one more useful number we can calculate: The number of stops our f-number is from f5.6.
This may help us if our f-number is just outside the range of our light meter, but we have a shutter which lets us set various speeds, and this shutter uses stops.</p></div><div class=paragraph><p>Say, our f-number is 5 stops from f5.6, and the light meter says we should use 1/1000 sec.
Then we can set our shutter speed to 1/1000 first, then move the dial by 5 stops.</p></div><div class=paragraph><p>This calculation is quite easy as well.
All we have to do is to calculate the base-2 logarithm of the f5.6 multiplier we had just calculated (though we need its value from before we rounded it off).
We then output the result rounded to the nearest integer.
We do not need to worry about having more than four significant digits in this one: The result is most likely to have only one or two digits anyway.</p></div></div></div><div class=sect2><h3 id=x86-fpu-optimizations>A.13.4. FPU Optimizations<a class=anchor href=#x86-fpu-optimizations></a></h3><div class=paragraph><p>In assembly language we can optimize the FPU code in ways impossible in high languages, including C.</p></div><div class=paragraph><p>Whenever a C function needs to calculate a floating-point value, it loads all necessary variables and constants into FPU registers.
It then does whatever calculation is required to get the correct result.
Good C compilers can optimize that part of the code really well.</p></div><div class=paragraph><p>It "returns" the value by leaving the result on the TOS.
However, before it returns, it cleans up.
Any variables and constants it used in its calculation are now gone from the FPU.</p></div><div class=paragraph><p>It cannot do what we just did above: We calculated the square of the f-number and kept it on the stack for later use by another function.</p></div><div class=paragraph><p>We <em>knew</em> we would need that value later on.
We also knew we had enough room on the stack (which only has room for 8 numbers) to store it there.</p></div><div class=paragraph><p>A C compiler has no way of knowing that a value it has on the stack will be required again in the very near future.</p></div><div class=paragraph><p>Of course, the C programmer may know it.
But the only recourse he has is to store the value in a memory variable.</p></div><div class=paragraph><p>That means, for one, the value will be changed from the 80-bit precision used internally by the FPU to a C <em>double</em> (64 bits) or even <em>single</em> (32 bits).</p></div><div class=paragraph><p>That also means that the value must be moved from the TOS into the memory, and then back again.
Alas, of all FPU operations, the ones that access the computer memory are the slowest.</p></div><div class=paragraph><p>So, whenever programming the FPU in assembly language, look for the ways of keeping intermediate results on the FPU stack.</p></div><div class=paragraph><p>We can take that idea even further! In our program we are using a <em>constant</em> (the one we named <code>PC</code>).</p></div><div class=paragraph><p>It does not matter how many pinhole diameters we are calculating: 1, 10, 20, 1000, we are always using the same constant.
Therefore, we can optimize our program by keeping the constant on the stack all the time.</p></div><div class=paragraph><p>Early on in our program, we are calculating the value of the above constant.
We need to divide our input by <code>10</code> for every digit in the constant.</p></div><div class=paragraph><p>It is much faster to multiply than to divide.
So, at the start of our program, we divide <code>10</code> into <code>1</code> to obtain <code>0.1</code>, which we then keep on the stack: Instead of dividing the input by <code>10</code> for every digit, we multiply it by <code>0.1</code>.</p></div><div class=paragraph><p>By the way, we do not input <code>0.1</code> directly, even though we could.
We have a reason for that: While <code>0.1</code> can be expressed with just one decimal place, we do not know how many <em>binary</em> places it takes.
We, therefore, let the FPU calculate its binary value to its own high precision.</p></div><div class=paragraph><p>We are using other constants: We multiply the pinhole diameter by <code>1000</code> to convert it from millimeters to microns.
We compare numbers to <code>10000</code> when we are rounding them off to four significant digits.
So, we keep both, <code>1000</code> and <code>10000</code>, on the stack.
And, of course, we reuse the <code>0.1</code> when rounding off numbers to four digits.</p></div><div class=paragraph><p>Last but not least, we keep <code>-5</code> on the stack.
We need it to scale the square of the f-number, instead of dividing it by <code>32</code>.
It is not by coincidence we load this constant last.
That makes it the top of the stack when only the constants are on it.
So, when the square of the f-number is being scaled, the <code>-5</code> is at <code>st(1)</code>, precisely where <code>fscale</code> expects it to be.</p></div><div class=paragraph><p>It is common to create certain constants from scratch instead of loading them from the memory.
That is what we are doing with <code>-5</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>	fld1			; TOS =  1
	fadd	st0, st0	; TOS =  2
	fadd	st0, st0	; TOS =  4
	fld1			; TOS =  1
	faddp	st1, st0	; TOS =  5
	fchs			; TOS = -5</pre></div></div><div class=paragraph><p>We can generalize all these optimizations into one rule: <em>Keep repeat values on the stack!</em></p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><em>PostScript®</em> is a stack-oriented programming language.
There are many more books available about PostScript® than about the FPU assembly language: Mastering PostScript® will help you master the FPU.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-pinhole-the-code>A.13.5. pinhole-The Code<a class=anchor href=#x86-pinhole-the-code></a></h3><div class="literalblock programlisting"><div class=content><pre>;;;;;;; pinhole.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Find various parameters of a pinhole camera construction and use
;
; Started:	 9-Jun-2001
; Updated:	10-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
align 4
ten	dd	10
thousand	dd	1000
tthou	dd	10000
fd.in	dd	stdin
fd.out	dd	stdout
envar	db	&#39;PINHOLE=&#39;	; Exactly 8 bytes, or 2 dwords long
pinhole	db	&#39;04,&#39;, 		; Bender&#39;s constant (0.04)
connors	db	&#39;037&#39;, 0Ah	; Connors&#39; constant
usg	db	&#39;Usage: pinhole [-b] [-c] [-e] [-p &lt;value&gt;] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;pinhole: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;pinhole: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg
pinmsg	db	&#34;pinhole: The PINHOLE constant must not be 0&#34;, 0Ah
pinlen	equ	$-pinmsg
toobig	db	&#34;pinhole: The PINHOLE constant may not exceed 18 decimal places&#34;, 0Ah
biglen	equ	$-toobig
huhmsg	db	9, &#39;???&#39;
separ	db	9, &#39;???&#39;
sep2	db	9, &#39;???&#39;
sep3	db	9, &#39;???&#39;
sep4	db	9, &#39;???&#39;, 0Ah
huhlen	equ	$-huhmsg
header	db	&#39;focal length in millimeters,pinhole diameter in microns,&#39;
	db	&#39;F-number,normalized F-number,F-5.6 multiplier,stops &#39;
	db	&#39;from F-5.6&#39;, 0Ah
headlen	equ	$-header

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE
dbuffer	resb	20		; decimal input buffer
bbuffer	resb	10		; BCD buffer

section	.text
align 4
huh:
	call	write
	push	dword huhlen
	push	dword huhmsg
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	ret

align 4
perr:
	push	dword pinlen
	push	dword pinmsg
	push	dword stderr
	sys.write
	push	dword 4		; return failure
	sys.exit

align 4
consttoobig:
	push	dword biglen
	push	dword toobig
	push	dword stderr
	sys.write
	push	dword 5		; return failure
	sys.exit

align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	sub	esi, esi

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .getenv		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]
	inc	ecx

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.c
	or	ah, ah
	jne	.pcheck

	pop	ecx
	or	ecx, ecx
	je	near usage

	mov	ah, [ecx]

.pcheck:
	cmp	ah, &#39;0&#39;
	jl	near usage
	cmp	ah, &#39;9&#39;
	ja	near usage
	mov	esi, ecx
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	.b
	or	ah, ah
	jne	near usage
	mov	esi, connors
	jmp	.arg

.b:
	cmp	al, &#39;b&#39;
	jne	.e
	or	ah, ah
	jne	near usage
	mov	esi, pinhole
	jmp	.arg

.e:
	cmp	al, &#39;e&#39;
	jne	near usage
	or	ah, ah
	jne	near usage
	mov	al, &#39;,&#39;
	mov	[huhmsg], al
	mov	[separ], al
	mov	[sep2], al
	mov	[sep3], al
	mov	[sep4], al
	jmp	.arg

align 4
.getenv:
	; If ESI = 0, we did not have a -p argument,
	; and need to check the environment for &#34;PINHOLE=&#34;
	or	esi, esi
	jne	.init

	sub	ecx, ecx

.nextenv:
	pop	esi
	or	esi, esi
	je	.default	; no PINHOLE envar found

	; check if this envar starts with &#39;PINHOLE=&#39;
	mov	edi, envar
	mov	cl, 2		; &#39;PINHOLE=&#39; is 2 dwords long
rep	cmpsd
	jne	.nextenv

	; Check if it is followed by a digit
	mov	al, [esi]
	cmp	al, &#39;0&#39;
	jl	.default
	cmp	al, &#39;9&#39;
	jbe	.init
	; fall through

align 4
.default:
	; We got here because we had no -p argument,
	; and did not find the PINHOLE envar.
	mov	esi, pinhole
	; fall through

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	sub	edx, edx
	mov	edi, dbuffer+1
	mov	byte [dbuffer], &#39;0&#39;

	; Convert the pinhole constant to real
.constloop:
	lodsb
	cmp	al, &#39;9&#39;
	ja	.setconst
	cmp	al, &#39;0&#39;
	je	.processconst
	jb	.setconst

	inc	dl

.processconst:
	inc	cl
	cmp	cl, 18
	ja	near consttoobig
	stosb
	jmp	short .constloop

align 4
.setconst:
	or	dl, dl
	je	near perr

	finit
	fild	dword [tthou]

	fld1
	fild	dword [ten]
	fdivp	st1, st0

	fild	dword [thousand]
	mov	edi, obuffer

	mov	ebp, ecx
	call	bcdload

.constdiv:
	fmul	st0, st2
	loop	.constdiv

	fld1
	fadd	st0, st0
	fadd	st0, st0
	fld1
	faddp	st1, st0
	fchs

	; If we are creating a CSV file,
	; print header
	cmp	byte [separ], &#39;,&#39;
	jne	.bigloop

	push	dword headlen
	push	dword header
	push	dword [fd.out]
	sys.write

.bigloop:
	call	getchar
	jc	near done

	; Skip to the end of the line if you got &#39;#&#39;
	cmp	al, &#39;#&#39;
	jne	.num
	call	skiptoeol
	jmp	short .bigloop

.num:
	; See if you got a number
	cmp	al, &#39;0&#39;
	jl	.bigloop
	cmp	al, &#39;9&#39;
	ja	.bigloop

	; Yes, we have a number
	sub	ebp, ebp
	sub	edx, edx

.number:
	cmp	al, &#39;0&#39;
	je	.number0
	mov	dl, 1

.number0:
	or	dl, dl		; Skip leading 0&#39;s
	je	.nextnumber
	push	eax
	call	putchar
	pop	eax
	inc	ebp
	cmp	ebp, 19
	jae	.nextnumber
	mov	[dbuffer+ebp], al

.nextnumber:
	call	getchar
	jc	.work
	cmp	al, &#39;#&#39;
	je	.ungetc
	cmp	al, &#39;0&#39;
	jl	.work
	cmp	al, &#39;9&#39;
	ja	.work
	jmp	short .number

.ungetc:
	dec	esi
	inc	ebx

.work:
	; Now, do all the work
	or	dl, dl
	je	near .work0

	cmp	ebp, 19
	jae	near .toobig

	call	bcdload

	; Calculate pinhole diameter

	fld	st0	; save it
	fsqrt
	fmul	st0, st3
	fld	st0
	fmul	st5
	sub	ebp, ebp

	; Round off to 4 significant digits
.diameter:
	fcom	st0, st7
	fstsw	ax
	sahf
	jb	.printdiameter
	fmul	st0, st6
	inc	ebp
	jmp	short .diameter

.printdiameter:
	call	printnumber	; pinhole diameter

	; Calculate F-number

	fdivp	st1, st0
	fld	st0

	sub	ebp, ebp

.fnumber:
	fcom	st0, st6
	fstsw	ax
	sahf
	jb	.printfnumber
	fmul	st0, st5
	inc	ebp
	jmp	short .fnumber

.printfnumber:
	call	printnumber	; F number

	; Calculate normalized F-number
	fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1

	sub	ebp, ebp
	call	printnumber

	; Calculate time multiplier from F-5.6

	fscale
	fld	st0

	; Round off to 4 significant digits
.fmul:
	fcom	st0, st6
	fstsw	ax
	sahf

	jb	.printfmul
	inc	ebp
	fmul	st0, st5
	jmp	short .fmul

.printfmul:
	call	printnumber	; F multiplier

	; Calculate F-stops from 5.6

	fld1
	fxch	st1
	fyl2x

	sub	ebp, ebp
	call	printnumber

	mov	al, 0Ah
	call	putchar
	jmp	.bigloop

.work0:
	mov	al, &#39;0&#39;
	call	putchar

align 4
.toobig:
	call	huh
	jmp	.bigloop

align 4
done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	finit

	; return success
	push	dword 0
	sys.exit

align 4
skiptoeol:
	; Keep reading until you come to cr, lf, or eof
	call	getchar
	jc	done
	cmp	al, 0Ah
	jne	.cr
	ret

.cr:
	cmp	al, 0Dh
	jne	skiptoeol
	ret

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	clc
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.empty
	sub	eax, eax
	ret

align 4
.empty:
	add	esp, byte 4
	stc
	ret

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret

align 4
bcdload:
	; EBP contains the number of chars in dbuffer
	push	ecx
	push	esi
	push	edi

	lea	ecx, [ebp+1]
	lea	esi, [dbuffer+ebp-1]
	shr	ecx, 1

	std

	mov	edi, bbuffer
	sub	eax, eax
	mov	[edi], eax
	mov	[edi+4], eax
	mov	[edi+2], ax

.loop:
	lodsw
	sub	ax, 3030h
	shl	al, 4
	or	al, ah
	mov	[edi], al
	inc	edi
	loop	.loop

	fbld	[bbuffer]

	cld
	pop	edi
	pop	esi
	pop	ecx
	sub	eax, eax
	ret

align 4
printnumber:
	push	ebp
	mov	al, [separ]
	call	putchar

	; Print the integer at the TOS
	mov	ebp, bbuffer+9
	fbstp	[bbuffer]

	; Check the sign
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jns	.leading

	; We got a negative number (should never happen)
	mov	al, &#39;-&#39;
	call	putchar

.leading:
	; Skip leading zeros
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jne	.first
	cmp	ebp, bbuffer
	jae	.leading

	; We are here because the result was 0.
	; Print &#39;0&#39; and return
	mov	al, &#39;0&#39;
	jmp	putchar

.first:
	; We have found the first non-zero.
	; But it is still packed
	test	al, 0F0h
	jz	.second
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh

.second:
	add	al, &#39;0&#39;
	call	putchar

.next:
	cmp	ebp, bbuffer
	jb	.done

	mov	al, [ebp]
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh
	add	al, &#39;0&#39;
	call	putchar

	dec	ebp
	jmp	short .next

.done:
	pop	ebp
	or	ebp, ebp
	je	.ret

.zeros:
	mov	al, &#39;0&#39;
	call	putchar
	dec	ebp
	jne	.zeros

.ret:
	ret</pre></div></div><div class=paragraph><p>The code follows the same format as all the other filters we have seen before, with one subtle exception:</p></div><div class=quoteblock><blockquote><div class=paragraph><p>We are no longer assuming that the end of input implies the end of things to do, something we took for granted in the <em>character-oriented</em> filters.</p></div><div class=paragraph><p>This filter does not process characters. It processes a <em>language</em> (albeit a very simple one, consisting only of numbers).</p></div><div class=paragraph><p>When we have no more input, it can mean one of two things:</p></div><div class=ulist><ul><li><p>We are done and can quit. This is the same as before.</p></li><li><p>The last character we have read was a digit. We have stored it at the end of our ASCII-to-float conversion buffer. We now need to convert the contents of that buffer into a number and write the last line of our output.</p></li></ul></div><div class=paragraph><p>For that reason, we have modified our <code>getchar</code> and our <code>read</code> routines to return with the <code>carry flag</code> <em>clear</em> whenever we are fetching another character from the input, or the <code>carry flag</code> <em>set</em> whenever there is no more input.</p></div><div class=paragraph><p>Of course, we are still using assembly language magic to do that! Take a good look at <code>getchar</code>.
It <em>always</em> returns with the <code>carry flag</code> <em>clear</em>.</p></div><div class=paragraph><p>Yet, our main code relies on the <code>carry flag</code> to tell it when to quit-and it works.</p></div><div class=paragraph><p>The magic is in <code>read</code>.
Whenever it receives more input from the system, it just returns to <code>getchar</code>, which fetches a character from the input buffer, <em>clears</em> the <code>carry flag</code> and returns.</p></div><div class=paragraph><p>But when <code>read</code> receives no more input from the system, it does <em>not</em> return to <code>getchar</code> at all.
Instead, the <code>add esp, byte 4</code> op code adds <code>4</code> to <code>ESP</code>, <em>sets</em> the <code>carry flag</code>, and returns.</p></div><div class=paragraph><p>So, where does it return to? Whenever a program uses the <code>call</code> op code, the microprocessor <code>push</code>es the return address, i.e.,
it stores it on the top of the stack (not the FPU stack, the system stack, which is in the memory).
When a program uses the <code>ret</code> op code, the microprocessor <code>pop</code>s the return value from the stack, and jumps to the address that was stored there.</p></div><div class=paragraph><p>But since we added <code>4</code> to <code>ESP</code> (which is the stack pointer register), we have effectively given the microprocessor a minor case of <em>amnesia</em>: It no longer remembers it was <code>getchar</code> that <code>call</code>ed <code>read</code>.</p></div><div class=paragraph><p>And since <code>getchar</code> never <code>push</code>ed anything before <code>call</code>ing <code>read</code>, the top of the stack now contains the return address to whatever or whoever <code>call</code>ed <code>getchar</code>. As far as that caller is concerned, he <code>call</code>ed <code>getchar</code>, which <code>ret</code>urned with the <code>carry flag</code> set!</p></div></blockquote></div><div class=paragraph><p>Other than that, the <code>bcdload</code> routine is caught up in the middle of a Lilliputian conflict between the Big-Endians and the Little-Endians.</p></div><div class=paragraph><p>It is converting the text representation of a number into that number: The text is stored in the big-endian order, but the <em>packed decimal</em> is little-endian.</p></div><div class=paragraph><p>To solve the conflict, we use the <code>std</code> op code early on.
We cancel it with <code>cld</code> later on: It is quite important we do not <code>call</code> anything that may depend on the default setting of the <em>direction flag</em> while <code>std</code> is active.</p></div><div class=paragraph><p>Everything else in this code should be quit eclear, providing you have read the entire chapter that precedes it.</p></div><div class=paragraph><p>It is a classical example of the adage that programming requires a lot of thought and only a little coding.
Once we have thought through every tiny detail, the code almost writes itself.</p></div></div><div class=sect2><h3 id=x86-pinhole-using>A.13.6. Using pinhole<a class=anchor href=#x86-pinhole-using></a></h3><div class=paragraph><p>Because we have decided to make the program <em>ignore</em> any input except for numbers (and even those inside a comment), we can actually perform <em>textual queries</em>.
We do not <em>have to</em>, but we <em>can</em>.</p></div><div class=paragraph><p>In my humble opinion, forming a textual query, instead of having to follow a very strict syntax, makes software much more user friendly.</p></div><div class=paragraph><p>Suppose we want to build a pinhole camera to use the 4x5 inch film.
The standard focal length for that film is about 150mm.
We want to <em>fine-tune</em> our focal length so the pinhole diameter is as round a number as possible.
Let us also suppose we are quite comfortable with cameras but somewhat intimidated by computers.
Rather than just have to type in a bunch of numbers, we want to <em>ask</em> a couple of questions.</p></div><div class=paragraph><p>Our session might look like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pinhole

Computer,

What size pinhole <span class=k>do </span>I need <span class=k>for </span>the focal length of 150?
150	490	306	362	2930	12
Hmmm... How about 160?
160	506	316	362	3125	12
Let<span class=s1>&#39;s make it 155, please.
155	498	311	362	3027	12
Ah, let&#39;</span>s try 157...
157	501	313	362	3066	12
156?
156	500	312	362	3047	12
That<span class=s1>&#39;s it! Perfect! Thank you very much!
^D</span></code></pre></div></div><div class=paragraph><p>We have found that while for the focal length of 150, our pinhole diameter should be 490 microns, or 0.49 mm, if we go with the almost identical focal length of 156 mm, we can get away with a pinhole diameter of exactly one half of a millimeter.</p></div></div><div class=sect2><h3 id=x86-pinhole-scripting>A.13.7. Scripting<a class=anchor href=#x86-pinhole-scripting></a></h3><div class=paragraph><p>Because we have chosen the <code>#</code> character to denote the start of a comment, we can treat our pinhole software as a <em>scripting language</em>.</p></div><div class=paragraph><p>You have probably seen shell <em>scripts</em> that start with:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh</pre></div></div><div class=paragraph><p>…​or…​</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh</pre></div></div><div class=paragraph><p>…​because the blank space after the <code>#!</code> is optional.</p></div><div class=paragraph><p>Whenever UNIX® is asked to run an executable file which starts with the <code>#!</code>, it assumes the file is a script.
It adds the command to the rest of the first line of the script, and tries to execute that.</p></div><div class=paragraph><p>Suppose now that we have installed pinhole in /usr/local/bin/, we can now write a script to calculate various pinhole diameters suitable for various focal lengths commonly used with the 120 film.</p></div><div class=paragraph><p>The script might look something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /usr/local/bin/pinhole -b -i
# Find the best pinhole diameter
# for the 120 film

### Standard
80

### Wide angle
30, 40, 50, 60, 70

### Telephoto
100, 120, 140</pre></div></div><div class=paragraph><p>Because 120 is a medium size film, we may name this file medium.</p></div><div class=paragraph><p>We can set its permissions to execute, and run it as if it were a program:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>755 medium
% ./medium</code></pre></div></div><div class=paragraph><p>UNIX® will interpret that last command as:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium</code></pre></div></div><div class=paragraph><p>It will run that command and display:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	358	224	256	1562	11
30	219	137	128	586	9
40	253	158	181	781	10
50	283	177	181	977	10
60	310	194	181	1172	10
70	335	209	181	1367	10
100	400	250	256	1953	11
120	438	274	256	2344	11
140	473	296	256	2734	11</code></pre></div></div><div class=paragraph><p>Now, let us enter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>UNIX® will treat that as:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>That gives it two conflicting options: <code>-b</code> and <code>-c</code> (Use Bender’s constant and use Connors' constant).
We have programmed it so later options override early ones-our program will calculate everything using Connors' constant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	331	242	256	1826	11
30	203	148	128	685	9
40	234	171	181	913	10
50	262	191	181	1141	10
60	287	209	181	1370	10
70	310	226	256	1598	11
100	370	270	256	2283	11
120	405	296	256	2739	11
140	438	320	362	3196	12</code></pre></div></div><div class=paragraph><p>We decide we want to go with Bender’s constant after all.
We want to save its values as a comma-separated file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-b</span> <span class=nt>-e</span> <span class=o>&gt;</span> bender
% <span class=nb>cat </span>bender
focal length <span class=k>in </span>millimeters,pinhole diameter <span class=k>in </span>microns,F-number,normalized F-number,F-5.6 multiplier,stops from F-5.6
80,358,224,256,1562,11
30,219,137,128,586,9
40,253,158,181,781,10
50,283,177,181,977,10
60,310,194,181,1172,10
70,335,209,181,1367,10
100,400,250,256,1953,11
120,438,274,256,2344,11
140,473,296,256,2734,11
%</code></pre></div></div></div></div></div><div class=sect1><h2 id=x86-caveats>A.14. Caveats<a class=anchor href=#x86-caveats></a></h2><div class=sectionbody><div class=paragraph><p>Assembly language programmers who "grew up" under MS-DOS® and Windows® often tend to take shortcuts.
Reading the keyboard scan codes and writing directly to video memory are two classical examples of practices which, under MS-DOS® are not frowned upon but considered the right thing to do.</p></div><div class=paragraph><p>The reason? Both the PC BIOS and MS-DOS® are notoriously slow when performing these operations.</p></div><div class=paragraph><p>You may be tempted to continue similar practices in the UNIX® environment.
For example, I have seen a web site which explains how to access the keyboard scan codes on a popular UNIX® clone.</p></div><div class=paragraph><p>That is generally a <em>very bad idea</em> in UNIX® environment! Let me explain why.</p></div><div class=sect2><h3 id=x86-protected>A.14.1. UNIX® Is Protected<a class=anchor href=#x86-protected></a></h3><div class=paragraph><p>For one thing, it may simply not be possible.
UNIX® runs in protected mode.
Only the kernel and device drivers are allowed to access hardware directly.
Perhaps a particular UNIX® clone will let you read the keyboard scan codes, but chances are a real UNIX® operating system will not.
And even if one version may let you do it, the next one may not, so your carefully crafted software may become a dinosaur overnight.</p></div></div><div class=sect2><h3 id=x86-abstraction>A.14.2. UNIX® Is an Abstraction<a class=anchor href=#x86-abstraction></a></h3><div class=paragraph><p>But there is a much more important reason not to try accessing the hardware directly (unless, of course, you are writing a device driver), even on the UNIX® like systems that let you do it:</p></div><div class=paragraph><p><em>UNIX® is an abstraction!</em></p></div><div class=paragraph><p>There is a major difference in the philosophy of design between MS-DOS® and UNIX®.
MS-DOS® was designed as a single-user system.
It is run on a computer with a keyboard and a video screen attached directly to that computer.
User input is almost guaranteed to come from that keyboard.
Your program’s output virtually always ends up on that screen.</p></div><div class=paragraph><p>This is NEVER guaranteed under UNIX®.
It is quite common for a UNIX® user to pipe and redirect program input and output:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% program1 | program2 | program3 <span class=o>&gt;</span> file1</code></pre></div></div><div class=paragraph><p>If you have written program2, your input does not come from the keyboard but from the output of program1.
Similarly, your output does not go to the screen but becomes the input for program3 whose output, in turn, goes to <span class=filename>file1</span>.</p></div><div class=paragraph><p>But there is more! Even if you made sure that your input comes from, and your output goes to, the terminal, there is no guarantee the terminal is a PC: It may not have its video memory where you expect it, nor may its keyboard be producing PC-style scan codes.
It may be a Macintosh®, or any other computer.</p></div><div class=paragraph><p>Now you may be shaking your head: My software is in PC assembly language, how can it run on a Macintosh®? But I did not say your software would be running on a Macintosh®, only that its terminal may be a Macintosh®.</p></div><div class=paragraph><p>Under UNIX®, the terminal does not have to be directly attached to the computer that runs your software, it can even be on another continent, or, for that matter, on another planet.
It is perfectly possible that a Macintosh® user in Australia connects to a UNIX® system in North America (or anywhere else) via telnet.
The software then runs on one computer, while the terminal is on a different computer: If you try to read the scan codes, you will get the wrong input!</p></div><div class=paragraph><p>Same holds true about any other hardware: A file you are reading may be on a disk you have no direct access to.
A camera you are reading images from may be on a space shuttle, connected to you via satellites.</p></div><div class=paragraph><p>That is why under UNIX® you must never make any assumptions about where your data is coming from and going to.
Always let the system handle the physical access to the hardware.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>These are caveats, not absolute rules.
Exceptions are possible.
For example, if a text editor has determined it is running on a local machine, it may want to read the scan codes directly for improved control.
I am not mentioning these caveats to tell you what to do or what not to do, just to make you aware of certain pitfalls that await you if you have just arrived to UNIX® form MS-DOS®.
Of course, creative people often break rules, and it is OK as long as they know they are breaking them and why.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=x86-acknowledgements>A.15. Acknowledgements<a class=anchor href=#x86-acknowledgements></a></h2><div class=sectionbody><div class=paragraph><p>This tutorial would never have been possible without the help of many experienced FreeBSD programmers from the <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions mailing list</a>, many of whom have patiently answered my questions, and pointed me in the right direction in my attempts to explore the inner workings of UNIX® system programming in general and FreeBSD in particular.</p></div><div class=paragraph><p>Thomas M. Sommers opened the door for me .
His <a href=https://web.archive.org/web/20090914064615/http://www.codebreakers-journal.com/content/view/262/27>How do I write "Hello, world" in FreeBSD assembler?</a> web page was my first encounter with an example of assembly language programming under FreeBSD.</p></div><div class=paragraph><p>Jake Burkholder has kept the door open by willingly answering all of my questions and supplying me with example assembly language source code.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. All rights reserved.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: August 11, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=557464e66e" target=_blank>Fernando Apesteguía</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/en/books/developers-handbook/partiv class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/en/books/developers-handbook/partv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#x86-intro>A.1. Synopsis</a></li><li><a href=#x86-the-tools>A.2. The Tools</a></li><li><a href=#x86-system-calls>A.3. System Calls</a></li><li><a href=#x86-return-values>A.4. Return Values</a></li><li><a href=#x86-portable-code>A.5. Creating Portable Code</a></li><li><a href=#x86-first-program>A.6. Our First Program</a></li><li><a href=#x86-unix-filters>A.7. Writing UNIX® Filters</a></li><li><a href=#x86-buffered-io>A.8. Buffered Input and Output</a></li><li><a href=#x86-command-line>A.9. Command Line Arguments</a></li><li><a href=#x86-environment>A.10. UNIX® Environment</a></li><li><a href=#x86-files>A.11. Working with Files</a></li><li><a href=#x86-one-pointed-mind>A.12. One-Pointed Mind</a></li><li><a href=#x86-fpu>A.13. Using the FPU</a></li><li><a href=#x86-caveats>A.14. Caveats</a></li><li><a href=#x86-acknowledgements>A.15. Acknowledgements</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/developers-handbook/developers-handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/en/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>