<!doctype html><html class=theme-light lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="FreeBSD Kernel Debugging"><meta name=keywords content="Debugging,Dump,kgdb,DDB,GDB"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/><title>Chapter 10. Kernel Debugging | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapter 10. Kernel Debugging"><meta property="og:description" content="FreeBSD Kernel Debugging"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/en\/books\/developers-handbook\/kerneldebug\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=https://docs.freebsd.org/en/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/en/books>Books</a></li><li><a href=https://docs.freebsd.org/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/parti/>Part I. Basics</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/introduction/>Chapter 1. Introduction</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/introduction/#introduction-devel>1.1. Developing on FreeBSD</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/introduction/#introduction-bsdvision>1.2. The BSD Vision</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/introduction/#introduction-archguide>1.3. Architectural Guidelines</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/introduction/#introduction-layout>1.4. The Layout of /usr/src</a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/>Chapter 2. Programming Tools</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#tools-synopsis>2.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#tools-intro>2.2. Introduction</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#tools-programming>2.3. Introduction to Programming</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#tools-compiling>2.4. Compiling with <code>cc</code></a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#debugging>2.6. Debugging</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#emacs>2.7. Using Emacs as a Development Environment</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/tools/#tools-reading>2.8. Further Reading</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/>Chapter 3. Secure Programming</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/#secure-synopsis>3.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/#secure-philosophy>3.2. Secure Design Methodology</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/#secure-bufferov>3.3. Buffer Overflows</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/#secure-setuid>3.4. SetUID issues</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/#secure-chroot>3.5. Limiting your program’s environment</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/#secure-trust>3.6. Trust</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/secure/#secure-race-conditions>3.7. Race Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/l10n/>Chapter 4. Localization and Internationalization - L10N and I18N</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/l10n/#l10n-programming>4.1. Programming I18N Compliant Applications</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/l10n/#posix-nls>4.2. Localized Messages with POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/policies/>Chapter 5. Source Tree Guidelines and Policies</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/policies/#policies-style>5.1. Style Guidelines</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> on Makefiles</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/policies/#policies-contributed>5.3. Contributed Software</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/policies/#policies-encumbered>5.4. Encumbered Files</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/policies/#policies-shlib>5.5. Shared Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/testing/>Chapter 6. Regression and Performance Testing</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Micro Benchmark Checklist</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/testing/#testing-tinderbox>6.2. The FreeBSD Source Tinderbox</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/testing/#_the_index_cgi_script>6.3. The index.cgi Script</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/testing/#_official_build_servers>6.4. Official Build Servers</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/testing/#_official_summary_site>6.5. Official Summary Site</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/partii/>Part II. Interprocess Communication</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle>
<label class="icon cursor" for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/>Chapter 7. Sockets</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-synopsis>7.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-diversity>7.2. Networking and Diversity</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-protocols>7.3. Protocols</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-model>7.4. The Sockets Model</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-essential-functions>7.5. Essential Socket Functions</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-helper-functions>7.6. Helper Functions</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-concurrent-servers>7.7. Concurrent Servers</a></li></ul></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/ipv6/>Chapter 8. IPv6 Internals</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec Implementation</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/partiii/>Part III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/kernelbuild/>Chapter 9. Building and Installing a FreeBSD Kernel</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Building the Faster but Brittle Way</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle checked>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/>Chapter 10. Kernel Debugging</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code></a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-console>10.5. Debugging a Console Driver</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.6. Debugging Deadlocks</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-dcons>10.7. Kernel debugging with Dcons</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossary of Kernel Options for Debugging</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/partiv/>Part IV. Architectures</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/>Chapter 11. x86 Assembly Language Programming</a><ul><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-intro>A.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-the-tools>A.2. The Tools</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-system-calls>A.3. System Calls</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-return-values>A.4. Return Values</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-portable-code>A.5. Creating Portable Code</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-first-program>A.6. Our First Program</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-unix-filters>A.7. Writing UNIX® Filters</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-buffered-io>A.8. Buffered Input and Output</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-command-line>A.9. Command Line Arguments</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-environment>A.10. UNIX® Environment</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-files>A.11. Working with Files</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-one-pointed-mind>A.12. One-Pointed Mind</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-fpu>A.13. Using the FPU</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-caveats>A.14. Caveats</a></li><li><a href=https://docs.freebsd.org/en/books/developers-handbook/x86/#x86-acknowledgements>A.15. Acknowledgements</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/partv/>Part V. Appendices</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=https://docs.freebsd.org/en/books/developers-handbook/bibliography/>Bibliography</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapter 10. Kernel Debugging</h1><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump</a></li><li><a href=#kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code></a></li><li><a href=#kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB</a></li><li><a href=#kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB</a></li><li><a href=#kerneldebug-console>10.5. Debugging a Console Driver</a></li><li><a href=#kerneldebug-deadlocks>10.6. Debugging Deadlocks</a></li><li><a href=#kerneldebug-dcons>10.7. Kernel debugging with Dcons</a></li><li><a href=#kerneldebug-options>10.8. Glossary of Kernel Options for Debugging</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump<a class=anchor href=#kerneldebug-obtain></a></h2><div class=sectionbody><div class=paragraph><p>When running a development kernel (e.g., FreeBSD-CURRENT), such as a kernel under extreme conditions (e.g., very high load averages, tens of thousands of connections, exceedingly high number of concurrent users, hundreds of <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>s, etc.),
or using a new feature or device driver on FreeBSD-STABLE (e.g., PAE), sometimes a kernel will panic.
In the event that it does, this chapter will demonstrate how to extract useful information out of a crash.</p></div><div class=paragraph><p>A system reboot is inevitable once a kernel panics.
Once a system is rebooted, the contents of a system’s physical memory (RAM) is lost, as well as any bits that are on the swap device before the panic.
To preserve the bits in physical memory, the kernel makes use of the swap device as a temporary place to store the bits that are in RAM across a reboot after a crash.
In doing this, when FreeBSD boots after a crash, a kernel image can now be extracted and debugging can take place.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A swap device that has been configured as a dump device still acts as a swap device.
Dumps to non-swap devices (such as tapes or CDRWs, for example) are not supported at this time.
A "swap device" is synonymous with a "swap partition."</p></div></td></tr></tbody></table></div><div class=paragraph><p>Several types of kernel crash dumps are available:</p></div><div class=dlist><dl><dt class=hdlist1>Full memory dumps</dt><dd><p>Hold the complete contents of physical memory.</p></dd><dt class=hdlist1>Minidumps</dt><dd><p>Hold only memory pages in use by the kernel (FreeBSD 6.2 and higher).</p></dd><dt class=hdlist1>Textdumps</dt><dd><p>Hold captured, scripted, or interactive debugger output (FreeBSD 7.1 and higher).</p></dd></dl></div><div class=paragraph><p>Minidumps are the default dump type as of FreeBSD 7.0, and in most cases will capture all necessary information present in a full memory dump, as most problems can be isolated only using kernel state.</p></div><div class=sect2><h3 id=config-dumpdev>10.1.1. Configuring the Dump Device<a class=anchor href=#config-dumpdev></a></h3><div class=paragraph><p>Before the kernel will dump the contents of its physical memory to a dump device, a dump device must be configured.
A dump device is specified by using the <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> command to tell the kernel where to save kernel crash dumps.
The <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> program must be called after the swap partition has been configured with <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>.
This is normally handled by setting the <code>dumpdev</code> variable in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> to the path of the swap device (the recommended way to extract a kernel dump) or <code>AUTO</code> to use the first configured swap device.
The default for <code>dumpdev</code> is <code>AUTO</code> in HEAD, and changed to <code>NO</code> on RELENG_* branches (except for RELENG_7, which was left set to <code>AUTO</code>).
On FreeBSD 9.0-RELEASE and later versions, bsdinstall will ask whether crash dumps should be enabled on the target system during the install process.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Check <span class=filename>/etc/fstab</span> or <a href="https://man.freebsd.org/cgi/man.cgi?query=swapinfo&amp;sektion=8&amp;format=html">swapinfo(8)</a> for a list of swap devices.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Make sure the <code>dumpdir</code> specified in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> exists before a kernel crash!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># mkdir /var/crash</span>
<span class=c># chmod 700 /var/crash</span></code></pre></div></div><div class=paragraph><p>Also, remember that the contents of <span class=filename>/var/crash</span> is sensitive and very likely contains confidential information such as passwords.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=extract-dump>10.1.2. Extracting a Kernel Dump<a class=anchor href=#extract-dump></a></h3><div class=paragraph><p>Once a dump has been written to a dump device, the dump must be extracted before the swap device is mounted.
To extract a dump from a dump device, use the <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> program.
If <code>dumpdev</code> has been set in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> will be called automatically on the first multi-user boot after the crash and before the swap device is mounted.
The location of the extracted core is placed in the <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> value <code>dumpdir</code>, by default <span class=filename>/var/crash</span> and will be named <span class=filename>vmcore.0</span>.</p></div><div class=paragraph><p>In the event that there is already a file called <span class=filename>vmcore.0</span> in <span class=filename>/var/crash</span> (or whatever <code>dumpdir</code> is set to), the kernel will increment the trailing number for every crash to avoid overwriting an existing <span class=filename>vmcore</span> (e.g., <span class=filename>vmcore.1</span>).
<a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> will always create a symbolic link to named <span class=filename>vmcore.last</span> in <span class=filename>/var/crash</span> after a dump is saved.
This symbolic link can be used to locate the name of the most recent dump.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=crashinfo&amp;sektion=8&amp;format=html">crashinfo(8)</a> utility generates a text file containing a summary of information from a full memory dump or minidump.
If <code>dumpdev</code> has been set in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=crashinfo&amp;sektion=8&amp;format=html">crashinfo(8)</a> will be invoked automatically after <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a>.
The output is saved to a file in <code>dumpdir</code> named <span class=filename>core.txt.N</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If you are testing a new kernel but need to boot a different one in order to get your system up and running again,
boot it only into single user mode using the <code>-s</code> flag at the boot prompt, and then perform the following steps:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># fsck -p</span>
<span class=c># mount -a -t ufs       # make sure /var/crash is writable</span>
<span class=c># savecore /var/crash /dev/ad0s1b</span>
<span class=c># exit                  # exit to multi-user</span></code></pre></div></div><div class=paragraph><p>This instructs <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> to extract a kernel dump from <span class=filename>/dev/ad0s1b</span> and place the contents in <span class=filename>/var/crash</span>.
Do not forget to make sure the destination directory <span class=filename>/var/crash</span> has enough space for the dump.
Also, do not forget to specify the correct path to your swap device as it is likely different than <span class=filename>/dev/ad0s1b</span>!</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_testing_kernel_dump_configuration>10.1.3. Testing Kernel Dump Configuration<a class=anchor href=#_testing_kernel_dump_configuration></a></h3><div class=paragraph><p>The kernel includes a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> node that requests a kernel panic.
This can be used to verify that your system is properly configured to save kernel crash dumps.
You may wish to remount existing file systems as read-only in single user mode before triggering the crash to avoid data loss.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># shutdown now</span>
...
Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># mount -a -u -r</span>
<span class=c># sysctl debug.kdb.panic=1</span>
debug.kdb.panic:panic: kdb_sysctl_panic
...</code></pre></div></div><div class=paragraph><p>After rebooting, your system should save a dump in <span class=filename>/var/crash</span> along with a matching summary from <a href="https://man.freebsd.org/cgi/man.cgi?query=crashinfo&amp;sektion=8&amp;format=html">crashinfo(8)</a>.</p></div></div></div></div><div class=sect1><h2 id=kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code><a class=anchor href=#kerneldebug-gdb></a></h2><div class=sectionbody><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This section covers <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a>.
The latest version is included in the <a class=package href=https://cgit.freebsd.org/ports/tree/devel/gdb/>devel/gdb</a>.
An older version is also present in FreeBSD 11 and earlier.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To enter into the debugger and begin getting information from the dump, start kgdb:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># kgdb -n N</span></code></pre></div></div><div class=paragraph><p>Where <em>N</em> is the suffix of the <span class=filename>vmcore.N</span> to examine.
To open the most recent dump use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># kgdb -n last</span></code></pre></div></div><div class=paragraph><p>Normally, <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> should be able to locate the kernel running at the time the dump was generated.
If it is not able to locate the correct kernel, pass the pathname of the kernel and dump as two arguments to kgdb:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># kgdb /boot/kernel/kernel /var/crash/vmcore.0</span></code></pre></div></div><div class=paragraph><p>You can debug the crash dump using the kernel sources just like you can for any other program.</p></div><div class=paragraph><p>This dump is from a 5.2-BETA kernel and the crash comes from deep within the kernel.
The output below has been modified to include line numbers on the left.
This first trace inspects the instruction pointer and obtains a back trace.
The address that is used on line 41 for the <code>list</code> command is the instruction pointer and can be found on line 17.
Most developers will request having at least this information sent to them if you are unable to debug the problem yourself.
If, however, you do solve the problem, make sure that your patch winds its way into the source tree via a problem report, mailing lists, or by being able to commit it!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> 1:# <span class=nb>cd</span> /usr/obj/usr/src/sys/KERNCONF
 2:# kgdb kernel.debug /var/crash/vmcore.0
 3:GNU gdb 5.2.1 <span class=o>(</span>FreeBSD<span class=o>)</span>
 4:Copyright 2002 Free Software Foundation, Inc.
 5:GDB is free software, covered by the GNU General Public License, and you are
 6:welcome to change it and/or distribute copies of it under certain conditions.
 7:Type <span class=s2>&#34;show copying&#34;</span> to see the conditions.
 8:There is absolutely no warranty <span class=k>for </span>GDB.  Type <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
 9:This GDB was configured as <span class=s2>&#34;i386-undermydesk-freebsd&#34;</span>...
10:panic: page fault
11:panic messages:
12:---
13:Fatal <span class=nb>trap </span>12: page fault <span class=k>while in </span>kernel mode
14:cpuid <span class=o>=</span> 0<span class=p>;</span> apic <span class=nb>id</span> <span class=o>=</span> 00
15:fault virtual address   <span class=o>=</span> 0x300
16:fault code:             <span class=o>=</span> supervisor <span class=nb>read</span>, page not present
17:instruction pointer     <span class=o>=</span> 0x8:0xc0713860
18:stack pointer           <span class=o>=</span> 0x10:0xdc1d0b70
19:frame pointer           <span class=o>=</span> 0x10:0xdc1d0b7c
20:code segment            <span class=o>=</span> base 0x0, limit 0xfffff, <span class=nb>type </span>0x1b
21:                        <span class=o>=</span> DPL 0, pres 1, def32 1, gran 1
22:processor eflags        <span class=o>=</span> resume, IOPL <span class=o>=</span> 0
23:current process         <span class=o>=</span> 14394 <span class=o>(</span><span class=nb>uname</span><span class=o>)</span>
24:trap number             <span class=o>=</span> 12
25:panic: page fault
26      cpuid <span class=o>=</span> 0<span class=p>;</span>
27:Stack backtrace:
28
29:syncing disks, buffers remaining... 2199 2199 panic: mi_switch: switch <span class=k>in </span>a critical section
30:cpuid <span class=o>=</span> 0<span class=p>;</span>
31:Uptime: 2h43m19s
32:Dumping 255 MB
33: 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
34:---
35:Reading symbols from /boot/kernel/snd_maestro3.ko...done.
36:Loaded symbols <span class=k>for</span> /boot/kernel/snd_maestro3.ko
37:Reading symbols from /boot/kernel/snd_pcm.ko...done.
38:Loaded symbols <span class=k>for</span> /boot/kernel/snd_pcm.ko
39:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
40:240             dumping++<span class=p>;</span>
41:<span class=o>(</span>kgdb<span class=o>)</span> list <span class=k>*</span>0xc0713860
42:0xc0713860 is <span class=k>in </span>lapic_ipi_wait <span class=o>(</span>/usr/src/sys/i386/i386/local_apic.c:663<span class=o>)</span><span class=nb>.</span>
43:658                     incr <span class=o>=</span> 0<span class=p>;</span>
44:659                     delay <span class=o>=</span> 1<span class=p>;</span>
45:660             <span class=o>}</span> <span class=k>else
</span>46:661                     incr <span class=o>=</span> 1<span class=p>;</span>
47:662             <span class=k>for</span> <span class=o>(</span>x <span class=o>=</span> 0<span class=p>;</span> x &lt; delay<span class=p>;</span> x +<span class=o>=</span> incr<span class=o>)</span> <span class=o>{</span>
48:663                     <span class=k>if</span> <span class=o>((</span>lapic-&gt;icr_lo &amp; APIC_DELSTAT_MASK<span class=o>)</span> <span class=o>==</span> APIC_DELSTAT_IDLE<span class=o>)</span>
49:664                             <span class=k>return</span> <span class=o>(</span>1<span class=o>)</span><span class=p>;</span>
50:665                     ia32_pause<span class=o>()</span><span class=p>;</span>
51:666             <span class=o>}</span>
52:667             <span class=k>return</span> <span class=o>(</span>0<span class=o>)</span><span class=p>;</span>
53:<span class=o>(</span>kgdb<span class=o>)</span> backtrace
54:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
55:#1  0xc055fd9b <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>260<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:372
56:#2  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
57:#3  0xc0567ef5 <span class=k>in </span>mi_switch <span class=o>()</span> at /usr/src/sys/kern/kern_synch.c:470
58:#4  0xc055fa87 <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>256<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:312
59:#5  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
60:#6  0xc0720c66 <span class=k>in </span>trap_fatal <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>0xdc1d0b30, <span class=nv>eva</span><span class=o>=</span>0<span class=o>)</span>
61:    at /usr/src/sys/i386/i386/trap.c:821
62:#7  0xc07202b3 <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
63:      <span class=o>{</span>tf_fs <span class=o>=</span> <span class=nt>-1065484264</span>, tf_es <span class=o>=</span> <span class=nt>-1065484272</span>, tf_ds <span class=o>=</span> <span class=nt>-1065484272</span>, tf_edi <span class=o>=</span> 1, tf_esi <span class=o>=</span> 0, tf_ebp <span class=o>=</span> <span class=nt>-602076292</span>, tf_isp <span class=o>=</span> <span class=nt>-602076324</span>, tf_ebx <span class=o>=</span> 0, tf_edx <span class=o>=</span> 0, tf_ecx <span class=o>=</span> 1000000, tf_eax <span class=o>=</span> 243, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 0, tf_eip <span class=o>=</span> <span class=nt>-1066321824</span>, tf_cs <span class=o>=</span> 8, tf_eflags <span class=o>=</span> 65671, tf_esp <span class=o>=</span> 243, tf_ss <span class=o>=</span> 0<span class=o>})</span>
64:    at /usr/src/sys/i386/i386/trap.c:250
65:#8  0xc070c9f8 <span class=k>in </span>calltrap <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:94
66:#9  0xc07139f3 <span class=k>in </span>lapic_ipi_vectored <span class=o>(</span><span class=nv>vector</span><span class=o>=</span>0, <span class=nv>dest</span><span class=o>=</span>0<span class=o>)</span>
67:    at /usr/src/sys/i386/i386/local_apic.c:733
68:#10 0xc0718b23 <span class=k>in </span>ipi_selected <span class=o>(</span><span class=nv>cpus</span><span class=o>=</span>1, <span class=nv>ipi</span><span class=o>=</span>1<span class=o>)</span>
69:    at /usr/src/sys/i386/i386/mp_machdep.c:1115
70:#11 0xc057473e <span class=k>in </span>kseq_notify <span class=o>(</span><span class=nv>ke</span><span class=o>=</span>0xcc05e360, <span class=nv>cpu</span><span class=o>=</span>0<span class=o>)</span>
71:    at /usr/src/sys/kern/sched_ule.c:520
72:#12 0xc0575cad <span class=k>in </span>sched_add <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
73:    at /usr/src/sys/kern/sched_ule.c:1366
74:#13 0xc05666c6 <span class=k>in </span>setrunqueue <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcc05e360<span class=o>)</span>
75:    at /usr/src/sys/kern/kern_switch.c:422
76:#14 0xc05752f4 <span class=k>in </span>sched_wakeup <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
77:    at /usr/src/sys/kern/sched_ule.c:999
78:#15 0xc056816c <span class=k>in </span>setrunnable <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
79:    at /usr/src/sys/kern/kern_synch.c:570
80:#16 0xc0567d53 <span class=k>in </span>wakeup <span class=o>(</span><span class=nv>ident</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
81:    at /usr/src/sys/kern/kern_synch.c:411
82:#17 0xc05490a8 <span class=k>in </span>exit1 <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5b40, <span class=nv>rv</span><span class=o>=</span>0<span class=o>)</span>
83:    at /usr/src/sys/kern/kern_exit.c:509
84:#18 0xc0548011 <span class=k>in </span>sys_exit <span class=o>()</span> at /usr/src/sys/kern/kern_exit.c:102
85:#19 0xc0720fd0 <span class=k>in </span>syscall <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
86:      <span class=o>{</span>tf_fs <span class=o>=</span> 47, tf_es <span class=o>=</span> 47, tf_ds <span class=o>=</span> 47, tf_edi <span class=o>=</span> 0, tf_esi <span class=o>=</span> <span class=nt>-1</span>, tf_ebp <span class=o>=</span> <span class=nt>-1077940712</span>, tf_isp <span class=o>=</span> <span class=nt>-602075788</span>, tf_ebx <span class=o>=</span> 672411944, tf_edx <span class=o>=</span> 10, tf_ecx <span class=o>=</span> 672411600, tf_eax <span class=o>=</span> 1, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 2, tf_eip <span class=o>=</span> 671899563, tf_cs <span class=o>=</span> 31, tf_eflags <span class=o>=</span> 642, tf_esp <span class=o>=</span> <span class=nt>-1077940740</span>, tf_ss <span class=o>=</span> 47<span class=o>})</span>
87:    at /usr/src/sys/i386/i386/trap.c:1010
88:#20 0xc070ca4d <span class=k>in </span>Xint0x80_syscall <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:136
89:---Can<span class=s1>&#39;t read userspace from dump, or kernel process---
90:(kgdb) quit</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If your system is crashing regularly and you are running out of disk space,
deleting old <span class=filename>vmcore</span> files in <span class=filename>/var/crash</span> could save a considerable amount of disk space!</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB<a class=anchor href=#kerneldebug-online-ddb></a></h2><div class=sectionbody><div class=paragraph><p>While <code>kgdb</code> as an off-line debugger provides a very high level of user interface, there are some things it cannot do.
The most important ones being breakpointing and single-stepping kernel code.</p></div><div class=paragraph><p>If you need to do low-level debugging on your kernel, there is an on-line debugger available called DDB.
It allows setting of breakpoints, single-stepping kernel functions, examining and changing kernel variables, etc.
However, it cannot access kernel source files, and only has access to the global and static symbols, not to the full debug information like <code>kgdb</code> does.</p></div><div class=paragraph><p>To configure your kernel to include DDB, add the options</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB</pre></div></div><div class="literalblock programlisting"><div class=content><pre>options DDB</pre></div></div><div class=paragraph><p>to your config file, and rebuild.
(See <a href=https://docs.freebsd.org/en/books/handbook/>The FreeBSD Handbook</a> for details on configuring the FreeBSD kernel).</p></div><div class=paragraph><p>Once your DDB kernel is running, there are several ways to enter DDB.
The first, and earliest way is to use the boot flag <code>-d</code>.
The kernel will start up in debug mode and enter DDB prior to any device probing.
Hence you can even debug the device probe/attach functions.
To use this, exit the loader’s boot menu and enter <code>boot -d</code> at the loader prompt.</p></div><div class=paragraph><p>The second scenario is to drop to the debugger once the system has booted.
There are two simple ways to accomplish this.
If you would like to break to the debugger from the command prompt, simply type the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># sysctl debug.kdb.enter=1</span></code></pre></div></div><div class=paragraph><p>Alternatively, if you are at the system console, you may use a hot-key on the keyboard.
The default break-to-debugger sequence is <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>ESC</kbd></span>.
For syscons, this sequence can be remapped and some of the distributed maps out there do this, so check to make sure you know the right sequence to use.
There is an option available for serial consoles that allows the use of a serial line BREAK on the console line to enter DDB (<code>options BREAK_TO_DEBUGGER</code> in the kernel config file).
It is not the default since there are a lot of serial adapters around that gratuitously generate a BREAK condition, for example when pulling the cable.</p></div><div class=paragraph><p>The third way is that any panic condition will branch to DDB if the kernel is configured to use it.
For this reason, it is not wise to configure a kernel with DDB for a machine running unattended.</p></div><div class=paragraph><p>To obtain the unattended functionality, add:</p></div><div class="literalblock programlisting"><div class=content><pre>options	KDB_UNATTENDED</pre></div></div><div class=paragraph><p>to the kernel configuration file and rebuild/reinstall.</p></div><div class=paragraph><p>The DDB commands roughly resemble some <code>gdb</code> commands.
The first thing you probably need to do is to set a breakpoint:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> <span class=nb>break </span><span class=k>function</span><span class=nt>-name</span> address</code></pre></div></div><div class=paragraph><p>Numbers are taken hexadecimal by default, but to make them distinct from symbol names;
hexadecimal numbers starting with the letters <code>a-f</code> need to be preceded with <code>0x</code> (this is optional for other numbers).
Simple expressions are allowed, for example: <code>function-name + 0x103</code>.</p></div><div class=paragraph><p>To exit the debugger and continue execution, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> <span class=k>continue</span></code></pre></div></div><div class=paragraph><p>To get a stack trace of the current thread, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> trace</code></pre></div></div><div class=paragraph><p>To get a stack trace of an arbitrary thread, specify a process ID or thread ID as a second argument to <code>trace</code>.</p></div><div class=paragraph><p>If you want to remove a breakpoint, use</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> del
 del address-expression</code></pre></div></div><div class=paragraph><p>The first form will be accepted immediately after a breakpoint hit, and deletes the current breakpoint.
The second form can remove any breakpoint, but you need to specify the exact address; this can be obtained from:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> show b</code></pre></div></div><div class=paragraph><p>or:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> show <span class=nb>break</span></code></pre></div></div><div class=paragraph><p>To single-step the kernel, try:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> s</code></pre></div></div><div class=paragraph><p>This will step into functions, but you can make DDB trace them until the matching return statement is reached by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> n</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This is different from <code>gdb</code>'s <code>next</code> statement; it is like <code>gdb</code>'s <code>finish</code>.
Pressing <kbd>n</kbd> more than once will cause a continue.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To examine data from memory, use (for example):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> x/wx 0xf0133fe0,40
 x/hd db_symtab_space
 x/bc termbuf,10
 x/s stringbuf</code></pre></div></div><div class=paragraph><p>for word/halfword/byte access, and hexadecimal/decimal/character/ string display.
The number after the comma is the object count.
To display the next 0x10 items, simply use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> x ,10</code></pre></div></div><div class=paragraph><p>Similarly, use</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> x/ia foofunc,10</code></pre></div></div><div class=paragraph><p>to disassemble the first 0x10 instructions of <code>foofunc</code>, and display them along with their offset from the beginning of <code>foofunc</code>.</p></div><div class=paragraph><p>To modify memory, use the write command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> w/b termbuf 0xa 0xb 0
 w/w 0xf0010030 0 0</code></pre></div></div><div class=paragraph><p>The command modifier (<code>b</code>/<code>h</code>/<code>w</code>) specifies the size of the data to be written,
the first following expression is the address to write to and the remainder is interpreted as data to write to successive memory locations.</p></div><div class=paragraph><p>If you need to know the current registers, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> show reg</code></pre></div></div><div class=paragraph><p>Alternatively, you can display a single register value by e.g.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> p <span class=nv>$eax</span></code></pre></div></div><div class=paragraph><p>and modify it by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> <span class=nb>set</span> <span class=nv>$eax</span> new-value</code></pre></div></div><div class=paragraph><p>Should you need to call some kernel functions from DDB, simply say:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> call func<span class=o>(</span>arg1, arg2, ...<span class=o>)</span></code></pre></div></div><div class=paragraph><p>The return value will be printed.</p></div><div class=paragraph><p>For a <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> style summary of all running processes, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> ps</code></pre></div></div><div class=paragraph><p>Now you have examined why your kernel failed, and you wish to reboot.
Remember that, depending on the severity of previous malfunctioning, not all parts of the kernel might still be working as expected.
Perform one of the following actions to shut down and reboot your system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> panic</code></pre></div></div><div class=paragraph><p>This will cause your kernel to dump core and reboot, so you can later analyze the core on a higher level with <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> call boot<span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Might be a good way to cleanly shut down the running system, <code>sync()</code> all disks, and finally, in some cases, reboot.
As long as the disk and filesystem interfaces of the kernel are not damaged, this could be a good way for an almost clean shutdown.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> reset</code></pre></div></div><div class=paragraph><p>This is the final way out of disaster and almost the same as hitting the Big Red Button.</p></div><div class=paragraph><p>If you need a short command summary, simply type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> <span class=nb>help</span></code></pre></div></div><div class=paragraph><p>It is highly recommended to have a printed copy of the <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> manual page ready for a debugging session.
Remember that it is hard to read the on-line manual while single-stepping the kernel.</p></div></div></div><div class=sect1><h2 id=kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB<a class=anchor href=#kerneldebug-online-gdb></a></h2><div class=sectionbody><div class=paragraph><p>The FreeBSD kernel provides a second KDB backend for on-line debugging: <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=4&amp;format=html">gdb(4)</a>.
This feature has been supported since FreeBSD 2.2, and it is actually a very neat one.</p></div><div class=paragraph><p>GDB has supported <em>remote debugging</em> for a long time.
This is done using a very simple protocol along a serial line.
Unlike the other debugging methods described above, you will need two machines for doing this.
One is the host providing the debugging environment, including all the sources, and a copy of the kernel binary with all the symbols in it.
The other is the target machine that runs a copy of the very same kernel (optionally stripped of the debugging information).</p></div><div class=paragraph><p>In order to use remote GDB, ensure that the following options are present in your kernel configuration:</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions     DEBUG=-g
options         KDB
options         GDB</pre></div></div><div class=paragraph><p>Note that the <code>GDB</code> option is turned off by default in <code>GENERIC</code> kernels on -STABLE and -RELEASE branches, but enabled on -CURRENT.</p></div><div class=paragraph><p>Once built, copy the kernel to the target machine, and boot it.
Connect the serial line of the target machine that has "flags 080" set on its uart device to any serial line of the debugging host.
See <a href="https://man.freebsd.org/cgi/man.cgi?query=uart&amp;sektion=4&amp;format=html">uart(4)</a> for information on how to set the flags on a uart device.</p></div><div class=paragraph><p>The target machine must be made to enter the GDB backend, either due to a panic or by taking a purposeful trap into the debugger.
Before doing this, select the GDB debugger backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># sysctl debug.kdb.current=gdb</span>
debug.kdb.current: ddb -&gt; gdb</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The supported backends can be listed by the <code>debug.kdb.available</code> sysctl.
If the kernel configuration includes <code>options DDB</code>, then <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> will be selected by default.
If <code>gdb</code> does not appear in the list of available backends, then the debug serial port may not have been configured correctly.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Then, force entry to the debugger:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># sysctl debug.kdb.enter=1</span>
debug.kdb.enter: 0KDB: enter: sysctl debug.kdb.enter</code></pre></div></div><div class=paragraph><p>The target machine now awaits connection from a remote GDB client.
On the debugging machine, go to the compile directory of the target kernel, and start <code>gdb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># cd /usr/obj/usr/src/amd64.amd64/sys/GENERIC/</span>
<span class=c># kgdb kernel</span>
GNU gdb <span class=o>(</span>GDB<span class=o>)</span> 10.2 <span class=o>[</span>GDB v10.2 <span class=k>for </span>FreeBSD]
Copyright <span class=o>(</span>C<span class=o>)</span> 2021 Free Software Foundation, Inc.
...
Reading symbols from kernel...
Reading symbols from /usr/obj/usr/src/amd64.amd64/sys/GENERIC/kernel.debug...
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Initialize the remote debugging session (assuming the first serial port is being used) by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=o>(</span>kgdb<span class=o>)</span> target remote /dev/cuau0</code></pre></div></div><div class=paragraph><p>Your hosting GDB will now gain control over the target kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash>Remote debugging using /dev/cuau0
kdb_enter <span class=o>(</span><span class=nv>why</span><span class=o>=</span>&lt;optimized out&gt;, <span class=nv>msg</span><span class=o>=</span>&lt;optimized out&gt;<span class=o>)</span> at /usr/src/sys/kern/subr_kdb.c:506
506                     kdb_why <span class=o>=</span> KDB_WHY_UNSET<span class=p>;</span>
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Depending on the compiler used, some local variables may appear as <code>&lt;optimized out></code>, preventing them from being inspected directly by <code>gdb</code>.
If this causes problems while debugging, it is possible to build the kernel at a decreased optimization level, which may improve the visibility of some variables.
This can be done by passing <code>COPTFLAGS=-O1</code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>.
However, certain classes of kernel bugs may manifest differently (or not at all) when the optimization level is changed.</p></div></td></tr></tbody></table></div><div class=paragraph><p>You can use this session almost as any other GDB session, including full access to the source,
running it in gud-mode inside an Emacs window (which gives you an automatic source code display in another Emacs window), etc.</p></div></div></div><div class=sect1><h2 id=kerneldebug-console>10.5. Debugging a Console Driver<a class=anchor href=#kerneldebug-console></a></h2><div class=sectionbody><div class=paragraph><p>Since you need a console driver to run DDB on, things are more complicated if the console driver itself is failing.
You might remember the use of a serial console (either with modified boot blocks, or by specifying <code>-h</code> at the <code>Boot:</code> prompt),
and hook up a standard terminal onto your first serial port.
DDB works on any configured console driver, including a serial console.</p></div></div></div><div class=sect1><h2 id=kerneldebug-deadlocks>10.6. Debugging Deadlocks<a class=anchor href=#kerneldebug-deadlocks></a></h2><div class=sectionbody><div class=paragraph><p>You may experience so called deadlocks, a situation where a system stops doing useful work.
To provide a helpful bug report in this situation, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> as described in the previous section.
Include the output of <code>ps</code> and <code>trace</code> for suspected processes in the report.</p></div><div class=paragraph><p>If possible, consider doing further investigation.
The recipe below is especially useful if you suspect that a deadlock occurs in the VFS layer.
Add these options to the kernel configuration file.</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions 	DEBUG=-g
options 	INVARIANTS
options 	INVARIANT_SUPPORT
options 	WITNESS
options 	WITNESS_SKIPSPIN
options 	DEBUG_LOCKS
options 	DEBUG_VFS_LOCKS
options 	DIAGNOSTIC</pre></div></div><div class=paragraph><p>When a deadlock occurs, in addition to the output of the <code>ps</code> command, provide information from the <code>show pcpu</code>, <code>show allpcpu</code>, <code>show locks</code>, <code>show alllocks</code>, <code>show lockedvnods</code> and <code>alltrace</code>.</p></div><div class=paragraph><p>To obtain meaningful backtraces for threaded processes, use <code>thread thread-id</code> to switch to the thread stack, and do a backtrace with <code>where</code>.</p></div></div></div><div class=sect1><h2 id=kerneldebug-dcons>10.7. Kernel debugging with Dcons<a class=anchor href=#kerneldebug-dcons></a></h2><div class=sectionbody><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> is a very simple console driver that is not directly connected with any physical devices.
It just reads and writes characters from and to a buffer in a kernel or loader.
Due to its simple nature, it is very useful for kernel debugging, especially with a FireWire® device.
Currently, FreeBSD provides two ways to interact with the buffer from outside of the kernel using <a href="https://man.freebsd.org/cgi/man.cgi?query=dconschat&amp;sektion=8&amp;format=html">dconschat(8)</a>.</p></div><div class=sect2><h3 id=_dcons_over_firewire>10.7.1. Dcons over FireWire®<a class=anchor href=#_dcons_over_firewire></a></h3><div class=paragraph><p>Most FireWire® (IEEE1394) host controllers are based on the OHCI specification that supports physical access to the host memory.
This means that once the host controller is initialized, we can access the host memory without the help of software (kernel).
We can exploit this facility for interaction with <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>.
<a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> provides similar functionality as a serial console.
It emulates two serial ports, one for the console and DDB, the other for GDB.
Since remote memory access is fully handled by the hardware, the <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer is accessible even when the system crashes.</p></div><div class=paragraph><p>FireWire® devices are not limited to those integrated into motherboards.
PCI cards exist for desktops, and a cardbus interface can be purchased for laptops.</p></div><div class=sect3><h4 id=_enabling_firewire_and_dcons_support_on_the_target_machine>10.7.1.1. Enabling FireWire® and Dcons support on the target machine<a class=anchor href=#_enabling_firewire_and_dcons_support_on_the_target_machine></a></h4><div class=paragraph><p>To enable FireWire® and Dcons support in the kernel of the <em>target machine</em>:</p></div><div class=ulist><ul><li><p>Make sure your kernel supports <code>dcons</code>, <code>dcons_crom</code> and <code>firewire</code>. <code>Dcons</code> should be statically linked with the kernel. For <code>dcons_crom</code> and <code>firewire</code>, modules should be OK.</p></li><li><p>Make sure physical DMA is enabled. You may need to add <code>hw.firewire.phydma_enable=1</code> to <span class=filename>/boot/loader.conf</span>.</p></li><li><p>Add options for debugging.</p></li><li><p>Add <code>dcons_gdb=1</code> in <span class=filename>/boot/loader.conf</span> if you use GDB over FireWire®.</p></li><li><p>Enable <code>dcons</code> in <span class=filename>/etc/ttys</span>.</p></li><li><p>Optionally, to force <code>dcons</code> to be the high-level console, add <code>hw.firewire.dcons_crom.force_console=1</code> to <span class=filename>loader.conf</span>.</p></li></ul></div><div class=paragraph><p>To enable FireWire® and Dcons support in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> on i386 or amd64:</p></div><div class=paragraph><p>Add <code>LOADER_FIREWIRE_SUPPORT=YES</code> in <span class=filename>/etc/make.conf</span> and rebuild <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># cd /sys/boot/i386 &amp;&amp; make clean &amp;&amp; make &amp;&amp; make install</span></code></pre></div></div><div class=paragraph><p>To enable <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> as an active low-level console, add <code>boot_multicons="YES"</code> to <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Here are a few configuration examples.
A sample kernel configuration file would contain:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash>device dcons
device dcons_crom
options KDB
options DDB
options GDB
options ALT_BREAK_TO_DEBUGGER</code></pre></div></div><div class=paragraph><p>And a sample <span class=filename>/boot/loader.conf</span> would contain:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=nv>dcons_crom_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>dcons_gdb</span><span class=o>=</span>1
<span class=nv>boot_multicons</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
hw.firewire.phydma_enable<span class=o>=</span>1
hw.firewire.dcons_crom.force_console<span class=o>=</span>1</code></pre></div></div></div><div class=sect3><h4 id=_enabling_firewire_and_dcons_support_on_the_host_machine>10.7.1.2. Enabling FireWire® and Dcons support on the host machine<a class=anchor href=#_enabling_firewire_and_dcons_support_on_the_host_machine></a></h4><div class=paragraph><p>To enable FireWire® support in the kernel on the <em>host machine</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># kldload firewire</span></code></pre></div></div><div class=paragraph><p>Find out the EUI64 (the unique 64 bit identifier) of the FireWire® host controller, and use <a href="https://man.freebsd.org/cgi/man.cgi?query=fwcontrol&amp;sektion=8&amp;format=html">fwcontrol(8)</a> or <code>dmesg</code> to find the EUI64 of the target machine.</p></div><div class=paragraph><p>Run <a href="https://man.freebsd.org/cgi/man.cgi?query=dconschat&amp;sektion=8&amp;format=html">dconschat(8)</a>, with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># dconschat -e \# -br -G 12345 -t 00-11-22-33-44-55-66-77</span></code></pre></div></div><div class=paragraph><p>The following key combinations can be used once <a href="https://man.freebsd.org/cgi/man.cgi?query=dconschat&amp;sektion=8&amp;format=html">dconschat(8)</a> is running:</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=keyseq><kbd>~</kbd>+<kbd>.</kbd></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disconnect</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>~</kbd></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ALT BREAK</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>~</kbd></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RESET target</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>~</kbd></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Suspend dconschat</p></td></tr></tbody></table><div class=paragraph><p>Attach remote GDB by starting <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> with a remote debugging session:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash> kgdb <span class=nt>-r</span> :12345 kernel</code></pre></div></div></div><div class=sect3><h4 id=_some_general_tips>10.7.1.3. Some general tips<a class=anchor href=#_some_general_tips></a></h4><div class=paragraph><p>Here are some general tips:</p></div><div class=paragraph><p>To take full advantage of the speed of FireWire®, disable other slow console drivers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># conscontrol delete ttyd0	     # serial console</span>
<span class=c># conscontrol delete consolectl	# video/keyboard</span></code></pre></div></div><div class=paragraph><p>There exists a GDB mode for <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a>; this is what you will need to add to your <span class=filename>.emacs</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=o>(</span>setq gud-gdba-command-name <span class=s2>&#34;kgdb -a -a -a -r :12345&#34;</span><span class=o>)</span>
<span class=o>(</span>setq gdb-many-windows t<span class=o>)</span>
<span class=o>(</span>xterm-mouse-mode 1<span class=o>)</span>
M-x gdba</code></pre></div></div><div class=paragraph><p>And for DDD (<span class=filename>devel/ddd</span>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># remote serial protocol</span>
<span class=nv>LANG</span><span class=o>=</span>C ddd <span class=nt>--debugger</span> kgdb <span class=nt>-r</span> :12345 kernel
<span class=c># live core debug</span>
<span class=nv>LANG</span><span class=o>=</span>C ddd <span class=nt>--debugger</span> kgdb kernel /dev/fwmem0.2</code></pre></div></div></div></div><div class=sect2><h3 id=_dcons_with_kvm>10.7.2. Dcons with KVM<a class=anchor href=#_dcons_with_kvm></a></h3><div class=paragraph><p>We can directly read the <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer via <span class=filename>/dev/mem</span> for live systems, and in the core dump for crashed systems.
These give you similar output to <code>dmesg -a</code>, but the <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer includes more information.</p></div><div class=sect3><h4 id=_using_dcons_with_kvm>10.7.2.1. Using Dcons with KVM<a class=anchor href=#_using_dcons_with_kvm></a></h4><div class=paragraph><p>To use <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> with KVM:</p></div><div class=paragraph><p>Dump a <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer of a live system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># dconschat -1</span></code></pre></div></div><div class=paragraph><p>Dump a <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer of a crash dump:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># dconschat -1 -M vmcore.XX</span></code></pre></div></div><div class=paragraph><p>Live core debugging can be done via:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=c># fwcontrol -m target_eui64</span>
<span class=c># kgdb kernel /dev/fwmem0.2</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=kerneldebug-options>10.8. Glossary of Kernel Options for Debugging<a class=anchor href=#kerneldebug-options></a></h2><div class=sectionbody><div class=paragraph><p>This section provides a brief glossary of compile-time kernel options used for debugging:</p></div><div class=ulist><ul><li><p><code>options KDB</code>: compiles in the kernel debugger framework. Required for <code>options DDB</code> and <code>options GDB</code>. Little or no performance overhead. By default, the debugger will be entered on panic instead of an automatic reboot.</p></li><li><p><code>options KDB_UNATTENDED</code>: change the default value of the <code>debug.debugger_on_panic</code> sysctl to 0, which controls whether the debugger is entered on panic. When <code>options KDB</code> is not compiled into the kernel, the behavior is to automatically reboot on panic; when it is compiled into the kernel, the default behavior is to drop into the debugger unless <code>options KDB_UNATTENDED</code> is compiled in. If you want to leave the kernel debugger compiled into the kernel but want the system to come back up unless you’re on-hand to use the debugger for diagnostics, use this option.</p></li><li><p><code>options KDB_TRACE</code>: change the default value of the <code>debug.trace_on_panic</code> sysctl to 1, which controls whether the debugger automatically prints a stack trace on panic. Especially if running with <code>options KDB_UNATTENDED</code>, this can be helpful to gather basic debugging information on the serial or firewire console while still rebooting to recover.</p></li><li><p><code>options DDB</code>: compile in support for the console debugger, DDB. This interactive debugger runs on whatever the active low-level console of the system is, which includes the video console, serial console, or firewire console. It provides basic integrated debugging facilities, such as stack tracing, process and thread listing, dumping of lock state, VM state, file system state, and kernel memory management. DDB does not require software running on a second machine or being able to generate a core dump or full debugging kernel symbols, and provides detailed diagnostics of the kernel at run-time. Many bugs can be fully diagnosed using only DDB output. This option depends on <code>options KDB</code>.</p></li><li><p><code>options GDB</code>: compile in support for the remote debugger, GDB, which can operate over serial cable or firewire. When the debugger is entered, GDB may be attached to inspect structure contents, generate stack traces, etc. Some kernel state is more awkward to access than in DDB, which is able to generate useful summaries of kernel state automatically, such as automatically walking lock debugging or kernel memory management structures, and a second machine running the debugger is required. On the other hand, GDB combines information from the kernel source and full debugging symbols, and is aware of full data structure definitions, local variables, and is scriptable. This option is not required to run GDB on a kernel core dump. This option depends on <code>options KDB</code>.</p></li><li><p><code>options BREAK_TO_DEBUGGER</code>, <code>options ALT_BREAK_TO_DEBUGGER</code>: allow a break signal or alternative signal on the console to enter the debugger. If the system hangs without a panic, this is a useful way to reach the debugger. Due to the current kernel locking, a break signal generated on a serial console is significantly more reliable at getting into the debugger, and is generally recommended. This option has little or no performance impact.</p></li><li><p><code>options INVARIANTS</code>: compile into the kernel a large number of run-time assertion checks and tests, which constantly test the integrity of kernel data structures and the invariants of kernel algorithms. These tests can be expensive, so are not compiled in by default, but help provide useful "fail stop" behavior, in which certain classes of undesired behavior enter the debugger before kernel data corruption occurs, making them easier to debug. Tests include memory scrubbing and use-after-free testing, which is one of the more significant sources of overhead. This option depends on <code>options INVARIANT_SUPPORT</code>.</p></li><li><p><code>options INVARIANT_SUPPORT</code>: many of the tests present in <code>options INVARIANTS</code> require modified data structures or additional kernel symbols to be defined.</p></li><li><p><code>options WITNESS</code>: this option enables run-time lock order tracking and verification, and is an invaluable tool for deadlock diagnosis. WITNESS maintains a graph of acquired lock orders by lock type, and checks the graph at each acquire for cycles (implicit or explicit). If a cycle is detected, a warning and stack trace are generated to the console, indicating that a potential deadlock might have occurred. WITNESS is required in order to use the <code>show locks</code>, <code>show witness</code> and <code>show alllocks</code> DDB commands. This debug option has significant performance overhead, which may be somewhat mitigated through the use of <code>options WITNESS_SKIPSPIN</code>. Detailed documentation may be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a>.</p></li><li><p><code>options WITNESS_SKIPSPIN</code>: disable run-time checking of spinlock lock order with WITNESS. As spin locks are acquired most frequently in the scheduler, and scheduler events occur often, this option can significantly speed up systems running with WITNESS. This option depends on <code>options WITNESS</code>.</p></li><li><p><code>options WITNESS_KDB</code>: change the default value of the <code>debug.witness.kdb</code> sysctl to 1, which causes WITNESS to enter the debugger when a lock order violation is detected, rather than simply printing a warning. This option depends on <code>options WITNESS</code>.</p></li><li><p><code>options SOCKBUF_DEBUG</code>: perform extensive run-time consistency checking on socket buffers, which can be useful for debugging both socket bugs and race conditions in protocols and device drivers that interact with sockets. This option significantly impacts network performance, and may change the timing in device driver races.</p></li><li><p><code>options DEBUG_VFS_LOCKS</code>: track lock acquisition points for lockmgr/vnode locks, expanding the amount of information displayed by <code>show lockedvnods</code> in DDB. This option has a measurable performance impact.</p></li><li><p><code>options DEBUG_MEMGUARD</code>: a replacement for the <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> kernel memory allocator that uses the VM system to detect reads or writes from allocated memory after free. Details may be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=memguard&amp;sektion=9&amp;format=html">memguard(9)</a>. This option has a significant performance impact, but can be very helpful in debugging kernel memory corruption bugs.</p></li><li><p><code>options DIAGNOSTIC</code>: enable additional, more expensive diagnostic tests along the lines of <code>options INVARIANTS</code>.</p></li><li><p><code>options KASAN</code>: enable the Kernel Address Sanitizer. This enables compiler instrumentation which can be used to detect invalid memory accesses in the kernel, such as use-after-frees and buffer overflows. This largely supersedes <code>options DEBUG_MEMGUARD</code>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=kasan&amp;sektion=9&amp;format=html">kasan(9)</a> for details, and for the currently supported platforms.</p></li><li><p><code>options KMSAN</code>: enable the Kernel Memory Sanitizer. This enables compiler instrumentation which can be used to detect uses of uninitialized memory. See <a href="https://man.freebsd.org/cgi/man.cgi?query=kmsan&amp;sektion=9&amp;format=html">kmsan(9)</a> for details, and for the currently supported platforms.</p></li></ul></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: March 9, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/en/books/developers-handbook/kernelbuild class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/en/books/developers-handbook/partiv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump</a></li><li><a href=#kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code></a></li><li><a href=#kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB</a></li><li><a href=#kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB</a></li><li><a href=#kerneldebug-console>10.5. Debugging a Console Driver</a></li><li><a href=#kerneldebug-deadlocks>10.6. Debugging Deadlocks</a></li><li><a href=#kerneldebug-dcons>10.7. Kernel debugging with Dcons</a></li><li><a href=#kerneldebug-options>10.8. Glossary of Kernel Options for Debugging</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/developers-handbook/developers-handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/en/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>