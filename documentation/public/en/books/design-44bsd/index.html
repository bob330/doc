<!doctype html><html class=theme-light lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Donated by Addison-Wesley, provides a design overview of 4.4BSD, from which FreeBSD was originally derived"><meta name=keywords content="4.4BSD,design,operating system,BSD,UNIX"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/en/books/design-44bsd/><title>The Design and Implementation of the 4.4BSD Operating System | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="The Design and Implementation of the 4.4BSD Operating System"><meta property="og:description" content="Donated by Addison-Wesley, provides a design overview of 4.4BSD, from which FreeBSD was originally derived"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="http://172.16.201.134:1313/en/books/design-44bsd/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/en\/books\/design-44bsd\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/en/books>Books</a></li><li><a href=http://172.16.201.134:1313/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>The Design and Implementation of the 4.4BSD Operating System</h1><div class=copyright>Copyright © 1996 Addison-Wesley Longman, Inc</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary></details></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#overview>2.1. Design Overview of 4.4BSD</a><ul><li><a href=#overview-facilities>2.1.1. 4.4BSD Facilities and the Kernel</a></li><li><a href=#overview-kernel-organization>2.1.2. Kernel Organization</a></li><li><a href=#overview-kernel-service>2.1.3. Kernel Services</a></li><li><a href=#overview-process-management>2.1.4. Process Management</a></li><li><a href=#overview-memory-management>2.1.5. Memory Management</a></li><li><a href=#overview-io-system>2.1.6. I/O System</a></li><li><a href=#overview-filesystem>2.1.7. Filesystems</a></li><li><a href=#overview-filestore>2.1.8. Filestores</a></li><li><a href=#overview-nfs>2.1.9. Network Filesystem</a></li><li><a href=#overview-terminal>2.1.10. Terminals</a></li><li><a href=#overview-ipc>2.1.11. Interprocess Communication</a></li><li><a href=#overview-network-communication>2.1.12. Network Communication</a></li><li><a href=#overview-network-implementation>2.1.13. Network Implementation</a></li><li><a href=#overview-operation>2.1.14. System Operation</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><hr></div></div><div class=sect1><h2 id=overview>2.1. Design Overview of 4.4BSD<a class=anchor href=#overview></a></h2><div class=sectionbody><div class=sect2><h3 id=overview-facilities>2.1.1. 4.4BSD Facilities and the Kernel<a class=anchor href=#overview-facilities></a></h3><div class=paragraph><p>The 4.4BSD kernel provides four basic facilities: processes, a filesystem, communications, and system startup.
This section outlines where each of these four basic services is described in this book.</p></div><div class="olist arabic"><ol class=arabic><li><p>Processes constitute a thread of control in an address space. Mechanisms for creating, terminating, and otherwise controlling processes are described in Chapter 4. The system multiplexes separate virtual-address spaces for each process; this memory management is discussed in Chapter 5.</p></li><li><p>The user interface to the filesystem and devices is similar; common aspects are discussed in Chapter 6. The filesystem is a set of named files, organized in a tree-structured hierarchy of directories, and of operations to manipulate them, as presented in Chapter 7. Files reside on physical media such as disks. 4.4BSD supports several organizations of data on the disk, as set forth in Chapter 8. Access to files on remote machines is the subject of Chapter 9. Terminals are used to access the system; their operation is the subject of Chapter 10.</p></li><li><p>Communication mechanisms provided by traditional UNIX systems include simplex reliable byte streams between related processes (see pipes, Section 11.1), and notification of exceptional events (see signals, Section 4.7). 4.4BSD also has a general interprocess-communication facility. This facility, described in Chapter 11, uses access mechanisms distinct from those of the filesystem, but, once a connection is set up, a process can access it as though it were a pipe. There is a general networking framework, discussed in Chapter 12, that is normally used as a layer underlying the IPC facility. Chapter 13 describes a particular networking implementation in detail.</p></li><li><p>Any real operating system has operational issues, such as how to start it running. Startup and operational issues are described in Chapter 14.</p></li></ol></div><div class=paragraph><p>Sections 2.3 through 2.14 present introductory material related to Chapters 3 through 14.
We shall define terms, mention basic system calls, and explore historical developments.
Finally, we shall give the reasons for many major design decisions.</p></div><div class=sect3><h4 id=_the_kernel>2.1.1.1. The Kernel<a class=anchor href=#_the_kernel></a></h4><div class=paragraph><p>The <em>kernel</em> is the part of the system that runs in protected mode and mediates access by all user programs to the underlying hardware (e.g., CPU, disks, terminals, network links) and software constructs (e.g., filesystem, network protocols).
The kernel provides the basic system facilities; it creates and manages processes, and provides functions to access the filesystem and communication facilities.
These functions, called <em>system calls</em> appear to user processes as library subroutines.
These system calls are the only interface that processes have to these facilities.
Details of the system-call mechanism are given in Chapter 3, as are descriptions of several kernel mechanisms that do not execute as the direct result of a process doing a system call.</p></div><div class=paragraph><p>A <em>kernel</em> in traditional operating-system terminology, is a small nucleus of software that provides only the minimal facilities necessary for implementing additional operating-system services.
In contemporary research operating systems — such as Chorus
<a href=../design-44bsd/#biblio-rozier>[Rozier et al</a>], Mach <a href=../design-44bsd/#biblio-accetta>[Accetta et al</a>], Tunis
<a href=../design-44bsd/#biblio-ewens>[Ewens et al</a>], and the V Kernel <a href=../design-44bsd/#biblio-cheriton>[Cheriton</a>] — this division of functionality is more than just a logical one.
Services such as filesystems and networking protocols are implemented as client application processes of the nucleus or kernel.</p></div><div class=paragraph><p>The 4.4BSD kernel is not partitioned into multiple processes.
This basic design decision was made in the earliest versions of UNIX.
The first two implementations by Ken Thompson had no memory mapping, and thus
made no hardware-enforced distinction between user and kernel space <a href=../design-44bsd/#biblio-ritchie>[Ritchie</a>].
A message-passing system could have been implemented as readily as the actually implemented model of kernel and user processes.
The monolithic kernel was chosen for simplicity and performance.
And the early kernels were small; the inclusion of facilities such as networking into the kernel has increased its size.
The current trend in operating-systems research is to reduce the kernel size by placing such services in user space.</p></div><div class=paragraph><p>Users ordinarily interact with the system through a command-language interpreter, called a <em>shell</em>, and perhaps through additional user application programs.
Such programs and the shell are implemented with processes.
Details of such programs are beyond the scope of this book, which instead concentrates almost exclusively on the kernel.</p></div><div class=paragraph><p>Sections 2.3 and 2.4 describe the services provided by the 4.4BSD kernel, and give an overview of the latter’s design.
Later chapters describe the detailed design and implementation of these services as they appear in 4.4BSD.</p></div></div></div><div class=sect2><h3 id=overview-kernel-organization>2.1.2. Kernel Organization<a class=anchor href=#overview-kernel-organization></a></h3><div class=paragraph><p>In this section, we view the organization of the 4.4BSD kernel in two ways:</p></div><div class="olist arabic"><ol class=arabic><li><p>As a static body of software, categorized by the functionality offered by the modules that make up the kernel</p></li><li><p>By its dynamic operation, categorized according to the services provided to users</p></li></ol></div><div class=paragraph><p>The largest part of the kernel implements the system services that applications access through system calls.
In 4.4BSD, this software has been organized according to the following:</p></div><div class=ulist><ul><li><p>Basic kernel facilities: timer and system-clock handling, descriptor management, and process management</p></li><li><p>Memory-management support: paging and swapping</p></li><li><p>Generic system interfaces: the I/O, control, and multiplexing operations performed on descriptors</p></li><li><p>The filesystem: files, directories, pathname translation, file locking, and I/O buffer management</p></li><li><p>Terminal-handling support: the terminal-interface driver and terminal line disciplines</p></li><li><p>Interprocess-communication facilities: sockets</p></li><li><p>Support for network communication: communication protocols and generic network facilities, such as routing</p></li></ul></div><table id=table-mach-indep class="tableblock frame-all grid-all stretch"><caption class=title>Table 1. Machine-independent software in the 4.4BSD kernel</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Category</th><th class="tableblock halign-left valign-top">Lines of code</th><th class="tableblock halign-left valign-top">Percentage of kernel</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>headers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>9,393</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>initialization</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1,107</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>kernel facilities</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8,793</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>generic interfaces</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,782</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>interprocess communication</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,540</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>terminal handling</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,911</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>virtual memory</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11,813</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>vnode management</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7,954</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>filesystem naming</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6,550</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fast filestore</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,365</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>log-structure filestore</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,337</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memory-based filestore</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>645</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cd9660 filesystem</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,177</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>miscellaneous filesystems (10)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>12,695</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>network filesystem</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>17,199</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>network communication</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8,630</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>internet protocols</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11,984</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO protocols</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>23,924</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>X.25 protocols</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10,626</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>XNS protocols</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5,192</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.6</p></td></tr></tbody></table><div class=paragraph><p>Most of the software in these categories is machine independent and is portable across different hardware architectures.</p></div><div class=paragraph><p>The machine-dependent aspects of the kernel are isolated from the mainstream code.
In particular, none of the machine-independent code contains conditional code for specific architecture.
When an architecture-dependent action is needed, the machine-independent code calls an architecture-dependent function that is located in the machine-dependent code.
The software that is machine dependent includes</p></div><div class=ulist><ul><li><p>Low-level system-startup actions</p></li><li><p>Trap and fault handling</p></li><li><p>Low-level manipulation of the run-time context of a process</p></li><li><p>Configuration and initialization of hardware devices</p></li><li><p>Run-time support for I/O devices</p></li></ul></div><table id=table-mach-dep class="tableblock frame-all grid-all stretch"><caption class=title>Table 2. Machine-dependent software for the HP300 in the 4.4BSD kernel</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Category</th><th class="tableblock halign-left valign-top">Lines of code</th><th class="tableblock halign-left valign-top">Percentage of kernel</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>machine dependent headers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1,562</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>device driver headers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,495</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>device driver source</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>17,506</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8.7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>virtual memory</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,087</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>other machine dependent</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6,287</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>routines in assembly language</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,014</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>HP/UX compatibility</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,683</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.3</p></td></tr></tbody></table><div class=paragraph><p><a href=../design-44bsd/#table-mach-indep>Machine-independent software in the 4.4BSD kernel</a> summarizes the machine-independent software that constitutes the 4.4BSD kernel for the HP300.
The numbers in column 2 are for lines of C source code, header files, and assembly language.
Virtually all the software in the kernel is written in the C programming language; less than 2 percent is written in assembly language.
As the statistics in <a href=../design-44bsd/#table-mach-dep>Machine-dependent software in the 4.4BSD kernel</a> show, the machine-dependent software, excluding HP/UX and device support, accounts for a minuscule 6.9 percent of the kernel.</p></div><div class=paragraph><p>Only a small part of the kernel is devoted to initializing the system.
This code is used when the system is <em>bootstrapped</em> into operation and is responsible for setting up the kernel hardware and software environment (see Chapter 14).
Some operating systems (especially those with limited physical memory) discard or <em>overlay</em> the software that performs these functions after that software has been executed.
The 4.4BSD kernel does not reclaim the memory used by the startup code because that memory space is barely 0.5 percent of the kernel resources used on a typical machine.
Also, the startup code does not appear in one place in the kernel — it is scattered throughout, and it usually appears in places logically associated with what is being initialized.</p></div></div><div class=sect2><h3 id=overview-kernel-service>2.1.3. Kernel Services<a class=anchor href=#overview-kernel-service></a></h3><div class=paragraph><p>The boundary between the kernel- and user-level code is enforced by hardware-protection facilities provided by the underlying hardware.
The kernel operates in a separate address space that is inaccessible to user processes.
Privileged operations — such as starting I/O and halting the central processing unit (CPU) — are available to only the kernel.
Applications request services from the kernel with <em>system calls</em>.
System calls are used to cause the kernel to execute complicated operations, such as writing data to secondary storage, and simple operations, such as returning the current time of day.
All system calls appear <em>synchronous</em> to applications: The application does not run while the kernel does the actions associated with a system call.
The kernel may finish some operations associated with a system call after it has returned.
For example, a <em>write</em> system call will copy the data to be written from the user process to a kernel buffer while the process waits, but will usually return from the system call before the kernel buffer is written to the disk.</p></div><div class=paragraph><p>A system call usually is implemented as a hardware trap that changes the CPU’s execution mode and the current address-space mapping.
Parameters supplied by users in system calls are validated by the kernel before being used.
Such checking ensures the integrity of the system.
All parameters passed into the kernel are copied into the kernel’s address space, to ensure that validated parameters are not changed as a side effect of the system call.
System-call results are returned by the kernel, either in hardware registers or by their values being copied to user-specified memory addresses.
Like parameters passed into the kernel, addresses used for the return of results must be validated to ensure that they are part of an application’s address space.
If the kernel encounters an error while processing a system call, it returns an error code to the user.
For the C programming language, this error code is stored in the global variable <em>errno</em>, and the function that executed the system call returns the value -1.</p></div><div class=paragraph><p>User applications and the kernel operate independently of each other.
4.4BSD does not store I/O control blocks or other operating-system-related data structures in the application’s address space.
Each user-level application is provided an independent address space in which it executes.
The kernel makes most state changes, such as suspending a process while another is running, invisible to the processes involved.</p></div></div><div class=sect2><h3 id=overview-process-management>2.1.4. Process Management<a class=anchor href=#overview-process-management></a></h3><div class=paragraph><p>4.4BSD supports a multitasking environment.
Each task or thread of execution is termed a <em>process</em>.
The <em>context</em> of a 4.4BSD process consists of user-level state, including the contents of its address space and the run-time environment, and kernel-level state, which includes scheduling parameters, resource controls, and identification information.
The context includes everything used by the kernel in providing services for the process.
Users can create processes, control the processes' execution, and receive notification when the processes' execution status changes.
Every process is assigned a unique value, termed a <em>process identifier</em> (PID).
This value is used by the kernel to identify a process when reporting status changes to a user, and by a user when referencing a process in a system call.</p></div><div class=paragraph><p>The kernel creates a process by duplicating the context of another process.
The new process is termed a <em>child process</em> of the original <em>parent process</em>
The context duplicated in process creation includes both the user-level execution state of the process and the process’s system state managed by the kernel.
Important components of the kernel state are described in Chapter 4.</p></div><div id=fig-process-lifecycle class=paragraph><div class=title>Process lifecycle</div><p><span class=image><img src=../../../images/books/design-44bsd/fig1.png alt="Process lifecycle"></span></p></div><div class=paragraph><p>The process lifecycle is depicted in
<a href=../design-44bsd/#fig-process-lifecycle>Process lifecycle</a>.
A process may create a new process that is a copy of the original by using the <em>fork</em> system call.
The <em>fork</em> call returns twice: once in the parent process, where the return value is the process identifier of the child, and once in the child process, where the return value is 0.
The parent-child relationship induces a hierarchical structure on the set of processes in the system.
The new process shares all its parent’s resources, such as file descriptors, signal-handling status, and memory layout.</p></div><div class=paragraph><p>Although there are occasions when the new process is intended to be a copy of the parent, the loading and execution of a different program is a more useful and typical action.
A process can overlay itself with the memory image of another program, passing to the newly created image a set of parameters, using the system call <em>execve</em>.
One parameter is the name of a file whose contents are in a format recognized by the system — either a binary-executable file or a file that causes the execution of a specified interpreter program to process its contents.</p></div><div class=paragraph><p>A process may terminate by executing an <em>exit</em> system call, sending 8 bits of exit status to its parent.
If a process wants to communicate more than a single byte of information with its parent, it must either set up an interprocess-communication channel using pipes or sockets, or use an intermediate file.
Interprocess communication is discussed extensively in Chapter 11.</p></div><div class=paragraph><p>A process can suspend execution until any of its child processes terminate using the <em>wait</em> system call, which returns the PID and exit status of the terminated child process.
A parent process can arrange to be notified by a signal when a child process exits or terminates abnormally.
Using the <em>wait4</em> system call, the parent can retrieve information about the event that caused termination of the child process and about resources consumed by the process during its lifetime.
If a process is orphaned because its parent exits before it is finished, then the kernel arranges for the child’s exit status to be passed back to a special system process <em>init</em>: see Sections 3.1 and 14.6).</p></div><div class=paragraph><p>The details of how the kernel creates and destroys processes are given in Chapter 5.</p></div><div class=paragraph><p>Processes are scheduled for execution according to a <em>process-priority</em> parameter.
This priority is managed by a kernel-based scheduling algorithm.
Users can influence the scheduling of a process by specifying a parameter (<em>nice</em>) that weights the overall scheduling priority, but are still obligated to share the underlying CPU resources according to the kernel’s scheduling policy.</p></div><div class=sect3><h4 id=_signals>2.1.4.1. Signals<a class=anchor href=#_signals></a></h4><div class=paragraph><p>The system defines a set of <em>signals</em> that may be delivered to a process.
Signals in 4.4BSD are modeled after hardware interrupts.
A process may specify a user-level subroutine to be a <em>handler</em> to which a signal should be delivered.
When a signal is generated, it is blocked from further occurrence while it is being <em>caught</em> by the handler.
Catching a signal involves saving the current process context and building a new one in which to run the handler.
The signal is then delivered to the handler, which can either abort the process or return to the executing process (perhaps after setting a global variable).
If the handler returns, the signal is unblocked and can be generated (and caught) again.</p></div><div class=paragraph><p>Alternatively, a process may specify that a signal is to be <em>ignored</em>, or that a default action, as determined by the kernel, is to be taken.
The default action of certain signals is to terminate the process.
This termination may be accompanied by creation of a <em>core file</em> that contains the current memory image of the process for use in postmortem debugging.</p></div><div class=paragraph><p>Some signals cannot be caught or ignored.
These signals include <em>SIGKILL</em>, which kills runaway processes, and the job-control signal <em>SIGSTOP</em>.</p></div><div class=paragraph><p>A process may choose to have signals delivered on a special stack so that sophisticated software stack manipulations are possible.
For example, a language supporting coroutines needs to provide a stack for each coroutine.
The language run-time system can allocate these stacks by dividing up the single stack provided by 4.4BSD.
If the kernel does not support a separate signal stack, the space allocated for each coroutine must be expanded by the amount of space required to catch a signal.</p></div><div class=paragraph><p>All signals have the same <em>priority</em>.
If multiple signals are pending simultaneously, the order in which signals are delivered to a process is implementation specific.
Signal handlers execute with the signal that caused their invocation to be blocked, but other signals may yet occur.
Mechanisms are provided so that processes can protect critical sections of code against the occurrence of specified signals.</p></div><div class=paragraph><p>The detailed design and implementation of signals is described in Section 4.7.</p></div></div><div class=sect3><h4 id=_process_groups_and_sessions>2.1.4.2. Process Groups and Sessions<a class=anchor href=#_process_groups_and_sessions></a></h4><div class=paragraph><p>Processes are organized into <em>process groups</em>.
Process groups are used to control access to terminals and to provide a means of distributing signals to collections of related processes.
A process inherits its process group from its parent process.
Mechanisms are provided by the kernel to allow a process to alter its process group or the process group of its descendants.
Creating a new process group is easy; the value of a new process group is ordinarily the process identifier of the creating process.</p></div><div class=paragraph><p>The group of processes in a process group is sometimes referred to as a <em>job</em> and is manipulated by high-level system software, such as the shell.
A common kind of job created by a shell is a <em>pipeline</em> of several processes connected by pipes, such that the output of the first process is the input of the second, the output of the second is the input of the third, and so forth.
The shell creates such a job by forking a process for each stage of the pipeline, then putting all those processes into a separate process group.</p></div><div class=paragraph><p>A user process can send a signal to each process in a process group, as well as to a single process.
A process in a specific process group may receive software interrupts affecting the group, causing the group to suspend or resume execution, or to be interrupted or terminated.</p></div><div class=paragraph><p>A terminal has a process-group identifier assigned to it.
This identifier is normally set to the identifier of a process group associated with the terminal.
A job-control shell may create a number of process groups associated with the same terminal; the terminal is the <em>controlling terminal</em> for each process in these groups.
A process may read from a descriptor for its controlling terminal only if the terminal’s process-group identifier matches that of the process.
If the identifiers do not match, the process will be blocked if it attempts to read from the terminal.
By changing the process-group identifier of the terminal, a shell can arbitrate a terminal among several different jobs.
This arbitration is called <em>job control</em> and is described, with process groups, in Section 4.8.</p></div><div class=paragraph><p>Just as a set of related processes can be collected into a process group, a set of process groups can be collected into a <em>session</em>.
The main uses for sessions are to create an isolated environment for a daemon process and its children, and to collect together a user’s login shell and the jobs that shell spawns.</p></div></div></div><div class=sect2><h3 id=overview-memory-management>2.1.5. Memory Management<a class=anchor href=#overview-memory-management></a></h3><div class=paragraph><p>Each process has its own private address space.
The address space is initially divided into three logical segments: <em>text</em>, <em>data</em>, and <em>stack</em>.
The text segment is read-only and contains the machine instructions of a program.
The data and stack segments are both readable and writable.
The data segment contains the initialized and uninitialized data portions of a program, whereas the stack segment holds the application’s run-time stack.
On most machines, the stack segment is extended automatically by the kernel as the process executes.
A process can expand or contract its data segment by making a system call, whereas a process can change the size of its text segment only when the segment’s contents are overlaid with data from the filesystem, or when debugging takes place.
The initial contents of the segments of a child process are duplicates of the segments of a parent process.</p></div><div class=paragraph><p>The entire contents of a process address space do not need to be resident for a process to execute.
If a process references a part of its address space that is not resident in main memory, the system <em>pages</em> the necessary information into memory.
When system resources are scarce, the system uses a two-level approach to maintain available resources.
If a modest amount of memory is available, the system will take memory resources away from processes if these resources have not been used recently.
Should there be a severe resource shortage, the system will resort to <em>swapping</em> the entire context of a process to secondary storage.
The <em>demand paging</em> and <em>swapping</em> done by the system are effectively transparent to processes.
A process may, however, advise the system about expected future memory utilization as a performance aid.</p></div><div class=sect3><h4 id=_bsd_memory_management_design_decisions>2.1.5.1. BSD Memory-Management Design Decisions<a class=anchor href=#_bsd_memory_management_design_decisions></a></h4><div class=paragraph><p>The support of large sparse address spaces, mapped files, and shared memory was a requirement for 4.2BSD.
An interface was specified, called <em>mmap</em>, that allowed unrelated processes to request a shared mapping of a file into their address spaces.
If multiple processes mapped the same file into their address spaces, changes to the file’s portion of an address space by one process would be reflected in the area mapped by the other processes, as well as in the file itself.
Ultimately, 4.2BSD was shipped without the <em>mmap</em> interface, because of pressure to make other features, such as networking, available.</p></div><div class=paragraph><p>Further development of the <em>mmap</em> interface continued during the work on 4.3BSD.
Over 40 companies and research groups participated in the discussions leading to
the revised architecture that was described in the Berkeley Software
Architecture Manual <a href=../design-44bsd/#biblio-mckusick-1>[McKusick et al</a>].
Several of the companies have implemented the revised interface
<a href=../design-44bsd/#biblio-gingell>[Gingell et al</a>].</p></div><div class=paragraph><p>Once again, time pressure prevented 4.3BSD from providing an implementation of the interface.
Although the latter could have been built into the existing 4.3BSD virtual-memory system, the developers decided not to put it in because that implementation was nearly 10 years old.
Furthermore, the original virtual-memory design was based on the assumption that computer memories were small and expensive, whereas disks were locally connected, fast, large, and inexpensive.
Thus, the virtual-memory system was designed to be frugal with its use of memory at the expense of generating extra disk traffic.
In addition, the 4.3BSD implementation was riddled with VAX memory-management hardware dependencies that impeded its portability to other computer architectures.
Finally, the virtual-memory system was not designed to support the tightly coupled multiprocessors that are becoming increasingly common and important today.</p></div><div class=paragraph><p>Attempts to improve the old implementation incrementally seemed doomed to failure.
A completely new design, on the other hand, could take advantage of large memories, conserve disk transfers, and have the potential to run on multiprocessors.
Consequently, the virtual-memory system was completely replaced in 4.4BSD.
The 4.4BSD virtual-memory system is based on the Mach 2.0 VM system
<a href=../design-44bsd/#biblio-tevanian>[Tevanian</a>]. with updates from Mach 2.5 and Mach 3.0.
It features efficient support for sharing, a clean separation of machine-independent and machine-dependent features, as well as (currently unused) multiprocessor support.
Processes can map files anywhere in their address space.
They can share parts of their address space by doing a shared mapping of the same file.
Changes made by one process are visible in the address space of the other process, and also are written back to the file itself.
Processes can also request private mappings of a file, which prevents any changes that they make from being visible to other processes mapping the file or being written back to the file itself.</p></div><div class=paragraph><p>Another issue with the virtual-memory system is the way that information is passed into the kernel when a system call is made.
4.4BSD always copies data from the process address space into a buffer in the kernel.
For read or write operations that are transferring large quantities of data, doing the copy can be time consuming.
An alternative to doing the copying is to remap the process memory into the kernel.
The 4.4BSD kernel always copies the data for several reasons:</p></div><div class=ulist><ul><li><p>Often, the user data are not page aligned and are not a multiple of the hardware page length.</p></li><li><p>If the page is taken away from the process, it will no longer be able to reference that page. Some programs depend on the data remaining in the buffer even after those data have been written.</p></li><li><p>If the process is allowed to keep a copy of the page (as it is in current 4.4BSD semantics), the page must be made <em>copy-on-write</em>. A copy-on-write page is one that is protected against being written by being made read-only. If the process attempts to modify the page, the kernel gets a write fault. The kernel then makes a copy of the page that the process can modify. Unfortunately, the typical process will immediately try to write new data to its output buffer, forcing the data to be copied anyway.</p></li><li><p>When pages are remapped to new virtual-memory addresses, most memory-management hardware requires that the hardware address-translation cache be purged selectively. The cache purges are often slow. The net effect is that remapping is slower than copying for blocks of data less than 4 to 8 Kbyte.</p></li></ul></div><div class=paragraph><p>The biggest incentives for memory mapping are the needs for accessing big files and for passing large quantities of data between processes.
The <em>mmap</em> interface provides a way for both of these tasks to be done without copying.</p></div></div><div class=sect3><h4 id=_memory_management_inside_the_kernel>2.1.5.2. Memory Management Inside the Kernel<a class=anchor href=#_memory_management_inside_the_kernel></a></h4><div class=paragraph><p>The kernel often does allocations of memory that are needed for only the duration of a single system call.
In a user process, such short-term memory would be allocated on the run-time stack.
Because the kernel has a limited run-time stack, it is not feasible to allocate even moderate-sized blocks of memory on it.
Consequently, such memory must be allocated through a more dynamic mechanism.
For example, when the system must translate a pathname, it must allocate a 1-Kbyte buffer to hold the name.
Other blocks of memory must be more persistent than a single system call, and thus could not be allocated on the stack even if there was space.
An example is protocol-control blocks that remain throughout the duration of a network connection.</p></div><div class=paragraph><p>Demands for dynamic memory allocation in the kernel have increased as more services have been added.
A generalized memory allocator reduces the complexity of writing code inside the kernel.
Thus, the 4.4BSD kernel has a single memory allocator that can be used by any part of the system.
It has an interface similar to the C library routines <em>malloc</em> and <em>free</em> that
provide memory allocation to application programs
<a href=../design-44bsd/#biblio-mckusick-2>[McKusick & Karels</a>].
Like the C library interface, the allocation routine takes a parameter specifying the size of memory that is needed.
The range of sizes for memory requests is not constrained; however, physical memory is allocated and is not paged.
The free routine takes a pointer to the storage being freed, but does not require the size of the piece of memory being freed.</p></div></div></div><div class=sect2><h3 id=overview-io-system>2.1.6. I/O System<a class=anchor href=#overview-io-system></a></h3><div class=paragraph><p>The basic model of the UNIX I/O system is a sequence of bytes that can be accessed either randomly or sequentially.
There are no <em>access methods</em> and no <em>control blocks</em> in a typical UNIX user process.</p></div><div class=paragraph><p>Different programs expect various levels of structure, but the kernel does not impose structure on I/O.
For instance, the convention for text files is lines of ASCII characters separated by a single newline character (the ASCII line-feed character), but the kernel knows nothing about this convention.
For the purposes of most programs, the model is further simplified to being a stream of data bytes, or an <em>I/O stream</em>.
It is this single common data form that makes the characteristic UNIX tool-based
approach work <a href=../design-44bsd/#biblio-kernighan>[Kernighan & Pike</a>].
An I/O stream from one program can be fed as input to almost any other program.
(This kind of traditional UNIX I/O stream should not be confused with the Eighth Edition stream I/O system or with the System V, Release 3 STREAMS, both of which can be accessed as traditional I/O streams.)</p></div><div class=sect3><h4 id=_descriptors_and_io>2.1.6.1. Descriptors and I/O<a class=anchor href=#_descriptors_and_io></a></h4><div class=paragraph><p>UNIX processes use <em>descriptors</em> to reference I/O streams.
Descriptors are small unsigned integers obtained from the <em>open</em> and <em>socket</em> system calls.
The <em>open</em> system call takes as arguments the name of a file and a permission mode to specify whether the file should be open for reading or for writing, or for both.
This system call also can be used to create a new, empty file.
A <em>read</em> or <em>write</em> system call can be applied to a descriptor to transfer data.
The <em>close</em> system call can be used to deallocate any descriptor.</p></div><div class=paragraph><p>Descriptors represent underlying objects supported by the kernel, and are created by system calls specific to the type of object.
In 4.4BSD, three kinds of objects can be represented by descriptors: files, pipes, and sockets.</p></div><div class=ulist><ul><li><p>A <em>file</em> is a linear array of bytes with at least one name. A file exists until all its names are deleted explicitly and no process holds a descriptor for it. A process acquires a descriptor for a file by opening that file’s name with the <em>open</em> system call. I/O devices are accessed as files.</p></li><li><p>A <em>pipe</em> is a linear array of bytes, as is a file, but it is used solely as an I/O stream, and it is unidirectional. It also has no name, and thus cannot be opened with <em>open</em>. Instead, it is created by the <em>pipe</em> system call, which returns two descriptors, one of which accepts input that is sent to the other descriptor reliably, without duplication, and in order. The system also supports a named pipe or FIFO. A FIFO has properties identical to a pipe, except that it appears in the filesystem; thus, it can be opened using the <em>open</em> system call. Two processes that wish to communicate each open the FIFO: One opens it for reading, the other for writing.</p></li><li><p>A <em>socket</em> is a transient object that is used for interprocess communication; it exists only as long as some process holds a descriptor referring to it. A socket is created by the <em>socket</em> system call, which returns a descriptor for it. There are different kinds of sockets that support various communication semantics, such as reliable delivery of data, preservation of message ordering, and preservation of message boundaries.</p></li></ul></div><div class=paragraph><p>In systems before 4.2BSD, pipes were implemented using the filesystem; when sockets were introduced in 4.2BSD, pipes were reimplemented as sockets.</p></div><div class=paragraph><p>The kernel keeps for each process a <em>descriptor table</em>, which is a table that the kernel uses to translate the external representation of a descriptor into an internal representation.
(The descriptor is merely an index into this table.)
The descriptor table of a process is inherited from that process’s parent, and thus access to the objects to which the descriptors refer also is inherited.
The main ways that a process can obtain a descriptor are by opening or creation of an object, and by inheritance from the parent process.
In addition, socket IPC allows passing of descriptors in messages between unrelated processes on the same machine.</p></div><div class=paragraph><p>Every valid descriptor has an associated <em>file offset</em> in bytes from the beginning of the object.
Read and write operations start at this offset, which is updated after each data transfer.
For objects that permit random access, the file offset also may be set with the <em>lseek</em> system call.
Ordinary files permit random access, and some devices do, as well.
Pipes and sockets do not.</p></div><div class=paragraph><p>When a process terminates, the kernel reclaims all the descriptors that were in use by that process.
If the process was holding the final reference to an object, the object’s manager is notified so that it can do any necessary cleanup actions, such as final deletion of a file or deallocation of a socket.</p></div></div><div class=sect3><h4 id=_descriptor_management>2.1.6.2. Descriptor Management<a class=anchor href=#_descriptor_management></a></h4><div class=paragraph><p>Most processes expect three descriptors to be open already when they start running.
These descriptors are 0, 1, 2, more commonly known as <em>standard input</em>, <em>standard output</em>, and <em>standard error</em>, respectively.
Usually, all three are associated with the user’s terminal by the login process (see Section 14.6) and are inherited through <em>fork</em> and <em>exec</em> by processes run by the user.
Thus, a program can read what the user types by reading standard input, and the program can send output to the user’s screen by writing to standard output.
The standard error descriptor also is open for writing and is used for error output, whereas standard output is used for ordinary output.</p></div><div class=paragraph><p>These (and other) descriptors can be mapped to objects other than the terminal; such mapping is called <em>I/O redirection</em>, and all the standard shells permit users to do it.
The shell can direct the output of a program to a file by closing descriptor 1 (standard output) and opening the desired output file to produce a new descriptor 1.
It can similarly redirect standard input to come from a file by closing descriptor 0 and opening the file.</p></div><div class=paragraph><p>Pipes allow the output of one program to be input to another program without rewriting or even relinking of either program.
Instead of descriptor 1 (standard output) of the source program being set up to write to the terminal, it is set up to be the input descriptor of a pipe.
Similarly, descriptor 0 (standard input) of the sink program is set up to reference the output of the pipe, instead of the terminal keyboard.
The resulting set of two processes and the connecting pipe is known as a <em>pipeline</em>.
Pipelines can be arbitrarily long series of processes connected by pipes.</p></div><div class=paragraph><p>The <em>open</em>, <em>pipe</em>, and <em>socket</em> system calls produce new descriptors with the lowest unused number usable for a descriptor.
For pipelines to work, some mechanism must be provided to map such descriptors into 0 and 1.
The <em>dup</em> system call creates a copy of a descriptor that points to the same file-table entry.
The new descriptor is also the lowest unused one, but if the desired descriptor is closed first, <em>dup</em> can be used to do the desired mapping.
Care is required, however: If descriptor 1 is desired, and descriptor 0 happens also to have been closed, descriptor 0 will be the result.
To avoid this problem, the system provides the <em>dup2</em> system call; it is like <em>dup</em>, but it takes an additional argument specifying the number of the desired descriptor (if the desired descriptor was already open, <em>dup2</em> closes it before reusing it).</p></div></div><div class=sect3><h4 id=_devices>2.1.6.3. Devices<a class=anchor href=#_devices></a></h4><div class=paragraph><p>Hardware devices have filenames, and may be accessed by the user via the same system calls used for regular files.
The kernel can distinguish a <em>device special file</em> or <em>special file</em>, and can determine to what device it refers, but most processes do not need to make this determination.
Terminals, printers, and tape drives are all accessed as though they were streams of bytes, like 4.4BSD disk files.
Thus, device dependencies and peculiarities are kept in the kernel as much as possible, and even in the kernel most of them are segregated in the device drivers.</p></div><div class=paragraph><p>Hardware devices can be categorized as either <em>structured</em> or <em>unstructured</em>; they are known as <em>block</em> or <em>character</em> devices, respectively.
Processes typically access devices through <em>special files</em> in the filesystem.
I/O operations to these files are handled by kernel-resident software modules termed <em>device drivers</em>.
Most network-communication hardware devices are accessible through only the interprocess-communication facilities, and do not have special files in the filesystem name space, because the <em>raw-socket</em> interface provides a more natural interface than does a special file.</p></div><div class=paragraph><p>Structured or block devices are typified by disks and magnetic tapes, and include most random-access devices.
The kernel supports read-modify-write-type buffering actions on block-oriented structured devices to allow the latter to be read and written in a totally random byte-addressed fashion, like regular files.
Filesystems are created on block devices.</p></div><div class=paragraph><p>Unstructured devices are those devices that do not support a block structure.
Familiar unstructured devices are communication lines, raster plotters, and unbuffered magnetic tapes and disks.
Unstructured devices typically support large block I/O transfers.</p></div><div class=paragraph><p>Unstructured files are called <em>character devices</em> because the first of these to be implemented were terminal device drivers.
The kernel interface to the driver for these devices proved convenient for other devices that were not block structured.</p></div><div class=paragraph><p>Device special files are created by the <em>mknod</em> system call.
There is an additional system call, <em>ioctl</em>, for manipulating the underlying device parameters of special files.
The operations that can be done differ for each device.
This system call allows the special characteristics of devices to be accessed, rather than overloading the semantics of other system calls.
For example, there is an <em>ioctl</em> on a tape drive to write an end-of-tape mark, instead of there being a special or modified version of <em>write</em>.</p></div></div><div class=sect3><h4 id=_socket_ipc>2.1.6.4. Socket IPC<a class=anchor href=#_socket_ipc></a></h4><div class=paragraph><p>The 4.2BSD kernel introduced an IPC mechanism more flexible than pipes, based on <em>sockets</em>.
A socket is an endpoint of communication referred to by a descriptor, just like a file or a pipe.
Two processes can each create a socket, and then connect those two endpoints to produce a reliable byte stream.
Once connected, the descriptors for the sockets can be read or written by processes, just as the latter would do with a pipe.
The transparency of sockets allows the kernel to redirect the output of one process to the input of another process residing on another machine.
A major difference between pipes and sockets is that pipes require a common parent process to set up the communications channel.
A connection between sockets can be set up by two unrelated processes, possibly residing on different machines.</p></div><div class=paragraph><p>System V provides local interprocess communication through FIFOs (also known as <em>named pipes</em>).
FIFOs appear as an object in the filesystem that unrelated processes can open and send data through in the same way as they would communicate through a pipe.
Thus, FIFOs do not require a common parent to set them up; they can be connected after a pair of processes are up and running.
Unlike sockets, FIFOs can be used on only a local machine; they cannot be used to communicate between processes on different machines.
FIFOs are implemented in 4.4BSD only because they are required by the POSIX.1 standard.
Their functionality is a subset of the socket interface.</p></div><div class=paragraph><p>The socket mechanism requires extensions to the traditional UNIX I/O system calls to provide the associated naming and connection semantics.
Rather than overloading the existing interface, the developers used the existing interfaces to the extent that the latter worked without being changed, and designed new interfaces to handle the added semantics.
The <em>read</em> and <em>write</em> system calls were used for byte-stream type connections, but six new system calls were added to allow sending and receiving addressed messages such as network datagrams.
The system calls for writing messages include <em>send</em>, <em>sendto</em>, and <em>sendmsg</em>.
The system calls for reading messages include <em>recv</em>, <em>recvfrom</em>, and <em>recvmsg</em>.
In retrospect, the first two in each class are special cases of the others; <em>recvfrom</em> and <em>sendto</em> probably should have been added as library interfaces to <em>recvmsg</em> and <em>sendmsg</em>, respectively.</p></div></div><div class=sect3><h4 id=_scattergather_io>2.1.6.5. Scatter/Gather I/O<a class=anchor href=#_scattergather_io></a></h4><div class=paragraph><p>In addition to the traditional <em>read</em> and <em>write</em> system calls, 4.2BSD introduced the ability to do scatter/gather I/O.
Scatter input uses the <em>readv</em> system call to allow a single read to be placed in several different buffers.
Conversely, the <em>writev</em> system call allows several different buffers to be written in a single atomic write.
Instead of passing a single buffer and length parameter, as is done with <em>read</em> and <em>write</em>, the process passes in a pointer to an array of buffers and lengths, along with a count describing the size of the array.</p></div><div class=paragraph><p>This facility allows buffers in different parts of a process address space to be written atomically, without the need to copy them to a single contiguous buffer.
Atomic writes are necessary in the case where the underlying abstraction is record based, such as tape drives that output a tape block on each write request.
It is also convenient to be able to read a single request into several different buffers (such as a record header into one place and the data into another).
Although an application can simulate the ability to scatter data by reading the data into a large buffer and then copying the pieces to their intended destinations, the cost of memory-to-memory copying in such cases often would more than double the running time of the affected application.</p></div><div class=paragraph><p>Just as <em>send</em> and <em>recv</em> could have been implemented as library interfaces to <em>sendto</em> and <em>recvfrom</em>, it also would have been possible to simulate <em>read</em> with <em>readv</em> and <em>write</em> with <em>writev</em>.
However, <em>read</em> and <em>write</em> are used so much more frequently that the added cost of simulating them would not have been worthwhile.</p></div></div><div class=sect3><h4 id=_multiple_filesystem_support>2.1.6.6. Multiple Filesystem Support<a class=anchor href=#_multiple_filesystem_support></a></h4><div class=paragraph><p>With the expansion of network computing, it became desirable to support both local and remote filesystems.
To simplify the support of multiple filesystems, the developers added a new virtual node or <em>vnode</em> interface to the kernel.
The set of operations exported from the vnode interface appear much like the filesystem operations previously supported by the local filesystem.
However, they may be supported by a wide range of filesystem types:</p></div><div class=ulist><ul><li><p>Local disk-based filesystems</p></li><li><p>Files imported using a variety of remote filesystem protocols</p></li><li><p>Read-only CD-ROM filesystems</p></li><li><p>Filesystems providing special-purpose interfaces — for example, the <code>/proc</code> filesystem</p></li></ul></div><div class=paragraph><p>A few variants of 4.4BSD, such as FreeBSD, allow filesystems to be loaded dynamically when the filesystems are first referenced by the <em>mount</em> system call.
The vnode interface is described in Section 6.5; its ancillary support routines are described in Section 6.6; several of the special-purpose filesystems are described in Section 6.7.</p></div></div></div><div class=sect2><h3 id=overview-filesystem>2.1.7. Filesystems<a class=anchor href=#overview-filesystem></a></h3><div class=paragraph><p>A regular file is a linear array of bytes, and can be read and written starting at any byte in the file.
The kernel distinguishes no record boundaries in regular files, although many programs recognize line-feed characters as distinguishing the ends of lines, and other programs may impose other structure.
No system-related information about a file is kept in the file itself, but the filesystem stores a small amount of ownership, protection, and usage information with each file.</p></div><div class=paragraph><p>A <em>filename</em> component is a string of up to 255 characters. These filenames are stored in a type of file called a <em>directory</em>.
The information in a directory about a file is called a <em>directory entry</em> and includes, in addition to the filename, a pointer to the file itself.
Directory entries may refer to other directories, as well as to plain files.
A hierarchy of directories and files is thus formed, and is called a <em>filesystem</em>;</p></div><div id=fig-small-fs class=paragraph><div class=title>A small filesystem</div><p><span class=image><img src=../../../images/books/design-44bsd/fig2.png alt="A small filesystem"></span></p></div><div class=paragraph><p>a small one is shown in <a href=../design-44bsd/#fig-small-fs>A small filesystem</a>.
Directories may contain subdirectories, and there is no inherent limitation to the depth with which directory nesting may occur.
To protect the consistency of the filesystem, the kernel does not permit processes to write directly into directories.
A filesystem may include not only plain files and directories, but also references to other objects, such as devices and sockets.</p></div><div class=paragraph><p>The filesystem forms a tree, the beginning of which is the <em>root directory</em>, sometimes referred to by the name <em>slash</em>, spelled with a single solidus character (/).
The root directory contains files; in our example in Fig 2.2, it contains <code>vmunix</code>, a copy of the kernel-executable object file.
It also contains directories; in this example, it contains the <code>usr</code> directory.
Within the <code>usr</code> directory is the <code>bin</code> directory, which mostly contains executable object code of programs, such as the files <code>ls</code> and <code>vi</code>.</p></div><div class=paragraph><p>A process identifies a file by specifying that file’s <em>pathname</em>, which is a string composed of zero or more filenames separated by slash (/) characters.
The kernel associates two directories with each process for use in interpreting pathnames.
A process’s <em>root directory</em> is the topmost point in the filesystem that the process can access; it is ordinarily set to the root directory of the entire filesystem.
A pathname beginning with a slash is called an <em>absolute pathname</em>, and is interpreted by the kernel starting with the process’s root directory.</p></div><div class=paragraph><p>A pathname that does not begin with a slash is called a <em>relative pathname</em>, and is interpreted relative to the <em>current working directory</em> of the process.
(This directory also is known by the shorter names <em>current directory</em> or <em>working directory</em>.)
The current directory itself may be referred to directly by the name <em>dot</em>, spelled with a single period (<code>.</code>)
The filename <em>dot-dot</em> (<code>..</code>) refers to a directory’s parent directory.
The root directory is its own parent.</p></div><div class=paragraph><p>A process may set its root directory with the <em>chroot</em> system call, and its current directory with the <em>chdir</em> system call.
Any process may do <em>chdir</em> at any time, but <em>chroot</em> is permitted only a process with superuser privileges.
<em>Chroot</em> is normally used to set up restricted access to the system.</p></div><div class=paragraph><p>Using the filesystem shown in Fig. 2.2, if a process has the root of the filesystem as its root directory, and has <code>/usr</code> as its current directory, it can refer to the file <code>vi</code> either from the root with the absolute pathname <code>/usr/bin/vi</code>, or from its current directory with the relative pathname <code>bin/vi</code>.</p></div><div class=paragraph><p>System utilities and databases are kept in certain well-known directories.
Part of the well-defined hierarchy includes a directory that contains the <em>home directory</em> for each user — for example, <code>/usr/staff/mckusick</code> and <code>/usr/staff/karels</code> in Fig. 2.2.
When users log in, the current working directory of their shell is set to the home directory.
Within their home directories, users can create directories as easily as they can regular files.
Thus, a user can build arbitrarily complex subhierarchies.</p></div><div class=paragraph><p>The user usually knows of only one filesystem, but the system may know that this one virtual filesystem is really composed of several physical filesystems, each on a different device.
A physical filesystem may not span multiple hardware devices.
Since most physical disk devices are divided into several logical devices, there may be more than one filesystem per physical device, but there will be no more than one per logical device.
One filesystem — the filesystem that anchors all absolute pathnames — is called the <em>root filesystem</em>, and is always available.
Others may be mounted; that is, they may be integrated into the directory hierarchy of the root filesystem.
References to a directory that has a filesystem mounted on it are converted transparently by the kernel into references to the root directory of the mounted filesystem.</p></div><div class=paragraph><p>The <em>link</em> system call takes the name of an existing file and another name to create for that file.
After a successful <em>link</em>, the file can be accessed by either filename.
A filename can be removed with the <em>unlink</em> system call.
When the final name for a file is removed (and the final process that has the file open closes it), the file is deleted.</p></div><div class=paragraph><p>Files are organized hierarchically in <em>directories</em>.
A directory is a type of file, but, in contrast to regular files, a directory has a structure imposed on it by the system.
A process can read a directory as it would an ordinary file, but only the kernel is permitted to modify a directory.
Directories are created by the <em>mkdir</em> system call and are removed by the <em>rmdir</em> system call.
Before 4.2BSD, the <em>mkdir</em> and <em>rmdir</em> system calls were implemented by a series of <em>link</em> and <em>unlink</em> system calls being done.
There were three reasons for adding systems calls explicitly to create and delete directories:</p></div><div class="olist arabic"><ol class=arabic><li><p>The operation could be made atomic. If the system crashed, the directory would not be left half-constructed, as could happen when a series of link operations were used.</p></li><li><p>When a networked filesystem is being run, the creation and deletion of files and directories need to be specified atomically so that they can be serialized.</p></li><li><p>When supporting non-UNIX filesystems, such as an MS-DOS filesystem, on another partition of the disk, the other filesystem may not support link operations. Although other filesystems might support the concept of directories, they probably would not create and delete the directories with links, as the UNIX filesystem does. Consequently, they could create and delete directories only if explicit directory create and delete requests were presented.</p></li></ol></div><div class=paragraph><p>The <em>chown</em> system call sets the owner and group of a file, and <em>chmod</em> changes protection attributes.
<em>Stat</em> applied to a filename can be used to read back such properties of a file.
The <em>fchown</em>, <em>fchmod</em>, and <em>fstat</em> system calls are applied to a descriptor, instead of to a filename, to do the same set of operations.
The <em>rename</em> system call can be used to give a file a new name in the filesystem, replacing one of the file’s old names.
Like the directory-creation and directory-deletion operations, the <em>rename</em> system call was added to 4.2BSD to provide atomicity to name changes in the local filesystem.
Later, it proved useful explicitly to export renaming operations to foreign filesystems and over the network.</p></div><div class=paragraph><p>The <em>truncate</em> system call was added to 4.2BSD to allow files to be shortened to an arbitrary offset.
The call was added primarily in support of the Fortran run-time library, which has the semantics such that the end of a random-access file is set to be wherever the program most recently accessed that file.
Without the <em>truncate</em> system call, the only way to shorten a file was to copy the part that was desired to a new file, to delete the old file, then to rename the copy to the original name.
As well as this algorithm being slow, the library could potentially fail on a full filesystem.</p></div><div class=paragraph><p>Once the filesystem had the ability to shorten files, the kernel took advantage of that ability to shorten large empty directories.
The advantage of shortening empty directories is that it reduces the time spent in the kernel searching them when names are being created or deleted.</p></div><div class=paragraph><p>Newly created files are assigned the user identifier of the process that created them and the group identifier of the directory in which they were created.
A three-level access-control mechanism is provided for the protection of files.
These three levels specify the accessibility of a file to</p></div><div class="olist arabic"><ol class=arabic><li><p>The user who owns the file</p></li><li><p>The group that owns the file</p></li><li><p>Everyone else</p></li></ol></div><div class=paragraph><p>Each level of access has separate indicators for read permission, write permission, and execute permission.</p></div><div class=paragraph><p>Files are created with zero length, and may grow when they are written.
While a file is open, the system maintains a pointer into the file indicating the current location in the file associated with the descriptor.
This pointer can be moved about in the file in a random-access fashion.
Processes sharing a file descriptor through a <em>fork</em> or <em>dup</em> system call share the current location pointer.
Descriptors created by separate <em>open</em> system calls have separate current location pointers.
Files may have <em>holes</em> in them.
Holes are void areas in the linear extent of the file where data have never been written.
A process can create these holes by positioning the pointer past the current end-of-file and writing.
When read, holes are treated by the system as zero-valued bytes.</p></div><div class=paragraph><p>Earlier UNIX systems had a limit of 14 characters per filename component.
This limitation was often a problem.
For example, in addition to the natural desire of users to give files long descriptive names, a common way of forming filenames is as <code>basename.extension</code>, where the extension (indicating the kind of file, such as <code>.c</code> for C source or <code>.o</code> for intermediate binary object) is one to three characters, leaving 10 to 12 characters for the basename.
Source-code-control systems and editors usually take up another two characters, either as a prefix or a suffix, for their purposes, leaving eight to 10 characters.
It is easy to use 10 or 12 characters in a single English word as a basename (e.g., <code>multiplexer</code>).</p></div><div class=paragraph><p>It is possible to keep within these limits, but it is inconvenient or even dangerous, because other UNIX systems accept strings longer than the limit when creating files, but then <em>truncate</em> to the limit.
A C language source file named <code>multiplexer.c</code> (already 13 characters) might have a source-code-control file with <code>s.</code> prepended, producing a filename <code>s.multiplexer</code> that is indistinguishable from the source-code-control file for <code>multiplexer.ms</code>, a file containing <code>troff</code> source for documentation for the C program.
The contents of the two original files could easily get confused with no warning from the source-code-control system.
Careful coding can detect this problem, but the long filenames first introduced in 4.2BSD practically eliminate it.</p></div></div><div class=sect2><h3 id=overview-filestore>2.1.8. Filestores<a class=anchor href=#overview-filestore></a></h3><div class=paragraph><p>The operations defined for local filesystems are divided into two parts.
Common to all local filesystems are hierarchical naming, locking, quotas, attribute management, and protection.
These features are independent of how the data will be stored. 4.4BSD has a single implementation to provide these semantics.</p></div><div class=paragraph><p>The other part of the local filesystem is the organization and management of the data on the storage media.
Laying out the contents of files on the storage media is the responsibility of the filestore. 4.4BSD supports three different filestore layouts:</p></div><div class=ulist><ul><li><p>The traditional Berkeley Fast Filesystem</p></li><li><p>The log-structured filesystem, based on the Sprite operating-system design
<a href=../design-44bsd/#biblio-rosenblum>[Rosenblum & Ousterhout</a>]</p></li><li><p>A memory-based filesystem</p></li></ul></div><div class=paragraph><p>Although the organizations of these filestores are completely different, these differences are indistinguishable to the processes using the filestores.</p></div><div class=paragraph><p>The Fast Filesystem organizes data into cylinder groups.
Files that are likely to be accessed together, based on their locations in the filesystem hierarchy, are stored in the same cylinder group.
Files that are not expected to accessed together are moved into different cylinder groups.
Thus, files written at the same time may be placed far apart on the disk.</p></div><div class=paragraph><p>The log-structured filesystem organizes data as a log.
All data being written at any point in time are gathered together, and are written at the same disk location.
Data are never overwritten; instead, a new copy of the file is written that replaces the old one.
The old files are reclaimed by a garbage-collection process that runs when the filesystem becomes full and additional free space is needed.</p></div><div class=paragraph><p>The memory-based filesystem is designed to store data in virtual memory.
It is used for filesystems that need to support fast but temporary data, such as <code>/tmp</code>.
The goal of the memory-based filesystem is to keep the storage packed as compactly as possible to minimize the usage of virtual-memory resources.</p></div></div><div class=sect2><h3 id=overview-nfs>2.1.9. Network Filesystem<a class=anchor href=#overview-nfs></a></h3><div class=paragraph><p>Initially, networking was used to transfer data from one machine to another.
Later, it evolved to allowing users to log in remotely to another machine.
The next logical step was to bring the data to the user, instead of having the user go to the data — and network filesystems were born.
Users working locally do not experience the network delays on each keystroke, so they have a more responsive environment.</p></div><div class=paragraph><p>Bringing the filesystem to a local machine was among the first of the major client-server applications.
The <em>server</em> is the remote machine that exports one or more of its filesystems.
The <em>client</em> is the local machine that imports those filesystems.
From the local client’s point of view, a remotely mounted filesystem appears in the file-tree name space just like any other locally mounted filesystem.
Local clients can change into directories on the remote filesystem, and can read, write, and execute binaries within that remote filesystem identically to the way that they can do these operations on a local filesystem.</p></div><div class=paragraph><p>When the local client does an operation on a remote filesystem, the request is packaged and is sent to the server.
The server does the requested operation and returns either the requested information or an error indicating why the request was denied.
To get reasonable performance, the client must cache frequently accessed data.
The complexity of remote filesystems lies in maintaining cache consistency between the server and its many clients.</p></div><div class=paragraph><p>Although many remote-filesystem protocols have been developed over the years, the most pervasive one in use among UNIX systems is the Network Filesystem (NFS), whose protocol and most widely used implementation were done by Sun Microsystems.
The 4.4BSD kernel supports the NFS protocol, although the implementation was
done independently from the protocol specification
<a href=../design-44bsd/#biblio-macklem>[Macklem</a>].
The NFS protocol is described in Chapter 9.</p></div></div><div class=sect2><h3 id=overview-terminal>2.1.10. Terminals<a class=anchor href=#overview-terminal></a></h3><div class=paragraph><p>Terminals support the standard system I/O operations, as well as a collection of terminal-specific operations to control input-character editing and output delays.
At the lowest level are the terminal device drivers that control the hardware terminal ports.
Terminal input is handled according to the underlying communication characteristics, such as baud rate, and according to a set of software-controllable parameters, such as parity checking.</p></div><div class=paragraph><p>Layered above the terminal device drivers are line disciplines that provide various degrees of character processing.
The default line discipline is selected when a port is being used for an interactive login.
The line discipline is run in <em>canonical mode</em>; input is processed to provide standard line-oriented editing functions, and input is presented to a process on a line-by-line basis.</p></div><div class=paragraph><p>Screen editors and programs that communicate with other computers generally run in <em>noncanonical mode</em> (also commonly referred to as <em>raw mode</em> or <em>character-at-a-time mode</em>).
In this mode, input is passed through to the reading process immediately and without interpretation.
All special-character input processing is disabled, no erase or other line editing processing is done, and all characters are passed to the program that is reading from the terminal.</p></div><div class=paragraph><p>It is possible to configure the terminal in thousands of combinations between these two extremes.
For example, a screen editor that wanted to receive user interrupts asynchronously might enable the special characters that generate signals and enable output flow control, but otherwise run in noncanonical mode; all other characters would be passed through to the process uninterpreted.</p></div><div class=paragraph><p>On output, the terminal handler provides simple formatting services, including</p></div><div class=ulist><ul><li><p>Converting the line-feed character to the two-character carriage-return-line-feed sequence</p></li><li><p>Inserting delays after certain standard control characters</p></li><li><p>Expanding tabs</p></li><li><p>Displaying echoed nongraphic ASCII characters as a two-character sequence of the form <code>^C</code> (i.e., the ASCII caret character followed by the ASCII character that is the character’s value offset from the ASCII <code>@</code> character).</p></li></ul></div><div class=paragraph><p>Each of these formatting services can be disabled individually by a process through control requests.</p></div></div><div class=sect2><h3 id=overview-ipc>2.1.11. Interprocess Communication<a class=anchor href=#overview-ipc></a></h3><div class=paragraph><p>Interprocess communication in 4.4BSD is organized in <em>communication domains</em>.
Domains currently supported include the <em>local domain</em>, for communication between processes executing on the same machine; the <em>internet domain</em>, for communication between processes using the TCP/IP protocol suite (perhaps within the Internet); the ISO/OSI protocol family for communication between sites required to run them; and the <em>XNS domain</em>, for communication between processes using the XEROX Network Systems (XNS) protocols.</p></div><div class=paragraph><p>Within a domain, communication takes place between communication endpoints known as <em>sockets</em>.
As mentioned in Section 2.6, the <em>socket</em> system call creates a socket and returns a descriptor; other IPC system calls are described in Chapter 11.
Each socket has a type that defines its communications semantics; these semantics include properties such as reliability, ordering, and prevention of duplication of messages.</p></div><div class=paragraph><p>Each socket has associated with it a <em>communication protocol</em>.
This protocol provides the semantics required by the socket according to the latter’s type.
Applications may request a specific protocol when creating a socket, or may allow the system to select a protocol that is appropriate for the type of socket being created.</p></div><div class=paragraph><p>Sockets may have addresses bound to them.
The form and meaning of socket addresses are dependent on the communication domain in which the socket is created.
Binding a name to a socket in the local domain causes a file to be created in the filesystem.</p></div><div class=paragraph><p>Normal data transmitted and received through sockets are untyped.
Data-representation issues are the responsibility of libraries built on top of the interprocess-communication facilities.
In addition to transporting normal data, communication domains may support the transmission and reception of specially typed data, termed <em>access rights</em>.
The local domain, for example, uses this facility to pass descriptors between processes.</p></div><div class=paragraph><p>Networking implementations on UNIX before 4.2BSD usually worked by overloading the character-device interfaces.
One goal of the socket interface was for naive programs to be able to work without change on stream-style connections.
Such programs can work only if the <em>read</em> and <em>write</em> systems calls are unchanged.
Consequently, the original interfaces were left intact, and were made to work on stream-type sockets.
A new interface was added for more complicated sockets, such as those used to send datagrams, with which a destination address must be presented with each <em>send</em> call.</p></div><div class=paragraph><p>Another benefit is that the new interface is highly portable.
Shortly after a test release was available from Berkeley, the socket interface had been ported to System III by a UNIX vendor (although AT&amp;T did not support the socket interface until the release of System V Release 4, deciding instead to use the Eighth Edition stream mechanism).
The socket interface was also ported to run in many Ethernet boards by vendors, such as Excelan and Interlan, that were selling into the PC market, where the machines were too small to run networking in the main processor.
More recently, the socket interface was used as the basis for Microsoft’s Winsock networking interface for Windows.</p></div></div><div class=sect2><h3 id=overview-network-communication>2.1.12. Network Communication<a class=anchor href=#overview-network-communication></a></h3><div class=paragraph><p>Some of the communication domains supported by the <em>socket</em> IPC mechanism provide access to network protocols.
These protocols are implemented as a separate software layer logically below the socket software in the kernel.
The kernel provides many ancillary services, such as buffer management, message routing, standardized interfaces to the protocols, and interfaces to the network interface drivers for the use of the various network protocols.</p></div><div class=paragraph><p>At the time that 4.2BSD was being implemented, there were many networking protocols in use or under development, each with its own strengths and weaknesses.
There was no clearly superior protocol or protocol suite.
By supporting multiple protocols, 4.2BSD could provide interoperability and resource sharing among the diverse set of machines that was available in the Berkeley environment.
Multiple-protocol support also provides for future changes.
Today’s protocols designed for 10- to 100-Mbit-per-second Ethernets are likely to be inadequate for tomorrow’s 1- to 10-Gbit-per-second fiber-optic networks.
Consequently, the network-communication layer is designed to support multiple protocols.
New protocols are added to the kernel without the support for older protocols being affected.
Older applications can continue to operate using the old protocol over the same physical network as is used by newer applications running with a newer network protocol.</p></div></div><div class=sect2><h3 id=overview-network-implementation>2.1.13. Network Implementation<a class=anchor href=#overview-network-implementation></a></h3><div class=paragraph><p>The first protocol suite implemented in 4.2BSD was DARPA’s Transmission Control Protocol/Internet Protocol (TCP/IP).
The CSRG chose TCP/IP as the first network to incorporate into the socket IPC framework, because a 4.1BSD-based implementation was publicly available from a DARPA-sponsored project at Bolt, Beranek, and Newman (BBN).
That was an influential choice: The 4.2BSD implementation is the main reason for the extremely widespread use of this protocol suite.
Later performance and capability improvements to the TCP/IP implementation have also been widely adopted.
The TCP/IP implementation is described in detail in Chapter 13.</p></div><div class=paragraph><p>The release of 4.3BSD added the Xerox Network Systems (XNS) protocol suite, partly building on work done at the University of Maryland and at Cornell University.
This suite was needed to connect isolated machines that could not communicate using TCP/IP.</p></div><div class=paragraph><p>The release of 4.4BSD added the ISO protocol suite because of the latter’s increasing visibility both within and outside the United States.
Because of the somewhat different semantics defined for the ISO protocols, some minor changes were required in the socket interface to accommodate these semantics.
The changes were made such that they were invisible to clients of other existing protocols.
The ISO protocols also required extensive addition to the two-level routing tables provided by the kernel in 4.3BSD.
The greatly expanded routing capabilities of 4.4BSD include arbitrary levels of routing with variable-length addresses and network masks.</p></div></div><div class=sect2><h3 id=overview-operation>2.1.14. System Operation<a class=anchor href=#overview-operation></a></h3><div class=paragraph><p>Bootstrapping mechanisms are used to start the system running.
First, the 4.4BSD kernel must be loaded into the main memory of the processor.
Once loaded, it must go through an initialization phase to set the hardware into a known state.
Next, the kernel must do autoconfiguration, a process that finds and configures the peripherals that are attached to the processor.
The system begins running in single-user mode while a start-up script does disk checks and starts the accounting and quota checking.
Finally, the start-up script starts the general system services and brings up the system to full multiuser operation.</p></div><div class=paragraph><p>During multiuser operation, processes wait for login requests on the terminal lines and network ports that have been configured for user access.
When a login request is detected, a login process is spawned and user validation is done.
When the login validation is successful, a login shell is created from which the user can run additional processes.</p></div></div></div></div><div class=sect1><h2 id=references>References<a class=anchor href=#references></a></h2><div class=sectionbody><div class=paragraph><p><a id=biblio-accetta></a>Accetta et al, 1986 Mach: A New Kernel Foundation for UNIX Development" M.Accetta R.Baron W.Bolosky D.Golub R.Rashid A.Tevanian M.Young 93-113 USENIX Association Conference Proceedings USENIX Association June 1986</p></div><div class=paragraph><p><a id=biblio-cheriton></a>Cheriton, 1988 The V Distributed System D. R.Cheriton 314-333 Comm ACM, 31, 3 March 1988</p></div><div class=paragraph><p><a id=biblio-ewens></a>Ewens et al, 1985 Tunis: A Distributed Multiprocessor Operating System P.Ewens D. R.Blythe M.Funkenhauser R. C.Holt 247-254 USENIX Assocation Conference Proceedings USENIX Association June 1985</p></div><div class=paragraph><p><a id=biblio-gingell></a>Gingell et al, 1987 Virtual Memory Architecture in SunOS R.Gingell J.Moran W.Shannon 81-94 USENIX Association Conference Proceedings USENIX Association June 1987</p></div><div class=paragraph><p><a id=biblio-kernighan></a>Kernighan & Pike, 1984 The UNIX Programming Environment B. W.Kernighan R.Pike Prentice-Hall Englewood Cliffs NJ 1984</p></div><div class=paragraph><p><a id=biblio-macklem></a>Macklem, 1994 The 4.4BSD NFS Implementation R.Macklem 6:1-14 4.4BSD System Manager’s Manual O’Reilly & Associates, Inc. Sebastopol CA 1994</p></div><div class=paragraph><p><a id=biblio-mckusick-2></a>McKusick & Karels, 1988 Design of a General Purpose Memory Allocator for the 4.3BSD UNIX Kernel M. K.McKusick M. J.Karels 295-304 USENIX Assocation Conference Proceedings USENIX Assocation June 1998</p></div><div class=paragraph><p><a id=biblio-mckusick-1></a>McKusick et al, 1994 Berkeley Software Architecture Manual, 4.4BSD Edition M. K.McKusick M. J.Karels S. J.Leffler W. N.Joy R. S.Faber 5:1-42 4.4BSD Programmer’s Supplementary Documents O’Reilly & Associates, Inc. Sebastopol CA 1994</p></div><div class=paragraph><p><a id=biblio-ritchie></a>Ritchie, 1988 Early Kernel Design private communication D. M.Ritchie March 1988</p></div><div class=paragraph><p><a id=biblio-rosenblum></a>Rosenblum & Ousterhout, 1992 The Design and Implementation of a Log-Structured File System M.Rosenblum K.Ousterhout 26-52 ACM Transactions on Computer Systems, 10, 1 Association for Computing Machinery February 1992</p></div><div class=paragraph><p><a id=biblio-rozier></a>Rozier et al, 1988 Chorus Distributed Operating Systems M.Rozier V.Abrossimov F.Armand I.Boule M.Gien M.Guillemont F.Herrmann C.Kaiser S.Langlois P.Leonard W.Neuhauser 305-370 USENIX Computing Systems, 1, 4 Fall 1988</p></div><div class=paragraph><p><a id=biblio-tevanian></a>Tevanian, 1987 Architecture-Independent Virtual Memory Management for Parallel and Distributed Environments: The Mach Approach Technical Report CMU-CS-88-106, A.Tevanian Department of Computer Science, Carnegie-Mellon University Pittsburgh PA December 1987</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: September 23, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=c6f45f0053" target=_blank>Fernando Apesteguía</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#overview>2.1. Design Overview of 4.4BSD</a><ul><li><a href=#overview-facilities>2.1.1. 4.4BSD Facilities and the Kernel</a></li><li><a href=#overview-kernel-organization>2.1.2. Kernel Organization</a></li><li><a href=#overview-kernel-service>2.1.3. Kernel Services</a></li><li><a href=#overview-process-management>2.1.4. Process Management</a></li><li><a href=#overview-memory-management>2.1.5. Memory Management</a></li><li><a href=#overview-io-system>2.1.6. I/O System</a></li><li><a href=#overview-filesystem>2.1.7. Filesystems</a></li><li><a href=#overview-filestore>2.1.8. Filestores</a></li><li><a href=#overview-nfs>2.1.9. Network Filesystem</a></li><li><a href=#overview-terminal>2.1.10. Terminals</a></li><li><a href=#overview-ipc>2.1.11. Interprocess Communication</a></li><li><a href=#overview-network-communication>2.1.12. Network Communication</a></li><li><a href=#overview-network-implementation>2.1.13. Network Implementation</a></li><li><a href=#overview-operation>2.1.14. System Operation</a></li></ul></li><li><a href=#references>References</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/design-44bsd/design-44bsd_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/en/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>