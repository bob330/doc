<!doctype html><html class=theme-light lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Virtualization software allows multiple operating systems to run simultaneously on the same computer"><meta name=keywords content="virtualization,Parallels,VMware,VirtualBox,QEMU,bhyve,XEN"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/en/books/handbook/virtualization/><title>Chapter 24. Virtualization | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapter 24. Virtualization"><meta property="og:description" content="Virtualization software allows multiple operating systems to run simultaneously on the same computer"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="http://172.16.201.134:1313/en/books/handbook/virtualization/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/en\/books\/handbook\/virtualization\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/en/books>Books</a></li><li><a href=http://172.16.201.134:1313/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/preface/>Preface</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-audience>Intended Audience</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-changes-from4>Fourth Edition</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-changes-from3>Third Edition</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-changes-from2>Second Edition (2004)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-changes>First Edition (2001)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-overview>Organization of This Book</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-conv>Conventions used in this book</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/preface/#preface-acknowledgements>Acknowledgments</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/parti/>Part I. Getting Started</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/introduction/>Chapter 1. Introduction</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/introduction/#introduction-synopsis>1.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/introduction/#nutshell>1.2. Welcome to FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/introduction/#history>1.3. About the FreeBSD Project</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/>Chapter 2. Installing FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Minimum Hardware Requirements</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Pre-Installation Tasks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-start>2.4. Starting the Installation</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#using-bsdinstall>2.5. Using bsdinstall</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Allocating Disk Space</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Fetching Distribution Files</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-post>2.8. Network Interfaces, Accounts, Time Zone, Services and Hardening</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.9. Troubleshooting</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bsdinstall/#using-live-cd>2.10. Using the Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/basics/>Chapter 3. FreeBSD Basics</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#basics-synopsis>3.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#consoles>3.2. Virtual Consoles and Terminals</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#users-synopsis>3.3. Users and Basic Account Management</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#permissions>3.4. Permissions</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#dirstructure>3.5. Directory Structure</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#disk-organization>3.6. Disk Organization</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#mount-unmount>3.7. Mounting and Unmounting File Systems</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#basics-processes>3.8. Processes and Daemons</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#editors>3.10. Text Editors</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#basics-devices>3.11. Devices and Device Nodes</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/basics/#basics-more-information>3.12. Manual Pages</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/ports/>Chapter 4. Installing Applications: Packages and Ports</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#ports-synopsis>4.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#ports-overview>4.2. Overview of Software Installation</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#ports-finding-applications>4.3. Finding Software</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#pkgng-intro>4.4. Using pkg for Binary Package Management</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#ports-using>4.5. Using the Ports Collection</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#ports-poudriere>4.6. Building Packages with poudriere</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#ports-nextsteps>4.7. Post-Installation Considerations</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ports/#ports-broken>4.8. Dealing with Broken Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/x11/>Chapter 5. The X Window System</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/x11/#x11-synopsis>5.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/x11/#x-install>5.2. Installing Xorg</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/x11/#x-graphic-card-drivers>5.3. Graphic card drivers</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/x11/#x-config>5.4. Xorg Configuration</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/x11/#x-fonts>5.5. Using Fonts in Xorg</a></li></ul></li><li><input type=checkbox id=chapter-f56428b9e0d0b77cc8e863910f96bbde class=toggle>
<label class="icon cursor" for=chapter-f56428b9e0d0b77cc8e863910f96bbde><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/wayland/>Chapter 6. Wayland</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-synopsis>6.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-overview>6.2. Wayland Overview</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-wayfire>6.3. The Wayfire Compositor</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-hikari>6.4. The Hikari Compositor</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-sway>6.5. The Sway Compositor</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-xwayland>6.6. Using Xwayland</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-remotedesktop>6.7. Remote Desktop Using VNC</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-ly>6.8. Wayland Login Manager</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wayland/#wayland-utilities>6.9. Useful Utilities</a></li></ul></li><li><input type=checkbox id=chapter-848ec5cebce5c9662e0ba48157db1823 class=toggle>
<label class="icon cursor" for=chapter-848ec5cebce5c9662e0ba48157db1823><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/network/>Chapter 7. Network</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/network/#network-synopsis>7.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network/#config-network-setup>7.2. Setting up the Network</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network/#config-network-connection>7.3. Wired Networks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network/#network-wireless>7.4. Wireless Networks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network/#hostname>7.5. Hostname</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network/#dns>7.6. DNS</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network/#troubleshooting>7.7. Troubleshooting</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/partii/>Part II. Common Tasks</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/desktop/>Chapter 8. Desktop Environments</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/desktop/#desktop-synopsis>8.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/desktop/#desktop-environments>8.2. Desktop Environments</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/desktop/#desktop-browsers>8.3. Browsers</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/desktop/#desktop-development>8.4. Development tools</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/desktop/#desktop-productivity>8.5. Desktop office productivity</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/desktop/#desktop-viewers>8.6. Document Viewers</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/desktop/#desktop-finance>8.7. Finance</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/multimedia/>Chapter 9. Multimedia</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/multimedia/#multimedia-synopsis>9.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/multimedia/#sound-setup>9.2. Setting Up the Sound Card</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/multimedia/#audio-ports>9.3. Audio players</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/multimedia/#video-ports>9.4. Video players</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/multimedia/#conferencing-meetings>9.5. Conferencing and Meetings</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/multimedia/#scanners>9.6. Image Scanners</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/kernelconfig/>Chapter 10. Configuring the FreeBSD Kernel</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/kernelconfig/#kernelconfig-synopsis>10.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/kernelconfig/#kernelconfig-custom-kernel>10.2. Why Build a Custom Kernel?</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/kernelconfig/#kernelconfig-devices>10.3. Finding the System Hardware</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/kernelconfig/#kernelconfig-config>10.4. The Configuration File</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/kernelconfig/#kernelconfig-building>10.5. Building and Installing a Custom Kernel</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/kernelconfig/#kernelconfig-trouble>10.6. If Something Goes Wrong</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/printing/>Chapter 11. Printing</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/printing/#printing-quick-start>11.1. Quick Start</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/printing/#printing-connections>11.2. Printer Connections</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/printing/#printing-pdls>11.3. Common Page Description Languages</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/printing/#printing-direct>11.4. Direct Printing</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/printing/#printing-lpd>11.5. LPD (Line Printer Daemon)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/printing/#printing-other>11.6. Other Printing Systems</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/linuxemu/>Chapter 12. Linux Binary Compatibility</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/linuxemu/#linuxemu-synopsis>12.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/linuxemu/#linuxemu-lbc-install>12.2. Configuring Linux Binary Compatibility</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/linuxemu/#linux-userlands>12.3. Linux userlands</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/linuxemu/#linuxemu-advanced>12.4. Advanced Topics</a></li></ul></li><li><input type=checkbox id=chapter-54c06b703788dcba4081bec5a0407412 class=toggle>
<label class="icon cursor" for=chapter-54c06b703788dcba4081bec5a0407412><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/wine/>Chapter 13. WINE</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#wine-synopsis>13.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#wine-overview-concepts>13.2. WINE Overview & Concepts</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#installing-wine-on-freebsd>13.3. Installing WINE on FreeBSD</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#running-first-wine-program>13.4. Running a First WINE Program on FreeBSD</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#configuring-wine-installation>13.5. Configuring WINE Installation</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#wine-management-guis>13.6. WINE Management GUIs</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#wine-in-multi-user-os-installations>13.7. WINE in Multi-User FreeBSD Installations</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/wine/#wine-on-os-faq>13.8. WINE on FreeBSD FAQ</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/partiii/>Part III. System Administration</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/config/>Chapter 14. Configuration, Services, Logging and Power Management</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/config/#config-synopsis>14.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/config/#configtuning-configfiles>14.2. Configuration Files</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/config/#configtuning-rcd>14.3. Managing Services in FreeBSD</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/config/#cron-periodic>14.4. Cron and Periodic</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/config/#configtuning-syslog>14.5. Configuring System Logging</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/config/#acpi-overview>14.6. Power and Resource Management</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/config/#adding-swap-space>14.7. Adding Swap Space</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/boot/>Chapter 15. The FreeBSD Booting Process</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/boot/#boot-synopsis>15.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/boot/#boot-introduction>15.2. FreeBSD Boot Process</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/boot/#device-hints>15.3. Device Hints</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/boot/#boot-shutdown>15.4. Shutdown Sequence</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/security/>Chapter 16. Security</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-synopsis>16.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-intro>16.2. Introduction</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#sec-accounts>16.3. Securing Accounts</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-ids>16.4. Intrusion Detection System (IDS)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-secure-levels>16.5. Secure levels</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-file-flags>16.6. File flags</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#openssh>16.7. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#openssl>16.8. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#kerberos5>16.9. Kerberos</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#tcpwrappers>16.10. TCP Wrappers</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#fs-acl>16.11. Access Control Lists</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#capsicum>16.12. Capsicum</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-accounting>16.13. Process Accounting</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-resourcelimits>16.14. Resource Limits</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-pkg>16.15. Monitoring Third Party Security Issues</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/security/#security-advisories>16.16. FreeBSD Security Advisories</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/jails/>Chapter 17. Jails and Containers</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#jails-synopsis>17.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#jail-types>17.2. Jail Types</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#host-configuration>17.3. Host Configuration</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#classic-jail>17.4. Classic Jail (Thick Jail)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#thin-jail>17.5. Thin Jails</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#jail-management>17.6. Jail Management</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#jail-upgrading>17.7. Jail Upgrading</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#jail-resource-limits>17.8. Jail Resource Limits</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/jails/#jail-managers-and-containers>17.9. Jail Managers and Containers</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/mac/>Chapter 18. Mandatory Access Control</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-synopsis>18.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-inline-glossary>18.2. Key Terms</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-understandlabel>18.3. Understanding MAC Labels</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-planning>18.4. Planning the Security Configuration</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-policies>18.5. Available MAC Policies</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-userlocked>18.6. User Lock Down</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-implementing>18.7. Nagios in a MAC Jail</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mac/#mac-troubleshoot>18.8. Troubleshooting the MAC Framework</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/audit/>Chapter 19. Security Event Auditing</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/audit/#audit-synopsis>19.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/audit/#audit-inline-glossary>19.2. Key Terms</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/audit/#audit-config>19.3. Audit Configuration</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/audit/#audit-administration>19.4. Working with Audit Trails</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/disks/>Chapter 20. Storage</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#disks-synopsis>20.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#disks-adding>20.2. Adding Disks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#disks-growing>20.3. Resizing and Growing Disks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#usb-disks>20.4. USB Storage Devices</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#creating-cds>20.5. Creating and Using CD Media</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#creating-dvds>20.6. Creating and Using DVD Media</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#floppies>20.7. Creating and Using Floppy Disks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#using-ntfs>20.8. Using NTFS Disks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#backup-basics>20.9. Backup Basics</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#disks-virtual>20.10. Memory Disks</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#snapshots>20.11. File System Snapshots</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#quotas>20.12. Disk Quotas</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#disks-encrypting>20.13. Encrypting Disk Partitions</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#swap-encrypting>20.14. Encrypting Swap</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/disks/#disks-hast>20.15. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/geom/>Chapter 21. GEOM: Modular Disk Transformation Framework</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-synopsis>21.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-striping>21.2. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-mirror>21.3. RAID1 - Mirroring</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-raid3>21.4. RAID3 - Byte-level Striping with Dedicated Parity</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-graid>21.5. Software RAID Devices</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-ggate>21.6. GEOM Gate Network</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-glabel>21.7. Labeling Disk Devices</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/geom/#geom-gjournal>21.8. UFS Journaling Through GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/zfs/>Chapter 22. The Z File System (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-differences>22.1. What Makes ZFS Different</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-quickstart>22.2. Quick Start Guide</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-zpool>22.3. <code>zpool</code> Administration</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-zfs>22.4. <code>zfs</code> Administration</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-zfs-allow>22.5. Delegated Administration</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-advanced>22.6. Advanced Topics</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-links>22.7. Further Resources</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/zfs/#zfs-term>22.8. ZFS Features and Terminology</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/filesystems/>Chapter 23. Other File Systems</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/filesystems/#filesystems-synopsis>23.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/filesystems/#filesystems-linux>23.2. Linux® File Systems</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle checked>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/>Chapter 24. Virtualization</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#virtualization-synopsis>24.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#virtualization-guest-parallelsdesktop>24.2. FreeBSD as a Guest on Parallels Desktop for macOS®</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#virtualization-guest-vmware>24.3. FreeBSD as a Guest on VMware Fusion for macOS®</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#virtualization-guest-virtualbox>24.4. FreeBSD as a Guest on VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#virtualization-host-virtualbox>24.5. FreeBSD as a Host with VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#qemu-virtualization-host-guest>24.6. Virtualization with QEMU on FreeBSD</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#virtualization-host-bhyve>24.7. FreeBSD as a Host with bhyve</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/virtualization/#virtualization-host-xen>24.8. FreeBSD as a Xen™-Host</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/l10n/>Chapter 25. Localization - i18n/L10n Usage and Setup</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/l10n/#l10n-synopsis>25.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/l10n/#using-localization>25.2. Using Localization</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/l10n/#l10n-compiling>25.3. Finding i18n Applications</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/l10n/#lang-setup>25.4. Locale Configuration for Specific Languages</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/>Chapter 26. Updating and Upgrading FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#updating-upgrading-synopsis>26.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>26.2. FreeBSD Update</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#updating-bootcode>26.3. Updating Bootcode</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#updating-upgrading-documentation>26.4. Updating the Documentation Set</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#current-stable>26.5. Tracking a Development Branch</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#makeworld>26.6. Updating FreeBSD from Source</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#small-lan>26.7. Tracking for Multiple Machines</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/cutting-edge/#building-on-non-freebsd-hosts>26.8. Building on non-FreeBSD Hosts</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/dtrace/>Chapter 27. DTrace</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/dtrace/#dtrace-synopsis>27.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/dtrace/#dtrace-implementation>27.2. Implementation Differences</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/dtrace/#dtrace-enable>27.3. Enabling DTrace Support</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/dtrace/#dtrace-out-of-kernel>27.4. Enabling DTrace in Out-of-Kernel Modules</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/dtrace/#dtrace-using>27.5. Using DTrace</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/usb-device-mode/>Chapter 28. USB Device Mode / USB OTG</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/usb-device-mode/#usb-device-mode-synopsis>28.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/usb-device-mode/#usb-device-mode-terminals>28.2. USB Virtual Serial Ports</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/usb-device-mode/#usb-device-mode-network>28.3. USB Device Mode Network Interfaces</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/usb-device-mode/#usb-device-mode-storage>28.4. USB Virtual Storage Device</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/partiv/>Part IV. Network Communication</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/serialcomms/>Chapter 29. Serial Communications</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/serialcomms/#serial-synopsis>29.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/serialcomms/#serial>29.2. Serial Terminology and Hardware</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/serialcomms/#term>29.3. Terminals</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/serialcomms/#dialup>29.4. Dial-in Service</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/serialcomms/#dialout>29.5. Dial-out Service</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/serialcomms/#serialconsole-setup>29.6. Setting Up the Serial Console</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/ppp-and-slip/>Chapter 30. PPP</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>30.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ppp-and-slip/#userppp>30.2. Configuring PPP</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ppp-and-slip/#ppp-troubleshoot>30.3. Troubleshooting PPP Connections</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ppp-and-slip/#pppoe>30.4. Using PPP over Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/ppp-and-slip/#pppoa>30.5. Using PPP over ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/mail/>Chapter 31. Electronic Mail</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/mail/#mail-synopsis>31.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mail/#mail-using>31.2. Mail Components</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mail/#dragonFly-mail-agent>31.3. DragonFly Mail Agent (DMA)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mail/#sendmail>31.4. Sendmail</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mail/#mail-changingmta>31.5. Changing the Mail Transfer Agent</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mail/#mail-agents>31.6. Mail User Agents</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mail/#mail-advanced>31.7. Advanced Topics</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/>Chapter 32. Network Servers</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-servers-synopsis>32.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-inetd>32.2. The inetd Super-Server</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-nfs>32.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-nis>32.4. Network Information System (NIS)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-ldap>32.5. Lightweight Directory Access Protocol (LDAP)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-dhcp>32.6. Dynamic Host Configuration Protocol (DHCP)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-dns>32.7. Domain Name System (DNS)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-zeroconf>32.8. Zero-configuration networking (mDNS/DNS-SD)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-apache>32.9. Apache HTTP Server</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-ftp>32.10. File Transfer Protocol (FTP)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-samba>32.11. File and Print Services for Microsoft® Windows® Clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-ntp>32.12. Clock Synchronization with NTP</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/network-servers/#network-iscsi>32.13. iSCSI Initiator and Target Configuration</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/firewalls/>Chapter 33. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/firewalls/#firewalls-intro>33.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/firewalls/#firewalls-concepts>33.2. Firewall Concepts</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/firewalls/#firewalls-pf>33.3. PF</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/firewalls/#firewalls-ipfw>33.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/firewalls/#firewalls-ipf>33.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/firewalls/#firewalls-blacklistd>33.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/>Chapter 34. Advanced Networking</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#advanced-networking-synopsis>34.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-routing>34.2. Gateways and Routes</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#configtuning-virtual-hosts>34.3. Virtual Hosts</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-advanced-wireless>34.4. Wireless Advanced Authentication</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#wireless-ad-hoc-mode>34.5. Wireless Ad-hoc Mode</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-usb-tethering>34.6. USB Tethering</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-bluetooth>34.7. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-bridging>34.8. Bridging</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-aggregation>34.9. Link Aggregation and Failover</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-diskless>34.10. Diskless Operation with PXE</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#carp>34.11. Common Address Redundancy Protocol (CARP)</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/advanced-networking/#network-vlan>34.12. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/partv/>Part V. Appendices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/mirrors/>Appendix A. Obtaining FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/mirrors/#mirrors>A.1. Mirrors</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mirrors/#git>A.2. Using Git</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mirrors/#svn>A.3. Using Subversion</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/mirrors/#mirrors-disc>A.4. Disc Copies</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/bibliography/>Appendix B. Bibliography</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/bibliography/#bibliography-freebsd>B.1. FreeBSD Bibliography</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bibliography/#bibliography-security>B.2. Security Reference</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bibliography/#bibliography-history>B.3. UNIX® History</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/bibliography/#bibliography-journals>B.4. Periodicals, Journals, and Magazines</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/eresources/>Appendix C. Resources on the Internet</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/eresources/#eresources-www>C.1. Websites</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/eresources/#eresources-mail>C.2. Mailing Lists</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook/eresources/#eresources-news>C.3. Usenet Newsgroups</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/pgpkeys/>Appendix D. OpenPGP Keys</a><ul><li><a href=http://172.16.201.134:1313/en/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li><input type=checkbox id=chapter-f4e28803fbf72f245ddccc3e6068ecc8 class=toggle>
<label for=chapter-f4e28803fbf72f245ddccc3e6068ecc8><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/glossary/>FreeBSD Glossary</a></li><li><input type=checkbox id=chapter-9d500d2a940a8aafffc86dbf2509be55 class=toggle>
<label for=chapter-9d500d2a940a8aafffc86dbf2509be55><a role=button></a></label><a href=http://172.16.201.134:1313/en/books/handbook/colophon/>Colophon</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapter 24. Virtualization</h1><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#virtualization-synopsis>24.1. Synopsis</a></li><li><a href=#virtualization-guest-parallelsdesktop>24.2. FreeBSD as a Guest on Parallels Desktop for macOS®</a></li><li><a href=#virtualization-guest-vmware>24.3. FreeBSD as a Guest on VMware Fusion for macOS®</a></li><li><a href=#virtualization-guest-virtualbox>24.4. FreeBSD as a Guest on VirtualBox™</a></li><li><a href=#virtualization-host-virtualbox>24.5. FreeBSD as a Host with VirtualBox™</a></li><li><a href=#qemu-virtualization-host-guest>24.6. Virtualization with QEMU on FreeBSD</a></li><li><a href=#virtualization-host-bhyve>24.7. FreeBSD as a Host with bhyve</a></li><li><a href=#virtualization-host-xen>24.8. FreeBSD as a Xen™-Host</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=virtualization-synopsis>24.1. Synopsis<a class=anchor href=#virtualization-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Virtualization software allows multiple operating systems to run simultaneously on the same computer.
Such software systems for PCs often involve a host operating system which runs the virtualization software and supports any number of guest operating systems.</p></div><div class=paragraph><p>After reading this chapter, you will know:</p></div><div class=ulist><ul><li><p>The difference between a host operating system and a guest operating system.</p></li><li><p>How to install FreeBSD on the following virtualization platforms:</p><div class=ulist><ul><li><p>Parallels Desktop(Apple® macOS®)</p></li><li><p>VMware Fusion(Apple® macOS®)</p></li><li><p>VirtualBox™(Microsoft® Windows®, Intel®-based Apple® macOS®, Linux)</p></li><li><p>QEMU(FreeBSD)</p></li><li><p>bhyve(FreeBSD)</p></li></ul></div></li><li><p>How to tune a FreeBSD system for best performance under virtualization.</p></li></ul></div><div class=paragraph><p>Before reading this chapter, you should:</p></div><div class=ulist><ul><li><p>Understand the <a href=../basics/#basics>basics of UNIX® and FreeBSD</a>.</p></li><li><p>Know how to <a href=../bsdinstall/#bsdinstall>install FreeBSD</a>.</p></li><li><p>Know how to <a href=../advanced-networking/#advanced-networking>set up a network connection</a>.</p></li><li><p>Know how to <a href=../ports/#ports>install additional third-party software</a>.</p></li></ul></div></div></div><div class=sect1><h2 id=virtualization-guest-parallelsdesktop>24.2. FreeBSD as a Guest on Parallels Desktop for macOS®<a class=anchor href=#virtualization-guest-parallelsdesktop></a></h2><div class=sectionbody><div class=paragraph><p>Parallels Desktop for Mac® is a commercial software product available for Apple® Mac® computers running macOS® 10.14.6 or higher.
FreeBSD is a fully supported guest operating system.
Once Parallels has been installed on macOS®, the user must configure a virtual machine and then install the desired guest operating system.</p></div><div class=sect2><h3 id=virtualization-guest-parallelsdesktop-install>24.2.1. Installing FreeBSD on Parallels Desktop on Mac®<a class=anchor href=#virtualization-guest-parallelsdesktop-install></a></h3><div class=paragraph><p>The first step in installing FreeBSD on Parallels is to create a new virtual machine for installing FreeBSD.</p></div><div class=paragraph><p>Choose <b class=menuref>Install Windows or another OS from a DVD or image file</b> and proceed.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd1.png alt="Parallels setup wizard showing Install Windows or another OS from a DVD or image file chosen"></div></div><div class=paragraph><p>Select the FreeBSD image file.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd2.png alt="Parallels setup wizard showing FreeBSD image file selected"></div></div><div class=paragraph><p>Choose <b class=menuref>Other as operating system</b>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Choosing FreeBSD will cause boot error on startup.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd3.png alt="Parallels setup wizard showing Other selected as operating system"></div></div><div class=paragraph><p>Name the virtual machine and check <b class=menuref>Customize settings before installation</b></p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd4.png alt="Parallels setup wizard showing the checkbox checked for customizing settings before installation"></div></div><div class=paragraph><p>When the configuration window pops up, go to <b class=menuref>Hardware</b> tab, choose <b class=menuref>Boot order</b>, and click <b class=menuref>Advanced</b>.
Then, choose <strong>EFI 64-bit</strong> as <b class=menuref>BIOS</b>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd5.png alt="Parallels setup wizard showing EFI 64-bit chosen as BIOS"></div></div><div class=paragraph><p>Click <b class=menuref>OK</b>, close the configuration window, and click <b class=menuref>Continue</b>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd6.png alt="Parallels setup wizard showing the summary of the new virtual machine"></div></div><div class=paragraph><p>The virtual machine will automatically boot.
Install FreeBSD following the general steps.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd7.png alt="FreeBSD booted on Parallels"></div></div></div><div class=sect2><h3 id=virtualization-guest-parallels-configure>24.2.2. Configuring FreeBSD on Parallels<a class=anchor href=#virtualization-guest-parallels-configure></a></h3><div class=paragraph><p>After FreeBSD has been successfully installed on macOS® X with Parallels, there are a number of configuration steps that can be taken to optimize the system for virtualized operation.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Set Boot Loader Variables</p><div class=paragraph><p>The most important step is to reduce the <code>kern.hz</code> tunable to reduce the CPU utilization of FreeBSD under the Parallels environment.
This is accomplished by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Without this setting, an idle FreeBSD Parallels guest will use roughly 15% of the CPU of a single processor iMac®.
After this change the usage will be closer to 5%.</p></div><div class=paragraph><p>If installing FreeBSD 14.0 or later, and CPU utilization is still high, add the following additional line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.disabled=&#34;ged&#34;</pre></div></div></li><li><p>Create a New Kernel Configuration File</p><div class=paragraph><p>All SCSI, FireWire, and USB device drivers can be removed from a custom kernel configuration file.
Parallels provides a virtual network adapter used by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> driver, so all network devices except for <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> can be removed from the kernel.</p></div></li><li><p>Configure Networking</p><div class=paragraph><p>The most basic networking setup uses DHCP to connect the virtual machine to the same local area network as the host Mac®.
This can be accomplished by adding <code>ifconfig_ed0="DHCP"</code> to <span class=filename>/etc/rc.conf</span>.
More advanced networking setups are described in <a href=../advanced-networking/#advanced-networking>Advanced Networking</a>.</p></div></li></ol></div></div></div></div><div class=sect1><h2 id=virtualization-guest-vmware>24.3. FreeBSD as a Guest on VMware Fusion for macOS®<a class=anchor href=#virtualization-guest-vmware></a></h2><div class=sectionbody><div class=paragraph><p>VMware Fusion for Mac® is a commercial software product available for Apple® Mac® computers running macOS® 12 or higher.
FreeBSD is a fully supported guest operating system.
Once VMware Fusion has been installed on macOS®, the user can configure a virtual machine and then install the desired guest operating system.</p></div><div class=sect2><h3 id=virtualization-guest-vmware-install>24.3.1. Installing FreeBSD on VMware Fusion<a class=anchor href=#virtualization-guest-vmware-install></a></h3><div class=paragraph><p>The first step is to start VMware Fusion which will load the Virtual Machine Library.
Click <span class=guimenuitem>+→New</span> to create the virtual machine:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd01.png alt="vmware freebsd01"></div></div><div class=paragraph><p>This will load the New Virtual Machine Assistant.
Choose <span class=guimenuitem>Create a custom virtual machine</span> and click <span class=guimenuitem>Continue</span> to proceed:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd02.png alt="vmware freebsd02"></div></div><div class=paragraph><p>Select <span class=guimenuitem>Other</span> as the <span class=guimenuitem>Operating System</span> and either <span class=guimenuitem>FreeBSD X</span> or <span class=guimenuitem>FreeBSD X 64-bit</span>, as the <b class=menuref>Version</b> when prompted:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd03.png alt="vmware freebsd03"></div></div><div class=paragraph><p>Choose the firmware(UEFI is recommended):</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd04.png alt="vmware freebsd04"></div></div><div class=paragraph><p>Choose <span class=guimenuitem>Create a new virtual disk</span> and click <span class=guimenuitem>Continue</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd05.png alt="vmware freebsd05"></div></div><div class=paragraph><p>Check the configuration and click <span class=guimenuitem>Finish</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd06.png alt="vmware freebsd06"></div></div><div class=paragraph><p>Choose the name of the virtual machine and the directory where it should be saved:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd07.png alt="vmware freebsd07"></div></div><div class=paragraph><p>Press command+E to open virtual machine settings and click <span class=guimenuitem>CD/DVD</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd08.png alt="vmware freebsd08"></div></div><div class=paragraph><p>Choose FreeBSD ISO image or from a CD/DVD:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd09.png alt="vmware freebsd09"></div></div><div class=paragraph><p>Start the virtual machine:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd10.png alt="vmware freebsd10"></div></div><div class=paragraph><p>Install FreeBSD as usual:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd11.png alt="vmware freebsd11"></div></div><div class=paragraph><p>Once the install is complete, the settings of the virtual machine can be modified, such as memory usage and the number of CPUs the virtual machine will have access to:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The System Hardware settings of the virtual machine cannot be modified while the virtual machine is running.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd12.png alt="vmware freebsd12"></div></div><div class=paragraph><p>The status of the CD-ROM device.
Normally the CD/DVD/ISO is disconnected from the virtual machine when it is no longer needed.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd09.png alt="vmware freebsd09"></div></div><div class=paragraph><p>The last thing to change is how the virtual machine will connect to the network.
To allow connections to the virtual machine from other machines besides the host, choose <span class=guimenuitem>Connect directly to the physical network (Bridged)</span>.
Otherwise, <span class=guimenuitem>Share the host’s internet connection (NAT)</span> is preferred so that the virtual machine can have access to the Internet, but the network cannot access the virtual machine.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd13.png alt="vmware freebsd13"></div></div><div class=paragraph><p>After modifying the settings, boot the newly installed FreeBSD virtual machine.</p></div></div><div class=sect2><h3 id=virtualization-guest-vmware-configure>24.3.2. Configuring FreeBSD on VMware Fusion<a class=anchor href=#virtualization-guest-vmware-configure></a></h3><div class=paragraph><p>After FreeBSD has been successfully installed on macOS® X with VMware Fusion, there are a number of configuration steps that can be taken to optimize the system for virtualized operation.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Set Boot Loader Variables</p><div class=paragraph><p>The most important step is to reduce the <code>kern.hz</code> tunable to reduce the CPU utilization of FreeBSD under the VMware Fusion environment.
This is accomplished by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Without this setting, an idle FreeBSD VMware Fusion guest will use roughly 15% of the CPU of a single processor iMac®.
After this change, the usage will be closer to 5%.</p></div></li><li><p>Create a New Kernel Configuration File</p><div class=paragraph><p>All FireWire, and USB device drivers can be removed from a custom kernel configuration file.
VMware Fusion provides a virtual network adapter used by the <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> driver, so all network devices except for <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> can be removed from the kernel.</p></div></li><li><p>Configure Networking</p><div class=paragraph><p>The most basic networking setup uses DHCP to connect the virtual machine to the same local area network as the host Mac®.
This can be accomplished by adding <code>ifconfig_em0="DHCP"</code> to <span class=filename>/etc/rc.conf</span>.
More advanced networking setups are described in <a href=../advanced-networking/#advanced-networking>Advanced Networking</a>.</p></div></li><li><p>Install drivers and open-vm-tools</p><div class=paragraph><p>To run FreeBSD smoothly on VMWare, drivers should be installed:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xf86-video-vmware xf86-input-vmmouse open-vm-tools</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect1><h2 id=virtualization-guest-virtualbox>24.4. FreeBSD as a Guest on VirtualBox™<a class=anchor href=#virtualization-guest-virtualbox></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD works well as a guest in VirtualBox™.
The virtualization software is available for most common operating systems, including FreeBSD itself.</p></div><div class=paragraph><p>The VirtualBox™ guest additions provide support for:</p></div><div class=ulist><ul><li><p>Clipboard sharing.</p></li><li><p>Mouse pointer integration.</p></li><li><p>Host time synchronization.</p></li><li><p>Window scaling.</p></li><li><p>Seamless mode.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>These commands are run in the FreeBSD guest.</p></div></td></tr></tbody></table></div><div class=paragraph><p>First, install the <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose-additions/>emulators/virtualbox-ose-additions</a> package or port in the FreeBSD guest.
This will install the port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose-additions &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>Add these lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxguest_enable=&#34;YES&#34;
vboxservice_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> is used, disable host time synchronization:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxservice_flags=&#34;--disable-timesync&#34;</pre></div></div><div class=paragraph><p>Xorg will automatically recognize the <code>vboxvideo</code> driver.
It can also be manually entered in <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver &#34;vboxvideo&#34;
	VendorName &#34;InnoTek Systemberatung GmbH&#34;
	BoardName &#34;VirtualBox Graphics Adapter&#34;
EndSection</pre></div></div><div class=paragraph><p>To use the <code>vboxmouse</code> driver, adjust the mouse section in <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier &#34;Mouse0&#34;
	Driver &#34;vboxmouse&#34;
EndSection</pre></div></div><div class=paragraph><p>Shared folders for file transfers between host and VM are accessible by mounting them using <code>mount_vboxvfs</code>.
A shared folder can be created on the host using the VirtualBox GUI or via <code>vboxmanage</code>.
For example, to create a shared folder called <em>myshare</em> under <span class=filename>/mnt/bsdboxshare</span> for the VM named <em>BSDBox</em>, run:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vboxmanage sharedfolder add &#39;BSDBox&#39; --name myshare --hostpath /mnt/bsdboxshare</span></code></pre></div></div><div class=paragraph><p>Note that the shared folder name must not contain spaces.
Mount the shared folder from within the guest system like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_vboxvfs -w myshare /mnt</span></code></pre></div></div></div></div><div class=sect1><h2 id=virtualization-host-virtualbox>24.5. FreeBSD as a Host with VirtualBox™<a class=anchor href=#virtualization-host-virtualbox></a></h2><div class=sectionbody><div class=paragraph><p>VirtualBox™ is an actively developed, complete virtualization package, that is available for most operating systems including Windows®, macOS®, Linux® and FreeBSD.
It is equally capable of running Windows® or UNIX®-like guests.
It is released as open source software, but with closed-source components available in a separate extension pack.
These components include support for USB 2.0 devices.
More information may be found on the <a href=http://www.virtualbox.org/wiki/Downloads>Downloads page of the VirtualBox™ wiki</a>.
Currently, these extensions are not available for FreeBSD.</p></div><div class=sect2><h3 id=virtualization-virtualbox-install>24.5.1. Installing VirtualBox™<a class=anchor href=#virtualization-virtualbox-install></a></h3><div class=paragraph><p>VirtualBox™ is available as a FreeBSD package or port in <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose/>emulators/virtualbox-ose</a>.
The port can be installed using these commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>One useful option in the port’s configuration menu is the <code>GuestAdditions</code> suite of programs.
These provide a number of useful features in guest operating systems, like mouse pointer integration (allowing the mouse to be shared between host and guest without the need to press a special keyboard shortcut to switch) and faster video rendering, especially in Windows® guests.
The guest additions are available in the <b class=menuref>Devices</b> menu, after the installation of the guest is finished.</p></div><div class=paragraph><p>A few configuration changes are needed before VirtualBox™ is started for the first time.
The port installs a kernel module in <span class=filename>/boot/modules</span> which must be loaded into the running kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vboxdrv</span></code></pre></div></div><div class=paragraph><p>To ensure the module is always loaded after a reboot, add this line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxdrv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To use the kernel modules that allow bridged or host-only networking, add this line to <span class=filename>/etc/rc.conf</span> and reboot the computer:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxnet_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The <code>vboxusers</code> group is created during installation of VirtualBox™.
All users that need access to VirtualBox™ will have to be added as members of this group.
<code>pw</code> can be used to add new members:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod vboxusers -m yourusername</span></code></pre></div></div><div class=paragraph><p>The default permissions for <span class=filename>/dev/vboxnetctl</span> are restrictive and need to be changed for bridged networking:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:vboxusers /dev/vboxnetctl</span>
<span class=c># chmod 0660 /dev/vboxnetctl</span></code></pre></div></div><div class=paragraph><p>To make this permissions change permanent, add these lines to <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>own     vboxnetctl root:vboxusers
perm    vboxnetctl 0660</pre></div></div><div class=paragraph><p>To launch VirtualBox™, type from an Xorg session:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% VirtualBox</code></pre></div></div><div class=paragraph><p>For more information on configuring and using VirtualBox™, refer to the <a href=http://www.virtualbox.org>official website</a>.
For FreeBSD-specific information and troubleshooting instructions, refer to the <a href=http://wiki.FreeBSD.org/VirtualBox>relevant page in the FreeBSD wiki</a>.</p></div></div><div class=sect2><h3 id=virtualization-virtualbox-usb-support>24.5.2. VirtualBox™ USB Support<a class=anchor href=#virtualization-virtualbox-usb-support></a></h3><div class=paragraph><p>VirtualBox™ can be configured to pass USB devices through to the guest operating system.
The host controller of the OSE version is limited to emulating USB 1.1 devices until the extension pack supporting USB 2.0 and 3.0 devices becomes available on FreeBSD.</p></div><div class=paragraph><p>For VirtualBox™ to be aware of USB devices attached to the machine, the user needs to be a member of the <code>operator</code> group.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod operator -m yourusername</span></code></pre></div></div><div class=paragraph><p>Then, add the following to <span class=filename>/etc/devfs.rules</span>, or create this file if it does not exist yet:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=10]
add path &#39;usb/*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>To load these new rules, add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Then, restart devfs:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div><div class=paragraph><p>Restart the login session and VirtualBox™ for these changes to take effect, and create USB filters as necessary.</p></div></div><div class=sect2><h3 id=virtualization-virtualbox-host-dvd-cd-access>24.5.3. VirtualBox™ Host DVD/CD Access<a class=anchor href=#virtualization-virtualbox-host-dvd-cd-access></a></h3><div class=paragraph><p>Access to the host DVD/CD drives from guests is achieved through the sharing of the physical drives.
Within VirtualBox™, this is set up from the Storage window in the Settings of the virtual machine.
If needed, create an empty IDECD/DVD device first.
Then choose the Host Drive from the popup menu for the virtual CD/DVD drive selection.
A checkbox labeled <code>Passthrough</code> will appear. This allows the virtual machine to use the hardware directly.
For example, audio CDs or the burner will only function if this option is selected.</p></div><div class=paragraph><p>In order for users to be able to use VirtualBox™DVD/CD functions, they need access to <span class=filename>/dev/xpt0</span>, <span class=filename>/dev/cdN</span>, and <span class=filename>/dev/passN</span>.
This is usually achieved by making the user a member of <code>operator</code>.
Permissions to these devices have to be corrected by adding these lines to <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>perm cd* 0660
perm xpt0 0660
perm pass* 0660</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=qemu-virtualization-host-guest>24.6. Virtualization with QEMU on FreeBSD<a class=anchor href=#qemu-virtualization-host-guest></a></h2><div class=sectionbody><div class=paragraph><p><a href=https://www.qemu.org>QEMU</a> is a generic machine emulator and virtualizer that is completely open source software.
It is developed by a large, active community and provides support for FreeBSD, OpenBSD, and NetBSD as well as other operating systems.</p></div><div class=paragraph><p>From the <a href=https://www.qemu.org/docs/master/>QEMU documentation</a>:</p></div><div class=ulist><ul><li><p>QEMU can be used in several different ways.
The most common is for System Emulation, where it provides a virtual model of an entire machine (CPU, memory, and emulated devices) to run a guest OS.
In this mode the CPU may be fully emulated, or it may work with a hypervisor such as <code>KVM</code>, <code>Xen</code> or <code>Hypervisor.Framework</code> to allow the guest to run directly on the host CPU.</p></li><li><p>The second supported way to use QEMU is User Mode Emulation, where QEMU can launch processes compiled for one CPU on another CPU.
In this mode the CPU is always emulated.</p></li><li><p>QEMU also provides a number of standalone command line utilities, such as the <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu-img&amp;sektion=1&amp;format=html">qemu-img(1)</a> disk image utility that allows one to create, convert, and modify disk images.</p></li></ul></div><div class=paragraph><p>QEMU can emulate a wide number of architectures including <code>Arm™</code>, <code>i386</code>, <code>x86_64</code>, <code>MIPS™</code>, <code>s390X</code>, <code>SPARC™</code> (Sparc™ and Sparc64™), and others.
The list of <a href=https://www.qemu.org/docs/master/system/targets.html#system-targets-ref>QEMU System Emulator Targets</a> is regularly kept up to date.</p></div><div class=paragraph><p>This section describes how to use QEMU for both System Emulation and User Mode Emulation on FreeBSD, and provides examples of using QMEU commands and command line utilities.</p></div><div class=sect2><h3 id=qemu-installing-qemu-software>24.6.1. Installing QEMU Software<a class=anchor href=#qemu-installing-qemu-software></a></h3><div class=paragraph><p>QEMU is available as a FreeBSD package or as a port in <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/qemu/>emulators/qemu</a>.
The package build includes sane options and defaults for most users and is the recommended method of installation.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install qemu</span></code></pre></div></div><div class=paragraph><p>The package installation includes several dependencies.
Once the installation is complete, create a link to the host version of QEMU that will be used most often.
If the host is an Intel™ or AMD™ 64 bit system that will be:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /usr/local/bin/qemu-system-x86_64 /usr/local/bin/qemu</span></code></pre></div></div><div class=paragraph><p>Test the installation by running the following command as a non-root user:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% qemu</code></pre></div></div><div class=paragraph><p>This brings up a window with QEMU actively trying to boot from hard disk, floppy disk, DVD/CD, and PXE.
Nothing has been set up yet, so the command will produce several errors and end
with "No bootable device" as shown in
<a href=../virtualization/#qemu-nullboot>Figure 1</a>.
However, it does show that the QEMU software has been installed correctly.</p></div><div id=qemu-nullboot class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd01.png alt="QEMU with no bootable image"></div><div class=title>Figure 1. QEMU with no bootable image</div></div></div><div class=sect2><h3 id=qemu-virtual-machine-install>24.6.2. Virtual Machine Install<a class=anchor href=#qemu-virtual-machine-install></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>QEMU is under very active development.
Features and command options can change from one version to the next.
This section provides examples developed with QEMU version 9.0.1 (Summer, 2024).
When in doubt, always consult the <a href=https://www.qemu.org/docs/master/>QEMU Documentation</a> particularly the <a href=https://www.qemu.org/docs/master/about/index.html>About QEMU</a> page which has links to supported build platforms, emulation, deprecated features, and removed features.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Follow the steps below to create two virtual machines named "<strong>left</strong>", and "<strong>right</strong>".
Most commands can be performed without root privileges.</p></div><div class="olist arabic"><ol class=arabic><li><p>Create a test environment to work with QEMU:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>mkdir</span> <span class=nt>-p</span> ~/QEMU  ~/QEMU/SCRIPTS  ~/QEMU/ISO  ~/QEMU/VM</code></pre></div></div><div class=paragraph><p>The <span class=filename>SCRIPTS</span> directory is for startup scripts and utilities.
The <span class=filename>ISO</span> directory is for the guest ISO boot images.
The <span class=filename>VM</span> directory is where the virtual machine images (<code>VMs</code>) will reside.</p></div></li><li><p>Download a recent copy of FreeBSD into <span class=filename>~/QEMU/ISO</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ~/QEMU/ISO
% fetch https://download.freebsd.org/releases/ISO-IMAGES/14.1/FreeBSD-14.1-RELEASE-amd64-bootonly.iso</code></pre></div></div><div class=paragraph><p>Once the download is complete create a shorthand link.
This shorthand link is used in the startup scripts below.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ln</span> <span class=nt>-s</span> FreeBSD-14.1-RELEASE-amd64-bootonly.iso  fbsd.iso</code></pre></div></div></li><li><p>Change directory to the location for virtual machines (<span class=filename>~/QEMU/VM</span>).
Run <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu-img&amp;sektion=1&amp;format=html">qemu-img(1)</a> to create the disk images for the “left” VM:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ~/QEMU/VM
% qemu-img create <span class=nt>-f</span> raw  left.img   15G</code></pre></div></div><div class=paragraph><p>The QEMU <code>raw</code> format is designed for performance.
The format is straightforward and has no overhead which makes it faster, especially for high performance or high throughput scenarios.
The use case is for maximum performance where no additional features, such as snapshots, are needed.
This format is used in the script for the "left" VM below.</p></div><div class=paragraph><p>A separate format is <code>qcow2</code> which uses QEMU’s "copy on write" technique for managing disk space.
This technique does not require a complete 15G disk, just a stub version that is managed directly by the VM.
The disk grows dynamically as the VM writes to it.
This format supports snapshots, compression, and encryption.
The use case for this format is for development, testing, and scenarios with the need of these advanced features.
This format is used in the script for the "right" VM below.</p></div><div class=paragraph><p>Run <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu-img&amp;sektion=1&amp;format=html">qemu-img(1)</a> again to create the disk image for the "right" VM using <code>qcow2</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% qemu-img create <span class=nt>-f</span> qcow2 <span class=nt>-o</span> <span class=nv>preallocation</span><span class=o>=</span>full,cluster_size<span class=o>=</span>512K,lazy_refcounts<span class=o>=</span>on right.qcow2 20G</code></pre></div></div><div class=paragraph><p>To see the actual size of the file use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>du</span> <span class=nt>-Ah</span> right.qcow2</code></pre></div></div></li><li><p>Set up networking for both virtual machines with the following commands.
In this example the host network interface is <code>em0</code>.
If necessary, change it to fit the interface for the host system.
This must be done after every host machine restart to enable the QEMU guest VMs to communicate.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig tap0 create</span>
<span class=c># ifconfig tap1 create</span>
<span class=c># sysctl net.link.tap.up_on_open=1</span>
net.link.tap.up_on_open: 0 -&gt; 1
<span class=c># sysctl net.link.tap.user_open=1</span>
net.link.tap.user_open: 0 -&gt; 1
<span class=c># ifconfig bridge0 create</span>
<span class=c># ifconfig bridge0 addm tap0 addm tap1 addm em0</span>
<span class=c># ifconfig bridge0 up</span></code></pre></div></div><div class=paragraph><p>The above commands create two <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> devices (<code>tap0</code>, <code>tap1</code>) and one <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> device (<code>bridge0</code>).
Then, they add the <code>tap</code> devices and the local host interface (<code>em0</code>) to the <code>bridge</code>, and set two <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> entries to allow for normal users to open the tap device.
These commands will allow the virtual machines to talk to the network stack on the host.</p></div></li><li><p>Change to <span class=filename>~/QEMU/SCRIPTS</span>, use the following script to start the first virtual machine, "left".
This script uses the QEMU raw disk format.</p><div class="literalblock programlisting"><div class=content><pre>/usr/local/bin/qemu-system-x86_64  -monitor none \
  -cpu qemu64 \
  -vga std \
  -m 4096 \
  -smp 4   \
  -cdrom ../ISO/fbsd.iso \
  -boot order=cd,menu=on \
  -blockdev driver=file,aio=threads,node-name=imgleft,filename=../VM/left.img \
  -blockdev driver=raw,node-name=drive0,file=imgleft \
  -device virtio-blk-pci,drive=drive0,bootindex=1  \
  -netdev tap,id=nd0,ifname=tap0,script=no,downscript=no,br=bridge0 \
  -device e1000,netdev=nd0,mac=02:20:6c:65:66:74 \
  -name \&#34;left\&#34;</pre></div></div></li></ol></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Save the above into a file (for example <code>left.sh</code>) and simply run: % <code>/bin/sh left.sh</code></p></div></td></tr></tbody></table></div><div class=paragraph><p>QEMU will start up a virtual machine in a separate window and boot the FreeBSD
iso as shown in <a href=../virtualization/#qemu-newboot-loader-menu>Figure 2</a>.
All command options such as <code>-cpu</code> and <code>-boot</code> are fully described in the QEMU man page <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu&amp;sektion=1&amp;format=html">qemu(1)</a>.</p></div><div id=qemu-newboot-loader-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd02.png alt="The FreeBSD loader menu."></div><div class=title>Figure 2. FreeBSD Boot Loader Menu</div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If the mouse is clicked in the QEMU console window, QEMU will “grab” the mouse
as shown in <a href=../virtualization/#qemu-grab>Figure 3</a>.
Type <kbd>Ctl</kbd>+<kbd>Alt</kbd>+<kbd>G</kbd>” to release the mouse.</p></div></td></tr></tbody></table></div><div id=qemu-grab class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd03.png alt="When QEMU has grabbed the mouse"></div><div class=title>Figure 3. When QEMU Has Grabbed the Mouse</div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>On FreeBSD, an initial QEMU installation can be somewhat slow.
This is because the emulator writes filesystem formatting and metadata during the disk first use.
Subsequent operations are generally much faster.</p></div></td></tr></tbody></table></div><div class=paragraph><p>During the installation there are several points to note:</p></div><div class=ulist><ul><li><p>Select to use UFS as the filesystem.
ZFS does not perform well with small memory sizes.</p></li><li><p>For networking use DHCP.
If desired, configure IPv6 if supported by the local LAN.</p></li><li><p>When adding the default user, ensure they are a member of the <strong>wheel</strong> group.</p></li></ul></div><div class=paragraph><p>Once the installation completes, the virtual machine reboots into the newly installed FreeBSD image.</p></div><div class=paragraph><p>Login as <code>root</code> and update the system as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update fetch install</span>
<span class=c># reboot</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>After a successful installation, QEMU will boot the operating system installed on the disk, and not the installation program.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>QEMU supports a <code><code>-runas</code></code> option.
For added security, include the option "-runas your_user_name" in the script listing above.
See <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu&amp;sektion=1&amp;format=html">qemu(1)</a> for details.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Login as <code>root</code> again and add any packages desired.
To utilize the X Window system in the guest, see the section "Using the X Window System" below.</p></div><div class=paragraph><p>This completes the setup of the "left" VM.</p></div><div class=paragraph><p>To install the "right" VM, run the following script.
This script has the modifications needed for tap1, format=qcow2, the image filename, the MAC address, and the terminal window name.
If desired, include the "-runas" parameter as described in the above note.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/bin/qemu-system-x86_64  -monitor none \
  -cpu qemu64 \
  -vga cirrus \
  -m 4096  -smp 4   \
  -cdrom ../ISO/fbsd.iso \
  -boot order=cd,menu=on \
  -drive if=none,id=drive0,cache=writeback,aio=threads,format=qcow2,discard=unmap,file=../VM/right.qcow2 \
  -device virtio-blk-pci,drive=drive0,bootindex=1  \
  -netdev tap,id=nd0,ifname=tap1,script=no,downscript=no,br=bridge0 \
  -device e1000,netdev=nd0,mac=02:72:69:67:68:74 \
  -name \&#34;right\&#34;</pre></div></div><div class=paragraph><p>Once the installation is complete, the "left" and "right" machines can communicate with each other and with the host.
If there are strict firewall rules on the host, consider adding or modifying rules to allow the bridge and tap devices to communicate with each other.</p></div></div><div class=sect2><h3 id=qemu-usage-tips>24.6.3. Usage Tips<a class=anchor href=#qemu-usage-tips></a></h3><div class=sect3><h4 id=qemu-setting-up-x-windows>24.6.3.1. Using the X Window System<a class=anchor href=#qemu-setting-up-x-windows></a></h4><div class=paragraph><p><a href=../x11/#x-install>Installing Xorg</a> describes how to set up the <code>X Window</code> system.
Refer to that guide for initial <code>X Window</code> setup then consult <a href=../desktop/#desktop>Desktop Environments</a> on how to set up a complete desktop.</p></div><div class=paragraph><p>This section demonstrates use of the XFCE desktop.</p></div><div class=paragraph><p>Once the installation is complete, login as a regular user, then type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div><div class=paragraph><p>The XFCE4 window manager should start up and present a functioning graphical
desktop as in <a href=../virtualization/#qemu-two-qemu>Figure 4</a>.
On initial startup, it may take up to a minute to display the desktop.
See the documentation at the <a href=https://www.xfce.org>XFCE website</a> for usage details.</p></div><div id=qemu-two-qemu class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd04.png alt="Both QEMU VMs"></div><div class=title>Figure 4. Both QEMU VMs</div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Adding more memory to the guest system may speed up the graphical user interface.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Here, the "left" VM has had the <code>X Window</code> system installed, while the "right" VM is still in text mode.</p></div></div><div class=sect3><h4 id=qemu-using-qemu-window>24.6.3.2. Using the QEMU Window<a class=anchor href=#qemu-using-qemu-window></a></h4><div class=paragraph><p>The QEMU window functions as a full FreeBSD console, and is capable of running multiple virtual terminals, just like a bare-metal system.</p></div><div class=paragraph><p>To switch to another virtual console, click into the QEMU window and type <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span> or <span class=keyseq><kbd>Alt</kbd>+<kbd>F3</kbd></span>.
FreeBSD should switch to another virtual console.
<a href=../virtualization/#qemu-console-ttyv3>Figure 5</a> shows the "left" VM displaying the virtual console on <code>ttyv3</code>.</p></div><div id=qemu-console-ttyv3 class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd05.png alt="Switching to Another Virtual Console in the QEMU Window"></div><div class=title>Figure 5. Switching to Another Virtual Console in the QEMU Window</div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>The host current desktop manager or window manager may be already setup for another function with the <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span> key sequences.
If so, try typing <span class=keyseq><kbd>Ctl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span>, <span class=keyseq><kbd>Ctl</kbd>+<kbd>Alt</kbd>+<kbd>F2</kbd></span>, or some other similar key combination.
Check the window manager or desktop manager documentation for details.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=qemu-using-qemu-window-menus>24.6.3.3. Using the QEMU Window Menus<a class=anchor href=#qemu-using-qemu-window-menus></a></h4><div class=paragraph><p>Another feature of the QEMU window is the <code>View</code> menu and the Zoom controls.
The most useful is <code>Zoom to Fit</code>.
When this menu selection is clicked, it is then possible to resize the QEMU window by clicking the window corner controls and resizing the window.
<a href=../virtualization/#qemu-zoom-to-fit>Figure 6</a> shows the effect of resizing the "left" window while in graphics mode.</p></div><div id=qemu-zoom-to-fit class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd06.png alt="Using the View Menu `Zoom to Fit` Option"></div><div class=title>Figure 6. Using the View Menu <code>Zoom to Fit</code> Option</div></div></div><div class=sect3><h4 id=qemu-other-qemu-window-menu-options>24.6.3.4. Other QEMU Window Menu Options<a class=anchor href=#qemu-other-qemu-window-menu-options></a></h4><div class=paragraph><p>Also shown in the <code>View</code> menu are</p></div><div class=ulist><ul><li><p><code>cirrus-vga</code>, <code>serial0</code>, and <code>parallel0</code> options.
These allow for switching input/output to the selected device.</p></li></ul></div><div class=paragraph><p>The QEMU window <code>Machine</code> menu allows for four types of control over the guest VM:</p></div><div class=ulist><ul><li><p><code>Pause</code> allows for pausing the QEMU virtual machine.
This may be helpful in freezing a fast scrolling window.</p></li><li><p><code>Reset</code> immediately resets the virtual machine back at cold "power on" state.
As with a real machine, it is not recommended unless absolutely necessary.</p></li><li><p><code>Power Down</code> simulates an ACPI shutdown signal and the operating system goes through a graceful shutdown.</p></li><li><p><code>Quit</code> powers off the virtual machine immediately - also not recommended unless necessary.</p></li></ul></div></div></div><div class=sect2><h3 id=qemu-adding-serial-port-to-guest-vm>24.6.4. Adding a Serial Port Interface to a Guest VM<a class=anchor href=#qemu-adding-serial-port-to-guest-vm></a></h3><div class=paragraph><p>To implement a serial console, a guest VM running FreeBSD needs to insert</p></div><div class="literalblock programlisting"><div class=content><pre>console=&#34;comconsole&#34;</pre></div></div><div class=paragraph><p>in <span class=filename>/boot/loader.conf</span> to allow the use of the FreeBSD serial console.</p></div><div class=paragraph><p>The updated configuration below shows how to implement the serial console on the guest VM.
Run the script to start the VM.</p></div><div class="literalblock programlisting"><div class=content><pre># left+serial.sh
echo
echo &#34;NOTE: telnet startup server running on guest VM!&#34;
echo &#34;To start QEMU, start another session and telnet to localhost port 4410&#34;
echo

/usr/local/bin/qemu-system-x86_64  -monitor none \
  -serial telnet:localhost:4410,server=on,wait=on\
  -cpu qemu64 \
  -vga std \
  -m 4096 \
  -smp 4   \
  -cdrom ../ISO/fbsd.iso \
  -boot order=cd,menu=on \
  -blockdev driver=file,aio=threads,node-name=imgleft,filename=../VM/left.img \
  -blockdev driver=raw,node-name=drive0,file=imgleft \
  -device virtio-blk-pci,drive=drive0,bootindex=1  \
  -netdev tap,id=nd0,ifname=tap0,script=no,downscript=no,br=bridge0 \
  -device e1000,netdev=nd0,mac=02:20:6c:65:66:74 \
  -name \&#34;left\&#34;</pre></div></div><div id=qemu-left-serial-port class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd07.png alt="qemu freebsd07"></div><div class=title>Figure 7. Enabling a Serial Port over TCP</div></div><div class=paragraph><p>In <a href=../virtualization/#qemu-notes-on-serial-console>Figure 7</a>, the serial port is redirected to a TCP port on the host system at VM startup and the QEMU monitor waits (<code>wait=on</code>) to activate the guest VM until a <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> connection occurs on the indicated localhost port.
After receiving a connection from a separate session, the FreeBSD system starts booting and looks for a console directive in <span class=filename>/boot/loader.conf</span>.
With the directive "console=comconsole", FreeBSD starts up a console session on a serial port.
The QEMU monitor detects this and directs the necessary character I/O on that serial port to the telnet session on the host.
The system boots and once finished, login prompts are enabled on the serial port (<code>ttyu0</code>) and on the console (<code>ttyv0</code>).</p></div><div class=paragraph><p>It is important to note that the this serial redirect over TCP takes place outside the virtual machine.
There is no interaction with any network on the virtual machine and therefore it is not subject to any firewall rules.
Think of it like a dumb terminal sitting on an RS-232 or USB port on a real machine.</p></div><div class=sect3><h4 id=qemu-notes-on-serial-console>24.6.4.1. Notes on Using the Serial Console<a class=anchor href=#qemu-notes-on-serial-console></a></h4><div class=paragraph><p>On the serial console, if the window is resized, execute <a href="https://man.freebsd.org/cgi/man.cgi?query=resizewin&amp;sektion=1&amp;format=html">resizewin(1)</a> to update the terminal size.</p></div><div class=paragraph><p>It may be desirable (even necessary) to stop syslog message from being sent to the console (both the QEMU console and the serial port).
Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> for details on redirecting console messages.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Once the <span class=filename>/boot.loader.conf</span> has been updated to permit a serial console,
the guest VM will attempt to boot from the serial port every time.
Ensure that the serial port is enabled as shown in the listing above, or update the <span class=filename>/boot/loader.conf</span> file to not require a serial console.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=qemu-user-mode-emulation>24.6.5. QEMU User Mode Emulation<a class=anchor href=#qemu-user-mode-emulation></a></h3><div class=paragraph><p>QEMU also supports running applications that are precompiled on an architecture different from the host CPU.
For example, it is possible to run a Sparc64 architecture operating system on an x86_64 host.
This is demonstrated in the next section.</p></div><div class=sect3><h4 id=qemu-sparc64-user-mode-emulation>24.6.5.1. Setting up a SPARC64 Guest VM on an x86_64 Host<a class=anchor href=#qemu-sparc64-user-mode-emulation></a></h4><div class=paragraph><p>Setting up a new VM with an architecture different from the host involves several steps:</p></div><div class=ulist><ul><li><p>Getting the software that will run on the guest VM</p></li><li><p>Creating a new disk image for the guest VM</p></li><li><p>Setting up a new QEMU script with the new architecture</p></li><li><p>Performing the install</p></li></ul></div><div class=paragraph><p>In the following procedure a copy of OpenBSD 6.8 SPARC64 software is used for this QEMU User Mode Emulation exercise.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Not all versions of OpenBSD Sparc64 work on QEMU.
OpenBSD version 6.8 is known to work and was selected as the example for this section.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>Download OpenBSD 6.8 Sparc64 from an OpenBSD archive.</p><div class=paragraph><p>On the OpenBSD download sites, only the most current versions are maintained.
It is necessary to search an archive to obtain past releases.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ~/QEMU/ISO
% fetch https://mirror.planetunix.net/pub/OpenBSD-archive/6.8/sparc64/install68.iso</code></pre></div></div></li><li><p>Creating a new disk image for the Sparc64 VM is similar to the "right" VM above.
This case uses the QEMU qcow2 format for the disk:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ~/QEMU/VM
qemu-img create <span class=nt>-f</span> qcow2 <span class=nt>-o</span> <span class=nv>preallocation</span><span class=o>=</span>full,lazy_refcounts<span class=o>=</span>on sparc64.qcow2 16G</code></pre></div></div></li><li><p>Use the script below for the new Sparc64 architecture.
As with the above example, run the script, then start a new session and <code>telnet</code> to localhost on the port indicated:</p><div class="literalblock programlisting"><div class=content><pre>echo
echo &#34;NOTE: telnet startup server running on guest VM!&#34;
echo &#34;To start QEMU, start another session and telnet to localhost port 4410&#34;
echo

/usr/local/bin/qemu-system-sparc64 \
  -serial telnet:localhost:4410,server=on,wait=on \
  -machine sun4u,usb=off \
  -smp 1,sockets=1,cores=1,threads=1 \
  -rtc base=utc \
  -m 1024 \
  -boot d \
  -drive file=../VM/sparc64.qcow2,if=none,id=drive-ide0-0-1,format=qcow2,cache=none \
  -cdrom ../ISO/install68.iso \
  -device ide-hd,bus=ide.0,unit=0,drive=drive-ide0-0-1,id=ide0-0-1 \
  -msg timestamp=on \
  -net nic,model=sunhme -net user \
  -nographic \
  -name \&#34;sparc64\&#34;</pre></div></div></li></ol></div><div class=paragraph><p>Note the following:</p></div><div class=ulist><ul><li><p>The <code>-boot d</code> option boots from the QEMU CDROM device which is set as <code>-cdrom ../ISO/install68.iso</code>.</p></li><li><p>As before, the <code>telnet</code> server option is set to wait for a separate connection on port 4410.
Start up another session and use <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> to connect to localhost on port 4410.</p></li><li><p>The script sets the <code>-nographic</code> option meaning there is only serial port I/O.
There is no graphical interface.</p></li><li><p>Networking is not set up through the <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> / <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> combination.
This example uses a separate method of QEMU networking known as "Serial Line Internet Protocol" (SLIRP), sometimes referred to as "User Mode Networking".
Documentation on this and other QEMU networking methods is here: <a href=https://wiki.qemu.org/Documentation/Networking>QEMU Networking Documentation</a></p></li></ul></div><div class=paragraph><p>If everything is set correctly, the system will boot as shown in
<a href=../virtualization/#qemu-sparc64-boot-cdrom-installation>Figure 8</a>.</p></div><div id=qemu-sparc64-boot-cdrom-installation class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd08.png alt="qemu freebsd08"></div><div class=title>Figure 8. QEMU Booting OpenBSD 6.8 Sparc64 from CDROM During User Mode Emulation</div></div><div class=paragraph><p>Once the system is installed, modify the script and change the boot parameter to <code>-boot c</code>.
This will indicate to QEMU to boot from the supplied hard disk, not the CDROM.</p></div><div class=paragraph><p>The installed system can be used just like any other guest virtual machine.
However, the underlying architecture of the guest is Sparc64, not x86_64.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If the system is halted at the OpenBios console prompt <code>0 ></code>, enter <code>power-off</code> to exit the system.</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href=../virtualization/#qemu-sparc64-login-to-installed-system>Figure 9</a> shows a root login to the installed system and running <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a>.</p></div><div id=qemu-sparc64-login-to-installed-system class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd09.png alt="qemu freebsd09"></div><div class=title>Figure 9. QEMU Booting from CDROM During User Mode Emulation</div></div></div></div><div class=sect2><h3 id=qemu-using-qemu-monitor>24.6.6. Using the QEMU Monitor<a class=anchor href=#qemu-using-qemu-monitor></a></h3><div class=paragraph><p>The <a href=https://www.qemu.org/docs/master/system/monitor.html>QEMU monitor</a> controls a running QEMU emulator (guest VM).</p></div><div class=paragraph><p>Using the monitor, it is possible to:</p></div><div class=ulist><ul><li><p>Dynamically remove or insert devices, including disks, network interfaces, CD-ROMs, or floppies</p></li><li><p>Freeze/unfreeze the guest VM, and save or restore its state from a disk file</p></li><li><p>Gather information about the state of the VM and devices</p></li><li><p>Change device settings on the fly</p></li></ul></div><div class=paragraph><p>As well as many other operations.</p></div><div class=paragraph><p>The most common uses of the monitor are to examine the state of the VM, and to add, delete, or change devices.
Some operations such as migrations are only available under hypervisor accelerators such as KVM, Xen, etc. and are not supported on FreeBSD hosts.</p></div><div class=paragraph><p>When using a graphical desktop environment, the simplest way to use the QEMU monitor is the <code>-monitor stdio</code> option when launching QEMU from a terminal session.</p></div><div class="literalblock programlisting"><div class=content><pre># /usr/local/bin/qemu-system-x86_64  -monitor stdio \
  -cpu qemu64 \
  -vga cirrus \
  -m 4096  -smp 4   \
  ...</pre></div></div><div class=paragraph><p>This results in a new prompt <code>(qemu)</code> in the terminal window as shown in
<a href=../virtualization/#qemu-monitor-operation>Figure 10</a>.</p></div><div id=qemu-monitor-operation class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd13.png alt="qemu freebsd13"></div><div class=title>Figure 10. QEMU Monitor Prompt and "stop" Command</div></div><div class=paragraph><p>The image also shows the <code>stop</code> command freezing the system during the FreeBSD boot sequence.
The system will remain frozen until the <code>cont</code> command is entered in the monitor.</p></div><div class=sect3><h4 id=qemu-adding-new-disk>24.6.6.1. Adding a New Disk to the VM<a class=anchor href=#qemu-adding-new-disk></a></h4><div class=paragraph><p>To add a new disk to a running VM, the disk needs to be prepared as above:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ~/QEMU/VM
% qemu-img create <span class=nt>-f</span> raw  new10G.img  10G</code></pre></div></div><div class=paragraph><p><a href=../virtualization/#qemu-add-new-disk-figure>Figure 11</a> shows the monitor command sequence needed to add a new disk in the VM.
Once the device has been added with the <code>device_add</code> command in the monitor it shows up on the FreeBSD system console shown in the lower part of the figure.
The disk can be configured as needed.</p></div><div class=paragraph><p>Note that the new disk must be added to the startup script if it is to be used after a VM reboot.</p></div><div id=qemu-add-new-disk-figure class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd14.png alt="qemu freebsd14"></div><div class=title>Figure 11. QEMU Monitor Commands to Add a New Disk</div></div></div><div class=sect3><h4 id=qemu-using-monitor-manage-snapshots>24.6.6.2. Using the QEMU Monitor to Manage Snapshots<a class=anchor href=#qemu-using-monitor-manage-snapshots></a></h4><div class=paragraph><p>QEMU’s documentation describes several similar concepts when using the term <strong>snapshot</strong>.
There is the <code>-snapshot</code> option on the command line which refers to using a drive or portion of a drive to contain a copy of a device.
Then there are the monitor commands <code>snapshot_blkdev</code> and <code>snapshot_blkdev_internal</code> which describe the actual act of copying the blockdev device.
Finally, there are the monitor commands <code>savevm</code>, <code>loadvm</code>, and <code>delvm</code> commands which refer to creating and saving, loading, or deleting a copy of an entire virtual machine.
Along with the latter, the monitor <code>info snapshots</code> command lists out details of recent snapshots.</p></div><div class=paragraph><p>This section will focus on creating, saving, and loading a complete VM image and will use the term <strong>snapshot</strong> for this purpose.</p></div><div class=paragraph><p>To start, recreate the "left" VM from scratch, this time using the <code>qcow2</code> format.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ~/QEMU/VM
% <span class=nb>rm </span>left.img
% qemu-img create <span class=nt>-f</span> qcow2 left.qcow2 16G  <span class=c># Clean file for a new FreeBSD installation.</span>
% <span class=nb>cd</span> ../SCRIPTS
<span class=c># /bin/sh left.sh                     # See the below program listing.</span></code></pre></div></div><div class=paragraph><p>Once the installation is complete, reboot, this time using the <code>-monitor stdio</code> option to allow use of the monitor.</p></div><div class="literalblock programlisting"><div class=content><pre># left VM script.
/usr/local/bin/qemu-system-x86_64  -monitor stdio \
  -cpu qemu64 \
  -vga std \
  -m 4096 \
  -smp 4   \
  -cdrom ../ISO/fbsd.iso \
  -boot order=cd,menu=on \
  -blockdev driver=file,aio=threads,node-name=imgleft,filename=../VM/left.qcow2 \
  -blockdev driver=qcow2,node-name=drive0,file=imgleft \
  -device virtio-blk-pci,drive=drive0,bootindex=1  \
  -netdev tap,id=nd0,ifname=tap0,script=no,downscript=no,br=bridge0 \
  -device e1000,netdev=nd0,mac=02:20:6c:65:66:74 \
  -name \&#34;left\&#34;</pre></div></div><div class=paragraph><p>To demonstrate snapshots, the following procedure can be used:</p></div><div class="olist arabic"><ol class=arabic><li><p>Install FreeBSD from scratch</p></li><li><p>Prepare the environment and take a snapshot with the <code>savevm</code> monitor command</p></li><li><p>Install several packages</p></li><li><p>Shut down the system</p></li><li><p>Restart a bare QEMU instance and utilize the monitor command <code>loadvm</code> to restore the VM</p></li><li><p>Observe that the restored VM does not have any packages</p></li></ol></div><div class=paragraph><p>During the "Prepare the environment" step, in a separate virtual console (ttyv1), an editing session with <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> is initiated simulating user activity.
Additional programs may be started if desired.
The snapshot should account for the state of all applications running at the time the snapshot is taken.</p></div><div class=paragraph><p><a href=../virtualization/#qemu-using-monitor-snapshots>Figure 12</a> shows the newly installed FreeBSD system with no packages, and separately, the editing session on ttyv1.
The <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> editor is currently in <code>insert</code> mode with the typist typing the word "broadcast".</p></div><div id=qemu-using-monitor-snapshots class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd15.png alt="qemu freebsd15"></div><div class=title>Figure 12. QEMU VM Before First Snapshot</div></div><div class=paragraph><p>To generate the snapshot, enter <code>savevm</code> in the monitor.
Be sure to give it a tag (such as <code>original_install</code>).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>QEMU 9.0.1 monitor - <span class=nb>type</span> <span class=s1>&#39;help&#39;</span> <span class=k>for </span>more information
<span class=o>(</span>qemu<span class=o>)</span>
<span class=o>(</span>qemu<span class=o>)</span> savevm original_install</code></pre></div></div><div class=paragraph><p>Next, in the main console window, install a package, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=zip&amp;sektion=1&amp;format=html">zip(1)</a> which has no dependencies.
Once that completes, renter the monitor and create another snapshot (<code>snap1_pkg+zip</code>).</p></div><div class=paragraph><p><a href=../virtualization/#qemu-after-monitor-snapshots>Figure 13</a> shows the results of the above commands and the output of the <code>info shapshots</code> command.</p></div><div id=qemu-after-monitor-snapshots class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd16.png alt="qemu freebsd16"></div><div class=title>Figure 13. QEMU Using Monitor Commands for Snapshots</div></div><div class=paragraph><p>Reboot the system, and before FreeBSD starts up, switch to the monitor and enter <code>stop</code>.
The VM will stop.</p></div><div class=paragraph><p>Enter <code>loadvm</code> with the tag you used above (here <code>original_install</code>).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>QEMU 9.0.1 monitor - <span class=nb>type</span> <span class=s1>&#39;help&#39;</span> <span class=k>for </span>more information
<span class=o>(</span>qemu<span class=o>)</span> stop
<span class=o>(</span>qemu<span class=o>)</span> loadvm original_install
<span class=o>(</span>qemu<span class=o>)</span> cont</code></pre></div></div><div class=paragraph><p>Immediately, the VM screen will switch to the exact moment the <code>savevm</code> command was entered above.
Note that the VM is still stopped.</p></div><div class=paragraph><p>Enter <code>cont</code> to start the VM, switch to the editing session on <code>ttyv1</code>, and type one letter on the keyboard.
The editor, still in insert mode, should respond accordingly.
Any other programs running at the time the snapshot was taken should be unaffected.</p></div><div class=paragraph><p>The above steps show how a snapshot can be taken, the system modified, and then "rolled back" by restoring the previous snapshot.</p></div><div class=paragraph><p>By default QEMU stores snapshot data in the same file as the image.
View the list of snapshots with <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu-img&amp;sektion=1&amp;format=html">qemu-img(1)</a> as shown below in
<a href=../virtualization/#qemu-examine-monitor-snapshots>Figure 14</a>.</p></div><div id=qemu-examine-monitor-snapshots class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd17.png alt="qemu freebsd17"></div><div class=title>Figure 14. QEMU Using <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu-img&amp;sektion=1&amp;format=html">qemu-img(1)</a> to Examine Snapshots</div></div></div></div><div class=sect2><h3 id=qemu-using-qemu-usb-devices>24.6.7. Using QEMU USB Devices<a class=anchor href=#qemu-using-qemu-usb-devices></a></h3><div class=paragraph><p>QEMU supports the creation of virtual USB devices that are backed by an image file.
These are virtual USB devices that can be partitioned, formatted, mounted, and used just like a real USB device.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/bin/qemu-system-x86_64  -monitor stdio \
  -cpu qemu64 \
  -vga cirrus \
  -m 4096  -smp 4   \
  -cdrom ../ISO/fbsd.iso \
  -boot order=cd,menu=on \
  -drive if=none,id=usbstick,format=raw,file=../VM/foo.img \
  -usb \
  -device usb-ehci,id=ehci \
  -device usb-storage,bus=ehci.0,drive=usbstick \
  -device usb-mouse \
  -blockdev driver=file,node-name=img1,filename=../VM/right.qcow2 \
  -blockdev driver=qcow2,node-name=drive0,file=img1 \
  -device virtio-blk-pci,drive=drive0,bootindex=1  \
  -netdev tap,id=nd0,ifname=tap1,script=no,downscript=no,br=bridge0 \
  -device e1000,netdev=nd0,mac=02:72:69:67:68:74 \
  -name \&#34;right\&#34;</pre></div></div><div class=paragraph><p>This configuration includes a <code>-drive</code> specification with the <code>id=usbstick</code>, raw format, and an image file (must be created by <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu-img&amp;sektion=1&amp;format=html">qemu-img(1)</a>).
The next line contains the <code>-device usb-ehci</code> specification for a USB EHCI controller, with <code>id=ehci</code>.
Finally, a <code>-device usb-storage</code> specification ties the above drive to the EHCI USB bus.</p></div><div class=paragraph><p>When the system is booted, FreeBSD will recognize a USB hub, add the attached
USB device, and assign it to <code>da0</code> as shown in
<a href=../virtualization/#qemu-usb-internal-storage>Figure 15</a>.</p></div><div id=qemu-usb-internal-storage class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd12.png alt="qemu freebsd12"></div><div class=title>Figure 15. QEMU Created USB Hub and Mass Storage Device</div></div><div class=paragraph><p>The device is ready to be partitioned with <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, and formatted with <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>.
Because the USB device is backed by a <a href="https://man.freebsd.org/cgi/man.cgi?query=qemu-img&amp;sektion=1&amp;format=html">qemu-img(1)</a> created file, data written to the device will persist across reboots.</p></div></div><div class=sect2><h3 id=qemu-using-host-usb-devices>24.6.8. Using Host USB Devices via Passthrough<a class=anchor href=#qemu-using-host-usb-devices></a></h3><div class=paragraph><p>QEMU USB passthrough support is listed as experimental in version 9.0.1 (Summer, 2024).
However, the following steps show how a USB stick mounted on the host can be used by the guest VM.</p></div><div class=paragraph><p>For more information and examples, see:</p></div><div class=ulist><ul><li><p><a href=https://www.qemu.org/docs/master/system/devices/usb.html class=bare>https://www.qemu.org/docs/master/system/devices/usb.html</a></p></li></ul></div><div class=paragraph><p>The upper part of <a href=../virtualization/#qemu-usb-passthrough>Figure 16</a> shows the QEMU monitor commands:</p></div><div class=ulist><ul><li><p><code>info usbhost</code> shows information about all USB devices on the host system.
Find the desired USB device on the host system and note the two hexadecimal values on that line.
(In the example below the host USB device is a Memorex Mini, with vendorid 0718, and productid 0619.)
Use the two values shown by the <code>info usbhost</code> command in the <code>device_add</code> step below.</p></li><li><p><code>device_add</code> adds a USB device to the guest VM.</p></li></ul></div><div id=qemu-usb-passthrough class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd18.png alt="qemu freebsd18"></div><div class=title>Figure 16. QEMU Monitor Commands to Access a USB Device on the Host</div></div><div class=paragraph><p>As before, once <code>device_add</code> completes, the FreeBSD kernel recognizes a new USB device, as shown in the lower half of the .</p></div><div class=paragraph><p>Using the new device is shown in
<a href=../virtualization/#qemu-usb-passthrough2>Figure 17</a>.</p></div><div id=qemu-usb-passthrough2 class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/qemu-freebsd19.png alt="qemu freebsd19"></div><div class=title>Figure 17. Using the Host USB Device via Passthrough</div></div><div class=paragraph><p>If the USB device is formatted as a FAT16 or FAT32 filesystem it can be mounted as an MS-DOS™ filesystem with <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> as in the example shown.
The <code>/etc/hosts</code> file is copied to the newly mounted drive and checksums are taken to verify the integrity of the file on the USB device.
The device is then unmounted with <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a>.</p></div><div class=paragraph><p>If the USB device is formatted with NTFS it is necessary to install the <code>fusefs-ntfs</code> package and use <a href="https://man.freebsd.org/cgi/man.cgi?query=ntfs-3g&amp;sektion=8&amp;format=html">ntfs-3g(8)</a> to access the device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install fusefs-ntfs</span>
<span class=c># kldload fusefs</span>
<span class=c># gpart show da1</span>
<span class=c># ntfs-3g /dev/da1s1 /mnt</span>

Access the drive as needed.  When finished:

<span class=c># umount /mnt</span></code></pre></div></div><div class=paragraph><p>Change the above device identifiers to match the installed hardware.
Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=ntfs-3g&amp;sektion=8&amp;format=html">ntfs-3g(8)</a> for additional information on working with NTFS filesystems.</p></div></div><div class=sect2><h3 id=qemu-summary>24.6.9. QEMU on FreeBSD Summary<a class=anchor href=#qemu-summary></a></h3><div class=paragraph><p>As noted above, QEMU works with several different hypervisor accelerators.</p></div><div class=paragraph><p>The list of <a href=https://www.qemu.org/docs/master/system/introduction.html#virtualisation-accelerators>Virtualization Accelerators</a> supported by QEMU includes:</p></div><div class=ulist><ul><li><p><code>KVM</code> on Linux supporting 64 bit Arm, MIPS, PPC, RISC-V, s390x, and x86</p></li><li><p><code>Xen</code> on Linux as dom0 supporting Arm, x86</p></li><li><p><code>Hypervisor Framework (hvf)</code> on MacOS supporting x86 and Arm (both 64 bit only)</p></li><li><p><code>Windows Hypervisor Platform (whpx)</code> on Windows supporting x86</p></li><li><p><code>NetBSD Virutal Machine Monitor (nvmm)</code> on NetBSD supporting x86</p></li><li><p><code>Tiny Code Generator (tcg)</code> on Linux and other POSIX, Windows, MacOS supporting Arm, x86, Loongarch64, MIPS, PPC, s390x, and Sparc64.</p></li></ul></div><div class=paragraph><p>All the examples in this section used the <code>Tiny Code Generator (tcg)</code> accelerator as that is the only supported accelerator on FreeBSD at present.</p></div></div></div></div><div class=sect1><h2 id=virtualization-host-bhyve>24.7. FreeBSD as a Host with bhyve<a class=anchor href=#virtualization-host-bhyve></a></h2><div class=sectionbody><div class=paragraph><p>The bhyve BSD-licensed hypervisor became part of the base system with FreeBSD 10.0-RELEASE.
This hypervisor supports several guests, including FreeBSD, OpenBSD, many Linux® distributions, and Microsoft Windows®.
By default, bhyve provides access to a serial console and does not emulate a graphical console.
Virtualization offload features of newer CPUs are used to avoid the legacy methods of translating instructions and manually managing memory mappings.</p></div><div class=paragraph><p>The bhyve design requires</p></div><div class=ulist><ul><li><p>an Intel® processor that supports Intel Extended Page Tables (EPT),</p></li><li><p>or an AMD® processor that supports AMD Rapid Virtualization Indexing (RVI), or Nested Page Tables (NPT),</p></li><li><p>or an ARM® aarch64 CPU.</p></li></ul></div><div class=paragraph><p>Only pure ARMv8.0 virtualization is supported on ARM, the Virtualization Host Extensions are not currently used.
Hosting Linux® guests or FreeBSD guests with more than one vCPU requires VMX unrestricted mode support (UG).</p></div><div class=paragraph><p>The easiest way to tell if an Intel or AMD processor supports bhyve is to run <code>dmesg</code> or look in <span class=filename>/var/run/dmesg.boot</span> for the <code>POPCNT</code> processor feature flag on the <code>Features2</code> line for AMD® processors or <code>EPT</code> and <code>UG</code> on the <code>VT-x</code> line for Intel® processors.</p></div><div class=sect2><h3 id=virtualization-bhyve-prep>24.7.1. Preparing the Host<a class=anchor href=#virtualization-bhyve-prep></a></h3><div class=paragraph><p>The first step to creating a virtual machine in bhyve is configuring the host system.
First, load the bhyve kernel module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vmm</span></code></pre></div></div><div class=paragraph><p>There are several ways to connect a virtual machine guest to a host’s network; one straightforward way to accomplish this is to create a <span class=filename>tap</span> interface for the network device in the virtual machine to attach to.
For the network device to participate in the network, also create a bridge interface containing the <span class=filename>tap</span> interface and the physical interface as members.
In this example, the physical interface is <em>igb0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig tap0 create</span>
<span class=c># sysctl net.link.tap.up_on_open=1</span>
net.link.tap.up_on_open: 0 -&gt; 1
<span class=c># ifconfig bridge0 create</span>
<span class=c># ifconfig bridge0 addm igb0 addm tap0</span>
<span class=c># ifconfig bridge0 up</span></code></pre></div></div></div><div class=sect2><h3 id=virtualization-bhyve-freebsd>24.7.2. Creating a FreeBSD Guest<a class=anchor href=#virtualization-bhyve-freebsd></a></h3><div class=paragraph><p>Create a file to use as the virtual disk for the guest machine.
Specify the size and name of the virtual disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G guest.img</span></code></pre></div></div><div class=paragraph><p>Download an installation image of FreeBSD to install:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch https://download.freebsd.org/releases/ISO-IMAGES/14.0/FreeBSD-14.0-RELEASE-amd64-bootonly.iso</span>
FreeBSD-14.0-RELEASE-amd64-bootonly.iso                426 MB   16 MBps    22s</code></pre></div></div><div class=paragraph><p>FreeBSD comes with an example script <code>vmrun.sh</code> for running a virtual machine in bhyve.
It will start the virtual machine and run it in a loop, so it will automatically restart if it crashes.
<code>vmrun.sh</code> takes several options to control the configuration of the machine, including:</p></div><div class=ulist><ul><li><p><code>-c</code> controls the number of virtual CPUs,</p></li><li><p><code>-m</code> limits the amount of memory available to the guest,</p></li><li><p><code>-t</code> defines which <span class=filename>tap</span> device to use,</p></li><li><p><code>-d</code> indicates which disk image to use,</p></li><li><p><code>-i</code> tells bhyve to boot from the CD image instead of the disk, and</p></li><li><p><code>-I</code> defines which CD image to use.</p></li></ul></div><div class=paragraph><p>The last parameter is the name of the virtual machine and is used to track the running machines.
The following command lists all available program argument options:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/share/examples/bhyve/vmrun.sh -h</span></code></pre></div></div><div class=paragraph><p>This example starts the virtual machine in installation mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/share/examples/bhyve/vmrun.sh -c 1 -m 1024M -t tap0 -d guest.img \</span>
     <span class=nt>-i</span> <span class=nt>-I</span> FreeBSD-14.0-RELEASE-amd64-bootonly.iso guestname</code></pre></div></div><div class=paragraph><p>The virtual machine will boot and start the installer.
After installing a system in the virtual machine, when the system asks about dropping into a shell at the end of the installation, choose <b class=button>Yes</b>.</p></div><div class=paragraph><p>Reboot the virtual machine.
While rebooting the virtual machine causes bhyve to exit, the <span class=filename>vmrun.sh</span> script runs <code>bhyve</code> in a loop and will automatically restart it.
When this happens, choose the reboot option from the boot loader menu to escape the loop.
Now the guest can be started from the virtual disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/share/examples/bhyve/vmrun.sh -c 4 -m 1024M -t tap0 -d guest.img guestname</span></code></pre></div></div></div><div class=sect2><h3 id=virtualization-bhyve-linux>24.7.3. Creating a Linux® Guest<a class=anchor href=#virtualization-bhyve-linux></a></h3><div class=paragraph><p>Linux guests can be booted either like any other regular <a href=../virtualization/#virtualization-bhyve-uefi>UEFI-based guest</a> virtual machine, or alternatively, you can make use of the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> port.</p></div><div class=paragraph><p>To do this, first ensure that the port is installed, then create a file to use as the virtual disk for the guest machine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G linux.img</span></code></pre></div></div><div class=paragraph><p>Starting a Linux virtual machine with <code>grub2-bhyve</code> is a two-step process.</p></div><div class="olist arabic"><ol class=arabic><li><p>First a kernel must be loaded, then the guest can be started.</p></li><li><p>The Linux® kernel is loaded with <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a>.</p></li></ol></div><div class=paragraph><p>Create a <span class=filename>device.map</span> that grub will use to map the virtual devices to the files on the host system:</p></div><div class="literalblock programlisting"><div class=content><pre>(hd0) ./linux.img
(cd0) ./somelinux.iso</pre></div></div><div class=paragraph><p>Use <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> to load the Linux® kernel from the ISO image:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r cd0 -M 1024M linuxguest</span></code></pre></div></div><div class=paragraph><p>This will start grub.
If the installation CD contains a <span class=filename>grub.cfg</span>, a menu will be displayed.
If not, the <code>vmlinuz</code> and <code>initrd</code> files must be located and loaded manually:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>cd0<span class=o>)</span>/isolinux
boot.cat boot.msg grub.conf initrd.img isolinux.bin isolinux.cfg memtest
splash.jpg TRANS.TBL vesamenu.c32 vmlinuz
grub&gt; linux <span class=o>(</span>cd0<span class=o>)</span>/isolinux/vmlinuz
grub&gt; initrd <span class=o>(</span>cd0<span class=o>)</span>/isolinux/initrd.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Now that the Linux® kernel is loaded, the guest can be started:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \</span>
    <span class=nt>-s</span> 3:0,virtio-blk,./linux.img <span class=nt>-s</span> 4:0,ahci-cd,./somelinux.iso <span class=se>\</span>
    <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>The system will boot and start the installer.
After installing a system in the virtual machine, reboot the virtual machine.
This will cause bhyve to exit.
The instance of the virtual machine needs to be destroyed before it can be started again:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div><div class=paragraph><p>Now the guest can be started directly from the virtual disk.
Load the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r hd0,msdos1 -M 1024M linuxguest</span>
grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>hd0,msdos2<span class=o>)</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
<span class=o>(</span>lvm/VolGroup-lv_swap<span class=o>)</span> <span class=o>(</span>lvm/VolGroup-lv_root<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span>/
lost+found/ grub/ efi/ System.map-2.6.32-431.el6.x86_64 config-2.6.32-431.el6.x
86_64 symvers-2.6.32-431.el6.x86_64.gz vmlinuz-2.6.32-431.el6.x86_64
initramfs-2.6.32-431.el6.x86_64.img
grub&gt; linux <span class=o>(</span>hd0,msdos1<span class=o>)</span>/vmlinuz-2.6.32-431.el6.x86_64 <span class=nv>root</span><span class=o>=</span>/dev/mapper/VolGroup-lv_root
grub&gt; initrd <span class=o>(</span>hd0,msdos1<span class=o>)</span>/initramfs-2.6.32-431.el6.x86_64.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Boot the virtual machine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \</span>
    <span class=nt>-s</span> 3:0,virtio-blk,./linux.img <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>Linux® will now boot in the virtual machine and eventually present you with the login prompt.
Login and use the virtual machine.
When you are finished, reboot the virtual machine to exit bhyve.
Destroy the virtual machine instance:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div></div><div class=sect2><h3 id=virtualization-bhyve-uefi>24.7.4. Booting bhyve Virtual Machines with UEFI Firmware<a class=anchor href=#virtualization-bhyve-uefi></a></h3><div class=paragraph><p>In addition to <code>bhyveload</code> and <code>grub-bhyve</code>, the bhyve hypervisor can also boot virtual machines using the UEFI firmware.
This option may support guest operating systems that are not supported by the other loaders.</p></div><div class=paragraph><p>To make use of the UEFI support in bhyve, first obtain the UEFI firmware images.
This can be done by installing <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> port or package.</p></div><div class=paragraph><p>With the firmware in place, add the flags <code>-l bootrom,<em>/path/to/firmware</em></code> to your bhyve command line.
The actual bhyve command may look like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
  	<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
	<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
	<span class=nt>-l</span> bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
	guest</code></pre></div></div><div class=paragraph><p>To allow a guest to store UEFI variables, you can use a variables file appended to the <code>-l</code> flag.
Note that bhyve will write guest modifications to the given variables file.
Therefore, be sure to first create a per-guest-copy of the variables template file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/local/share/uefi-firmware/BHYVE_UEFI_VARS.fd /path/to/vm-image/BHYVE_UEFI_VARS.fd</span></code></pre></div></div><div class=paragraph><p>Then, add that variables file into your bhyve arguments:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
  	<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
	<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
	<span class=nt>-l</span> bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd,/path/to/vm-image/BHYVE_UEFI_VARS.fd <span class=se>\</span>
	guest</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some Linux distributions require the use of UEFI variables to store the path for their UEFI boot file (using <code>linux64.efi</code> or <code>grubx64.efi</code> instead of <code>bootx64.efi</code>, for example).
It is therefore recommended to use a variables file for Linux virtual machines to avoid having to manually alter the boot partition files.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To view or modify the variables file contents, use <a href="https://man.freebsd.org/cgi/man.cgi?query=efivar&amp;sektion=8&amp;format=html">efivar(8)</a> from the host.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> also contains a CSM-enabled firmware, to boot guests with no UEFI support in legacy BIOS mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
  	<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
	<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
	<span class=nt>-l</span> bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI_CSM.fd <span class=se>\</span>
	guest</code></pre></div></div></div><div class=sect2><h3 id=virtualization-bhyve-framebuffer>24.7.5. Graphical UEFI Framebuffer for bhyve Guests<a class=anchor href=#virtualization-bhyve-framebuffer></a></h3><div class=paragraph><p>The UEFI firmware support is particularly useful with predominantly graphical guest operating systems such as Microsoft Windows®.</p></div><div class=paragraph><p>Support for the UEFI-GOP framebuffer may also be enabled with the <code>-s 29,fbuf,tcp=<em>0.0.0.0:5900</em></code> flags.
The framebuffer resolution may be configured with <code>w=<em>800</em></code> and <code>h=<em>600</em></code>, and bhyve can be instructed to wait for a VNC connection before booting the guest by adding <code>wait</code>.
The framebuffer may be accessed from the host or over the network via the VNC protocol.
Additionally, <code>-s 30,xhci,tablet</code> can be added to achieve precise mouse cursor synchronization with the host.</p></div><div class=paragraph><p>The resulting bhyve command would look like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 31:0,lpc \</span>
  	<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
	<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
	<span class=nt>-s</span> 29,fbuf,tcp<span class=o>=</span>0.0.0.0:5900,w<span class=o>=</span>800,h<span class=o>=</span>600,wait <span class=se>\</span>
	<span class=nt>-s</span> 30,xhci,tablet <span class=se>\</span>
	<span class=nt>-l</span> bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
	guest</code></pre></div></div><div class=paragraph><p>Note, in BIOS emulation mode, the framebuffer will cease receiving updates once control is passed from firmware to guest operating system.</p></div></div><div class=sect2><h3 id=virtualization-bhyve-windows>24.7.6. Creating a Microsoft Windows® Guest<a class=anchor href=#virtualization-bhyve-windows></a></h3><div class=paragraph><p>Setting up a guest for Windows versions 10 or earlier can be done directly from the original installation media and is a relatively straightforward process.
Aside from minimum resource requirements, running Windows as guest requires</p></div><div class=ulist><ul><li><p>wiring virtual machine memory (flag <code>-w</code>) and</p></li><li><p>booting with an UEFI bootrom.</p></li></ul></div><div class=paragraph><p>An example for booting a virtual machine guest with a Windows installation ISO:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bhyve <span class=se>\</span>
      <span class=nt>-c</span> 2 <span class=se>\</span>
      <span class=nt>-s</span> 0,hostbridge <span class=se>\</span>
      <span class=nt>-s</span> 3,nvme,windows2016.img <span class=se>\</span>
      <span class=nt>-s</span> 4,ahci-cd,install.iso <span class=se>\</span>
      <span class=nt>-s</span> 10,virtio-net,tap0 <span class=se>\</span>
      <span class=nt>-s</span> 31,lpc <span class=se>\</span>
      <span class=nt>-s</span> 30,xhci,tablet <span class=se>\</span>
      <span class=nt>-l</span> bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
      <span class=nt>-m</span> 8G <span class=nt>-H</span> <span class=nt>-w</span> <span class=se>\</span>
      windows2016</code></pre></div></div><div class=paragraph><p>Only one or two VCPUs should be used during installation but this number can be increased once Windows is installed.</p></div><div class=paragraph><p><a href=https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md>VirtIO drivers</a> must be installed to use the defined <code>virtio-net</code> network interface.
An alternative is to switch to E1000 (Intel E82545) emulation by changing <code>virtio-net</code> to <code>e1000</code> in the above command line.
However, performance will be impacted.</p></div><div class=sect3><h4 id=virtualization-bhyve-windows-win11>24.7.6.1. Creating a Windows 11 Guest<a class=anchor href=#virtualization-bhyve-windows-win11></a></h4><div class=paragraph><p>Beginning with Windows 11, Microsoft introduced a hardware requirement for a TPM 2 module.
bhyve supports passing a hardware TPM through to a guest.
The installation media can be modified to disable the relevant hardware checks.
A detailed description for this process can be found on the <a href=https://wiki.freebsd.org/bhyve/Windows#iso-remaster>FreeBSD Wiki</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Modifying Windows installation media and running Windows guests without a TPM module are unsupported by the manufacturer.
Consider your application and use case before implementing such approaches.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=virtualization-bhyve-zfs>24.7.7. Using ZFS with bhyve Guests<a class=anchor href=#virtualization-bhyve-zfs></a></h3><div class=paragraph><p>If ZFS is available on the host machine, using ZFS volumes instead of disk image files can provide significant performance benefits for the guest VMs.
A ZFS volume can be created by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V16G -o volmode=dev zroot/linuxdisk0</span></code></pre></div></div><div class=paragraph><p>When starting the VM, specify the ZFS volume as the disk drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \</span>
  	<span class=nt>-s3</span>:0,virtio-blk,/dev/zvol/zroot/linuxdisk0 <span class=se>\</span>
	<span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>If you are using ZFS for the host as well as inside a guest, keep in mind the competing memory pressure of both systems caching the virtual machine’s contents.
To alleviate this, consider setting the host’s ZFS filesystems to use metadata-only cache.
To do this, apply the following settings to ZFS filesystems on the host, replacing <code>&lt;name></code> with the name of the specific zvol dataset name of the virtual machine.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set primarycache=metadata &lt;name&gt;</span></code></pre></div></div></div><div class=sect2><h3 id=virtualiziation-bhyve-snapshot>24.7.8. Creating a Virtual Machine Snapshot<a class=anchor href=#virtualiziation-bhyve-snapshot></a></h3><div class=paragraph><p>Modern hypervisors allow their users to create "snapshots" of their state;
such a snapshot includes a guest’s disk, CPU, and memory contents.
A snapshot can usually be taken independent of whether the guest is running or shut down.
One can then reset and return the virtual machine to the precise state when the snapshot was taken.</p></div><div class=sect3><h4 id=virtualization-bhyve-snapshot-zfs>24.7.8.1. ZFS Snapshots<a class=anchor href=#virtualization-bhyve-snapshot-zfs></a></h4><div class=paragraph><p>Using ZFS volumes as the backing storage for a virtual machine enables the snapshotting of the guest’s disk. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>zfs snapshot zroot/path/to/zvol@snapshot_name</code></pre></div></div><div class=paragraph><p>Though it is possible to snapshot a ZFS volume this way while the guest is running, keep in mind that the contents of the virtual disk may be in an inconsistent state while the guest is active.
It is therefore recommended to first shutdown or pause the guest before executing this command.
Pausing a guest is not supported by default and needs to be enabled first (see <a href=../virtualization/#virtualization-bhyve-snapshot-builtin>Memory and CPU Snapshots</a>)</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Rolling back a ZFS zvol to a snapshot while a virtual machine is using it may corrupt the file system contents and crash the guest.
All unsaved data in the guest will be lost and modifications since the last snapshot may get destroyed.</p></div><div class=paragraph><p>A second rollback may be required once the virtual machine is shut down to restore the file system to a useable state.
This in turn will ultimately destroy any changes made after the snapshot.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=virtualization-bhyve-snapshot-builtin>24.7.8.2. Memory and CPU Snapshots (Experimental Feature)<a class=anchor href=#virtualization-bhyve-snapshot-builtin></a></h4><div class=paragraph><p>As of FreeBSD 13, bhyve has an experimental "snapshot" feature for dumping a guest’s memory and CPU state to a file and then halting the virtual machine.
The guest can be resumed from the snapshot file contents later.</p></div><div class=paragraph><p>However, this feature is not enabled by default and requires the system to be rebuilt from source.
See <a href=../cutting-edge/#updating-src-building>Building from Source</a> for an in-depth description on the process of compiling the kernel with custom options.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>The functionality is not ready for production use and limited to work for specific virtual machine configurations.
There are multiple limitations:</p></div><div class=ulist><ul><li><p><code>nvme</code> and <code>virtio-blk</code> storage backends do not work yet</p></li><li><p>snapshots are only supported when the guest uses a single kind of each device, i.e. if there is more than one <code>ahci-hd</code> disk attached, snapshot creation will fail</p></li><li><p>additionally, the feature may be reasonably stable on Intel, but it probably won’t work on AMD CPUs.</p></li></ul></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Make sure the <span class=filename>/usr/src</span> directory is up-to date before taking the following steps. See <a href=../cutting-edge/#updating-src-obtaining-src>Updating the Source</a> for the detailed procedure how to do this.</p></div></td></tr></tbody></table></div><div class=paragraph><p>First, add the following to <span class=filename>/etc/src.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>WITH_BHYVE_SNAPHOT=yes
BHYVE_SNAPSHOT=1
MK_BHYVE_SNAPSHOT=yes</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the system was partially or wholly rebuilt, it is recommended to run</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make cleanworld</span></code></pre></div></div><div class=paragraph><p>before proceeding.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Then follow the steps outlined in the <a href=../cutting-edge/#updating-src-quick-start>Quick Start section of the Updating FreeBSD from Source</a> chapter to build and install world and kernel.</p></div><div class=paragraph><p>To verify successful activation of the snapshot feature, enter</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --usage</span></code></pre></div></div><div class=paragraph><p>and check if the output lists a <code>--suspend</code> flag.
If the flag is missing, the feature did not activate correctly.</p></div><div class=paragraph><p>Then, you can snapshot and suspend a running virtual machine of your choice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --vm=vmname --suspend=/path/to/snapshot/filename</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Provide an absolute path and filename to <code>--suspend</code>.
Otherwise, bhyve will write snapshot data to whichever directory bhyve was started from.</p></div><div class=paragraph><p>Make sure to write the snapshot data to a secure directory.
The generated output contains a full memory dump of the guest and may thus contain sensitive data (i.e. passwords)!</p></div></td></tr></tbody></table></div><div class=paragraph><p>This creates three files:</p></div><div class=ulist><ul><li><p>memory snapshot - named like the input to <code>--suspend</code></p></li><li><p>kernel file - name like the input to <code>--suspend</code> with the suffix <span class=filename>.kern</span></p></li><li><p>metadata - contains meta data about the system state, named with the suffix <span class=filename>.meta</span></p></li></ul></div><div class=paragraph><p>To restore a guest from a snapshot, use the <code>-r</code> flag with <code>bhyve</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -r /path/to/snapshot/filename</span></code></pre></div></div><div class=paragraph><p>Restoring a guest snapshot on a different CPU architecture will not work.
Generally, attempting to restore on a system not identical to the snapshot creator will likely fail.</p></div></div></div><div class=sect2><h3 id=virtualization-bhyve-jailed>24.7.9. Jailing bhyve<a class=anchor href=#virtualization-bhyve-jailed></a></h3><div class=paragraph><p>For improved security and separation of virtual machines from the host operating system, it is possible to run bhyve in a jail.
See <a href=../jails/#>Jails</a> for an in-depth description of jails and their security benefits.</p></div><div class=sect3><h4 id=virtualization-bhyve-jailed-creation>24.7.9.1. Creating a Jail for bhyve<a class=anchor href=#virtualization-bhyve-jailed-creation></a></h4><div class=paragraph><p>First, create a jail environment. If using a UFS file system, simply run:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /jails/bhyve</span></code></pre></div></div><div class=paragraph><p>If using a <a href=../zfs/#>ZFS filesystem</a>, use the following commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create zroot/jails</span>
<span class=c># zfs create zroot/jails/bhyve</span></code></pre></div></div><div class=paragraph><p>Then create a ZFS zvol for the virtual machine <code>bhyvevm0</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create zroot/vms</span>
<span class=c># zfs create -V 20G zroot/vms/bhyvevm0</span></code></pre></div></div><div class=paragraph><p>If not using ZFS, use the following commands to create a disk image file directly in the jail directory structure:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /jails/bhyve/vms</span>
<span class=c># truncate -s 20G /jails/bhyve/vms/bhyvevm0</span></code></pre></div></div><div class=paragraph><p>Download a FreeBSD image, preferably a version equal to or older than the host and extract it into the jail directory:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /jails</span>
<span class=c># fetch -o base.txz http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/13.2-RELEASE/base.txz</span>
<span class=c># tar -C /jails/bhyve -xvf base.txz</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Running a higher FreeBSD version in a jail than the host is unsupported (i.e. running 14.0-RELEASE in a jail, embedded in a 13.2-RELEASE host).</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next, add a devfs ruleset to <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[devfsrules_jail_bhyve=100]
add include $devfsrules_hide_all
add include $devfsrules_unhide_login
add path &#39;urandom&#39; unhide
add path &#39;random&#39; unhide
add path &#39;crypto&#39; unhide
add path &#39;shm&#39; unhide
add path &#39;zero&#39; unhide
add path &#39;null&#39; unhide
add path &#39;mem&#39; unhide
add path &#39;vmm&#39; unhide
add path &#39;vmm/*&#39; unhide
add path &#39;vmm.io&#39; unhide
add path &#39;vmm.io/*&#39; unhide
add path &#39;nmdmbhyve*&#39; unhide
add path &#39;zvol&#39; unhide
add path &#39;zvol/zroot&#39; unhide
add path &#39;zvol/zroot/vms&#39; unhide
add path &#39;zvol/zroot/vms/bhyvevm0&#39; unhide
add path &#39;zvol/zroot/vms/bhyvevm1&#39; unhide
add path &#39;tap10*&#39; unhide</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If there’s another devfs rule with the numeric ID 100 in your <span class=filename>/etc/devfs.rules</span> file, replace the one in the listing with another yet unused ID number.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If not using a ZFS filesystem, skip the related zvol rules in <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;zvol&#39; unhide
add path &#39;zvol/zroot&#39; unhide
add path &#39;zvol/zroot/vms&#39; unhide
add path &#39;zvol/zroot/vms/bhyvevm0&#39; unhide
add path &#39;zvol/zroot/vms/bhyvevm1&#39; unhide</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>These rules will cause bhyve to</p></div><div class=ulist><ul><li><p>create a virtual machine with disk volumes called <code>bhyvevm0</code> and <code>bhyvevm1</code>,</p></li><li><p>use <span class=filename>tap</span> network interfaces with the name prefix <code>tap10</code>.
That means, valid interface names will be <code>tap10</code>, <code>tap100</code>, <code>tap101</code>, …​ <code>tap109</code>, <code>tap1000</code> and so on.</p><div class=paragraph><p>Limiting the access to a subset of possible <span class=filename>tap</span> interface names will prevent the jail (and thus bhyve) from seeing <span class=filename>tap</span> interfaces of the host and other jails.</p></div></li><li><p>use <span class=filename>nmdm</span> devices prefixed with "bhyve", i.e. <span class=filename>/dev/nmdmbhyve0</span>.</p></li></ul></div><div class=paragraph><p>Those rules can be expanded and varied with different guest and interface names as desired.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you intend to use bhyve on the host as well as in a one or more jails, remember that <span class=filename>tap</span> and <span class=filename>nmdm</span> interface names will operate in a shared environment.
For example, you can use <span class=filename>/dev/nmdmbhyve0</span> only either for bhyve on the host or in a jail.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Restart devfs for the changes to be loaded:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div><div class=paragraph><p>Then add a definition for your new jail into <span class=filename>/etc/jail.conf</span> or <span class=filename>/etc/jail.conf.d</span>.
Replace the interface number <span class=filename>$if</span> and IP address with your personal variations.</p></div><div class=exampleblock><div class=title>Example 1. Using NAT or routed traffic with a firewall</div><div class=content><div class="literalblock programlisting"><div class=content><pre>bhyve {
        $if = 0;
        exec.prestart = &#34;/sbin/ifconfig epair${if} create up&#34;;
        exec.prestart += &#34;/sbin/ifconfig epair${if}a up&#34;;
        exec.prestart += &#34;/sbin/ifconfig epair${if}a name ${name}0&#34;;
        exec.prestart += &#34;/sbin/ifconfig epair${if}b name jail${if}&#34;;
        exec.prestart += &#34;/sbin/ifconfig ${name}0 inet 192.168.168.1/27&#34;;
        exec.prestart += &#34;/sbin/sysctl net.inet.ip.forwarding=1&#34;;

        exec.clean;

        host.hostname = &#34;your-hostname-here&#34;;
        vnet;
        vnet.interface = &#34;em${if}&#34;;
        path = &#34;/jails/${name}&#34;;
        persist;
        securelevel = 3;
        devfs_ruleset = 100;
        mount.devfs;

        allow.vmm;

        exec.start += &#34;/bin/sh /etc/rc&#34;;
        exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;

        exec.poststop += &#34;/sbin/ifconfig ${name}0 destroy&#34;;
}</pre></div></div><div class=paragraph><p>This example assumes use of a firewall like <code>pf</code> or <code>ipfw</code> to NAT your jail traffic.
See the <a href=../firewalls/#>Firewalls</a> chapter for more details on the available options to implement this.</p></div></div></div><div class=exampleblock><div class=title>Example 2. Using a bridged network connection</div><div class=content><div class="literalblock programlisting"><div class=content><pre>bhyve {
        $if = 0;
        exec.prestart = &#34;/sbin/ifconfig epair${if} create up&#34;;
        exec.prestart += &#34;/sbin/ifconfig epair${if}a up&#34;;
        exec.prestart += &#34;/sbin/ifconfig epair${if}a name ${name}0&#34;;
        exec.prestart += &#34;/sbin/ifconfig epair${if}b name jail${if}&#34;;
        exec.prestart += &#34;/sbin/ifconfig bridge0 addm ${name}0&#34;;
        exec.prestart += &#34;/sbin/sysctl net.inet.ip.forwarding=1&#34;;

        exec.clean;

        host.hostname = &#34;your-hostname-here&#34;;
        vnet;
        vnet.interface = &#34;em${if}&#34;;
        path = &#34;/jails/${name}&#34;;
        persist;
        securelevel = 3;
        devfs_ruleset = 100;
        mount.devfs;

        allow.vmm;

        exec.start += &#34;/bin/sh /etc/rc&#34;;
        exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;

        exec.poststop += &#34;/sbin/ifconfig ${name}0 destroy&#34;;
}</pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you previously replaced the devfs ruleset ID 100 in <span class=filename>/etc/devfs.rules</span> with your own unique number, remember to replace the numeric ID also in your <span class=filename>jails.conf</span> too.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=virtualization-bhyve-jailed-config>24.7.9.2. Configuring the Jail<a class=anchor href=#virtualization-bhyve-jailed-config></a></h4><div class=paragraph><p>To start the jail for the first time and do some additional configuration work, enter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/resolv.conf /jails/bhyve/etc</span>
<span class=c># service jail onestart bhyve</span>
<span class=c># jexec bhyve</span>
<span class=c># sysrc ifconfig_jail0=&#34;inet 192.168.168.2/27&#34;</span>
<span class=c># sysrc defaultrouter=&#34;192.168.168.1&#34;</span>
<span class=c># sysrc sendmail_enable=NONE</span>
<span class=c># sysrc cloned_interfaces=&#34;tap100&#34;</span>
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Restart and enable the jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc jail_enable=YES</span>
<span class=c># service jail restart bhyve</span></code></pre></div></div><div class=paragraph><p>Afterwards, you can create a virtual machine within the jail.
For a FreeBSD guest, download an installation ISO first:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec bhyve</span>
<span class=c># cd /vms</span>
<span class=c># fetch -o freebsd.iso https://download.freebsd.org/releases/ISO-IMAGES/14.0/FreeBSD-14.0-RELEASE-amd64-bootonly.iso</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-jailed-createvm>24.7.9.3. Creating a Virtual Machine Inside the Jail<a class=anchor href=#virtualization-bhyve-jailed-createvm></a></h4><div class=paragraph><p>To create a virtual machine, use <code>bhyvectl</code> to initialize it first:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec bhyve</span>
<span class=c># bhyvectl --create --vm=bhyvevm0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Creating the guest with <code>bhyvectl</code> may be required when initiating the virtual machine from a jail.
Skipping this step may cause the following error message when starting <code>bhyve</code>:</p></div><div class=paragraph><p><code>vm_open: vm-name could not be opened. No such file or directory</code></p></div></td></tr></tbody></table></div><div class=paragraph><p>Finally, use your preferred way of starting the guest.</p></div><div class=exampleblock><div class=title>Example 3. Starting with <code>vmrun.sh</code> and ZFS</div><div class=content><div class=paragraph><p>Using <code>vmrun.sh</code> on a ZFS filesystems:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec bhyve</span>
<span class=c># sh /usr/share/examples/bhyve/vmrun.sh -c 1 -m 1024M \</span>
     <span class=nt>-t</span> tap100 <span class=nt>-d</span> /dev/zvols/zroot/vms/bhyvevm0 <span class=nt>-i</span> <span class=nt>-I</span> /vms/FreeBSD-14.0-RELEASE-amd64-bootonly.iso bhyvevm0</code></pre></div></div></div></div><div class=exampleblock><div class=title>Example 4. Starting with <code>vmrun.sh</code> and UFS</div><div class=content><div class=paragraph><p>Using <code>vmrun.sh</code> on a UFS filesystem:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec bhyve</span>
<span class=c># sh /usr/share/examples/bhyve/vmrun.sh -c 1 -m 1024M \</span>
     <span class=nt>-t</span> tap100 <span class=nt>-d</span> /vms/bhyvevm0 <span class=nt>-i</span> <span class=nt>-I</span> /vms/FreeBSD-14.0-RELEASE-amd64-bootonly.iso bhyvevm0</code></pre></div></div></div></div><div class=exampleblock><div class=title>Example 5. Starting bhyve for an UEFI guest with ZFS</div><div class=content><div class=paragraph><p>If instead you want to use an UEFI guest, remember to first install the required firmware package <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> in the jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg -j bhyve install bhyve-firmware</span></code></pre></div></div><div class=paragraph><p>Then use <code>bhyve</code> directly:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -c 4 -D -H -m 2G \</span>
        <span class=nt>-s</span> 0,hostbridge <span class=se>\</span>
        <span class=nt>-s</span> 1,lpc <span class=se>\</span>
        <span class=nt>-s</span> 2,virtio-net,tap100 <span class=se>\</span>
        <span class=nt>-s</span> 3,virtio-blk,/dev/zvol/zroot/vms/bhyvevm0 <span class=se>\</span>
	<span class=nt>-s</span> 4,ahci-cd,/vms/FreeBSD-14.0-RELEASE-amd64-bootonly.iso <span class=se>\</span>
        <span class=nt>-s</span> 31,fbuf,tcp<span class=o>=</span>127.0.0.1:5900,w<span class=o>=</span>1024,h<span class=o>=</span>800,tablet <span class=se>\</span>
        <span class=nt>-l</span> bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
        <span class=nt>-l</span> com1,/dev/nmdbbhyve0A <span class=se>\</span>
        bhyvevm0</code></pre></div></div><div class=paragraph><p>This will allow you to connect to your virtual machine <code>bhyvevm0</code> through VNC as well as a serial console at <span class=filename>/dev/nmdbbhyve0B</span>.</p></div></div></div></div></div><div class=sect2><h3 id=virtualization-bhyve-nmdm>24.7.10. Virtual Machine Consoles<a class=anchor href=#virtualization-bhyve-nmdm></a></h3><div class=paragraph><p>It is advantageous to wrap the bhyve console in a session management tool such as <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/tmux/>sysutils/tmux</a> or <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/screen/>sysutils/screen</a> in order to detach and reattach to the console.
It is also possible to have the console of bhyve be a null modem device that can be accessed with <code>cu</code>.
To do this, load the <span class=filename>nmdm</span> kernel module and replace <code>-l com1,stdio</code> with <code>-l com1,/dev/nmdm0A</code>.
The <span class=filename>/dev/nmdm</span> devices are created automatically as needed, where each is a pair, corresponding to the two ends of the null modem cable (<span class=filename>/dev/nmdm0A</span> and <span class=filename>/dev/nmdm0B</span>).
See <a href="https://man.freebsd.org/cgi/man.cgi?query=nmdm&amp;sektion=4&amp;format=html">nmdm(4)</a> for more information.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload nmdm</span>
<span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    <span class=nt>-l</span> com1,/dev/nmdm0A <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest
<span class=c># cu -l /dev/nmdm0B</span>
Connected

Ubuntu 13.10 handbook ttyS0

handbook login:</code></pre></div></div><div class=paragraph><p>To disconnect from a console, enter a newline (i.e. press <code>RETURN</code>) followed by tilde (<code>~</code>), and finally dot (<code>.</code>).
Keep in mind that only the connection is dropped while the login session remains active.
Another user connecting to the same console could therefore make use of any active sessions without having to first authenticate.
For security reasons, it’s therefore recommended to logout before disconnecting.</p></div><div class=paragraph><p>The number in the <span class=filename>nmdm</span> device path must be unique for each virtual machine and must not be used by any other processes before bhyve starts.
The number can be chosen arbitrarily and does not need to be taken from a consecutive sequence of numbers.
The device node pair (i.e. <span class=filename>/dev/nmdm0a</span> and <span class=filename>/dev/nmdm0b</span>) are created dynamically when bhyve connects its console and destroyed when it shuts down.
Keep this in mind when creating scripts to start your virtual machines: you need to make sure that all virtual machines are assigned unique <span class=filename>nmdm</span> devices.</p></div></div><div class=sect2><h3 id=virtualization-bhyve-managing>24.7.11. Managing Virtual Machines<a class=anchor href=#virtualization-bhyve-managing></a></h3><div class=paragraph><p>A device node is created in <span class=filename>/dev/vmm</span> for each virtual machine.
This allows the administrator to easily see a list of the running virtual machines:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al /dev/vmm</span>
total 1
dr-xr-xr-x   2 root  wheel    512 Mar 17 12:19 ./
dr-xr-xr-x  14 root  wheel    512 Mar 17 06:38 ../
crw-------   1 root  wheel  0x1a2 Mar 17 12:20 guestname
crw-------   1 root  wheel  0x19f Mar 17 12:19 linuxguest
crw-------   1 root  wheel  0x1a1 Mar 17 12:19 otherguest</code></pre></div></div><div class=paragraph><p>A specified virtual machine can be destroyed using <code>bhyvectl</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=guestname</span></code></pre></div></div><div class=paragraph><p>Destroying a virtual machine this way means killing it immediately. Any unsaved data will be lost, open files and filesystems may get corrupted.
To gracefully shut down a virtual machine, send a <code>TERM</code> signal to its bhyve process instead. This triggers an ACPI shutdown event for the guest:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps ax | grep bhyve</span>
17424  -  SC      56:48.27 bhyve: guestvm <span class=o>(</span>bhyve<span class=o>)</span>
<span class=c># kill 17424</span></code></pre></div></div></div><div class=sect2><h3 id=virtualization-tools-utilities>24.7.12. Tools and Utilities<a class=anchor href=#virtualization-tools-utilities></a></h3><div class=paragraph><p>There are numerous utilities and applications available in ports to help simplify setting up and managing bhyve virtual machines:</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Table 1. bhyve Managers</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Name</th><th class="tableblock halign-left valign-top">License</th><th class="tableblock halign-left valign-top">Package</th><th class="tableblock halign-left valign-top">Documentation</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>vm-bhyve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BSD-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/vm-bhyve/>sysutils/vm-bhyve</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://github.com/churchers/vm-bhyve>Documentation</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CBSD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BSD-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cbsd/>sysutils/cbsd</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://www.bsdstore.ru>Documentation</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Virt-Manager</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LGPL-3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/deskutils/virt-manager/>deskutils/virt-manager</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://virt-manager.org/>Documentation</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Bhyve RC Script</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Unknown</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-rc/>sysutils/bhyve-rc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://www.freshports.org/sysutils/bhyve-rc/>Documentation</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>bmd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Unknown</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bmd/>sysutils/bmd</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://github.com/yuichiro-naito/bmd>Documentation</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>vmstated</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BSD-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/vmstated/>sysutils/vmstated</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://github.com/christian-moerz/vmstated>Documentation</a></p></td></tr></tbody></table></div><div class=sect2><h3 id=virtualization-bhyve-onboot>24.7.13. Persistent Configuration<a class=anchor href=#virtualization-bhyve-onboot></a></h3><div class=paragraph><p>In order to configure the system to start bhyve guests at boot time, some configuration file changes are required.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p><span class=filename>/etc/sysctl.conf</span></p><div class=paragraph><p>When using <span class=filename>tap</span> interfaces as network backend, you either need to manually set each used <span class=filename>tap</span> interface to UP or simply set the following sysctl:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.tap.up_on_open=1</pre></div></div></li><li><p><span class=filename>/etc/rc.conf</span></p><div class=paragraph><p>To connect your virtual machine’s <span class=filename>tap</span> device to the network via a <span class=filename>bridge</span>, you need to persist the device settings in <span class=filename>/etc/rc.conf</span>.
Additionally, you can load the necessary kernel modules <code>vmm</code> for bhyve and <code>nmdm</code> for <span class=filename>nmdm</span> devices through the <code>kld_list</code> configuration variable.
When configuring <code>ifconfig_bridge0</code>, make sure to replace <code>&lt;ipaddr>/&lt;netmask></code> with the actual IP address of your physical interface (<span class=filename>igb0</span> in this example) and remove IP settings from your physical device.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc cloned_interfaces+=&#34;bridge0 tap0&#34;</span>
<span class=c># sysrc ifconfig_bridge0=&#34;inet &lt;ipaddr&gt;/&lt;netmask&gt; addm igb0 addm tap0&#34;</span>
<span class=c># sysrc kld_list+=&#34;nmdm vmm&#34;</span>
<span class=c># sysrc ifconfig_igb0=&#34;up&#34;</span></code></pre></div></div></li></ol></div><div id=virtualization-bhyve-onboot-bridgenet class=exampleblock><div class=title>Example 6. Setting the IP for a bridge device</div><div class=content><div class=paragraph><p>For a host with an <em>igb0</em> interface connected to the network with IP <code>10.10.10.1</code> and netmask <code>255.255.255.0</code>, you would use the following commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc ifconfig_igb0=&#34;up&#34;</span>
<span class=c># sysrc ifconfig_bridge0=&#34;inet 10.10.10.1/24 addm igb0 addm tap0&#34;</span>
<span class=c># sysrc kld_list+=&#34;nmdm vmm&#34;</span>
<span class=c># sysrc cloned_interfaces+=&#34;bridge0 tap0&#34;</span></code></pre></div></div></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Modifying the IP address configuration of a system may lock you out if you are executing these commands while you are connected remotely (i.e. via SSH)!
Take precautions to maintain system access or make those modifications while logged in on a local terminal session.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=virtualization-host-xen>24.8. FreeBSD as a Xen™-Host<a class=anchor href=#virtualization-host-xen></a></h2><div class=sectionbody><div class=paragraph><p>Xen is a GPLv2-licensed <a href=https://en.wikipedia.org/wiki/Hypervisor#Classification>type 1 hypervisor</a> for Intel® and ARM® architectures.
FreeBSD has included i386™ and AMD® 64-Bit <a href=https://wiki.xenproject.org/wiki/DomU>DomU</a> and <a href=https://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud>Amazon EC2</a> unprivileged domain (virtual machine) support since FreeBSD 8.0 and includes Dom0 control domain (host) support in FreeBSD 11.0.
Support for para-virtualized (PV) domains has been removed from FreeBSD 11 in favor of hardware virtualized (HVM) domains, which provides better performance.</p></div><div class=paragraph><p>Xen™ is a bare-metal hypervisor, which means that it is the first program loaded after the BIOS.
A special privileged guest called the Domain-0 (<code>Dom0</code> for short) is then started.
The Dom0 uses its special privileges to directly access the underlying physical hardware, making it a high-performance solution.
It is able to access the disk controllers and network adapters directly.
The Xen™ management tools to manage and control the Xen™ hypervisor are also used by the Dom0 to create, list, and destroy VMs.
Dom0 provides virtual disks and networking for unprivileged domains, often called <code>DomU</code>.
Xen™ Dom0 can be compared to the service console of other hypervisor solutions, while the DomU is where individual guest VMs are run.</p></div><div class=paragraph><p>Xen™ can migrate VMs between different Xen™ servers.
When the two xen hosts share the same underlying storage, the migration can be done without having to shut the VM down first.
Instead, the migration is performed live while the DomU is running and there is no need to restart it or plan a downtime.
This is useful in maintenance scenarios or upgrade windows to ensure that the services provided by the DomU are still provided.
Many more features of Xen™ are listed on the <a href=https://wiki.xenproject.org/wiki/Category:Overview>Xen Wiki Overview page</a>.
Note that not all features are supported on FreeBSD yet.</p></div><div class=sect2><h3 id=virtualization-host-xen-requirements>24.8.1. Hardware Requirements for Xen™ Dom0<a class=anchor href=#virtualization-host-xen-requirements></a></h3><div class=paragraph><p>To run the Xen™ hypervisor on a host, certain hardware functionality is required.
Running FreeBSD as a Xen host (Dom0) require Intel Extended Page Tables (<a href=https://en.wikipedia.org/wiki/Extended_Page_Table>EPT</a>) or AMD Nested Page Tables (<a href=https://en.wikipedia.org/wiki/Rapid_Virtualization_Indexing>NPT</a>) and Input/Output Memory Management Unit (<a href=https://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware>IOMMU</a>) support in the host processor.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to run a FreeBSD 13 Xen™ Dom0 the box must be booted using legacy boot (BIOS).
FreeBSD 14 and newer supports booting as a Xen™ Dom0 in both BIOS and UEFI modes.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=virtualization-host-xen-dom0-setup>24.8.2. Xen™ Dom0 Control Domain Setup<a class=anchor href=#virtualization-host-xen-dom0-setup></a></h3><div class=paragraph><p>Users should install the <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/xen-kernel/>emulators/xen-kernel</a> and <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xen-tools/>sysutils/xen-tools</a> packages, based on Xen™ 4.18.</p></div><div class=paragraph><p>Configuration files must be edited to prepare the host for the Dom0 integration after the Xen packages are installed.
An entry to <span class=filename>/etc/sysctl.conf</span> disables the limit on how many pages of memory are allowed to be wired.
Otherwise, DomU VMs with higher memory requirements will not run.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;vm.max_wired=-1&#39; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Another memory-related setting involves changing <span class=filename>/etc/login.conf</span>, setting the <code>memorylocked</code> option to <code>unlimited</code>.
Otherwise, creating DomU domains may fail with <code>Cannot allocate memory</code> errors.
After making the change to <span class=filename>/etc/login.conf</span>, run <code>cap_mkdb</code> to update the capability database.
See <a href=../security/#security-resourcelimits>Resource Limits</a> for details.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sed -i &#39;&#39; -e &#39;s/memorylocked=64K/memorylocked=unlimited/&#39; /etc/login.conf</span>
<span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class=paragraph><p>Add an entry for the Xen™ console to <span class=filename>/etc/ttys</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;xc0     &#34;/usr/libexec/getty Pc&#34;         xterm   onifconsole  secure&#39; &gt;&gt; /etc/ttys</span></code></pre></div></div><div class=paragraph><p>Selecting a Xen™ kernel in <span class=filename>/boot/loader.conf</span> activates the Dom0.
Xen™ also requires resources like CPU and memory from the host machine for itself and other DomU domains.
How much CPU and memory depends on the individual requirements and hardware capabilities.
In this example, 8 GB of memory and 4 virtual CPUs are made available for the Dom0.
The serial console is also activated, and logging options are defined.</p></div><div class=paragraph><p>The following command is used for Xen 4.7 packages:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;hw.pci.mcfg=0&#39; &gt;&gt; /boot/loader.conf</span>
<span class=c># echo &#39;if_tap_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class=c># echo &#39;xen_kernel=&#34;/boot/xen&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class=c># echo &#39;xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0pvh=1 console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div><div class=paragraph><p>For Xen versions 4.11 and higher, the following command should be used instead:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;if_tap_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class=c># echo &#39;xen_kernel=&#34;/boot/xen&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class=c># echo &#39;xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0=pvh console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Log files that Xen™ creates for the DomU VMs are stored in <span class=filename>/var/log/xen</span>.
Please be sure to check the contents of that directory if experiencing issues.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Activate the xencommons service during system startup:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc xencommons_enable=yes</span></code></pre></div></div><div class=paragraph><p>These settings are enough to start a Dom0-enabled system.
However, it lacks network functionality for the DomU machines.
To fix that, define a bridged interface with the main NIC of the system which the DomU VMs can use to connect to the network.
Replace <em>em0</em> with the host network interface name.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc cloned_interfaces=&#34;bridge0&#34;</span>
<span class=c># sysrc ifconfig_bridge0=&#34;addm em0 SYNCDHCP&#34;</span>
<span class=c># sysrc ifconfig_em0=&#34;up&#34;</span></code></pre></div></div><div class=paragraph><p>Restart the host to load the Xen™ kernel and start the Dom0.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># reboot</span></code></pre></div></div><div class=paragraph><p>After successfully booting the Xen™ kernel and logging into the system again, the Xen™ management tool <code>xl</code> is used to show information about the domains.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----     962.0</code></pre></div></div><div class=paragraph><p>The output confirms that the Dom0 (called <code>Domain-0</code>) has the ID <code>0</code> and is running.
It also has the memory and virtual CPUs that were defined in <span class=filename>/boot/loader.conf</span> earlier.
More information can be found in the <a href=https://www.xenproject.org/help/documentation.html>Xen™ Documentation</a>.
DomU guest VMs can now be created.</p></div></div><div class=sect2><h3 id=virtualization-host-xen-domu-setup>24.8.3. Xen™ DomU Guest VM Configuration<a class=anchor href=#virtualization-host-xen-domu-setup></a></h3><div class=paragraph><p>Unprivileged domains consist of a configuration file and virtual or physical hard disks.
Virtual disk storage for the DomU can be files created by <a href="https://man.freebsd.org/cgi/man.cgi?query=truncate&amp;sektion=1&amp;format=html">truncate(1)</a> or ZFS volumes as described in <a href=../zfs/#zfs-zfs-volume>“Creating and Destroying Volumes”</a>.
In this example, a 20 GB volume is used.
A VM is created with the ZFS volume, a FreeBSD ISO image, 1 GB of RAM and two virtual CPUs.
The ISO installation file is retrieved with <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> and saved locally in a file called <span class=filename>freebsd.iso</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch https://download.freebsd.org/releases/ISO-IMAGES/14.0/FreeBSD-14.0-RELEASE-amd64-bootonly.iso -o freebsd.iso</span></code></pre></div></div><div class=paragraph><p>A ZFS volume of 20 GB called <span class=filename>xendisk0</span> is created to serve as the disk space for the VM.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V20G -o volmode=dev zroot/xendisk0</span></code></pre></div></div><div class=paragraph><p>The new DomU guest VM is defined in a file.
Some specific definitions like name, keymap, and VNC connection details are also defined.
The following <span class=filename>freebsd.cfg</span> contains a minimum DomU configuration for this example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat freebsd.cfg</span>
builder <span class=o>=</span> <span class=s2>&#34;hvm&#34;</span> <i class=conum data-value=1></i><b>(1)</b>
name <span class=o>=</span> <span class=s2>&#34;freebsd&#34;</span> <i class=conum data-value=2></i><b>(2)</b>
memory <span class=o>=</span> 1024 <i class=conum data-value=3></i><b>(3)</b>
vcpus <span class=o>=</span> 2 <i class=conum data-value=4></i><b>(4)</b>
vif <span class=o>=</span> <span class=o>[</span> <span class=s1>&#39;mac=00:16:3E:74:34:32,bridge=bridge0&#39;</span> <span class=o>]</span> <i class=conum data-value=5></i><b>(5)</b>
disk <span class=o>=</span> <span class=o>[</span>
<span class=s1>&#39;/dev/zvol/tank/xendisk0,raw,hda,rw&#39;</span>, <i class=conum data-value=6></i><b>(6)</b>
<span class=s1>&#39;/root/freebsd.iso,raw,hdc:cdrom,r&#39;</span> <i class=conum data-value=7></i><b>(7)</b>
  <span class=o>]</span>
vnc <span class=o>=</span> 1 <i class=conum data-value=8></i><b>(8)</b>
vnclisten <span class=o>=</span> <span class=s2>&#34;0.0.0.0&#34;</span>
serial <span class=o>=</span> <span class=s2>&#34;pty&#34;</span>
usbdevice <span class=o>=</span> <span class=s2>&#34;tablet&#34;</span></code></pre></div></div><div class=paragraph><p>These lines are explained in more detail:</p></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This defines what kind of virtualization to use. <code>hvm</code> refers to hardware-assisted virtualization or hardware virtual machine. Guest operating systems can run unmodified on CPUs with virtualization extensions, providing nearly the same performance as running on physical hardware. <code>generic</code> is the default value and creates a PV domain.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Name of this virtual machine to distinguish it from others running on the same Dom0. Required.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Quantity of RAM in megabytes to make available to the VM. This amount is subtracted from the hypervisor’s total available memory, not the memory of the Dom0.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Number of virtual CPUs available to the guest VM. For best performance, do not create guests with more virtual CPUs than the number of physical CPUs on the host.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Virtual network adapter. This is the bridge connected to the network interface of the host. The <code>mac</code> parameter is the MAC address set on the virtual network interface. This parameter is optional, if no MAC is provided Xen™ will generate a random one.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Full path to the disk, file, or ZFS volume of the disk storage for this VM. Options and multiple disk definitions are separated by commas.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Defines the Boot medium from which the initial operating system is installed. In this example, it is the ISO image downloaded earlier. Consult the Xen™ documentation for other kinds of devices and options to set.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Options controlling VNC connectivity to the serial console of the DomU. In order, these are: active VNC support, define IP address on which to listen, device node for the serial console, and the input method for precise positioning of the mouse and other input methods. <code>keymap</code> defines which keymap to use, and is <code>english</code> by default.</td></tr></tbody></table></div><div class=paragraph><p>After the file has been created with all the necessary options, the DomU is created by passing it to <code>xl create</code> as a parameter.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Each time the Dom0 is restarted, the configuration file must be passed to <code>xl create</code> again to re-create the DomU.
By default, only the Dom0 is created after a reboot, not the individual VMs.
The VMs can continue where they left off as they stored the operating system on the virtual disk.
The virtual machine configuration can change over time (for example, when adding more memory).
The virtual machine configuration files must be properly backed up and kept available to be able to re-create the guest VM when needed.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The output of <code>xl list</code> confirms that the DomU has been created.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----  1653.4
freebsd                                      1  1024     1     <span class=nt>-b----</span>   663.9</code></pre></div></div><div class=paragraph><p>To begin the installation of the base operating system, start the VNC client, directing it to the main network address of the host or to the IP address defined on the <code>vnclisten</code> line of <span class=filename>freebsd.cfg</span>.
After the operating system has been installed, shut down the DomU and disconnect the VNC viewer.
Edit <span class=filename>freebsd.cfg</span>, removing the line with the <code>cdrom</code> definition or commenting it out by inserting a <code>#</code> character at the beginning of the line.
To load this new configuration, it is necessary to remove the old DomU with <code>xl destroy</code>, passing either the name or the id as the parameter.
Afterwards, recreate it using the modified <strong class=filename>freebsd.cfg</strong>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl destroy freebsd</span>
<span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class=paragraph><p>The machine can then be accessed again using the VNC viewer.
This time, it will boot from the virtual disk where the operating system has been installed and can be used as a virtual machine.</p></div></div><div class=sect2><h3 id=virtualization-host-xen-troubleshooting>24.8.4. Troubleshooting<a class=anchor href=#virtualization-host-xen-troubleshooting></a></h3><div class=paragraph><p>This section contains basic information in order to help troubleshoot issues found when using FreeBSD as a Xen™ host or guest.</p></div><div class=sect3><h4 id=virtualization-host-xen-troubleshooting-host>24.8.4.1. Host Boot Troubleshooting<a class=anchor href=#virtualization-host-xen-troubleshooting-host></a></h4><div class=paragraph><p>Please note that the following troubleshooting tips are intended for Xen™ 4.11 or newer.
If you are still using Xen™ 4.7 and having issues, consider migrating to a newer version of Xen™.</p></div><div class=paragraph><p>In order to troubleshoot host boot issues, you will likely need a serial cable, or a debug USB cable.
Verbose Xen™ boot output can be obtained by adding options to the <code>xen_cmdline</code> option found in <span class=filename>loader.conf</span>.
A couple of relevant debug options are:</p></div><div class=ulist><ul><li><p><code>iommu=debug</code>: can be used to print additional diagnostic information about the iommu.</p></li><li><p><code>dom0=verbose</code>: can be used to print additional diagnostic information about the dom0 build process.</p></li><li><p><code>sync_console</code>: flag to force synchronous console output. Useful for debugging to avoid losing messages due to rate limiting. Never use this option in production environments since it can allow malicious guests to perform DoS attacks against Xen™ using the console.</p></li></ul></div><div class=paragraph><p>FreeBSD should also be booted in verbose mode in order to identify any issues.
To activate verbose booting, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;boot_verbose=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div><div class=paragraph><p>If none of these options help solving the problem, please send the serial boot log to <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> and <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a> for further analysis.</p></div></div><div class=sect3><h4 id=virtualization-host-xen-troubleshooting-guest>24.8.4.2. Guest Creation Troubleshooting<a class=anchor href=#virtualization-host-xen-troubleshooting-guest></a></h4><div class=paragraph><p>Issues can also arise when creating guests, the following attempts to provide some help for those trying to diagnose guest creation issues.</p></div><div class=paragraph><p>The most common cause of guest creation failures is the <code>xl</code> command spitting some error and exiting with a return code different than 0.
If the error provided is not enough to help identify the issue, more verbose output can also be obtained from <code>xl</code> by using the <code>v</code> option repeatedly.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl -vvv create freebsd.cfg</span>
Parsing config from freebsd.cfg
libxl: debug: libxl_create.c:1693:do_domain_create: Domain 0:ao 0x800d750a0: create: <span class=nv>how</span><span class=o>=</span>0x0 <span class=nv>callback</span><span class=o>=</span>0x0 <span class=nv>poller</span><span class=o>=</span>0x800d6f0f0
libxl: debug: libxl_device.c:397:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda spec.backend<span class=o>=</span>unknown
libxl: debug: libxl_device.c:432:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda, using backend phy
libxl: debug: libxl_create.c:1018:initiate_domain_create: Domain 1:running bootloader
libxl: debug: libxl_bootloader.c:328:libxl__bootloader_run: Domain 1:not a PV/PVH domain, skipping bootloader
libxl: debug: libxl_event.c:689:libxl__ev_xswatch_deregister: watch <span class=nv>w</span><span class=o>=</span>0x800d96b98: deregister unregistered
domainbuilder: detail: xc_dom_allocate: <span class=nv>cmdline</span><span class=o>=</span><span class=s2>&#34;&#34;</span>, <span class=nv>features</span><span class=o>=</span><span class=s2>&#34;&#34;</span>
domainbuilder: detail: xc_dom_kernel_file: <span class=nv>filename</span><span class=o>=</span><span class=s2>&#34;/usr/local/lib/xen/boot/hvmloader&#34;</span>
domainbuilder: detail: xc_dom_malloc_filemap    : 326 kB
libxl: debug: libxl_dom.c:988:libxl__load_hvm_firmware_module: Loading BIOS: /usr/local/share/seabios/bios.bin
...</code></pre></div></div><div class=paragraph><p>If the verbose output does not help diagnose the issue, there are also QEMU and Xen™ toolstack logs in <span class=filename>/var/log/xen</span>.
Note that the name of the domain is appended to the log name, so if the domain is named <code>freebsd</code> you should find a <span class=filename>/var/log/xen/xl-freebsd.log</span> and likely a <span class=filename>/var/log/xen/qemu-dm-freebsd.log</span>.
Both log files can contain useful information for debugging.
If none of this helps solve the issue, please send the description of the issue you are facing and as much information as possible to <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> and <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a> in order to get help.</p></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: October 15, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=ddc41033bc" target=_blank>Roger Pau Monné</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/en/books/handbook/filesystems class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/en/books/handbook/l10n class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#virtualization-synopsis>24.1. Synopsis</a></li><li><a href=#virtualization-guest-parallelsdesktop>24.2. FreeBSD as a Guest on Parallels Desktop for macOS®</a></li><li><a href=#virtualization-guest-vmware>24.3. FreeBSD as a Guest on VMware Fusion for macOS®</a></li><li><a href=#virtualization-guest-virtualbox>24.4. FreeBSD as a Guest on VirtualBox™</a></li><li><a href=#virtualization-host-virtualbox>24.5. FreeBSD as a Host with VirtualBox™</a></li><li><a href=#qemu-virtualization-host-guest>24.6. Virtualization with QEMU on FreeBSD</a></li><li><a href=#virtualization-host-bhyve>24.7. FreeBSD as a Host with bhyve</a></li><li><a href=#virtualization-host-xen>24.8. FreeBSD as a Xen™-Host</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/books/handbook/handbook_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/en/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>