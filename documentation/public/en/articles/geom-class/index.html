<!doctype html><html class=theme-light lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A guide to GEOM internals, and writing your own GEOM class"><meta name=keywords content="GEOM,kernel,modules,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/en/articles/geom-class/><title>Writing a GEOM Class | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Writing a GEOM Class"><meta property="og:description" content="A guide to GEOM internals, and writing your own GEOM class"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="https://docs.freebsd.org/en/articles/geom-class/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/en\/articles\/geom-class\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=https://docs.freebsd.org/en/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/en/books>Books</a></li><li><a href=https://docs.freebsd.org/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Writing a GEOM Class</h1><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, and Xeon are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introduction</a></li><li><a href=#prelim>2. Preliminaries</a></li><li><a href=#kernelprog>3. On FreeBSD Kernel Programming</a></li><li><a href=#geom>4. On GEOM Programming</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Abstract</p></div><div class=paragraph><p>This text documents some starting points in developing GEOM classes, and kernel modules in general.
It is assumed that the reader is familiar with C userland programming.</p></div><hr></div></div><div class=sect1><h2 id=intro>1. Introduction<a class=anchor href=#intro></a></h2><div class=sectionbody><div class=sect2><h3 id=intro-docs>1.1. Documentation<a class=anchor href=#intro-docs></a></h3><div class=paragraph><p>Documentation on kernel programming is scarce - it is one of few areas where there is nearly nothing in the way of friendly tutorials, and the phrase "use the source!" really holds true.
However, there are some bits and pieces (some of them seriously outdated) floating around that should be studied before beginning to code:</p></div><div class=ulist><ul><li><p>The <a href=https://docs.freebsd.org/en/books/developers-handbook/>FreeBSD Developer’s Handbook</a> - part of the documentation project, it does not contain anything specific to kernel programming, but rather some general useful information.</p></li><li><p>The <a href=https://docs.freebsd.org/en/books/arch-handbook/>FreeBSD Architecture Handbook</a> - also from the documentation project, contains descriptions of several low-level facilities and procedures. The most important chapter is 13, <a href=https://docs.freebsd.org/en/books/arch-handbook/#driverbasics>Writing FreeBSD device drivers</a>.</p></li><li><p>The Blueprints section of <a href=http://www.freebsddiary.org>FreeBSD Diary</a> web site - contains several interesting articles on kernel facilities.</p></li><li><p>The man pages in section 9 - for important documentation on kernel functions.</p></li><li><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a> man page and <a href=http://phk.freebsd.dk/pubs/>PHK’s GEOM slides</a> - for general introduction of the GEOM subsystem.</p></li><li><p>Man pages <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_event&amp;sektion=9&amp;format=html">g_event(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_data&amp;sektion=9&amp;format=html">g_data(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_geom&amp;sektion=9&amp;format=html">g_geom(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_provider&amp;sektion=9&amp;format=html">g_provider(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_consumer&amp;sektion=9&amp;format=html">g_consumer(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_access&amp;sektion=9&amp;format=html">g_access(9)</a> & others linked from those, for documentation on specific functionalities.</p></li><li><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> man page - for documentation on the coding-style conventions which must be followed for any code which is to be committed to the FreeBSD tree.</p></li></ul></div></div></div></div><div class=sect1><h2 id=prelim>2. Preliminaries<a class=anchor href=#prelim></a></h2><div class=sectionbody><div class=paragraph><p>The best way to do kernel development is to have (at least) two separate computers.
One of these would contain the development environment and sources, and the other would be used to test the newly written code by network-booting and network-mounting filesystems from the first one.
This way if the new code contains bugs and crashes the machine, it will not mess up the sources (and other "live" data).
The second system does not even require a proper display.
Instead, it could be connected with a serial cable or KVM to the first one.</p></div><div class=paragraph><p>But, since not everybody has two or more computers handy, there are a few things that can be done to prepare an otherwise "live" system for developing kernel code.
This setup is also applicable for developing in a <a href=http://www.vmware.com/>VMWare</a> or <a href=http://www.qemu.org/>QEmu</a> virtual machine (the next best thing after a dedicated development machine).</p></div><div class=sect2><h3 id=prelim-system>2.1. Modifying a System for Development<a class=anchor href=#prelim-system></a></h3><div class=paragraph><p>For any kernel programming a kernel with <code>INVARIANTS</code> enabled is a must-have. So enter these in your kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options INVARIANT_SUPPORT
options INVARIANTS</pre></div></div><div class=paragraph><p>For more debugging you should also include WITNESS support, which will alert you of mistakes in locking:</p></div><div class="literalblock programlisting"><div class=content><pre>options WITNESS_SUPPORT
options WITNESS</pre></div></div><div class=paragraph><p>For debugging crash dumps, a kernel with debug symbols is needed:</p></div><div class="literalblock programlisting"><div class=content><pre>  makeoptions    DEBUG=-g</pre></div></div><div class=paragraph><p>With the usual way of installing the kernel (<code>make installkernel</code>) the debug kernel will not be automatically installed.
It is called <span class=filename>kernel.debug</span> and located in <span class=filename>/usr/obj/usr/src/sys/KERNELNAME/</span>.
For convenience it should be copied to <span class=filename>/boot/kernel/</span>.</p></div><div class=paragraph><p>Another convenience is enabling the kernel debugger so you can examine a kernel panic when it happens.
For this, enter the following lines in your kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB
options DDB
options KDB_TRACE</pre></div></div><div class=paragraph><p>For this to work you might need to set a sysctl (if it is not on by default):</p></div><div class="literalblock programlisting"><div class=content><pre>  debug.debugger_on_panic=1</pre></div></div><div class=paragraph><p>Kernel panics will happen, so care should be taken with the filesystem cache.
In particular, having softupdates might mean the latest file version could be lost if a panic occurs before it is committed to storage.
Disabling softupdates yields a great performance hit, and still does not guarantee data consistency.
Mounting filesystem with the "sync" option is needed for that.
For a compromise, the softupdates cache delays can be shortened.
There are three sysctl’s that are useful for this (best to be set in <span class=filename>/etc/sysctl.conf</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>kern.filedelay=5
kern.dirdelay=4
kern.metadelay=3</pre></div></div><div class=paragraph><p>The numbers represent seconds.</p></div><div class=paragraph><p>For debugging kernel panics, kernel core dumps are required.
Since a kernel panic might make filesystems unusable, this crash dump is first written to a raw partition.
Usually, this is the swap partition.
This partition must be at least as large as the physical RAM in the machine.
On the next boot, the dump is copied to a regular file.
This happens after filesystems are checked and mounted, and before swap is enabled.
This is controlled with two <span class=filename>/etc/rc.conf</span> variables:</p></div><div class="literalblock programlisting"><div class=content><pre>dumpdev=&#34;/dev/ad0s4b&#34;
dumpdir=&#34;/usr/core</pre></div></div><div class=paragraph><p>The <code>dumpdev</code> variable specifies the swap partition and <code>dumpdir</code> tells the system where in the filesystem to relocate the core dump on reboot.</p></div><div class=paragraph><p>Writing kernel core dumps is slow and takes a long time so if you have lots of memory (>256M) and lots of panics it could be frustrating to sit and wait while it is done (twice - first to write it to swap, then to relocate it to filesystem).
It is convenient then to limit the amount of RAM the system will use via a <span class=filename>/boot/loader.conf</span> tunable:</p></div><div class="literalblock programlisting"><div class=content><pre>  hw.physmem=&#34;256M&#34;</pre></div></div><div class=paragraph><p>If the panics are frequent and filesystems large (or you simply do not trust softupdates+background fsck) it is advisable to turn background fsck off via <span class=filename>/etc/rc.conf</span> variable:</p></div><div class="literalblock programlisting"><div class=content><pre>  background_fsck=&#34;NO&#34;</pre></div></div><div class=paragraph><p>This way, the filesystems will always get checked when needed.
Note that with background fsck, a new panic could happen while it is checking the disks.
Again, the safest way is not to have many local filesystems by using another computer as an NFS server.</p></div></div><div class=sect2><h3 id=prelim-starting>2.2. Starting the Project<a class=anchor href=#prelim-starting></a></h3><div class=paragraph><p>For the purpose of creating a new GEOM class, an empty subdirectory has to be created under an arbitrary user-accessible directory.
You do not have to create the module directory under <span class=filename>/usr/src</span>.</p></div></div><div class=sect2><h3 id=prelim-makefile>2.3. The Makefile<a class=anchor href=#prelim-makefile></a></h3><div class=paragraph><p>It is good practice to create <span class=filename>Makefiles</span> for every nontrivial coding project, which of course includes kernel modules.</p></div><div class=paragraph><p>Creating the <span class=filename>Makefile</span> is simple thanks to an extensive set of helper routines provided by the system.
In short, here is how a minimal <span class=filename>Makefile</span> looks for a kernel module:</p></div><div class="literalblock programlisting"><div class=content><pre>SRCS=g_journal.c
KMOD=geom_journal

.include &lt;bsd.kmod.mk&gt;</pre></div></div><div class=paragraph><p>This <span class=filename>Makefile</span> (with changed filenames) will do for any kernel module, and a GEOM class can reside in just one kernel module.
If more than one file is required, list it in the <code>SRCS</code> variable, separated with whitespace from other filenames.</p></div></div></div></div><div class=sect1><h2 id=kernelprog>3. On FreeBSD Kernel Programming<a class=anchor href=#kernelprog></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelprog-memalloc>3.1. Memory Allocation<a class=anchor href=#kernelprog-memalloc></a></h3><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>.
Basic memory allocation is only slightly different than its userland equivalent.
Most notably, <code>malloc</code>() and <code>free</code>() accept additional parameters as is described in the man page.</p></div><div class=paragraph><p>A "malloc type" must be declared in the declaration section of a source file, like this:</p></div><div class="literalblock programlisting"><div class=content><pre>  static MALLOC_DEFINE(M_GJOURNAL, &#34;gjournal data&#34;, &#34;GEOM_JOURNAL Data&#34;);</pre></div></div><div class=paragraph><p>To use this macro, <span class=filename>sys/param.h</span>, <span class=filename>sys/kernel.h</span> and <span class=filename>sys/malloc.h</span> headers must be included.</p></div><div class=paragraph><p>There is another mechanism for allocating memory, the UMA (Universal Memory Allocator).
See <a href="https://man.freebsd.org/cgi/man.cgi?query=uma&amp;sektion=9&amp;format=html">uma(9)</a> for details, but it is a special type of allocator mainly used for speedy allocation of lists comprised of same-sized items (for example, dynamic arrays of structs).</p></div></div><div class=sect2><h3 id=kernelprog-lists>3.2. Lists and Queues<a class=anchor href=#kernelprog-lists></a></h3><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=queue&amp;sektion=3&amp;format=html">queue(3)</a>.
There are a LOT of cases when a list of things needs to be maintained.
Fortunately, this data structure is implemented (in several ways) by C macros included in the system.
The most used list type is TAILQ because it is the most flexible.
It is also the one with largest memory requirements (its elements are doubly-linked) and also the slowest (although the speed variation is on the order of several CPU instructions more, so it should not be taken seriously).</p></div><div class=paragraph><p>If data retrieval speed is very important, see <a href="https://man.freebsd.org/cgi/man.cgi?query=tree&amp;sektion=3&amp;format=html">tree(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=hashinit&amp;sektion=9&amp;format=html">hashinit(9)</a>.</p></div></div><div class=sect2><h3 id=kernelprog-bios>3.3. BIOs<a class=anchor href=#kernelprog-bios></a></h3><div class=paragraph><p>Structure <code>bio</code> is used for any and all Input/Output operations concerning GEOM.
It basically contains information about what device ('provider') should satisfy the request, request type, offset, length, pointer to a buffer, and a bunch of "user-specific" flags and fields that can help implement various hacks.</p></div><div class=paragraph><p>The important thing here is that <code>bio</code>s are handled asynchronously.
That means that, in most parts of the code, there is no analogue to userland’s <a href="https://man.freebsd.org/cgi/man.cgi?query=read&amp;sektion=2&amp;format=html">read(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2&amp;format=html">write(2)</a> calls that do not return until a request is done.
Rather, a developer-supplied function is called as a notification when the request gets completed (or results in error).</p></div><div class=paragraph><p>The asynchronous programming model (also called "event-driven") is somewhat harder than the much more used imperative one used in userland (at least it takes a while to get used to it).
In some cases the helper routines <code>g_write_data</code>() and <code>g_read_data</code>() can be used, but <em>not always</em>.
In particular, they cannot be used when a mutex is held; for example, the GEOM topology mutex or the internal mutex held during the <code>.start</code>() and <code>.stop</code>() functions.</p></div></div></div></div><div class=sect1><h2 id=geom>4. On GEOM Programming<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=geom-ggate>4.1. Ggate<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>If maximum performance is not needed, a much simpler way of making a data transformation is to implement it in userland via the ggate (GEOM gate) facility.
Unfortunately, there is no easy way to convert between, or even share code between the two approaches.</p></div></div><div class=sect2><h3 id=geom-class>4.2. GEOM Class<a class=anchor href=#geom-class></a></h3><div class=paragraph><p>GEOM classes are transformations on the data.
These transformations can be combined in a tree-like fashion.
Instances of GEOM classes are called <em>geoms</em>.</p></div><div class=paragraph><p>Each GEOM class has several "class methods" that get called when there is no geom instance available (or they are simply not bound to a single instance):</p></div><div class=ulist><ul><li><p><code>.init</code> is called when GEOM becomes aware of a GEOM class (when the kernel module gets loaded.)</p></li><li><p><code>.fini</code> gets called when GEOM abandons the class (when the module gets unloaded)</p></li><li><p><code>.taste</code> is called next, once for each provider the system has available. If applicable, this function will usually create and start a geom instance.</p></li><li><p><code>.destroy_geom</code> is called when the geom should be disbanded</p></li><li><p><code>.ctlconf</code> is called when user requests reconfiguration of existing geom</p></li></ul></div><div class=paragraph><p>Also defined are the GEOM event functions, which will get copied to the geom instance.</p></div><div class=paragraph><p>Field <code>.geom</code> in the <code>g_class</code> structure is a LIST of geoms instantiated from the class.</p></div><div class=paragraph><p>These functions are called from the g_event kernel thread.</p></div></div><div class=sect2><h3 id=geom-softc>4.3. Softc<a class=anchor href=#geom-softc></a></h3><div class=paragraph><p>The name "softc" is a legacy term for "driver private data".
The name most probably comes from the archaic term "software control block".
In GEOM, it is a structure (more precise: pointer to a structure) that can be attached to a geom instance to hold whatever data is private to the geom instance.
Most GEOM classes have the following members:</p></div><div class=ulist><ul><li><p><code>struct g_provider *provider</code> : The "provider" this geom instantiates</p></li><li><p><code>uint16_t n_disks</code> : Number of consumer this geom consumes</p></li><li><p><code>struct g_consumer **disks</code> : Array of <code>struct g_consumer*</code>. (It is not possible to use just single indirection because struct g_consumer* are created on our behalf by GEOM).</p></li></ul></div><div class=paragraph><p>The <code>softc</code> structure contains all the state of geom instance.
Every geom instance has its own softc.</p></div></div><div class=sect2><h3 id=geom-metadata>4.4. Metadata<a class=anchor href=#geom-metadata></a></h3><div class=paragraph><p>Format of metadata is more-or-less class-dependent, but MUST start with:</p></div><div class=ulist><ul><li><p>16 byte buffer for null-terminated signature (usually the class name)</p></li><li><p>uint32 version ID</p></li></ul></div><div class=paragraph><p>It is assumed that geom classes know how to handle metadata with version ID’s lower than theirs.</p></div><div class=paragraph><p>Metadata is located in the last sector of the provider (and thus must fit in it).</p></div><div class=paragraph><p>(All this is implementation-dependent but all existing code works like that, and it is supported by libraries.)</p></div></div><div class=sect2><h3 id=geom-creating>4.5. Labeling/creating a GEOM<a class=anchor href=#geom-creating></a></h3><div class=paragraph><p>The sequence of events is:</p></div><div class=ulist><ul><li><p>user calls <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a> utility (or one of its hardlinked friends)</p></li><li><p>the utility figures out which geom class it is supposed to handle and searches for <span class=filename>geom_CLASSNAME.so</span> library (usually in <span class=filename>/lib/geom</span>).</p></li><li><p>it <a href="https://man.freebsd.org/cgi/man.cgi?query=dlopen&amp;sektion=3&amp;format=html">dlopen(3)</a>-s the library, extracts the definitions of command-line parameters and helper functions.</p></li></ul></div><div class=paragraph><p>In the case of creating/labeling a new geom, this is what happens:</p></div><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a> looks in the command-line argument for the command (usually <code>label</code>), and calls a helper function.</p></li><li><p>The helper function checks parameters and gathers metadata, which it proceeds to write to all concerned providers.</p></li><li><p>This "spoils" existing geoms (if any) and initializes a new round of "tasting" of the providers. The intended geom class recognizes the metadata and brings the geom up.</p></li></ul></div><div class=paragraph><p>(The above sequence of events is implementation-dependent but all existing code works like that, and it is supported by libraries.)</p></div></div><div class=sect2><h3 id=geom-command>4.6. GEOM Command Structure<a class=anchor href=#geom-command></a></h3><div class=paragraph><p>The helper <span class=filename>geom_CLASSNAME.so</span> library exports <code>class_commands</code> structure, which is an array of <code>struct g_command</code> elements.
Commands are of uniform format and look like:</p></div><div class="literalblock programlisting"><div class=content><pre>  verb [-options] geomname [other]</pre></div></div><div class=paragraph><p>Common verbs are:</p></div><div class=ulist><ul><li><p>label - to write metadata to devices so they can be recognized at tasting and brought up in geoms</p></li><li><p>destroy - to destroy metadata, so the geoms get destroyed</p></li></ul></div><div class=paragraph><p>Common options are:</p></div><div class=ulist><ul><li><p><code>-v</code> : be verbose</p></li><li><p><code>-f</code> : force</p></li></ul></div><div class=paragraph><p>Many actions, such as labeling and destroying metadata can be performed in userland.
For this, <code>struct g_command</code> provides field <code>gc_func</code> that can be set to a function (in the same <span class=filename>.so</span>) that will be called to process a verb.
If <code>gc_func</code> is NULL, the command will be passed to kernel module, to <code>.ctlreq</code> function of the geom class.</p></div></div><div class=sect2><h3 id=geom-geoms>4.7. Geoms<a class=anchor href=#geom-geoms></a></h3><div class=paragraph><p>Geoms are instances of GEOM classes.
They have internal data (a softc structure) and some functions with which they respond to external events.</p></div><div class=paragraph><p>The event functions are:</p></div><div class=ulist><ul><li><p><code>.access</code> : calculates permissions (read/write/exclusive)</p></li><li><p><code>.dumpconf</code> : returns XML-formatted information about the geom</p></li><li><p><code>.orphan</code> : called when some underlying provider gets disconnected</p></li><li><p><code>.spoiled</code> : called when some underlying provider gets written to</p></li><li><p><code>.start</code> : handles I/O</p></li></ul></div><div class=paragraph><p>These functions are called from the <code>g_down</code> kernel thread and there can be no sleeping in this context, (see definition of sleeping elsewhere) which limits what can be done quite a bit, but forces the handling to be fast.</p></div><div class=paragraph><p>Of these, the most important function for doing actual useful work is the <code>.start</code>() function, which is called when a BIO request arrives for a provider managed by a instance of geom class.</p></div></div><div class=sect2><h3 id=geom-threads>4.8. GEOM Threads<a class=anchor href=#geom-threads></a></h3><div class=paragraph><p>There are three kernel threads created and run by the GEOM framework:</p></div><div class=ulist><ul><li><p><code>g_down</code> : Handles requests coming from high-level entities (such as a userland request) on the way to physical devices</p></li><li><p><code>g_up</code> : Handles responses from device drivers to requests made by higher-level entities</p></li><li><p><code>g_event</code> : Handles all other cases: creation of geom instances, access counting, "spoil" events, etc.</p></li></ul></div><div class=paragraph><p>When a user process issues "read data X at offset Y of a file" request, this is what happens:</p></div><div class=ulist><ul><li><p>The filesystem converts the request into a struct bio instance and passes it to the GEOM subsystem. It knows what geom instance should handle it because filesystems are hosted directly on a geom instance.</p></li><li><p>The request ends up as a call to the <code>.start</code>() function made on the g_down thread and reaches the top-level geom instance.</p></li><li><p>This top-level geom instance (for example the partition slicer) determines that the request should be routed to a lower-level instance (for example the disk driver). It makes a copy of the bio request (bio requests <em>ALWAYS</em> need to be copied between instances, with <code>g_clone_bio</code>()!), modifies the data offset and target provider fields and executes the copy with <code>g_io_request</code>()</p></li><li><p>The disk driver gets the bio request also as a call to <code>.start</code>() on the <code>g_down</code> thread. It talks to hardware, gets the data back, and calls <code>g_io_deliver</code>() on the bio.</p></li><li><p>Now, the notification of bio completion "bubbles up" in the <code>g_up</code> thread. First the partition slicer gets <code>.done</code>() called in the <code>g_up</code> thread, it uses information stored in the bio to free the cloned <code>bio</code> structure (with <code>g_destroy_bio</code>()) and calls <code>g_io_deliver</code>() on the original request.</p></li><li><p>The filesystem gets the data and transfers it to userland.</p></li></ul></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a> man page for information how the data is passed back and forth in the <code>bio</code> structure (note in particular the <code>bio_parent</code> and <code>bio_children</code> fields and how they are handled).</p></div><div class=paragraph><p>One important feature is: <em>THERE CAN BE NO SLEEPING IN G_UP AND G_DOWN THREADS</em>.
This means that none of the following things can be done in those threads (the list is of course not complete, but only informative):</p></div><div class=ulist><ul><li><p>Calls to <code>msleep</code>() and <code>tsleep</code>(), obviously.</p></li><li><p>Calls to <code>g_write_data</code>() and <code>g_read_data</code>(), because these sleep between passing the data to consumers and returning.</p></li><li><p>Waiting for I/O.</p></li><li><p>Calls to <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> and <code>uma_zalloc</code>() with <code>M_WAITOK</code> flag set</p></li><li><p>sx and other sleepable locks</p></li></ul></div><div class=paragraph><p>This restriction is here to stop GEOM code clogging the I/O request path, since sleeping is usually not time-bound and there can be no guarantees on how long will it take (there are some other, more technical reasons also).
It also means that there is not much that can be done in those threads; for example, almost any complex thing requires memory allocation.
Fortunately, there is a way out: creating additional kernel threads.</p></div></div><div class=sect2><h3 id=geom-kernelthreads>4.9. Kernel Threads for Use in GEOM Code<a class=anchor href=#geom-kernelthreads></a></h3><div class=paragraph><p>Kernel threads are created with <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_create&amp;sektion=9&amp;format=html">kthread_create(9)</a> function, and they are sort of similar to userland threads in behavior, only they cannot return to caller to signify termination, but must call <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_exit&amp;sektion=9&amp;format=html">kthread_exit(9)</a>.</p></div><div class=paragraph><p>In GEOM code, the usual use of threads is to offload processing of requests from <code>g_down</code> thread (the <code>.start</code>() function).
These threads look like "event handlers": they have a linked list of event associated with them (on which events can be posted by various functions in various threads so it must be protected by a mutex), take the events from the list one by one and process them in a big <code>switch</code>() statement.</p></div><div class=paragraph><p>The main benefit of using a thread to handle I/O requests is that it can sleep when needed.
Now, this sounds good, but should be carefully thought out.
Sleeping is well and very convenient but can very effectively destroy performance of the geom transformation.
Extremely performance-sensitive classes probably should do all the work in <code>.start</code>() function call, taking great care to handle out-of-memory and similar errors.</p></div><div class=paragraph><p>The other benefit of having a event-handler thread like that is to serialize all the requests and responses coming from different geom threads into one thread.
This is also very convenient but can be slow.
In most cases, handling of <code>.done</code>() requests can be left to the <code>g_up</code> thread.</p></div><div class=paragraph><p>Mutexes in FreeBSD kernel (see <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a>) have one distinction from their more common userland cousins - the code cannot sleep while holding a mutex).
If the code needs to sleep a lot, <a href="https://man.freebsd.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;format=html">sx(9)</a> locks may be more appropriate.
On the other hand, if you do almost everything in a single thread, you may get away with no mutexes at all.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: November 3, 2021 by <a href="https://cgit.freebsd.org/doc/commit/?id=64acd169b8" target=_blank>Sergio Carlavilla Delgado</a></p></div></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introduction</a></li><li><a href=#prelim>2. Preliminaries</a></li><li><a href=#kernelprog>3. On FreeBSD Kernel Programming</a></li><li><a href=#geom>4. On GEOM Programming</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/articles/geom-class/geom-class_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/en/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>