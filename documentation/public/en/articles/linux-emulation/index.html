<!doctype html><html class=theme-light lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A technical description about the internals of the Linux emulation layer in FreeBSD"><meta name=keywords content="Emulation,Linuxulator,kernel,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/en/articles/linux-emulation/><title>Linux® emulation in FreeBSD | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Linux® emulation in FreeBSD"><meta property="og:description" content="A technical description about the internals of the Linux emulation layer in FreeBSD"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="en"><meta property="og:url" content="http://172.16.201.134:1313/en/articles/linux-emulation/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/en\/articles\/linux-emulation\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/en>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/en/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/en/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/en/books>Books</a></li><li><a href=http://172.16.201.134:1313/en/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/en/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=en>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Linux® emulation in FreeBSD</h1><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390, and ThinkPad are trademarks of International Business Machines Corporation in the United States, other countries, or both.</p><p>Adobe, Acrobat, Acrobat Reader, Flash and PostScript are either registered trademarks or trademarks of Adobe Systems Incorporated in the United States and/or other countries.</p><p>Linux is a registered trademark of Linus Torvalds.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS and VirtualBox are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.</p><p>NetBSD is a registered trademark of the NetBSD Foundation.</p><p>RealNetworks, RealPlayer, and RealAudio are the registered trademarks of RealNetworks, Inc.</p><p>Oracle is a registered trademark of Oracle Corporation.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introduction</a></li><li><a href=#inside>2. A look inside…​</a></li><li><a href=#freebsd-emulation>3. Emulation</a></li><li><a href=#md>4. Linux® emulation layer -MD part</a></li><li><a href=#mi>5. Linux® emulation layer -MI part</a></li><li><a href=#conclusion>6. Conclusion</a></li><li><a href=#literatures>7. Literatures</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Abstract</p></div><div class=paragraph><p>This masters thesis deals with updating the Linux® emulation layer (the so called <em>Linuxulator</em>).
The task was to update the layer to match the functionality of Linux® 2.6.
As a reference implementation, the Linux® 2.6.16 kernel was chosen.
The concept is loosely based on the NetBSD implementation.
Most of the work was done in the summer of 2006 as a part of the Google Summer of Code students program.
The focus was on bringing the <em>NPTL</em> (new POSIX® thread library) support into the emulation layer, including <em>TLS</em> (thread local storage), <em>futexes</em> (fast user space mutexes), <em>PID mangling</em>, and some other minor things.
Many small problems were identified and fixed in the process.
My work was integrated into the main FreeBSD source repository and will be shipped in the upcoming 7.0R release.
We, the emulation development team, are working on making the Linux® 2.6 emulation the default emulation layer in FreeBSD.</p></div><hr></div></div><div class=sect1><h2 id=intro>1. Introduction<a class=anchor href=#intro></a></h2><div class=sectionbody><div class=paragraph><p>In the last few years the open source UNIX® based operating systems started to be widely deployed on server and client machines.
Among these operating systems I would like to point out two: FreeBSD, for its BSD heritage, time proven code base and many interesting features and Linux® for its wide user base, enthusiastic open developer community and support from large companies.
FreeBSD tends to be used on server class machines serving heavy duty networking tasks with less usage on desktop class machines for ordinary users.
While Linux® has the same usage on servers, but it is used much more by home based users.
This leads to a situation where there are many binary only programs available for Linux® that lack support for FreeBSD.</p></div><div class=paragraph><p>Naturally, a need for the ability to run Linux® binaries on a FreeBSD system arises and this is what this thesis deals with: the emulation of the Linux® kernel in the FreeBSD operating system.</p></div><div class=paragraph><p>During the Summer of 2006 Google Inc. sponsored a project which focused on extending the Linux® emulation layer (the so called Linuxulator) in FreeBSD to include Linux® 2.6 facilities.
This thesis is written as a part of this project.</p></div></div></div><div class=sect1><h2 id=inside>2. A look inside…​<a class=anchor href=#inside></a></h2><div class=sectionbody><div class=paragraph><p>In this section we are going to describe every operating system in question.
How they deal with syscalls, trapframes etc., all the low-level stuff.
We also describe the way they understand common UNIX® primitives like what a PID is, what a thread is, etc.
In the third subsection we talk about how UNIX® on UNIX® emulation could be done in general.</p></div><div class=sect2><h3 id=what-is-unix>2.1. What is UNIX®<a class=anchor href=#what-is-unix></a></h3><div class=paragraph><p>UNIX® is an operating system with a long history that has influenced almost every other operating system currently in use.
Starting in the 1960s, its development continues to this day (although in different projects).
UNIX® development soon forked into two main ways: the BSDs and System III/V families.
They mutually influenced themselves by growing a common UNIX® standard.
Among the contributions originated in BSD we can name virtual memory, TCP/IP networking, FFS, and many others.
The System V branch contributed to SysV interprocess communication primitives, copy-on-write, etc.
UNIX® itself does not exist any more but its ideas have been used by many other operating systems world wide thus forming the so called UNIX®-like operating systems.
These days the most influential ones are Linux®, Solaris, and possibly (to some extent) FreeBSD.
There are in-company UNIX® derivatives (AIX, HP-UX etc.), but these have been more and more migrated to the aforementioned systems.
Let us summarize typical UNIX® characteristics.</p></div></div><div class=sect2><h3 id=tech-details>2.2. Technical details<a class=anchor href=#tech-details></a></h3><div class=paragraph><p>Every running program constitutes a process that represents a state of the computation.
Running process is divided between kernel-space and user-space.
Some operations can be done only from kernel space (dealing with hardware etc.), but the process should spend most of its lifetime in the user space.
The kernel is where the management of the processes, hardware, and low-level details take place.
The kernel provides a standard unified UNIX® API to the user space.
The most important ones are covered below.</p></div><div class=sect3><h4 id=kern-proc-comm>2.2.1. Communication between kernel and user space process<a class=anchor href=#kern-proc-comm></a></h4><div class=paragraph><p>Common UNIX® API defines a syscall as a way to issue commands from a user space process to the kernel.
The most common implementation is either by using an interrupt or specialized instruction (think of <code>SYSENTER</code>/<code>SYSCALL</code> instructions for ia32).
Syscalls are defined by a number.
For example in FreeBSD, the syscall number 85 is the <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=2&amp;format=html">swapon(2)</a> syscall and the syscall number 132 is <a href="https://man.freebsd.org/cgi/man.cgi?query=mkfifo&amp;sektion=2&amp;format=html">mkfifo(2)</a>.
Some syscalls need parameters, which are passed from the user-space to the kernel-space in various ways (implementation dependent).
Syscalls are synchronous.</p></div><div class=paragraph><p>Another possible way to communicate is by using a <em>trap</em>.
Traps occur asynchronously after some event occurs (division by zero, page fault etc.).
A trap can be transparent for a process (page fault) or can result in a reaction like sending a <em>signal</em> (division by zero).</p></div></div><div class=sect3><h4 id=proc-proc-comm>2.2.2. Communication between processes<a class=anchor href=#proc-proc-comm></a></h4><div class=paragraph><p>There are other APIs (System V IPC, shared memory etc.) but the single most important API is signal.
Signals are sent by processes or by the kernel and received by processes.
Some signals can be ignored or handled by a user supplied routine, some result in a predefined action that cannot be altered or ignored.</p></div></div><div class=sect3><h4 id=proc-mgmt>2.2.3. Process management<a class=anchor href=#proc-mgmt></a></h4><div class=paragraph><p>Kernel instances are processed first in the system (so called init).
Every running process can create its identical copy using the <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> syscall.
Some slightly modified versions of this syscall were introduced but the basic semantic is the same.
Every running process can morph into some other process using the <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a> syscall.
Some modifications of this syscall were introduced but all serve the same basic purpose.
Processes end their lives by calling the <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=2&amp;format=html">exit(2)</a> syscall.
Every process is identified by a unique number called PID.
Every process has a defined parent (identified by its PID).</p></div></div><div class=sect3><h4 id=thread-mgmt>2.2.4. Thread management<a class=anchor href=#thread-mgmt></a></h4><div class=paragraph><p>Traditional UNIX® does not define any API nor implementation for threading, while POSIX® defines its threading API but the implementation is undefined.
Traditionally there were two ways of implementing threads.
Handling them as separate processes (1:1 threading) or envelope the whole thread group in one process and managing the threading in userspace (1:N threading).
Comparing main features of each approach:</p></div><div class=paragraph><p>1:1 threading</p></div><div class=ulist><ul><li><p>- heavyweight threads</p></li><li><p>- the scheduling cannot be altered by the user (slightly mitigated by the POSIX® API)</p></li><li><p>+ no syscall wrapping necessary</p></li><li><p>+ can utilize multiple CPUs</p></li></ul></div><div class=paragraph><p>1:N threading</p></div><div class=ulist><ul><li><p>+ lightweight threads</p></li><li><p>+ scheduling can be easily altered by the user</p></li><li><p>- syscalls must be wrapped</p></li><li><p>- cannot utilize more than one CPU</p></li></ul></div></div></div><div class=sect2><h3 id=what-is-freebsd>2.3. What is FreeBSD?<a class=anchor href=#what-is-freebsd></a></h3><div class=paragraph><p>The FreeBSD project is one of the oldest open source operating systems currently available for daily use.
It is a direct descendant of the genuine UNIX® so it could be claimed that it is a true UNIX® although licensing issues do not permit that.
The start of the project dates back to the early 1990’s when a crew of fellow BSD users patched the 386BSD operating system.
Based on this patchkit a new operating system arose named FreeBSD for its liberal license.
Another group created the NetBSD operating system with different goals in mind.
We will focus on FreeBSD.</p></div><div class=paragraph><p>FreeBSD is a modern UNIX®-based operating system with all the features of UNIX®.
Preemptive multitasking, multiuser facilities, TCP/IP networking, memory protection, symmetric multiprocessing support, virtual memory with merged VM and buffer cache, they are all there.
One of the interesting and extremely useful features is the ability to emulate other UNIX®-like operating systems.
As of December 2006 and 7-CURRENT development, the following emulation functionalities are supported:</p></div><div class=ulist><ul><li><p>FreeBSD/i386 emulation on FreeBSD/amd64</p></li><li><p>FreeBSD/i386 emulation on FreeBSD/ia64</p></li><li><p>Linux®-emulation of Linux® operating system on FreeBSD</p></li><li><p>NDIS-emulation of Windows networking drivers interface</p></li><li><p>NetBSD-emulation of NetBSD operating system</p></li><li><p>PECoff-support for PECoff FreeBSD executables</p></li><li><p>SVR4-emulation of System V revision 4 UNIX®</p></li></ul></div><div class=paragraph><p>Actively developed emulations are the Linux® layer and various FreeBSD-on-FreeBSD layers.
Others are not supposed to work properly nor be usable these days.</p></div><div class=sect3><h4 id=freebsd-tech-details>2.3.1. Technical details<a class=anchor href=#freebsd-tech-details></a></h4><div class=paragraph><p>FreeBSD is traditional flavor of UNIX® in the sense of dividing the run of processes into two halves: kernel space and user space run.
There are two types of process entry to the kernel: a syscall and a trap.
There is only one way to return.
In the subsequent sections we will describe the three gates to/from the kernel.
The whole description applies to the i386 architecture as the Linuxulator only exists there but the concept is similar on other architectures.
The information was taken from [1] and the source code.</p></div><div class=sect4><h5 id=freebsd-sys-entries>2.3.1.1. System entries<a class=anchor href=#freebsd-sys-entries></a></h5><div class=paragraph><p>FreeBSD has an abstraction called an execution class loader, which is a wedge into the <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> syscall.
This employs a structure <code>sysentvec</code>, which describes an executable ABI.
It contains things like errno translation table, signal translation table, various functions to serve syscall needs (stack fixup, coredumping, etc.).
Every ABI the FreeBSD kernel wants to support must define this structure, as it is used later in the syscall processing code and at some other places.
System entries are handled by trap handlers, where we can access both the kernel-space and the user-space at once.</p></div></div><div class=sect4><h5 id=freebsd-syscalls>2.3.1.2. Syscalls<a class=anchor href=#freebsd-syscalls></a></h5><div class=paragraph><p>Syscalls on FreeBSD are issued by executing interrupt <code>0x80</code> with register <code>%eax</code> set to a desired syscall number with arguments passed on the stack.</p></div><div class=paragraph><p>When a process issues an interrupt <code>0x80</code>, the <code>int0x80</code> syscall trap handler is issued (defined in <span class=filename>sys/i386/i386/exception.s</span>), which prepares arguments (i.e. copies them on to the stack) for a call to a C function <a href="https://man.freebsd.org/cgi/man.cgi?query=syscall&amp;sektion=2&amp;format=html">syscall(2)</a> (defined in <span class=filename>sys/i386/i386/trap.c</span>), which processes the passed in trapframe.
The processing consists of preparing the syscall (depending on the <code>sysvec</code> entry), determining if the syscall is 32-bit or 64-bit one (changes size of the parameters), then the parameters are copied, including the syscall.
Next, the actual syscall function is executed with processing of the return code (special cases for <code>ERESTART</code> and <code>EJUSTRETURN</code> errors).
Finally an <code>userret()</code> is scheduled, switching the process back to the users-pace.
The parameters to the actual syscall handler are passed in the form of <code>struct thread *td</code>, <code>struct syscall args *</code> arguments where the second parameter is a pointer to the copied in structure of parameters.</p></div></div><div class=sect4><h5 id=freebsd-traps>2.3.1.3. Traps<a class=anchor href=#freebsd-traps></a></h5><div class=paragraph><p>Handling of traps in FreeBSD is similar to the handling of syscalls.
Whenever a trap occurs, an assembler handler is called.
It is chosen between alltraps, alltraps with regs pushed or calltrap depending on the type of the trap.
This handler prepares arguments for a call to a C function <code>trap()</code> (defined in <span class=filename>sys/i386/i386/trap.c</span>), which then processes the occurred trap.
After the processing it might send a signal to the process and/or exit to userland using <code>userret()</code>.</p></div></div><div class=sect4><h5 id=freebsd-exits>2.3.1.4. Exits<a class=anchor href=#freebsd-exits></a></h5><div class=paragraph><p>Exits from kernel to userspace happen using the assembler routine <code>doreti</code> regardless of whether the kernel was entered via a trap or via a syscall.
This restores the program status from the stack and returns to the userspace.</p></div></div><div class=sect4><h5 id=freebsd-unix-primitives>2.3.1.5. UNIX® primitives<a class=anchor href=#freebsd-unix-primitives></a></h5><div class=paragraph><p>FreeBSD operating system adheres to the traditional UNIX® scheme, where every process has a unique identification number, the so called <em>PID</em> (Process ID).
PID numbers are allocated either linearly or randomly ranging from <code>0</code> to <code>PID_MAX</code>.
The allocation of PID numbers is done using linear searching of PID space.
Every thread in a process receives the same PID number as result of the <a href="https://man.freebsd.org/cgi/man.cgi?query=getpid&amp;sektion=2&amp;format=html">getpid(2)</a> call.</p></div><div class=paragraph><p>There are currently two ways to implement threading in FreeBSD.
The first way is M:N threading followed by the 1:1 threading model.
The default library used is M:N threading (<code>libpthread</code>) and you can switch at runtime to 1:1 threading (<code>libthr</code>).
The plan is to switch to 1:1 library by default soon.
Although those two libraries use the same kernel primitives, they are accessed through different API(es).
The M:N library uses the <code>kse_*</code> family of syscalls while the 1:1 library uses the <code>thr_*</code> family of syscalls.
Due to this, there is no general concept of thread ID shared between kernel and userspace.
Of course, both threading libraries implement the pthread thread ID API.
Every kernel thread (as described by <code>struct thread</code>) has td tid identifier but this is not directly accessible from userland and solely serves the kernel’s needs.
It is also used for 1:1 threading library as pthread’s thread ID but handling of this is internal to the library and cannot be relied on.</p></div><div class=paragraph><p>As stated previously there are two implementations of threading in FreeBSD.
The M:N library divides the work between kernel space and userspace.
Thread is an entity that gets scheduled in the kernel but it can represent various number of userspace threads.
M userspace threads get mapped to N kernel threads thus saving resources while keeping the ability to exploit multiprocessor parallelism.
Further information about the implementation can be obtained from the man page or [1].
The 1:1 library directly maps a userland thread to a kernel thread thus greatly simplifying the scheme.
None of these designs implement a fairness mechanism (such a mechanism was implemented but it was removed recently because it caused serious slowdown and made the code more difficult to deal with).</p></div></div></div></div><div class=sect2><h3 id=what-is-linux>2.4. What is Linux®<a class=anchor href=#what-is-linux></a></h3><div class=paragraph><p>Linux® is a UNIX®-like kernel originally developed by Linus Torvalds, and now being contributed to by a massive crowd of programmers all around the world.
From its mere beginnings to today, with wide support from companies such as IBM or Google, Linux® is being associated with its fast development pace, full hardware support and benevolent dictator model of organization.</p></div><div class=paragraph><p>Linux® development started in 1991 as a hobbyist project at University of Helsinki in Finland.
Since then it has obtained all the features of a modern UNIX®-like OS: multiprocessing, multiuser support, virtual memory, networking, basically everything is there.
There are also highly advanced features like virtualization etc.</p></div><div class=paragraph><p>As of 2006 Linux® seems to be the most widely used open source operating system with support from independent software vendors like Oracle, RealNetworks, Adobe, etc.
Most of the commercial software distributed for Linux® can only be obtained in a binary form so recompilation for other operating systems is impossible.</p></div><div class=paragraph><p>Most of the Linux® development happens in a Git version control system.
Git is a distributed system so there is no central source of the Linux® code, but some branches are considered prominent and official.
The version number scheme implemented by Linux® consists of four numbers A.B.C.D.
Currently development happens in 2.6.C.D, where C represents major version, where new features are added or changed while D is a minor version for bugfixes only.</p></div><div class=paragraph><p>More information can be obtained from [3].</p></div><div class=sect3><h4 id=linux-tech-details>2.4.1. Technical details<a class=anchor href=#linux-tech-details></a></h4><div class=paragraph><p>Linux® follows the traditional UNIX® scheme of dividing the run of a process in two halves: the kernel and user space.
The kernel can be entered in two ways: via a trap or via a syscall.
The return is handled only in one way.
The further description applies to Linux® 2.6 on the i386™ architecture.
This information was taken from [2].</p></div><div class=sect4><h5 id=linux-syscalls>2.4.1.1. Syscalls<a class=anchor href=#linux-syscalls></a></h5><div class=paragraph><p>Syscalls in Linux® are performed (in userspace) using <code>syscallX</code> macros where X substitutes a number representing the number of parameters of the given syscall.
This macro translates to a code that loads <code>%eax</code> register with a number of the syscall and executes interrupt <code>0x80</code>.
After this syscall return is called, which translates negative return values to positive <code>errno</code> values and sets <code>res</code> to <code>-1</code> in case of an error.
Whenever the interrupt <code>0x80</code> is called the process enters the kernel in system call trap handler.
This routine saves all registers on the stack and calls the selected syscall entry.
Note that the Linux® calling convention expects parameters to the syscall to be passed via registers as shown here:</p></div><div class="olist arabic"><ol class=arabic><li><p>parameter → <code>%ebx</code></p></li><li><p>parameter → <code>%ecx</code></p></li><li><p>parameter → <code>%edx</code></p></li><li><p>parameter → <code>%esi</code></p></li><li><p>parameter → <code>%edi</code></p></li><li><p>parameter → <code>%ebp</code></p></li></ol></div><div class=paragraph><p>There are some exceptions to this, where Linux® uses different calling convention (most notably the <code>clone</code> syscall).</p></div></div><div class=sect4><h5 id=linux-traps>2.4.1.2. Traps<a class=anchor href=#linux-traps></a></h5><div class=paragraph><p>The trap handlers are introduced in <span class=filename>arch/i386/kernel/traps.c</span> and most of these handlers live in <span class=filename>arch/i386/kernel/entry.S</span>, where handling of the traps happens.</p></div></div><div class=sect4><h5 id=linux-exits>2.4.1.3. Exits<a class=anchor href=#linux-exits></a></h5><div class=paragraph><p>Return from the syscall is managed by syscall <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>, which checks for the process having unfinished work, then checks whether we used user-supplied selectors.
If this happens stack fixing is applied and finally the registers are restored from the stack and the process returns to the userspace.</p></div></div><div class=sect4><h5 id=linux-unix-primitives>2.4.1.4. UNIX® primitives<a class=anchor href=#linux-unix-primitives></a></h5><div class=paragraph><p>In the 2.6 version, the Linux® operating system redefined some of the traditional UNIX® primitives, notably PID, TID and thread.
PID is defined not to be unique for every process, so for some processes (threads) <a href="https://man.freebsd.org/cgi/man.cgi?query=getppid&amp;sektion=2&amp;format=html">getppid(2)</a> returns the same value.
Unique identification of process is provided by TID.
This is because <em>NPTL</em> (New POSIX® Thread Library) defines threads to be normal processes (so called 1:1 threading).
Spawning a new process in Linux® 2.6 happens using the <code>clone</code> syscall (fork variants are reimplemented using it).
This clone syscall defines a set of flags that affect behavior of the cloning process regarding thread implementation.
The semantic is a bit fuzzy as there is no single flag telling the syscall to create a thread.</p></div><div class=paragraph><p>Implemented clone flags are:</p></div><div class=ulist><ul><li><p><code>CLONE_VM</code> - processes share their memory space</p></li><li><p><code>CLONE_FS</code> - share umask, cwd and namespace</p></li><li><p><code>CLONE_FILES</code> - share open files</p></li><li><p><code>CLONE_SIGHAND</code> - share signal handlers and blocked signals</p></li><li><p><code>CLONE_PARENT</code> - share parent</p></li><li><p><code>CLONE_THREAD</code> - be thread (further explanation below)</p></li><li><p><code>CLONE_NEWNS</code> - new namespace</p></li><li><p><code>CLONE_SYSVSEM</code> - share SysV undo structures</p></li><li><p><code>CLONE_SETTLS</code> - setup TLS at supplied address</p></li><li><p><code>CLONE_PARENT_SETTID</code> - set TID in the parent</p></li><li><p><code>CLONE_CHILD_CLEARTID</code> - clear TID in the child</p></li><li><p><code>CLONE_CHILD_SETTID</code> - set TID in the child</p></li></ul></div><div class=paragraph><p><code>CLONE_PARENT</code> sets the real parent to the parent of the caller.
This is useful for threads because if thread A creates thread B we want thread B to be parented to the parent of the whole thread group.
<code>CLONE_THREAD</code> does exactly the same thing as <code>CLONE_PARENT</code>, <code>CLONE_VM</code> and <code>CLONE_SIGHAND</code>, rewrites PID to be the same as PID of the caller, sets exit signal to be none and enters the thread group.
<code>CLONE_SETTLS</code> sets up GDT entries for TLS handling.
The <code>CLONE_*_*TID</code> set of flags sets/clears user supplied address to TID or 0.</p></div><div class=paragraph><p>As you can see the <code>CLONE_THREAD</code> does most of the work and does not seem to fit the scheme very well.
The original intention is unclear (even for authors, according to comments in the code) but I think originally there was one threading flag, which was then parcelled among many other flags but this separation was never fully finished.
It is also unclear what this partition is good for as glibc does not use that so only hand-written use of the clone permits a programmer to access this features.</p></div><div class=paragraph><p>For non-threaded programs the PID and TID are the same.
For threaded programs the first thread PID and TID are the same and every created thread shares the same PID and gets assigned a unique TID (because <code>CLONE_THREAD</code> is passed in) also parent is shared for all processes forming this threaded program.</p></div><div class=paragraph><p>The code that implements <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_create&amp;sektion=3&amp;format=html">pthread_create(3)</a> in NPTL defines the clone flags like this:</p></div><div class="literalblock programlisting"><div class=content><pre>int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL

 | CLONE_SETTLS | CLONE_PARENT_SETTID

| CLONE_CHILD_CLEARTID | CLONE_SYSVSEM
#if __ASSUME_NO_CLONE_DETACHED == 0

| CLONE_DETACHED
#endif

| 0);</pre></div></div><div class=paragraph><p>The <code>CLONE_SIGNAL</code> is defined like</p></div><div class="literalblock programlisting"><div class=content><pre>#define CLONE_SIGNAL (CLONE_SIGHAND | CLONE_THREAD)</pre></div></div><div class=paragraph><p>the last 0 means no signal is sent when any of the threads exits.</p></div></div></div></div><div class=sect2><h3 id=what-is-emu>2.5. What is emulation<a class=anchor href=#what-is-emu></a></h3><div class=paragraph><p>According to a dictionary definition, emulation is the ability of a program or device to imitate another program or device.
This is achieved by providing the same reaction to a given stimulus as the emulated object.
In practice, the software world mostly sees three types of emulation - a program used to emulate a machine (QEMU, various game console emulators etc.), software emulation of a hardware facility (OpenGL emulators, floating point units emulation etc.) and operating system emulation (either in kernel of the operating system or as a userspace program).</p></div><div class=paragraph><p>Emulation is usually used in a place, where using the original component is not feasible nor possible at all.
For example someone might want to use a program developed for a different operating system than they use.
Then emulation comes in handy.
Sometimes there is no other way but to use emulation - e.g. when the hardware device you try to use does not exist (yet/anymore) then there is no other way but emulation.
This happens often when porting an operating system to a new (non-existent) platform.
Sometimes it is just cheaper to emulate.</p></div><div class=paragraph><p>Looking from an implementation point of view, there are two main approaches to the implementation of emulation.
You can either emulate the whole thing - accepting possible inputs of the original object, maintaining inner state and emitting correct output based on the state and/or input.
This kind of emulation does not require any special conditions and basically can be implemented anywhere for any device/program.
The drawback is that implementing such emulation is quite difficult, time-consuming and error-prone.
In some cases we can use a simpler approach.
Imagine you want to emulate a printer that prints from left to right on a printer that prints from right to left.
It is obvious that there is no need for a complex emulation layer but simply reversing of the printed text is sufficient.
Sometimes the emulating environment is very similar to the emulated one so just a thin layer of some translation is necessary to provide fully working emulation! As you can see this is much less demanding to implement, so less time-consuming and error-prone than the previous approach.
But the necessary condition is that the two environments must be similar enough.
The third approach combines the two previous.
Most of the time the objects do not provide the same capabilities so in a case of emulating the more powerful one on the less powerful we have to emulate the missing features with full emulation described above.</p></div><div class=paragraph><p>This master thesis deals with emulation of UNIX® on UNIX®, which is exactly the case, where only a thin layer of translation is sufficient to provide full emulation.
The UNIX® API consists of a set of syscalls, which are usually self contained and do not affect some global kernel state.</p></div><div class=paragraph><p>There are a few syscalls that affect inner state but this can be dealt with by providing some structures that maintain the extra state.</p></div><div class=paragraph><p>No emulation is perfect and emulations tend to lack some parts but this usually does not cause any serious drawbacks.
Imagine a game console emulator that emulates everything but music output. No doubt that the games are playable and one can use the emulator.
It might not be that comfortable as the original game console but its an acceptable compromise between price and comfort.</p></div><div class=paragraph><p>The same goes with the UNIX® API.
Most programs can live with a very limited set of syscalls working.
Those syscalls tend to be the oldest ones (<a href="https://man.freebsd.org/cgi/man.cgi?query=read&amp;sektion=2&amp;format=html">read(2)</a>/<a href="https://man.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2&amp;format=html">write(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> family, <a href="https://man.freebsd.org/cgi/man.cgi?query=signal&amp;sektion=3&amp;format=html">signal(3)</a> handling, <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> API) hence it is easy to emulate because their semantics is shared among all UNIX®es, which exist todays.</p></div></div></div></div><div class=sect1><h2 id=freebsd-emulation>3. Emulation<a class=anchor href=#freebsd-emulation></a></h2><div class=sectionbody><div class=sect2><h3 id=_how_emulation_works_in_freebsd>3.1. How emulation works in FreeBSD<a class=anchor href=#_how_emulation_works_in_freebsd></a></h3><div class=paragraph><p>As stated earlier, FreeBSD supports running binaries from several other UNIX®es.
This works because FreeBSD has an abstraction called the execution class loader.
This wedges into the <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> syscall, so when <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> is about to execute a binary it examines its type.</p></div><div class=paragraph><p>There are basically two types of binaries in FreeBSD.
Shell-like text scripts which are identified by <code>#!</code> as their first two characters and normal (typically <em>ELF</em>) binaries, which are a representation of a compiled executable object.
The vast majority (one could say all of them) of binaries in FreeBSD are from type ELF.
ELF files contain a header, which specifies the OS ABI for this ELF file.
By reading this information, the operating system can accurately determine what type of binary the given file is.</p></div><div class=paragraph><p>Every OS ABI must be registered in the FreeBSD kernel.
This applies to the FreeBSD native OS ABI, as well.
So when <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> executes a binary it iterates through the list of registered APIs and when it finds the right one it starts to use the information contained in the OS ABI description (its syscall table, <code>errno</code> translation table, etc.).
So every time the process calls a syscall, it uses its own set of syscalls instead of some global one.
This effectively provides a very elegant and easy way of supporting execution of various binary formats.</p></div><div class=paragraph><p>The nature of emulation of different OSes (and also some other subsystems) led developers to invite a handler event mechanism.
There are various places in the kernel, where a list of event handlers are called.
Every subsystem can register an event handler and they are called accordingly.
For example, when a process exits there is a handler called that possibly cleans up whatever the subsystem needs to be cleaned.</p></div><div class=paragraph><p>Those simple facilities provide basically everything that is needed for the emulation infrastructure and in fact these are basically the only things necessary to implement the Linux® emulation layer.</p></div></div><div class=sect2><h3 id=freebsd-common-primitives>3.2. Common primitives in the FreeBSD kernel<a class=anchor href=#freebsd-common-primitives></a></h3><div class=paragraph><p>Emulation layers need some support from the operating system.
I am going to describe some of the supported primitives in the FreeBSD operating system.</p></div><div class=sect3><h4 id=freebsd-locking-primitives>3.2.1. Locking primitives<a class=anchor href=#freebsd-locking-primitives></a></h4><div class=paragraph><p>Contributed by: <code>Attilio Rao &lt;<a href=mailto:attilio@FreeBSD.org>attilio@FreeBSD.org</a>></code></p></div><div class=paragraph><p>The FreeBSD synchronization primitive set is based on the idea to supply a rather huge number of different primitives in a way that the better one can be used for every particular, appropriate situation.</p></div><div class=paragraph><p>To a high level point of view you can consider three kinds of synchronization primitives in the FreeBSD kernel:</p></div><div class=ulist><ul><li><p>atomic operations and memory barriers</p></li><li><p>locks</p></li><li><p>scheduling barriers</p></li></ul></div><div class=paragraph><p>Below there are descriptions for the 3 families.
For every lock, you should really check the linked manpage (where possible) for more detailed explanations.</p></div><div class=sect4><h5 id=freebsd-atomic-op>3.2.1.1. Atomic operations and memory barriers<a class=anchor href=#freebsd-atomic-op></a></h5><div class=paragraph><p>Atomic operations are implemented through a set of functions performing simple arithmetics on memory operands in an atomic way with respect to external events (interrupts, preemption, etc.).
Atomic operations can guarantee atomicity just on small data types (in the magnitude order of the <code>.long.</code> architecture C data type), so should be rarely used directly in the end-level code, if not only for very simple operations (like flag setting in a bitmap, for example).
In fact, it is rather simple and common to write down a wrong semantic based on just atomic operations (usually referred as lock-less).
The FreeBSD kernel offers a way to perform atomic operations in conjunction with a memory barrier.
The memory barriers will guarantee that an atomic operation will happen following some specified ordering with respect to other memory accesses.
For example, if we need that an atomic operation happen just after all other pending writes (in terms of instructions reordering buffers activities) are completed, we need to explicitly use a memory barrier in conjunction to this atomic operation.
So it is simple to understand why memory barriers play a key role for higher-level locks building (just as refcounts, mutexes, etc.).
For a detailed explanatory on atomic operations, please refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=atomic&amp;sektion=9&amp;format=html">atomic(9)</a>.
It is far, however, noting that atomic operations (and memory barriers as well) should ideally only be used for building front-ending locks (as mutexes).</p></div></div><div class=sect4><h5 id=freebsd-refcounts>3.2.1.2. Refcounts<a class=anchor href=#freebsd-refcounts></a></h5><div class=paragraph><p>Refcounts are interfaces for handling reference counters.
They are implemented through atomic operations and are intended to be used just for cases, where the reference counter is the only one thing to be protected, so even something like a spin-mutex is deprecated.
Using the refcount interface for structures, where a mutex is already used is often wrong since we should probably close the reference counter in some already protected paths.
A manpage discussing refcount does not exist currently, just check <span class=filename>sys/refcount.h</span> for an overview of the existing API.</p></div></div><div class=sect4><h5 id=freebsd-locks>3.2.1.3. Locks<a class=anchor href=#freebsd-locks></a></h5><div class=paragraph><p>FreeBSD kernel has huge classes of locks.
Every lock is defined by some peculiar properties, but probably the most important is the event linked to contesting holders (or in other terms, the behavior of threads unable to acquire the lock).
FreeBSD’s locking scheme presents three different behaviors for contenders:</p></div><div class="olist arabic"><ol class=arabic><li><p>spinning</p></li><li><p>blocking</p></li><li><p>sleeping</p></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>numbers are not casual</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=freebsd-spinlocks>3.2.1.4. Spinning locks<a class=anchor href=#freebsd-spinlocks></a></h5><div class=paragraph><p>Spin locks let waiters to spin until they cannot acquire the lock.
An important matter do deal with is when a thread contests on a spin lock if it is not descheduled.
Since the FreeBSD kernel is preemptive, this exposes spin lock at the risk of deadlocks that can be solved just disabling interrupts while they are acquired.
For this and other reasons (like lack of priority propagation support, poorness in load balancing schemes between CPUs, etc.), spin locks are intended to protect very small paths of code, or ideally not to be used at all if not explicitly requested (explained later).</p></div></div><div class=sect4><h5 id=freebsd-blocking>3.2.1.5. Blocking<a class=anchor href=#freebsd-blocking></a></h5><div class=paragraph><p>Block locks let waiters to be descheduled and blocked until the lock owner does not drop it and wakes up one or more contenders.
To avoid starvation issues, blocking locks do priority propagation from the waiters to the owner.
Block locks must be implemented through the turnstile interface and are intended to be the most used kind of locks in the kernel, if no particular conditions are met.</p></div></div><div class=sect4><h5 id=freebsd-sleeping>3.2.1.6. Sleeping<a class=anchor href=#freebsd-sleeping></a></h5><div class=paragraph><p>Sleep locks let waiters to be descheduled and fall asleep until the lock holder does not drop it and wakes up one or more waiters.
Since sleep locks are intended to protect large paths of code and to cater asynchronous events, they do not do any form of priority propagation.
They must be implemented through the <a href="https://man.freebsd.org/cgi/man.cgi?query=sleepqueue&amp;sektion=9&amp;format=html">sleepqueue(9)</a> interface.</p></div><div class=paragraph><p>The order used to acquire locks is very important, not only for the possibility to deadlock due at lock order reversals, but even because lock acquisition should follow specific rules linked to locks natures.
If you give a look at the table above, the practical rule is that if a thread holds a lock of level n (where the level is the number listed close to the kind of lock) it is not allowed to acquire a lock of superior levels, since this would break the specified semantic for a path.
For example, if a thread holds a block lock (level 2), it is allowed to acquire a spin lock (level 1) but not a sleep lock (level 3), since block locks are intended to protect smaller paths than sleep lock (these rules are not about atomic operations or scheduling barriers, however).</p></div><div class=paragraph><p>This is a list of lock with their respective behaviors:</p></div><div class=ulist><ul><li><p>spin mutex - spinning - <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a></p></li><li><p>sleep mutex - blocking - <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a></p></li><li><p>pool mutex - blocking - <a href="https://man.freebsd.org/cgi/man.cgi?query=mtx&amp;sektion=pool&amp;format=html">mtx(pool)</a></p></li><li><p>sleep family - sleeping - <a href="https://man.freebsd.org/cgi/man.cgi?query=sleep&amp;sektion=9&amp;format=html">sleep(9)</a> pause tsleep msleep msleep spin msleep rw msleep sx</p></li><li><p>condvar - sleeping - <a href="https://man.freebsd.org/cgi/man.cgi?query=condvar&amp;sektion=9&amp;format=html">condvar(9)</a></p></li><li><p>rwlock - blocking - <a href="https://man.freebsd.org/cgi/man.cgi?query=rwlock&amp;sektion=9&amp;format=html">rwlock(9)</a></p></li><li><p>sxlock - sleeping - <a href="https://man.freebsd.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;format=html">sx(9)</a></p></li><li><p>lockmgr - sleeping - <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a></p></li><li><p>semaphores - sleeping - <a href="https://man.freebsd.org/cgi/man.cgi?query=sema&amp;sektion=9&amp;format=html">sema(9)</a></p></li></ul></div><div class=paragraph><p>Among these locks only mutexes, sxlocks, rwlocks and lockmgrs are intended to handle recursion, but currently recursion is only supported by mutexes and lockmgrs.</p></div></div><div class=sect4><h5 id=freebsd-scheduling>3.2.1.7. Scheduling barriers<a class=anchor href=#freebsd-scheduling></a></h5><div class=paragraph><p>Scheduling barriers are intended to be used to drive scheduling of threading.
They consist mainly of three different stubs:</p></div><div class=ulist><ul><li><p>critical sections (and preemption)</p></li><li><p>sched_bind</p></li><li><p>sched_pin</p></li></ul></div><div class=paragraph><p>Generally, these should be used only in a particular context and even if they can often replace locks, they should be avoided because they do not let the diagnose of simple eventual problems with locking debugging tools (as <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a>).</p></div></div><div class=sect4><h5 id=freebsd-critical>3.2.1.8. Critical sections<a class=anchor href=#freebsd-critical></a></h5><div class=paragraph><p>The FreeBSD kernel has been made preemptive basically to deal with interrupt threads.
In fact, to avoid high interrupt latency, time-sharing priority threads can be preempted by interrupt threads (in this way, they do not need to wait to be scheduled as the normal path previews).
Preemption, however, introduces new racing points that need to be handled, as well.
Often, to deal with preemption, the simplest thing to do is to completely disable it.
A critical section defines a piece of code (borderlined by the pair of functions <a href="https://man.freebsd.org/cgi/man.cgi?query=critical_enter&amp;sektion=9&amp;format=html">critical_enter(9)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=critical_exit&amp;sektion=9&amp;format=html">critical_exit(9)</a>, where preemption is guaranteed to not happen (until the protected code is fully executed).
This can often replace a lock effectively but should be used carefully to not lose the whole advantage that preemption brings.</p></div></div><div class=sect4><h5 id=freebsd-schedpin>3.2.1.9. sched_pin/sched_unpin<a class=anchor href=#freebsd-schedpin></a></h5><div class=paragraph><p>Another way to deal with preemption is the <code>sched_pin()</code> interface.
If a piece of code is closed in the <code>sched_pin()</code> and <code>sched_unpin()</code> pair of functions it is guaranteed that the respective thread, even if it can be preempted, it will always be executed on the same CPU.
Pinning is very effective in the particular case when we have to access at per-cpu datas and we assume other threads will not change those data.
The latter condition will determine a critical section as a too strong condition for our code.</p></div></div><div class=sect4><h5 id=freebsd-schedbind>3.2.1.10. sched_bind/sched_unbind<a class=anchor href=#freebsd-schedbind></a></h5><div class=paragraph><p><code>sched_bind</code> is an API used to bind a thread to a particular CPU for all the time it executes the code, until a <code>sched_unbind</code> function call does not unbind it.
This feature has a key role in situations where you cannot trust the current state of CPUs (for example, at very early stages of boot), as you want to avoid your thread to migrate on inactive CPUs.
Since <code>sched_bind</code> and <code>sched_unbind</code> manipulate internal scheduler structures, they need to be enclosed in <code>sched_lock</code> acquisition/releasing when used.</p></div></div></div><div class=sect3><h4 id=freebsd-proc>3.2.2. Proc structure<a class=anchor href=#freebsd-proc></a></h4><div class=paragraph><p>Various emulation layers sometimes require some additional per-process data.
It can manage separate structures (a list, a tree etc.) containing these data for every process but this tends to be slow and memory consuming.
To solve this problem the FreeBSD <code>proc</code> structure contains <code>p_emuldata</code>, which is a void pointer to some emulation layer specific data.
This <code>proc</code> entry is protected by the proc mutex.</p></div><div class=paragraph><p>The FreeBSD <code>proc</code> structure contains a <code>p_sysent</code> entry that identifies, which ABI this process is running.
In fact, it is a pointer to the <code>sysentvec</code> described above.
So by comparing this pointer to the address where the <code>sysentvec</code> structure for the given ABI is stored we can effectively determine whether the process belongs to our emulation layer.
The code typically looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>if (__predict_true(p-&gt;p_sysent != &amp;elf_Linux(R)_sysvec))
	  return;</pre></div></div><div class=paragraph><p>As you can see, we effectively use the <code>__predict_true</code> modifier to collapse the most common case (FreeBSD process) to a simple return operation thus preserving high performance.
This code should be turned into a macro because currently it is not very flexible, i.e. we do not support Linux®64 emulation nor A.OUT Linux® processes on i386.</p></div></div><div class=sect3><h4 id=freebsd-vfs>3.2.3. VFS<a class=anchor href=#freebsd-vfs></a></h4><div class=paragraph><p>The FreeBSD VFS subsystem is very complex but the Linux® emulation layer uses just a small subset via a well defined API.
It can either operate on vnodes or file handlers.
Vnode represents a virtual vnode, i.e. representation of a node in VFS.
Another representation is a file handler, which represents an opened file from the perspective of a process.
A file handler can represent a socket or an ordinary file.
A file handler contains a pointer to its vnode.
More then one file handler can point to the same vnode.</p></div><div class=sect4><h5 id=freebsd-namei>3.2.3.1. namei<a class=anchor href=#freebsd-namei></a></h5><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> routine is a central entry point to pathname lookup and translation.
It traverses the path point by point from the starting point to the end point using lookup function, which is internal to VFS.
The <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> syscall can cope with symlinks, absolute and relative paths.
When a path is looked up using <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> it is inputed to the name cache. This behavior can be suppressed.
This routine is used all over the kernel and its performance is very critical.</p></div></div><div class=sect4><h5 id=freebsd-vn>3.2.3.2. vn_fullpath<a class=anchor href=#freebsd-vn></a></h5><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=vn_fullpath&amp;sektion=9&amp;format=html">vn_fullpath(9)</a> function takes the best effort to traverse VFS name cache and returns a path for a given (locked) vnode.
This process is unreliable but works just fine for the most common cases.
The unreliability is because it relies on VFS cache (it does not traverse the on medium structures), it does not work with hardlinks, etc.
This routine is used in several places in the Linuxulator.</p></div></div><div class=sect4><h5 id=freebsd-vnode>3.2.3.3. Vnode operations<a class=anchor href=#freebsd-vnode></a></h5><div class=ulist><ul><li><p><code>fgetvp</code> - given a thread and a file descriptor number it returns the associated vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vn_lock&amp;sektion=9&amp;format=html">vn_lock(9)</a> - locks a vnode</p></li><li><p><code>vn_unlock</code> - unlocks a vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_READDIR&amp;sektion=9&amp;format=html">VOP_READDIR(9)</a> - reads a directory referenced by a vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_GETATTR&amp;sektion=9&amp;format=html">VOP_GETATTR(9)</a> - gets attributes of a file or a directory referenced by a vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_LOOKUP&amp;sektion=9&amp;format=html">VOP_LOOKUP(9)</a> - looks up a path to a given directory</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_OPEN&amp;sektion=9&amp;format=html">VOP_OPEN(9)</a> - opens a file referenced by a vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_CLOSE&amp;sektion=9&amp;format=html">VOP_CLOSE(9)</a> - closes a file referenced by a vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vput&amp;sektion=9&amp;format=html">vput(9)</a> - decrements the use count for a vnode and unlocks it</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vrele&amp;sektion=9&amp;format=html">vrele(9)</a> - decrements the use count for a vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vref&amp;sektion=9&amp;format=html">vref(9)</a> - increments the use count for a vnode</p></li></ul></div></div><div class=sect4><h5 id=freebsd-file-handler>3.2.3.4. File handler operations<a class=anchor href=#freebsd-file-handler></a></h5><div class=ulist><ul><li><p><code>fget</code> - given a thread and a file descriptor number it returns associated file handler and references it</p></li><li><p><code>fdrop</code> - drops a reference to a file handler</p></li><li><p><code>fhold</code> - references a file handler</p></li></ul></div></div></div></div></div></div><div class=sect1><h2 id=md>4. Linux® emulation layer -MD part<a class=anchor href=#md></a></h2><div class=sectionbody><div class=paragraph><p>This section deals with implementation of Linux® emulation layer in FreeBSD operating system.
It first describes the machine dependent part talking about how and where interaction between userland and kernel is implemented.
It talks about syscalls, signals, ptrace, traps, stack fixup.
This part discusses i386 but it is written generally so other architectures should not differ very much.
The next part is the machine independent part of the Linuxulator.
This section only covers i386 and ELF handling. A.OUT is obsolete and untested.</p></div><div class=sect2><h3 id=syscall-handling>4.1. Syscall handling<a class=anchor href=#syscall-handling></a></h3><div class=paragraph><p>Syscall handling is mostly written in <span class=filename>linux_sysvec.c</span>, which covers most of the routines pointed out in the <code>sysentvec</code> structure.
When a Linux® process running on FreeBSD issues a syscall, the general syscall routine calls linux prepsyscall routine for the Linux® ABI.</p></div><div class=sect3><h4 id=linux-prepsyscall>4.1.1. Linux® prepsyscall<a class=anchor href=#linux-prepsyscall></a></h4><div class=paragraph><p>Linux® passes arguments to syscalls via registers (that is why it is limited to 6 parameters on i386) while FreeBSD uses the stack.
The Linux® prepsyscall routine must copy parameters from registers to the stack.
The order of the registers is: <code>%ebx</code>, <code>%ecx</code>, <code>%edx</code>, <code>%esi</code>, <code>%edi</code>, <code>%ebp</code>.
The catch is that this is true for only <em>most</em> of the syscalls.
Some (most notably <code>clone</code>) uses a different order but it is luckily easy to fix by inserting a dummy parameter in the <code>linux_clone</code> prototype.</p></div></div><div class=sect3><h4 id=syscall-writing>4.1.2. Syscall writing<a class=anchor href=#syscall-writing></a></h4><div class=paragraph><p>Every syscall implemented in the Linuxulator must have its prototype with various flags in <span class=filename>syscalls.master</span>.
The form of the file is:</p></div><div class="literalblock programlisting"><div class=content><pre>...
	AUE_FORK STD		{ int linux_fork(void); }
...
	AUE_CLOSE NOPROTO	{ int close(int fd); }
...</pre></div></div><div class=paragraph><p>The first column represents the syscall number.
The second column is for auditing support.
The third column represents the syscall type.
It is either <code>STD</code>, <code>OBSOL</code>, <code>NOPROTO</code> and <code>UNIMPL</code>.
<code>STD</code> is a standard syscall with full prototype and implementation.
<code>OBSOL</code> is obsolete and defines just the prototype.
<code>NOPROTO</code> means that the syscall is implemented elsewhere so do not prepend ABI prefix, etc.
<code>UNIMPL</code> means that the syscall will be substituted with the <code>nosys</code> syscall (a syscall just printing out a message about the syscall not being implemented and returning <code>ENOSYS</code>).</p></div><div class=paragraph><p>From <span class=filename>syscalls.master</span> a script generates three files: <span class=filename>linux_syscall.h</span>, <span class=filename>linux_proto.h</span> and <span class=filename>linux_sysent.c</span>.
The <span class=filename>linux_syscall.h</span> contains definitions of syscall names and their numerical value, e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>...
#define LINUX_SYS_linux_fork 2
...
#define LINUX_SYS_close 6
...</pre></div></div><div class=paragraph><p>The <span class=filename>linux_proto.h</span> contains structure definitions of arguments to every syscall, e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_fork_args {
  register_t dummy;
};</pre></div></div><div class=paragraph><p>And finally, <span class=filename>linux_sysent.c</span> contains structure describing the system entry table, used to actually dispatch a syscall, e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>{ 0, (sy_call_t *)linux_fork, AUE_FORK, NULL, 0, 0 }, /* 2 = linux_fork */
{ AS(close_args), (sy_call_t *)close, AUE_CLOSE, NULL, 0, 0 }, /* 6 = close */</pre></div></div><div class=paragraph><p>As you can see <code>linux_fork</code> is implemented in Linuxulator itself so the definition is of <code>STD</code> type and has no argument, which is exhibited by the dummy argument structure.
On the other hand <code>close</code> is just an alias for real FreeBSD <a href="https://man.freebsd.org/cgi/man.cgi?query=close&amp;sektion=2&amp;format=html">close(2)</a> so it has no linux arguments structure associated and in the system entry table it is not prefixed with linux as it calls the real <a href="https://man.freebsd.org/cgi/man.cgi?query=close&amp;sektion=2&amp;format=html">close(2)</a> in the kernel.</p></div></div><div class=sect3><h4 id=dummy-syscalls>4.1.3. Dummy syscalls<a class=anchor href=#dummy-syscalls></a></h4><div class=paragraph><p>The Linux® emulation layer is not complete, as some syscalls are not implemented properly and some are not implemented at all.
The emulation layer employs a facility to mark unimplemented syscalls with the <code>DUMMY</code> macro.
These dummy definitions reside in <span class=filename>linux_dummy.c</span> in a form of <code>DUMMY(syscall);</code>, which is then translated to various syscall auxiliary files and the implementation consists of printing a message saying that this syscall is not implemented.
The <code>UNIMPL</code> prototype is not used because we want to be able to identify the name of the syscall that was called to know what syscalls are more important to implement.</p></div></div></div><div class=sect2><h3 id=signal-handling>4.2. Signal handling<a class=anchor href=#signal-handling></a></h3><div class=paragraph><p>Signal handling is done generally in the FreeBSD kernel for all binary compatibilities with a call to a compat-dependent layer.
Linux® compatibility layer defines <code>linux_sendsig</code> routine for this purpose.</p></div><div class=sect3><h4 id=linux-sendsig>4.2.1. Linux® sendsig<a class=anchor href=#linux-sendsig></a></h4><div class=paragraph><p>This routine first checks whether the signal has been installed with a <code>SA_SIGINFO</code> in which case it calls <code>linux_rt_sendsig</code> routine instead.
Furthermore, it allocates (or reuses an already existing) signal handle context, then it builds a list of arguments for the signal handler.
It translates the signal number based on the signal translation table, assigns a handler, translates sigset.
Then it saves context for the <code>sigreturn</code> routine (various registers, translated trap number and signal mask).
Finally, it copies out the signal context to the userspace and prepares context for the actual signal handler to run.</p></div></div><div class=sect3><h4 id=linux-rt-sendsig>4.2.2. linux_rt_sendsig<a class=anchor href=#linux-rt-sendsig></a></h4><div class=paragraph><p>This routine is similar to <code>linux_sendsig</code> just the signal context preparation is different.
It adds <code>siginfo</code>, <code>ucontext</code>, and some POSIX® parts.
It might be worth considering whether those two functions could not be merged with a benefit of less code duplication and possibly even faster execution.</p></div></div><div class=sect3><h4 id=linux-sigreturn>4.2.3. linux_sigreturn<a class=anchor href=#linux-sigreturn></a></h4><div class=paragraph><p>This syscall is used for return from the signal handler.
It does some security checks and restores the original process context.
It also unmasks the signal in process signal mask.</p></div></div></div><div class=sect2><h3 id=ptrace>4.3. Ptrace<a class=anchor href=#ptrace></a></h3><div class=paragraph><p>Many UNIX® derivates implement the <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> syscall to allow various tracking and debugging features.
This facility enables the tracing process to obtain various information about the traced process, like register dumps, any memory from the process address space, etc. and also to trace the process like in stepping an instruction or between system entries (syscalls and traps).
<a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> also lets you set various information in the traced process (registers etc.).
<a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> is a UNIX®-wide standard implemented in most UNIX®es around the world.</p></div><div class=paragraph><p>Linux® emulation in FreeBSD implements the <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> facility in <span class=filename>linux_ptrace.c</span>.
The routines for converting registers between Linux® and FreeBSD and the actual <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> syscall emulation syscall.
The syscall is a long switch block that implements its counterpart in FreeBSD for every <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> command.
The <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> commands are mostly equal between Linux® and FreeBSD so usually just a small modification is needed.
For example, <code>PT_GETREGS</code> in Linux® operates on direct data while FreeBSD uses a pointer to the data so after performing a (native) <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> syscall, a copyout must be done to preserve Linux® semantics.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> implementation in Linuxulator has some known weaknesses.
There have been panics seen when using <code>strace</code> (which is a <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> consumer) in the Linuxulator environment.
Also <code>PT_SYSCALL</code> is not implemented.</p></div></div><div class=sect2><h3 id=traps>4.4. Traps<a class=anchor href=#traps></a></h3><div class=paragraph><p>Whenever a Linux® process running in the emulation layer traps the trap itself is handled transparently with the only exception of the trap translation.
Linux® and FreeBSD differs in opinion on what a trap is so this is dealt with here.
The code is actually very short:</p></div><div class="literalblock programlisting"><div class=content><pre>static int
translate_traps(int signal, int trap_code)
{

  if (signal != SIGBUS)
    return signal;

  switch (trap_code) {

    case T_PROTFLT:
    case T_TSSFLT:
    case T_DOUBLEFLT:
    case T_PAGEFLT:
      return SIGSEGV;

    default:
      return signal;
  }
}</pre></div></div></div><div class=sect2><h3 id=stack-fixup>4.5. Stack fixup<a class=anchor href=#stack-fixup></a></h3><div class=paragraph><p>The RTLD run-time link-editor expects so called AUX tags on stack during an <code>execve</code> so a fixup must be done to ensure this.
Of course, every RTLD system is different so the emulation layer must provide its own stack fixup routine to do this.
So does Linuxulator.
The <code>elf_linux_fixup</code> simply copies out AUX tags to the stack and adjusts the stack of the user space process to point right after those tags.
So RTLD works in a smart way.</p></div></div><div class=sect2><h3 id=aout-support>4.6. A.OUT support<a class=anchor href=#aout-support></a></h3><div class=paragraph><p>The Linux® emulation layer on i386 also supports Linux® A.OUT binaries.
Pretty much everything described in the previous sections must be implemented for A.OUT support (beside traps translation and signals sending).
The support for A.OUT binaries is no longer maintained, especially the 2.6 emulation does not work with it but this does not cause any problem, as the linux-base in ports probably do not support A.OUT binaries at all.
This support will probably be removed in future.
Most of the stuff necessary for loading Linux® A.OUT binaries is in <span class=filename>imgact_linux.c</span> file.</p></div></div></div></div><div class=sect1><h2 id=mi>5. Linux® emulation layer -MI part<a class=anchor href=#mi></a></h2><div class=sectionbody><div class=paragraph><p>This section talks about machine independent part of the Linuxulator.
It covers the emulation infrastructure needed for Linux® 2.6 emulation, the thread local storage (TLS) implementation (on i386) and futexes.
Then we talk briefly about some syscalls.</p></div><div class=sect2><h3 id=nptl-desc>5.1. Description of NPTL<a class=anchor href=#nptl-desc></a></h3><div class=paragraph><p>One of the major areas of progress in development of Linux® 2.6 was threading.
Prior to 2.6, the Linux® threading support was implemented in the linuxthreads library.
The library was a partial implementation of POSIX® threading.
The threading was implemented using separate processes for each thread using the <code>clone</code> syscall to let them share the address space (and other things).
The main weaknesses of this approach was that every thread had a different PID, signal handling was broken (from the pthreads perspective), etc.
Also the performance was not very good (use of <code>SIGUSR</code> signals for threads synchronization, kernel resource consumption, etc.) so to overcome these problems a new threading system was developed and named NPTL.</p></div><div class=paragraph><p>The NPTL library focused on two things but a third thing came along so it is usually considered a part of NPTL.
Those two things were embedding of threads into a process structure and futexes.
The additional third thing was TLS, which is not directly required by NPTL but the whole NPTL userland library depends on it.
Those improvements yielded in much improved performance and standards conformance.
NPTL is a standard threading library in Linux® systems these days.</p></div><div class=paragraph><p>The FreeBSD Linuxulator implementation approaches the NPTL in three main areas.
The TLS, futexes and PID mangling, which is meant to simulate the Linux® threads.
Further sections describe each of these areas.</p></div></div><div class=sect2><h3 id=linux26-emu>5.2. Linux® 2.6 emulation infrastructure<a class=anchor href=#linux26-emu></a></h3><div class=paragraph><p>These sections deal with the way Linux® threads are managed and how we simulate that in FreeBSD.</p></div><div class=sect3><h4 id=linux26-runtime>5.2.1. Runtime determining of 2.6 emulation<a class=anchor href=#linux26-runtime></a></h4><div class=paragraph><p>The Linux® emulation layer in FreeBSD supports runtime setting of the emulated version.
This is done via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>, namely <code>compat.linux.osrelease</code>.
Setting this <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> affects runtime behavior of the emulation layer.
When set to 2.6.x it sets the value of <code>linux_use_linux26</code> while setting to something else keeps it unset.
This variable (plus per-prison variables of the very same kind) determines whether 2.6 infrastructure (mainly PID mangling) is used in the code or not.
The version setting is done system-wide and this affects all Linux® processes.
The <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> should not be changed when running any Linux® binary as it might harm things.</p></div></div><div class=sect3><h4 id=linux-proc-thread>5.2.2. Linux® processes and thread identifiers<a class=anchor href=#linux-proc-thread></a></h4><div class=paragraph><p>The semantics of Linux® threading are a little confusing and uses entirely different nomenclature to FreeBSD.
A process in Linux® consists of a <code>struct task</code> embedding two identifier fields - PID and TGID.
PID is <em>not</em> a process ID but it is a thread ID.
The TGID identifies a thread group in other words a process.
For single-threaded process the PID equals the TGID.</p></div><div class=paragraph><p>The thread in NPTL is just an ordinary process that happens to have TGID not equal to PID and have a group leader not equal to itself (and shared VM etc. of course).
Everything else happens in the same way as to an ordinary process.
There is no separation of a shared status to some external structure like in FreeBSD.
This creates some duplication of information and possible data inconsistency.
The Linux® kernel seems to use task → group information in some places and task information elsewhere and it is really not very consistent and looks error-prone.</p></div><div class=paragraph><p>Every NPTL thread is created by a call to the <code>clone</code> syscall with a specific set of flags (more in the next subsection).
The NPTL implements strict 1:1 threading.</p></div><div class=paragraph><p>In FreeBSD we emulate NPTL threads with ordinary FreeBSD processes that share VM space, etc. and the PID gymnastic is just mimicked in the emulation specific structure attached to the process. The structure attached to the process looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_emuldata {
  pid_t pid;

  int *child_set_tid; /* in clone(): Child.s TID to set on clone */
  int *child_clear_tid;/* in clone(): Child.s TID to clear on exit */

  struct linux_emuldata_shared *shared;

  int pdeath_signal; /* parent death signal */

  LIST_ENTRY(linux_emuldata) threads; /* list of linux threads */
};</pre></div></div><div class=paragraph><p>The PID is used to identify the FreeBSD process that attaches this structure.
The <code>child_se_tid</code> and <code>child_clear_tid</code> are used for TID address copyout when a process exits and is created.
The <code>shared</code> pointer points to a structure shared among threads.
The <code>pdeath_signal</code> variable identifies the parent death signal and the <code>threads</code> pointer is used to link this structure to the list of threads.
The <code>linux_emuldata_shared</code> structure looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_emuldata_shared {

  int refs;

  pid_t group_pid;

  LIST_HEAD(, linux_emuldata) threads; /* head of list of linux threads */
};</pre></div></div><div class=paragraph><p>The <code>refs</code> is a reference counter being used to determine when we can free the structure to avoid memory leaks.
The <code>group_pid</code> is to identify PID ( = TGID) of the whole process ( = thread group).
The <code>threads</code> pointer is the head of the list of threads in the process.</p></div><div class=paragraph><p>The <code>linux_emuldata</code> structure can be obtained from the process using <code>em_find</code>.
The prototype of the function is:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_emuldata *em_find(struct proc *, int locked);</pre></div></div><div class=paragraph><p>Here, <code>proc</code> is the process we want the emuldata structure from and the locked parameter determines whether we want to lock or not.
The accepted values are <code>EMUL_DOLOCK</code> and <code>EMUL_DOUNLOCK</code>.
More about locking later.</p></div></div><div class=sect3><h4 id=pid-mangling>5.2.3. PID mangling<a class=anchor href=#pid-mangling></a></h4><div class=paragraph><p>As there is a difference in view as what to the idea of a process ID and thread ID is between FreeBSD and Linux® we have to translate the view somehow.
We do it by PID mangling.
This means that we fake what a PID (=TGID) and TID (=PID) is between kernel and userland.
The rule of thumb is that in kernel (in Linuxulator) PID = PID and TGID = shared → group pid and to userland we present <code>PID = shared → group_pid</code> and <code>TID = proc → p_pid</code>.
The PID member of <code>linux_emuldata structure</code> is a FreeBSD PID.</p></div><div class=paragraph><p>The above affects mainly getpid, getppid, gettid syscalls.
Where we use PID/TGID respectively.
In copyout of TIDs in <code>child_clear_tid</code> and <code>child_set_tid</code> we copy out FreeBSD PID.</p></div></div><div class=sect3><h4 id=clone-syscall>5.2.4. Clone syscall<a class=anchor href=#clone-syscall></a></h4><div class=paragraph><p>The <code>clone</code> syscall is the way threads are created in Linux®.
The syscall prototype looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>int linux_clone(l_int flags, void *stack, void *parent_tidptr, int dummy,
void * child_tidptr);</pre></div></div><div class=paragraph><p>The <code>flags</code> parameter tells the syscall how exactly the processes should be cloned.
As described above, Linux® can create processes sharing various things independently, for example two processes can share file descriptors but not VM, etc.
Last byte of the <code>flags</code> parameter is the exit signal of the newly created process.
The <code>stack</code> parameter if non-<code>NULL</code> tells, where the thread stack is and if it is <code>NULL</code> we are supposed to copy-on-write the calling process stack (i.e. do what normal <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> routine does).
The <code>parent_tidptr</code> parameter is used as an address for copying out process PID (i.e. thread id) once the process is sufficiently instantiated but is not runnable yet.
The <code>dummy</code> parameter is here because of the very strange calling convention of this syscall on i386.
It uses the registers directly and does not let the compiler do it what results in the need of a dummy syscall.
The <code>child_tidptr</code> parameter is used as an address for copying out PID once the process has finished forking and when the process exits.</p></div><div class=paragraph><p>The syscall itself proceeds by setting corresponding flags depending on the flags passed in.
For example, <code>CLONE_VM</code> maps to RFMEM (sharing of VM), etc.
The only nit here is <code>CLONE_FS</code> and <code>CLONE_FILES</code> because FreeBSD does not allow setting this separately so we fake it by not setting RFFDG (copying of fd table and other fs information) if either of these is defined.
This does not cause any problems, because those flags are always set together.
After setting the flags the process is forked using the internal <code>fork1</code> routine, the process is instrumented not to be put on a run queue, i.e. not to be set runnable.
After the forking is done we possibly reparent the newly created process to emulate <code>CLONE_PARENT</code> semantics.
Next part is creating the emulation data.
Threads in Linux® does not signal their parents so we set exit signal to be 0 to disable this.
After that setting of <code>child_set_tid</code> and <code>child_clear_tid</code> is performed enabling the functionality later in the code.
At this point we copy out the PID to the address specified by <code>parent_tidptr</code>.
The setting of process stack is done by simply rewriting thread frame <code>%esp</code> register (<code>%rsp</code> on amd64).
Next part is setting up TLS for the newly created process.
After this <a href="https://man.freebsd.org/cgi/man.cgi?query=vfork&amp;sektion=2&amp;format=html">vfork(2)</a> semantics might be emulated and finally the newly created process is put on a run queue and copying out its PID to the parent process via <code>clone</code> return value is done.</p></div><div class=paragraph><p>The <code>clone</code> syscall is able and in fact is used for emulating classic <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=vfork&amp;sektion=2&amp;format=html">vfork(2)</a> syscalls.
Newer glibc in a case of 2.6 kernel uses <code>clone</code> to implement <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=vfork&amp;sektion=2&amp;format=html">vfork(2)</a> syscalls.</p></div></div><div class=sect3><h4 id=locking>5.2.5. Locking<a class=anchor href=#locking></a></h4><div class=paragraph><p>The locking is implemented to be per-subsystem because we do not expect a lot of contention on these.
There are two locks: <code>emul_lock</code> used to protect manipulating of <code>linux_emuldata</code> and <code>emul_shared_lock</code> used to manipulate <code>linux_emuldata_shared</code>.
The <code>emul_lock</code> is a nonsleepable blocking mutex while <code>emul_shared_lock</code> is a sleepable blocking <code>sx_lock</code>.
Due to of the per-subsystem locking we can coalesce some locks and that is why the em find offers the non-locking access.</p></div></div></div><div class=sect2><h3 id=tls>5.3. TLS<a class=anchor href=#tls></a></h3><div class=paragraph><p>This section deals with TLS also known as thread local storage.</p></div><div class=sect3><h4 id=trheading-intro>5.3.1. Introduction to threading<a class=anchor href=#trheading-intro></a></h4><div class=paragraph><p>Threads in computer science are entities within a process that can be scheduled independently from each other.
The threads in the process share process wide data (file descriptors, etc.) but also have their own stack for their own data.
Sometimes there is a need for process-wide data specific to a given thread.
Imagine a name of the thread in execution or something like that.
The traditional UNIX® threading API, pthreads provides a way to do it via <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_key_create&amp;sektion=3&amp;format=html">pthread_key_create(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_setspecific&amp;sektion=3&amp;format=html">pthread_setspecific(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_getspecific&amp;sektion=3&amp;format=html">pthread_getspecific(3)</a> where a thread can create a key to the thread local data and using <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_getspecific&amp;sektion=3&amp;format=html">pthread_getspecific(3)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_getspecific&amp;sektion=3&amp;format=html">pthread_getspecific(3)</a> to manipulate those data.
You can easily see that this is not the most comfortable way this could be accomplished.
So various producers of C/C++ compilers introduced a better way.
They defined a new modifier keyword thread that specifies that a variable is thread specific.
A new method of accessing such variables was developed as well (at least on i386).
The pthreads method tends to be implemented in userspace as a trivial lookup table.
The performance of such a solution is not very good.
So the new method uses (on i386) segment registers to address a segment, where TLS area is stored so the actual accessing of a thread variable is just appending the segment register to the address thus addressing via it.
The segment registers are usually <code>%gs</code> and <code>%fs</code> acting like segment selectors.
Every thread has its own area where the thread local data are stored and the segment must be loaded on every context switch.
This method is very fast and used almost exclusively in the whole i386 UNIX® world.
Both FreeBSD and Linux® implement this approach and it yields very good results.
The only drawback is the need to reload the segment on every context switch which can slowdown context switches.
FreeBSD tries to avoid this overhead by using only 1 segment descriptor for this while Linux® uses 3.
Interesting thing is that almost nothing uses more than 1 descriptor (only Wine seems to use 2) so Linux® pays this unnecessary price for context switches.</p></div></div><div class=sect3><h4 id=i386-segs>5.3.2. Segments on i386<a class=anchor href=#i386-segs></a></h4><div class=paragraph><p>The i386 architecture implements the so called segments.
A segment is a description of an area of memory.
The base address (bottom) of the memory area, the end of it (ceiling), type, protection, etc.
The memory described by a segment can be accessed using segment selector registers (<code>%cs</code>, <code>%ds</code>, <code>%ss</code>, <code>%es</code>, <code>%fs</code>, <code>%gs</code>).
For example let us suppose we have a segment which base address is 0x1234 and length and this code:</p></div><div class="literalblock programlisting"><div class=content><pre>mov %edx,%gs:0x10</pre></div></div><div class=paragraph><p>This will load the content of the <code>%edx</code> register into memory location 0x1244.
Some segment registers have a special use, for example <code>%cs</code> is used for code segment and <code>%ss</code> is used for stack segment but <code>%fs</code> and <code>%gs</code> are generally unused.
Segments are either stored in a global GDT table or in a local LDT table.
LDT is accessed via an entry in the GDT.
The LDT can store more types of segments.
LDT can be per process.
Both tables define up to 8191 entries.</p></div></div><div class=sect3><h4 id=linux-i386>5.3.3. Implementation on Linux® i386<a class=anchor href=#linux-i386></a></h4><div class=paragraph><p>There are two main ways of setting up TLS in Linux®.
It can be set when cloning a process using the <code>clone</code> syscall or it can call <code>set_thread_area</code>.
When a process passes <code>CLONE_SETTLS</code> flag to <code>clone</code>, the kernel expects the memory pointed to by the <code>%esi</code> register a Linux® user space representation of a segment, which gets translated to the machine representation of a segment and loaded into a GDT slot.
The GDT slot can be specified with a number or -1 can be used meaning that the system itself should choose the first free slot.
In practice, the vast majority of programs use only one TLS entry and does not care about the number of the entry.
We exploit this in the emulation and in fact depend on it.</p></div></div><div class=sect3><h4 id=tls-emu>5.3.4. Emulation of Linux® TLS<a class=anchor href=#tls-emu></a></h4><div class=sect4><h5 id=tls-i386>5.3.4.1. i386<a class=anchor href=#tls-i386></a></h5><div class=paragraph><p>Loading of TLS for the current thread happens by calling <code>set_thread_area</code> while loading TLS for a second process in <code>clone</code> is done in the separate block in <code>clone</code>.
Those two functions are very similar.
The only difference being the actual loading of the GDT segment, which happens on the next context switch for the newly created process while <code>set_thread_area</code> must load this directly.
The code basically does this.
It copies the Linux® form segment descriptor from the userland.
The code checks for the number of the descriptor but because this differs between FreeBSD and Linux® we fake it a little.
We only support indexes of 6, 3 and -1.
The 6 is genuine Linux® number, 3 is genuine FreeBSD one and -1 means autoselection.
Then we set the descriptor number to constant 3 and copy out this to the userspace.
We rely on the userspace process using the number from the descriptor but this works most of the time (have never seen a case where this did not work) as the userspace process typically passes in 1.
Then we convert the descriptor from the Linux® form to a machine dependant form (i.e. operating system independent form) and copy this to the FreeBSD defined segment descriptor.
Finally we can load it.
We assign the descriptor to threads PCB (process control block) and load the <code>%gs</code> segment using <code>load_gs</code>.
This loading must be done in a critical section so that nothing can interrupt us.
The <code>CLONE_SETTLS</code> case works exactly like this just the loading using <code>load_gs</code> is not performed.
The segment used for this (segment number 3) is shared for this use between FreeBSD processes and Linux® processes so the Linux® emulation layer does not add any overhead over plain FreeBSD.</p></div></div><div class=sect4><h5 id=tls-amd64>5.3.4.2. amd64<a class=anchor href=#tls-amd64></a></h5><div class=paragraph><p>The amd64 implementation is similar to the i386 one but there was initially no 32bit segment descriptor used for this purpose (hence not even native 32bit TLS users worked) so we had to add such a segment and implement its loading on every context switch (when a flag signaling use of 32bit is set).
Apart from this the TLS loading is exactly the same just the segment numbers are different and the descriptor format and the loading differs slightly.</p></div></div></div></div><div class=sect2><h3 id=futexes>5.4. Futexes<a class=anchor href=#futexes></a></h3><div class=sect3><h4 id=sync-intro>5.4.1. Introduction to synchronization<a class=anchor href=#sync-intro></a></h4><div class=paragraph><p>Threads need some kind of synchronization and POSIX® provides some of them: mutexes for mutual exclusion, read-write locks for mutual exclusion with biased ratio of reads and writes and condition variables for signaling a status change.
It is interesting to note that POSIX® threading API lacks support for semaphores.
Those synchronization routines implementations are heavily dependant on the type threading support we have.
In pure 1:M (userspace) model the implementation can be solely done in userspace and thus be very fast (the condition variables will probably end up being implemented using signals, i.e. not fast) and simple.
In 1:1 model, the situation is also quite clear - the threads must be synchronized using kernel facilities (which is very slow because a syscall must be performed).
The mixed M:N scenario just combines the first and second approach or rely solely on kernel.
Threads synchronization is a vital part of thread-enabled programming and its performance can affect resulting program a lot.
Recent benchmarks on FreeBSD operating system showed that an improved sx_lock implementation yielded 40% speedup in <em>ZFS</em> (a heavy sx user), this is in-kernel stuff but it shows clearly how important the performance of synchronization primitives is.</p></div><div class=paragraph><p>Threaded programs should be written with as little contention on locks as possible.
Otherwise, instead of doing useful work the thread just waits on a lock.
As a result of this, the most well written threaded programs show little locks contention.</p></div></div><div class=sect3><h4 id=futex-intro>5.4.2. Futexes introduction<a class=anchor href=#futex-intro></a></h4><div class=paragraph><p>Linux® implements 1:1 threading, i.e. it has to use in-kernel synchronization primitives.
As stated earlier, well written threaded programs have little lock contention.
So a typical sequence could be performed as two atomic increase/decrease mutex reference counter, which is very fast, as presented by the following example:</p></div><div class="literalblock programlisting"><div class=content><pre>pthread_mutex_lock(&amp;mutex);
...
pthread_mutex_unlock(&amp;mutex);</pre></div></div><div class=paragraph><p>1:1 threading forces us to perform two syscalls for those mutex calls, which is very slow.</p></div><div class=paragraph><p>The solution Linux® 2.6 implements is called futexes.
Futexes implement the check for contention in userspace and call kernel primitives only in a case of contention.
Thus the typical case takes place without any kernel intervention.
This yields reasonably fast and flexible synchronization primitives implementation.</p></div></div><div class=sect3><h4 id=futex-api>5.4.3. Futex API<a class=anchor href=#futex-api></a></h4><div class=paragraph><p>The futex syscall looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>int futex(void *uaddr, int op, int val, struct timespec *timeout, void *uaddr2, int val3);</pre></div></div><div class=paragraph><p>In this example <code>uaddr</code> is an address of the mutex in userspace, <code>op</code> is an operation we are about to perform and the other parameters have per-operation meaning.</p></div><div class=paragraph><p>Futexes implement the following operations:</p></div><div class=ulist><ul><li><p><code>FUTEX_WAIT</code></p></li><li><p><code>FUTEX_WAKE</code></p></li><li><p><code>FUTEX_FD</code></p></li><li><p><code>FUTEX_REQUEUE</code></p></li><li><p><code>FUTEX_CMP_REQUEUE</code></p></li><li><p><code>FUTEX_WAKE_OP</code></p></li></ul></div><div class=sect4><h5 id=futex-wait>5.4.3.1. FUTEX_WAIT<a class=anchor href=#futex-wait></a></h5><div class=paragraph><p>This operation verifies that on address <code>uaddr</code> the value <code>val</code> is written.
If not, <code>EWOULDBLOCK</code> is returned, otherwise the thread is queued on the futex and gets suspended.
If the argument <code>timeout</code> is non-zero it specifies the maximum time for the sleeping, otherwise the sleeping is infinite.</p></div></div><div class=sect4><h5 id=futex-wake>5.4.3.2. FUTEX_WAKE<a class=anchor href=#futex-wake></a></h5><div class=paragraph><p>This operation takes a futex at <code>uaddr</code> and wakes up <code>val</code> first futexes queued on this futex.</p></div></div><div class=sect4><h5 id=futex-fd>5.4.3.3. FUTEX_FD<a class=anchor href=#futex-fd></a></h5><div class=paragraph><p>This operations associates a file descriptor with a given futex.</p></div></div><div class=sect4><h5 id=futex-requeue>5.4.3.4. FUTEX_REQUEUE<a class=anchor href=#futex-requeue></a></h5><div class=paragraph><p>This operation takes <code>val</code> threads queued on futex at <code>uaddr</code>, wakes them up, and takes <code>val2</code> next threads and requeues them on futex at <code>uaddr2</code>.</p></div></div><div class=sect4><h5 id=futex-cmp-requeue>5.4.3.5. FUTEX_CMP_REQUEUE<a class=anchor href=#futex-cmp-requeue></a></h5><div class=paragraph><p>This operation does the same as <code>FUTEX_REQUEUE</code> but it checks that <code>val3</code> equals to <code>val</code> first.</p></div></div><div class=sect4><h5 id=futex-wake-op>5.4.3.6. FUTEX_WAKE_OP<a class=anchor href=#futex-wake-op></a></h5><div class=paragraph><p>This operation performs an atomic operation on <code>val3</code> (which contains coded some other value) and <code>uaddr</code>.
Then it wakes up <code>val</code> threads on futex at <code>uaddr</code> and if the atomic operation returned a positive number it wakes up <code>val2</code> threads on futex at <code>uaddr2</code>.</p></div><div class=paragraph><p>The operations implemented in <code>FUTEX_WAKE_OP</code>:</p></div><div class=ulist><ul><li><p><code>FUTEX_OP_SET</code></p></li><li><p><code>FUTEX_OP_ADD</code></p></li><li><p><code>FUTEX_OP_OR</code></p></li><li><p><code>FUTEX_OP_AND</code></p></li><li><p><code>FUTEX_OP_XOR</code></p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>There is no <code>val2</code> parameter in the futex prototype.
The <code>val2</code> is taken from the <code>struct timespec *timeout</code> parameter for operations <code>FUTEX_REQUEUE</code>, <code>FUTEX_CMP_REQUEUE</code> and <code>FUTEX_WAKE_OP</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=futex-emu>5.4.4. Futex emulation in FreeBSD<a class=anchor href=#futex-emu></a></h4><div class=paragraph><p>The futex emulation in FreeBSD is taken from NetBSD and further extended by us.
It is placed in <code>linux_futex.c</code> and <span class=filename>linux_futex.h</span> files.
The <code>futex</code> structure looks like:</p></div><div class="literalblock programlisting"><div class=content><pre>struct futex {
  void *f_uaddr;
  int f_refcount;

  LIST_ENTRY(futex) f_list;

  TAILQ_HEAD(lf_waiting_paroc, waiting_proc) f_waiting_proc;
};</pre></div></div><div class=paragraph><p>And the structure <code>waiting_proc</code> is:</p></div><div class="literalblock programlisting"><div class=content><pre>struct waiting_proc {

  struct thread *wp_t;

  struct futex *wp_new_futex;

  TAILQ_ENTRY(waiting_proc) wp_list;
};</pre></div></div><div class=sect4><h5 id=futex-get>5.4.4.1. futex_get / futex_put<a class=anchor href=#futex-get></a></h5><div class=paragraph><p>A futex is obtained using the <code>futex_get</code> function, which searches a linear list of futexes and returns the found one or creates a new futex.
When releasing a futex from the use we call the <code>futex_put</code> function, which decreases a reference counter of the futex and if the refcount reaches zero it is released.</p></div></div><div class=sect4><h5 id=futex-sleep>5.4.4.2. futex_sleep<a class=anchor href=#futex-sleep></a></h5><div class=paragraph><p>When a futex queues a thread for sleeping it creates a <code>working_proc</code> structure and puts this structure to the list inside the futex structure then it just performs a <a href="https://man.freebsd.org/cgi/man.cgi?query=tsleep&amp;sektion=9&amp;format=html">tsleep(9)</a> to suspend the thread.
The sleep can be timed out.
After <a href="https://man.freebsd.org/cgi/man.cgi?query=tsleep&amp;sektion=9&amp;format=html">tsleep(9)</a> returns (the thread was woken up or it timed out) the <code>working_proc</code> structure is removed from the list and is destroyed.
All this is done in the <code>futex_sleep</code> function.
If we got woken up from <code>futex_wake</code> we have <code>wp_new_futex</code> set so we sleep on it.
This way the actual requeueing is done in this function.</p></div></div><div class=sect4><h5 id=futex-wake-2>5.4.4.3. futex_wake<a class=anchor href=#futex-wake-2></a></h5><div class=paragraph><p>Waking up a thread sleeping on a futex is performed in the <code>futex_wake</code> function.
First in this function we mimic the strange Linux® behavior, where it wakes up N threads for all operations, the only exception is that the REQUEUE operations are performed on N+1 threads.
But this usually does not make any difference as we are waking up all threads.
Next in the function in the loop we wake up n threads, after this we check if there is a new futex for requeueing.
If so, we requeue up to n2 threads on the new futex.
This cooperates with <code>futex_sleep</code>.</p></div></div><div class=sect4><h5 id=futex-wake-op-2>5.4.4.4. futex_wake_op<a class=anchor href=#futex-wake-op-2></a></h5><div class=paragraph><p>The <code>FUTEX_WAKE_OP</code> operation is quite complicated.
First we obtain two futexes at addresses <code>uaddr</code> and <code>uaddr2</code> then we perform the atomic operation using <code>val3</code> and <code>uaddr2</code>.
Then <code>val</code> waiters on the first futex is woken up and if the atomic operation condition holds we wake up <code>val2</code> (i.e. <code>timeout</code>) waiter on the second futex.</p></div></div><div class=sect4><h5 id=futex-atomic-op>5.4.4.5. futex atomic operation<a class=anchor href=#futex-atomic-op></a></h5><div class=paragraph><p>The atomic operation takes two parameters <code>encoded_op</code> and <code>uaddr</code>.
The encoded operation encodes the operation itself, comparing value, operation argument, and comparing argument.
The pseudocode for the operation is like this one:</p></div><div class="literalblock programlisting"><div class=content><pre>oldval = *uaddr2
*uaddr2 = oldval OP oparg</pre></div></div><div class=paragraph><p>And this is done atomically. First a copying in of the number at <code>uaddr</code> is performed and the operation is done.
The code handles page faults and if no page fault occurs <code>oldval</code> is compared to <code>cmparg</code> argument with cmp comparator.</p></div></div><div class=sect4><h5 id=futex-locking>5.4.4.6. Futex locking<a class=anchor href=#futex-locking></a></h5><div class=paragraph><p>Futex implementation uses two lock lists protecting <code>sx_lock</code> and global locks (either Giant or another <code>sx_lock</code>).
Every operation is performed locked from the start to the very end.</p></div></div></div></div><div class=sect2><h3 id=syscall-impl>5.5. Various syscalls implementation<a class=anchor href=#syscall-impl></a></h3><div class=paragraph><p>In this section I am going to describe some smaller syscalls that are worth mentioning because their implementation is not obvious or those syscalls are interesting from other point of view.</p></div><div class=sect3><h4 id=syscall-at>5.5.1. *at family of syscalls<a class=anchor href=#syscall-at></a></h4><div class=paragraph><p>During development of Linux® 2.6.16 kernel, the *at syscalls were added.
Those syscalls (<code>openat</code> for example) work exactly like their at-less counterparts with the slight exception of the <code>dirfd</code> parameter.
This parameter changes where the given file, on which the syscall is to be performed, is.
When the <code>filename</code> parameter is absolute <code>dirfd</code> is ignored but when the path to the file is relative, it comes to the play.
The <code>dirfd</code> parameter is a directory relative to which the relative pathname is checked.
The <code>dirfd</code> parameter is a file descriptor of some directory or <code>AT_FDCWD</code>.
So for example the <code>openat</code> syscall can be like this:</p></div><div class="literalblock programlisting"><div class=content><pre>file descriptor 123 = /tmp/foo/, current working directory = /tmp/

openat(123, /tmp/bah\, flags, mode)	/* opens /tmp/bah */
openat(123, bah\, flags, mode)		/* opens /tmp/foo/bah */
openat(AT_FDWCWD, bah\, flags, mode)	/* opens /tmp/bah */
openat(stdio, bah\, flags, mode)	/* returns error because stdio is not a directory */</pre></div></div><div class=paragraph><p>This infrastructure is necessary to avoid races when opening files outside the working directory.
Imagine that a process consists of two threads, thread A and thread B.
Thread A issues <code>open(./tmp/foo/bah., flags, mode)</code> and before returning it gets preempted and thread B runs.
Thread B does not care about the needs of thread A and renames or removes <span class=filename>/tmp/foo/</span>.
We got a race.
To avoid this we can open <span class=filename>/tmp/foo</span> and use it as <code>dirfd</code> for <code>openat</code> syscall.
This also enables user to implement per-thread working directories.</p></div><div class=paragraph><p>Linux® family of *at syscalls contains: <code>linux_openat</code>, <code>linux_mkdirat</code>, <code>linux_mknodat</code>, <code>linux_fchownat</code>, <code>linux_futimesat</code>, <code>linux_fstatat64</code>, <code>linux_unlinkat</code>, <code>linux_renameat</code>, <code>linux_linkat</code>, <code>linux_symlinkat</code>, <code>linux_readlinkat</code>, <code>linux_fchmodat</code> and <code>linux_faccessat</code>.
All these are implemented using the modified <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> routine and simple wrapping layer.</p></div><div class=sect4><h5 id=implementation>5.5.1.1. Implementation<a class=anchor href=#implementation></a></h5><div class=paragraph><p>The implementation is done by altering the <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> routine (described above) to take additional parameter <code>dirfd</code> in its <code>nameidata</code> structure, which specifies the starting point of the pathname lookup instead of using the current working directory every time.
The resolution of <code>dirfd</code> from file descriptor number to a vnode is done in native *at syscalls.
When <code>dirfd</code> is <code>AT_FDCWD</code> the <code>dvp</code> entry in <code>nameidata</code> structure is <code>NULL</code> but when <code>dirfd</code> is a different number we obtain a file for this file descriptor, check whether this file is valid and if there is vnode attached to it then we get a vnode. Then we check this vnode for being a directory.
In the actual <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> routine we simply substitute the <code>dvp</code> vnode for <code>dp</code> variable in the <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> function, which determines the starting point.
The <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> is not used directly but via a trace of different functions on various levels.
For example the <code>openat</code> goes like this:</p></div><div class="literalblock programlisting"><div class=content><pre>openat() --&gt; kern_openat() --&gt; vn_open() -&gt; namei()</pre></div></div><div class=paragraph><p>For this reason <code>kern_open</code> and <code>vn_open</code> must be altered to incorporate the additional <code>dirfd</code> parameter.
No compat layer is created for those because there are not many users of this and the users can be easily converted.
This general implementation enables FreeBSD to implement their own *at syscalls.
This is being discussed right now.</p></div></div></div><div class=sect3><h4 id=ioctl>5.5.2. Ioctl<a class=anchor href=#ioctl></a></h4><div class=paragraph><p>The ioctl interface is quite fragile due to its generality.
We have to bear in mind that devices differ between Linux® and FreeBSD so some care must be applied to do ioctl emulation work right.
The ioctl handling is implemented in <span class=filename>linux_ioctl.c</span>, where <code>linux_ioctl</code> function is defined.
This function simply iterates over sets of ioctl handlers to find a handler that implements a given command.
The ioctl syscall has three parameters, the file descriptor, command and an argument.
The command is a 16-bit number, which in theory is divided into high 8 bits determining class of the ioctl command and low 8 bits, which are the actual command within the given set.
The emulation takes advantage of this division.
We implement handlers for each set, like <code>sound_handler</code> or <code>disk_handler</code>.
Each handler has a maximum command and a minimum command defined, which is used for determining what handler is used.
There are slight problems with this approach because Linux® does not use the set division consistently so sometimes ioctls for a different set are inside a set they should not belong to (SCSI generic ioctls inside cdrom set, etc.).
FreeBSD currently does not implement many Linux® ioctls (compared to NetBSD, for example) but the plan is to port those from NetBSD.
The trend is to use Linux® ioctls even in the native FreeBSD drivers because of the easy porting of applications.</p></div></div><div class=sect3><h4 id=debugging>5.5.3. Debugging<a class=anchor href=#debugging></a></h4><div class=paragraph><p>Every syscall should be debuggable.
For this purpose we introduce a small infrastructure.
We have the ldebug facility, which tells whether a given syscall should be debugged (settable via a sysctl).
For printing we have LMSG and ARGS macros.
Those are used for altering a printable string for uniform debugging messages.</p></div></div></div></div></div><div class=sect1><h2 id=conclusion>6. Conclusion<a class=anchor href=#conclusion></a></h2><div class=sectionbody><div class=sect2><h3 id=results>6.1. Results<a class=anchor href=#results></a></h3><div class=paragraph><p>As of April 2007 the Linux® emulation layer is capable of emulating the Linux® 2.6.16 kernel quite well.
The remaining problems concern futexes, unfinished *at family of syscalls, problematic signals delivery, missing <code>epoll</code> and <code>inotify</code> and probably some bugs we have not discovered yet.
Despite this we are capable of running basically all the Linux® programs included in FreeBSD Ports Collection with Fedora Core 4 at 2.6.16 and there are some rudimentary reports of success with Fedora Core 6 at 2.6.16.
The Fedora Core 6 linux_base was recently committed enabling some further testing of the emulation layer and giving us some more hints where we should put our effort in implementing missing stuff.</p></div><div class=paragraph><p>We are able to run the most used applications like <a class=package href=https://cgit.freebsd.org/ports/tree/www/linux-firefox/>www/linux-firefox</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/net-im/skype/>net-im/skype</a> and some games from the Ports Collection.
Some of the programs exhibit bad behavior under 2.6 emulation but this is currently under investigation and hopefully will be fixed soon.
The only big application that is known not to work is the Linux® Java™ Development Kit and this is because of the requirement of <code>epoll</code> facility which is not directly related to the Linux® kernel 2.6.</p></div><div class=paragraph><p>We hope to enable 2.6.16 emulation by default some time after FreeBSD 7.0 is released at least to expose the 2.6 emulation parts for some wider testing.
Once this is done we can switch to Fedora Core 6 linux_base, which is the ultimate plan.</p></div></div><div class=sect2><h3 id=future-work>6.2. Future work<a class=anchor href=#future-work></a></h3><div class=paragraph><p>Future work should focus on fixing the remaining issues with futexes, implement the rest of the *at family of syscalls, fix the signal delivery and possibly implement the <code>epoll</code> and <code>inotify</code> facilities.</p></div><div class=paragraph><p>We hope to be able to run the most important programs flawlessly soon, so we will be able to switch to the 2.6 emulation by default and make the Fedora Core 6 the default linux_base because our currently used Fedora Core 4 is not supported any more.</p></div><div class=paragraph><p>The other possible goal is to share our code with NetBSD and DragonflyBSD.
NetBSD has some support for 2.6 emulation but its far from finished and not really tested.
DragonflyBSD has expressed some interest in porting the 2.6 improvements.</p></div><div class=paragraph><p>Generally, as Linux® develops we would like to keep up with their development, implementing newly added syscalls.
Splice comes to mind first.
Some already implemented syscalls are also suboptimal, for example <code>mremap</code> and others.
Some performance improvements can also be made, finer grained locking and others.</p></div></div><div class=sect2><h3 id=team>6.3. Team<a class=anchor href=#team></a></h3><div class=paragraph><p>I cooperated on this project with (in alphabetical order):</p></div><div class=ulist><ul><li><p><code>John Baldwin &lt;<a href=mailto:jhb@FreeBSD.org>jhb@FreeBSD.org</a>></code></p></li><li><p><code>Konstantin Belousov &lt;<a href=mailto:kib@FreeBSD.org>kib@FreeBSD.org</a>></code></p></li><li><p>Emmanuel Dreyfus</p></li><li><p>Scot Hetzel</p></li><li><p><code>Jung-uk Kim &lt;<a href=mailto:jkim@FreeBSD.org>jkim@FreeBSD.org</a>></code></p></li><li><p><code>Alexander Leidinger &lt;<a href=mailto:netchild@FreeBSD.org>netchild@FreeBSD.org</a>></code></p></li><li><p><code>Suleiman Souhlal &lt;<a href=mailto:ssouhlal@FreeBSD.org>ssouhlal@FreeBSD.org</a>></code></p></li><li><p>Li Xiao</p></li><li><p><code>David Xu &lt;<a href=mailto:davidxu@FreeBSD.org>davidxu@FreeBSD.org</a>></code></p></li></ul></div><div class=paragraph><p>I would like to thank all those people for their advice, code reviews and general support.</p></div></div></div></div><div class=sect1><h2 id=literatures>7. Literatures<a class=anchor href=#literatures></a></h2><div class=sectionbody><div class="olist arabic"><ol class=arabic><li><p>Marshall Kirk McKusick - George V. Nevile-Neil. Design and Implementation of the FreeBSD operating system. Addison-Wesley, 2005.</p></li><li><p><a href=https://tldp.org>https://tldp.org</a></p></li><li><p><a href=https://www.kernel.org>https://www.kernel.org</a></p></li></ol></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: December 29, 2023 by <a href="https://cgit.freebsd.org/doc/commit/?id=fa54965290" target=_blank>Benedict Reuschling</a></p></div></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introduction</a></li><li><a href=#inside>2. A look inside…​</a></li><li><a href=#freebsd-emulation>3. Emulation</a></li><li><a href=#md>4. Linux® emulation layer -MD part</a></li><li><a href=#mi>5. Linux® emulation layer -MI part</a></li><li><a href=#conclusion>6. Conclusion</a></li><li><a href=#literatures>7. Literatures</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/en/articles/linux-emulation/linux-emulation_en.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/en/_index target=_blank>Edit this page</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/en/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>English</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/en class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/en/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>