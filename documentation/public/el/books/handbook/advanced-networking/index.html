<!doctype html><html class=theme-light lang=el><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/el/books/handbook/advanced-networking/><title>Κεφάλαιο 31. Προχωρημένα Θέματα Δικτύωσης | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Κεφάλαιο 31. Προχωρημένα Θέματα Δικτύωσης"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="el"><meta property="og:url" content="https://docs.freebsd.org/el/books/handbook/advanced-networking/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/el\/books\/handbook\/advanced-networking\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/el>Documentation portal</a></li><li><a href=https://docs.freebsd.org/el/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/el/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/el/books>Books</a></li><li><a href=https://docs.freebsd.org/el/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/el/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=el>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Αναζήτηση aria-label=Αναζήτηση maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/preface/>Πρόλογος</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/preface/#preface-audience>Σε Ποιους Απευθύνεται Αυτό το Βιβλίο</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/preface/#preface-changes-from3>Αλλαγές από την Τρίτη Έκδοση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/preface/#preface-changes-from2>Αλλαγές από τη Δεύτερη Έκδοση (2004)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/preface/#preface-changes>Αλλαγές από την Πρώτη Έκδοση (2001)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/preface/#preface-overview>Οργάνωση Αυτού του Βιβλίου</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/preface/#preface-conv>Συμβάσεις που χρησιμοποιούνται σε αυτό το βιβλίο</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/preface/#preface-acknowledgements>Ευχαριστίες</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/parti/>Μέρος I. Ξεκινώντας με το FreeBSD</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/introduction/>Κεφάλαιο 1. Εισαγωγή</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/introduction/#introduction-synopsis>1.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/introduction/#nutshell>1.2. Καλώς ήλθατε στο FreeBSD!</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/introduction/#history>1.3. Πληροφορίες για το FreeBSD Project</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/>Κεφάλαιο 2. Εγκατάσταση του FreeBSD 9.x και Μεταγενέστερων Εκδόσεων</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Απαιτήσεις Υλικού</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Εργασίες πριν την Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-start>2.4. Ξεκινώντας την Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#using-bsdinstall>2.5. Εισαγωγή στο bsdinstall</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-netinstall>2.6. Εγκατάσταση από το Δίκτυο</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-partitioning>2.7. Εκχώρηση Χώρου στο Δίσκο</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-final-warning>2.8. Επιβεβαίωση της Εγκατάστασης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-post>2.9. Μετά την Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Αντιμετώπιση Προβλημάτων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bsdinstall/#using-live-cd>2.11. Χρησιμοποιώντας τη Λειτουργία Live CD</a></li></ul></li><li><input type=checkbox id=chapter-6aaec170775233b7c45f6cdcfb70d466 class=toggle>
<label class="icon cursor" for=chapter-6aaec170775233b7c45f6cdcfb70d466><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/install/>Κεφάλαιο 3. Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-synopsis>3.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-hardware>3.2. Απαιτήσεις Υλικού</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-pre>3.3. Εργασίες πριν την Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-start>3.4. Ξεκινώντας την Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#using-sysinstall>3.5. Εισαγωγή στο Sysinstall</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-steps>3.6. Εκχώρηση Χώρου στο Δίσκο</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-choosing>3.7. Επιλέγοντας τι θα Εγκαταστήσετε</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-media>3.8. Επιλέγοντας το Μέσο Εγκατάστασης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-final-warning>3.9. Επιβεβαίωση της Εγκατάστασης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-post>3.10. Μετά την Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-trouble>3.11. Αντιμετώπιση Προβλημάτων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-advanced>3.12. Οδηγός Εγκατάστασης για Προχωρημένους</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/install/#install-diff-media>3.13. Προετοιμάζοντας τα Δικά σας Μέσα Εγκατάστασης</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/basics/>Κεφάλαιο 4. Βασικές Έννοιες στο UNIX®</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#basics-synopsis>4.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#consoles>4.2. Εικονικές Κονσόλες και Τερματικά</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#permissions>4.3. Άδειες (Permissions)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#dirstructure>4.4. Δομή Καταλόγου</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#disk-organization>4.5. Οργάνωση Δίσκου</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#mount-unmount>4.6. Προσάρτηση και Αποπροσάρτηση Συστημάτων Αρχείων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#basics-processes>4.7. Διεργασίες</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#basics-daemons>4.8. Δαίμονες, Σήματα, και Τερματισμός Διεργασιών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#shells>4.9. Κελύφη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#editors>4.10. Κειμενογράφοι</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#basics-devices>4.11. Συσκευές και Αρχεία συσκευών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#binary-formats>4.12. Τύποι Εκτελέσιμων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/basics/#basics-more-information>4.13. Για Περισσότερες Πληροφορίες</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/ports/>Κεφάλαιο 5. Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/ports/#ports-synopsis>5.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ports/#ports-overview>5.2. Επισκόπησή της εγκατάστασης λογισμικού</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ports/#ports-finding-applications>5.3. Βρίσκοντας την Εφαρμογή σας</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ports/#packages-using>5.4. Χρησιμοποιώντας το Σύστημα των Πακέτων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ports/#ports-using>5.5. Χρησιμοποιώντας την Συλλογή των Ports</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ports/#ports-nextsteps>5.6. Ενέργειες μετά την Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ports/#ports-broken>5.7. Αντιμετωπίζοντας Χαλασμένα Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/x11/>Κεφάλαιο 6. Το Σύστημα X Window</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/x11/#x11-synopsis>6.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/x11/#x-understanding>6.2. Κατανόηση του περιβάλλοντος X11</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/x11/#x-install>6.3. Εγκατάσταση του X11</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/x11/#x-config>6.4. Ρύθμιση του X11</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/x11/#x-fonts>6.5. Χρήση Γραμματοσειρών στο X11</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/x11/#x-xdm>6.6. Ο X Display Manager</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/x11/#x11-wm>6.7. Γραφικά Περιβάλλοντα</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/partii/>Μέρος II. Βασικές Εργασίες</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/desktop/>Κεφάλαιο 7. Desktop Εφαρμογές</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/desktop/#desktop-synopsis>7.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/desktop/#desktop-browsers>7.2. Φυλλομετρητές (Browsers)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/desktop/#desktop-productivity>7.3. Εφαρμογές Γραφείου</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/desktop/#desktop-viewers>7.4. Προγράμματα Προβολής Εγγράφων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/desktop/#desktop-finance>7.5. Χρηματοοικονομικές Εφαρμογές</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/desktop/#desktop-summary>7.6. Περίληψη</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/multimedia/>Κεφάλαιο 8. Πολυμέσα</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/multimedia/#multimedia-synopsis>8.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/multimedia/#sound-setup>8.2. Ρύθμιση της Κάρτας Ήχου</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/multimedia/#sound-mp3>8.3. Ήχος MP3</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/multimedia/#video-playback>8.4. Αναπαραγωγή Video</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/multimedia/#tvcard>8.5. Ρύθμιση Κάρτας Τηλεόρασης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/multimedia/#mythtv>8.6. MythTV</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/multimedia/#scanners>8.7. Σαρωτές Εικόνας</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/>Κεφάλαιο 9. Ρυθμίζοντας τον Πυρήνα του FreeBSD</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/#kernelconfig-synopsis>9.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/#kernelconfig-custom-kernel>9.2. Γιατί να Φτιάξετε Προσαρμοσμένο Πυρήνα;</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/#kernelconfig-devices>9.3. Ανακαλύπτοντας τις Συσκευές του Συστήματος σας</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/#kernelconfig-modules>9.4. Προγράμματα Οδήγησης, Υποσυστήματα και Αρθρώματα (modules)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/#kernelconfig-building>9.5. Δημιουργία και Εγκατάσταση Προσαρμοσμένου Πυρήνα</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/#kernelconfig-config>9.6. Το Αρχείο Ρυθμίσεων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/kernelconfig/#kernelconfig-trouble>9.7. Αν Κάτι Πάει Λάθος</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/printing/>Κεφάλαιο 10. Εκτυπώσεις</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/printing/#printing-synopsis>10.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/printing/#printing-intro-spooler>10.2. Εισαγωγή</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/printing/#printing-intro-setup>10.3. Βασική Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/printing/#printing-advanced>10.4. Ρυθμίσεις Εκτυπωτών για Προχωρημένους</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/printing/#printing-using>10.5. Χρήση Εκτυπωτών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/printing/#printing-lpd-alternatives>10.6. Εναλλακτικές Λύσεις για τον Στάνταρ Spooler</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/printing/#printing-troubleshooting>10.7. Εντοπισμός Βλαβών</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/>Κεφάλαιο 11. Συμβατότητα με Εκτελέσιμα του Linux</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/#linuxemu-synopsis>11.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/#linuxemu-lbc-install>11.2. Εγκατάσταση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/#linuxemu-mathematica>11.3. Εγκαθιστώντας το Mathematica®</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/#linuxemu-maple>11.4. Εγκαθιστώντας το Maple™</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/#linuxemu-matlab>11.5. Εγκαθιστώντας το MATLAB®</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/#linuxemu-oracle>11.6. Εγκατάσταση της Oracle®</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/linuxemu/#linuxemu-advanced>11.7. Προχωρημένα Θέματα</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/partiii/>Μέρος III. Διαχείριση Συστήματος</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/config/>Κεφάλαιο 12. Ρύθμιση και Βελτιστοποίηση</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/config/#config-synopsis>12.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-initial>12.2. Αρχική Ρύθμιση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-core-configuration>12.3. Κύρια Ρύθμιση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-appconfig>12.4. Ρύθμιση Εφαρμογών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-starting-services>12.5. Eκκινώντας Υπηρεσίες</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-cron>12.6. Ρυθμίζοντας Το Πρόγραμμα <code>cron</code></a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-rcd>12.7. Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#config-network-setup>12.8. Ρυθμίζοντας Τις Κάρτες Δικτύου</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-virtual-hosts>12.9. Εικονικά Hosts</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-configfiles>12.10. Αρχεία Ρυθμίσεων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-sysctl>12.11. Tuning with sysctl</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-disk>12.12. Tuning Disks</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#configtuning-kernel-limits>12.13. Tuning Kernel Limits</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#adding-swap-space>12.14. Adding Swap Space</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#acpi-overview>12.15. Power and Resource Management</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/config/#ACPI-debug>12.16. Using and Debugging FreeBSD ACPI</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/boot/>Κεφάλαιο 13. Η Διαδικασία Εκκίνησης του FreeBSD</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/boot/#boot-synopsis>13.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/boot/#boot-introduction>13.2. Το Πρόβλημα της Εκκίνησης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/boot/#boot-blocks>13.3. Ο Διαχειριστής Εκκίνησης και τα Στάδια Εκκίνησης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/boot/#boot-kernel>13.4. Αλληλεπίδραση με τον Πυρήνα κατά την Εκκίνηση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/boot/#device-hints>13.5. Device Hints</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/boot/#boot-init>13.6. Init: Αρχικοποίηση Ελέγχου Διαδικασιών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/boot/#boot-shutdown>13.7. Ακολουθία Τερματισμού</a></li></ul></li><li><input type=checkbox id=chapter-d251c21b963b5ab783e5aec225e02b5a class=toggle>
<label class="icon cursor" for=chapter-d251c21b963b5ab783e5aec225e02b5a><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/users/>Κεφάλαιο 14. Χρήστες και Βασική Διαχείριση Λογαριασμών</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-synopsis>14.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-introduction>14.2. Εισαγωγή</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-superuser>14.3. Ο Λογαριασμός Υπερχρήστη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-system>14.4. Λογαριασμοί Συστήματος</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-user>14.5. Λογαριασμοί Χρηστών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-modifying>14.6. Τροποποιώντας Λογαριασμούς</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-limiting>14.7. Περιορίζοντας Χρήστες</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/users/#users-groups>14.8. Ομάδες</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/security/>Κεφάλαιο 15. Ασφάλεια</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/security/#security-synopsis>15.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#security-intro>15.2. Introduction</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#securing-freebsd>15.3. Securing FreeBSD</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#crypt>15.4. DES, MD5, and Crypt</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#one-time-passwords>15.5. One-time Passwords</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#tcpwrappers>15.6. TCP Wrappers</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#kerberosIV>15.7. KerberosIV</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#kerberos5>15.8. Kerberos5</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#openssl>15.9. OpenSSL</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#ipsec>15.10. VPN over IPsec</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#openssh>15.11. OpenSSH</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#fs-acl>15.12. File System Access Control Lists</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#security-portaudit>15.13. Monitoring Third Party Security Issues</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#security-advisories>15.14. FreeBSD Security Advisories</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/security/#security-accounting>15.15. Process Accounting</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/jails/>Κεφάλαιο 16. Jails</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/jails/#jails-synopsis>16.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/jails/#jails-terms>16.2. Όροι των Jails</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/jails/#jails-intro>16.3. Εισαγωγή</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/jails/#jails-build>16.4. Δημιουργώντας και Ελέγχοντας Jails</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/jails/#jails-tuning>16.5. Λεπτομερής Ρύθμιση και Διαχείριση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/jails/#jails-application>16.6. Εφαρμογή των Jails</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/mac/>Κεφάλαιο 17. Υποχρεωτικός Έλεγχος Πρόσβασης</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-synopsis>17.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-inline-glossary>17.2. Key Terms in this Chapter</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-initial>17.3. Explanation of MAC</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-understandlabel>17.4. Understanding MAC Labels</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-planning>17.5. Planning the Security Configuration</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-modules>17.6. Module Configuration</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-bsdextended>17.7. The MAC bsdextended Module</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-ifoff>17.8. The MAC ifoff Module</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-portacl>17.9. The MAC portacl Module</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-partition>17.10. The MAC partition Module</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-mls>17.11. The MAC Multi-Level Security Module</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-biba>17.12. The MAC Biba Module</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-lomac>17.13. The MAC LOMAC Module</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-implementing>17.14. Nagios in a MAC Jail</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-userlocked>17.15. User Lock Down</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mac/#mac-troubleshoot>17.16. Troubleshooting the MAC Framework</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/audit/>Κεφάλαιο 18. Έλεγχος Συμβάντων Ασφαλείας</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/audit/#audit-synopsis>31.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/audit/#audit-inline-glossary>31.2. Key Terms in this Chapter</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/audit/#audit-install>31.3. Installing Audit Support</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/audit/#audit-config>31.4. Audit Configuration</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/audit/#audit-administration>31.5. Administering the Audit Subsystem</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/disks/>Κεφάλαιο 19. Αποθηκευτικά Μέσα</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#disks-synopsis>19.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#disks-naming>19.2. Device Names</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#disks-adding>19.3. Adding Disks</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#usb-disks>19.4. USB Storage Devices</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#creating-cds>19.5. Creating and Using CD Media</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#creating-dvds>19.6. Creating and Using DVD Media</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#floppies>19.7. Creating and Using Floppy Disks</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#backups-tapebackups>19.8. Creating and Using Data Tapes</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#backup-strategies>19.9. Backup Strategies</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#backup-basics>19.10. Backup Basics</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#disks-virtual>19.11. Network, Memory, and File-Backed File Systems</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#snapshots>19.12. File System Snapshots</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#quotas>19.13. File System Quotas</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#disks-encrypting>19.14. Encrypting Disk Partitions</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#swap-encrypting>19.15. Encrypting Swap Space</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/disks/#disks-hast>19.16. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/geom/>Κεφάλαιο 20. GEOM: Διαχείριση Συστοιχιών Δίσκων</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#GEOM-synopsis>20.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#GEOM-intro>20.2. Εισαγωγή στο GEOM</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#GEOM-striping>20.3. RAID0 - Striping</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#GEOM-mirror>20.4. RAID1 - Mirroring</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#GEOM-raid3>20.5. RAID3 - Striping σε Επίπεδο Byte με Αφοσιωμένο Parity</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#geom-ggate>20.6. Δικτυακές Συσκευές μέσω GEOM Gate</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#geom-glabel>20.7. Δημιουργώντας Ετικέτες (Labels) στις Συσκευές Δίσκων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/geom/#geom-gjournal>20.8. UFS Journaling Μέσω GEOM</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/filesystems/>Κεφάλαιο 21. Υποστήριξη Συστημάτων Αρχείων</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/filesystems/#filesystems-synopsis>21.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/filesystems/#filesystems-zfs>21.2. Το Σύστημα Αρχείων Z (ZFS)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/filesystems/#filesystems-linux>21.3. Συστήματα Αρχείων Linux®</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/virtualization/>Κεφάλαιο 22. Εικονικοποίηση</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/virtualization/#virtualization-synopsis>22.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/virtualization/#virtualization-guest>22.2. Το FreeBSD ως φιλοξενούμενο λειτουργικό</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/virtualization/#virtualization-host>22.3. Το FreeBSD ως Ξενιστής (Host)</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/l10n/>Κεφάλαιο 23. Τοπικές Ρυθμίσεις - Χρήση και ρύθμιση I18N/L10N</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/l10n/#l10n-synopsis>23.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/l10n/#l10n-basics>23.2. Βασικές Γνώσεις</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/l10n/#using-localization>23.3. Χρήση των Τοπικών Ρυθμίσεων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/l10n/#l10n-compiling>23.4. Μεταγλώττιση Προγραμμάτων I18N</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/l10n/#lang-setup>23.5. Τοπικές Ρυθμίσεις για Συγκεκριμένες Γλώσσες</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/>Κεφάλαιο 24. Ενημέρωση και Αναβάθμιση του FreeBSD</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#updating-upgrading-synopsis>24.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>24.2. Ενημερώνοντας το FreeBSD</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#updating-upgrading-portsnap>24.3. Portsnap: Ένα Εργαλείο Ενημέρωσης της Συλλογής των Ports</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#updating-upgrading-documentation>24.4. Ενημερώνοντας την Τεκμηρίωση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#current-stable>24.5. Παρακολούθηση Ενός Κλάδου Ανάπτυξης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#synching>24.6. Συγχρονίζοντας τον Πηγαίο σας Κώδικα</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#makeworld>24.7. Μεταγλωττίζοντας το Βασικό Σύστημα ("world")</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#make-delete-old>24.8. Διαγραφή Παρωχημένων Αρχείων, Καταλόγων και Βιβλιοθηκών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/cutting-edge/#small-lan>24.9. Διαδικασία για Πολλαπλά Μηχανήματα</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/dtrace/>Κεφάλαιο 25. DTrace</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/dtrace/#dtrace-synopsis>25.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/dtrace/#dtrace-implementation>25.2. Διαφορές στην Υλοποίηση</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/dtrace/#dtrace-enable>25.3. Ενεργοποίηση της Υποστήριξης DTrace</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/dtrace/#dtrace-using>25.4. Χρησιμοποιώντας το DTrace</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/dtrace/#dtrace-language>25.5. Η Γλώσσα D</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/partiv/>Μέρος IV. Δικτυακές Επικοινωνίες</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/serialcomms/>Κεφάλαιο 26. Σειριακές Επικοινωνίες</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/serialcomms/#serial-synopsis>26.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/serialcomms/#serial>26.2. Εισαγωγή</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/serialcomms/#term>26.3. Τερματικά</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/serialcomms/#dialup>26.4. Υπηρεσία Εισόδου μέσω Επιλογικής Σύνδεσης (dial-in)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/serialcomms/#dialout>26.5. Υπηρεσία Επιλογικής Σύνδεσης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/serialcomms/#serialconsole-setup>26.6. Ρύθμιση της Σειριακής Κονσόλας</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/>Κεφάλαιο 27. PPP και SLIP</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/#userppp>27.2. Χρησιμοποιώντας το PPP Χρήστη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/#ppp>27.3. Χρησιμοποιώντας το PPP του Πυρήνα</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.4. Αντιμετώπιση Προβλημάτων σε Συνδέσεις PPP</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/#pppoe>27.5. Χρησιμοποιώντας PPP μέσω Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/#pppoa>27.6. Χρησιμοποιώντας PPP μέσω ATM (PPPoA)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/ppp-and-slip/#slip>27.7. Χρησιμοποιώντας το SLIP</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/mail/>Κεφάλαιο 28. Ηλεκτρονικό Ταχυδρομείο</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-synopsis>28.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-using>28.2. Χρησιμοποιώντας το Ηλεκτρονικό Ταχυδρομείο</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#sendmail>28.3. Ρύθμιση του sendmail</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-changingmta>28.4. Αλλάζοντας τον Αντιπρόσωπο Μεταφοράς Ταχυδρομείου (MTA)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-trouble>28.5. Αντιμετώπιση Προβλημάτων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-advanced>28.6. Προχωρημένα Θέματα</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#SMTP-UUCP>28.7. SMTP με UUCP</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#outgoing-only>28.8. Ρύθμιση Εξυπηρετητή Μόνο για Αποστολή</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#SMTP-dialup>28.9. Χρησιμοποιώντας το Mail Μέσω Επιλογικής (Dialup) Σύνδεσης</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#SMTP-Auth>28.10. Πιστοποίηση Αυθεντικότητας στο SMTP</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-agents>28.11. Προγράμματα Ταχυδρομείου για τον Χρήστη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-fetchmail>28.12. Χρησιμοποιώντας το fetchmail</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mail/#mail-procmail>28.13. Χρησιμοποιώντας το procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/network-servers/>Κεφάλαιο 29. Εξυπηρετητές Δικτύου</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-servers-synopsis>29.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-inetd>29.2. The inetd"Super-Server"</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-nis>29.4. Network Information System (NIS/YP)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-dhcp>29.5. Automatic Network Configuration (DHCP)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-dns>29.6. Domain Name System (DNS)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-apache>29.7. Ο εξυπηρετητής HTTP Apache</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-ftp>29.8. Πρωτόκολο Μεταφοράς Αρχείων (FTP)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-samba>29.9. File and Print Services for Microsoft® Windows® clients (Samba)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/network-servers/#network-ntp>29.10. Συγχρονισμός Ρολογιού Συστήματος με NTP</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/firewalls/>Κεφάλαιο 30. Firewalls</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/firewalls/#firewalls-intro>30.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/firewalls/#firewalls-concepts>30.2. Βασικές Έννοιες των Firewalls</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/firewalls/#firewalls-apps>30.3. Προγράμματα Firewall</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/firewalls/#firewalls-pf>30.4. Το Packet Filter (PF) και το ALTQ του OpenBSD</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/firewalls/#firewalls-ipf>30.5. Το IPFILTER (IPF) Firewall</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/firewalls/#firewalls-ipfw>30.6. IPFW</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle checked>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/>Κεφάλαιο 31. Προχωρημένα Θέματα Δικτύωσης</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Σύνοψη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-routing>31.2. Gateways and Routes</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-wireless>31.3. Wireless Networking</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-bluetooth>31.4. Bluetooth</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-bridging>31.5. Bridging</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-diskless>31.6. Diskless Operation</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-isdn>31.7. ISDN</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-natd>31.8. Network Address Translation</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-plip>31.9. Parallel Line IP (PLIP)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-ipv6>31.10. IPv6</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#network-atm>31.11. Asynchronous Transfer Mode (ATM)</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/advanced-networking/#carp>31.12. Common Access Redundancy Protocol (CARP)</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/partv/>Μέρος V. Παραρτήματα</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/mirrors/>Παράρτημα A. Που θα Βρείτε το FreeBSD</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#mirrors-cdrom>A.1. Εκδόσεις σε CDROM και DVD</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#mirrors-ftp>A.2. Εξυπηρετητές FTP</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#anoncvs>A.3. Ανώνυμο CVS</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#ctm>A.4. Χρησιμοποιώντας το CTM</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#cvsup>A.5. Χρησιμοποιώντας το CVSup</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#cvs-tags>A.6. Ετικέτες (Tags) για το CVS</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#mirrors-afs>A.7. Τοποθεσίες AFS</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/mirrors/#mirrors-rsync>A.8. Τοποθεσίες rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/bibliography/>Παράρτημα B. Βιβλιογραφία</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-freebsd>B.1. Βιβλία & Περιοδικά σχετικά με το FreeBSD</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-userguides>B.2. Οδηγοί χρήστη</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-adminguides>B.3. Οδηγοί διαχειριστή</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-programmers>B.4. Οδηγοί προγραμματιστών</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-osinternals>B.5. Το εσωτερικό του λειτουργικού συστήματος</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-security>B.6. Αναφορές ασφαλείας</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-hardware>B.7. Αναφορές υλικού</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-history>B.8. Ιστορία του UNIX®</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/bibliography/#bibliography-journals>B.9. Περιοδικά και εφημερίδες</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/eresources/>Παράρτημα C. Πηγές Πληροφόρησης στο Διαδίκτυο</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/eresources/#eresources-mail>C.1. Λίστες Ηλεκτρονικού Ταχυδρομείου</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/eresources/#eresources-news>C.2. Usenet Newsgroups</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/eresources/#eresources-web>C.3. Διακομιστές Ιστοσελίδων</a></li><li><a href=https://docs.freebsd.org/el/books/handbook/eresources/#eresources-email>C.4. Διευθύνσεις Ηλεκτρονικού Ταχυδρομείου</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/el/books/handbook/pgpkeys/>Παράρτημα D. Κλειδιά PGP</a><ul><li><a href=https://docs.freebsd.org/el/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Κεφάλαιο 31. Προχωρημένα Θέματα Δικτύωσης</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Πίνακας περιεχομένων</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. Σύνοψη</a></li><li><a href=#network-routing>31.2. Gateways and Routes</a></li><li><a href=#network-wireless>31.3. Wireless Networking</a></li><li><a href=#network-bluetooth>31.4. Bluetooth</a></li><li><a href=#network-bridging>31.5. Bridging</a></li><li><a href=#network-diskless>31.6. Diskless Operation</a></li><li><a href=#network-isdn>31.7. ISDN</a></li><li><a href=#network-natd>31.8. Network Address Translation</a></li><li><a href=#network-plip>31.9. Parallel Line IP (PLIP)</a></li><li><a href=#network-ipv6>31.10. IPv6</a></li><li><a href=#network-atm>31.11. Asynchronous Transfer Mode (ATM)</a></li><li><a href=#carp>31.12. Common Access Redundancy Protocol (CARP)</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=advanced-networking-synopsis>31.1. Σύνοψη<a class=anchor href=#advanced-networking-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Το κεφάλαιο αυτό καλύπτει προχωρημένα θέματα δικτύωσης.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Τα βασικά των πυλών (gateways) και των δρομολογήσεων (routes).</p></li><li><p>Πως να ρυθμίσετε συσκευές IEEE 802.11 και Bluetooth®.</p></li><li><p>Πως να κάνετε το FreeBSD να δρα ως γέφυρα (bridge).</p></li><li><p>Πως να ρυθμίσετε εκκίνηση από το δίκτυο σε ένα μηχάνημα χωρίς σκληρό δίσκο.</p></li><li><p>Πως να ρυθμίσετε μετάφραση δικτυακών διευθύνσεων (NAT).</p></li><li><p>Πως να συνδέσετε δύο υπολογιστές μέσω PLIP.</p></li><li><p>Πως να ρυθμίσετε το IPv6 σε ένα μηχάνημα FreeBSD.</p></li><li><p>Πως να ρυθμίσετε το ATM.</p></li><li><p>Πως να ρυθμίσετε και να χρησιμοποιήσετε τις δυνατότητες του CARP (Common Access Redundancy Protocol) στο FreeBSD.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε τις βασικές έννοιες των αρχείων script <span class=filename>/etc/rc</span>.</p></li><li><p>Να είστε εξοικειωμένος με τη βασική ορολογία των δικτύων.</p></li><li><p>Να γνωρίζετε πως να ρυθμίσετε και να εγκαταστήσετε ένα νέο πυρήνα στο FreeBSD (<a href=../kernelconfig/#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li><li><p>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=../ports/#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=network-routing>31.2. Gateways and Routes<a class=anchor href=#network-routing></a></h2><div class=sectionbody><div class=paragraph><p>For one machine to be able to find another over a network, there must be a mechanism in place to describe how to get from one to the other. This is called <em>routing</em>. A "route" is a defined pair of addresses: a "destination" and a "gateway". The pair indicates that if you are trying to get to this <em>destination</em>, communicate through this <em>gateway</em>. There are three types of destinations: individual hosts, subnets, and "default". The "default route" is used if none of the other routes apply. We will talk a little bit more about default routes later on. There are also three types of gateways: individual hosts, interfaces (also called "links"), and Ethernet hardware addresses (MAC addresses).</p></div><div class=sect2><h3 id=_an_example>31.2.1. An Example<a class=anchor href=#_an_example></a></h3><div class=paragraph><p>To illustrate different aspects of routing, we will use the following example from <code>netstat</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1             UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>The first two lines specify the default route (which we will cover in the <a href=#network-routing-default>next section</a>) and the <code>localhost</code> route.</p></div><div class=paragraph><p>The interface (<code>Netif</code> column) that this routing table specifies to use for <code>localhost</code> is <span class=filename>lo0</span>, also known as the loopback device. This says to keep all traffic for this destination internal, rather than sending it out over the LAN, since it will only end up back where it started.</p></div><div class=paragraph><p>The next thing that stands out are the addresses beginning with <code>0:e0:</code>. These are Ethernet hardware addresses, which are also known as MAC addresses. FreeBSD will automatically identify any hosts (<code>test0</code> in the example) on the local Ethernet and add a route for that host, directly to it over the Ethernet interface, <span class=filename>ed0</span>. There is also a timeout (<code>Expire</code> column) associated with this type of route, which is used if we fail to hear from the host in a specific amount of time. When this happens, the route to this host will be automatically deleted. These hosts are identified using a mechanism known as RIP (Routing Information Protocol), which figures out routes to local hosts based upon a shortest path determination.</p></div><div class=paragraph><p>FreeBSD will also add subnet routes for the local subnet (<code>10.20.30.255</code> is the broadcast address for the subnet <code>10.20.30</code>, and <code>example.com</code> is the domain name associated with that subnet). The designation <code>link#1</code> refers to the first Ethernet card in the machine. You will notice no additional interface is specified for those.</p></div><div class=paragraph><p>Both of these groups (local network hosts and local subnets) have their routes automatically configured by a daemon called routed. If this is not run, then only routes which are statically defined (i.e. entered explicitly) will exist.</p></div><div class=paragraph><p>The <code>host1</code> line refers to our host, which it knows by Ethernet address. Since we are the sending host, FreeBSD knows to use the loopback interface (<span class=filename>lo0</span>) rather than sending it out over the Ethernet interface.</p></div><div class=paragraph><p>The two <code>host2</code> lines are an example of what happens when we use an <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> alias (see the section on Ethernet for reasons why we would do this). The <code>⇒</code> symbol after the <span class=filename>lo0</span> interface says that not only are we using the loopback (since this address also refers to the local host), but specifically it is an alias. Such routes only show up on the host that supports the alias; all other hosts on the local network will simply have a <code>link#1</code> line for such routes.</p></div><div class=paragraph><p>The final line (destination subnet <code>224</code>) deals with multicasting, which will be covered in another section.</p></div><div class=paragraph><p>Finally, various attributes of each route can be seen in the <code>Flags</code> column. Below is a short table of some of these flags and their meanings:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Up: The route is active.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Host: The route destination is a single host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gateway: Send anything for this destination on to this remote system, which will figure out from there where to send it.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Static: This route was configured manually, not automatically generated by the system.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clone: Generates a new route based upon this route for machines we connect to. This type of route is normally used for local networks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>WasCloned: Indicated a route that was auto-configured based upon a local area network (Clone) route.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Link: Route involves references to Ethernet hardware.</p></td></tr></tbody></table></div><div class=sect2><h3 id=network-routing-default>31.2.2. Default Routes<a class=anchor href=#network-routing-default></a></h3><div class=paragraph><p>When the local system needs to make a connection to a remote host, it checks the routing table to determine if a known path exists. If the remote host falls into a subnet that we know how to reach (Cloned routes), then the system checks to see if it can connect along that interface.</p></div><div class=paragraph><p>If all known paths fail, the system has one last option: the "default" route. This route is a special type of gateway route (usually the only one present in the system), and is always marked with a <code>c</code> in the flags field. For hosts on a local area network, this gateway is set to whatever machine has a direct connection to the outside world (whether via PPP link, DSL, cable modem, T1, or another network interface).</p></div><div class=paragraph><p>If you are configuring the default route for a machine which itself is functioning as the gateway to the outside world, then the default route will be the gateway machine at your Internet Service Provider’s (ISP) site.</p></div><div class=paragraph><p>Let us look at an example of default routes. This is a common configuration:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/net-routing.png alt="net routing"></div></div><div class=paragraph><p>The hosts <code>Local1</code> and <code>Local2</code> are at your site. <code>Local1</code> is connected to an ISP via a dial up PPP connection. This PPP server computer is connected through a local area network to another gateway computer through an external interface to the ISPs Internet feed.</p></div><div class=paragraph><p>The default routes for each of your machines will be:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Host</th><th class="tableblock halign-left valign-top">Default Gateway</th><th class="tableblock halign-left valign-top">Interface</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ethernet</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PPP</p></td></tr></tbody></table><div class=paragraph><p>A common question is "Why (or how) would we set the <code>T1-GW</code> to be the default gateway for <code>Local1</code>, rather than the ISP server it is connected to?".</p></div><div class=paragraph><p>Remember, since the PPP interface is using an address on the ISP’s local network for your side of the connection, routes for any other machines on the ISP’s local network will be automatically generated. Hence, you will already know how to reach the <code>T1-GW</code> machine, so there is no need for the intermediate step of sending traffic to the ISP server.</p></div><div class=paragraph><p>It is common to use the address <code>X.X.X.1</code> as the gateway address for your local network. So (using the same example), if your local class-C address space was <code>10.20.30</code> and your ISP was using <code>10.9.9</code> then the default routes would be:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Host</th><th class="tableblock halign-left valign-top">Default Route</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2 (10.20.30.2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1, 10.9.9.30)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW (10.9.9.1)</p></td></tr></tbody></table><div class=paragraph><p>You can easily define the default route via the <span class=filename>/etc/rc.conf</span> file. In our example, on the <code>Local2</code> machine, we added the following line in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>It is also possible to do it directly from the command line with the <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>For more information on manual manipulation of network routing tables, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> manual page.</p></div></div><div class=sect2><h3 id=_dual_homed_hosts>31.2.3. Dual Homed Hosts<a class=anchor href=#_dual_homed_hosts></a></h3><div class=paragraph><p>There is one other type of configuration that we should cover, and that is a host that sits on two different networks. Technically, any machine functioning as a gateway (in the example above, using a PPP connection) counts as a dual-homed host. But the term is really only used to refer to a machine that sits on two local-area networks.</p></div><div class=paragraph><p>In one case, the machine has two Ethernet cards, each having an address on the separate subnets. Alternately, the machine may only have one Ethernet card, and be using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aliasing. The former is used if two physically separate Ethernet networks are in use, the latter if there is one physical network segment, but two logically separate subnets.</p></div><div class=paragraph><p>Either way, routing tables are set up so that each subnet knows that this machine is the defined gateway (inbound route) to the other subnet. This configuration, with the machine acting as a router between the two subnets, is often used when we need to implement packet filtering or firewall security in either or both directions.</p></div><div class=paragraph><p>If you want this machine to actually forward packets between the two interfaces, you need to tell FreeBSD to enable this ability. See the next section for more details on how to do this.</p></div></div><div class=sect2><h3 id=network-dedicated-router>31.2.4. Building a Router<a class=anchor href=#network-dedicated-router></a></h3><div class=paragraph><p>A network router is simply a system that forwards packets from one interface to another. Internet standards and good engineering practice prevent the FreeBSD Project from enabling this by default in FreeBSD. You can enable this feature by changing the following variable to <code>YES</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>This option will set the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>net.inet.ip.forwarding</code> to <code>1</code>. If you should need to stop routing temporarily, you can reset this to <code>0</code> temporarily.</p></div><div class=paragraph><p>Your new router will need routes to know where to send the traffic. If your network is simple enough you can use static routes. FreeBSD also comes with the standard BSD routing daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, which speaks RIP (both version 1 and version 2) and IRDP. Support for BGP v4, OSPF v2, and other sophisticated routing protocols is available with the <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> package. Commercial products such as GateD® are also available for more complex network routing solutions.</p></div></div><div class=sect2><h3 id=_setting_up_static_routes>31.2.5. Setting Up Static Routes<a class=anchor href=#_setting_up_static_routes></a></h3><div class=sect3><h4 id=_manual_configuration>31.2.5.1. Manual Configuration<a class=anchor href=#_manual_configuration></a></h4><div class=paragraph><p>Let us assume we have a network as follows:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>In this scenario, <code>RouterA</code> is our FreeBSD machine that is acting as a router to the rest of the Internet. It has a default route set to <code>10.0.0.1</code> which allows it to connect with the outside world. We will assume that <code>RouterB</code> is already configured properly and knows how to get wherever it needs to go. (This is simple in this picture. Just add a default route on <code>RouterB</code> using <code>192.168.1.1</code> as the gateway.)</p></div><div class=paragraph><p>If we look at the routing table for <code>RouterA</code> we would see something like the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>With the current routing table <code>RouterA</code> will not be able to reach our Internal Net 2. It does not have a route for <code>192.168.2.0/24</code>. One way to alleviate this is to manually add the route. The following command would add the Internal Net 2 network to <code>RouterA</code>'s routing table using <code>192.168.1.2</code> as the next hop:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Now <code>RouterA</code> can reach any hosts on the <code>192.168.2.0/24</code> network.</p></div></div><div class=sect3><h4 id=_persistent_configuration>31.2.5.2. Persistent Configuration<a class=anchor href=#_persistent_configuration></a></h4><div class=paragraph><p>The above example is perfect for configuring a static route on a running system. However, one problem is that the routing information will not persist if you reboot your FreeBSD machine. The way to handle the addition of a static route is to put it in your <span class=filename>/etc/rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>The <code>static_routes</code> configuration variable is a list of strings separated by a space. Each string references to a route name. In our above example we only have one string in <code>static_routes</code>. This string is <em>internalnet2</em>. We then add a configuration variable called <code>route_internalnet2</code> where we put all of the configuration parameters we would give to the <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> command. For our example above we would have used the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>so we need <code>"-net 192.168.2.0/24 192.168.1.2"</code>.</p></div><div class=paragraph><p>As said above, we can have more than one string in <code>static_routes</code>. This allows us to create multiple static routes. The following lines shows an example of adding static routes for the <code>192.168.0.0/24</code> and <code>192.168.1.0/24</code> networks on an imaginary router:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div></div><div class=sect2><h3 id=_routing_propagation>31.2.6. Routing Propagation<a class=anchor href=#_routing_propagation></a></h3><div class=paragraph><p>We have already talked about how we define our routes to the outside world, but not about how the outside world finds us.</p></div><div class=paragraph><p>We already know that routing tables can be set up so that all traffic for a particular address space (in our examples, a class-C subnet) can be sent to a particular host on that network, which will forward the packets inbound.</p></div><div class=paragraph><p>When you get an address space assigned to your site, your service provider will set up their routing tables so that all traffic for your subnet will be sent down your PPP link to your site. But how do sites across the country know to send to your ISP?</p></div><div class=paragraph><p>There is a system (much like the distributed DNS information) that keeps track of all assigned address-spaces, and defines their point of connection to the Internet Backbone. The "Backbone" are the main trunk lines that carry Internet traffic across the country, and around the world. Each backbone machine has a copy of a master set of tables, which direct traffic for a particular network to a specific backbone carrier, and from there down the chain of service providers until it reaches your network.</p></div><div class=paragraph><p>It is the task of your service provider to advertise to the backbone sites that they are the point of connection (and thus the path inward) for your site. This is known as route propagation.</p></div></div><div class=sect2><h3 id=_troubleshooting>31.2.7. Troubleshooting<a class=anchor href=#_troubleshooting></a></h3><div class=paragraph><p>Sometimes, there is a problem with routing propagation, and some sites are unable to connect to you. Perhaps the most useful command for trying to figure out where routing is breaking down is the <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> command. It is equally useful if you cannot seem to make a connection to a remote machine (i.e. <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> fails).</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> command is run with the name of the remote host you are trying to connect to. It will show the gateway hosts along the path of the attempt, eventually either reaching the target host, or terminating because of a lack of connection.</p></div><div class=paragraph><p>For more information, see the manual page for <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect2><h3 id=_multicast_routing>31.2.8. Multicast Routing<a class=anchor href=#_multicast_routing></a></h3><div class=paragraph><p>FreeBSD supports both multicast applications and multicast routing natively. Multicast applications do not require any special configuration of FreeBSD; applications will generally run out of the box. Multicast routing requires that support be compiled into the kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>In addition, the multicast routing daemon, <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> must be configured to set up tunnels and DVMRP via <span class=filename>/etc/mrouted.conf</span>. More details on multicast configuration may be found in the manual page for <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a>.</p></div></div></div></div><div class=sect1><h2 id=network-wireless>31.3. Wireless Networking<a class=anchor href=#network-wireless></a></h2><div class=sectionbody><div class=sect2><h3 id=_wireless_networking_basics>31.3.1. Wireless Networking Basics<a class=anchor href=#_wireless_networking_basics></a></h3><div class=paragraph><p>Most wireless networks are based on the IEEE 802.11 standards. A basic wireless network consists of multiple stations communicating with radios that broadcast in either the 2.4GHz or 5GHz band (though this varies according to the locale and is also changing to enable communication in the 2.3GHz and 4.9GHz ranges).</p></div><div class=paragraph><p>802.11 networks are organized in two ways: in <em>infrastructure mode</em> one station acts as a master with all the other stations associating to it; the network is known as a BSS and the master station is termed an access point (AP). In a BSS all communication passes through the AP; even when one station wants to communicate with another wireless station messages must go through the AP. In the second form of network there is no master and stations communicate directly. This form of network is termed an IBSS and is commonly known as an <em>ad-hoc network</em>.</p></div><div class=paragraph><p>802.11 networks were first deployed in the 2.4GHz band using protocols defined by the IEEE 802.11 and 802.11b standard. These specifications include the operating frequencies, MAC layer characteristics including framing and transmission rates (communication can be done at various rates). Later the 802.11a standard defined operation in the 5GHz band, including different signalling mechanisms and higher transmission rates. Still later the 802.11g standard was defined to enable use of 802.11a signalling and transmission mechanisms in the 2.4GHz band in such a way as to be backwards compatible with 802.11b networks.</p></div><div class=paragraph><p>Separate from the underlying transmission techniques 802.11 networks have a variety of security mechanisms. The original 802.11 specifications defined a simple security protocol called WEP. This protocol uses a fixed pre-shared key and the RC4 cryptographic cipher to encode data transmitted on a network. Stations must all agree on the fixed key in order to communicate. This scheme was shown to be easily broken and is now rarely used except to discourage transient users from joining networks. Current security practice is given by the IEEE 802.11i specification that defines new cryptographic ciphers and an additional protocol to authenticate stations to an access point and exchange keys for doing data communication. Further, cryptographic keys are periodically refreshed and there are mechanisms for detecting intrusion attempts (and for countering intrusion attempts). Another security protocol specification commonly used in wireless networks is termed WPA. This was a precursor to 802.11i defined by an industry group as an interim measure while waiting for 802.11i to be ratified. WPA specifies a subset of the requirements found in 802.11i and is designed for implementation on legacy hardware. Specifically WPA requires only the TKIP cipher that is derived from the original WEP cipher. 802.11i permits use of TKIP but also requires support for a stronger cipher, AES-CCM, for encrypting data. (The AES cipher was not required in WPA because it was deemed too computationally costly to be implemented on legacy hardware.)</p></div><div class=paragraph><p>Other than the above protocol standards the other important standard to be aware of is 802.11e. This defines protocols for deploying multi-media applications such as streaming video and voice over IP (VoIP) in an 802.11 network. Like 802.11i, 802.11e also has a precursor specification termed WME (later renamed WMM) that has been defined by an industry group as a subset of 802.11e that can be deployed now to enable multi-media applications while waiting for the final ratification of 802.11e. The most important thing to know about 802.11e and WME/WMM is that it enables prioritized traffic use of a wireless network through Quality of Service (QoS) protocols and enhanced media access protocols. Proper implementation of these protocols enable high speed bursting of data and prioritized traffic flow.</p></div><div class=paragraph><p>Since the 6.0 version, FreeBSD supports networks that operate using 802.11a, 802.11b, and 802.11g. The WPA and 802.11i security protocols are likewise supported (in conjunction with any of 11a, 11b, and 11g) and QoS and traffic prioritization required by the WME/WMM protocols are supported for a limited set of wireless devices.</p></div></div><div class=sect2><h3 id=network-wireless-basic>31.3.2. Basic Setup<a class=anchor href=#network-wireless-basic></a></h3><div class=sect3><h4 id=_kernel_configuration>31.3.2.1. Kernel Configuration<a class=anchor href=#_kernel_configuration></a></h4><div class=paragraph><p>To use wireless networking you need a wireless networking card and to configure the kernel with the appropriate wireless networking support. The latter is separated into multiple modules so that you only need to configure the software you are actually going to use.</p></div><div class=paragraph><p>The first thing you need is a wireless device. The most commonly used devices are those that use parts made by Atheros. These devices are supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> driver and require the following line to be added to the <span class=filename>/boot/loader.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The Atheros driver is split up into three separate pieces: the driver proper (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), the hardware support layer that handles chip-specific functions (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>), and an algorithm for selecting which of several possible rates for transmitting frames (ath_rate_sample here). When you load this support as modules these dependencies are automatically handled for you. If instead of an Atheros device you had another device you would select the module for that device; e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>for devices based on the Intersil Prism parts (<a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> driver).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In the rest of this document, we will use an <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> device, the device name in the examples must be changed according to your configuration. A list of available wireless drivers can be found at the beginning of the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> manual page. If a native FreeBSD driver for your wireless device does not exist, it may be possible to directly use the Windows® driver with the help of the <a href=../config/#config-network-ndis>NDIS</a> driver wrapper.</p></div></td></tr></tbody></table></div><div class=paragraph><p>With a device driver configured you need to also bring in the 802.11 networking support required by the driver. For the <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> driver this is at least the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> module; this module is automatically loaded with the wireless device driver. With that you will need the modules that implement cryptographic support for the security protocols you intend to use. These are intended to be dynamically loaded on demand by the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> module but for now they must be manually configured. The following modules are available: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. Both <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> drivers are only needed if you intend to use the WPA and/or 802.11i security protocols. If your network is to run totally open (i.e., with no encryption) then you do not even need the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a> support. To load these modules at boot time, add the following lines to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>With this information in the system bootstrap configuration file (i.e., <span class=filename>/boot/loader.conf</span>), you have to reboot your FreeBSD box. If you do not want to reboot your machine for the moment, you can just load the modules by hand using <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you do not want to use modules, it is possible to compile these drivers into the kernel by adding the following lines to your kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device ath               # Atheros IEEE 802.11 wireless network driver
device ath_hal           # Atheros Hardware Access Layer
device ath_rate_sample   # John Bicket&#39;s SampleRate control algorithm.
device wlan              # 802.11 support (Required)
device wlan_wep          # WEP crypto support for 802.11 devices
device wlan_ccmp         # AES-CCMP crypto support for 802.11 devices
device wlan_tkip         # TKIP and Michael crypto support for 802.11 devices</pre></div></div><div class=paragraph><p>With this information in the kernel configuration file, recompile the kernel and reboot your FreeBSD machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When the system is up, we could find some information about the wireless device in the boot messages, like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0xff9f0000-0xff9fffff irq 17 at device 2.0 on pci2
ath0: Ethernet address: 00:11:95:d5:43:62
ath0: mac 7.9 phy 4.5 radio 5.6</code></pre></div></div></div></div><div class=sect2><h3 id=_infrastructure_mode>31.3.3. Infrastructure Mode<a class=anchor href=#_infrastructure_mode></a></h3><div class=paragraph><p>The infrastructure mode or BSS mode is the mode that is typically used. In this mode, a number of wireless access points are connected to a wired network. Each wireless network has its own name, this name is called the SSID of the network. Wireless clients connect to the wireless access points.</p></div><div class=sect3><h4 id=_freebsd_clients>31.3.3.1. FreeBSD Clients<a class=anchor href=#_freebsd_clients></a></h4><div class=sect4><h5 id=_how_to_find_access_points>31.3.3.1.1. How to Find Access Points<a class=anchor href=#_how_to_find_access_points></a></h5><div class=paragraph><p>To scan for networks, use the <code>ifconfig</code> command. This request may take a few moments to complete as it requires that the system switches to each available wireless frequency and probes for available access points. Only the super-user can initiate such a scan:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
dlinkap         00:13:46:49:41:76    6   54M 29:0   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M 22:0   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>You must mark the interface <code>up</code> before you can scan. Subsequent scan requests do not require you to mark the interface up again.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The output of a scan request lists each BSS/IBSS network found. Beside the name of the network, <code>SSID</code>, we find the <code>BSSID</code> which is the MAC address of the access point. The <code>CAPS</code> field identifies the type of each network and the capabilities of the stations operating there:</p></div><div class=dlist><dl><dt class=hdlist1><code>E</code></dt><dd><p>Extended Service Set (ESS). Indicates that the station is part of an infrastructure network (in contrast to an IBSS/ad-hoc network).</p></dd><dt class=hdlist1><code>I</code></dt><dd><p>IBSS/ad-hoc network. Indicates that the station is part of an ad-hoc network (in contrast to an ESS network).</p></dd><dt class=hdlist1><code>P</code></dt><dd><p>Privacy. Data confidentiality is required for all data frames exchanged within the BSS. This means that this BSS requires the station to use cryptographic means such as WEP, TKIP or AES-CCMP to encrypt/decrypt data frames being exchanged with others.</p></dd><dt class=hdlist1><code>S</code></dt><dd><p>Short Preamble. Indicates that the network is using short preambles (defined in 802.11b High Rate/DSSS PHY, short preamble utilizes a 56 bit sync field in contrast to a 128 bit field used in long preamble mode).</p></dd><dt class=hdlist1><code>s</code></dt><dd><p>Short slot time. Indicates that the 802.11g network is using a short slot time because there are no legacy (802.11b) stations present.</p></dd></dl></div><div class=paragraph><p>One can also display the current list of known networks with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 list scan</span></code></pre></div></div><div class=paragraph><p>This information may be updated automatically by the adapter or manually with a <code>scan</code> request. Old data is automatically removed from the cache, so over time this list may shrink unless more scans are done.</p></div></div><div class=sect4><h5 id=_basic_settings>31.3.3.1.2. Basic Settings<a class=anchor href=#_basic_settings></a></h5><div class=paragraph><p>This section provides a simple example of how to make the wireless network adapter work in FreeBSD without encryption. After you are familiar with these concepts, we strongly recommend using <a href=#network-wireless-wpa>WPA</a> to set up your wireless network.</p></div><div class=paragraph><p>There are three basic steps to configure a wireless network: selecting an access point, authenticating your station, and configuring an IP address. The following sections discuss each step.</p></div><div class=sect5><h6 id=_selecting_an_access_point>31.3.3.1.2.1. Selecting an Access Point<a class=anchor href=#_selecting_an_access_point></a></h6><div class=paragraph><p>Most of time it is sufficient to let the system choose an access point using the builtin heuristics. This is the default behaviour when you mark an interface up or otherwise configure an interface by listing it in <span class=filename>/etc/rc.conf</span>, e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>If there are multiple access points and you want to select a specific one, you can select it by its SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>In an environment where there are multiple access points with the same SSID (often done to simplify roaming) it may be necessary to associate to one specific device. In this case you can also specify the BSSID of the access point (you can also leave off the SSID):</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>There are other ways to constrain the choice of an access point such as limiting the set of frequencies the system will scan on. This may be useful if you have a multi-band wireless card as scanning all the possible channels can be time-consuming. To limit operation to a specific band you can use the <code>mode</code> parameter; e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;mode 11g ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>will force the card to operate in 802.11g which is defined only for 2.4GHz frequencies so any 5GHz channels will not be considered. Other ways to do this are the <code>channel</code> parameter, to lock operation to one specific frequency, and the <code>chanlist</code> parameter, to specify a list of channels for scanning. More information about these parameters can be found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> manual page.</p></div></div><div class=sect5><h6 id=_authentication>31.3.3.1.2.2. Authentication<a class=anchor href=#_authentication></a></h6><div class=paragraph><p>Once you have selected an access point your station needs to authenticate before it can pass data. Authentication can happen in several ways. The most common scheme used is termed open authentication and allows any station to join the network and communicate. This is the authentication you should use for test purpose the first time you set up a wireless network. Other schemes require cryptographic handshakes be completed before data traffic can flow; either using pre-shared keys or secrets, or more complex schemes that involve backend services such as RADIUS. Most users will use open authentication which is the default setting. Next most common setup is WPA-PSK, also known as WPA Personal, which is described <a href=#network-wireless-wpa-wpa-psk>below</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you have an Apple® AirPort® Extreme base station for an access point you may need to configure shared-key authentication together with a WEP key. This can be done in the <span class=filename>/etc/rc.conf</span> file or using the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> program. If you have a single AirPort® base station you can setup access with something like:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>In general shared key authentication is to be avoided because it uses the WEP key material in a highly-constrained manner making it even easier to crack the key. If WEP must be used (e.g., for compatibility with legacy devices) it is better to use WEP with <code>open</code> authentication. More information regarding WEP can be found in the <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_getting_an_ip_address_with_dhcp>31.3.3.1.2.3. Getting an IP Address with DHCP<a class=anchor href=#_getting_an_ip_address_with_dhcp></a></h6><div class=paragraph><p>Once you have selected an access point and set the authentication parameters, you will have to get an IP address to communicate. Most of time you will obtain your wireless IP address via DHCP. To achieve that, simply edit <span class=filename>/etc/rc.conf</span> and add <code>DHCP</code> to the configuration for your device as shown in various examples above:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>At this point, you are ready to bring up the wireless interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span></code></pre></div></div><div class=paragraph><p>Once the interface is running, use <code>ifconfig</code> to see the status of the interface <span class=filename>ath0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0</span>
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:11:95:d5:43:62
        media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/54Mbps<span class=o>)</span>
        status: associated
        ssid dlinkap channel 6 bssid 00:13:46:49:41:76
        authmode OPEN privacy OFF txpowmax 36 protmode CTS bintval 100</code></pre></div></div><div class=paragraph><p>The <code>status: associated</code> means you are connected to the wireless network (to the <code>dlinkap</code> network in our case). The <code>bssid 00:13:46:49:41:76</code> part is the MAC address of your access point; the <code>authmode</code> line informs you that the communication is not encrypted (<code>OPEN</code>).</p></div></div><div class=sect5><h6 id=_static_ip_address>31.3.3.1.2.4. Static IP Address<a class=anchor href=#_static_ip_address></a></h6><div class=paragraph><p>In the case you cannot obtain an IP address from a DHCP server, you can set a fixed IP address. Replace the <code>DHCP</code> keyword shown above with the address information. Be sure to retain any other parameters you have set up for selecting an access point:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wpa>31.3.3.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h5><div class=paragraph><p>WPA (Wi-Fi Protected Access) is a security protocol used together with 802.11 networks to address the lack of proper authentication and the weakness of <a href=#network-wireless-wep>WEP</a>. WPA leverages the 802.1X authentication protocol and uses one of several ciphers instead of WEP for data integrity. The only cipher required by WPA is TKIP (Temporary Key Integrity Protocol) which is a cipher that extends the basic RC4 cipher used by WEP by adding integrity checking, tamper detection, and measures for responding to any detected intrusions. TKIP is designed to work on legacy hardware with only software modification; it represents a compromise that improves security but is still not entirely immune to attack. WPA also specifies the AES-CCMP cipher as an alternative to TKIP and that is preferred when possible; for this specification the term WPA2 (or RSN) is commonly used.</p></div><div class=paragraph><p>WPA defines authentication and encryption protocols. Authentication is most commonly done using one of two techniques: by 802.1X and a backend authentication service such as RADIUS, or by a minimal handshake between the station and the access point using a pre-shared secret. The former is commonly termed WPA Enterprise with the latter known as WPA Personal. Since most people will not set up a RADIUS backend server for wireless network, WPA-PSK is by far the most commonly encountered configuration for WPA.</p></div><div class=paragraph><p>The control of the wireless connection and the authentication (key negotiation or authentication with a server) is done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> utility. This program requires a configuration file, <span class=filename>/etc/wpa_supplicant.conf</span>, to run. More information regarding this file can be found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a> manual page.</p></div><div class=sect5><h6 id=network-wireless-wpa-wpa-psk>31.3.3.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h6><div class=paragraph><p>WPA-PSK also known as WPA-Personal is based on a pre-shared key (PSK) generated from a given password and that will be used as the master key in the wireless network. This means every wireless user will share the same key. WPA-PSK is intended for small networks where the use of an authentication server is not possible or desired.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Always use strong passwords that are sufficiently long and made from a rich alphabet so they will not be guessed and/or attacked.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The first step is the configuration of the <span class=filename>/etc/wpa_supplicant.conf</span> file with the SSID and the pre-shared key of your network:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Then, in <span class=filename>/etc/rc.conf</span>, we indicate that the wireless device configuration will be done with WPA and the IP address will be obtained with DHCP:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, we can bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on ath0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on ath0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/36Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA privacy ON deftxkey UNDEF TKIP 2:128-bit txpowmax 36
      protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class=paragraph><p>Or you can try to configure it manually using the same <span class=filename>/etc/wpa_supplicant.conf</span> <a href=#network-wireless-wpa-wpa-psk>above</a>, and run:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i ath0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>TKIP <span class=nv>GTK</span><span class=o>=</span>TKIP]</code></pre></div></div><div class=paragraph><p>The next operation is the launch of the <code>dhclient</code> command to get the IP address from the DHCP server:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient ath0</span>
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig ath0</span>
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/48Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA privacy ON deftxkey UNDEF TKIP 2:128-bit txpowmax 36
      protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the <span class=filename>/etc/rc.conf</span> is set up with the line <code>ifconfig_ath0="DHCP"</code> then it is no need to run the <code>dhclient</code> command manually, <code>dhclient</code> will be launched after <code>wpa_supplicant</code> plumbs the keys.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In the case where the use of DHCP is not possible, you can set a static IP address after <code>wpa_supplicant</code> has authenticated the station:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig ath0</span>
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/36Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA privacy ON deftxkey UNDEF TKIP 2:128-bit txpowmax 36
      protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class=paragraph><p>When DHCP is not used, you also have to manually set up the default gateway and the nameserver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-tls>31.3.3.1.3.2. WPA with EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h6><div class=paragraph><p>The second way to use WPA is with an 802.1X backend authentication server, in this case WPA is called WPA-Enterprise to make difference with the less secure WPA-Personal with its pre-shared key. The authentication in WPA-Enterprise is based on EAP (Extensible Authentication Protocol).</p></div><div class=paragraph><p>EAP does not come with an encryption method, it was decided to embed EAP inside an encrypted tunnel. Many types of EAP authentication methods have been designed, the most common methods are EAP-TLS, EAP-TTLS and EAP-PEAP.</p></div><div class=paragraph><p>EAP-TLS (EAP with Transport Layer Security) is a very well-supported authentication protocol in the wireless world since it was the first EAP method to be certified by the <a href=http://www.wi-fi.org/>Wi-Fi alliance</a>. EAP-TLS will require three certificates to run: the CA certificate (installed on all machines), the server certificate for your authentication server, and one client certificate for each wireless client. In this EAP method, both authentication server and wireless client authenticate each other in presenting their respective certificates, and they verify that these certificates were signed by your organization’s certificate authority (CA).</p></div><div class=paragraph><p>As previously, the configuration is done via <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field indicates the network name (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Here, we use RSN (IEEE 802.11i) protocol, i.e., WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>key_mgmt</code> line refers to the key management protocol we use. In our case it is WPA using EAP authentication: <code>WPA-EAP</code>.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>In this field, we mention the EAP method for our connection.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The <code>identity</code> field contains the identity string for EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificat.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>The <code>client_cert</code> line gives the pathname to the client certificate file. This certificate is unique to each wireless client of the network.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The <code>private_key</code> field is the pathname to the client certificate private key file.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>The <code>private_key_passwd</code> field contains the passphrase for the private key.</td></tr></tbody></table></div><div class=paragraph><p>Then add the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface with the help of the <span class=filename>rc.d</span> facility:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/11Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy ON deftxkey UNDEF TKIP 2:128-bit
      txpowmax 36 protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class=paragraph><p>As previously shown, it is also possible to bring up the interface manually with both <code>wpa_supplicant</code> and <code>ifconfig</code> commands.</p></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-ttls>31.3.3.1.3.3. WPA with EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h6><div class=paragraph><p>With EAP-TLS both the authentication server and the client need a certificate, with EAP-TTLS (EAP-Tunneled Transport Layer Security) a client certificate is optional. This method is close to what some secure web sites do , where the web server can create a secure SSL tunnel even if the visitors do not have client-side certificates. EAP-TTLS will use the encrypted TLS tunnel for safe transport of the authentication data.</p></div><div class=paragraph><p>The configuration is done via the <span class=filename>/etc/wpa_supplicant.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>In this field, we mention the EAP method for our connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificat.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>In this field, we mention the authentication method used in the encrypted TLS tunnel. In our case, EAP with MD5-Challenge has been used. The "inner authentication" phase is often called "phase2".</td></tr></tbody></table></div><div class=paragraph><p>You also have to add the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/11Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy ON deftxkey UNDEF TKIP 2:128-bit
      txpowmax 36 protmode CTS roaming MANUAL bintval 100</code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-peap>31.3.3.1.3.4. WPA with EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h6><div class=paragraph><p>PEAP (Protected EAP) has been designed as an alternative to EAP-TTLS. There are two types of PEAP methods, the most common one is PEAPv0/EAP-MSCHAPv2. In the rest of this document, we will use the PEAP term to refer to that EAP method. PEAP is the most used EAP standard after EAP-TLS, in other words if you have a network with mixed OSes, PEAP should be the most supported standard after EAP-TLS.</p></div><div class=paragraph><p>PEAP is similar to EAP-TTLS: it uses a server-side certificate to authenticate clients by creating an encrypted TLS tunnel between the client and the authentication server, which protects the ensuing exchange of authentication information. In term of security the difference between EAP-TTLS and PEAP is that PEAP authentication broadcasts the username in clear, only the password is sent in the encrypted TLS tunnel. EAP-TTLS will use the TLS tunnel for both username and password.</p></div><div class=paragraph><p>We have to edit the <span class=filename>/etc/wpa_supplicant.conf</span> file and add the EAP-PEAP related settings:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>In this field, we mention the EAP method for our connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificat.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>This field contains the parameters for the first phase of the authentication (the TLS tunnel). According to the authentication server used, you will have to specify a specific label for the authentication. Most of time, the label will be "client EAP encryption" which is set by using <code>peaplabel=0</code>. More information can be found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a> manual page.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>In this field, we mention the authentication protocol used in the encrypted TLS tunnel. In the case of PEAP, it is <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>The following must be added to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, we can bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/11Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy ON deftxkey UNDEF TKIP 2:128-bit
      txpowmax 36 protmode CTS roaming MANUAL bintval 100</code></pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wep>31.3.3.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h5><div class=paragraph><p>WEP (Wired Equivalent Privacy) is part of the original 802.11 standard. There is no authentication mechanism, only a weak form of access control, and it is easily to be cracked.</p></div><div class=paragraph><p>WEP can be set up with <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.1.100 netmask 255.255.255.0 ssid my_net \</span>
	    wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p>The <code>weptxkey</code> means which WEP key will be used in the transmission. Here we used the third key. This must match the setting in the access point.</p></li><li><p>The <code>wepkey</code> means setting the selected WEP key. It should in the format <em>index:key</em>, if the index is not given, key <code>1</code> is set. That is to say we need to set the index if we use keys other than the first key.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>You must replace the <code>0x3456789012</code> with the key configured for use on the access point.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>You are encouraged to read <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> manual page for further information.</p></div><div class=paragraph><p>The <code>wpa_supplicant</code> facility also can be used to configure your wireless interface with WEP. The example above can be set up by adding the following lines to <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Then:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i ath0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect2><h3 id=_ad_hoc_mode>31.3.4. Ad-hoc Mode<a class=anchor href=#_ad_hoc_mode></a></h3><div class=paragraph><p>IBSS mode, also called ad-hoc mode, is designed for point to point connections. For example, to establish an ad-hoc network between the machine <code>A</code> and the machine <code>B</code> we will just need to choose two IP adresses and a SSID.</p></div><div class=paragraph><p>On the box <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mediaopt adhoc</span>
<span class=c># ifconfig ath0</span>
  ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect &lt;adhoc&gt; <span class=o>(</span>autoselect &lt;adhoc&gt;<span class=o>)</span>
	  status: associated
	  ssid freebsdap channel 2 bssid 02:11:95:c3:0d:ac
	  authmode OPEN privacy OFF txpowmax 36 protmode CTS bintval 100</code></pre></div></div><div class=paragraph><p>The <code>adhoc</code> parameter indicates the interface is running in the IBSS mode.</p></div><div class=paragraph><p>On <code>B</code>, we should be able to detect <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 up scan</span>
  SSID            BSSID              CHAN RATE  S:N   INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M 19:0   100 IS</code></pre></div></div><div class=paragraph><p>The <code>I</code> in the output confirms the machine <code>A</code> is in ad-hoc mode. We just have to configure <code>B</code> with a different IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap mediaopt adhoc</span>
<span class=c># ifconfig ath0</span>
  ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	  inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  ether 00:11:95:d5:43:62
	  media: IEEE 802.11 Wireless Ethernet autoselect &lt;adhoc&gt; <span class=o>(</span>autoselect &lt;adhoc&gt;<span class=o>)</span>
	  status: associated
	  ssid freebsdap channel 2 bssid 02:11:95:c3:0d:ac
	  authmode OPEN privacy OFF txpowmax 36 protmode CTS bintval 100</code></pre></div></div><div class=paragraph><p>Both <code>A</code> and <code>B</code> are now ready to exchange informations.</p></div></div><div class=sect2><h3 id=_troubleshooting_2>31.3.5. Troubleshooting<a class=anchor href=#_troubleshooting_2></a></h3><div class=paragraph><p>If you are having trouble with wireless networking, there are a number of steps you can take to help troubleshoot the problem.</p></div><div class=ulist><ul><li><p>If you do not see the access point listed when scanning be sure you have not configured your wireless device to a limited set of channels.</p></li><li><p>If you cannot associate to an access point verify the configuration of your station matches the one of the access point. This includes the authentication scheme and any security protocols. Simplify your configuration as much as possible. If you are using a security protocol such as WPA or WEP configure the access point for open authentication and no security to see if you can get traffic to pass.</p></li><li><p>Once you can associate to the access point diagnose any security configuration using simple tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p><div class=paragraph><p>The <code>wpa_supplicant</code> has much debugging support; try running it manually with the <code>-dd</code> option and look at the system logs.</p></div></li><li><p>There are also many lower-level debugging tools. You can enable debugging messages in the 802.11 protocol support layer using the <code>wlandebug</code> program found in <span class=filename>/usr/src/tools/tools/net80211</span>. For example:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i ath0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>can be used to enable console messages related to scanning for access points and doing the 802.11 protocol handshakes required to arrange communication.</p></div><div class=paragraph><p>There are also many useful statistics maintained by the 802.11 layer; the <code>wlanstats</code> tool will dump these informations. These statistics should identify all errors identified by the 802.11 layer. Beware however that some errors are identified in the device drivers that lie below the 802.11 layer so they may not show up. To diagnose device-specific problems you need to refer to the drivers' documentation.</p></div></li></ul></div><div class=paragraph><p>If the above information does not help to clarify the problem, please submit a problem report and include output from the above tools.</p></div></div></div></div><div class=sect1><h2 id=network-bluetooth>31.4. Bluetooth<a class=anchor href=#network-bluetooth></a></h2><div class=sectionbody><div class=sect2><h3 id=_introduction>31.4.1. Introduction<a class=anchor href=#_introduction></a></h3><div class=paragraph><p>Bluetooth is a wireless technology for creating personal networks operating in the 2.4 GHz unlicensed band, with a range of 10 meters. Networks are usually formed ad-hoc from portable devices such as cellular phones, handhelds and laptops. Unlike the other popular wireless technology, Wi-Fi, Bluetooth offers higher level service profiles, e.g. FTP-like file servers, file pushing, voice transport, serial line emulation, and more.</p></div><div class=paragraph><p>The Bluetooth stack in FreeBSD is implemented using the Netgraph framework (see <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>). A broad variety of Bluetooth USB dongles is supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> driver. The Broadcom BCM2033 chip based Bluetooth devices are supported via the <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> drivers. The 3Com Bluetooth PC Card 3CRWB60-A is supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a> driver. Serial and UART based Bluetooth devices are supported via <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>. This section describes the use of the USB Bluetooth dongle.</p></div></div><div class=sect2><h3 id=_plugging_in_the_device>31.4.2. Plugging in the Device<a class=anchor href=#_plugging_in_the_device></a></h3><div class=paragraph><p>By default Bluetooth device drivers are available as kernel modules. Before attaching a device, you will need to load the driver into the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>If the Bluetooth device is present in the system during system startup, load the module from <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Plug in your USB dongle. The output similar to the following will appear on the console (or in syslog):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The Bluetooth stack has to be started manually on FreeBSD 6.0, and on FreeBSD 5.X before 5.5. It is done automatically from <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> on FreeBSD 5.5, 6.1 and newer.</p></div><div class=paragraph><p>Copy <span class=filename>/usr/shared/examples/netgraph/bluetooth/rc.bluetooth</span> into some convenient place, like <span class=filename>/etc/rc.bluetooth</span>. This script is used to start and stop the Bluetooth stack. It is a good idea to stop the stack before unplugging the device, but it is not (usually) fatal. When starting the stack, you will receive output similar to the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_host_controller_interface_hci>31.4.3. Host Controller Interface (HCI)<a class=anchor href=#_host_controller_interface_hci></a></h3><div class=paragraph><p>Host Controller Interface (HCI) provides a command interface to the baseband controller and link manager, and access to hardware status and control registers. This interface provides a uniform method of accessing the Bluetooth baseband capabilities. HCI layer on the Host exchanges data and commands with the HCI firmware on the Bluetooth hardware. The Host Controller Transport Layer (i.e. physical bus) driver provides both HCI layers with the ability to exchange information with each other.</p></div><div class=paragraph><p>A single Netgraph node of type <em>hci</em> is created for a single Bluetooth device. The HCI node is normally connected to the Bluetooth device driver node (downstream) and the L2CAP node (upstream). All HCI operations must be performed on the HCI node and not on the device driver node. Default name for the HCI node is "devicehci". For more details refer to the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a> manual page.</p></div><div class=paragraph><p>One of the most common tasks is discovery of Bluetooth devices in RF proximity. This operation is called <em>inquiry</em>. Inquiry and other HCI related operations are done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a> utility. The example below shows how to find out which Bluetooth devices are in range. You should receive the list of devices in a few seconds. Note that a remote device will only answer the inquiry if it put into <em>discoverable</em> mode.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> is unique address of a Bluetooth device, similar to MAC addresses of a network card. This address is needed for further communication with a device. It is possible to assign human readable name to a BD_ADDR. The <span class=filename>/etc/bluetooth/hosts</span> file contains information regarding the known Bluetooth hosts. The following example shows how to obtain human readable name that was assigned to the remote device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>If you perform an inquiry on a remote Bluetooth device, it will find your computer as "your.host.name (ubt0)". The name assigned to the local device can be changed at any time.</p></div><div class=paragraph><p>The Bluetooth system provides a point-to-point connection (only two Bluetooth units involved), or a point-to-multipoint connection. In the point-to-multipoint connection the connection is shared among several Bluetooth devices. The following example shows how to obtain the list of active baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>A <em>connection handle</em> is useful when termination of the baseband connection is required. Note, that it is normally not required to do it by hand. The stack will automatically terminate inactive baseband connections.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Refer to <code>hccontrol help</code> for a complete listing of available HCI commands. Most of the HCI commands do not require superuser privileges.</p></div></div><div class=sect2><h3 id=_logical_link_control_and_adaptation_protocol_l2cap>31.4.4. Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_logical_link_control_and_adaptation_protocol_l2cap></a></h3><div class=paragraph><p>Logical Link Control and Adaptation Protocol (L2CAP) provides connection-oriented and connectionless data services to upper layer protocols with protocol multiplexing capability and segmentation and reassembly operation. L2CAP permits higher level protocols and applications to transmit and receive L2CAP data packets up to 64 kilobytes in length.</p></div><div class=paragraph><p>L2CAP is based around the concept of <em>channels</em>. Channel is a logical connection on top of baseband connection. Each channel is bound to a single protocol in a many-to-one fashion. Multiple channels can be bound to the same protocol, but a channel cannot be bound to multiple protocols. Each L2CAP packet received on a channel is directed to the appropriate higher level protocol. Multiple channels can share the same baseband connection.</p></div><div class=paragraph><p>A single Netgraph node of type <em>l2cap</em> is created for a single Bluetooth device. The L2CAP node is normally connected to the Bluetooth HCI node (downstream) and Bluetooth sockets nodes (upstream). Default name for the L2CAP node is "devicel2cap". For more details refer to the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a> manual page.</p></div><div class=paragraph><p>A useful command is <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, which can be used to ping other devices. Some Bluetooth implementations might not return all of the data sent to them, so <code>0 bytes</code> in the following example is normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> utility is used to perform various operations on L2CAP nodes. This example shows how to obtain the list of logical connections (channels) and the list of baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Another diagnostic tool is <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. It does a job similar to as <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> does, but for Bluetooth network-related data structures. The example below shows the same logical connection as <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> above.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect2><h3 id=_rfcomm_protocol>31.4.5. RFCOMM Protocol<a class=anchor href=#_rfcomm_protocol></a></h3><div class=paragraph><p>The RFCOMM protocol provides emulation of serial ports over the L2CAP protocol. The protocol is based on the ETSI standard TS 07.10. RFCOMM is a simple transport protocol, with additional provisions for emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports. The RFCOMM protocol supports up to 60 simultaneous connections (RFCOMM channels) between two Bluetooth devices.</p></div><div class=paragraph><p>For the purposes of RFCOMM, a complete communication path involves two applications running on different devices (the communication endpoints) with a communication segment between them. RFCOMM is intended to cover applications that make use of the serial ports of the devices in which they reside. The communication segment is a Bluetooth link from one device to another (direct connect).</p></div><div class=paragraph><p>RFCOMM is only concerned with the connection between the devices in the direct connect case, or between the device and a modem in the network case. RFCOMM can support other configurations, such as modules that communicate via Bluetooth wireless technology on one side and provide a wired interface on the other side.</p></div><div class=paragraph><p>In FreeBSD the RFCOMM protocol is implemented at the Bluetooth sockets layer.</p></div></div><div class=sect2><h3 id=_pairing_of_devices>31.4.6. Pairing of Devices<a class=anchor href=#_pairing_of_devices></a></h3><div class=paragraph><p>By default, Bluetooth communication is not authenticated, and any device can talk to any other device. A Bluetooth device (for example, cellular phone) may choose to require authentication to provide a particular service (for example, Dial-Up service). Bluetooth authentication is normally done with <em>PIN codes</em>. A PIN code is an ASCII string up to 16 characters in length. User is required to enter the same PIN code on both devices. Once user has entered the PIN code, both devices will generate a <em>link key</em>. After that the link key can be stored either in the devices themselves or in a persistent storage. Next time both devices will use previously generated link key. The described above procedure is called <em>pairing</em>. Note that if the link key is lost by any device then pairing must be repeated.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon is responsible for handling of all Bluetooth authentication requests. The default configuration file is <span class=filename>/etc/bluetooth/hcsecd.conf</span>. An example section for a cellular phone with the PIN code arbitrarily set to "1234" is shown below:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>There is no limitation on PIN codes (except length). Some devices (for example Bluetooth headsets) may have a fixed PIN code built in. The <code>-d</code> switch forces the <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon to stay in the foreground, so it is easy to see what is happening. Set the remote device to receive pairing and initiate the Bluetooth connection to the remote device. The remote device should say that pairing was accepted, and request the PIN code. Enter the same PIN code as you have in <span class=filename>hcsecd.conf</span>. Now your PC and the remote device are paired. Alternatively, you can initiate pairing on the remote device.</p></div><div class=paragraph><p>On FreeBSD 5.5, 6.1 and newer, the following line can be added to the <span class=filename>/etc/rc.conf</span> file to have hcsecd started automatically on system start:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The following is a sample of the hcsecd daemon output:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect2><h3 id=_service_discovery_protocol_sdp>31.4.7. Service Discovery Protocol (SDP)<a class=anchor href=#_service_discovery_protocol_sdp></a></h3><div class=paragraph><p>The Service Discovery Protocol (SDP) provides the means for client applications to discover the existence of services provided by server applications as well as the attributes of those services. The attributes of a service include the type or class of service offered and the mechanism or protocol information needed to utilize the service.</p></div><div class=paragraph><p>SDP involves communication between a SDP server and a SDP client. The server maintains a list of service records that describe the characteristics of services associated with the server. Each service record contains information about a single service. A client may retrieve information from a service record maintained by the SDP server by issuing a SDP request. If the client, or an application associated with the client, decides to use a service, it must open a separate connection to the service provider in order to utilize the service. SDP provides a mechanism for discovering services and their attributes, but it does not provide a mechanism for utilizing those services.</p></div><div class=paragraph><p>Normally, a SDP client searches for services based on some desired characteristics of the services. However, there are times when it is desirable to discover which types of services are described by an SDP server’s service records without any a priori information about the services. This process of looking for any offered services is called <em>browsing</em>.</p></div><div class=paragraph><p>The Bluetooth SDP server <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> and command line client <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> are included in the standard FreeBSD installation. The following example shows how to perform a SDP browse query.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>and so on. Note that each service has a list of attributes (RFCOMM channel for example). Depending on the service you might need to make a note of some of the attributes. Some Bluetooth implementations do not support service browsing and may return an empty list. In this case it is possible to search for the specific service. The example below shows how to search for the OBEX Object Push (OPUSH) service:</p></li></ol></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Offering services on FreeBSD to Bluetooth clients is done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server. On FreeBSD 5.5, 6.1 and newer, the following line can be added to the <span class=filename>/etc/rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then the sdpd daemon can be started with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sdpd start</span></code></pre></div></div><div class=paragraph><p>On FreeBSD 6.0, and on FreeBSD 5.X before 5.5, sdpd is not integrated into the system startup scripts. It has to be started manually with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpd</span></code></pre></div></div><div class=paragraph><p>The local server application that wants to provide Bluetooth service to the remote clients will register service with the local SDP daemon. The example of such application is <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Once started it will register Bluetooth LAN service with the local SDP daemon.</p></div><div class=paragraph><p>The list of services registered with the local SDP server can be obtained by issuing SDP browse query via local control channel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect2><h3 id=_dial_up_networking_dun_and_network_access_with_ppp_lan_profiles>31.4.8. Dial-Up Networking (DUN) and Network Access with PPP (LAN) Profiles<a class=anchor href=#_dial_up_networking_dun_and_network_access_with_ppp_lan_profiles></a></h3><div class=paragraph><p>The Dial-Up Networking (DUN) profile is mostly used with modems and cellular phones. The scenarios covered by this profile are the following:</p></div><div class=ulist><ul><li><p>use of a cellular phone or modem by a computer as a wireless modem for connecting to a dial-up Internet access server, or using other dial-up services;</p></li><li><p>use of a cellular phone or modem by a computer to receive data calls.</p></li></ul></div><div class=paragraph><p>Network Access with PPP (LAN) profile can be used in the following situations:</p></div><div class=ulist><ul><li><p>LAN access for a single Bluetooth device;</p></li><li><p>LAN access for multiple Bluetooth devices;</p></li><li><p>PC to PC (using PPP networking over serial cable emulation).</p></li></ul></div><div class=paragraph><p>In FreeBSD both profiles are implemented with <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> - a wrapper that converts RFCOMM Bluetooth connection into something PPP can operate with. Before any profile can be used, a new PPP label in the <span class=filename>/etc/ppp/ppp.conf</span> must be created. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> manual page for examples.</p></div><div class=paragraph><p>In the following example <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> will be used to open RFCOMM connection to remote device with BD_ADDR 00:80:37:29:19:a4 on DUN RFCOMM channel. The actual RFCOMM channel number will be obtained from the remote device via SDP. It is possible to specify RFCOMM channel by hand, and in this case <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> will not perform SDP query. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> to find out RFCOMM channel on the remote device.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>In order to provide Network Access with PPP (LAN) service the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server must be running. A new entry for LAN clients must be created in the <span class=filename>/etc/ppp/ppp.conf</span> file. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> manual page for examples. Finally, start RFCOMM PPP server on valid RFCOMM channel number. The RFCOMM PPP server will automatically register Bluetooth LAN service with the local SDP daemon. The example below shows how to start RFCOMM PPP server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect2><h3 id=_obex_object_push_opush_profile>31.4.9. OBEX Object Push (OPUSH) Profile<a class=anchor href=#_obex_object_push_opush_profile></a></h3><div class=paragraph><p>OBEX is a widely used protocol for simple file transfers between mobile devices. Its main use is in infrared communication, where it is used for generic file transfers between notebooks or PDAs, and for sending business cards or calendar entries between cellular phones and other devices with PIM applications.</p></div><div class=paragraph><p>The OBEX server and client are implemented as a third-party package obexapp, which is available as <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a> port.</p></div><div class=paragraph><p>OBEX client is used to push and/or pull objects from the OBEX server. An object can, for example, be a business card or an appointment. The OBEX client can obtain RFCOMM channel number from the remote device via SDP. This can be done by specifying service name instead of RFCOMM channel number. Supported service names are: IrMC, FTRN and OPUSH. It is possible to specify RFCOMM channel as a number. Below is an example of an OBEX session, where device information object is pulled from the cellular phone, and a new object (business card) is pushed into the phone’s directory.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In order to provide OBEX Object Push service, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server must be running. A root folder, where all incoming objects will be stored, must be created. The default path to the root folder is <span class=filename>/var/spool/obex</span>. Finally, start OBEX server on valid RFCOMM channel number. The OBEX server will automatically register OBEX Object Push service with the local SDP daemon. The example below shows how to start OBEX server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect2><h3 id=_serial_port_profile_spp>31.4.10. Serial Port Profile (SPP)<a class=anchor href=#_serial_port_profile_spp></a></h3><div class=paragraph><p>The Serial Port Profile (SPP) allows Bluetooth devices to perform RS232 (or similar) serial cable emulation. The scenario covered by this profile deals with legacy applications using Bluetooth as a cable replacement, through a virtual serial port abstraction.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> utility implements the Serial Port profile. A pseudo tty is used as a virtual serial port abstraction. The example below shows how to connect to a remote device Serial Port service. Note that you do not have to specify a RFCOMM channel - <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> can obtain it from the remote device via SDP. If you would like to override this, specify a RFCOMM channel on the command line.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</span>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</code></pre></div></div><div class=paragraph><p>Once connected, the pseudo tty can be used as serial port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l ttyp6</span></code></pre></div></div></div><div class=sect2><h3 id=_troubleshooting_3>31.4.11. Troubleshooting<a class=anchor href=#_troubleshooting_3></a></h3><div class=sect3><h4 id=_a_remote_device_cannot_connect>31.4.11.1. A remote device cannot connect<a class=anchor href=#_a_remote_device_cannot_connect></a></h4><div class=paragraph><p>Some older Bluetooth devices do not support role switching. By default, when FreeBSD is accepting a new connection, it tries to perform a role switch and become master. Devices, which do not support this will not be able to connect. Note that role switching is performed when a new connection is being established, so it is not possible to ask the remote device if it does support role switching. There is a HCI option to disable role switching on the local side:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div></div><div class=sect3><h4 id=_something_is_going_wrong_can_i_see_what_exactly_is_happening>31.4.11.2. Something is going wrong, can I see what exactly is happening?<a class=anchor href=#_something_is_going_wrong_can_i_see_what_exactly_is_happening></a></h4><div class=paragraph><p>Yes, you can. Use the third-party package hcidump, which is available as <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> port. The hcidump utility is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. It can be used to display the content of the Bluetooth packets on the terminal and to dump the Bluetooth packets to a file.</p></div></div></div></div></div><div class=sect1><h2 id=network-bridging>31.5. Bridging<a class=anchor href=#network-bridging></a></h2><div class=sectionbody><div class=sect2><h3 id=_introduction_2>31.5.1. Introduction<a class=anchor href=#_introduction_2></a></h3><div class=paragraph><p>It is sometimes useful to divide one physical network (such as an Ethernet segment) into two separate network segments without having to create IP subnets and use a router to connect the segments together. A device that connects two networks together in this fashion is called a "bridge". A FreeBSD system with two network interface cards can act as a bridge.</p></div><div class=paragraph><p>The bridge works by learning the MAC layer addresses (Ethernet addresses) of the devices on each of its network interfaces. It forwards traffic between two networks only when its source and destination are on different networks.</p></div><div class=paragraph><p>In many respects, a bridge is like an Ethernet switch with very few ports.</p></div></div><div class=sect2><h3 id=_situations_where_bridging_is_appropriate>31.5.2. Situations Where Bridging Is Appropriate<a class=anchor href=#_situations_where_bridging_is_appropriate></a></h3><div class=paragraph><p>There are two common situations in which a bridge is used today.</p></div><div class=sect3><h4 id=_high_traffic_on_a_segment>31.5.2.1. High Traffic on a Segment<a class=anchor href=#_high_traffic_on_a_segment></a></h4><div class=paragraph><p>Situation one is where your physical network segment is overloaded with traffic, but you do not want for whatever reason to subnet the network and interconnect the subnets with a router.</p></div><div class=paragraph><p>Let us consider an example of a newspaper where the Editorial and Production departments are on the same subnetwork. The Editorial users all use server <code>A</code> for file service, and the Production users are on server <code>B</code>. An Ethernet network is used to connect all users together, and high loads on the network are slowing things down.</p></div><div class=paragraph><p>If the Editorial users could be segregated on one network segment and the Production users on another, the two network segments could be connected with a bridge. Only the network traffic destined for interfaces on the "other" side of the bridge would be sent to the other network, reducing congestion on each network segment.</p></div></div><div class=sect3><h4 id=_filteringtraffic_shaping_firewall>31.5.2.2. Filtering/Traffic Shaping Firewall<a class=anchor href=#_filteringtraffic_shaping_firewall></a></h4><div class=paragraph><p>The second common situation is where firewall functionality is needed without network address translation (NAT).</p></div><div class=paragraph><p>An example is a small company that is connected via DSL or ISDN to their ISP. They have a 13 globally-accessible IP addresses from their ISP and have 10 PCs on their network. In this situation, using a router-based firewall is difficult because of subnetting issues.</p></div><div class=paragraph><p>A bridge-based firewall can be configured and dropped into the path just downstream of their DSL/ISDN router without any IP numbering issues.</p></div></div></div><div class=sect2><h3 id=_configuring_a_bridge>31.5.3. Configuring a Bridge<a class=anchor href=#_configuring_a_bridge></a></h3><div class=sect3><h4 id=_network_interface_card_selection>31.5.3.1. Network Interface Card Selection<a class=anchor href=#_network_interface_card_selection></a></h4><div class=paragraph><p>A bridge requires at least two network cards to function. Unfortunately, not all network interface cards support bridging. Read <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> for details on the cards that are supported.</p></div><div class=paragraph><p>Install and test the two network cards before continuing.</p></div></div><div class=sect3><h4 id=_kernel_configuration_changes>31.5.3.2. Kernel Configuration Changes<a class=anchor href=#_kernel_configuration_changes></a></h4><div class=paragraph><p>To enable kernel support for bridging, add the:</p></div><div class="literalblock programlisting"><div class=content><pre>options BRIDGE</pre></div></div><div class=paragraph><p>statement to your kernel configuration file, and rebuild your kernel.</p></div></div><div class=sect3><h4 id=_firewall_support>31.5.3.3. Firewall Support<a class=anchor href=#_firewall_support></a></h4><div class=paragraph><p>If you are planning to use the bridge as a firewall, you will need to add the <code>IPFIREWALL</code> option as well. Read <a href=../firewalls/#firewalls>Firewalls</a> for general information on configuring the bridge as a firewall.</p></div><div class=paragraph><p>If you need to allow non-IP packets (such as ARP) to flow through the bridge, there are three options available. The first is to add the following option to the kernel and rebuild:</p></div><div class="literalblock programlisting"><div class=content><pre>option	IPFIREWALL_DEFAULT_TO_ACCEPT</pre></div></div><div class=paragraph><p>The second is to set the firewall type to “open” in the <span class=filename>rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>firewall_type=&#34;open&#34;</pre></div></div><div class=paragraph><p>Note that these options will make the firewall seem completely transparent; any packet or connection will be permitted by default. This may require significant changes to the firewall ruleset.</p></div><div class=paragraph><p>The third option is to apply the following <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> rule:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw add allow mac-type arp layer2</span></code></pre></div></div><div class=paragraph><p>Or add it to the current firewall ruleset. This rule effectively allows <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> packets through, so it must be be applied near the beginning of the ruleset for early evaluation.</p></div></div><div class=sect3><h4 id=_traffic_shaping_support>31.5.3.4. Traffic Shaping Support<a class=anchor href=#_traffic_shaping_support></a></h4><div class=paragraph><p>If you want to use the bridge as a traffic shaper, you will need to add the <code>DUMMYNET</code> option to your kernel configuration. Read <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> for further information.</p></div></div></div><div class=sect2><h3 id=_enabling_the_bridge>31.5.4. Enabling the Bridge<a class=anchor href=#_enabling_the_bridge></a></h3><div class=paragraph><p>Add the line:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.enable=1</pre></div></div><div class=paragraph><p>to <span class=filename>/etc/sysctl.conf</span> to enable the bridge at runtime, and the line:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.config=if1,if2</pre></div></div><div class=paragraph><p>to enable bridging on the specified interfaces (replace <em>if1</em> and <em>if2</em> with the names of your two network interfaces). If you want the bridged packets to be filtered by <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, you should add:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.ipfw=1</pre></div></div><div class=paragraph><p>as well.</p></div><div class=paragraph><p>For versions prior to FreeBSD 5.2-RELEASE, use instead the following lines:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge=1
net.link.ether.bridge_cfg=if1,if2
net.link.ether.bridge_ipfw=1</pre></div></div></div><div class=sect2><h3 id=_other_information>31.5.5. Other Information<a class=anchor href=#_other_information></a></h3><div class=paragraph><p>If you want to be able to <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> into the bridge from the network, it is correct to assign one of the network cards an IP address. The consensus is that assigning both cards an address is a bad idea.</p></div><div class=paragraph><p>If you have multiple bridges on your network, there cannot be more than one path between any two workstations. Technically, this means that there is no support for spanning tree link management.</p></div><div class=paragraph><p>A bridge can add latency to your <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> times, especially for traffic from one segment to another.</p></div></div></div></div><div class=sect1><h2 id=network-diskless>31.6. Diskless Operation<a class=anchor href=#network-diskless></a></h2><div class=sectionbody><div class=paragraph><p>A FreeBSD machine can boot over the network and operate without a local disk, using file systems mounted from an NFS server. No system modification is necessary, beyond standard configuration files. Such a system is relatively easy to set up because all the necessary elements are readily available:</p></div><div class=ulist><ul><li><p>There are at least two possible methods to load the kernel over the network:</p><div class=ulist><ul><li><p>PXE: The Intel® Preboot eXecution Environment system is a form of smart boot ROM built into some networking cards or motherboards. See <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> for more details.</p></li><li><p>The Etherboot port (<a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a>) produces ROM-able code to boot kernels over the network. The code can be either burnt into a boot PROM on a network card, or loaded from a local floppy (or hard) disk drive, or from a running MS-DOS® system. Many network cards are supported.</p></li></ul></div></li><li><p>A sample script (<span class=filename>/usr/shared/examples/diskless/clone_root</span>) eases the creation and maintenance of the workstation’s root file system on the server. The script will probably require a little customization but it will get you started very quickly.</p></li><li><p>Standard system startup files exist in <span class=filename>/etc</span> to detect and support a diskless system startup.</p></li><li><p>Swapping, if needed, can be done either to an NFS file or to a local disk.</p></li></ul></div><div class=paragraph><p>There are many ways to set up diskless workstations. Many elements are involved, and most can be customized to suit local taste. The following will describe variations on the setup of a complete system, emphasizing simplicity and compatibility with the standard FreeBSD startup scripts. The system described has the following characteristics:</p></div><div class=ulist><ul><li><p>The diskless workstations use a shared read-only <span class=filename>/</span> file system, and a shared read-only <span class=filename>/usr</span>.</p><div class=paragraph><p>The root file system is a copy of a standard FreeBSD root (typically the server’s), with some configuration files overridden by ones specific to diskless operation or, possibly, to the workstation they belong to.</p></div><div class=paragraph><p>The parts of the root which have to be writable are overlaid with <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> file systems. Any changes will be lost when the system reboots.</p></div></li><li><p>The kernel is transferred and loaded either with Etherboot or PXE as some situations may mandate the use of either method.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>As described, this system is insecure. It should live in a protected area of a network, and be untrusted by other hosts.</p></div></td></tr></tbody></table></div><div class=paragraph><p>All the information in this section has been tested using FreeBSD 5.2.1-RELEASE.</p></div><div class=sect2><h3 id=_background_information>31.6.1. Background Information<a class=anchor href=#_background_information></a></h3><div class=paragraph><p>Setting up diskless workstations is both relatively straightforward and prone to errors. These are sometimes difficult to diagnose for a number of reasons. For example:</p></div><div class=ulist><ul><li><p>Compile time options may determine different behaviors at runtime.</p></li><li><p>Error messages are often cryptic or totally absent.</p></li></ul></div><div class=paragraph><p>In this context, having some knowledge of the background mechanisms involved is very useful to solve the problems that may arise.</p></div><div class=paragraph><p>Several operations need to be performed for a successful bootstrap:</p></div><div class=ulist><ul><li><p>The machine needs to obtain initial parameters such as its IP address, executable filename, server name, root path. This is done using the DHCP or BOOTP protocols. DHCP is a compatible extension of BOOTP, and uses the same port numbers and basic packet format.</p><div class=paragraph><p>It is possible to configure a system to use only BOOTP. The <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> server program is included in the base FreeBSD system.</p></div><div class=paragraph><p>However, DHCP has a number of advantages over BOOTP (nicer configuration files, possibility of using PXE, plus many others not directly related to diskless operation), and we will describe mainly a DHCP configuration, with equivalent examples using <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> when possible. The sample configuration will use the ISC DHCP software package (release 3.0.1.r12 was installed on the test server).</p></div></li><li><p>The machine needs to transfer one or several programs to local memory. Either TFTP or NFS are used. The choice between TFTP and NFS is a compile time option in several places. A common source of error is to specify filenames for the wrong protocol: TFTP typically transfers all files from a single directory on the server, and would expect filenames relative to this directory. NFS needs absolute file paths.</p></li><li><p>The possible intermediate bootstrap programs and the kernel need to be initialized and executed. There are several important variations in this area:</p><div class=ulist><ul><li><p>PXE will load <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a>, which is a modified version of the FreeBSD third stage loader. The <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> will obtain most parameters necessary to system startup, and leave them in the kernel environment before transferring control. It is possible to use a <span class=filename>GENERIC</span> kernel in this case.</p></li><li><p>Etherboot, will directly load the kernel, with less preparation. You will need to build a kernel with specific options.</p><div class=paragraph><p>PXE and Etherboot work equally well; however, because kernels normally let the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> do more work for them, PXE is the preferred method.</p></div><div class=paragraph><p>If your BIOS and network cards support PXE, you should probably use it.</p></div></li></ul></div></li><li><p>Finally, the machine needs to access its file systems. NFS is used in all cases.</p></li></ul></div><div class=paragraph><p>See also <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> manual page.</p></div></div><div class=sect2><h3 id=_setup_instructions>31.6.2. Setup Instructions<a class=anchor href=#_setup_instructions></a></h3><div class=sect3><h4 id=_configuration_using_isc_dhcp>31.6.2.1. Configuration Using ISC DHCP<a class=anchor href=#_configuration_using_isc_dhcp></a></h4><div class=paragraph><p>The ISC DHCP server can answer both BOOTP and DHCP requests.</p></div><div class=paragraph><p>ISC DHCP 3.0 is not part of the base system. You will first need to install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port or the corresponding package.</p></div><div class=paragraph><p>Once ISC DHCP is installed, it needs a configuration file to run (normally named <span class=filename>/usr/local/etc/dhcpd.conf</span>). Here follows a commented example, where host <code>margaux</code> uses Etherboot and host <code>corbieres</code> uses PXE:</p></div><div class="literalblock programlisting"><div class=content><pre>default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name &#34;example.com&#34;;
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <i class=conum data-value=1></i><b>(1)</b>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <i class=conum data-value=2></i><b>(2)</b>
    filename &#34;/data/misc/kernel.diskless&#34;; <i class=conum data-value=3></i><b>(3)</b>
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;; <i class=conum data-value=4></i><b>(4)</b>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename &#34;pxeboot&#34;;
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;;
  }
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This option tells dhcpd to send the value in the <code>host</code> declarations as the hostname for the diskless host. An alternate way would be to add an <code>option host-name margaux</code> inside the <code>host</code> declarations.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>next-server</code> directive designates the TFTP or NFS server to use for loading loader or kernel file (the default is to use the same host as the DHCP server).</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>filename</code> directive defines the file that Etherboot or PXE will load for the next execution step. It must be specified according to the transfer method used. Etherboot can be compiled to use NFS or TFTP. The FreeBSD port configures NFS by default. PXE uses TFTP, which is why a relative filename is used here (this may depend on the TFTP server configuration, but would be fairly typical). Also, PXE loads <span class=filename>pxeboot</span>, not the kernel. There are other interesting possibilities, like loading <span class=filename>pxeboot</span> from a FreeBSD CD-ROM <span class=filename>/boot</span> directory (as <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> can load a <span class=filename>GENERIC</span> kernel, this makes it possible to use PXE to boot from a remote CD-ROM).</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>root-path</code> option defines the path to the root file system, in usual NFS notation. When using PXE, it is possible to leave off the host’s IP as long as you do not enable the kernel option BOOTP. The NFS server will then be the same as the TFTP one.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_configuration_using_bootp>31.6.2.2. Configuration Using BOOTP<a class=anchor href=#_configuration_using_bootp></a></h4><div class=paragraph><p>Here follows an equivalent bootpd configuration (reduced to one client). This would be found in <span class=filename>/etc/bootptab</span>.</p></div><div class=paragraph><p>Please note that Etherboot must be compiled with the non-default option <code>NO_DHCP_SUPPORT</code> in order to use BOOTP, and that PXE_needs_DHCP. The only obvious advantage of bootpd is that it exists in the base system.</p></div><div class="literalblock programlisting"><div class=content><pre>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd=&#34;/tftpboot&#34;:\
  :bf=&#34;/kernel.diskless&#34;:\
  :rp=&#34;192.168.4.4:/data/misc/diskless&#34;:

margaux:ha=0123456789ab:tc=.def100</pre></div></div></div><div class=sect3><h4 id=_preparing_a_boot_program_with_etherboot>31.6.2.3. Preparing a Boot Program with Etherboot<a class=anchor href=#_preparing_a_boot_program_with_etherboot></a></h4><div class=paragraph><p><a href=http://etherboot.sourceforge.net>Etherboot’s Web site</a> contains <a href=http://etherboot.sourceforge.net/doc/html/userman/t1.html>extensive documentation</a> mainly intended for Linux systems, but nonetheless containing useful information. The following will just outline how you would use Etherboot on a FreeBSD system.</p></div><div class=paragraph><p>You must first install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a> package or port.</p></div><div class=paragraph><p>You can change the Etherboot configuration (i.e. to use TFTP instead of NFS) by editing the <span class=filename>Config</span> file in the Etherboot source directory.</p></div><div class=paragraph><p>For our setup, we shall use a boot floppy. For other methods (PROM, or MS-DOS® program), please refer to the Etherboot documentation.</p></div><div class=paragraph><p>To make a boot floppy, insert a floppy in the drive on the machine where you installed Etherboot, then change your current directory to the <span class=filename>src</span> directory in the Etherboot tree and type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmake bin32/devicetype.fd0</span></code></pre></div></div><div class=paragraph><p><em>devicetype</em> depends on the type of the Ethernet card in the diskless workstation. Refer to the <span class=filename>NIC</span> file in the same directory to determine the right <em>devicetype</em>.</p></div></div><div class=sect3><h4 id=_booting_with_pxe>31.6.2.4. Booting with PXE<a class=anchor href=#_booting_with_pxe></a></h4><div class=paragraph><p>By default, the <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> loader loads the kernel via NFS. It can be compiled to use TFTP instead by specifying the <code>LOADER_TFTP_SUPPORT</code> option in <span class=filename>/etc/make.conf</span>. See the comments in <span class=filename>/usr/shared/examples/etc/make.conf</span> for instructions.</p></div><div class=paragraph><p>There are two other <span class=filename>make.conf</span> options which may be useful for setting up a serial console diskless machine: <code>BOOT_PXELDR_PROBE_KEYBOARD</code>, and <code>BOOT_PXELDR_ALWAYS_SERIAL</code>.</p></div><div class=paragraph><p>To use PXE when the machine starts, you will usually need to select the <code>Boot from network</code> option in your BIOS setup, or type a function key during the PC initialization.</p></div></div><div class=sect3><h4 id=_configuring_the_tftp_and_nfs_servers>31.6.2.5. Configuring the TFTP and NFS Servers<a class=anchor href=#_configuring_the_tftp_and_nfs_servers></a></h4><div class=paragraph><p>If you are using PXE or Etherboot configured to use TFTP, you need to enable tftpd on the file server:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Create a directory from which tftpd will serve the files, e.g. <span class=filename>/tftpboot</span>.</p></li><li><p>Add this line to your <span class=filename>/etc/inetd.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It appears that at least some PXE versions want the TCP version of TFTP. In this case, add a second line, replacing <code>dgram udp</code> with <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Tell inetd to reread its configuration file. The <code>inetd_enable="YES"</code> must be in the <span class=filename>/etc/rc.conf</span> file for this command to execute correctly:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/inetd restart</span></code></pre></div></div></li></ol></div><div class=paragraph><p>You can place the <span class=filename>tftpboot</span> directory anywhere on the server. Make sure that the location is set in both <span class=filename>inetd.conf</span> and <span class=filename>dhcpd.conf</span>.</p></div><div class=paragraph><p>In all cases, you also need to enable NFS and export the appropriate file system on the NFS server.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Add this to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Export the file system where the diskless root directory is located by adding the following to <span class=filename>/etc/exports</span> (adjust the volume mount point and replace <em>margaux corbieres</em> with the names of the diskless workstations):</p><div class="literalblock programlisting"><div class=content><pre>/data/misc -alldirs -ro margaux corbieres</pre></div></div></li><li><p>Tell mountd to reread its configuration file. If you actually needed to enable NFS in <span class=filename>/etc/rc.conf</span> at the first step, you probably want to reboot instead.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/mountd restart</span></code></pre></div></div></li></ol></div></div><div class=sect3><h4 id=_building_a_diskless_kernel>31.6.2.6. Building a Diskless Kernel<a class=anchor href=#_building_a_diskless_kernel></a></h4><div class=paragraph><p>If using Etherboot, you need to create a kernel configuration file for the diskless client with the following options (in addition to the usual ones):</p></div><div class="literalblock programlisting"><div class=content><pre>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</pre></div></div><div class=paragraph><p>You may also want to use <code>BOOTP_NFSV3</code>, <code>BOOT_COMPAT</code> and <code>BOOTP_WIRED_TO</code> (refer to <span class=filename>NOTES</span>).</p></div><div class=paragraph><p>These option names are historical and slightly misleading as they actually enable indifferent use of DHCP and BOOTP inside the kernel (it is also possible to force strict BOOTP or DHCP use).</p></div><div class=paragraph><p>Build the kernel (see <a href=../kernelconfig/#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>), and copy it to the place specified in <span class=filename>dhcpd.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When using PXE, building a kernel with the above options is not strictly necessary (though suggested). Enabling them will cause more DHCP requests to be issued during kernel startup, with a small risk of inconsistency between the new values and those retrieved by <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> in some special cases. The advantage of using them is that the host name will be set as a side effect. Otherwise you will need to set the host name by another method, for example in a client-specific <span class=filename>rc.conf</span> file.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to be loadable with Etherboot, a kernel needs to have the device hints compiled in. You would typically set the following option in the configuration file (see the <span class=filename>NOTES</span> configuration comments file):</p></div><div class="literalblock programlisting"><div class=content><pre>hints		&#34;GENERIC.hints&#34;</pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_preparing_the_root_filesystem>31.6.2.7. Preparing the Root Filesystem<a class=anchor href=#_preparing_the_root_filesystem></a></h4><div class=paragraph><p>You need to create a root file system for the diskless workstations, in the location listed as <code>root-path</code> in <span class=filename>dhcpd.conf</span>.</p></div><div class=sect4><h5 id=_using_make_world_to_populate_root>31.6.2.7.1. Using <code>make world</code> to populate root<a class=anchor href=#_using_make_world_to_populate_root></a></h5><div class=paragraph><p>This method is quick and will install a complete virgin system (not only the root file system) into <code>DESTDIR</code>. All you have to do is simply execute the following script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
cd /usr/src/etc; make distribution</pre></div></div><div class=paragraph><p>Once done, you may need to customize your <span class=filename>/etc/rc.conf</span> and <span class=filename>/etc/fstab</span> placed into <code>DESTDIR</code> according to your needs.</p></div></div></div><div class=sect3><h4 id=_configuring_swap>31.6.2.8. Configuring Swap<a class=anchor href=#_configuring_swap></a></h4><div class=paragraph><p>If needed, a swap file located on the server can be accessed via NFS.</p></div><div class=sect4><h5 id=_nfs_swap>31.6.2.8.1. NFS Swap<a class=anchor href=#_nfs_swap></a></h5><div class=paragraph><p>The kernel does not support enabling NFS swap at boot time. Swap must be enabled by the startup scripts, by mounting a writable file system and creating and enabling a swap file. To create a swap file of appropriate size, you can do like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</span></code></pre></div></div><div class=paragraph><p>To enable it you have to add the following line to your <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>swapfile=/path/to/swapfile</pre></div></div></div></div><div class=sect3><h4 id=_miscellaneous_issues>31.6.2.9. Miscellaneous Issues<a class=anchor href=#_miscellaneous_issues></a></h4><div class=sect4><h5 id=_running_with_a_read_only_usr>31.6.2.9.1. Running with a Read-only <span class=filename>/usr</span><a class=anchor href=#_running_with_a_read_only_usr></a></h5><div class=paragraph><p>If the diskless workstation is configured to run X, you will have to adjust the XDM configuration file, which puts the error log on <span class=filename>/usr</span> by default.</p></div></div><div class=sect4><h5 id=_using_a_non_freebsd_server>31.6.2.9.2. Using a Non-FreeBSD Server<a class=anchor href=#_using_a_non_freebsd_server></a></h5><div class=paragraph><p>When the server for the root file system is not running FreeBSD, you will have to create the root file system on a FreeBSD machine, then copy it to its destination, using <code>tar</code> or <code>cpio</code>.</p></div><div class=paragraph><p>In this situation, there are sometimes problems with the special files in <span class=filename>/dev</span>, due to differing major/minor integer sizes. A solution to this problem is to export a directory from the non-FreeBSD server, mount this directory onto a FreeBSD machine, and use <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> to allocate device nodes transparently for the user.</p></div></div></div></div></div></div><div class=sect1><h2 id=network-isdn>31.7. ISDN<a class=anchor href=#network-isdn></a></h2><div class=sectionbody><div class=paragraph><p>A good resource for information on ISDN technology and hardware is <a href=http://www.alumni.caltech.edu/~dank/isdn/>Dan Kegel’s ISDN Page</a>.</p></div><div class=paragraph><p>A quick simple road map to ISDN follows:</p></div><div class=ulist><ul><li><p>If you live in Europe you might want to investigate the ISDN card section.</p></li><li><p>If you are planning to use ISDN primarily to connect to the Internet with an Internet Provider on a dial-up non-dedicated basis, you might look into Terminal Adapters. This will give you the most flexibility, with the fewest problems, if you change providers.</p></li><li><p>If you are connecting two LANs together, or connecting to the Internet with a dedicated ISDN connection, you might consider the stand alone router/bridge option.</p></li></ul></div><div class=paragraph><p>Cost is a significant factor in determining what solution you will choose. The following options are listed from least expensive to most expensive.</p></div><div class=sect2><h3 id=network-isdn-cards>31.7.1. ISDN Cards<a class=anchor href=#network-isdn-cards></a></h3><div class=paragraph><p>FreeBSD’s ISDN implementation supports only the DSS1/Q.931 (or Euro-ISDN) standard using passive cards. Some active cards are supported where the firmware also supports other signaling protocols; this also includes the first supported Primary Rate (PRI) ISDN card.</p></div><div class=paragraph><p>The isdn4bsd software allows you to connect to other ISDN routers using either IP over raw HDLC or by using synchronous PPP: either by using kernel PPP with <code>isppp</code>, a modified <a href="https://man.freebsd.org/cgi/man.cgi?query=sppp&amp;sektion=4&amp;format=html">sppp(4)</a> driver, or by using userland <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>. By using userland <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>, channel bonding of two or more ISDN B-channels is possible. A telephone answering machine application is also available as well as many utilities such as a software 300 Baud modem.</p></div><div class=paragraph><p>Some growing number of PC ISDN cards are supported under FreeBSD and the reports show that it is successfully used all over Europe and in many other parts of the world.</p></div><div class=paragraph><p>The passive ISDN cards supported are mostly the ones with the Infineon (formerly Siemens) ISAC/HSCX/IPAC ISDN chipsets, but also ISDN cards with chips from Cologne Chip (ISA bus only), PCI cards with Winbond W6692 chips, some cards with the Tiger300/320/ISAC chipset combinations and some vendor specific chipset based cards such as the AVM Fritz!Card PCI V.1.0 and the AVM Fritz!Card PnP.</p></div><div class=paragraph><p>Currently the active supported ISDN cards are the AVM B1 (ISA and PCI) BRI cards and the AVM T1 PCI PRI cards.</p></div><div class=paragraph><p>For documentation on isdn4bsd, have a look at <span class=filename>/usr/shared/examples/isdn/</span> directory on your FreeBSD system or at the <a href=http://www.freebsd-support.de/i4b/>homepage of isdn4bsd</a> which also has pointers to hints, erratas and much more documentation such as the <a href=http://people.FreeBSD.org/~hm/>isdn4bsd handbook</a>.</p></div><div class=paragraph><p>In case you are interested in adding support for a different ISDN protocol, a currently unsupported ISDN PC card or otherwise enhancing isdn4bsd, please get in touch with Hellmuth Michaelis &lt;<a href=mailto:hm@FreeBSD.org>hm@FreeBSD.org</a>>.</p></div><div class=paragraph><p>For questions regarding the installation, configuration and troubleshooting isdn4bsd, a <a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a> mailing list is available.</p></div></div><div class=sect2><h3 id=_isdn_terminal_adapters>31.7.2. ISDN Terminal Adapters<a class=anchor href=#_isdn_terminal_adapters></a></h3><div class=paragraph><p>Terminal adapters (TA), are to ISDN what modems are to regular phone lines.</p></div><div class=paragraph><p>Most TA’s use the standard Hayes modem AT command set, and can be used as a drop in replacement for a modem.</p></div><div class=paragraph><p>A TA will operate basically the same as a modem except connection and throughput speeds will be much faster than your old modem. You will need to configure <a href=../ppp-and-slip/#ppp>PPP</a> exactly the same as for a modem setup. Make sure you set your serial speed as high as possible.</p></div><div class=paragraph><p>The main advantage of using a TA to connect to an Internet Provider is that you can do Dynamic PPP. As IP address space becomes more and more scarce, most providers are not willing to provide you with a static IP anymore. Most stand-alone routers are not able to accommodate dynamic IP allocation.</p></div><div class=paragraph><p>TA’s completely rely on the PPP daemon that you are running for their features and stability of connection. This allows you to upgrade easily from using a modem to ISDN on a FreeBSD machine, if you already have PPP set up. However, at the same time any problems you experienced with the PPP program and are going to persist.</p></div><div class=paragraph><p>If you want maximum stability, use the kernel <a href=../ppp-and-slip/#ppp>PPP</a> option, not the <a href=../ppp-and-slip/#userppp>userland PPP</a>.</p></div><div class=paragraph><p>The following TA’s are known to work with FreeBSD:</p></div><div class=ulist><ul><li><p>Motorola BitSurfer and Bitsurfer Pro</p></li><li><p>Adtran</p></li></ul></div><div class=paragraph><p>Most other TA’s will probably work as well, TA vendors try to make sure their product can accept most of the standard modem AT command set.</p></div><div class=paragraph><p>The real problem with external TA’s is that, like modems, you need a good serial card in your computer.</p></div><div class=paragraph><p>You should read the <a href=https://docs.freebsd.org/en/articles/serial-uart/>FreeBSD Serial Hardware</a> tutorial for a detailed understanding of serial devices, and the differences between asynchronous and synchronous serial ports.</p></div><div class=paragraph><p>A TA running off a standard PC serial port (asynchronous) limits you to 115.2 Kbs, even though you have a 128 Kbs connection. To fully utilize the 128 Kbs that ISDN is capable of, you must move the TA to a synchronous serial card.</p></div><div class=paragraph><p>Do not be fooled into buying an internal TA and thinking you have avoided the synchronous/asynchronous issue. Internal TA’s simply have a standard PC serial port chip built into them. All this will do is save you having to buy another serial cable and find another empty electrical socket.</p></div><div class=paragraph><p>A synchronous card with a TA is at least as fast as a stand-alone router, and with a simple 386 FreeBSD box driving it, probably more flexible.</p></div><div class=paragraph><p>The choice of synchronous card/TA v.s. stand-alone router is largely a religious issue. There has been some discussion of this in the mailing lists. We suggest you search the <a href=https://www.FreeBSD.org/search/>archives</a> for the complete discussion.</p></div></div><div class=sect2><h3 id=_stand_alone_isdn_bridgesrouters>31.7.3. Stand-alone ISDN Bridges/Routers<a class=anchor href=#_stand_alone_isdn_bridgesrouters></a></h3><div class=paragraph><p>ISDN bridges or routers are not at all specific to FreeBSD or any other operating system. For a more complete description of routing and bridging technology, please refer to a networking reference book.</p></div><div class=paragraph><p>In the context of this section, the terms router and bridge will be used interchangeably.</p></div><div class=paragraph><p>As the cost of low end ISDN routers/bridges comes down, it will likely become a more and more popular choice. An ISDN router is a small box that plugs directly into your local Ethernet network, and manages its own connection to the other bridge/router. It has built in software to communicate via PPP and other popular protocols.</p></div><div class=paragraph><p>A router will allow you much faster throughput than a standard TA, since it will be using a full synchronous ISDN connection.</p></div><div class=paragraph><p>The main problem with ISDN routers and bridges is that interoperability between manufacturers can still be a problem. If you are planning to connect to an Internet provider, you should discuss your needs with them.</p></div><div class=paragraph><p>If you are planning to connect two LAN segments together, such as your home LAN to the office LAN, this is the simplest lowest maintenance solution. Since you are buying the equipment for both sides of the connection you can be assured that the link will work.</p></div><div class=paragraph><p>For example to connect a home computer or branch office network to a head office network the following setup could be used:</p></div><div class=exampleblock><div class=title>Παράδειγμα 1. Branch Office or Home Network</div><div class=content><div class=paragraph><p>Network uses a bus based topology with 10 base 2 Ethernet ("thinnet"). Connect router to network cable with AUI/10BT transceiver, if necessary.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-bus.png alt="10 Base 2 Ethernet"></div></div><div class=paragraph><p>If your home/branch office is only one computer you can use a twisted pair crossover cable to connect to the stand-alone router directly.</p></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 2. Head Office or Other LAN</div><div class=content><div class=paragraph><p>Network uses a star topology with 10 base T Ethernet ("Twisted Pair").</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-twisted-pair.png alt="ISDN Network Diagram"></div></div></div></div><div class=paragraph><p>One large advantage of most routers/bridges is that they allow you to have 2 <em>separate independent</em> PPP connections to 2 separate sites at the <em>same</em> time. This is not supported on most TA’s, except for specific (usually expensive) models that have two serial ports. Do not confuse this with channel bonding, MPP, etc.</p></div><div class=paragraph><p>This can be a very useful feature if, for example, you have an dedicated ISDN connection at your office and would like to tap into it, but do not want to get another ISDN line at work. A router at the office location can manage a dedicated B channel connection (64 Kbps) to the Internet and use the other B channel for a separate data connection. The second B channel can be used for dial-in, dial-out or dynamically bonding (MPP, etc.) with the first B channel for more bandwidth.</p></div><div class=paragraph><p>An Ethernet bridge will also allow you to transmit more than just IP traffic. You can also send IPX/SPX or whatever other protocols you use.</p></div></div></div></div><div class=sect1><h2 id=network-natd>31.8. Network Address Translation<a class=anchor href=#network-natd></a></h2><div class=sectionbody><div class=sect2><h3 id=network-natoverview>31.8.1. Overview<a class=anchor href=#network-natoverview></a></h3><div class=paragraph><p>FreeBSD’s Network Address Translation daemon, commonly known as <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> is a daemon that accepts incoming raw IP packets, changes the source to the local machine and re-injects these packets back into the outgoing IP packet stream. <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> does this by changing the source IP address and port such that when data is received back, it is able to determine the original location of the data and forward it back to its original requester.</p></div><div class=paragraph><p>The most common use of NAT is to perform what is commonly known as Internet Connection Sharing.</p></div></div><div class=sect2><h3 id=network-natsetup>31.8.2. Setup<a class=anchor href=#network-natsetup></a></h3><div class=paragraph><p>Due to the diminishing IP space in IPv4, and the increased number of users on high-speed consumer lines such as cable or DSL, people are increasingly in need of an Internet Connection Sharing solution. The ability to connect several computers online through one connection and IP address makes <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> a reasonable choice.</p></div><div class=paragraph><p>Most commonly, a user has a machine connected to a cable or DSL line with one IP address and wishes to use this one connected computer to provide Internet access to several more over a LAN.</p></div><div class=paragraph><p>To do this, the FreeBSD machine on the Internet must act as a gateway. This gateway machine must have two NICs-one for connecting to the Internet router, the other connecting to a LAN. All the machines on the LAN are connected through a hub or switch.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>There are many ways to get a LAN connected to the Internet through a FreeBSD gateway. This example will only cover a gateway with at least two NICs.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/natd.png alt="Network Layout"></div></div><div class=paragraph><p>A setup like this is commonly used to share an Internet connection. One of the LAN machines is connected to the Internet. The rest of the machines access the Internet through that "gateway" machine.</p></div></div><div class=sect2><h3 id=network-natdkernconfiguration>31.8.3. Configuration<a class=anchor href=#network-natdkernconfiguration></a></h3><div class=paragraph><p>The following options must be in the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL
options IPDIVERT</pre></div></div><div class=paragraph><p>Additionally, at choice, the following may also be suitable:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</pre></div></div><div class=paragraph><p>The following must be in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34; <i class=conum data-value=1></i><b>(1)</b>
firewall_enable=&#34;YES&#34; <i class=conum data-value=2></i><b>(2)</b>
firewall_type=&#34;OPEN&#34; <i class=conum data-value=3></i><b>(3)</b>
natd_enable=&#34;YES&#34;
natd_interface=&#34;fxp0&#34; <i class=conum data-value=4></i><b>(4)</b>
natd_flags=&#34;&#34; <i class=conum data-value=5></i><b>(5)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Sets up the machine to act as a gateway. Running <code>sysctl net.inet.ip.forwarding=1</code> would have the same effect.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Enables the firewall rules in <span class=filename>/etc/rc.firewall</span> at boot.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>This specifies a predefined firewall ruleset that allows anything in. See <span class=filename>/etc/rc.firewall</span> for additional types.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Indicates which interface to forward packets through (the interface connected to the Internet).</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Any additional configuration options passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> on boot.</td></tr></tbody></table></div><div class=paragraph><p>Having the previous options defined in <span class=filename>/etc/rc.conf</span> would run <code>natd -interface fxp0</code> at boot. This can also be run manually.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is also possible to use a configuration file for <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> when there are too many options to pass. In this case, the configuration file must be defined by adding the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class=paragraph><p>The <span class=filename>/etc/natd.conf</span> file will contain a list of configuration options, one per line. For example the next section case would use the following file:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>For more information about the configuration file, consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> manual page about the <code>-f</code> option.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Each machine and interface behind the LAN should be assigned IP address numbers in the private network space as defined by <a href=ftp://ftp.isi.edu/in-notes/rfc1918.txt>RFC 1918</a> and have a default gateway of the natd machine’s internal IP address.</p></div><div class=paragraph><p>For example, client <code>A</code> and <code>B</code> behind the LAN have IP addresses of <code>192.168.0.2</code> and <code>192.168.0.3</code>, while the natd machine’s LAN interface has an IP address of <code>192.168.0.1</code>. Client <code>A</code> and <code>B</code>'s default gateway must be set to that of the natd machine, <code>192.168.0.1</code>. The natd machine’s external, or Internet interface does not require any special modification for <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> to work.</p></div></div><div class=sect2><h3 id=network-natdport-redirection>31.8.4. Port Redirection<a class=anchor href=#network-natdport-redirection></a></h3><div class=paragraph><p>The drawback with <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> is that the LAN clients are not accessible from the Internet. Clients on the LAN can make outgoing connections to the world but cannot receive incoming ones. This presents a problem if trying to run Internet services on one of the LAN client machines. A simple way around this is to redirect selected Internet ports on the natd machine to a LAN client.</p></div><div class=paragraph><p>For example, an IRC server runs on client <code>A</code>, and a web server runs on client <code>B</code>. For this to work properly, connections received on ports 6667 (IRC) and 80 (web) must be redirected to the respective machines.</p></div><div class=paragraph><p>The <code>-redirect_port</code> must be passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> with the proper options. The syntax is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>In the above example, the argument should be:</p></div><div class="literalblock programlisting"><div class=content><pre>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=literalblock><div class=content><pre>This will redirect the proper _tcp_ ports to the LAN client machines.</pre></div></div><div class=paragraph><p>The <code>-redirect_port</code> argument can be used to indicate port ranges over individual ports. For example, <em>tcp 192.168.0.2:2000-3000 2000-3000</em> would redirect all connections received on ports 2000 to 3000 to ports 2000 to 3000 on client <code>A</code>.</p></div><div class=paragraph><p>These options can be used when directly running <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, placed within the <code>natd_flags=""</code> option in <span class=filename>/etc/rc.conf</span>, or passed via a configuration file.</p></div><div class=paragraph><p>For further configuration options, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a></p></div></div><div class=sect2><h3 id=network-natdaddress-redirection>31.8.5. Address Redirection<a class=anchor href=#network-natdaddress-redirection></a></h3><div class=paragraph><p>Address redirection is useful if several IP addresses are available, yet they must be on one machine. With this, <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> can assign each LAN client its own external IP address. <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> then rewrites outgoing packets from the LAN clients with the proper external IP address and redirects all traffic incoming on that particular IP address back to the specific LAN client. This is also known as static NAT. For example, the IP addresses <code>128.1.1.1</code>, <code>128.1.1.2</code>, and <code>128.1.1.3</code> belong to the natd gateway machine. <code>128.1.1.1</code> can be used as the natd gateway machine’s external IP address, while <code>128.1.1.2</code> and <code>128.1.1.3</code> are forwarded back to LAN clients <code>A</code> and <code>B</code>.</p></div><div class=paragraph><p>The <code>-redirect_address</code> syntax is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address localIP publicIP</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>localIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The internal IP address of the LAN client.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>publicIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The external IP address corresponding to the LAN client.</p></td></tr></tbody></table><div class=paragraph><p>In the example, this argument would read:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Like <code>-redirect_port</code>, these arguments are also placed within the <code>natd_flags=""</code> option of <span class=filename>/etc/rc.conf</span>, or passed via a configuration file. With address redirection, there is no need for port redirection since all data received on a particular IP address is redirected.</p></div><div class=paragraph><p>The external IP addresses on the natd machine must be active and aliased to the external interface. Look at <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> to do so.</p></div></div></div></div><div class=sect1><h2 id=network-plip>31.9. Parallel Line IP (PLIP)<a class=anchor href=#network-plip></a></h2><div class=sectionbody><div class=paragraph><p>PLIP lets us run TCP/IP between parallel ports. It is useful on machines without network cards, or to install on laptops. In this section, we will discuss:</p></div><div class=ulist><ul><li><p>Creating a parallel (laplink) cable.</p></li><li><p>Connecting two computers with PLIP.</p></li></ul></div><div class=sect2><h3 id=network-create-parallel-cable>31.9.1. Creating a Parallel Cable<a class=anchor href=#network-create-parallel-cable></a></h3><div class=paragraph><p>You can purchase a parallel cable at most computer supply stores. If you cannot do that, or you just want to know how it is done, the following table shows how to make one out of a normal parallel printer cable.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 1. Wiring a Parallel Cable for Networking</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">A-name</th><th class="tableblock halign-left valign-top">A-End</th><th class="tableblock halign-left valign-top">B-End</th><th class="tableblock halign-left valign-top">Descr.</th><th class="tableblock halign-left valign-top">Post/Bit</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA0
-ERROR
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
2
15
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
15
2
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x01
1/0x08
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA1
+SLCT
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
3
13
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
13
3
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x02
1/0x10
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA2
+PE
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
4
12
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
12
4
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x04
1/0x20
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA3
-ACK
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
5
10
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
10
5
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Strobe</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x08
1/0x40
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA4
BUSY
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
6
11
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
11
6
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x10
1/0x80
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>GND</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>GND</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>-</pre></div></td></tr></tbody></table></div><div class=sect2><h3 id=network-plip-setup>31.9.2. Setting Up PLIP<a class=anchor href=#network-plip-setup></a></h3><div class=paragraph><p>First, you have to get a laplink cable. Then, confirm that both computers have a kernel with <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> driver support:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep lp /var/run/dmesg.boot</span>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</code></pre></div></div><div class=paragraph><p>The parallel port must be an interrupt driven port, you should have lines similar to the following in your in the <span class=filename>/boot/device.hints</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.at=&#34;isa&#34;
hint.ppc.0.irq=&#34;7&#34;</pre></div></div><div class=paragraph><p>Then check if the kernel configuration file has a <code>device plip</code> line or if the <span class=filename>plip.ko</span> kernel module is loaded. In both cases the parallel networking interface should appear when you use the <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> command to display it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>Plug the laplink cable into the parallel interface on both computers.</p></div><div class=paragraph><p>Configure the network interface parameters on both sites as <code>root</code>. For example, if you want to connect the host <code>host1</code> with another machine <code>host2</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</pre></div></div><div class=paragraph><p>Configure the interface on <code>host1</code> by doing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.1 10.0.0.2</span></code></pre></div></div><div class=paragraph><p>Configure the interface on <code>host2</code> by doing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.2 10.0.0.1</span></code></pre></div></div><div class=paragraph><p>You now should have a working connection. Please read the manual pages <a href="https://man.freebsd.org/cgi/man.cgi?query=lp&amp;sektion=4&amp;format=html">lp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> for more details.</p></div><div class=paragraph><p>You should also add both hosts to <span class=filename>/etc/hosts</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</pre></div></div><div class=paragraph><p>To confirm the connection works, go to each host and ping the other. For example, on <code>host1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class=nt>--</span><span class=o>&gt;</span> 10.0.0.2 netmask 0xff000000
<span class=c># netstat -r</span>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1            UH          0       0       plip0
<span class=c># ping -c 4 host2</span>
PING host2 <span class=o>(</span>10.0.0.2<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.774 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.530 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.556 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.714 ms

<span class=nt>---</span> host2 ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 2.530/2.643/2.774/0.103 ms</code></pre></div></div></div></div></div><div class=sect1><h2 id=network-ipv6>31.10. IPv6<a class=anchor href=#network-ipv6></a></h2><div class=sectionbody><div class=paragraph><p>IPv6 (also known as IPng "IP next generation") is the new version of the well known IP protocol (also known as IPv4). Like the other current *BSD systems, FreeBSD includes the KAME IPv6 reference implementation. So your FreeBSD system comes with all you will need to experiment with IPv6. This section focuses on getting IPv6 configured and running.</p></div><div class=paragraph><p>In the early 1990s, people became aware of the rapidly diminishing address space of IPv4. Given the expansion rate of the Internet there were two major concerns:</p></div><div class=ulist><ul><li><p>Running out of addresses. Today this is not so much of a concern anymore since RFC1918 private address space (<code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, and <code>192.168.0.0/16</code>) and Network Address Translation (NAT) are being employed.</p></li><li><p>Router table entries were getting too large. This is still a concern today.</p></li></ul></div><div class=paragraph><p>IPv6 deals with these and many other issues:</p></div><div class=ulist><ul><li><p>128 bit address space. In other words theoretically there are 340,282,366,920,938,463,463,374,607,431,768,211,456 addresses available. This means there are approximately 6.67 * 10^27 IPv6 addresses per square meter on our planet.</p></li><li><p>Routers will only store network aggregation addresses in their routing tables thus reducing the average space of a routing table to 8192 entries.</p></li></ul></div><div class=paragraph><p>There are also lots of other useful features of IPv6 such as:</p></div><div class=ulist><ul><li><p>Address autoconfiguration (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>)</p></li><li><p>Anycast addresses ("one-out-of many")</p></li><li><p>Mandatory multicast addresses</p></li><li><p>IPsec (IP security)</p></li><li><p>Simplified header structure</p></li><li><p>Mobile IP</p></li><li><p>IPv6-to-IPv4 transition mechanisms</p></li></ul></div><div class=paragraph><p>For more information see:</p></div><div class=ulist><ul><li><p>IPv6 overview at <a href=http://playground.sun.com/pub/ipng/html/ipng-main.html>playground.sun.com</a></p></li><li><p><a href=http://www.kame.net>KAME.net</a></p></li></ul></div><div class=sect2><h3 id=_background_on_ipv6_addresses>31.10.1. Background on IPv6 Addresses<a class=anchor href=#_background_on_ipv6_addresses></a></h3><div class=paragraph><p>There are different types of IPv6 addresses: Unicast, Anycast and Multicast.</p></div><div class=paragraph><p>Unicast addresses are the well known addresses. A packet sent to a unicast address arrives exactly at the interface belonging to the address.</p></div><div class=paragraph><p>Anycast addresses are syntactically indistinguishable from unicast addresses but they address a group of interfaces. The packet destined for an anycast address will arrive at the nearest (in router metric) interface. Anycast addresses may only be used by routers.</p></div><div class=paragraph><p>Multicast addresses identify a group of interfaces. A packet destined for a multicast address will arrive at all interfaces belonging to the multicast group.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The IPv4 broadcast address (usually <code>xxx.xxx.xxx.255</code>) is expressed by multicast addresses in IPv6.</p></div></td></tr></tbody></table></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 2. Reserved IPv6 addresses</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6 address</th><th class="tableblock halign-left valign-top">Prefixlength (Bits)</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Notes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unspecified</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>cf. <code>0.0.0.0</code> in IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>loopback address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>cf. <code>127.0.0.1</code> in IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>embedded IPv4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the IPv4 address. Also called "IPv4 compatible IPv6 address"</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 mapped IPv6 address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the IPv4 address. For hosts which do not support IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::</code> - <code>feb::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>cf. loopback address in IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fec0::</code> - <code>fef::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>site-local</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>001</code> (base 2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>global unicast</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All global unicast addresses are assigned from this pool. The first 3 bits are "001".</p></td></tr></tbody></table></div><div class=sect2><h3 id=_reading_ipv6_addresses>31.10.2. Reading IPv6 Addresses<a class=anchor href=#_reading_ipv6_addresses></a></h3><div class=paragraph><p>The canonical form is represented as: <code>x:x:x:x:x:x:x:x</code>, each "x" being a 16 Bit hex value. For example <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code></p></div><div class=paragraph><p>Often an address will have long substrings of all zeros therefore one such substring per address can be abbreviated by "::". Also up to three leading "0"s per hexquad can be omitted. For example <code>fe80::1</code> corresponds to the canonical form <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>A third form is to write the last 32 Bit part in the well known (decimal) IPv4 style with dots "." as separators. For example <code>2002::10.0.0.1</code> corresponds to the (hexadecimal) canonical representation <code>2002:0000:0000:0000:0000:0000:0a00:0001</code> which in turn is equivalent to writing <code>2002::a00:1</code>.</p></div><div class=paragraph><p>By now the reader should be able to understand the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p><code>fe80::200:21ff:fe03:8e1%rl0</code> is an auto configured link-local address. It is generated from the MAC address as part of the auto configuration.</p></div><div class=paragraph><p>For further information on the structure of IPv6 addresses see <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect2><h3 id=_getting_connected>31.10.3. Getting Connected<a class=anchor href=#_getting_connected></a></h3><div class=paragraph><p>Currently there are four ways to connect to other IPv6 hosts and networks:</p></div><div class=ulist><ul><li><p>Getting an IPv6 network from your upstream provider. Talk to your Internet provider for instructions.</p></li><li><p>Tunnel via 6-to-4 (<a href=http://www.ietf.org/rfc/rfc3068.txt>RFC3068</a>)</p></li><li><p>Use the <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> port if you are on a dial-up connection.</p></li></ul></div></div><div class=sect2><h3 id=_dns_in_the_ipv6_world>31.10.4. DNS in the IPv6 World<a class=anchor href=#_dns_in_the_ipv6_world></a></h3><div class=paragraph><p>There used to be two types of DNS records for IPv6. The IETF has declared A6 records obsolete. AAAA records are the standard now.</p></div><div class=paragraph><p>Using AAAA records is straightforward. Assign your hostname to the new IPv6 address you just received by adding:</p></div><div class="literalblock programlisting"><div class=content><pre>MYHOSTNAME           AAAA    MYIPv6ADDR</pre></div></div><div class=paragraph><p>To your primary zone DNS file. In case you do not serve your own DNS zones ask your DNS provider. Current versions of bind (version 8.3 and 9) and <a class=package href=https://cgit.freebsd.org/ports/tree/dns/djbdns/>dns/djbdns</a> (with the IPv6 patch) support AAAA records.</p></div></div><div class=sect2><h3 id=_applying_the_needed_changes_to_etcrc_conf>31.10.5. Applying the needed changes to <span class=filename>/etc/rc.conf</span><a class=anchor href=#_applying_the_needed_changes_to_etcrc_conf></a></h3><div class=sect3><h4 id=_ipv6_client_settings>31.10.5.1. IPv6 Client Settings<a class=anchor href=#_ipv6_client_settings></a></h4><div class=paragraph><p>These settings will help you configure a machine that will be on your LAN and act as a client, not a router. To have <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a> autoconfigure your interface on boot all you need to add is:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To statically assign an IP address such as <code>2001:471:1f11:251:290:27ff:fee0:2093</code>, to your <span class=filename>fxp0</span> interface, add:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_fxp0=&#34;2001:471:1f11:251:290:27ff:fee0:2093&#34;</pre></div></div><div class=paragraph><p>To assign a default router of <code>2001:471:1f11:251::1</code> add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:471:1f11:251::1&#34;</pre></div></div></div><div class=sect3><h4 id=_ipv6_routergateway_settings>31.10.5.2. IPv6 Router/Gateway Settings<a class=anchor href=#_ipv6_routergateway_settings></a></h4><div class=paragraph><p>This will help you take the directions that your tunnel provider has given you and convert it into settings that will persist through reboots. To restore your tunnel on startup use something like the following in <span class=filename>/etc/rc.conf</span>:</p></div><div class=paragraph><p>List the Generic Tunneling interfaces that will be configured, for example <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gif_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>To configure the interface with a local endpoint of <em>MY_IPv4_ADDR</em> to a remote endpoint of <em>REMOTE_IPv4_ADDR</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig_gif0=&#34;MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>To apply the IPv6 address you have been assigned for use as your IPv6 tunnel endpoint, add:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_gif0=&#34;MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Then all you have to do is set the default route for IPv6. This is the other side of the IPv6 tunnel:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div></div><div class=sect3><h4 id=_ipv6_tunnel_settings>31.10.5.3. IPv6 Tunnel Settings<a class=anchor href=#_ipv6_tunnel_settings></a></h4><div class=paragraph><p>If the server is to route IPv6 between the rest of your network and the world, the following <span class=filename>/etc/rc.conf</span> setting will also be needed:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_router_advertisement_and_host_auto_configuration>31.10.6. Router Advertisement and Host Auto Configuration<a class=anchor href=#_router_advertisement_and_host_auto_configuration></a></h3><div class=paragraph><p>This section will help you setup <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to advertise the IPv6 default route.</p></div><div class=paragraph><p>To enable <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> you will need the following in your <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>It is important that you specify the interface on which to do IPv6 router solicitation. For example to tell <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to use <span class=filename>fxp0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;fxp0&#34;</pre></div></div><div class=paragraph><p>Now we must create the configuration file, <span class=filename>/etc/rtadvd.conf</span>. Here is an example:</p></div><div class="literalblock programlisting"><div class=content><pre>fxp0:\
	:addrs#1:addr=&#34;2001:471:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Replace <span class=filename>fxp0</span> with the interface you are going to be using.</p></div><div class=paragraph><p>Next, replace <code>2001:471:1f11:246::</code> with the prefix of your allocation.</p></div><div class=paragraph><p>If you are dedicated a <code>/64</code> subnet you will not need to change anything else. Otherwise, you will need to change the <code>prefixlen#</code> to the correct value.</p></div></div></div></div><div class=sect1><h2 id=network-atm>31.11. Asynchronous Transfer Mode (ATM)<a class=anchor href=#network-atm></a></h2><div class=sectionbody><div class=sect2><h3 id=_configuring_classical_ip_over_atm_pvcs>31.11.1. Configuring classical IP over ATM (PVCs)<a class=anchor href=#_configuring_classical_ip_over_atm_pvcs></a></h3><div class=paragraph><p>Classical IP over ATM (CLIP) is the simplest method to use Asynchronous Transfer Mode (ATM) with IP. It can be used with switched connections (SVCs) and with permanent connections (PVCs). This section describes how to set up a network based on PVCs.</p></div><div class=sect3><h4 id=_fully_meshed_configurations>31.11.1.1. Fully meshed configurations<a class=anchor href=#_fully_meshed_configurations></a></h4><div class=paragraph><p>The first method to set up a CLIP with PVCs is to connect each machine to each other machine in the network via a dedicated PVC. While this is simple to configure it tends to become impractical for a larger number of machines. The example supposes that we have four machines in the network, each connected to the ATM network with an ATM adapter card. The first step is the planning of the IP addresses and the ATM connections between the machines. We use the following:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Host</th><th class="tableblock halign-left valign-top">IP Address</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.3</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.4</code></p></td></tr></tbody></table><div class=paragraph><p>To build a fully meshed net we need one ATM connection between each pair of machines:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machines</th><th class="tableblock halign-left valign-top">VPI.VCI couple</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.100</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.101</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.102</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.103</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.104</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.105</p></td></tr></tbody></table><div class=paragraph><p>The VPI and VCI values at each end of the connection may of course differ, but for simplicity we assume that they are the same. Next we need to configure the ATM interfaces on each host:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# ifconfig hatm0 192.168.173.1 up
hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up
hostD# ifconfig hatm0 192.168.173.4 up</code></pre></div></div><div class=paragraph><p>assuming that the ATM interface is <span class=filename>hatm0</span> on all hosts. Now the PVCs need to be configured on <code>hostA</code> (we assume that they are already configured on the ATM switches, you need to consult the manual for the switch on how to do this).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA# atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA# atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB# atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB# atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB# atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC# atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD# atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD# atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD# atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</code></pre></div></div><div class=paragraph><p>Of course other traffic contracts than UBR can be used given the ATM adapter supports those. In this case the name of the traffic contract is followed by the parameters of the traffic. Help for the <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a> tool can be obtained with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atmconfig help natm add</span></code></pre></div></div><div class=paragraph><p>or in the <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a> manual page.</p></div><div class=paragraph><p>The same configuration can also be done via <span class=filename>/etc/rc.conf</span>. For <code>hostA</code> this would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 hatm0&#34;
ifconfig_hatm0=&#34;inet 192.168.173.1 up&#34;
natm_static_routes=&#34;hostB hostC hostD&#34;
route_hostB=&#34;192.168.173.2 hatm0 0 100 llc/snap ubr&#34;
route_hostC=&#34;192.168.173.3 hatm0 0 101 llc/snap ubr&#34;
route_hostD=&#34;192.168.173.4 hatm0 0 102 llc/snap ubr&#34;</pre></div></div><div class=paragraph><p>The current state of all CLIP routes can be obtained with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm show</code></pre></div></div></div></div></div></div><div class=sect1><h2 id=carp>31.12. Common Access Redundancy Protocol (CARP)<a class=anchor href=#carp></a></h2><div class=sectionbody><div class=paragraph><p>The Common Access Redundancy Protocol, or CARP allows multiple hosts to share the same IP address. In some configurations, this may be used for availability or load balancing. Hosts may use separate IP addresses as well, as in the example provided here.</p></div><div class=paragraph><p>To enable support for CARP, the FreeBSD kernel must be rebuilt with the following option:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>CARP functionality should now be available and may be tuned via several <code>sysctl</code> OIDs. Devices themselves may be loaded via the <code>ifconfig</code> command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>In a real environment, these interfaces will need unique identification numbers known as a VHID. This VHID or Virtual Host Identification will be used to distinguish the host on the network.</p></div><div class=sect2><h3 id=_using_carp_for_server_availability_carp>31.12.1. Using CARP For Server Availability (CARP)<a class=anchor href=#_using_carp_for_server_availability_carp></a></h3><div class=paragraph><p>One use of CARP, as noted above, is for server availability. This example will provide failover support for three hosts, all with unique IP addresses and providing the same web content. These machines will act in conjunction with a Round Robin DNS configuration. The failover machine will have two additional CARP interfaces, one for each of the content server’s IPs. When a failure occurs, the failover server should pick up the failed machine’s IP address. This means the failure should go completely unnoticed to the user. The failover server requires identical content and services as the other content servers it is expected to pick up load for.</p></div><div class=paragraph><p>The two machines should be configured identically other than their issued hostnames and VHIDs. This example calls these machines <code>hosta.example.org</code> and <code>hostb.example.org</code> respectively. First, the required lines for a CARP configuration have to be added to <span class=filename>rc.conf</span>. For <code>hosta.example.org</code>, the <span class=filename>rc.conf</span> file should contain the following lines:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpast 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>On <code>hostb.example.org</code> the following lines should be in <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is very important that the passwords, specified by the <code>pass</code> option to <code>ifconfig</code>, are identical. The <span class=filename>carp</span> devices will only listen to and accept advertisements from machines with the correct password. The VHID must also be different for each machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The third machine, <code>provider.example.org</code>, should be prepared so that it may handle failover from either host. This machine will require two <span class=filename>carp</span> devices, one to handle each host. The appropriate <span class=filename>rc.conf</span> configuration lines will be similar to the following:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;provider.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>Having the two <span class=filename>carp</span> devices will allow <code>provider.example.org</code> to notice and pick up the IP address of either machine should it stop responding.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The default FreeBSD kernel <em>may</em> have preemption enabled. If so, <code>provider.example.org</code> may not relinquish the IP address back to the original content server. In this case, an administrator may "nudge" the interface. The following command should be issued on <code>provider.example.org</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>This should be done on the <span class=filename>carp</span> interface which corresponds to the correct host.</p></div></td></tr></tbody></table></div><div class=paragraph><p>At this point, CARP should be completely enabled and available for testing. For testing, either networking has to be restarted or the machines need to be rebooted.</p></div><div class=paragraph><p>More information is always available in the <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> manual page.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Τελευταία τροποποίηση</strong>: 9 Μαρτίου 2024 από <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Προηγούμενη></i><div class=container><a href=https://docs.freebsd.org/el/books/handbook/firewalls class=direction>Προηγούμενη</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Αρχική></i><div class=container><a href=../ class=direction>Αρχική</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/el/books/handbook/partv class=direction>Επόμενη</a></div><i class="fa fa-angle-right" aria-hidden=true title=Επόμενη></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Πίνακας περιεχομένων</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. Σύνοψη</a></li><li><a href=#network-routing>31.2. Gateways and Routes</a></li><li><a href=#network-wireless>31.3. Wireless Networking</a></li><li><a href=#network-bluetooth>31.4. Bluetooth</a></li><li><a href=#network-bridging>31.5. Bridging</a></li><li><a href=#network-diskless>31.6. Diskless Operation</a></li><li><a href=#network-isdn>31.7. ISDN</a></li><li><a href=#network-natd>31.8. Network Address Translation</a></li><li><a href=#network-plip>31.9. Parallel Line IP (PLIP)</a></li><li><a href=#network-ipv6>31.10. IPv6</a></li><li><a href=#network-atm>31.11. Asynchronous Transfer Mode (ATM)</a></li><li><a href=#carp>31.12. Common Access Redundancy Protocol (CARP)</a></li></ul></nav><hr><div class=resources><h3>Πηγές</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Λήψη PDF"></i><a href=https://download.freebsd.org/doc/el/books/handbook/handbook_el.pdf>Λήψη PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Τροποποίηση αυτής της σελίδας"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/el/_index target=_blank>Τροποποίηση αυτής της σελίδας</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/el/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Επιλογή γλώσσας">
<span>Greek</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>Σύστημα</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Υψηλή αντίθεση</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/el class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/el/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>