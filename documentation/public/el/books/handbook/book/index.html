<!doctype html><html class=theme-light lang=el><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/el/books/handbook/book/><title>Εγχειρίδιο του FreeBSD | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Εγχειρίδιο του FreeBSD"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="el"><meta property="og:url" content="http://172.16.201.134:1313/el/books/handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/el\/books\/handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/el>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/el/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/el/books>Books</a></li><li><a href=http://172.16.201.134:1313/el/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/el/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=el>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>Εγχειρίδιο του FreeBSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 Ομάδα Τεκμηρίωσης του FreeBSD</div><div class=legalnotice><a id=trademarks></a><details><summary>Εμπορικά σύμβολα</summary><p>Το FreeBSD είναι ένα κατοχυρωμένο εμπορικό σύμβολο του FreeBSD Foundation.</p><p>Οι λέξεις ή φράσεις IBM, AIX, OS/2, PowerPC, PS/2, S/390, και ThinkPad είναι εμπορικά σύμβολα της International Business Machines Corporation στις Ηνωμένες Πολιτείες, άλλες χώρες, ή και στα δύο ταυτόχρονα.</p><p>Οι λέξεις IEEE, POSIX, και 802 είναι κατοχυρωμένα εμπορικά σύμβολα του Institute of Electrical and Electronics Engineers, Inc. στις Ηνωμένες Πολιτείες.</p><p>Οι λέξεις ή φράσεις Red Hat, και RPM είναι εμπορικά σύμβολα ή κατοχυρωμένα εμπορικά σύμβολα της Red Hat, Inc. στις Ηνωμένες Πολιτείες και σε άλλες χώρες.</p><p>Οι λέξεις 3Com και HomeConnect είναι κατοχυρωμένα εμπορικά σύμβολα της 3Com Corporation.</p><p>Οι λέξεις ή φράσεις Adobe, Acrobat, Acrobat Reader, και PostScript είναι είτε κατοχυρωμένα εμπορικά σύμβολα ή εμπορικά σύμβολα της Adobe Systems Incorporated στις Ηνωμένες Πολιτείες ή/και σε άλλες χώρες.</p><p>Οι λέξεις ή φράσεις Apple, AirPort, FireWire, Mac, Macintosh, Mac OS, Quicktime, και TrueType είναι εμπορικά σύμβολα της Apple Computer, Inc., κατοχυρωμένα στις Ηνωμένες Πολιτείες και σε άλλες χώρες.</p><p>Οι λέξεις Intel, Celeron, EtherExpress, i386, i486, Itanium, Pentium, και Xeon είναι εμπορικά σύμβολα ή κατοχυρωμένα εμπορικά σύμβολα της Intel Corporation και των θυγατρικών της στις Ηνωμένες Πολιτείες και σε άλλες χώρες.</p><p>Το Linux είναι ένα κατοχυρωμένα εμπορικό σύμβολο του Linus Torvalds στις Ηνωμένες Πολιτείες.</p><p>Οι λέξεις Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media, και Windows NT είναι είτε κατοχυρωμένα εμπορικά σύμβολα ή εμπορικά σύμβολα της Microsoft Corporation στις Ηνωμένες Πολιτείες και/ή σε άλλες χώρες.</p><p>Οι λέξεις Motif, OSF/1, και UNIX είναι κατοχυρωμένα εμπορικά σύμβολα και οι λέξεις ή φράσεις IT DialTone και The Open Group είναι εμπορικά σύμβολα του The Open Group στις Ηνωμένες Πολιτείες και σε άλλες χώρες.</p><p>Οι λέξεις ή φράσεις Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS και VirtualBox είναι εμπορικά σύμβολα ή κατοχυρωμένα εμπορικά σύμβολα της Sun Microsystems, Inc. στις Ηνωμένες Πολιτείες και σε άλλες χώρες.</p><p>Οι λέξεις RealNetworks, RealPlayer και RealAudio είναι κατοχυρωμένα εμπορικά σύμβολα της RealNetworks, Inc.</p><p>Η λέξη Oracle είναι κατοχυρωμένο εμπορικό σύμβολο της Oracle Corporation.</p><p>Οι λέξεις 3ware και Escalade είναι κατοχυρωμένα εμπορικά σύμβολα της 3ware Inc.</p><p>Η λέξη ARM είναι κατοχυρωμένο εμπορικό σύμβολο της ARM Limited.</p><p>Η λέξη Adaptec είναι κατοχυρωμένο εμπορικό σύμβολο της Adaptec, Inc.</p><p>Οι λέξεις ή φράσεις Heidelberg, Helvetica, Palatino, και Times Roman είναι είτε κατοχυρωμένα εμπορικά σύμβολα ή εμπορικά σύμβολα της Heidelberger Druckmaschinen AG στις ΗΠΑ και σε άλλες χώρες.</p><p>Οι λέξεις Intuit και Quicken είναι κατοχυρωμένα εμπορικά σύμβολα ή κατοχυρωμένα σύμβολα υπηρεσιών της Intuit Inc., ή κάποιων από τις θυγατρικές της, στις Ηνωμένες Πολιτείες και σε άλλες χώρες.</p><p>Οι λέξεις LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID και Mylex είναι εμπορικά σύμβολα ή κατοχυρωμένα εμπορικά σύμβολα της LSI Logic Corp.</p><p>Η λέξη MATLAB είναι ένα κατοχυρωμένο εμπορικό σύμβολο της The MathWorks, Inc.</p><p>Η λέξη SpeedTouch είναι ένα εμπορικό σύμβολο της Thomson</p><p>Η λέξη VMware είναι εμπορικό σύμβολο της VMware, Inc.</p><p>Η λέξη Mathematica είναι κατοχυρωμένο εμπορικό σύμβολο της Wolfram Research, Inc.</p><p>Οι λέξεις ή φράσεις Ogg Vorbis και Xiph.Org είναι εμπορικά σύμβολα τουXiph.Org.</p><p>Η λέξη XFree86 είναι ένα εμπορικό σύμβολο του The XFree86 Project, Inc.</p><p>Πολλές από τις λέξεις ή φράσεις οι οποίες χρησιμοποιούνται από τους κατασκευαστές ή τους πωλητές τους για να διακρίνουν τα προϊόντα τους θεωρούνται εμπορικά σύμβολα. Όπου αυτές εμφανίζονται σε αυτό το κείμενο και για όσες από αυτές γνωρίζει η Ομάδα Ανάπτυξης του FreeBSD ότι είναι πιθανόν να είναι εμπορικά σύμβολα, θα δείτε ένα από τα σύμβολα: “™” ή “®”.</p></details></div><div class=toc-mobile><h3>Πίνακας περιεχομένων</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Πρόλογος</a><ul><li><a href=#preface-audience>Σε Ποιους Απευθύνεται Αυτό το Βιβλίο</a></li><li><a href=#preface-changes-from3>Αλλαγές από την Τρίτη Έκδοση</a></li><li><a href=#preface-changes-from2>Αλλαγές από τη Δεύτερη Έκδοση (2004)</a></li><li><a href=#preface-changes>Αλλαγές από την Πρώτη Έκδοση (2001)</a></li><li><a href=#preface-overview>Οργάνωση Αυτού του Βιβλίου</a></li><li><a href=#preface-conv>Συμβάσεις που χρησιμοποιούνται σε αυτό το βιβλίο</a></li><li><a href=#preface-acknowledgements>Ευχαριστίες</a></li></ul></li><li><a href=#introduction>Part I: Εισαγωγή</a><ul><li><a href=#introduction-synopsis>Chapter 1. Σύνοψη</a></li><li><a href=#nutshell>Chapter 2. Καλώς ήλθατε στο FreeBSD!</a></li><li><a href=#history>Chapter 3. Πληροφορίες για το FreeBSD Project</a></li><li><a href=#bsdinstall>Chapter 4. Εγκατάσταση του FreeBSD 9.x και Μεταγενέστερων Εκδόσεων</a></li><li><a href=#basics>Chapter 5. Βασικές Έννοιες στο UNIX®</a></li><li><a href=#ports>Chapter 6. Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a></li><li><a href=#x11>Chapter 7. Το Σύστημα X Window</a></li></ul></li><li><a href=#desktop>Part II: Desktop Εφαρμογές</a><ul><li><a href=#desktop-synopsis>Chapter 8. Σύνοψη</a></li><li><a href=#desktop-browsers>Chapter 9. Φυλλομετρητές (Browsers)</a></li><li><a href=#desktop-productivity>Chapter 10. Εφαρμογές Γραφείου</a></li><li><a href=#desktop-viewers>Chapter 11. Προγράμματα Προβολής Εγγράφων</a></li><li><a href=#desktop-finance>Chapter 12. Χρηματοοικονομικές Εφαρμογές</a></li><li><a href=#desktop-summary>Chapter 13. Περίληψη</a></li><li><a href=#multimedia>Chapter 14. Πολυμέσα</a></li><li><a href=#kernelconfig>Chapter 15. Ρυθμίζοντας τον Πυρήνα του FreeBSD</a></li><li><a href=#printing>Chapter 16. Εκτυπώσεις</a></li><li><a href=#linuxemu>Chapter 17. Συμβατότητα με Εκτελέσιμα του Linux</a></li></ul></li><li><a href=#config-tuning>Part III: Ρύθμιση και Βελτιστοποίηση</a><ul><li><a href=#config-synopsis>Chapter 18. Σύνοψη</a></li><li><a href=#configtuning-initial>Chapter 19. Αρχική Ρύθμιση</a></li><li><a href=#configtuning-core-configuration>Chapter 20. Κύρια Ρύθμιση</a></li><li><a href=#configtuning-appconfig>Chapter 21. Ρύθμιση Εφαρμογών</a></li><li><a href=#configtuning-starting-services>Chapter 22. Eκκινώντας Υπηρεσίες</a></li><li><a href=#configtuning-cron>Chapter 23. Ρυθμίζοντας Το Πρόγραμμα <code>cron</code></a></li><li><a href=#configtuning-rcd>Chapter 24. Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD</a></li><li><a href=#config-network-setup>Chapter 25. Ρυθμίζοντας Τις Κάρτες Δικτύου</a></li><li><a href=#configtuning-virtual-hosts>Chapter 26. Εικονικά Hosts</a></li><li><a href=#configtuning-configfiles>Chapter 27. Αρχεία Ρυθμίσεων</a></li><li><a href=#configtuning-sysctl>Chapter 28. Tuning with sysctl</a></li><li><a href=#configtuning-disk>Chapter 29. Tuning Disks</a></li><li><a href=#configtuning-kernel-limits>Chapter 30. Tuning Kernel Limits</a></li><li><a href=#adding-swap-space>Chapter 31. Adding Swap Space</a></li><li><a href=#acpi-overview>Chapter 32. Power and Resource Management</a></li><li><a href=#ACPI-debug>Chapter 33. Using and Debugging FreeBSD ACPI</a></li><li><a href=#boot>Chapter 34. Η Διαδικασία Εκκίνησης του FreeBSD</a></li><li><a href=#security>Chapter 35. Ασφάλεια</a></li><li><a href=#jails>Chapter 36. Jails</a></li><li><a href=#mac>Chapter 37. Υποχρεωτικός Έλεγχος Πρόσβασης</a></li><li><a href=#audit>Chapter 38. Έλεγχος Συμβάντων Ασφαλείας</a></li><li><a href=#disks>Chapter 39. Αποθηκευτικά Μέσα</a></li><li><a href=#geom>Chapter 40. GEOM: Διαχείριση Συστοιχιών Δίσκων</a></li><li><a href=#filesystems>Chapter 41. Υποστήριξη Συστημάτων Αρχείων</a></li><li><a href=#virtualization>Chapter 42. Εικονικοποίηση</a></li><li><a href=#l10n>Chapter 43. Τοπικές Ρυθμίσεις - Χρήση και ρύθμιση I18N/L10N</a></li><li><a href=#updating-upgrading>Chapter 44. Ενημέρωση και Αναβάθμιση του FreeBSD</a></li><li><a href=#dtrace>Chapter 45. DTrace</a></li></ul></li><li><a href=#serialcomms>Part IV: Serial Communications</a><ul><li><a href=#serial-synopsis>Chapter 46. Σύνοψη</a></li><li><a href=#serial>Chapter 47. Εισαγωγή</a></li><li><a href=#term>Chapter 48. Τερματικά</a></li><li><a href=#dialup>Chapter 49. Υπηρεσία Εισόδου μέσω Επιλογικής Σύνδεσης (dial-in)</a></li><li><a href=#dialout>Chapter 50. Υπηρεσία Επιλογικής Σύνδεσης</a></li><li><a href=#serialconsole-setup>Chapter 51. Ρύθμιση της Σειριακής Κονσόλας</a></li><li><a href=#ppp-and-slip>Chapter 52. PPP</a></li><li><a href=#mail>Chapter 53. Ηλεκτρονικό Ταχυδρομείο</a></li><li><a href=#network-servers>Chapter 54. Εξυπηρετητές Δικτύου</a></li><li><a href=#firewalls>Chapter 55. Firewalls</a></li><li><a href=#advanced-networking>Chapter 56. Προχωρημένα Θέματα Δικτύωσης</a></li></ul></li><li><a href=#mirrors>Appendix A: Που θα Βρείτε το FreeBSD</a></li><li><a href=#mirrors-cdrom>Chapter 57. Εκδόσεις σε CDROM και DVD</a><ul><li><a href=#_retail_εκδόσεις>57.1. Retail Εκδόσεις</a></li><li><a href=#_cd_και_dvd_διανομές>57.2. CD και DVD διανομές</a></li><li><a href=#_διανομείς>57.3. Διανομείς</a></li></ul></li><li><a href=#mirrors-ftp>Chapter 58. Εξυπηρετητές FTP</a></li><li><a href=#anoncvs>Chapter 59. Ανώνυμο CVS</a><ul><li><a href=#anoncvs-intro>59.1. Εισαγωγή</a></li><li><a href=#anoncvs-usage>59.2. Χρησιμοποιώντας Ανώνυμο CVS</a></li><li><a href=#_παραδείγματα>59.3. Παραδείγματα</a></li><li><a href=#_άλλες_πηγές_πληροφοριών>59.4. Άλλες Πηγές Πληροφοριών</a></li></ul></li><li><a href=#ctm>Chapter 60. Χρησιμοποιώντας το CTM</a><ul><li><a href=#_γιατί_πρέπει_να_χρησιμοποιήσω_το_ctm>60.1. Γιατί Πρέπει να Χρησιμοποιήσω το CTM;</a></li><li><a href=#_τι_χρειάζομαι_για_να_χρησιμοποιήσω_το_ctm>60.2. Τι Χρειάζομαι για να Χρησιμοποιήσω το CTM;</a></li><li><a href=#_χρησιμοποιώντας_το_ctm_για_πρώτη_φορά>60.3. Χρησιμοποιώντας το CTM για Πρώτη Φορά</a></li><li><a href=#_χρησιμοποιώντας_το_ctm_στην_καθημερινή_σας_ζωή>60.4. Χρησιμοποιώντας το CTM στην Καθημερινή σας Ζωή</a></li><li><a href=#_κρατώντας_τις_τοπικές_σας_αλλαγές>60.5. Κρατώντας τις Τοπικές σας Αλλαγές</a></li><li><a href=#_άλλες_ενδιαφέρουσες_επιλογές_του_ctm>60.6. Άλλες Ενδιαφέρουσες Επιλογές του CTM</a></li><li><a href=#_μελλοντικά_σχέδια_για_το_ctm>60.7. Μελλοντικά Σχέδια για το CTM</a></li><li><a href=#_διάφορα_2>60.8. Διάφορα</a></li><li><a href=#mirrors-ctm>60.9. CTM Mirrors</a></li></ul></li><li><a href=#cvsup>Chapter 61. Χρησιμοποιώντας το CVSup</a><ul><li><a href=#cvsup-intro>61.1. Εισαγωγή</a></li><li><a href=#cvsup-install>61.2. Εγκατάσταση</a></li><li><a href=#cvsup-config>61.3. Ρύθμιση του CVSup</a></li><li><a href=#_εκτελώντας_το_cvsup>61.4. Εκτελώντας το CVSup</a></li><li><a href=#cvsup-collec>61.5. Συλλογές Αρχείων τουCVSup</a></li><li><a href=#_για_περισσότερες_πληροφορίες>61.6. Για Περισσότερες Πληροφορίες</a></li><li><a href=#cvsup-mirrors>61.7. Τοποθεσίες CVSup</a></li></ul></li><li><a href=#cvs-tags>Chapter 62. Ετικέτες (Tags) για το CVS</a><ul><li><a href=#_ετικέτες_κλάδων_branch_tags>62.1. Ετικέτες Κλάδων (Branch Tags)</a></li><li><a href=#_ετικέτες_εκδόσεων_release_tags>62.2. Ετικέτες Εκδόσεων (Release Tags)</a></li></ul></li><li><a href=#mirrors-afs>Chapter 63. Τοποθεσίες AFS</a></li><li><a href=#mirrors-rsync>Chapter 64. Τοποθεσίες rsync</a></li><li><a href=#bibliography>Appendix B: Βιβλιογραφία</a><ul><li><a href=#bibliography-freebsd>B.1. Βιβλία & Περιοδικά σχετικά με το FreeBSD</a></li><li><a href=#bibliography-userguides>B.2. Οδηγοί χρήστη</a></li><li><a href=#bibliography-adminguides>B.3. Οδηγοί διαχειριστή</a></li><li><a href=#bibliography-programmers>B.4. Οδηγοί προγραμματιστών</a></li><li><a href=#bibliography-osinternals>B.5. Το εσωτερικό του λειτουργικού συστήματος</a></li><li><a href=#bibliography-security>B.6. Αναφορές ασφαλείας</a></li><li><a href=#bibliography-hardware>B.7. Αναφορές υλικού</a></li><li><a href=#bibliography-history>B.8. Ιστορία του UNIX®</a></li><li><a href=#bibliography-journals>B.9. Περιοδικά και εφημερίδες</a></li></ul></li><li><a href=#eresources>Appendix C: Πηγές Πληροφόρησης στο Διαδίκτυο</a><ul><li><a href=#eresources-mail>C.1. Λίστες Ηλεκτρονικού Ταχυδρομείου</a></li><li><a href=#eresources-news>C.2. Usenet Newsgroups</a></li><li><a href=#eresources-web>C.3. Διακομιστές Ιστοσελίδων</a></li><li><a href=#eresources-email>C.4. Διευθύνσεις Ηλεκτρονικού Ταχυδρομείου</a></li></ul></li><li><a href=#pgpkeys>Appendix D: Κλειδιά PGP</a><ul><li><a href=#pgpkeys-officers>D.1. Officers</a></li></ul></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>Περίληψη</blockquote></div><div class=paragraph><p>Καλώς ήρθατε στο FreeBSD! Αυτό το εγχειρίδιο καλύπτει την εγκατάσταση και την καθημερινή χρήση του <em>FreeBSD 11.2-RELEASE</em> και του <em>FreeBSD 12.0-RELEASE</em>. Το βιβλίο αυτό είναι <em>μόνιμα υπό βελτίωση και ανάπτυξη</em> και αποτελεί το αποτέλεσμα της δουλειάς πολλών ατόμων, οπότε κάποια τμήματα μπορεί να περιέχουν σχετικά ξεπερασμένες πληροφορίες και να χρειάζονται ανανέωση. Αν ενδιαφέρεστε να μας βοηθήσετε σε αυτό το έργο, επικοινωνήστε μαζί μας στην <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>ηλεκτρονική λίστα ομάδας τεκμηρίωσης του FreeBSD</a>. Η τελευταία έκδοση αυτού του κειμένου είναι πάντα διαθέσιμη από την <a href=http://www.FreeBSD.org/>ιστοσελίδα του FreeBSD</a> (παλιότερες εκδόσεις μπορείτε να βρείτε στη διεύθυνση <a href=http://docs.FreeBSD.org/doc/>http://docs.FreeBSD.org/doc/</a>). Μπορείτε επίσης να μεταφορτώσετε στον υπολογιστή σας το ίδιο βιβλίο σε άλλες μορφές αρχείου και με διάφορες μορφές συμπίεσης από τον <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/>εξυπηρετητή FTP του FreeBSD</a> ή ένα από τα πολλά <a href=#mirrors-ftp>mirror sites</a>. Αν προτιμάτε ένα τυπωμένο αντίτυπο, μπορείτε να αγοράσετε ένα αντίγραφο του Εγχειριδίου, από το <a href=http://www.freebsdmall.com/>FreeBSD Mall</a>. Μπορείτε επίσης να <a href=https://www.FreeBSD.org/search/>ψάξετε σε όλο το βιβλίο</a>.</p></div><hr></div></div><div class=sect1><h2 id=book-preface>Πρόλογος<a class=anchor href=#book-preface></a></h2><div class=sectionbody><div class=sect2><h3 id=preface-audience>Σε Ποιους Απευθύνεται Αυτό το Βιβλίο<a class=anchor href=#preface-audience></a></h3><div class=paragraph><p>Το πρώτο τμήμα αυτού του βιβλίου, οδηγεί τον νέο χρήστη στη διαδικασία εγκατάστασης του FreeBSD και τον εισάγει ομαλά στη φιλοσοφία και τον σχεδιασμό του UNIX®. Αυτό το τμήμα δεν έχει ιδιαίτερες απαιτήσεις. Αρκεί μόνο η διάθεση για εξερεύνηση ενός νέου συστήματος και η δυνατότητα αφομοίωσης των γνώσεων για το FreeBSD καθώς αυτές εισάγονται σταδιακά.</p></div><div class=paragraph><p>Αφού διαβάσετε το πρώτο τμήμα, το δεύτερο, κατά πολύ μεγαλύτερο τμήμα, περιλαμβάνει μια εκτενή αναφορά σε διάφορα θέματα που ενδιαφέρουν τους διαχειριστές συστημάτων FreeBSD. Μερικά από αυτά τα κεφάλαια είναι ευκολότερο να τα κατανοήσετε αν έχετε ήδη μελετήσει συγκεκριμένα τμήματα του βιβλίου. Όπου χρειάζεται κάτι τέτοιο, θα αναφέρεται στη σύνοψη του κεφαλαίου που μόλις ξεκινήσατε να διαβάζετε.</p></div><div class=paragraph><p>Για περισσότερες πηγές πληροφοριών, δείτε το <a href=./#bibliography>Βιβλιογραφία</a>.</p></div></div><div class=sect2><h3 id=preface-changes-from3>Αλλαγές από την Τρίτη Έκδοση<a class=anchor href=#preface-changes-from3></a></h3><div class=paragraph><p>Η τρέχουσα έκδοση του Εγχειριδίου στο διαδίκτυο, είναι το αποτέλεσμα της προσπάθειας πολλών εκατοντάδων εθελοντών στο διάστημα των τελευταίων 10 χρόνων. Οι πιο σημαντικές αλλαγές σε σχέση με την τρίτη έντυπη έκδοση του Εγχειριδίου (2004) φαίνονται παρακάτω:</p></div><div class=ulist><ul><li><p>Το <a href=./#dtrace>DTrace</a> είναι ένα νέο κεφάλαιο με πληροφορίες σχετικά με αυτό το πανίσχυρο εργαλείο ανάλυσης απόδοσης.</p></li><li><p>Το <a href=./#filesystems>Υποστήριξη Συστημάτων Αρχείων</a> είναι ένα νέο κεφάλαιο με πληροφορίες για συστήματα αρχείων τα οποία υποστηρίζονται από το FreeBSD αλλά αναπτύσσονται από άλλες ομάδες, όπως το ZFS από την Sun™.</p></li><li><p>Το <a href=./#audit>Έλεγχος Συμβάντων Ασφαλείας</a> είναι ένα νέο κεφάλαιο με πληροφορίες σχετικά με τις νέες δυνατότητες και την χρήση του auditing στο FreeBSD.</p></li><li><p>Το <a href=./#virtualization>Εικονικοποίηση</a> είναι ένα νέο κεφάλαιο με πληροφορίες σχετικά με την εγκατάσταση του FreeBSD σε λογισμικό εκτέλεσης εικονικών (virtual) μηχανημάτων.</p></li><li><p>Το <a href=./#bsdinstall>Εγκατάσταση του FreeBSD 9.x και Μεταγενέστερων Εκδόσεων</a> FreeBSD 9.<em>x</em> και Μεταγενέστερων Εκδόσεων, είναι ένα νέο κεφάλαιο σχετικά με την εγκατάσταση του FreeBSD με τη βοήθεια του νέου προγράμματος bsdinstall.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes-from2>Αλλαγές από τη Δεύτερη Έκδοση (2004)<a class=anchor href=#preface-changes-from2></a></h3><div class=paragraph><p>Η τρίτη έκδοση αυτού του βιβλίου ήταν το αποτέλεσμα της προσπάθειας περισσότερων από δύο χρόνων από τα μέλη της Ομάδας Τεκμηρίωσης του FreeBSD. Η έντυπη έκδοση είχε τόσο μεγάλο μέγεθος, που κρίθηκε αναγκαίο να τυπωθεί σε δύο χωριστούς τόμους. Παρακάτω φαίνονται οι σημαντικότερες αλλαγές σε αυτή τη νέα έκδοση:</p></div><div class=ulist><ul><li><p>Το <a href=./#config-tuning>Ρύθμιση και Βελτιστοποίηση</a> επεκτάθηκε με νέες πληροφορίες για τη διαχείριση ενέργειας και πόρων του συστήματος μέσω ACPI, με περισσότερες πληροφορίες για το σύστημα <code>cron</code> και με περισσότερες επιλογές παραμετροποίησης του πυρήνα του FreeBSD.</p></li><li><p>Το <a href=./#security>Ασφάλεια</a> επεκτάθηκε με νέες πληροφορίες για Δίκτυα VPN, για λίστες ελέγχου πρόσβασης αρχείων (ACLs) και περισσότερες συμβουλές σχετικά με την ασφάλεια του FreeBSD.</p></li><li><p>Το <a href=./#mac>Υποχρεωτικός Έλεγχος Πρόσβασης</a> είναι ένα νέο κεφάλαιο σε αυτή την έκδοση. Εξηγεί τι είναι ο μηχανισμός MAC και πώς μπορεί να χρησιμοποιηθεί για να ενισχυθεί η ασφάλεια ενός συστήματος FreeBSD.</p></li><li><p>Το <a href=./#disks>Αποθηκευτικά Μέσα</a> επεκτάθηκε, με νέες πληροφορίες για συσκευές αποθήκευσης USB, στιγμιότυπα συστήματος αρχείων (snapshots), περιορισμούς στη χρήση των συστημάτων αρχείων (quotas), συστήματα αρχείων που βασίζονται σε υπάρχοντα αρχεία ή στο δίκτυο, καθώς και κρυπτογραφημένες κατατμήσεις δίσκων.</p></li><li><p>Προστέθηκε μια ενότητα σχετικά με την αντιμετώπιση προβλημάτων στο <a href=./#ppp-and-slip>PPP και SLIP</a>.</p></li><li><p>Το <a href=./#mail>Ηλεκτρονικό Ταχυδρομείο</a> επεκτάθηκε με νέες πληροφορίες για την χρήση εναλλακτικών MTA, πιστοποίηση ταυτότητας στο SMTP, το πρωτόκολλο UUCP, τα εργαλεία fetchmail και procmail και με άλλα θέματα για προχωρημένους.</p></li><li><p>Το <a href=./#network-servers>Εξυπηρετητές Δικτύου</a> περιλαμβάνεται για πρώτη φορά σε αυτή την έκδοση. Αυτό το κεφάλαιο περιγράφει πως να εγκαταστήσετε τον Διακομιστή HTTP Apache, τον εξυπηρετητή ftpd του FreeBSD και τον διακομιστή Samba για επικοινωνία με πελάτες Microsoft® Windows®. Στο κεφάλαιο αυτό, έχουν μεταφερθεί κάποιες ενότητες από το <a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a> (Προχωρημένα Θέματα Δικτύωσης), προκειμένου να βελτιωθεί η παρουσίαση τους.</p></li><li><p>Το <a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a> επεκτάθηκε με νέες πληροφορίες για τη χρήση συσκευών Bluetooth® στο FreeBSD, την εγκατάσταση ασύρματων δικτύων, και την Μέθοδο Δικτύωσης Ασύγχρονης Μεταφοράς (ATM).</p></li><li><p>Προστέθηκε ένα Λεξιλόγιο, για να συγκεντρώσει όλους τους τεχνικούς όρους και τους διάφορους ορισμούς που περιέχονται σε ολόκληρο το βιβλίο.</p></li><li><p>Έγιναν αισθητικές βελτιώσεις στους πίνακες και στα γραφήματα σε ολόκληρο το βιβλίο.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes>Αλλαγές από την Πρώτη Έκδοση (2001)<a class=anchor href=#preface-changes></a></h3><div class=paragraph><p>Η δεύτερη έκδοση ήταν το αποτέλεσμα τουλάχιστον δύο χρόνων εργασίας από τα μέλη της Ομάδας Τεκμηρίωσης του FreeBSD. Οι πιο σημαντικές αλλαγές σε αυτή την έκδοση ήταν οι παρακάτω:</p></div><div class=ulist><ul><li><p>Προστέθηκε ένα ολοκληρωμένο Ευρετήριο.</p></li><li><p>Όλα τα γραφήματα σε ASCII αντικαταστάθηκαν από γραφικά διαγράμματα.</p></li><li><p>Προστέθηκε μια τυποποιημένη σύνοψη σε κάθε κεφάλαιο, η οποία περιέχει μια σύντομη ανακεφαλαίωση των πληροφοριών που περιέχει το κεφάλαιο και τι αναμένεται να γνωρίζει από πριν ο αναγνώστης.</p></li><li><p>Το περιεχόμενο αναδιοργανώθηκε σε τρία λογικά μέρη: "Ξεκινώντας με το FreeBSD", "Διαχείριση Συστήματος" και "Παραρτήματα".</p></li><li><p>Το <a href=./#install>Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a> ξαναγράφτηκε από την αρχή με πολλές εικόνες, ώστε να διευκολύνει τους χρήστες να κατανοήσουν το κείμενο.</p></li><li><p>Το <a href=./#basics>Βασικές Έννοιες στο UNIX®</a> επεκτάθηκε ώστε να συμπεριλαμβάνει πρόσθετες πληροφορίες για τις διεργασίες (processes), τους δαίμονες (daemons), και τα σήματα (signals).</p></li><li><p>Το <a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a> επεκτάθηκε ώστε να συμπεριλαμβάνει πρόσθετες πληροφορίες για την διαχείριση προμεταγλωττισμένων πακέτων (packages).</p></li><li><p>Το <a href=./#x11>Το Σύστημα X Window</a> ξαναγράφτηκε από την αρχή με έμφαση στην χρήση μοντέρνων τεχνολογιών, όπως τα περιβάλλοντα εργασίας KDE και GNOME σε XFree86™ 4.X.</p></li><li><p>Το <a href=./#boot>Η Διαδικασία Εκκίνησης του FreeBSD</a> επεκτάθηκε με περισσότερες πληροφορίες.</p></li><li><p>Το <a href=./#disks>Αποθηκευτικά Μέσα</a> ξαναγράφτηκε με βάση τα παλαιότερα δύο κεφάλαια "Δίσκοι" και "Αντίγραφα Ασφαλείας". Πιστεύουμε ότι τα θέματα αυτά είναι πιο ευκολονόητα όταν παρουσιάζονται μαζί σαν ένα κεφάλαιο. Προστέθηκε επίσης μια ενότητα για RAID (υλοποίηση μέσω υλικού ή λογισμικού).</p></li><li><p>Το <a href=./#serialcomms>Σειριακές Επικοινωνίες</a> αναδιοργανώθηκε από την αρχή και ενημερώθηκε για τις εκδόσεις FreeBSD 4.X/5.X.</p></li><li><p>Το <a href=./#ppp-and-slip>PPP και SLIP</a> ενημερώθηκε σε σημαντικό βαθμό.</p></li><li><p>Πολλοί νέοι τομείς προστέθηκαν στο <a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a>.</p></li><li><p>Το <a href=./#mail>Ηλεκτρονικό Ταχυδρομείο</a> επεκτάθηκε για να συμπεριλαμβάνει περισσότερες πληροφορίες για τις ρυθμίσεις του sendmail.</p></li><li><p>Το <a href=./#linuxemu>Συμβατότητα με Εκτελέσιμα του Linux</a> επεκτάθηκε για να συμπεριλαμβάνει πληροφορίες για την εγκατάσταση της βάσης δεδομένων Oracle® και του SAP® R/3®.</p></li><li><p>Στην δεύτερη έκδοση καλύπτονται επίσης τα παρακάτω νέα θέματα:</p><div class=ulist><ul><li><p><a href=./#config-tuning>Ρύθμιση και Βελτιστοποίηση</a>.</p></li><li><p><a href=./#multimedia>Πολυμέσα</a>.</p></li></ul></div></li></ul></div></div><div class=sect2><h3 id=preface-overview>Οργάνωση Αυτού του Βιβλίου<a class=anchor href=#preface-overview></a></h3><div class=paragraph><p>Αυτό το βιβλίο χωρίζεται σε πέντε διακριτά λογικά τμήματα. Το πρώτο τμήμα, <em>Ξεκινώντας με το FreeBSD</em>, περιγράφει την εγκατάσταση και την βασική χρήση του FreeBSD. Ο προτεινόμενος τρόπος ανάγνωσης αυτού του τμήματος είναι ένα-ένα κεφάλαιο, με τη σειρά, προσπερνώντας κεφάλαια με γνωστά θέματα. Το δεύτερο τμήμα, <em>Βασικές Εργασίες</em>, περιγράφει μερικά χαρακτηριστικά του FreeBSD τα οποία χρησιμοποιούνται συχνά. Μπορείτε να διαβάσετε τα κεφάλαια σε αυτό το τμήμα (καθώς και σε όλα τα τμήματα που ακολουθούν) με όποια σειρά θέλετε. Κάθε κεφάλαιο ξεκινά με μια σαφή και σύντομη σύνοψη, η οποία περιγράφει τα περιεχόμενα του κεφαλαίου καθώς και τι χρειάζεται να γνωρίζει ήδη ο αναγνώστης. Αυτό επιτρέπει στον περιστασιακό αναγνώστη να προσπερνά γρήγορα ενότητες, για να βρει κεφάλαια τα οποία τον ενδιαφέρουν περισσότερο. Το τρίτο τμήμα, <em>Διαχείριση Συστήματος</em>, περιέχει θέματα σχετικά με τη διαχείριση συστημάτων FreeBSD. Το τέταρτο τμήμα, <em>Δικτυακές Επικοινωνίες</em>, καλύπτει θέματα δικτύωσης και διακομιστών. Το πέμπτο τμήμα περιέχει παραρτήματα με διάφορες πληροφορίες.</p></div><div class=dlist><dl><dt class=hdlist1><em><a href=./#introduction>Εισαγωγή</a></em></dt><dd><p>Παρουσιάζει το FreeBSD στο νέο χρήστη. Περιγράφει την ιστορία του FreeBSD Project, τους στόχους του και το μοντέλο ανάπτυξης του.</p></dd><dt class=hdlist1><em><a href=./#bsdinstall>Εγκατάσταση του FreeBSD 9.x και Μεταγενέστερων Εκδόσεων</a></em></dt><dd><p>Οδηγεί τον χρήστη στην διαδικασία εγκατάστασης του FreeBSD 9.<em>x</em> και μεταγενέστερων εκδόσεων με τη χρήση του bsdinstall.</p></dd><dt class=hdlist1><em><a href=./#install>Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a></em></dt><dd><p>Οδηγεί τον χρήστη στην διαδικασία εγκατάστασης του FreeBSD 8.<em>x</em> και προγενέστερων εκδόσεων με τη χρήση του sysinstall. Συμπεριλαμβάνονται επίσης μερικά θέματα εγκατάστασης για προχωρημένους, όπως η εγκατάσταση μέσω σειριακής κονσόλας.</p></dd><dt class=hdlist1><em><a href=./#basics>Βασικές Έννοιες στο UNIX®</a></em></dt><dd><p>Περιέχει τις βασικές εντολές και λειτουργίες του λειτουργικού συστήματος FreeBSD. Εάν είστε εξοικειωμένος με το Linux® ή με άλλο λειτουργικό τύπου UNIX® μπορείτε πιθανώς να προσπεράσετε αυτό το κεφάλαιο.</p></dd><dt class=hdlist1><em><a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a></em></dt><dd><p>Περιγράφει τον τρόπο εγκατάστασης λογισμικού τρίτων κατασκευαστών με την καινοτόμο "Συλλογή των Ports (Ports Collection)" του FreeBSD και με τα συνήθη προμεταγλωττισμένα πακέτα (packages).</p></dd><dt class=hdlist1><em><a href=./#x11>Το Σύστημα X Window</a></em></dt><dd><p>Περιγράφει γενικά το σύστημα X Window και ειδικότερα το X11 του FreeBSD. Επίσης περιγράφει ολοκληρωμένα περιβάλλοντα εργασίας όπως το KDE και το GNOME.</p></dd><dt class=hdlist1><em><a href=./#desktop>Desktop Εφαρμογές</a></em></dt><dd><p>Αναφέρει και εξηγεί μερικές από τις πιο συνήθεις εφαρμογές για υπολογιστές γραφείου, όπως προγράμματα πλοήγησης ιστοσελίδων και εφαρμογές γραφείου και περιγράφει πως να τις εγκαταστήσετε στο FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#multimedia>Πολυμέσα</a></em></dt><dd><p>Υποδεικνύει πως να εγκαταστήσετε δυνατότητες αναπαραγωγής ήχου και βίντεο στο σύστημα σας. Επίσης περιλαμβάνει δειγματοληπτικά κάποιες εφαρμογές ήχου και βίντεο.</p></dd><dt class=hdlist1><em><a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a></em></dt><dd><p>Εξηγεί τους λόγους για τους οποίους θα πρέπει να δημιουργήσετε ένα νέο πυρήνα. Παρέχει, επίσης, λεπτομερείς οδηγίες για την ρύθμιση, μεταγλώττιση και εγκατάσταση του νέου σας προσαρμοσμένου πυρήνα.</p></dd><dt class=hdlist1><em><a href=./#printing>Εκτυπώσεις</a></em></dt><dd><p>Περιγράφει πως να διαχειρίζεστε εκτυπωτές στο FreeBSD. Συμπεριλαμβάνει πληροφορίες για σελίδες λογοτύπων, λογαριασμούς εκτυπωτών και αρχικές ρυθμίσεις.</p></dd><dt class=hdlist1><em><a href=./#linuxemu>Συμβατότητα με Εκτελέσιμα του Linux</a></em></dt><dd><p>Περιγράφει τις δυνατότητες συμβατότητας του FreeBSD με εφαρμογές Linux®. Επίσης παρέχει λεπτομερείς οδηγίες εγκατάστασης για πολλές γνωστές εφαρμογές του Linux® όπως Oracle®, και Mathematica®.</p></dd><dt class=hdlist1><em><a href=./#config-tuning>Ρύθμιση και Βελτιστοποίηση</a></em></dt><dd><p>Περιγράφει τις παραμέτρους που έχουν στη διάθεση τους οι διαχειριστές του συστήματος, ώστε να ρυθμίσουν ένα σύστημα FreeBSD για βέλτιστη απόδοση. Επίσης περιγράφει τα διάφορα αρχεία ρυθμίσεων που χρησιμοποιούνται στο FreeBSD και που να τα βρείτε.</p></dd><dt class=hdlist1><em><a href=./#boot>Η Διαδικασία Εκκίνησης του FreeBSD</a></em></dt><dd><p>Περιγράφει την διαδικασία εκκίνησης του FreeBSD και εξηγεί πως μπορούμε να την ελέγχουμε με τη βοήθεια επιλογών και ρυθμίσεων.</p></dd><dt class=hdlist1><em><a href=./#users>Χρήστες και Βασική Διαχείριση Λογαριασμών</a></em></dt><dd><p>Περιγράφει την δημιουργία και την διαχείριση των λογαριασμών χρηστών. Επίσης περιγράφει τρόπους με τους οποίους μπορούν να τεθούν περιορισμοί στους χρήστες όσο αφορά τη χρήση πόρων του συστήματος, καθώς και άλλες λειτουργίες διαχείρισης λογαριασμών.</p></dd><dt class=hdlist1><em><a href=./#security>Ασφάλεια</a></em></dt><dd><p>Περιγράφει διάφορα διαθέσιμα εργαλεία που θα σας βοηθήσουν να κρατήσετε το FreeBSD σύστημα σας ασφαλές. Συμπεριλαμβάνονται οι υλοποιήσεις Kerberos, IPsec και OpenSSH.</p></dd><dt class=hdlist1><em><a href=./#jails>Jails</a></em></dt><dd><p>Περιγράφει το πλαίσιο λειτουργιών των jails και τις βελτιώσεις που παρέχουν σε σχέση με την παραδοσιακή chroot υποστήριξη του FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mac>Υποχρεωτικός Έλεγχος Πρόσβασης</a></em></dt><dd><p>Εξηγεί τι είναι ο Υποχρεωτικός Έλεγχος Πρόσβασης (MAC) και πως ο μηχανισμός αυτός μπορεί να χρησιμοποιηθεί για την ασφάλιση ενός FreeBSD συστήματος.</p></dd><dt class=hdlist1><em><a href=./#audit>Έλεγχος Συμβάντων Ασφαλείας</a></em></dt><dd><p>Περιγράφει τι είναι ο Έλεγχος Συμβάντων, πως μπορεί να εγκατασταθεί, να ρυθμιστεί και πως μπορούν να διερευνώνται και να παρακολουθούνται τα ίχνη του ελέγχου (audit trails).</p></dd><dt class=hdlist1><em><a href=./#disks>Αποθηκευτικά Μέσα</a></em></dt><dd><p>Περιγράφει πως να διαχειρίζεστε μέσα αποθήκευσης και συστήματα αρχείων με το FreeBSD. Συμπεριλαμβάνονται φυσικοί δίσκοι, συστοιχίες RAID, οπτικά και μαγνητικά μέσα, εικονικοί δίσκοι μνήμης και δικτυακά συστήματα αρχείων.</p></dd><dt class=hdlist1><em><a href=./#geom>GEOM: Διαχείριση Συστοιχιών Δίσκων</a></em></dt><dd><p>Περιγράφει τι είναι το πλαίσιο λειτουργιών GEOM στο FreeBSD και πως να ρυθμίσετε διάφορα επίπεδα RAID που υποστηρίζονται στο FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#filesystems>Υποστήριξη Συστημάτων Αρχείων</a></em></dt><dd><p>Εξετάζει την υποστήριξη μη-εγγενών συστημάτων αρχείων στο FreeBSD, όπως το Z File System της Sun™.</p></dd><dt class=hdlist1><em><a href=./#virtualization>Εικονικοποίηση</a></em></dt><dd><p>Περιγράφει τι προσφέρουν τα συστήματα εικονικοποίησης και πως μπορούν να χρησιμοποιηθούν με το FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#l10n>Τοπικές Ρυθμίσεις - Χρήση και ρύθμιση I18N/L10N</a></em></dt><dd><p>Περιγράφει πως να χρησιμοποιήσετε το FreeBSD σε γλώσσες εκτός της Αγγλικής. Καλύπτει την δυνατότητα τοπικών ρυθμίσεων τόσο σε επίπεδο συστήματος, όσο και σε επίπεδο εφαρμογών.</p></dd><dt class=hdlist1><em><a href=./#updating-upgrading>Ενημέρωση και Αναβάθμιση του FreeBSD</a></em></dt><dd><p>Εξηγεί τις διαφορές μεταξύ των εκδόσεων FreeBSD-STABLE, FreeBSD-CURRENT και των επίσημων (RELEASE) εκδόσεων του FreeBSD. Περιγράφει ποιοι χρήστες ωφελούνται όταν ακολουθούν ένα σύστημα ανάπτυξης καθώς και τα απαιτούμενα για αυτό το σκοπό βήματα. Καλύπτει τις μεθόδους που μπορούν να χρησιμοποιήσουν οι χρήστες για να ενημερώσουν το σύστημα τους με τις τελευταίες διορθώσεις ασφαλείας.</p></dd><dt class=hdlist1><em><a href=./#dtrace>DTrace</a></em></dt><dd><p>Περιγράφει την ρύθμιση και χρήση του εργαλείου DTrace της Sun™ στο FreeBSD. Το δυναμικό tracing μπορεί να βοηθήσει στον εντοπισμό προβλημάτων απόδοσης, παρέχοντας ανάλυση του συστήματος σε πραγματικό χρόνο.</p></dd><dt class=hdlist1><em><a href=./#serialcomms>Σειριακές Επικοινωνίες</a></em></dt><dd><p>Εξηγεί πως να συνδέσετε τερματικά και μόντεμ στο FreeBSD σύστημα σας, για χρήση τόσο σε εισερχόμενες όσο και σε εξερχόμενες συνδέσεις.</p></dd><dt class=hdlist1><em><a href=./#ppp-and-slip>PPP και SLIP</a></em></dt><dd><p>Περιγράφει πως να χρησιμοποιήσετε τις τεχνολογίες PPP, SLIP, ή PPP μέσω Ethernet για να συνδεθείτε σε απομακρυσμένα συστήματα με το FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mail>Ηλεκτρονικό Ταχυδρομείο</a></em></dt><dd><p>Εξηγεί τα διαφορετικά στοιχεία ενός διακομιστή ηλεκτρονικής αλληλογραφίας και εμβαθύνει σε θέματα απλών ρυθμίσεων για το πλέον δημοφιλές λογισμικό διακομιστή ηλεκτρονικής αλληλογραφίας: το sendmail.</p></dd><dt class=hdlist1><em><a href=./#network-servers>Εξυπηρετητές Δικτύου</a></em></dt><dd><p>Παρέχει λεπτομερείς οδηγίες και παραδείγματα αρχείων ρύθμισης για να ρυθμίσετε το FreeBSD να ενεργεί ως δικτυακός εξυπηρετητής αρχείων, εξυπηρετητής ονομάτων τομέα (DNS), εξυπηρετητής δικτυακών πληροφοριών (NIS), η εξυπηρετητής συγχρονισμού ώρας (NTP).</p></dd><dt class=hdlist1><em><a href=./#firewalls>Firewalls</a></em></dt><dd><p>Εξηγεί την φιλοσοφία που κρύβεται πίσω από τα firewalls (τείχη προστασίας) που βασίζονται σε λογισμικό και παρέχει λεπτομερείς πληροφορίες για τις ρυθμίσεις των διαφόρων firewalls που διατίθενται για το FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a></em></dt><dd><p>Περιγράφει πολλά προχωρημένα θέματα δικτύωσης, συμπεριλαμβανομένου του διαμοιρασμού μιας σύνδεσης Internet με άλλους υπολογιστές στο τοπικό σας δίκτυο (LAN), θέματα δρομολόγησης για προχωρημένους, ασύρματη δικτύωση, Bluetooth®, ATM, IPv6 και πολλά ακόμη.</p></dd><dt class=hdlist1><em><a href=./#mirrors>Που θα Βρείτε το FreeBSD</a></em></dt><dd><p>Περιέχει λίστα με διάφορες πηγές για να αποκτήσετε το FreeBSD σε CD-ROM ή DVD, όπως επίσης και διάφορες τοποθεσίες στο Internet από όπου μπορείτε να κατεβάσετε και να εγκαταστήσετε το FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#bibliography>Βιβλιογραφία</a></em></dt><dd><p>Αυτό το βιβλίο αγγίζει πολλά διαφορετικά θέματα που μπορεί να σας κεντρίσουν το ενδιαφέρον για μια πιο λεπτομερή εξερεύνηση. Η βιβλιογραφία ταξινομεί σε κατηγορίες πολλά εξαιρετικά βιβλία τα οποία αναφέρονται στο κείμενο.</p></dd><dt class=hdlist1><em><a href=./#eresources>Πηγές Πληροφόρησης στο Διαδίκτυο</a></em></dt><dd><p>Περιγράφει πολλά φόρουμ που διατίθενται στους χρήστες του FreeBSD, ώστε να θέτουν ερωτήματα και να συμμετέχουν σε τεχνικές συζητήσεις για το FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#pgpkeys>Κλειδιά PGP</a></em></dt><dd><p>Καταγράφει τα δακτυλικά αποτυπώματα των κλειδιών PGP αρκετών μελών της Ομάδας Ανάπτυξης του FreeBSD.</p></dd></dl></div></div><div class=sect2><h3 id=preface-conv>Συμβάσεις που χρησιμοποιούνται σε αυτό το βιβλίο<a class=anchor href=#preface-conv></a></h3><div class=paragraph><p>Σε ολόκληρο το βιβλίο, χρησιμοποιούνται κάποιες τυπογραφικές συμβάσεις ώστε η μορφοποίηση του να είναι συνεπής και να είναι πιο ευανάγνωστο:</p></div><div class=sect3><h4 id=preface-conv-typographic>Τυπογραφικές Συμβάσεις<a class=anchor href=#preface-conv-typographic></a></h4><div class=dlist><dl><dt class=hdlist1><em>Πλάγια γραφή</em></dt><dd><p>Η <em>πλάγια</em> γραμματοσειρά χρησιμοποιείται για ονόματα αρχείων, URLs, κείμενο με έμφαση και για χρήση πρωτοεμφανιζόμενων τεχνικών όρων.</p></dd><dt class=hdlist1><code>Γραφή σταθερού πλάτους</code></dt><dd><p>Η <code>σταθερού πλάτους</code> γραμματοσειρά χρησιμοποιείται για μηνύματα λάθους, εντολές, μεταβλητές περιβάλλοντος, ονομασίες των ports, ονόματα κεντρικών υπολογιστών, ονόματα χρηστών, ονόματα ομάδων, ονόματα συσκευών, μεταβλητές και αποσπάσματα κώδικα.</p></dd><dt class=hdlist1>Έντονη γραφή</dt><dd><p>Η έντονη γραμματοσειρά χρησιμοποιείται για εφαρμογές, εντολές και πλήκτρα.</p></dd></dl></div></div><div class=sect3><h4 id=preface-conv-commands>Είσοδος Δεδομένων από το Χρήστη<a class=anchor href=#preface-conv-commands></a></h4><div class=paragraph><p>Η πληκτρολόγηση σημειώνεται με <strong>έντονη</strong> γραφή ώστε να ξεχωρίζει από το υπόλοιπο κείμενο. Συνδυασμοί πλήκτρων που πρέπει να πιεσθούν ταυτόχρονα σημειώνονται με `+’ μεταξύ των πλήκτρων, όπως:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span></p></div><div class=paragraph><p>Το οποίο σημαίνει πως ο χρήστης θα πρέπει να πιέσει τα πλήκτρα <kbd>Ctrl</kbd>, <kbd>Alt</kbd> και το πλήκτρο <kbd>Del</kbd> ταυτόχρονα.</p></div><div class=paragraph><p>Σε περίπτωση που κάποια πλήκτρα πρέπει να πιεσθούν με συγκεκριμένη σειρά, θα εμφανίζονται χωρισμένα με κόμματα:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p></div><div class=paragraph><p>Το οποίο σημαίνει πως ο χρήστης αναμένεται να πιέσει τα πλήκτρα <kbd>Ctrl</kbd> και <kbd>X</kbd> ταυτόχρονα και έπειτα να πιέσει τα πλήκτρα <kbd>Ctrl</kbd> και <kbd>S</kbd> ταυτόχρονα.</p></div></div><div class=sect3><h4 id=preface-conv-examples>Παραδείγματα<a class=anchor href=#preface-conv-examples></a></h4><div class=paragraph><p>Τα παραδείγματα που ξεκινούν με <span class=filename>C:\></span> υποδηλώνουν μια εντολή MS-DOS®. Αυτές οι εντολές μπορούν να εκτελούνται από το παράθυρο "Γραμμής Εντολών" σε σύγχρονο περιβάλλον Microsoft® Windows®, εκτός αν αναφέρεται κάτι διαφορετικό.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>E:<span class=se>\&gt;</span> tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>Τα παραδείγματα που ξεκινούν με # υποδηλώνουν μια εντολή που θα πρέπει να εκτελεστεί από τον υπερχρήστη (superuser) ενός συστήματος FreeBSD. Μπορείτε να συνδεθείτε σαν χρήστης <code>root</code> για να πληκτρολογήσετε την εντολή, ή να συνδεθείτε σαν κανονικός χρήστης και να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> ώστε να αποκτήσετε προνόμια υπερχρήστη.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>Τα παραδείγματα που ξεκινούν με % υποδηλώνουν μια εντολή που πρέπει να εκτελεστεί από ένα κανονικό χρήστη. Χρησιμοποιείται η σύνταξη C-shell για να θέσουμε μεταβλητές περιβάλλοντος και άλλες εντολές κελύφους, εκτός αν αναφέρεται κάτι διαφορετικό.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top</code></pre></div></div></div></div><div class=sect2><h3 id=preface-acknowledgements>Ευχαριστίες<a class=anchor href=#preface-acknowledgements></a></h3><div class=paragraph><p>Το βιβλίο που κρατάτε, παρουσιάζει τις προσπάθειες πολλών εκατοντάδων ανθρώπων από όλο τον κόσμο. Είτε μας ενημέρωσαν για τυπογραφικά λάθη, είτε μας έστειλαν ολόκληρα κεφάλαια, η συμβολή όλων ήταν χρήσιμη.</p></div><div class=paragraph><p>Μερικές εταιρείες υποστήριξαν την ανάπτυξη αυτού του εγγράφου μισθώνοντας συντάκτες να εργάζονται σε πλήρη απασχόληση, πληρώνοντας για την έκδοση, κτλ. Ειδικότερα, η BSDi (η οποία αργότερα αποκτήθηκε από την <a href=http://www.windriver.com>Wind River Systems</a>) μίσθωσε μέλη του FreeBSD Documentation Project να εργάζονται σε πλήρη απασχόληση για την βελτίωση του βιβλίου, οδηγώντας στην πρώτη έντυπη έκδοση στα αγγλικά τον Μάρτιο του 2000 (ISBN 1-57176-241-8). Η εταιρεία Wind River Systems μίσθωσε τότε μερικούς επιπρόσθετους συντάκτες ώστε να κάνει βελτιώσεις στην δομή της έντυπης έκδοσης και να προσθέσει κάποια νέα κεφάλαια. Η αποκορύφωση αυτής της εργασίας ήταν η παρουσίαση της δεύτερης έντυπης έκδοσης, τον Νοέμβριο του 2001 (ISBN 1-57176-303-1). 1-57176-303-1). Το 2003-2004, η <a href=http://www.freebsdmall.com>FreeBSD Mall, Inc</a>, μίσθωσε αρκετούς συνεργάτες να βελτιώσουν το Εγχειρίδιο Χρήσης προς ετοιμασία της τρίτης έντυπης έκδοσης.</p></div><div class=paragraph><p>path: "/books/handbook/parti/"
---
:leveloffset: +1</p></div></div></div></div><h1 id=introduction class=sect0>Part I: Εισαγωγή<a class=anchor href=#introduction></a></h1><div class=sect1><h2 id=introduction-synopsis>Chapter 1. Σύνοψη<a class=anchor href=#introduction-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Ευχαριστούμε για το ενδιαφέρον σας για το FreeBSD! Το ακόλουθο κεφάλαιο καλύπτει διάφορες πτυχές του FreeBSD Project, όπως την ιστορία του, τους στόχους του, το μοντέλο ανάπτυξης, κ.τ.λ.</p></div><div class=paragraph><p>Μετά την ανάγνωση αυτού του κεφαλαίου, θα γνωρίζετε:</p></div><div class=ulist><ul><li><p>Πως σχετίζεται το FreeBSD με άλλα λειτουργικά συστήματα Η/Υ.</p></li><li><p>Την ιστορία του FreeBSD Project.</p></li><li><p>Τους στόχους του FreeBSD Project.</p></li><li><p>Τις βασικές αρχές του open-source μοντέλου ανάπτυξης του FreeBSD.</p></li><li><p>Και φυσικά: από που προέρχεται το όνομα "FreeBSD".</p></li></ul></div></div></div><div class=sect1><h2 id=nutshell>Chapter 2. Καλώς ήλθατε στο FreeBSD!<a class=anchor href=#nutshell></a></h2><div class=sectionbody><div class=paragraph><p>Το FreeBSD είναι ένα λειτουργικό σύστημα βασισμένο στο 4.4BSD-Lite, το οποίο μπορεί να χρησιμοποιηθεί σε Η/Υ Intel (x86 και Itanium®), AMD64 και Sun UltraSPARC®. Σε εξέλιξη βρίσκεται επίσης η διαδικασία μεταφοράς του FreeBSD σε άλλες αρχιτεκτονικές. Μπορείτε επίσης να διαβάσετε για <a href=#history>την ιστορία του FreeBSD</a>, ή για την <a href=#relnotes>πιο πρόσφατη επίσημη έκδοση του</a>. Εάν ενδιαφέρεστε να συμβάλλετε με κάποιο τρόπο στο Project (κώδικα, hardware, χρηματοδότηση), διαβάστε το άρθρο <a href=https://docs.freebsd.org/el/articles/contributing/>Συνεισφέροντας στην Ανάπτυξη του FreeBSD</a>.</p></div><div class=sect2><h3 id=os-overview>2.1. Τι μπορεί να κάνει το FreeBSD;<a class=anchor href=#os-overview></a></h3><div class=paragraph><p>Το FreeBSD έχει πολλά αξιόλογα χαρακτηριστικά. Μερικά από αυτά είναι:</p></div><div class=ulist><ul><li><p><em>Preemptive πολυεπεξεργασία</em> (preemptive multitasking) με δυναμικό έλεγχο προτεραιότητας για να εξασφαλιστεί ομαλός και δίκαιος διαμοιρασμός των πόρων του Η/Υ μεταξύ εφαρμογών και χρηστών, ακόμη και στις πιο αντίξοες συνθήκες και βαρύ φορτίο.</p></li><li><p><em>Πολυχρηστικές δυνατότητες</em> (multi-user facilities) οι οποίες επιτρέπουν σε πολλά άτομα ταυτόχρονα να χρησιμοποιήσουν ένα σύστημα FreeBSD για διαφορετικά πράγματα. Αυτό σημαίνει, για παράδειγμα, ότι τα περιφερειακά του συστήματος, όπως εκτυπωτές και οδηγοί ταινιών είναι σωστά μοιρασμένα μεταξύ όλων των χρηστών του συστήματος ή του δικτύου και πως μπορούν να τεθούν συγκεκριμένα όρια σε χρήστες ή ομάδες χρηστών, προστατεύοντας κρίσιμους πόρους του συστήματος από υπερβολική χρήση.</p></li><li><p>Ισχυρές δυνατότητες <em>δικτύωσης TCP/IP</em> (TCP/IP networking) με υποστήριξη για βιομηχανικά πρότυπα όπως τα SCTP, DHCP, NFS, NIS, PPP, SLIP, IPsec και IPv6. Αυτό σημαίνει πως ένα μηχάνημα FreeBSD μπορεί να αλληλεπιδρά εύκολα με άλλα συστήματα και να εργάζεται σαν εταιρικός εξυπηρετητής, υποστηρίζοντας λειτουργίες ζωτικής σημασίας, όπως NFS (απομακρυσμένη πρόσβαση σε αρχεία) και υπηρεσίες ηλεκτρονικού ταχυδρομείου (e-mail), ή την παρουσία του οργανισμού σας στο διαδίκτυο μέσω των υπηρεσιών WWW, FTP, routing και firewall (ασφάλειας).</p></li><li><p>Η <em>προστασία της μνήμης</em> (memory protection) εξασφαλίζει ότι οι διάφορες εφαρμογές (ή οι χρήστες) δεν αλληλεπιδρούν μεταξύ τους. Μια εφαρμογή που παρουσιάζει κάποιο πρόβλημα δε μπορεί να επηρεάσει άλλες με κανέναν τρόπο.</p></li><li><p>Το βιομηχανικό πρότυπο <em>X Window System</em> (X11R6) προσφέρει γραφικό περιβάλλον εργασίας (GUI) σε οποιοδήποτε μηχάνημα και διατίθεται με τον πλήρη πηγαίο κώδικα.</p></li><li><p><em>Συμβατότητα εκτελέσιμων</em> με πολλά προγράμματα που έχουν μεταγλωττιστεί για Linux, SCO, SVR4, BSDI και NetBSD.</p></li><li><p>Χιλιάδες <em>έτοιμες-προς-εκτέλεση</em> εφαρμογές είναι διαθέσιμες από την συλλογή <em>ports</em> και <em>packages</em> για το FreeBSD. Γιατί να ψάχνετε στο διαδίκτυο όταν μπορείτε να τα βρείτε όλα εδώ;</p></li><li><p>Στο διαδίκτυο είναι επίσης διαθέσιμες χιλιάδες πρόσθετες και <em>εύκολες στην προσαρμογή</em> εφαρμογές. Το FreeBSD έχει συμβατότητα πηγαίου κώδικα με τα πιο δημοφιλή εμπορικά συστήματα UNIX®, επομένως οι περισσότερες εφαρμογές χρειάζονται λίγες έως καθόλου μετατροπές για να μεταγλωττιστούν (compile).</p></li><li><p>Η κατά απαίτηση σελιδοποίηση <em>εικονικής μνήμης</em> και το "ολοκληρωμένο VM/buffer cache" παρέχουν υψηλή απόδοση σε εφαρμογές με αυξημένες ανάγκες σε μνήμη, ενώ διατηρούν την ικανοποιητική απόκριση του συστήματος στους άλλους χρήστες.</p></li><li><p>Υποστήριξη <em>SMP</em> για μηχανήματα με πολλαπλές CPU.</p></li><li><p>Πλήρης σειρά εργαλείων ανάπτυξης για <em>C</em>, <em>C++</em>. Στη Συλλογή των Ports και των έτοιμων πακέτων, θα βρείτε πολλές ακόμα γλώσσες προγραμματισμού, κατάλληλες τόσο για έρευνα όσο και για ανάπτυξη λογισμικού.</p></li><li><p><em>Η διαθεσιμότητα του πηγαίου κώδικα</em> ολόκληρου του συστήματος σημαίνει ότι έχετε τον υψηλότερο βαθμό ελέγχου στο περιβάλλον σας. Γιατί να είστε κλειδωμένοι σε ένα κλειστό σύστημα και να είστε εξαρτημένοι από τον προμηθευτή σας, όταν μπορείτε να έχετε ένα πραγματικά ανοιχτό σύστημα;</p></li><li><p>Εκτεταμένη <em>online τεκμηρίωση</em>.</p></li><li><p><em>Και πολλά άλλα!</em></p></li></ul></div><div class=paragraph><p>Το FreeBSD βασίζεται στην έκδοση 4.4BSD-Lite του Computer Systems Research Group (CSRG) του Πανεπιστημίου της Καλιφόρνιας στο Berkeley, και συνεχίζει την διακεκριμένη παράδοση του στην ανάπτυξη συστημάτων BSD. Επιπρόσθετα στο εξαίρετο έργο που παρείχε το CSRG, το FreeBSD Project ξόδεψε πολλές χιλιάδες ώρες στη βελτιστοποίηση του συστήματος για μέγιστες επιδόσεις και αξιοπιστία σε καθημερινές καταστάσεις πραγματικού φόρτου εργασίας. Το FreeBSD προσφέρει απόδοση και αξιοπιστία ισάξια με αντίστοιχων εμπορικών συστημάτων και τα συνδυάζει με τελευταίες τεχνολογιές και χαρακτηριστικά που δεν υπάρχουν πουθενά αλλού.</p></div><div class=paragraph><p>Οι εφαρμογές στις οποίες μπορεί να χρησιμοποιηθεί το FreeBSD, πραγματικά περιορίζονται μόνο από την φαντασία σας. Από ανάπτυξη λογισμικού μέχρι αυτοματισμούς εργοστασίων, από απογραφή ειδών μέχρι την διόρθωση του αζιμούθιου απομακρυσμένων δορυφορικών κεραιών, εάν μπορεί να γίνει με ένα εμπορικό προϊόν UNIX®, είναι παραπάνω από πιθανό ότι μπορεί να γίνει και με το FreeBSD! Το FreeBSD επίσης ωφελείται σημαντικά από κυριολεκτικά χιλιάδες εφαρμογές υψηλής ποιότητας που αναπτύσσονται από κέντρα ερευνών και πανεπιστήμια σε όλο τον κόσμο, και συχνά διατίθενται σε χαμηλό κόστος ή δωρεάν. Το πλήθος των εμπορικών εφαρμογών που διατίθενται για το FreeBSD, αυξάνεται επίσης καθημερινά.</p></div><div class=paragraph><p>Ο πηγαίος κώδικας του ίδιου του FreeBSD είναι πλήρως διαθέσιμος, και έτσι το σύστημα μπορεί να προσαρμοστεί σε αφάνταστα υψηλό επίπεδο για ειδικές εφαρμογές ή projects, και με τρόπους γενικά μη πραγματοποιήσιμους σε άλλα λειτουργικά εμπορικών προμηθευτών. Παρακάτω θα βρείτε μερικά μόνο παραδείγματα από εφαρμογές στις οποίες χρησιμοποιείται αυτή τη στιγμή το FreeBSD:</p></div><div class=ulist><ul><li><p><em>Υπηρεσίες Ίντερνετ:</em> Το ισχυρό σύστημα δικτύωσης TCP/IP του FreeBSD, το αναδεικνύει σε ιδανική πλατφόρμα για μια μεγάλη γκάμα υπηρεσιών Ίντερνετ όπως:</p><div class=ulist><ul><li><p>Εξυπηρετητές ιστοσελίδων World Wide Web (κοινούς ή με ασφαλή σύνδεση [SSL])</p></li><li><p>Δρομολόγηση πρωτοκόλλων IPv4 και IPv6</p></li><li><p>Firewalls και πύλες NAT ("IP masquerading")</p></li><li><p>Εξυπηρετητές FTP</p></li><li><p>Εξυπηρετητές ηλεκτρονικού ταχυδρομείου</p></li><li><p>Και άλλα…​</p></li></ul></div></li><li><p><em>Εκπαίδευση:</em> Είστε φοιτητής πληροφορικής ή κάποιου σχετικού τομέα; Δεν υπάρχει καλύτερος τρόπος να μάθετε για λειτουργικά συστήματα, αρχιτεκτονικές Η/Υ, και συστήματα δικτύων από την πρακτική εμπειρία και την σε βάθος γνώση που μπορεί να σας παρέχει το FreeBSD. Το μεγάλο πλήθος των δωρεάν διαθέσιμων πακέτων εφαρμογών CAD, γραφικής σχεδίασης, και μαθηματικών, κάνουν το FreeBSD εξαιρετικά χρήσιμο σε όσους το κύριο ενδιαφέρον τους στους υπολογιστές είναι να <em>κάνουν τη δουλειά τους</em>!</p></li><li><p><em>Έρευνα:</em> Με διαθέσιμο τον πηγαίο κώδικα ολόκληρου του συστήματος, το FreeBSD είναι μία εξαίρετη πλατφόρμα για την έρευνα στα λειτουργικά συστήματα όπως επίσης για άλλους κλάδους της πληροφορικής. Η φύση της ελεύθερης διάθεσης του FreeBSD επιτρέπει επίσης σε απομακρυσμένες ομάδες να συνεργάζονται σε ιδέες ή να μοιράζονται την ανάπτυξη εφαρμογών, χωρίς να ανησυχούν για άδειες χρήσης και χωρίς να περιορίζεται η δυνατότητα τους για ελεύθερη συζήτηση οποιουδήποτε θέματος σε ανοιχτές ομάδες συζήτησης (forums).</p></li><li><p><em>Δικτύωση:</em> Χρειάζεστε ένα καινούργιο router (δρομολογητή); Ένα εξυπηρετητή DNS; Ένα firewall για να κρατάτε τον κόσμο έξω από το εσωτερικό σας δίκτυο; Το FreeBSD μπορεί εύκολα να μετατρέψει εκείνο το παλιό PC που κάθεται αχρησιμοποίητο στην γωνία, σε ένα προηγμένο δρομολογητή με εξεζητημένες δυνατότητες φιλτραρίσματος πακέτων.</p></li><li><p><em>Embedded:</em> Το FreeBSD αποτελεί μια εξαιρετική πλατφόρμα για τη δημιουργία embedded συστημάτων. Με υποστήριξη για τις πλατφόρμες ARM®, MIPS® και PowerPC® και σε συνδυασμό με αξιόπιστη δικτύωση, προηγμένα χαρακτηριστικά και την ελεύθερη άδεια <a href=https://docs.freebsd.org/el/books/faq/#bsd-license-restrictions>BSD</a> το FreeBSD είναι ένα εξαιρετικό σημείο εκκίνησης για embedded συστήματα router, firewall και άλλα.</p></li><li><p><em>Desktop:</em> Το FreeBSD είναι μια εξαίρετη επιλογή για ένα οικονομικό desktop. Το FreeBSD σας επιτρέπει να επιλέξετε ανάμεσα σε πολλά ανοικτού κώδικα περιβάλλοντα εργασίας τα οποία περιλαμβάνουν το GNOME και το KDE. To FreeBSD μπορεί να ξεκινήσει ακόμα και "diskless" (χωρίς σκληρό δίσκο), κάνοντας έτσι τους προσωπικούς σταθμούς εργασίας ακόμη πιο φτηνούς και ευκολότερους στη διαχείριση.</p></li><li><p><em>Ανάπτυξη Λογισμικού:</em> Το βασικό σύστημα του FreeBSD διατίθεται ολοκληρωμένο, με πλήρη σειρά εργαλείων ανάπτυξης, που περιλαμβάνουν ένα πλήρη C/C++ compiler και debugger.</p></li></ul></div><div class=paragraph><p>Το FreeBSD είναι διαθέσιμο για δωρεάν κατέβασμα ή μπορείτε να το προμηθευτείτε σε CD-ROM ή DVD. Δείτε το <a href=./#mirrors>Που θα Βρείτε το FreeBSD</a> για περισσότερες πληροφορίες για το πως να αποκτήσετε το FreeBSD.</p></div></div><div class=sect2><h3 id=introduction-nutshell-users>2.2. Ποιος χρησιμοποιεί FreeBSD;<a class=anchor href=#introduction-nutshell-users></a></h3><div class=paragraph><p>Τα προηγμένα χαρακτηριστικά, η αποδεδειγμένη ασφάλεια και ο τακτικός κύκλος νέων εκδόσεων του FreeBSD, σε συνδυασμό με την ελεύθερη άδεια χρήσης του, το κάνουν ιδανικό ως πλατφόρμα για τη δημιουργία πολλών εμπορικών και ανοιχτών συσκευών και προϊόντων. Κάποιες από τις μεγαλύτερες εταιρίες στο χώρο του IT χρησιμοποιούν το FreeBSD:</p></div><div class=ulist><ul><li><p><a href=http://www.apache.org/>Apache</a> - Το Apache Software Foundation χρησιμοποιεί το FreeBSD στα περισσότερα δημόσια συστήματα του, που συμπεριλαμβάνουν ένα από τα μεγαλύτερα αποθετήρια SVN στον κόσμο με περισσότερα από 1.4 εκατομμύρια commits.</p></li><li><p><a href=http://www.apple.com>Apple</a> - Το OS X δανείζεται πολλά στοιχεία από το FreeBSD για το υποσύστημα δικτύωσης και τα εργαλεία χρήστη (userland). To iOS περιέχει επίσης στοιχεία που προέρχονται από το FreeBSD.</p></li><li><p><a href=http://www.cisco.com/>Cisco</a> - Οι συσκευές ασφαλείας IronPort και anti-spam χρησιμοποιούν ένα τροποποιημένο πυρήνα του FreeBSD.</p></li><li><p><a href=http://www.citrix.com/>Citrix</a> - Η σειρά συσκευών ασφαλείας NetScaler παρέχει load balancing στα επίπεδα 4-7, caching περιεχομένου, firewall σε επίπεδο εφαρμογών, ασφαλές VPN και υπηρεσίες mobile cloud σε συνδυασμό με την ισχύ του τερματικού του FreeBSD.</p></li><li><p><a href=http://www.dell.com/KACE>Dell KACE</a> - Οι συσκευές διαχείρισης συστημάτων KACE χρησιμοποιούν FreeBSD λόγω της σταθερότητας και επεκτασιμότητας του καθώς και της κοινότητας που στηρίζει την συνεχή ανάπτυξη του.</p></li><li><p><a href=http://www.experts-exchange.com/>Experts Exchange</a> - Όλοι οι δημόσιοι εξυπηρετητές ιστοσελίδων χρησιμοποιούν FreeBSD με εκτεταμένη χρήση jails για την απομόνωση των περιβάλλοντων ανάπτυξης και ελέγχου, χωρίς την πρόσθετη επιβάρυνση της εικονικοποίησης (virtualization).</p></li><li><p><a href=http://www.isilon.com/>Isilon</a> - Τα επαγγλεματικά συστήματα αποθήκευσης της Isilon βασίζονται στο FreeBSD. Η εξαιρετικά ελεύθερη άδεια του FreeBSD επέτρεψε στην Isilon να ενσωματώσει το δικό της κώδικα (με τα δικά της πνευματικά δικαιώματα) στον πυρήνα και να επικεντρώσει την προσπάθεια της στη δημιουργία του προϊόντος της, αντί να ξαναγράψει ένα λειτουργικό σύστημα από την αρχή.</p></li><li><p><a href=http://www.ixsystems.com/>iXsystems</a> - Η σειρά συσκευών αποθήκευσης TrueNAS βασίζεται στο FreeBSD. Εκτός από τα εμπορικά της προϊόντα, η iXsystems κατευθύνει επίσης την ανάπτυξη των projects ανοικτού λογισμικού PC-BSD και FreeNAS.</p></li><li><p><a href=http://www.juniper.net/>Juniper</a> - Το λειτουργικό σύστημα JunOS το οποίο χρησιμοποιείται σε όλες τις συσκευές δικτύωσης της Juniper (που περιλαμβάνουν routers, switches και συσκευές ασφαλείας) βασίζεται στο FreeBSD. Η Juniper είναι μια εταιρία που επιδεικνύει τη συμβιωτική σχέση μεταξύ του Project και των εμπορικών προιόντων. Οι βελτιώσεις που παράγονται στη Juniper ενσωματώνονται στο FreeBSD μειώνοντας έτσι την πολυπλοκότητα της μελλοντικής ενσωμάτωσης νέων χαρακτηριστικών του FreeBSD πίσω στο JunOS.</p></li><li><p><a href=http://www.mcafee.com/>McAfee</a> - Το SecurOS, που αποτελεί τη βάση των προϊόντων firewall της εταιρίας και περιλαμβάνει το Sidewinder, βασίζεται στο FreeBSD.</p></li><li><p><a href=http://www.netapp.com/>NetApp</a> - Οι συσκευές αποθήκευσης Data ONTAP GX βασίζονται στο FreeBSD. Επιπρόσθετα, η NetApp έχει συνεισφέρει αρκετά νέα χαρακτηριστικά, συμπεριλαμβανομένου του bhyve, του νέου hypervisor ύπο άδεια BSD.</p></li><li><p><a href=http://www.netflix.com/>Netflix</a> - Η συσκευή OpenConnect που χρησιμοποιεί η Netflix για το streaming ταινιών στους πελάτες της, βασίζεται στο FreeBSD. Η Netflix έχει εκτεταμένη συνεισφορά στον κώδικα και εργάζεται ώστε να μην υπάρχουν διαφορές μεταξύ του κώδικα της και του FreeBSD. Οι συσκευές Netflix OpenConnect είναι υπεύθυνες για περισσότερο από το 32% της συνολικής κίνησης Internet στη Βόρειο Αμερική.</p></li><li><p><a href=http://www.sandvine.com/>Sandvine</a> - Η Sandvine χρησιμοποιεί το FreeBSD ως βάση για την υψηλής απόδοσης δικτυακή πλατφόρμα επεξεργασίας που χρησιμοποιεί στα προϊόντα της.</p></li><li><p><a href=http://www.sony.com/>Sony</a> - Η κονσόλα παιχνιδιών PlayStation 4 χρησιμοποιεί μια τροποποιημένη έκδοση του FreeBSD.</p></li><li><p><a href=http://www.sophos.com/>Sophos</a> - Η συσκευή Sophos Email Appliance χρησιμοποιεί μια ενισχυμένης ασφάλειας έκδοση του FreeBSD και σαρώνει τα εισερχόμενα email για spam και ιούς καθώς και τα εξερχόμενα για ανεπιθύμητα προγράμματα (malware) και πιθανή απώλεια ευαίσθητων δεδομένων.</p></li><li><p><a href=http://www.spectralogic.com/>Spectra Logic</a> - Η σειρά αποθηκευτικών μέσων nTier χρησιμοποιεί FreeBSD και OpenZFS.</p></li><li><p><a href=http://www.weather.com/>The Weather Channel</a> - Η συσκευή IntelliStar που εγκαθίσταται στους παρόχους καλωδιακής τηλεόρασης και παρέχει δελτία καιρού στους συνδρομητές, χρησιμοποιεί FreeBSD.</p></li><li><p><a href=http://www.verisign.com/>Verisign</a> - Η Verisign είναι υπεύθυνη για τη λειτουργία των τομέων .com και .net και των αντίστοιχων εξυπηρετητών DNS. Χρησιμοποιεί διάφορα δικτυακά λειτουργικά συστήματα, συμπεριλαμβανομένου του FreeBSD, για να εξασφαλίσει ότι δεν μπορεί να υπάρξει κάποιο κοινό σημείο αποτυχίας στην δικτυακή υποδομή της.</p></li><li><p><a href=http://www.voxer.com/>Voxer</a> - Η Voxer χρησιμοποιεί το FreeBSD με ZFS στην πλατφόρμα μηνυμάτων που εχει αναπτύξει για κινητά τηλέφωνα. Η Voxer αρχικά χρησιμοποιούσε ένα σύστημα που προέρχονταν από το Solaris, αλλά το άλλαξε σε FreeBSD λόγω της εξαιρετικής του τεκμηρίωσης, της μεγαλύτερης και πιο ενεργής κοινότητας και του φιλικότερου περιβάλλοντος ανάπτυξης. Εκτός από τα ιδιαίτερα κρίσιμα χαρακτηριστικά - όπως το ZFS και το DTrace - το FreeBSD επίσης διαθέτει και υποστήριξη TRIM για το ZFS.</p></li><li><p><a href=http://www.whatsapp.com/>WhatsApp</a> - Όταν η WhatsApp χρειάστηκε μια πλατφόρμα ικανή να αντιμετωπίσει περισσότερες από 1 εκατομμύριο ταυτόχρονες συνδέσεις TCP ανά εξυπηρετητή, επέλεξαν το FreeBSD. Έπειτα πέτυχαν περισσότερες από 2.5 εκατομμύρια συνδέσεις ανά εξυπηρετητή.</p></li><li><p><a href=http://wheelsystems.com/>Wheel Systems</a> - Η συσκευή ασφαλείας FUDO επιτρέπει στις επιχειρήσεις να ελέγχουν, να κατευθύνουν και να καταγράφουν διαχειριστές και εργαζομένους άλλων εταιριών που εργάζονται στα συστήματα τους. Βασίζεται στα καλύτερα χαρακτηριστικά ασφαλείας του FreeBSD που περιλαμβάνουν τεχνολογίες όπως ZFS, GELI, Capsicum, HAST και auditdstd.</p></li></ul></div><div class=paragraph><p>Το FreeBSD έχει επίσης βοηθήσει στη δημιουργία και άλλων σχετιζόμενων έργων ανοικτού λογισμικού:</p></div><div class=ulist><ul><li><p><a href=http://bsdrp.net/>BSD Router</a> - Ένας εναλλακτικός router για μεγάλες επιχειρήσεις που χρησιμοποιεί FreeBSD και είναι σχεδιασμένος να λειτουργεί σε απλά PC της αγοράς.</p></li><li><p><a href=http://www.freenas.org/>FreeNAS</a> - Μια τροποποιημένη έκδοση του FreeBSD σχεδιασμένη για χρήση ως συσκευή δικτυακής αποθήκευσης. Παρέχει γραφική διεπαφή γραμμένη σε Python η οποία απλουστεύει τη διαχείριση των συστημάτων αρχείων UFS και ZFS. Περιλαμβάνει υποστήριξη για NFS, SMB/CIFS, AFP, FTP και iSCSI. Έχει δυνατότητα επέκτασης μέσω πρόσθετων (plugins) τα οποία βασίζονται σε FreeBSD jails.</p></li><li><p><a href=http://www.ghostbsd.org/>GhostBSD</a> - Μια διανομή του FreeBSD για χρήση desktop. Παρέχεται με το περιβάλλον εργασίας Gnome.</p></li><li><p><a href=http://mfsbsd.vx.sk/>mfsBSD</a> - Ένα σύνολο εργαλείων για τη δημιουργία ενός συστήματος FreeBSD το οποίο εκτελείται αποκλειστικά από τη μνήμη.</p></li><li><p><a href=http://www.nas4free.org/>NAS4Free</a> - Μια διανομή για εξυπηρετητές αρχείων που βασίζεται στο FreeBSD και παρέχεται με μια web διεπαφή ρυθμίσεων γραμμένη σε PHP.</p></li><li><p><a href=http://www.pcbsd.org/>PC-BSD</a> - Μια τροποποιημένη διανομή του FreeBSD που προσανατολίζεται σε χρήση desktop και παρέχει γραφικά εργαλεία για να αναδείξει τη δύναμη του FreeBSD σε όλους τους χρήστες. Είναι σχεδιασμένη ώστε να διευκολύνει τη μετάβαση των χρηστών Windows και OS X στο FreeBSD.</p></li><li><p><a href=http://www.pfsense.org/>pfSense</a> - Μια διανομή για firewall που βασίζεται στο FreeBSD και περιέχει τεράστια συλλογή χαρακτηριστικών και εκτεταμένη υποστήριξη για IPv6.</p></li><li><p><a href=http://m0n0.ch/wall/>m0n0wall</a> - Μια λιτή έκδοση του FreeBSD με ένα εξυπηρετητή ιστοσελίδων και διεπαφή σε PHP. Έχει σχεδιαστεί ως συσκευή firewall και καταλαμβάνει χώρο μικρότερο από 12 MB.</p></li><li><p><a href=http://zrouter.org/>ZRouter</a> - Ένα εναλλακτικό firmware ανοικτού λογισμικού για δικτυακές συσκευές, βασισμένο στο FreeBSD. Έχει σχεδιαστεί ώστε να αντικαθιστά το ιδιοταγές firmware εμπορικών routers.</p></li></ul></div><div class=paragraph><p>Το FreeBSD χρησιμοποιείται για να υποστηρίζει μερικές από τις μεγαλύτερες τοποθεσίες στο Ίντερνετ, περιλαμβανομένων των:</p></div><div class=ulist><ul><li><p><a href=http://www.yahoo.com/>Yahoo!</a></p></li><li><p><a href=http://www.yandex.ru/>Yandex</a></p></li><li><p><a href=http://www.rambler.ru/>Rambler</a></p></li><li><p><a href=http://www.sina.com/>Sina</a></p></li><li><p><a href=http://www.pair.com/>Pair Networks</a></p></li><li><p><a href=http://www.sony.co.jp/>Sony Japan</a></p></li><li><p><a href=http://www.netcraft.com/>Netcraft</a></p></li><li><p><a href=https://signup.netflix.com/openconnect>Netflix</a></p></li><li><p><a href=http://www.163.com/>NetEase</a></p></li><li><p><a href=http://www.weathernews.com/>Weathernews</a></p></li><li><p><a href=http://www.telehouse.com/>TELEHOUSE America</a></p></li></ul></div><div class=paragraph><p>και πολλών ακόμη. Στη Wikipedia θα βρείτε μια <a href=http://en.wikipedia.org/wiki/List_of_products_based_on_FreeBSD>λίστα προϊόντων που βασίζονται στο FreeBSD</a>.</p></div></div></div></div><div class=sect1><h2 id=history>Chapter 3. Πληροφορίες για το FreeBSD Project<a class=anchor href=#history></a></h2><div class=sectionbody><div class=paragraph><p>Το ακόλουθο τμήμα παρέχει μερικές πληροφορίες σχετικές με το project, και περιλαμβάνει μια σύντομη ιστορία του FreeBSD, τους στόχους, και το μοντέλο ανάπτυξης του.</p></div><div class=sect2><h3 id=intro-history>3.1. Μια σύντομη ιστορία του FreeBSD<a class=anchor href=#intro-history></a></h3><div class=paragraph><p>To FreeBSD Project γεννήθηκε στις αρχές του 1993, μερικώς σαν εξέλιξη του "Unofficial 386BSD Patchkit" από τους 3 τελευταίους συντονιστές του patchkit: τον Nate Williams, τον Rod Grimes και τον Jordan Hubbard.</p></div><div class=paragraph><p>Ο πρωταρχικός στόχος ήταν να παραχθεί ένα ενδιάμεσο στιγμιότυπο (snapshot) του 386BSD ώστε να διορθωθούν μερικά προβλήματα που ο μηχανισμός του patchkit δεν ήταν ικανός να λύσει. Ο αρχικός τίτλος εργασίας για το project ήταν "386BSD 0.5" ή "386BSD Interim" και αναφέρονταν σε αυτό ακριβώς το γεγονός.</p></div><div class=paragraph><p>Το 386BSD ήταν το λειτουργικό σύστημα του Bill Jolitz, το οποίο μέχρι εκείνο το σημείο, υπέφερε βαριά έχοντας αμεληθεί για σχεδόν ένα έτος. Καθώς το patchkit φούσκωνε ολοένα και περισσότερο με το πέρασμα των ημερών, το ενδιάμεσο "cleanup" snapshot αποτέλεσε μια συμπαράσταση για τον Bill. Τα σχέδια αυτά διακόπηκαν απότομα, όταν ξαφνικά ο Bill Jolitz αποφάσισε να αποσύρει την έγκριση του στο project δίχως μια ξεκάθαρη ένδειξη του τι θα έπρεπε να γίνει.</p></div><div class=paragraph><p>Οι τρεις συντονιστές γρήγορα αποφάσισαν πως ο στόχος παρέμενε αξιόλογος, ακόμη και χωρίς την βοήθεια του Bill, και έτσι υιοθέτησαν το όνομα "FreeBSD", που επινόησε ο David Greenman. Οι αρχικοί στόχοι τέθηκαν κατόπιν συμβουλών από τους τότε χρήστες του συστήματος, και όταν έγινε πλέον ξεκάθαρο πως το project είχε πάρει σωστή πορεία και ίσως έτεινε να γίνει πραγματικότητα, ο Jordan ήρθε σε επαφή με την Walnut Creek CDROM προσβλέποντας στην βελτίωση των καναλιών διανομής του FreeBSD για όλους αυτούς τους άτυχους που δεν είχαν εύκολη πρόσβαση στο Ίντερνετ. Η Walnut Creek CDROM, όχι μόνο υποστήριξε την ιδέα διανομής του FreeBSD σε CD, αλλά προχώρησε αρκετά περισσότερο, παρέχοντας στο project ένα μηχάνημα εργασίας και μια γρήγορη σύνδεση στο Ίντερνετ. Δίχως τον βαθμό πίστης της Walnut Creek CDROM σε αυτό που εκείνο τον καιρό ήταν ένα εντελώς άγνωστο project, είναι πολύ απίθανο το FreeBSD να είχε φτάσει τόσο μακριά, και τόσο γρήγορα, όπως σήμερα.</p></div><div class=paragraph><p>Η πρώτη διανομή CD-ROM (και με γενικά ευρεία διάδοση στο δίκτυο) ήταν η FreeBSD 1.0, που κυκλοφόρησε τον Δεκέμβρη του 1993. Βασίζονταν σε μια ταινία του 4.3BSD-Lite ("Net/2") του U.C. Berkeley, έχοντας πάρει και πολλά στοιχεία από το 386BSD και το Free Software Foundation. Ήταν αρκετά επιτυχημένη για πρώτη προσπάθεια, και την συνεχίσαμε με την αρκετά επιτυχημένη έκδοση FreeBSD 1.1 που κυκλοφόρησε τον Μάϊο του 1994.</p></div><div class=paragraph><p>Περίπου εκείνη την περίοδο, σχηματίστηκαν απρόσμενα στον ορίζοντα σύννεφα καταιγίδας, καθώς η Novell και το U.C. Berkeley τακτοποίησαν την μακράς διαρκείας δικαστική διαμάχη σχετικά με τα δικαιώματα της ταινίας Net/2. Μία συνθήκη αυτής της συμφωνίας ήταν η παραδοχή από την μεριά του U.C. Berkeley ότι μεγάλο μέρος του Net/2 ήταν "επιβαρυμένος" κώδικας και ιδιοκτησία της Novell, η οποία με την σειρά της το είχε αποκτήσει από την AT&amp;T λίγο καιρό πριν. Αυτό που πήρε ως αντάλλαγμα το Berkeley ήταν οι "ευλογίες" της Novell ότι η έκδοση 4.4BSD-Lite, όταν τελικά ολοκληρωνόταν, θα δηλωνόταν ως μη-επιβαρυμένη, και όλοι οι μέχρι τότε χρήστες του Net/2 θα ενθαρρύνονταν ένθερμα να μεταβούν σε αυτή. Αυτό συμπεριλάμβανε και το FreeBSD, και στο project δόθηκε χρόνος μέχρι τον Ιούλιο του 1994 να σταματήσει τις παραδόσεις των προϊόντων που βασίζονταν στο Net/2. Υπό τους όρους αυτής της συμφωνίας, επιτράπηκε στο project μια τελευταία έκδοση πριν την λήξη της προθεσμίας, και αυτή ήταν η έκδοση FreeBSD 1.1.5.1.</p></div><div class=paragraph><p>Το FreeBSD βρέθηκε τότε στη δυσχερή θέση κυριολεκτικά να ξανα-ανακαλύψει τον εαυτό του από ένα σύνολο από bit του 4.4BSD-Lite, εντελώς καινούργιο, και κυρίως ατελές. Οι εκδόσεις "Lite" ήταν light (ελαφριές) εν' μέρει επειδή το CSRG του Berkeley είχε αφαιρέσει μεγάλο όγκο κώδικα ο οποίος ήταν απαραίτητος για να κατασκευαστεί ένα πραγματικά εκκινήσιμο λειτουργικό σύστημα (λόγω διαφόρων νομικών ζητημάτων), και εν' μέρει επειδή το port για Intel του 4.4 ήταν σε υψηλό βαθμό ατελές. Η μετάβαση ολοκληρώθηκε τον Νοέμβριο του 1994, και σε αυτό το σημείο κυκλοφόρησε η FreeBSD 2.0. Παρά το γεγονός ότι ήταν ακόμη αρκετά πρόχειρη μέσες-άκρες, η έκδοση ήταν μια σημαντική επιτυχία και την ακολούθησε η πιο αξιόπιστη και ευκολότερη ως προς την εγκατάσταση έκδοση FreeBSD 2.0.5 τον Ιούνιο του 1995.</p></div><div class=paragraph><p>Από την εποχή εκείνη, το FreeBSD έχει δημιουργήσει σειρά νέων εκδόσεων οι οποίες βελτιώνουν την ταχύτητα, σταθερότητα και τα χαρακτηριστικά των προηγούμενων.</p></div><div class=paragraph><p>Για την ώρα, η μακρόχρονη ανάπτυξη συνεχίζεται στον κλάδο 10.X-CURRENT (trunk) και τα στιγμιότυπα (snapshots) του 10.X είναι πάντοτε διαθέσιμα μέσω του <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/snapshots/>εξυπηρετητή snapshot</a>.</p></div></div><div class=sect2><h3 id=goals>3.2. Στόχοι του FreeBSD Project<a class=anchor href=#goals></a></h3><div class=paragraph><p>Οι στόχοι του FreeBSD Project είναι να παρέχει λογισμικό που θα μπορεί να χρησιμοποιηθεί για οποιαδήποτε περίσταση και δίχως δεσμεύσεις. Πολλοί από μας έχουν κάνει σημαντική επένδυση στον κώδικα (και το project) και σίγουρα δε θα μας πείραζε πότε-πότε μια μικρή οικονομική συνεισφορά, αλλά σίγουρα δεν είμαστε έτοιμοι να επιμείνουμε σε αυτό. Πιστεύουμε ότι η πρωταρχική και σπουδαιότερη "αποστολή" μας είναι να παρέχουμε κώδικα σε υπάρχοντες και μελλοντικούς χρήστες, και για οποιοδήποτε σκοπό, ώστε ο κώδικας μας να έχει την ευρύτερη πιθανή χρήση και να αποφέρει το μεγαλύτερο δυνατό όφελος. Αυτό είναι, πιστεύω, ένας από τους σημαντικότερους στόχους του Ελεύθερου Λογισμικού και ένας από τους οποίους υποστηρίζουμε με ενθουσιασμό.</p></div><div class=paragraph><p>Το τμήμα του πηγαίου μας κώδικα που βρίσκεται υπό την GNU General Public License (GPL) ή την Library General Public License (LGPL) έχει κάπως περισσότερες δεσμεύσεις, αν και σκοπός τους είναι μάλλον να διασφαλίσουν την ελεύθερη διάθεση του κώδικα, παρά το αντίθετο. Λόγω των επιπρόσθετων επιπλοκών που θέτει η άδεια χρήσης GPL στην εμπορική χρήση του λογισμικού, προτιμούμε, όσο είναι εφικτό, να παρέχουμε το λογισμικό μας υπό το χαλαρότερο BSD copyright.</p></div></div><div class=sect2><h3 id=development>3.3. Το Μοντέλο Ανάπτυξης του FreeBSD<a class=anchor href=#development></a></h3><div class=paragraph><p>Η ανάπτυξη του FreeBSD είναι μία πολύ ανοικτή και ευέλικτη διαδικασία, αφού κυριολεκτικά βασίζεται στην συνεισφορά χιλιάδων ανθρώπων από όλο τον κόσμο, όπως μπορείτε να δείτε από την <a href=https://docs.freebsd.org/en/articles/contributors/>λίστα των συνεργατών</a> μας. Η υποδομή ανάπτυξης του FreeBSD επιτρέπει στα χιλιάδες μέλη των συνεργατών μας να συνεργάζονται μέσω του Ίντερνετ. Είμαστε σταθερά σε αναζήτηση για νέα μέλη στην ομάδα ανάπτυξης και για ιδέες, και όσοι ενδιαφέρονται να ασχοληθούν ακόμη περισσότερο με το project χρειάζεται απλά να επικοινωνήσουν μαζί μας στην <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>ηλεκτρονική λίστα τεχνικών συζητήσεων του FreeBSD</a>. Επίσης η <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>ηλεκτρονική λίστα ανακοινώσεων του FreeBSD</a> είναι διαθέσιμη σε όσους επιθυμούν να ενημερώσουν άλλους χρήστες του FreeBSD για βασικούς τομείς εργασίας πάνω στο Project.</p></div><div class=paragraph><p>Χρήσιμα πράγματα που πρέπει να γνωρίζετε για το FreeBSD Project και την διαδικασία ανάπτυξης του, είτε δουλεύετε ανεξάρτητα είτε ως στενοί συνεργάτες:</p></div><div class=dlist><dl><dt class=hdlist1>Τα SVN repositories<a id=development-cvs-repository></a></dt><dd><p>Για πολλά χρόνια, ο κεντρικός κορμός κώδικα του FreeBSD συντηρούνταν μέσω του <a href=http://www.nongnu.org/cvs/>CVS</a> (Concurrent Versions System), ενός ελεύθερα διαθέσιμου εργαλείου ελέγχου πηγαίου κώδικα. Τον Ιούνιο του 2008, το Project αποφάσισε τη μετάβαση στο <a href=http://subversion.tigris.org>SVN</a> (Subversion). Η αλλαγή κρίθηκε αναγκαία, καθώς οι τεχνικοί περιορισμοί του CVS ήταν πλέον εμφανείς, εξαιτίας του μεγέθους του αποθηκευμένου κώδικα και του ιστορικού που τον συνοδεύει. Η Τεκμηρίωση και η Συλλογή των Ports μεταφέρθηκαν επίσης από το CVS στο SVN το Μάιο και Ιούλιο του 2012 αντίστοιχα. Ακολουθήστε το σύνδεσμο <a href=./#synching>Συγχρονίζοντας τον Πηγαίο σας Κώδικα</a> για περισσότερες πληροφορίες σχετικά με την ανάκτηση του FreeBSD <code>src/</code> repository και τον σύνδεσμο <a href=./#ports-using>Χρησιμοποιώντας τη Συλλογή των Ports</a> για λεπτομέρειες σχετικές με την ανάκτηση της Συλλογής των Ports.</p></dd><dt class=hdlist1>Η λίστα των committers<a id=development-committers></a></dt><dd><p>Οι <em>committers</em> είναι άτομα που έχουν άδεια <em>εγγραφής (write)</em> στο δέντρο Subversion και είναι εξουσιοδοτημένοι να κάνουν μετατροπές στον κώδικα του FreeBSD (ο όρος "committer" προέρχεται από την εντολή <code>commit</code>, η οποία χρησιμοποιείται για να γίνουν νέες αλλαγές στο repository). Οποιοσδήποτε μπορεί να υποβάλλει ένα σφάλμα (bug) στη <a href=https://bugs.FreeBSD.org/submit/>Βάση Δεδομένων Προβλημάτων</a>. Πριν την υποβολή, καλό είναι να γίνει σχετική αναζήτηση στις λίστες ταχυδρομείου, τα φορουμς και τα κανάλια IRC του FreeBSD για να επιβεβαιωθεί ότι όντως πρόκειται για πρόβλημα του λειτουργικού.</p></dd><dt class=hdlist1>The FreeBSD core team<a id=development-core></a></dt><dd><p>Η <em>FreeBSD core team</em> θα ήταν ισοδύναμη με το διοικητικό συμβούλιο αν το FreeBSD Project ήταν μια ανώνυμη εταιρεία. Ο πρωταρχικός στόχος της core team είναι να εξασφαλίσει ότι το project, στο σύνολο του, είναι σε καλή κατάσταση και να το οδηγεί προς την σωστή κατεύθυνση. Μια από τις λειτουργίες της core team είναι να προσκαλεί αφοσιωμένους και υπεύθυνους developers να συμμετέχουν στην ομάδα ανάπτυξης (τους committers) καθώς και να βρίσκει νέα μέλη για την ίδια την core team καθώς κάποιοι αποχωρούν. Η παρούσα core team εκλέχτηκε από ένα σύνολο υποψηφίων committers τον Ιούλιο του 2014. Εκλογές διεξάγονται κάθε 2 χρόνια.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όπως και τα περισσότερη μέλη της ομάδας ανάπτυξης, τα περισσότερα μέλη του core team είναι εθελοντές όσον αφορά την ανάπτυξη του FreeBSD και δεν έχουν οικονομικής φύσεως οφέλη από το project, επομένως η "δέσμευση" δεν θα πρέπει να παρερμηνεύεται ως "εγγυημένη υποστήριξη". Η παραπάνω παρομοίωση με το "διοικητικό συμβούλιο" δεν είναι πολύ ακριβής, ίσως είναι καταλληλότερο να πούμε ότι πρόκειται για ανθρώπους που θυσίασαν τις ζωές τους για χάρη του FreeBSD ενάντια στην καλύτερη τους κρίση!</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>Εξωτερικοί συνεργάτες</dt><dd><p>Τέλος, αλλά οπωσδήποτε όχι μικρότερης σημασίας, η μεγαλύτερη ομάδα ανάπτυξης είναι οι ίδιοι οι χρήστες που μας παρέχουν σχόλια και διορθώσεις των bug σε σχεδόν σταθερή βάση. Ο κύριος τρόπος για να κρατάτε επαφή με την μη-συγκεντρωτική ομάδα ανάπτυξης του FreeBSD είναι να γίνετε συνδρομητές στην <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>ηλεκτρονική λίστα τεχνικών συζητήσεων του FreeBSD</a> όπου γίνονται οι ανάλογες συζητήσεις. Δείτε το <a href=./#eresources>Πηγές Πληροφόρησης στο Διαδίκτυο</a> για περισσότερες πληροφορίες σχετικά με τις διάφορες λίστες ηλεκτρονικού ταχυδρομείου του FreeBSD.</p><div class=paragraph><p><a href=https://docs.freebsd.org/en/articles/contributors/>Η Λίστα Συνεργατών του FreeBSD</a> είναι μεγάλη και συνεχώς αυξανόμενη, επομένως γιατί να μην γίνετε και εσείς μέλος της και να συμβάλλετε σήμερα σε κάτι στο FreeBSD;</p></div><div class=paragraph><p>Η παροχή κώδικα δεν είναι ο μόνος τρόπος για να συνεισφέρετε στο project. Για μια ολοκληρωμένη λίστα των πραγμάτων στα οποία χρειαζόμαστε βοήθεια, παρακαλούμε επισκεφθείτε την <a href=https://www.FreeBSD.org/>Δικτυακή τοποθεσία του FreeBSD Project</a>.</p></div></dd></dl></div><div class=paragraph><p>Συνοψίζοντας, το μοντέλο ανάπτυξης μας είναι οργανωμένο σαν ένα χαλαρό σύνολο ομόκεντρων κύκλων. Το συγκεντρωτικό μοντέλο είναι σχεδιασμένο για να διευκολύνει τους <em>χρήστες</em> του FreeBSD, στους οποίους παρέχεται έτσι ένας εύκολος τρόπος παρακολούθησης του βασικού κώδικα, και όχι για να αποκλείουμε πιθανούς συνεργάτες! Επιθυμία μας είναι να παρουσιάσουμε ένα σταθερό λειτουργικό σύστημα σε συνάρτηση με μια μεγάλη γκάμα από <a href=./#ports>προγράμματα εφαρμογών</a> που οι χρήστες να μπορούν εύκολα να εγκαθιστούν και να χρησιμοποιούν - για την εκπλήρωση αυτών των στόχων, το μοντέλο αυτό δουλεύει πολύ καλά.</p></div><div class=paragraph><p>Το μόνο που ζητάμε από όσους ενδιαφέρονται να ενωθούν μαζί μας στην ομάδα ανάπτυξης του FreeBSD, είναι λίγη από την ίδια αφοσίωση της τωρινής ομάδας, για μια συνεχή πορεία στην επιτυχία του!</p></div></div><div class=sect2><h3 id=relnotes>3.4. Προγράμματα Τρίτων Κατασκευαστών<a class=anchor href=#relnotes></a></h3><div class=paragraph><p>Εκτός από τη βασική του διανομή, το FreeBSD προσφέρει μια συλλογή λογισμικού με χιλιάδες προγράμματα για καθημερινή χρήση. Την στιγμή που γράφονται αυτές οι γραμμές, υπάρχουν πάνω από 36000 ports! Η λίστα των ports ξεκινάει από εξυπηρετητές http (WWW), μέχρι παιχνίδια, γλώσσες προγραμματισμού, κειμενογράφους, και οτιδήποτε άλλο ενδιάμεσα. Η συνολική Συλλογή των Ports απαιτεί προσεγγιστικά 3 GB. Για να μεταγλωττιστεί (compile) ένα port, χρειάζεται απλώς να μεταβείτε στον κατάλογο του προγράμματος που επιθυμείτε να εγκαταστήσετε, να πληκτρολογήσετε <code>make install</code>, και να αφήσετε το σύστημα σας να κάνει τα υπόλοιπα. Ολόκληρη η αυθεντική διανομή για κάθε port που κάνετε build παρέχεται δυναμικά έτσι τα ports που δεν χρειάζεστε δεν καταλαμβάνουν άσκοπο χώρο στο σκληρό σας δίσκο. Σχεδόν κάθε port παρέχεται επίσης και σαν προ-μεταγλωττισμένο (pre-compiled) "πακέτο (package)", το οποίο μπορεί να εγκατασταθεί με μια απλή εντολή (<code>pkg install</code>) για εκείνους που δεν επιθυμούν να μεταγλωττίζουν τα ports τους από τον πηγαίο κώδικα. Περισσότερες πληροφορίες για τα packages και τα ports μπορείτε να βρείτε στο <a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>.</p></div></div><div class=sect2><h3 id=_πρόσθετη_τεκμηρίωση>3.5. Πρόσθετη Τεκμηρίωση<a class=anchor href=#_πρόσθετη_τεκμηρίωση></a></h3><div class=paragraph><p>Όλες οι τρέχουσες εκδόσεις του FreeBSD παρέχουν επιλογή στο πρόγραμμα εγκατάστασης (είτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a>) για την εγκατάσταση πρόσθετης τεκμηρίωσης στην τοποθεσία <span class=filename>/usr/local/shared/doc/freebsd</span> κατά την αρχική εγκατάσταση του συστήματος. Μπορείτε επίσης να εγκαταστήσετε την τεκμηρίωση οποιαδήποτε στιγμή αργότερα, χρησιμοποιώντας τα πακέτα όπως περιγράφεται στο <a href=./#doc-ports-install-package>“Χρήση Έτοιμων Πακέτων Τεκμηρίωσης”</a>. Μπορείτε να δείτε την τοπικά εγκατεστημένη τεκμηρίωση χρησιμοποιώντας οποιοδήποτε πρόγραμμα φυλλομετρητή, στις παρακάτω τοποθεσίες:</p></div><div class=dlist><dl><dt class=hdlist1>Το Εγχειρίδιο Χρήσης του FreeBSD</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/handbook/index.html>/usr/local/shared/doc/freebsd/handbook/index.html</a></p></dd><dt class=hdlist1>Συχνές ερωτήσεις του FreeBSD (FAQ)</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/faq/index.html>/usr/local/shared/doc/freebsd/faq/index.html</a></p></dd></dl></div><div class=paragraph><p>Μπορείτε επίσης να δείτε τα πρωτότυπα (και συχνά αναβαθμιζόμενα) αντίγραφα στο <a href=http://www.FreeBSD.org/>http://www.FreeBSD.org/</a>.</p></div></div></div></div><div class=sect1><h2 id=bsdinstall>Chapter 4. Εγκατάσταση του FreeBSD 9.x και Μεταγενέστερων Εκδόσεων<a class=anchor href=#bsdinstall></a></h2><div class=sectionbody><div class=sect2><h3 id=bsdinstall-synopsis>4.1. Σύνοψη<a class=anchor href=#bsdinstall-synopsis></a></h3><div class=paragraph><p>Το FreeBSD έρχεται με ένα μη-γραφικό αλλά εύκολο στη χρήση πρόγραμμα εγκατάστασης. Από το FreeBSD 9.0-RELEASE και μετά, χρησιμοποιείται το πρόγραμμα bsdinstall ενώ οι προηγούμενες εκδόσεις χρησιμοποιούν το sysinstall. Το κεφάλαιο αυτό περιγράφει τη χρήση του bsdinstall. Η χρήση του sysinstall περιγράφεται στο <a href=./#install>“Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων”</a>.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα γνωρίζετε:</p></div><div class=ulist><ul><li><p>Πως να δημιουργήσετε μέσα εγκατάστασης για το FreeBSD.</p></li><li><p>Πως το FreeBSD υποδιαιρεί τους σκληρούς δίσκους και πως αναφέρεται σε αυτούς.</p></li><li><p>Πως να εκκινήσετε το bsdinstall.</p></li><li><p>Τις ερωτήσεις που θα σας κάνει το bsdinstall, τι σημαίνουν και πως να τις απαντήσετε.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο θα πρέπει:</p></div><div class=ulist><ul><li><p>Να διαβάσετε τη λίστα του υλικού που υποστηρίζεται από την έκδοση του FreeBSD που εγκαθιστάτε και να επαληθεύσετε ότι το υλικό του υπολογιστή σας υποστηρίζεται.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σε γενικές γραμμές, αυτές οι οδηγίες εγκατάστασης αναφέρονται στην αρχιτεκτονική i386™ ("PC συμβατή"). Όπου χρειάζεται, γίνεται αναφορά και σε άλλες αρχιτεκτονικές. Πιθανόν να υπάρχουν μικρές διαφορές στο πρόγραμμα εγκατάστασης σε σχέση με το παρόν κείμενο και για το λόγο αυτό σας συνιστούμε να το χρησιμοποιήσετε ως γενικό οδηγό παρά σαν κυριολεκτικά ακριβείς οδηγίες.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=bsdinstall-hardware>4.2. Απαιτήσεις Υλικού<a class=anchor href=#bsdinstall-hardware></a></h3><div class=sect3><h4 id=bsdinstall-hardware-minimal>4.2.1. Ελάχιστες Απαιτήσεις Εγκατάστασης<a class=anchor href=#bsdinstall-hardware-minimal></a></h4><div class=paragraph><p>Οι ελάχιστες απαιτήσεις για την εγκατάσταση του FreeBSD ποικίλουν ανάλογα με την έκδοση του λειτουργικού και την αρχιτεκτονική του υλικού που χρησιμοποιείται.</p></div><div class=paragraph><p>Στις επόμενες ενότητες θα σας παρουσιάσουμε μια σύνοψη αυτών των πληροφοριών. Ανάλογα με τη μέθοδο που θα χρησιμοποιήσετε για να εγκαταστήσετε το FreeBSD, μπορεί να χρειαστείτε ένα υποστηριζόμενο οδηγό CDROM και - σε κάποιες περιπτώσεις - μια κάρτα δικτύου. Τα θέματα αυτά καλύπτονται στο <a href=#bsdinstall-installation-media>Προετοιμάστε τα Μέσα Εγκατάστασης</a>.</p></div><div class=sect4><h5 id=_freebsdi386>4.2.1.1. FreeBSD/i386<a class=anchor href=#_freebsdi386></a></h5><div class=paragraph><p>Το FreeBSD/i386 απαιτεί 486 ή καλύτερο επεξεργαστή και τουλάχιστον 64 MB RAM. Για την ελάχιστη δυνατή εγκατάσταση απαιτείται 1.1 GB ελεύθερου χώρου στο σκληρό δίσκο.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σε περιπτώσεις παλιών μηχανημάτων, τις περισσότερες φορές, η απόδοση του συστήματος βελτιώνεται περισσότερο με αύξηση της μνήμης RAM και του ελεύθερου χώρου στο δίσκο, παρά με ένα ταχύτερο επεξεργαστή.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_freebsdamd64>4.2.1.2. FreeBSD/amd64<a class=anchor href=#_freebsdamd64></a></h5><div class=paragraph><p>Υπάρχουν δύο κλάσεις επεξεργαστών ικανές να εκτελέσουν το FreeBSD/amd64. Η πρώτη είναι οι επεξεργαστές AMD64 που περιλαμβάνουν τους AMD Athlon™64, AMD Athlon™64-FX, AMD Opteron™ ή καλύτερους.</p></div><div class=paragraph><p>Η δεύτερη κλάση επεξεργαστών που μπορούν να εκτελέσουν το FreeBSD/amd64 περιλαμβάνει όσους χρησιμοποιούν την αρχιτεκτονική Intel® EM64T. Παραδείγματα των επεξεργαστών αυτών περιλαμβάνουν τις οικογένειες Intel® Core™ 2 Duo, Quad, Extreme processor, τη σειρά επεξεργαστών Intel® Xeon™ 3000, 5000 και 7000 καθώς και τους επεξεργαστές Intel® Core™ i3, i5 και i7.</p></div><div class=paragraph><p>Αν το μηχάνημα σας είναι βασισμένο σε nVidia nForce3 Pro-150, θα <em>πρέπει</em> να χρησιμοποιήσετε την κατάλληλη επιλογή στο BIOS για να απενεργοποιήσετε το IO APIC. Αν η επιλογή αυτή δεν υπάρχει, θα πρέπει να απενεργοποιήσετε αντί αυτού το ACPI. Υπάρχουν προβλήματα στο Pro-150 για τα οποία μέχρι στιγμής δεν έχει βρεθεί λύση που να τα παρακάμπτει.</p></div></div><div class=sect4><h5 id=_freebsdpowerpc_apple_macintosh>4.2.1.3. FreeBSD/powerpc Apple® Macintosh®<a class=anchor href=#_freebsdpowerpc_apple_macintosh></a></h5><div class=paragraph><p>Υποστηρίζονται όλοι οι νέοι υπολογιστές Apple® Macintosh® που διαθέτουν ενσωματωμένες USB. Υποστηρίζεται επίσης η λειτουργία SMP σε μηχανήματα με πολλαπλούς επεξεργαστές.</p></div><div class=paragraph><p>Ένας 32-bit πυρήνας μπορεί να χρησιμοποιήσει μόνο τα πρώτα 2 GB RAM. Το FireWire® δεν υποστηρίζεται στα Μπλε και Λευκά PowerMac G3.</p></div></div><div class=sect4><h5 id=_freebsdsparc64>4.2.1.4. FreeBSD/sparc64<a class=anchor href=#_freebsdsparc64></a></h5><div class=paragraph><p>Μπορείτε να δείτε τα συστήματα που υποστηρίζονται από το FreeBSD/sparc64 στο <a href=http://www.freebsd.org/platforms/sparc/>FreeBSD/sparc64</a> Project.</p></div><div class=paragraph><p>Θα χρειαστείτε ένα δίσκο για αποκλειστική χρήση από το FreeBSD/sparc64. Τη δεδομένη στιγμή, δεν είναι δυνατόν το FreeBSD/sparc64 να μοιράζεται τον ίδιο δίσκο με ένα άλλο λειτουργικό σύστημα.</p></div></div></div><div class=sect3><h4 id=bsdinstall-hardware-supported>4.2.2. Υποστηριζόμενο Υλικό<a class=anchor href=#bsdinstall-hardware-supported></a></h4><div class=paragraph><p>Στις Σημειώσεις Υλικού (Hardware Notes) μπορείτε να βρείτε πληροφορίες για τις αρχιτεκτονικές και τις συσκευές που υποστηρίζονται από μια επίσημη έκδοση του FreeBSD. Το αρχείο αυτό ονομάζεται συνήθως <span class=filename>HARDWARE.TXT</span>, και βρίσκεται στον κεντρικό κατάλογο του μέσου εγκατάστασης. Μπορείτε επίσης να βρείτε αντίγραφα αυτού του καταλόγου στη σελίδα <a href=http://www.FreeBSD.org/releases/>Πληροφοριών Έκδοσης</a> στο δικτυακό τόπο του FreeBSD.</p></div></div></div><div class=sect2><h3 id=bsdinstall-pre>4.3. Εργασίες πριν την Εγκατάσταση<a class=anchor href=#bsdinstall-pre></a></h3><div class=sect3><h4 id=_κρατήστε_αντίγραφα_ασφαλείας_των_δεδομένων_σας>4.3.1. Κρατήστε Αντίγραφα Ασφαλείας των Δεδομένων σας<a class=anchor href=#_κρατήστε_αντίγραφα_ασφαλείας_των_δεδομένων_σας></a></h4><div class=paragraph><p>Κρατήστε αντίγραφα ασφαλείας όλων των σημαντικών δεδομένων του υπολογιστή στον οποίο θα κάνετε εγκατάσταση του FreeBSD. Ελέγξτε τη σωστή λειτουργία των αντιγράφων ασφαλείας πριν συνεχίσετε. Το πρόγραμμα εγκατάστασης του FreeBSD θα ζητήσει επιβεβαίωση πριν κάνει οποιαδήποτε αλλαγή στο δίσκο σας, αλλά από τη στιγμή που αυτή η διαδικασία ξεκινήσει, δεν υπάρχει δυνατότητα επιστροφής.</p></div></div><div class=sect3><h4 id=bsdinstall-where>4.3.2. Αποφασίστε που θα Εγκαταστήσετε το FreeBSD<a class=anchor href=#bsdinstall-where></a></h4><div class=paragraph><p>Αν το FreeBSD πρόκειται να είναι το μοναδικό λειτουργικό σύστημα του υπολογιστή και σκοπεύετε να διαθέσετε σε αυτό ολόκληρο το χώρο του σκληρού σας δίσκου, μπορείτε να παραλείψετε το υπόλοιπο αυτής της ενότητας. Αν ωστόσο θέλετε να συνυπάρχει το FreeBSD με άλλα λειτουργικά συστήματα, είναι χρήσιμο να κατανοείτε γενικά τον τρόπο διάταξης των δεδομένων στο δίσκο.</p></div><div class=sect4><h5 id=bsdinstall-where-i386>4.3.2.1. Κατατμήσεις Δίσκων για τις Αρχιτεκτονικές FreeBSD/i386 και FreeBSD/amd64<a class=anchor href=#bsdinstall-where-i386></a></h5><div class=paragraph><p>Οι σκληροί δίσκοι μπορούν να χωριστούν σε διακριτά τμήματα. Τα τμήματα αυτά ονομάζονται <em>κατατμήσεις (partitions)</em>.</p></div><div class=paragraph><p>Υπάρχουν δύο τρόποι για να χωριστεί ένας δίσκος σε κατατμήσεις. Ο παραδοσιακός τρόπος χρησιμοποιεί το <em>Master Boot Record (Βασική Εγγραφή Εκκίνησης)</em> ή MBR, ένα πίνακα κατατμήσεων ικανό να αποθηκεύσει ως τέσσερις <em>πρωτεύουσες κατατμήσεις (primary partitions)</em>. (Για ιστορικούς λόγους, το FreeBSD ονομάζει τις πρωτεύουσες κατατμήσεις <em>slices ή φέτες</em>.) Το όριο των τεσσάρων κατατμήσεων είναι πολύ περιοριστικό για μεγάλους δίσκους, έτσι μια από αυτές τις κατατμήσεις μπορεί να μετατραπεί σε <em>εκτεταμένη κατάτμηση (extended partition)</em>. Μέσα στην εκτεταμένη κατάτμηση μπορούν να δημιουργηθούν πολλαπλές <em>λογικές κατατμήσεις (logical partitions)</em>. Αυτό ακούγεται κάπως παράξενο, και μάλλον είναι.</p></div><div class=paragraph><p>Ο <em>Πίνακας Κατατμήσεων GUID (GUID Partition Table)</em> ή GPT, αποτελεί μια νέα και απλούστερη μέθοδος κατάτμησης ενός δίσκου. Το GPT είναι πολύ πιο βολικό από τον παραδοσιακό πίνακα κατατμήσεων MBR. Οι συνήθεις υλοποιήσεις του GPT επιτρέπουν ως και 128 κατατμήσεις ανά δίσκο, εξαλείφοντας έτσι την ανάγκη για άβολες λύσεις όπως οι λογικές κατατμήσεις.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Κάποια παλιότερα λειτουργικά συστήματα όπως τα Windows® XP δεν είναι συμβατά με το σύστημα κατατμήσεων GPT. Αν το FreeBSD πρόκειται να εγκατασταθεί σε ένα δίσκο από κοινού με ένα τέτοιο λειτουργικό, θα πρέπει να χρησιμοποιήσετε το σύστημα MBR.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ο τυπικός φορτωτής εκκίνησης (boot loader) του FreeBSD χρειάζεται είτε μια πρωτεύουσα είτε μια GPT κατάτμηση. (Δείτε το <a href=./#boot>Η Διαδικασία Εκκίνησης του FreeBSD</a> για περισσότερες πληροφορίες σχετικά με τη διαδικασία εκκίνησης του FreeBSD.) Αν όλες οι πρωτεύουσες ή GPT κατατμήσεις είναι ήδη σε χρήση, θα πρέπει να ελευθερώσετε μία για χρήση με το FreeBSD.</p></div><div class=paragraph><p>Η ελάχιστη εγκατάσταση του FreeBSD καταλαμβάνει μόνο περίπου 1 GB χώρο στο δίσκο. Πρόκειται όμως για την <em>απόλυτα</em> ελάχιστη εγκατάσταση η οποία δεν αφήνει σχεδόν καθόλου ελεύθερο χώρο. Μια πιο ρεαλιστική ελάχιστη εγκατάσταση καταλαμβάνει περίπου 3 GB χωρίς γραφικό περιβάλλον και περίπου 5 GB με χρήση κάποιου γραφικού περιβάλλοντος. Η εγκατάσταση λογισμικού τρίτων κατασκευαστών απαιτεί ακόμα περισσότερο χώρο στο δίσκο.</p></div><div class=paragraph><p>Υπάρχει πληθώρα <a href=http://en.wikipedia.org/wiki/List_of_disk_partitioning_software>ελεύθερων και εμπορικών εργαλείων αναδιανομής χώρου κατατμήσεων</a>. Το <a href=http://gparted.sourceforge.net/livecd.php>GParted Live</a> είναι ένα δωρεάν Live CD το οποίο περιλαμβάνει τον επεξεργαστή κατατμήσεων GParted. Το GParted περιλαμβάνεται επίσης σε πολλές άλλες Live διανομές Linux.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Οι εφαρμογές που διαχειρίζονται κατατμήσεις σκληρών δίσκων μπορούν να καταστρέψουν τα δεδομένα σας. Πάρτε πλήρη αντίγραφα ασφαλείας και επιβεβαιώστε την ορθή λειτουργία τους πριν ξεκινήσετε την τροποποίηση των κατατμήσεων του δίσκου σας.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η αλλαγή μεγέθους κατατμήσεων των Microsoft® Vista ενδέχεται να είναι δύσκολη. Είναι χρήσιμο να έχετε διαθέσιμο ένα DVD εγκατάστασης των Vista πριν ξεκινήσετε μια τέτοια διαδικασία.</p></div><div class=exampleblock><div class=title>Παράδειγμα 1. Χρησιμοποιώντας μια Υπάρχουσα Κατάτμηση</div><div class=content><div class=paragraph><p>Ένας υπολογιστής Windows® διαθέτει ένα μοναδικό δίσκο 40 GB ο οποίος έχει χωριστεί σε δύο κατατμήσεις των 20 GB. Στα Windows® ονομάζονται <span class=filename>C:</span> και <span class=filename>D:</span>. Η κατάτμηση <span class=filename>C:</span> περιέχει 10 GB δεδομένων, ενώ η κατάτμηση <span class=filename>D:</span> 5 GB.</p></div><div class=paragraph><p>Η μετακίνηση των δεδομένων από τον <span class=filename>D:</span> στο <span class=filename>C:</span> ελευθερώνει τη δεύτερη κατάτμηση ώστε να μπορεί να χρησιμοποιηθεί από το FreeBSD.</p></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 2. Συρρικνώνοντας μια Υπάρχουσα Κατάτμηση</div><div class=content><div class=paragraph><p>Ένας υπολογιστής Windows® έχει ένα μοναδικό σκληρό δίσκο 40 GB και μια μεγάλη κατάτμηση που τον καταλαμβάνει εξ' ολοκλήρου. Τα Windows® δείχνουν αυτή την κατάτμηση των 40 GB ως ένα μοναδικό οδηγό <span class=filename>C:</span>. Τη δεδομένη στιγμή χρησιμοποιούνται 15 GB χώρου. Σκοπός είναι να καταλήξουμε με μια κατάτμηση των 20 GB για τα Windows® και άλλα 20 GB για το FreeBSD.</p></div><div class=paragraph><p>Υπάρχουν δύο τρόποι για να γίνει αυτό:</p></div><div class="olist arabic"><ol class=arabic><li><p>Κρατήστε αντίγραφο των δεδομένων που έχετε δημιουργήσει στα Windows®. Έπειτα επανεγκαταστήστε τα Windows® δημιουργώντας μια κατάτμηση μεγέθους 20 GB κατά την διαδικασία εγκατάστασης.</p></li><li><p>Χρησιμοποιήστε κάποιο εργαλείο αλλαγής μεγέθους κατατμήσεων όπως το GParted για να συρρικνώσετε την κατάτμηση των Windows® και να δημιουργήσετε μια νέα κατάτμηση για το FreeBSD στον ελεύθερο χώρο.</p></li></ol></div></div></div><div class=paragraph><p>Η εγκατάσταση διαφορετικών λειτουργικών συστημάτων σε άλλες κατατμήσεις, επιτρέπει την εκτέλεση ενός από αυτά σε μια δεδομένη χρονική στιγμή. Μια εναλλακτική μέθοδος που επιτρέπει την ταυτόχρονη εκτέλεση πολλών λειτουργικών περιγράφεται στο <a href=./#virtualization>Εικονικοποίηση</a>.</p></div></div></div><div class=sect3><h4 id=bsdinstall-collect-network-information>4.3.3. Συλλέξτε Πληροφορίες για το Δίκτυο<a class=anchor href=#bsdinstall-collect-network-information></a></h4><div class=paragraph><p>Κάποιες μέθοδοι εγκατάστασης του FreeBSD χρειάζονται μια σύνδεση δικτύου για να κατεβάσουν αρχεία. Για να συνδεθείτε με ένα δίκτυο Ethernet (ή μέσω καλωδιακού ή DSL modem με διεπαφή Ethernet), το πρόγραμμα εγκατάστασης θα σας ζητήσει πληροφορίες σχετικά με το δίκτυο σας.</p></div><div class=paragraph><p>Συχνά, γίνεται χρήση του <em>DHCP</em> ώστε οι ρυθμίσεις του δικτύου να γίνονται αυτόματα. Αν δεν διαθέτετε DHCP, θα πρέπει να βρείτε τις παρακάτω πληροφορίες από τον τοπικό σας διαχειριστή δικτύου ή τον παροχέα των υπηρεσιών σας:</p></div><div class="olist arabic"><ol class=arabic><li><p>Διεύθυνση IP</p></li><li><p>Μάσκα Υποδικτύου</p></li><li><p>Διεύθυνση IP προεπιλεγμένου δρομολογητή</p></li><li><p>Όνομα Τομέα για το τοπικό δίκτυο</p></li><li><p>Διευθύνσεις IP των διακομιστών DNS</p></li></ol></div></div><div class=sect3><h4 id=_ελέγξτε_για_παροράματα_errata_στο_freebsd>4.3.4. Ελέγξτε για Παροράματα (Errata) στο FreeBSD<a class=anchor href=#_ελέγξτε_για_παροράματα_errata_στο_freebsd></a></h4><div class=paragraph><p>Αν και το FreeBSD Project πασχίζει για να εξασφαλίσει ότι κάθε νέα έκδοση του FreeBSD θα είναι όσο πιο σταθερή γίνεται, ορισμένες φορές στη διαδικασία αυτή εισέρχονται λάθη. Σε πολύ σπάνιες περιπτώσεις, τα λάθη αυτά επηρεάζουν τη διαδικασία εγκατάστασης. Καθώς τα προβλήματα αυτά γίνονται αντιληπτά και επιδιορθώνονται, σημειώνονται στα <a href=https://www.FreeBSD.org/releases/9.0r/errata/>Παροράματα του FreeBSD</a> στη δικτυακή τοποθεσία του FreeBSD. Ελέγξτε τα παροράματα πριν ξεκινήσετε την εγκατάσταση, για να βεβαιωθείτε ότι δεν υπάρχουν προβλήματα που μπορούν να επηρεάσουν τη διαδικασία.</p></div><div class=paragraph><p>Μπορείτε να βρείτε πληροφορίες και παροράματα για όλες τις εκδόσεις στη σελίδα <a href=https://www.FreeBSD.org/releases/>πληροφοριών έκδοσης</a> στην <a href=https://www.FreeBSD.org/>δικτυακή τοποθεσία του FreeBSD</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-installation-media>4.3.5. Προετοιμάστε τα Μέσα Εγκατάστασης<a class=anchor href=#bsdinstall-installation-media></a></h4><div class=paragraph><p>Η εγκατάσταση του FreeBSD ξεκινάει με την εκκίνηση του υπολογιστή με τη χρήση ενός FreeBSD CD, DVD ή μνήμης USB. Το πρόγραμμα εγκατάστασης δεν μπορεί να εκτελεστεί μέσα από κάποιο άλλο λειτουργικό σύστημα.</p></div><div class=paragraph><p>Εκτός από τα τυποποιημένα μέσα εγκατάστασης που περιέχουν όλα τα απαραίτητα αρχεία εγκατάστασης του FreeBSD, διατίθεται επίσης και η εκδοχή <em>bootonly</em>. Αυτό το μέσο εγκατάστασης δεν περιέχει τα απαραίτητα αρχεία, αλλά τα κατεβάζει από το δίκτυο κατά τη διάρκεια της εγκατάστασης. Κατά συνέπεια, το συγκεκριμένο CD είναι αρκετά μικρότερο σε μέγεθος ενώ και το απαιτούμενο εύρος ζώνης του δικτύου περιορίζεται καθώς κατεβαίνουν μόνο τα αρχεία που απαιτούνται.</p></div><div class=paragraph><p>Μπορείτε να βρείτε έτοιμα μέσα εγκατάστασης για το FreeBSD στην <a href=https://www.FreeBSD.org/where/>δικτυακή τοποθεσία του FreeBSD.</a>. Κατεβάστε επίσης το αρχείο <span class=filename>CHECKSUM.SHA256</span> από τον ίδιο κατάλογο που περιέχει και το αρχείο εγκατάστασης και χρησιμοποιήστε το για να ελέγξετε την ακεραιότητα του αρχείου εγκατάστασης υπολογίζοντας το <em>Άθροισμα Ελέγχου (checksum)</em>. Το FreeBSD διαθέτει το <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a> για αυτό το σκοπό και θα βρείτε αντίστοιχα προγράμματα και σε άλλα λειτουργικά συστήματα. Επαληθεύστε το άθροισμα ελέγχου σύμφωνα με αυτό που αναγράφεται στο αρχείο <span class=filename>CHECKSUM.SHA256</span>. Τα αθροίσματα πρέπει να είναι ίδια. Αν δεν είναι, το αρχείο εγκατάστασης αλλοιώθηκε κατά το κατέβασμα και είναι άχρηστο.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Αν διαθέτετε ήδη ένα CDROM, DVD ή USB οδηγό εγκατάστασης FreeBSD, μπορείτε να παραλείψετε αυτή την ενότητα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Τα CD και DVD αρχεία ISO του FreeBSD είναι εκκινήσιμα. Χρειάζεστε μόνο ένα από αυτά για την εγκατάσταση. Γράψτε το αρχείο ISO σε ένα CD ή DVD χρησιμοποιώντας τα αντίστοιχα προγράμματα εγγραφής που διαθέτει το τρέχον λειτουργικό σας σύστημα. Στο FreeBSD, η εγγραφή μπορείτε να γίνει με το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> από το port <span class=filename>sysutils/cdrtools</span> που μπορείτε να εγκαταστήσετε από τη Συλλογή των Ports.</p></div><div class=paragraph><p>Για να δημιουργήσετε μια εκκινήσιμη μνήμη Flash (USB), ακολουθήστε τα παρακάτω βήματα:</p></div><div id=bsdinstall-installation-media-memory-stick class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ανακτήστε το Αρχείο ISO για τη Μνήμη Flash</p><div class=paragraph><p>Για το FreeBSD 9.0-RELEASE και μεταγενέστερες εκδόσεις, μπορείτε να κατεβάσετε το αντίστοιχο αρχείο από τον κατάλογο <span class=filename>ISO-IMAGES/</span> στην τοποθεσία <code><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/arch/arch/ISO-IMAGES/version/FreeBSD-version-RELEASE-arch-memstick.img class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/arch/arch/ISO-IMAGES/version/FreeBSD-version-RELEASE-arch-memstick.img</a></code>. Αντικαταστήστε το <em>arch</em> και το <em>version</em> με την αρχιτεκτονική και την έκδοση που θέλετε να εγκαταστήσετε. Για παράδειγμα, το αρχείο για το FreeBSD/i386 9.0-RELEASE βρίσκεται στη θέση <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/9.0/FreeBSD-9.0-RELEASE-i386-memstick.img>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/9.0/FreeBSD-9.0-RELEASE-i386-memstick.img</a>.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Ο κατάλογος είναι διαφορετικός για το FreeBSD 8.<em>X</em> και προηγούμενες εκδόσεις. Για περισσότερες πληροφορίες σχετικά με το κατέβασμα και την εγκατάσταση του FreeBSD 8.<em>X</em> και προηγούμενων εκδόσεων, δείτε το <a href=./#install>Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a>.</p></div></div></div><div class=paragraph><p>Το αρχείο για τη μνήμη Flash έχει επέκταση <span class=filename>.img</span>. Ο κατάλογος <span class=filename>ISO-IMAGES/</span> περιέχει πλήθος από διαφορετικά αρχεία. Θα πρέπει να κατεβάσετε το κατάλληλο ανάλογα με την έκδοση του FreeBSD και το υλικό του υπολογιστή που πρόκειται να χρησιμοποιηθεί.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Πριν προχωρήσετε, <em>αντιγράψτε</em> τυχόν δεδομένα που έχετε ήδη στη μνήμη USB, καθώς η παρακάτω διαδικασία θα τα <em>διαγράψει</em>.</p></div></div></div></li><li><p>Γράψτε το Αρχείο στη Μνήμη USB</p></li></ol></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Εγγραφή του Αρχείου με Χρήση του FreeBSD</strong></p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Το παρακάτω παράδειγμα δείχνει τη συσκευή <span class=filename>/dev/da0</span> ως τον προορισμό εγγραφής του αρχείου. Θα πρέπει να είστε πολύ προσεκτικοί και να βεβαιωθείτε για το όνομα της συσκευής που χρησιμοποιείτε, διαφορετικά ενδέχεται να διαγράψετε δεδομένα που χρειάζεστε.</p></div></div></div><div class="olist arabic"><ol class=arabic><li><p>Εγγραφή του Αρχείου με την <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a></p><div class=paragraph><p>Το αρχείο <span class=filename>.img</span><em>δεν</em> είναι ένα συνηθισμένο αρχείο. Είναι ένα αρχείο <em>εικόνας (image)</em> με όλο το περιεχόμενο που χρειάζεται η μνήμη USB. <em>Δεν μπορείτε</em> να το αντιγράψετε ως ένα κανονικό αρχείο, θα χρειαστεί να το γράψετε απευθείας στη συσκευή προορισμού χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=FreeBSD-9.0-RELEASE-i386-memstick.img of=/dev/da0 bs=64k</span></code></pre></div></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Εγγραφή του Αρχείου Μέσω Windows®</strong></p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Βεβαιωθείτε ότι χρησιμοποιείτε το σωστό όνομα οδηγού για την μνήμη USB, διαφορετικά μπορεί να προκληθεί απώλεια δεδομένων.</p></div></div></div><div class="olist arabic"><ol class=arabic><li><p>Ανάκτηση του Προγράμματος Image Writer για Windows®</p><div class=paragraph><p>Το Image Writer για Windows® είναι μια δωρεάν εφαρμογή που μπορεί να γράψει σωστά ένα αρχείο image σε μια μνήμη USB. Μπορείτε να το κατεβάσετε από την τοποθεσία <a href=https://launchpad.net/win32-image-writer/>https://launchpad.net/win32-image-writer/</a> και να το αποσυμπιέσετε σε ένα φάκελο.</p></div></li><li><p>Εγγραφή του Αρχείου με το Image Writer</p><div class=paragraph><p>Κάντε διπλό κλικ στο εικονίδιο Win32DiskImager για να ξεκινήσετε το πρόγραμμα. Βεβαιωθείτε ότι το γράμμα του οδηγού που φαίνεται στην επιλογή <code>Device</code> αντιστοιχεί στη μνήμη USB. Κάντε κλικ στο εικονίδιο με το φάκελο και επιλέξτε το αρχείο εικόνας που θα γραφεί στη μνήμη USB. Κάντε κλικ στο <b class=button>Save</b> για να αποδεχθείτε το όνομα του αρχείου εικόνας. Βεβαιωθείτε ότι οι παραπάνω ενέργειες είναι σωστές και ότι δεν υπάρχουν ανοικτά παράθυρα στο σύστημα σας που να απεικονίζουν φακέλους της μνήμης USB. Τέλος, κάντε κλικ στο <b class=button>Write</b> για να γράψετε το αρχείο εικόνας στη μνήμη USB.</p></div></li></ol></div></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Δεν υποστηρίζεται πλέον η εγκατάσταση από δισκέτες</p></div></td></tr></tbody></table></div><div class=paragraph><p>Είστε πλέον έτοιμοι να ξεκινήσετε την εγκατάσταση του FreeBSD.</p></div></div></div><div class=sect2><h3 id=bsdinstall-start>4.4. Ξεκινώντας την Εγκατάσταση<a class=anchor href=#bsdinstall-start></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Από προεπιλογή, η εγκατάσταση δεν θα κάνει αλλαγές στους δίσκους σας μέχρι να δείτε το παρακάτω μήνυμα:</p></div><div class="literalblock programlisting"><div class=content><pre>Your changes will now be written to disk.  If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?</pre></div></div><div class=paragraph><p>Μπορείτε να εγκαταλείψετε την εγκατάσταση οποιαδήποτε στιγμή πριν από την παραπάνω προειδοποίηση, χωρίς να έχουν γίνει αλλαγές στα περιεχόμενα του δίσκου σας. Αν ανησυχείτε ότι ενδεχομένως έχετε κάνει κάτι λάθος, μπορείτε απλά να σβήσετε τον υπολογιστή σας πριν από αυτό το σημείο και δεν θα γίνει καμιά ζημιά.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=bsdinstall-starting>4.4.1. Εκκίνηση<a class=anchor href=#bsdinstall-starting></a></h4><div class=sect4><h5 id=bsdinstall-starting-i386>4.4.1.1. Εκκίνηση στις Αρχιτεκτονικές i386™ και amd64<a class=anchor href=#bsdinstall-starting-i386></a></h5><div class="olist arabic procedure"><ol class=arabic><li><p>Αν προετοιμάσατε μια "εκκινήσιμη" μνήμη USB όπως περιγράφεται στο <a href=#bsdinstall-installation-media>Προετοιμάστε τα Μέσα Εγκατάστασης</a>, τοποθετήστε τη μνήμη στην υποδοχή του υπολογιστή σας πριν τον ενεργοποιήσετε.</p><div class=paragraph><p>Αν πρόκειται να εκκινήσετε από το CDROM, θα χρειαστεί να ενεργοποιήσετε τον υπολογιστή σας και να εισάγετε το CDROM όσο πιο γρήγορα γίνεται.</p></div></li><li><p>Ρυθμίστε το μηχάνημα σας να ξεκινάει είτε από το CDROM είτε από την USB, ανάλογα με το μέσο εγκατάστασης που πρόκειται να χρησιμοποιήσετε. Γενικά, αυτό επιτυγχάνεται αλλάζοντας τη σχετική ρύθμιση στο BIOS. Τα περισσότερα συστήματα επιτρέπουν επίσης την επιλογή μιας συσκευής εκκίνησης καθώς ξεκινούν, τυπικά με τα πλήκτρα <kbd>F10</kbd>, <kbd>F11</kbd>, <kbd>F12</kbd>, ή <kbd>Escape</kbd>.</p></li><li><p>Αν ο υπολογιστής σας ξεκινήσει όπως συνήθως και φορτώσει το ήδη υπάρχον λειτουργικό σύστημα, μπορεί να συμβαίνει κάτι από τα παρακάτω:</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Δεν τοποθετήσατε το CD ή DVD αρκετά νωρίς κατά την εκκίνηση. Αφήστε το μέσο στον οδηγό και δοκιμάστε να επανεκκινήσετε τον υπολογιστή σας.</p></li><li><p>Οι αλλαγές ρυθμίσεων που κάνατε στο BIOS δεν λειτούργησαν σωστά. Θα πρέπει να ξαναδοκιμάσετε μέχρι να πετύχετε τις σωστές ρυθμίσεις.</p></li><li><p>Το BIOS της μητρικής σας δεν υποστηρίζει εκκίνηση από το μέσο που έχετε επιλέξει. Μπορείτε να χρησιμοποιήσετε τον <a href=http://www.plop.at/en/bootmanager.html>Plop Boot Manager</a> για να εκκινήσετε παλιά μηχανήματα από CD ή USB.</p></li></ol></div></li><li><p>Θα αρχίσει η εκκίνηση του FreeBSD. Αν ξεκινάτε από CDROM, θα δείτε μια οθόνη σαν την παρακάτω (έχουμε παραλείψει τις πληροφορίες έκδοσης):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Booting from CD-ROM...
645MB medium detected
CD Loader 1.2

Building the boot loader arguments
Looking up /BOOT/LOADER... Found
Relocating the loader and the BTX
Starting the BTX loader

BTX loader 1.00 BTX version is 1.02
Consoles: internal video/keyboard
BIOS CD is cd0
BIOS drive C: is disk0
BIOS drive D: is disk1
BIOS 636kB/261056kB available memory

FreeBSD/i386 bootstrap loader, Revision 1.1

Loading /boot/defaults/loader.conf
/boot/kernel/kernel <span class=nv>text</span><span class=o>=</span>0x64daa0 <span class=nv>data</span><span class=o>=</span>0xa4e80+0xa9e40 <span class=nv>syms</span><span class=o>=[</span>0x4+0x6cac0+0x4+0x88e9d]
<span class=se>\</span></code></pre></div></div></li><li><p>Εμφανίζεται η οθόνη του φορτωτή εκκίνησης του FreeBSD:</p><div id=bsdinstall-boot-loader-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-boot-loader-menu.png alt="bsdinstall boot loader menu"></div><div class=title>Σχήμα 1. Μενού Φορτωτή Εκκίνησης του FreeBSD</div></div><div class=paragraph><p>Περιμένετε δέκα δευτερόλεπτα, ή πιέστε <kbd>Enter</kbd>.</p></div></li></ol></div></div><div class=sect4><h5 id=_εκκίνηση_στον_macintosh_powerpc>4.4.1.2. Εκκίνηση στον Macintosh® PowerPC®<a class=anchor href=#_εκκίνηση_στον_macintosh_powerpc></a></h5><div class=paragraph><p>Στα περισσότερα μηχανήματα, μπορείτε να κρατήσετε πιεσμένο το πλήκτρο <kbd>C</kbd> κατά την εκκίνηση και θα ξεκινήσετε από το CD. Σε διαφορετική περίπτωση, κρατήστε πιεσμένα τα πλήκτρα <span class=keyseq><kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span>, ή <span class=keyseq><kbd>Windows</kbd>+<kbd>Alt</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span> αν χρησιμοποιείτε πληκτρολόγιο που δεν είναι Apple®. Στην προτροπή <code>0 ></code> γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nb>cd</span>:,<span class=se>\p</span>pc<span class=se>\l</span>oader <span class=nb>cd</span>:0</code></pre></div></div><div class=paragraph><p>Σε μηχανήματα Xserve χωρίς πληκτρολόγιο, δείτε την <a href=http://support.apple.com/kb/TA26930>σελίδα τεχνικής υποστήριξης της Apple®</a> για πληροφορίες εκκίνησης στο Open Firmware.</p></div></div><div class=sect4><h5 id=_εκκίνηση_στον_sparc64>4.4.1.3. Εκκίνηση στον sparc64<a class=anchor href=#_εκκίνηση_στον_sparc64></a></h5><div class=paragraph><p>Τα περισσότερα συστήματα sparc64 είναι ρυθμισμένα να εκκινούν αυτόματα από το σκληρό δίσκο. Για να εγκαταστήσετε το FreeBSD, θα πρέπει να εκκινήσετε από το δίκτυο ή από ένα CDROM. Θα χρειαστεί να εισέλθετε στις ρυθμίσεις της PROM (OpenFirmware).</p></div><div class=paragraph><p>Για να γίνει αυτό, επανεκκινήστε το σύστημα και περιμένετε μέχρι να εμφανιστεί το μήνυμα εκκίνησης. Το ακριβές μήνυμα εξαρτάται από το μοντέλο, αλλά γενικά θα δείχνει όπως το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Sun Blade 100 <span class=o>(</span>UltraSPARC-IIe<span class=o>)</span>, Keyboard Present
Copyright 1998-2001 Sun Microsystems, Inc.  All rights reserved.
OpenBoot 4.2, 128 MB memory installed, Serial <span class=c>#51090132.</span>
Ethernet address 0:3:ba:b:92:d4, Host ID: 830b92d4.</code></pre></div></div><div class=paragraph><p>Αν μετά από αυτό το σημείο το σύστημα σας συνεχίζει με εκκίνηση από το σκληρό δίσκο, θα πρέπει να πιέσετε <span class=keyseq><kbd>L1</kbd>+<kbd>A</kbd></span> ή <span class=keyseq><kbd>Stop</kbd>+<kbd>A</kbd></span> στο πληκτρολόγιο, ή να στείλετε σήμα <code>BREAK</code> μέσω της σειριακής κονσόλας (χρησιμοποιώντας π.χ. το <code>~#</code> στο <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> ή <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a>) για να βγείτε στην προτροπή της PROM η οποία μοιάζει με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ok     <i class=conum data-value=1></i><b>(1)</b>
ok <span class=o>{</span>0<span class=o>}</span> <i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Αυτή η προτροπή φαίνεται σε συστήματα με μόνο μία CPU.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Αυτή η προτροπή φαίνεται σε συστήματα SMP. Το ψηφίο δείχνει τον αριθμό της ενεργής CPU.</td></tr></tbody></table></div><div class=paragraph><p>Στο σημείο αυτό, τοποθετήστε το CDROM στον οδηγό και στην προτροπή της PROM γράψτε <code>boot cdrom</code>.</p></div></div></div><div class=sect3><h4 id=bsdinstall-view-probe>4.4.2. Επισκόπηση των Αποτελεσμάτων Ανίχνευσης Συσκευών<a class=anchor href=#bsdinstall-view-probe></a></h4><div class=paragraph><p>Οι τελευταίες εκατοντάδες γραμμές που πέρασαν από την οθόνη σας αποθηκεύονται και μπορείτε να τις ξαναδείτε.</p></div><div class=paragraph><p>Για να δείτε τα περιεχόμενα της προσωρινής μνήμης (buffer) πιέστε <kbd>Scroll Lock</kbd>. Με τον τρόπο αυτό ενεργοποιείται η κύλιση της οθόνης. Μπορείτε έπειτα να χρησιμοποιήσετε τα πλήκτρα με τα βελάκια ή τα <kbd>PageUp</kbd> και <kbd>PageDown</kbd> για να δείτε τα αποτελέσματα. Πιέστε ξανά το <kbd>Scroll Lock</kbd> για να σταματήσετε την κύλιση.</p></div><div class=paragraph><p>Κάντε το αυτό τώρα, για να ξαναδείτε το κείμενο που κύλησε εκτός οθόνης καθώς ο πυρήνας εκτελούσε την ανίχνευση συσκευών. Θα δείτε κείμενο αντίστοιχο με το <a href=#bsdinstall-dev-probe>Τυπικά Αποτελέσματα Ανίχνευσης Συσκευών</a>, αν και θα υπάρχουν διαφορές ανάλογα με τις συσκευές που διαθέτει ο υπολογιστής σας.</p></div><div id=bsdinstall-dev-probe class=paragraph><div class=title>Τυπικά Αποτελέσματα Ανίχνευσης Συσκευών</div><p>Ελέγξτε προσεκτικά τα αποτελέσματα της ανίχνευσης συσκευών για να βεβαιωθείτε ότι το FreeBSD βρήκε όλες τις συσκευές που αναμένατε. Αν κάποια συσκευή δεν βρέθηκε, δεν θα φαίνεται στην παραπάνω λίστα. Τα <a href=./#kernelconfig-modules>Αρθρώματα Πυρήνα</a> σας επιτρέπουν να προσθέσετε υποστήριξη για συσκευές που δεν υπάρχουν στον πυρήνα <span class=filename>GENERIC</span>.</p></div><div class=paragraph><p>Μετά τη διαδικασία ανίχνευσης συσκευών θα δείτε το <a href=#bsdinstall-choose-mode>Επιλογή Τρόπου Λειτουργίας Μέσου Εγκατάστασης</a>. Το μέσο εγκατάστασης μπορεί να χρησιμοποιηθεί με τρεις τρόπους: για να εγκαταστήσετε το FreeBSD, ως "live CD" ή απλά για να αποκτήσετε πρόσβαση σε ένα κέλυφος του FreeBSD. Χρησιμοποιήστε τα βελάκια για να κάνετε μια επιλογή και το <kbd>Enter</kbd> για να την επιβεβαιώσετε.</p></div><div id=bsdinstall-choose-mode class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-choose-mode.png alt="bsdinstall choose mode"></div><div class=title>Σχήμα 2. Επιλογή Τρόπου Λειτουργίας Μέσου Εγκατάστασης</div></div><div class=paragraph><p>Επιλέξτε <b class=button>Install</b> για να ξεκινήσετε το πρόγραμμα εγκατάστασης.</p></div></div></div><div class=sect2><h3 id=using-bsdinstall>4.5. Εισαγωγή στο bsdinstall<a class=anchor href=#using-bsdinstall></a></h3><div class=paragraph><p>Το bsdinstall είναι μια εφαρμογή εγκατάστασης για το FreeBSD που βασίζεται σε περιβάλλον κειμένου. Γράφτηκε από τον Nathan Whitehorn &lt;<a href=mailto:nwhitehorn@FreeBSD.org>nwhitehorn@FreeBSD.org</a>> και χρησιμοποιήθηκε πρώτη φορά το 2011 στο FreeBSD 9.0.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η εφαρμογή pc-sysinstall του Kris Moore &lt;<a href=mailto:kmoore@FreeBSD.org>kmoore@FreeBSD.org</a>> συμπεριλαμβάνεται με το <a href=http://pcbsd.org>PC-BSD</a> και μπορεί επίσης να χρησιμοποιηθεί για την <a href=http://wiki.pcbsd.org/index.php/Use_PC-BSD_Installer_to_Install_FreeBSD>εγκατάσταση του FreeBSD</a>. Αν και μερικές φορές συγχέεται με το bsdinstall οι δύο αυτές εφαρμογές δεν σχετίζονται.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το σύστημα μενού του bsdinstall ελέγχεται μέσω των πλήκτρων με τα βελάκια και τα πλήκτρα <kbd>Enter</kbd>, <kbd>Tab</kbd>, <kbd>Space</kbd> και μερικά ακόμα.</p></div><div class=sect3><h4 id=bsdinstall-keymap>4.5.1. Επιλογές στο Μενού Keymap<a class=anchor href=#bsdinstall-keymap></a></h4><div class=paragraph><p>Ανάλογα με το είδος της κονσόλας που χρησιμοποιείτε, το bsdinstall ίσως σας ρωτήσει αν επιθυμείτε να επιλέξετε μια διάταξη πληκτρολογίου διαφορετική από την προεπιλεγμένη.</p></div><div id=bsdinstall-keymap-select-default class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-select-default.png alt="bsdinstall keymap select default"></div><div class=title>Σχήμα 3. Επιλογή Διάταξης Πληκτρολογίου</div></div><div class=paragraph><p>Αν επιλέξετε <b class=button>YES</b> θα εμφανιστεί η οθόνη επιλογής που φαίνεται παρακάτω. Σε διαφορετική περίπτωση, η οθόνη αυτή δεν θα εμφανιστεί και θα χρησιμοποιηθεί η προεπιλεγμένη διάταξη πληκτρολογίου.</p></div><div id=bsdinstall-config-keymap class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-keymap.png alt="bsdinstall config keymap"></div><div class=title>Σχήμα 4. Μενού Επιλογής Διάταξης Πληκτρολογίου</div></div><div class=paragraph><p>Επιλέξτε την διάταξη πληκτρολογίου που είναι πιο κοντά στο πληκτρολόγιο που διαθέτετε, χρησιμοποιώντας τα πάνω και κάτω βελάκια και επιβεβαιώνοντας με το <kbd>Enter</kbd>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν πιέσετε <kbd>Esc</kbd> θα χρησιμοποιηθεί η προεπιλεγμένη διάταξη. Αν η διάταξη του τρέχοντος πληκτρολογίου δεν είναι προφανής, μια ασφαλής επιλογή είναι το <span class=guimenuitem>United States of America ISO-8859-1</span>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=bsdinstall-hostname>4.5.2. Καθορισμός Ονόματος Υπολογιστή (hostname)<a class=anchor href=#bsdinstall-hostname></a></h4><div class=paragraph><p>Στο επόμενο βήμα, το bsdinstall θα σας ρωτήσει για το όνομα υπολογιστή (hostname) το οποίο θα δοθεί στο νέο σύστημα.</p></div><div id=bsdinstall-config-hostname class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-hostname.png alt="bsdinstall config hostname"></div><div class=title>Σχήμα 5. Καθορισμός Ονόματος Υπολογιστή</div></div><div class=paragraph><p>Το όνομα που θα δώσετε πρέπει να περιλαμβάνει και τον τομέα (fully-qualified) όπως για παράδειγμα <code>machine3.example.com</code></p></div></div><div class=sect3><h4 id=bsdinstall-components>4.5.3. Επιλογή Στοιχείων Εγκατάστασης<a class=anchor href=#bsdinstall-components></a></h4><div class=paragraph><p>Στο επόμενο βήμα, το bsdinstall θα σας καλέσει να επιλέξετε ποια προαιρετικά στοιχεία του λειτουργικού επιθυμείτε να εγκαταστήσετε.</p></div><div id=bsdinstall-config-components class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-components.png alt="bsdinstall config components"></div><div class=title>Σχήμα 6. Επιλογή Στοιχείων Εγκατάστασης</div></div><div class=paragraph><p>Η επιλογή των στοιχείων εγκατάστασης εξαρτάται κυρίως από την χρήση που θα έχει το σύστημα και το διαθέσιμο ελεύθερο χώρο στο δίσκο. Ο πυρήνας και τα βασικά προγράμματα του FreeBSD (γνωστά και ως "base system" ή βασικό σύστημα) εγκαθίστανται υποχρεωτικά.</p></div><div class=paragraph><p>Ανάλογα με το είδος της εγκατάστασης, κάποια από τα παρακάτω στοιχεία μπορεί να μην εμφανιστούν.</p></div><div class=ulist><div class=title>Προαιρετικά Στοιχεία</div><ul><li><p><code>doc</code> - Επιπρόσθετη τεκμηρίωση, κυρίως ιστορικής σημασίας. Η τεκμηρίωση που παρέχεται από την Ομάδα Τεκμηρίωσης του FreeBSD εγκαθίσταται χωριστά σε επόμενο στάδιο.</p></li><li><p><code>games</code> - Κάποια παραδοσιακά BSD παιχνίδια που περιλαμβάνουν τα fortune, rot13 και άλλα.</p></li><li><p><code>lib32</code> - Βιβλιοθήκες συμβατότητας για εκτέλεση εφαρμογών 32-bit σε 64-bit εκδόσεις του FreeBSD.</p></li><li><p><code>ports</code> - Η Συλλογή των Ports του FreeBSD.</p><div class=paragraph><p>Η Συλλογή των Ports αποτελεί ένα εύκολο και βολικό τρόπο εγκατάστασης λογισμικού. Η Συλλογή των Ports δεν περιέχει τον πηγαίο κώδικα που απαιτείται για τη μεταγλώττιση του λογισμικού. Πρόκειται στην πραγματικότητα για μια συλλογή αρχείων που αυτοματοποιεί τη μεταφόρτωση, μεταγλώττιση και εγκατάσταση λογισμικού τρίτων κατασκευαστών. Το <a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a> αναλύει τον τρόπο χρήσης της Συλλογής των Ports.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Το πρόγραμμα εγκατάστασης δεν ελέγχει για να δει αν διαθέτετε αρκετό ελεύθερο χώρο στο δίσκο. Επιλέξτε αυτό το στοιχείο μόνο αν έχετε αρκετό χώρο. Από το FreeBSD 9.0 και μετά, η Συλλογή των Ports καταλαμβάνει περίπου 3 GB χώρο στο δίσκο. Μπορείτε με βεβαιότητα να θεωρήσετε ότι ο χώρος αυτός θα είναι ακόμα μεγαλύτερος στις νεώτερες εκδόσεις του FreeBSD.</p></div></td></tr></tbody></table></div></li><li><p><code>src</code> - Ο Πηγαίος Κώδικας του Συστήματος.</p><div class=paragraph><p>Το FreeBSD έρχεται με πλήρη πηγαίο κώδικα, τόσο για τον πυρήνα όσο και για τα βασικά προγράμματα. Αν και ο πηγαίος κώδικας δεν απαιτείται για την πλειονότητα των εφαρμογών, ίσως να τον χρειαστείτε για τη μεταγλώττιση συγκεκριμένων προγραμμάτων που παρέχονται ως πηγαίος κώδικας (π.χ. οδηγούς συσκευών ή αρθρώματα πυρήνα), ή για εργασίες ανάπτυξης του ίδιου του FreeBSD.</p></div><div class=paragraph><p>Το πλήρες δέντρο του πηγαίου κώδικα καταλαμβάνει 1 GB χώρου στο δίσκο, ενώ μια πλήρης μεταγλώττιση όλου του FreeBSD απαιτεί επιπλέον 5 GB χώρου.</p></div></li></ul></div></div></div><div class=sect2><h3 id=bsdinstall-netinstall>4.6. Εγκατάσταση από το Δίκτυο<a class=anchor href=#bsdinstall-netinstall></a></h3><div class=paragraph><p>Το μέσο εγκατάστασης <em>bootonly</em> δεν διαθέτει αντίγραφα των αρχείων εγκατάστασης. Όταν χρησιμοποιείτε την μέθοδο <em>bootonly</em>, τα αρχεία μεταφορτώνονται από το δίκτυο κατά απαίτηση.</p></div><div id=bsdinstall-netinstall-notify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-files.png alt="bsdinstall netinstall files"></div><div class=title>Σχήμα 7. Εγκατάσταση από το Δίκτυο</div></div><div class=paragraph><p>Μετά την ρύθμιση των παραμέτρων δικτύου όπως φαίνεται στο <a href=#bsdinstall-config-network-dev>Ρύθμιση Καρτών Δικτύου</a>, γίνεται η επιλογή ενός mirror site. Τα mirror sites διαθέτουν αντίγραφα των αρχείων του FreeBSD. Επιλέξτε ένα mirror site το οποίο βρίσκεται όσο το δυνατόν πιο κοντά στην περιοχή σας. Με τον τρόπο αυτό, η μεταφόρτωση των αρχείων θα είναι ταχύτερη και θα μειωθεί ο χρόνος εγκατάστασης.</p></div><div id=bsdinstall-netinstall-mirror class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-mirrorselect.png alt="bsdinstall netinstall mirrorselect"></div><div class=title>Σχήμα 8. Επιλογή Mirror</div></div><div class=paragraph><p>Η εγκατάσταση θα συνεχιστεί με τον ίδιο τρόπο όπως και αν τα αρχεία ήταν διαθέσιμα τοπικά.</p></div></div><div class=sect2><h3 id=bsdinstall-partitioning>4.7. Εκχώρηση Χώρου στο Δίσκο<a class=anchor href=#bsdinstall-partitioning></a></h3><div class=paragraph><p>Υπάρχουν τρεις τρόποι να εκχωρήσετε χώρο για το FreeBSD. Με τη μέθοδο <em>Guided (καθοδηγούμενη)</em>, οι κατατμήσεις δημιουργούνται αυτόματα, ενώ με τη μέθοδο <em>Manual (χειροκίνητη)</em> οι προχωρημένοι χρήστες μπορούν να δημιουργήσουν προσαρμοσμένες κατατμήσεις. Τέλος, υπάρχει η επιλογή να εκκινήσετε ένα κέλυφος και να δημιουργήσετε τις κατατμήσεις με απευθείας χρήση προγραμμάτων της γραμμής εντολών όπως <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>, και <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></div><div id=bsdinstall-part-guided-manual class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-manual.png alt="bsdinstall part guided manual"></div><div class=title>Σχήμα 9. Επιλογή Guided ή Manual Partitioning</div></div><div class=sect3><h4 id=bsdinstall-part-guided>4.7.1. Καθοδηγούμενη (Guided) Κατάτμηση<a class=anchor href=#bsdinstall-part-guided></a></h4><div class=paragraph><p>Αν έχετε συνδέσει πολλαπλούς δίσκους, επιλέξτε αυτόν στον οποίο θα εγκαταστήσετε το FreeBSD.</p></div><div id=bsdinstall-part-guided-disk class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-disk.png alt="bsdinstall part guided disk"></div><div class=title>Σχήμα 10. Επιλογή από Πολλαπλούς Δίσκους</div></div><div class=paragraph><p>Μπορείτε να εκχωρήσετε είτε ολόκληρο το δίσκο, είτε ένα μέρος του στο FreeBSD. Αν επιλέξετε <b class=button>Entire Disk</b>, θα δημιουργηθούν μια κατάλληλη διάταξη κατατμήσεων ώστε να χρησιμοποιηθεί ολόκληρος ο δίσκος. Αν επιλέξετε <b class=button>Partition</b>, θα δημιουργηθεί μια διάταξη που θα καταλαμβάνει τον ελεύθερο χώρο του δίσκου.</p></div><div id=bsdinstall-part-entire-part class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-entire-part.png alt="bsdinstall part entire part"></div><div class=title>Σχήμα 11. Επιλογή Ολόκληρου Δίσκου ή Κατάτμησης</div></div><div class=paragraph><p>Ελέγξτε προσεκτικά τη διάταξη των κατατμήσεων που δημιουργήθηκε. Αν βρείτε κάποιο λάθος, επιλέξτε <b class=button>Revert</b> για να επαναφέρετε τις προηγούμενες κατατμήσεις ή <b class=button>Auto</b> για να δημιουργήσετε τις κατατμήσεις που προτείνονται αυτόματα από το FreeBSD. Μπορείτε να δημιουργήσετε, να τροποποιήσετε και να διαγράψετε κατατμήσεις χειροκίνητα. Όταν οι κατατμήσεις είναι οι σωστές, επιλέξτε <b class=button>Finish</b> για να συνεχίσετε με την εγκατάσταση.</p></div><div id=bsdinstall-part-review class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-review.png alt="bsdinstall part review"></div><div class=title>Σχήμα 12. Επισκόπηση Κατατμήσεων</div></div></div><div class=sect3><h4 id=bsdinstall-part-manual>4.7.2. Χειροκίνητη Δημιουργία Κατατμήσεων<a class=anchor href=#bsdinstall-part-manual></a></h4><div class=paragraph><p>Επιλέγοντας χειροκίνητη δημιουργία κατατμήσεων, θα μεταφερθείτε απευθείας στον επεξεργαστή κατατμήσεων.</p></div><div id=bsdinstall-part-manual-create class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-create.png alt="bsdinstall part manual create"></div><div class=title>Σχήμα 13. Χειροκίνητη Δημιουργία Κατατμήσεων</div></div><div class=paragraph><p>Επιλέγοντας ένα οδηγό (<span class=filename>ada0</span> στο παράδειγμα μας) και το πλήκτρο <b class=button>Create</b> θα δείτε ένα μενού για την επιλογή του σχήματος κατατμήσεων (<em>partitioning scheme</em>).</p></div><div id=bsdinstall-part-manual-partscheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div><div class=title>Σχήμα 14. Χειροκίνητη Δημιουργία Κατατμήσεων</div></div><div class=paragraph><p>Το σύστημα κατατμήσεων GPT είναι συνήθως το καταλληλότερο για τα περισσότερους PC-συμβατούς υπολογιστές. Παλαιότερα λειτουργικά συστήματα δεν είναι συμβατά με τη μέθοδο GPT και χρειάζονται κατατμήσεις τύπου MBR. Τα υπόλοιπα είδη κατατμήσεων χρησιμοποιούνται σε παλιά ή μη-συνηθισμένα συστήματα υπολογιστών.</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Πίνακας 1. Κατηγορίες Κατατμήσεων</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Συντομογραφία</th><th class="tableblock halign-left valign-top">Περιγραφή</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>APM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://support.apple.com/kb/TA21692>Apple Partition Map, χρησιμοποιείται στο PowerPC® Macintosh®.</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>BSD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Κατατμήσεις BSD χωρίς MBR, ορισμένες φορές καλούνται και "επικίνδυνα αφοσιωμένη κατάσταση". Δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GPT</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>Πίνακας Κατατμήσεων GUID.</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>MBR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://en.wikipedia.org/wiki/Master_boot_record>Master Boot Record.</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PC98</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://en.wikipedia.org/wiki/Pc9801>Παραλλαγή του MBR που χρησιμοποιείται σε υπολογιστές NEC PC-98.</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>VTOC8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Volume Table Of Contents, χρησιμοποιείται στα Sun SPARC64 και UltraSPARC.</p></td></tr></tbody></table><div class=paragraph><p>Μετά τη δημιουργία του σχήματος κατατμήσεων, αν επιλέξετε ξανά <b class=button>Create</b> θα δημιουργήσετε νέες κατατμήσεις.</p></div><div id=bsdinstall-part-manual-addpart class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-addpart.png alt="bsdinstall part manual addpart"></div><div class=title>Σχήμα 15. Χειροκίνητη Δημιουργία Κατατμήσεων</div></div><div class=paragraph><p>Η τυποποιημένη εγκατάσταση FreeBSD με χρήση GPT δημιουργεί τουλάχιστον τρεις κατατμήσεις:</p></div><div class=ulist><div class=title>Τυποποιημένες FreeBSD GPT Κατατμήσεις</div><ul><li><p><code>freebsd-boot</code> - Ο κώδικας εκκίνησης του FreeBSD. Η κατάτμηση αυτή πρέπει να είναι η πρώτη στο δίσκο.</p></li><li><p><code>freebsd-ufs</code> - Σύστημα αρχείων FreeBSD UFS.</p></li><li><p><code>freebsd-swap</code> - Χώρος swap FreeBSD.</p></li></ul></div><div class=paragraph><p>Ένα άλλο αξιοσημείωτο είδος κατάτμησης, είναι το <code>freebsd-zfs</code>. Δείτε το <a href=./#filesystems-zfs>Το Σύστημα Αρχείων Z (ZFS)</a>. Μπορείτε να δείτε τα υπόλοιπα διαθέσιμα είδη κατατμήσεων GPT στο <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>.</p></div><div class=paragraph><p>Μπορείτε να δημιουργήσετε πολλαπλά συστήματα αρχείων. Κάποιοι χρήστες προτιμούν τη δημιουργία των παραδοσιακών κατατμήσεων με χωριστά συστήματα αρχείων για τα <span class=filename>/</span>, <span class=filename>/var</span>, και <span class=filename>/usr</span>. Δείτε το <a href=#bsdinstall-part-manual-splitfs>Δημιουργία Παραδοσιακών Κατατμήσεων στο Σύστημα Αρχείων</a> για ένα παράδειγμα.</p></div><div class=paragraph><p>Μπορείτε να εισάγετε το μέγεθος με τη βοήθεια κοινών συντομεύσεων: <em>K</em> για kilobytes, <em>M</em> για megabytes, ή <em>G</em> για gigabytes.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Η καλύτερη απόδοση επιτυγχάνεται με ευθυγράμμιση των τομέων του δίσκου (sector alignment). Η σωστή ευθυγράμμιση επιτυγχάνεται με τη δημιουργία κατατμήσεων με μεγέθη πολλαπλάσια των 4K bytes σε οδηγούς που χρησιμοποιούν τομείς των 512 bytes ή 4K-byte. Σε γενικές γραμμές, η χρήση κατατμήσεων με μεγέθη που είναι άρτια πολλαπλάσια του 1Μ ή 1G είναι ο ευκολότερος τρόπος να επιβεβαιώσουμε ότι κάθε κατάτμηση ξεκινά σε ζυγό πολλαπλάσιο των 4Κ. Μια εξαίρεση: την παρούσα στιγμή η κατάτμηση <em>freebsd-boot</em> δεν μπορεί να είναι μεγαλύτερη των 512Κ λόγων περιορισμών του κώδικα εκκίνησης.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Σε κάθε κατάτμηση που περιέχει σύστημα αρχείων, χρειάζεται ένα σημείο προσάρτησης. Αν χρησιμοποιηθεί μόνο μια κατάτμηση UFS, το σημείο προσάρτησης θα είναι η <span class=filename>/</span>.</p></div><div class=paragraph><p>θα σας ζητηθεί επίσης μια ετικέτα (<em>label</em>). Η ετικέτα είναι ένα όνομα το οποίο δίνεται σε μια κατάτμηση. Το όνομα ενός δίσκου ή οι αριθμοί που περιγράφουν τις κατατμήσεις μπορεί να αλλάξουν αν ο δίσκος συνδεθεί σε άλλη θύρα ή ελεγκτή, αλλά η ετικέτα του παραμένει σταθερή. Με χρήση της ετικέτας σε αρχεία όπως το <span class=filename>/etc/fstab</span> το σύστημα γίνεται πιο ανεκτικό σε αλλαγές του υλικού. Οι ετικέτες GPT εμφανίζονται στον κατάλογο <span class=filename>/dev/gpt/</span> όταν γίνεται η προσάρτηση της συσκευής. Σε άλλα είδη κατατμήσεων υπάρχουν διαφορετικές δυνατότητες όσο αφορά τις ετικέτες, οι οποίες εμφανίζονται σε διαφορετικούς υποκαταλόγους στο <span class=filename>/dev/</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Χρησιμοποιήστε μοναδικές ετικέτες σε κάθε σύστημα αρχείων για να αποφύγετε συγκρούσεις που μπορεί να προκληθούν από όμοια ονόματα. Σε κάθε ετικέτα μπορείτε να συμπεριλάβετε μερικά γράμματα από το όνομα του υπολογιστή ή τη θέση του, ή ακόμα και τη χρήση του. Θα μπορούσατε για παράδειγμα να ονομάσετε τον κεντρικό κατάλογο <code>labroot</code> ή <code>rootfs-lab</code> σε ένα υπολογιστή που ανήκει σε ένα εργαστήριο.</p></div></td></tr></tbody></table></div><div id=bsdinstall-part-manual-splitfs class=exampleblock><div class=title>Παράδειγμα 3. Δημιουργία Παραδοσιακών Κατατμήσεων στο Σύστημα Αρχείων</div><div class=content><div class=paragraph><p>Αν επιθυμείτε να χρησιμοποιήσετε το παραδοσιακό σύστημα κατατμήσεων του FreeBSD όπου τα συστήματα αρχείων <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span> και <span class=filename>/usr</span> βρίσκονται σε χωριστές κατατμήσεις, δημιουργήστε ένα πίνακα κατατμήσεων GPT και ορίστε τις κατατμήσεις με τον τρόπο που φαίνεται παρακάτω. Τα μεγέθη που φαίνονται είναι τυπικά για ένα σκληρό δίσκο χωρητικότητας 20G. Αν διαθέτετε περισσότερο χώρο, ίσως είναι χρήσιμο να μεγαλώσετε την κατάτμηση swap ή <span class=filename>/var</span>. Στο παράδειγμα μας, οι ετικέτες που χρησιμοποιούνται ξεκινούν με <code>ex</code> (από τη λέξη "example") αλλά καλό θα είναι να χρησιμοποιήσετε δικές σας μονάδικες ετικέτες όπως αναφέραμε παραπάνω.</p></div><div class=paragraph><p>Από προεπιλογή, το <span class=filename>gptboot</span> του FreeBSD αναμένει την πρώτη UFS κατάτμηση ως <span class=filename>/</span>.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Τύπος Κατάτμησης</th><th class="tableblock halign-left valign-top">Μέγεθος</th><th class="tableblock halign-left valign-top">Σημείο Προσάρτησης</th><th class="tableblock halign-left valign-top">Ετικέτα</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-boot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>512K</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exrootfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-swap</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>4G</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exswap</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exvarfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>1G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>extmpfs</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>αποδεχθείτε την προεπιλογή (υπόλοιπος χώρος του δίσκου)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exusrfs</code></p></td></tr></tbody></table></div></div><div class=paragraph><p>Μετά τη δημιουργία των προσαρμοσμένων κατατμήσεων, επιλέξτε <b class=button>Finish</b> για να συνεχίσετε με την εγκατάσταση.</p></div></div></div><div class=sect2><h3 id=bsdinstall-final-warning>4.8. Επιβεβαίωση της Εγκατάστασης<a class=anchor href=#bsdinstall-final-warning></a></h3><div class=paragraph><p>Σε αυτό το σημείο έχετε την τελευταία ευκαιρία να εγκαταλείψετε την εγκατάσταση χωρίς να γίνουν αλλαγές στο σκληρό δίσκο σας.</p></div><div id=bsdinstall-final-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-confirmation.png alt="bsdinstall final confirmation"></div><div class=title>Σχήμα 16. Τελική Επιβεβαίωση</div></div><div class=paragraph><p>Επιλέξτε <b class=button>Commit</b> και πιέστε <kbd>Enter</kbd> για να συνεχίσετε. Αν χρειάζεται να κάνετε αλλαγές, επιλέξτε <b class=button>Back</b> για να επιστρέψετε στον επεξεργαστή κατατμήσεων. Με το πλήκτρο <b class=button>Revert & Exit</b> μπορείτε να εγκαταλείψετε το πρόγραμμα εγκατάστασης χωρίς να γίνουν αλλαγές στο σκληρό σας δίσκο.</p></div><div class=paragraph><p>Ο χρόνος εγκατάστασης ποικίλει ανάλογα με τις διανομές και τα στοιχεία εγκατάστασης που έχετε επιλέξει, το μέσο εγκατάστασης και την ταχύτητα του υπολογιστή. Θα δείτε μια σειρά από μηνύματα σχετικά με την πρόοδο της διαδικασίας.</p></div><div class=paragraph><p>Αρχικά, το πρόγραμμα εγκατάστασης θα γράψει τις κατατμήσεις στο δίσκο και θα εκτελέσει κατάλληλες εντολές <code>newfs</code> για να δημιουργήσει τα ανάλογα συστήματα αρχείων.</p></div><div class=paragraph><p>Αν κάνετε εγκατάσταση μέσω δικτύου, το bsdinstall θα προχωρήσει μεταφορτώνοντας τα απαραίτητα αρχεία.</p></div><div id=bsdinstall-distfile-fetching class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-fetching.png alt="bsdinstall distfile fetching"></div><div class=title>Σχήμα 17. Μεταφόρτωση Αρχείων Εγκατάστασης</div></div><div class=paragraph><p>Στη συνέχεια, θα γίνει έλεγχος ακεραιότητας των αρχείων εγκατάστασης για να επιβεβαιωθεί ότι δεν έχουν αλλοιωθεί κατά τη μεταφόρτωση ή κατά την ανάγνωση από το μέσο εγκατάστασης.</p></div><div id=bsdinstall-distfile-verify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-verifying.png alt="bsdinstall distfile verifying"></div><div class=title>Σχήμα 18. Επαλήθευση Αρχείων Εγκατάστασης</div></div><div class=paragraph><p>Στο τελευταίο βήμα, τα επιβεβαιωμένα αρχεία εγκατάστασης θα εξαχθούν και θα γραφούν στο σκληρό δίσκο.</p></div><div id=bsdinstall-distfile-extract class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-extracting.png alt="bsdinstall distfile extracting"></div><div class=title>Σχήμα 19. Εξαγωγή Αρχείων Εγκατάστασης</div></div><div class=paragraph><p>Με το τέλος της εξαγωγής όλων των αρχείων εγκατάστασης, το bsdinstall θα εισέλθει στη διαδικασία ρυθμίσεων μετά την εγκατάσταση (δείτε <a href=#bsdinstall-post>Μετά την Εγκατάσταση</a>).</p></div></div><div class=sect2><h3 id=bsdinstall-post>4.9. Μετά την Εγκατάσταση<a class=anchor href=#bsdinstall-post></a></h3><div class=paragraph><p>Μετά από μια επιτυχημένη εγκατάσταση του FreeBSD, ακολουθεί μια σειρά ρυθμίσεων. Μπορείτε να επαναλάβετε οποιαδήποτε ρύθμιση αν εισέλθετε στην αντίστοιχη επιλογή στο τελικό μενού πριν επανεκκινήσετε στο νέο-εγκατεστημένο σας FreeBSD σύστημα.</p></div><div class=sect3><h4 id=bsdinstall-post-root>4.9.1. Ρύθμιση του Κωδικού του <code>root</code><a class=anchor href=#bsdinstall-post-root></a></h4><div class=paragraph><p>Θα πρέπει να ορίσετε ένα κωδικό πρόσβασης για το χρήστη <code>root</code>. Παρατηρήστε ότι δεν φαίνονται τα γράμματα που πληκτρολογείτε καθώς εισάγετε τον κωδικό. Μετά την εισαγωγή του κωδικού, θα πρέπει να τον εισάγετε ακόμα μια φορά. Με τον τρόπο αυτό εξασφαλίζεται ότι δεν έχει γίνει κάποιο λάθος κατά την πληκτρολόγηση.</p></div><div id=bsdinstall-post-set-root-passwd class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-post-root-passwd.png alt="bsdinstall post root passwd"></div><div class=title>Σχήμα 20. Ρύθμιση του Κωδικού του <code>root</code></div></div><div class=paragraph><p>Η εγκατάσταση συνεχίζεται μετά την επιτυχή εισαγωγή του κωδικού.</p></div></div><div class=sect3><h4 id=bsdinstall-config-network-dev>4.9.2. Ρύθμιση Καρτών Δικτύου<a class=anchor href=#bsdinstall-config-network-dev></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η ρύθμιση του δικτύου παραλείπεται αν έχει ήδη πραγματοποιηθεί στα πλαίσια μιας εγκατάστασης <em>bootonly</em>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Θα δείτε μια λίστα με όλες τις διεπαφές δικτύου που ανιχνεύθηκαν στον υπολογιστή σας. Επιλέξτε αυτή που επιθυμείτε να ρυθμίσετε.</p></div><div id=bsdinstall-configure-net-interface class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface.png alt="bsdinstall configure network interface"></div><div class=title>Σχήμα 21. Επιλογή μιας Διεπαφής Δικτύου</div></div><div class=sect4><h5 id=bsdinstall-configure-net-wireless>4.9.2.1. Ρύθμιση Ασύρματης Κάρτας Δικτύου<a class=anchor href=#bsdinstall-configure-net-wireless></a></h5><div class=paragraph><p>Αν επιλέξετε να ρυθμίσετε μια ασύρματη διεπαφή δικτύου, θα πρέπει να ρυθμίσετε τις παραμέτρους αναγνώρισης και ασφάλειας για να συνδεθείτε στο δίκτυο.</p></div><div class=paragraph><p>Τα ασύρματα δίκτυα αναγνωρίζονται από το Αναγνωριστικό Υπηρεσίας ή Service Set Identifier (SSID). Το SSID είναι ένα σύντομο μοναδικό όνομα που αποδίδεται σε κάθε ασύρματο δίκτυο.</p></div><div class=paragraph><p>Τα περισσότερα ασύρματα δίκτυα κρυπτογραφούν τα δεδομένα που μεταδίδονται για να προστατεύσουν τις πληροφορίες από μη εξουσιοδοτημένη χρήση. Συνίσταται να χρησιμοποιήσετε κρυπτογράφηση WPA2. Παλαιότερες μέθοδοι κρυπτογράφησης όπως το WEP προσφέρουν ελάχιστη ασφάλεια.</p></div><div class=paragraph><p>Το πρώτο βήμα για να συνδεθείτε σε ένα ασύρματο δίκτυο είναι να σαρώσετε για Σημεία Ασύρματης Πρόσβασης (Access Points).</p></div><div id=bsdinstall-wireless-scan class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-scan.png alt="bsdinstall configure wireless scan"></div><div class=title>Σχήμα 22. Σάρωση για Access Points</div></div><div class=paragraph><p>Τα SSIDs που θα βρείτε κατά τη διάρκεια της σάρωσης συνοδεύονται από τα είδη κρυπτογράφησης που διατίθενται για κάθε δίκτυο. Αν δεν βλέπετε το SSID που επιθυμείτε στη λίστα, επιλέξτε <b class=button>Rescan</b> για να εκτελέσετε τη σάρωση ξανά. Αν εξακολουθείτε να μη βλέπετε το επιθυμητό δίκτυο, ελέγξτε την κεραία για τυχόν προβλήματα ή μετακινήστε τον υπολογιστή πιο κοντά στο σημείο πρόσβασης. Να εκτελείτε νέα σάρωση μετά από κάθε αλλαγή.</p></div><div id=bsdinstall-wireless-accesspoints class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-accesspoints.png alt="bsdinstall configure wireless accesspoints"></div><div class=title>Σχήμα 23. Επιλογή Ασύρματου Δικτύου</div></div><div class=paragraph><p>Μετά την επιλογή του ασύρματου δικτύου, θα πρέπει να εισάγετε τις πληροφορίες που σχετίζονται με την κρυπτογράφηση. Σε δίκτυα WPA2 χρειάζεται να δώσετε μόνο ένα κωδικό πρόσβασης (γνωστό ως Pre-Shared Key ή PSK). Για λόγους ασφαλείας, οι χαρακτήρες που πληκτρολογείτε στο πεδίο εμφανίζονται ως αστερίσκοι.</p></div><div id=bsdinstall-wireless-wpa2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-wpa2setup.png alt="bsdinstall configure wireless wpa2setup"></div><div class=title>Σχήμα 24. Ρύθμιση WPA2</div></div><div class=paragraph><p>Μετά την επιλογή του ασύρματου δικτύου και την εισαγωγή των πληροφοριών σύνδεσης, η εγκατάσταση συνεχίζεται με τη ρύθμιση των υπόλοιπων παραμέτρων του δικτύου.</p></div></div><div class=sect4><h5 id=bsdinstall-ipv4>4.9.2.2. Ρύθμιση Δικτύου IPv4<a class=anchor href=#bsdinstall-ipv4></a></h5><div class=paragraph><p>Επιλέξτε αν θα χρησιμοποιηθεί δικτύωση IPv4. Πρόκειται για το πιο συνηθισμένο είδος σύνδεσης.</p></div><div id=bsdinstall-configure-net-ipv4 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4.png alt="bsdinstall configure network interface ipv4"></div><div class=title>Σχήμα 25. Επιλογή Δικτύωσης IPv4</div></div><div class=paragraph><p>Υπάρχουν δύο μέθοδοι ρύθμισης του IPv4. Μέσω του <em>DHCP</em> η ρύθμιση της διεπαφής γίνεται αυτόματα. Αυτή είναι και η συνιστώμενη μέθοδος. Η ρύθμιση <em>Static</em> απαιτεί χειροκίνητη εισαγωγή πληροφοριών δικτύου.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μη βάλετε τυχαίες ρυθμίσεις δικτύου, καθώς δεν θα λειτουργήσουν. Θα πρέπει να λάβετε τις πληροφορίες που αναφέρονται στο <a href=#bsdinstall-collect-network-information>Συλλέξτε Πληροφορίες για το Δίκτυο</a> από τον διαχειριστή ή τον παροχέα του δικτύου σας.</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=bsdinstall-net-ipv4-dhcp-config>4.9.2.2.1. Ρύθμιση Δικτύου IPv4 μέσω DHCP<a class=anchor href=#bsdinstall-net-ipv4-dhcp-config></a></h6><div class=paragraph><p>Αν διαθέτετε εξυπηρετητή DHCP, επιλέξτε <b class=button>Yes</b> για να ρυθμίσετε αυτόματα την διεπαφή δικτύου.</p></div><div id=bsdinstall-net-ipv4-dhcp class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-dhcp.png alt="bsdinstall configure network interface ipv4 dhcp"></div><div class=title>Σχήμα 26. Επιλέξτε Ρύθμιση IPv4 μέσω DHCP</div></div></div><div class=sect5><h6 id=bsdinstall-net-ipv4-static-config>4.9.2.2.2. Στατική Ρύθμιση Δικτύου IPv4<a class=anchor href=#bsdinstall-net-ipv4-static-config></a></h6><div class=paragraph><p>Η στατική ρύθμιση της διεπαφής δικτύου, απαιτεί να εισάγετε κάποιες πληροφορίες σχετικά με το IPv4.</p></div><div id=bsdinstall-net-ipv4-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-static.png alt="bsdinstall configure network interface ipv4 static"></div><div class=title>Σχήμα 27. Στατική Ρύθμιση IPv4</div></div><div class=ulist><ul><li><p><code>IP Address</code> - Η διεύθυνση IP που θα εισάγετε χειροκίνητα σε αυτό τον υπολογιστή. Η διεύθυνση αυτή πρέπει να είναι μοναδική και να μην χρησιμοποιείται από οποιοδήποτε άλλο μηχάνημα στο τοπικό σας δίκτυο.</p></li><li><p><code>Subnet Mask</code> - Η μάσκα υποδικτύου που χρησιμοποιεί το τοπικό σας δίκτυο. Τυπικά αυτή είναι <code>255.255.255.0</code>.</p></li><li><p><code>Default Router</code> - Η διεύθυνση IP του προεπιλεγμένου δρομολογητή του δικτύου σας. Συνήθως είναι η διεύθυνση του δρομολογητή ή άλλου δικτυακού εξοπλισμού που συνδέει το τοπικό σας δίκτυο με το Internet. Θα τη δείτε επίσης να αναφέρετε ως <em>default gateway (προεπιλεγμένη πύλη)</em>.</p></li></ul></div></div></div><div class=sect4><h5 id=bsdinstall-ipv6>4.9.2.3. Ρύθμιση Δικτύου IPv6<a class=anchor href=#bsdinstall-ipv6></a></h5><div class=paragraph><p>Το IPv6 είναι μια νέα μέθοδος ρύθμισης δικτύου. Αν το δίκτυο σας διαθέτει IPv6 και επιθυμείτε να το ρυθμίσετε, πιέστε <b class=button>Yes</b> για να το επιλέξετε.</p></div><div id=bsdinstall-net-ipv6 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6.png alt="bsdinstall configure network interface ipv6"></div><div class=title>Σχήμα 28. Επιλογή Δικτύωσης IPv6</div></div><div class=paragraph><p>Το IPv6 διαθέτει επίσης δύο μεθόδους ρύθμισης. Το <em>SLAAC</em>, ή <em>StateLess Address AutoConfiguration</em>, ρυθμίζει αυτόματα τις παραμέτρους του δικτύου σας. Η ρύθμιση <em>Static</em> απαιτεί να κάνετε τις αντίστοιχες ρυθμίσεις χειροκίνητα.</p></div><div class=sect5><h6 id=bsdinstall-net-ipv6-slaac-config>4.9.2.3.1. IPv6 Stateless Address Autoconfiguration<a class=anchor href=#bsdinstall-net-ipv6-slaac-config></a></h6><div class=paragraph><p>Το SLAAC επιτρέπει σε μια συσκευή ενός δικτύου IPv6 να ζητήσει πληροφορίες αυτόματης ρύθμισης από ένα τοπικό δρομολογητή. Δείτε το <a href=http://tools.ietf.org/html/rfc4862>RFC4862</a> για περισσότερες πληροφορίες.</p></div><div id=bsdinstall-net-ipv6-slaac class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-slaac.png alt="bsdinstall configure network interface slaac"></div><div class=title>Σχήμα 29. Επιλέξτε Ρύθμιση IPv6 SLAAC</div></div></div><div class=sect5><h6 id=bsdinstall-net-ipv6-static-config>4.9.2.3.2. Στατική Ρύθμιση Δικτύου IPv6<a class=anchor href=#bsdinstall-net-ipv6-static-config></a></h6><div class=paragraph><p>Η στατική ρύθμιση της διεπαφής δικτύου στο IPv6, απαιτεί την χειροκίνητη εισαγωγή κάποιων ρυθμίσεων.</p></div><div id=bsdinstall-net-ipv6-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6-static.png alt="bsdinstall configure network interface ipv6 static"></div><div class=title>Σχήμα 30. Στατική Ρύθμιση IPv6</div></div><div class=ulist><ul><li><p><code>IPv6 Address</code> - Η διεύθυνση IP που θα εισάγετε χειροκίνητα σε αυτό τον υπολογιστή. Η διεύθυνση αυτή πρέπει να είναι μοναδική και να μην χρησιμοποιείται από κανένα άλλο μηχάνημα στο τοπικό σας δίκτυο.</p></li><li><p><code>Default Router</code> - Η IPv6 διεύθυνση του προεπιλεγμένου δρομολογητή για το δίκτυο σας. Συνήθως είναι η διεύθυνση του δρομολογητή ή άλλου δικτυακού εξοπλισμού που συνδέει το τοπικό σας δίκτυο με το Internet. Θα τη δείτε επίσης να αναφέρεται ως <em>default gateway (προεπιλεγμένη πύλη)</em>.</p></li></ul></div></div></div><div class=sect4><h5 id=bsdinstall-net-dns>4.9.2.4. Ρύθμιση του DNS<a class=anchor href=#bsdinstall-net-dns></a></h5><div class=paragraph><p>Το <em>Domain Name System (Σύστημα Ονομάτων Τομέα)</em> ή <em>DNS</em> μετατρέπει ονόματα υπολογιστών σε διευθύνσεις δικτύου και το αντίθετο. Αν χρησιμοποιήσατε DHCP ή SLAAC για να ρυθμίσετε αυτόματα τη διεπαφή δικτύου, οι αντίστοιχες ρυθμίσεις πιθανόν να έχουν γίνει ήδη. Στην αντίθετη περίπτωση, βάλτε το όνομα τομέα του τοπικού δικτύου στο πεδίο Search. Τα πεδία DNS #1 και DNS #2 είναι οι διευθύνσεις IP των τοπικών εξυπηρετητών DNS. Χρειάζεται να εισάγετε τουλάχιστον ένα εξυπηρετητή DNS.</p></div><div id=bsdinstall-net-dns-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-ipv4-dns.png alt="bsdinstall configure network ipv4 dns"></div><div class=title>Σχήμα 31. Ρύθμιση DNS</div></div></div></div><div class=sect3><h4 id=bsdinstall-timezone>4.9.3. Ρύθμιση της Ζώνης Ώρας<a class=anchor href=#bsdinstall-timezone></a></h4><div class=paragraph><p>Η ρύθμιση της σωστής ζώνης ώρας στο μηχάνημα σας, εξασφαλίζει την αυτόματη αλλαγή της από χειμερινή σε εαρινή και το αντίστροφο. Επιτρέπει επίσης τη σωστή λειτουργία όλων των υπηρεσιών που σχετίζονται με την τήρηση χρόνου.</p></div><div class=paragraph><p>Το παράδειγμα μας αναφέρεται σε ένα μηχάνημα που βρίσκεται στην Ανατολική ζώνη ώρας των Ηνωμένων Πολιτειών. Η δική σας επιλογή θα είναι διαφορετική ανάλογα με τη γεωγραφική σας περιοχή.</p></div><div id=bsdinstall-local-utc class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-set-clock-local-utc.png alt="bsdinstall set clock local utc"></div><div class=title>Σχήμα 32. Επιλογή Τοπικού ή UTC Ρολογιού</div></div><div class=paragraph><p>Επιλέξτε <b class=button>Yes</b> ή <b class=button>No</b> ανάλογα με το πως είναι ρυθμισμένο το ρολόι του μηχανήματος και πιέστε <kbd>Enter</kbd>. Αν δεν γνωρίζετε αν το σύστημα σας χρησιμοποιεί ώρα UTC ή τοπική, επιλέξτε <b class=button>No</b> για να επιλέξετε την τοπική ώρα που είναι και η πιο συνηθισμένη.</p></div><div id=bsdinstall-timezone-region class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-region.png alt="bsdinstall timezone region"></div><div class=title>Σχήμα 33. Επιλέξτε μια Περιοχή</div></div><div class=paragraph><p>Επιλέξτε την σωστή περιοχή χρησιμοποιώντας τα βελάκια και πιέστε <kbd>Enter</kbd>.</p></div><div id=bsdinstall-timezone-country class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-country.png alt="bsdinstall timezone country"></div><div class=title>Σχήμα 34. Επιλογή Χώρας</div></div><div class=paragraph><p>Επιλέξτε τη σωστή χώρα χρησιμοποιώντας τα βελάκια και πιέστε <kbd>Enter</kbd>.</p></div><div id=bsdinstall-timezone-zone class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-zone.png alt="bsdinstall timezone zone"></div><div class=title>Σχήμα 35. Επιλογή Ζώνης Ώρας</div></div><div class=paragraph><p>Επιλέξτε τη σωστή ζώνη ώρας χρησιμοποιώντας τα βελάκια και πιέστε <kbd>Enter</kbd>.</p></div><div id=bsdinstall-timezone-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-confirm.png alt="bsdinstall timezone confirm"></div><div class=title>Σχήμα 36. Επιβεβαίωση Ζώνης Ώρας</div></div><div class=paragraph><p>Επιβεβαιώστε ότι η συντομογραφία για την επιλεγμένη ζώνη ώρας είναι η σωστή. Έπειτα πιέστε <kbd>Enter</kbd> για να συνεχίσετε με τις υπόλοιπες ρυθμίσεις.</p></div></div><div class=sect3><h4 id=bsdinstall-sysconf>4.9.4. Επιλογή Υπηρεσιών που θα Ενεργοποιηθούν<a class=anchor href=#bsdinstall-sysconf></a></h4><div class=paragraph><p>Μπορείτε να επιλέξετε ποιες από τις πρόσθετες υπηρεσίες θα ενεργοποιηθούν στην εκκίνηση. Όλες οι παρακάτω υπηρεσίες είναι προαιρετικές.</p></div><div id=bsdinstall-config-serv class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-services.png alt="bsdinstall config services"></div><div class=title>Σχήμα 37. Επιλογή Πρόσθετων Υπηρεσιών προς Ενεργοποίηση</div></div><div class=ulist><div class=title>Πρόσθετες Υπηρεσίες</div><ul><li><p><code>sshd</code> - Secure Shell (Ασφαλές Κέλυφος) (SSH) Ο δαίμονας για ασφαλή απομακρυσμένη πρόσβαση.</p></li><li><p><code>moused</code> - Παρέχει δυνατότητα χρήσης του ποντικιού από την κονσόλα του συστήματος.</p></li><li><p><code>ntpd</code> - Network Time Protocol, πρωτόκολλο για ρύθμιση της ώρας μέσω δικτύου (NTP). Ο δαίμονας χρησιμοποιείται για την αυτόματη ρύθμιση του ρολογιού.</p></li><li><p><code>powerd</code> - Βοηθητικό πρόγραμμα για έλεγχο ισχύος και διαχείριση ενέργειας.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-crashdump>4.9.5. Ενεργοποίηση Crash Dumps<a class=anchor href=#bsdinstall-crashdump></a></h4><div class=paragraph><p>Το bsdinstall θα σας ρωτήσει αν θέλετε να ενεργοποιήσετε τα crash dumps στο σύστημα σας. Η ενεργοποίηση των crash dumps μπορεί να είναι πολύ χρήσιμη στον εντοπισμό προβλημάτων του συστήματος και για το λόγο αυτό συνιστούμε να τα ενεργοποιείτε όταν είναι δυνατόν. Επιλέξτε <b class=button>Yes</b> για να τα ενεργοποιήσετε, ή <b class=button>No</b> για να συνεχίσετε χωρίς crash dumps.</p></div><div id=bsdinstall-config-crashdump class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-crashdump.png alt="bsdinstall config crashdump"></div><div class=title>Σχήμα 38. Ενεργοποίηση Crash Dumps</div></div></div><div class=sect3><h4 id=bsdinstall-addusers>4.9.6. Προσθήκη Χρηστών<a class=anchor href=#bsdinstall-addusers></a></h4><div class=paragraph><p>Η προσθήκη τουλάχιστον ενός χρήστη κατά την εγκατάσταση, σας επιτρέπει να χρησιμοποιήσετε το σύστημα χωρίς να εισέλθετε ως <code>root</code>. Όταν εισέρχεστε ως <code>root</code>, δεν υπάρχουν πρακτικά όρια ή κάποιο είδος προστασίας σχετικά με το τι μπορείτε να κάνετε. Όταν εισέρχεστε ως κανονικός χρήστης, μπορείτε να χειριστείτε το σύστημα σας με περισσότερη ασφάλεια.</p></div><div class=paragraph><p>Επιλέξτε <b class=button>Yes</b> για να προσθέσετε νέους χρήστες.</p></div><div id=bsdinstall-add-user1 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser1.png alt="bsdinstall adduser1"></div><div class=title>Σχήμα 39. Προσθήκη Λογαριασμών Χρηστών</div></div><div class=paragraph><p>Εισάγετε τις πληροφορίες για το χρήστη που θα προστεθεί.</p></div><div id=bsdinstall-add-user2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser2.png alt="bsdinstall adduser2"></div><div class=title>Σχήμα 40. Εισαγωγή Πληροφοριών Χρήστη</div></div><div class=ulist><div class=title>Πληροφορίες Χρήστη</div><ul><li><p><code>Username</code> - Το όνομα που θα χρησιμοποιεί ο χρήστης για να εισέλθει στο σύστημα. Τυπικά το πρώτο γράμμα του μικρού ονόματος σε συνδυασμό με το επίθετο.</p></li><li><p><code>Full name</code> - Το πλήρες όνομα του χρήστη.</p></li><li><p><code>Uid</code> - User ID. Ο αναγνωριστικός αριθμός χρήστη. Συνήθως δεν συμπληρώνουμε αυτό το πεδίο, ώστε να επιλεγεί αυτόματα ένας αριθμός από το σύστημα.</p></li><li><p><code>Login group</code> - Η ομάδα στην οποία ανήκει ο χρήστης. Συνήθως το αφήνουμε κενό ώστε να γίνει αποδεκτή η προεπιλεγμένη τιμή.</p></li><li><p><code>Invite user into other groups?</code> - Επιπρόσθετες ομάδες χρηστών στις οποίες θέλουμε να ανήκει ο χρήστης.</p></li><li><p><code>Login class</code> - Συνήθως δεν συμπληρώνουμε αυτό το πεδίο, ώστε να γίνει αποδεκτή η προεπιλεγμένη τιμή.</p></li><li><p><code>Shell</code> - Το κέλυφος που θα χρησιμοποιεί ο συγκεκριμένος χρήστης. Στο παράδειγμα μας επιλέξαμε το <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>.</p></li><li><p><code>Home directory</code> - Ο προσωπικός κατάλογος του χρήστη. Η προεπιλεγμένη τιμή είναι συνήθως η σωστή.</p></li><li><p><code>Home directory permissions</code> - Τα δικαιώματα στον κατάλογο του χρήστη. Τα προεπιλεγμένα είναι συνήθως σωστά.</p></li><li><p><code>Use password-based authentication?</code> - H τυπική απάντηση είναι "yes".</p></li><li><p><code>Use an empty password?</code> - Η τυπική απάντηση είναι "no".</p></li><li><p><code>Use a random password?</code> - Η τυπική απάντηση είναι "no".</p></li><li><p><code>Enter password</code> - Ο κωδικός πρόσβασης για το συγκεκριμένο χρήστη. Δεν φαίνεται στην οθόνη καθώς τον πληκτρολογούμε.</p></li><li><p><code>Enter password again</code> - Ο κωδικός πρέπει να εισαχθεί άλλη μια φορά για επιβεβαίωση.</p></li><li><p><code>Lock out the account after creation?</code> - Η τυπική απάντηση είναι "no".</p></li></ul></div><div class=paragraph><p>Αφού εισάγετε όλες τις πληροφορίες, θα δείτε μια περίληψη τους και το σύστημα θα σας ρωτήσει για την ορθότητα τους. Αν κάνατε κάποιο λάθος κατά τη διάρκεια της εισαγωγής, γράψτε <code>no</code> και ξαναπροσπαθήστε. Αν όλα είναι σωστά, γράψτε <code>yes</code> για να δημιουργήσετε το νέο χρήστη.</p></div><div id=bsdinstall-add-user3 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser3.png alt="bsdinstall adduser3"></div><div class=title>Σχήμα 41. Έξοδος από τη Διαχείριση Χρηστών και Ομάδων</div></div><div class=paragraph><p>Αν θέλετε να προσθέσετε περισσότερους χρήστες, απαντήστε στην ερώτηση "Add another user?" με <code>yes</code>. Απαντήστε <code>no</code> για να τελειώσετε με την προσθήκη χρηστών και να συνεχίσετε την εγκατάσταση.</p></div><div class=paragraph><p>Για περισσότερες πληροφορίες σχετικά με την προσθήκη και διαχείριση χρηστών, δείτε το <a href=./#users>Χρήστες και Βασική Διαχείριση Λογαριασμών</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-final-conf>4.9.7. Τελικές Ρυθμίσεις<a class=anchor href=#bsdinstall-final-conf></a></h4><div class=paragraph><p>Μετά το τέλος της εγκατάστασης και των αρχικών ρυθμίσεων, έχετε μια τελευταία ευκαιρία να αλλάξετε τις ρυθμίσεις πριν την έξοδο από το πρόγραμμα εγκατάστασης.</p></div><div id=bsdinstall-final-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-finalconfiguration.png alt="bsdinstall finalconfiguration"></div><div class=title>Σχήμα 42. Τελικές Ρυθμίσεις</div></div><div class=paragraph><p>Χρησιμοποιήστε αυτό το μενού για να κάνετε οποιεσδήποτε αλλαγές ή πρόσθετες ρυθμίσεις θέλετε πριν την ολοκλήρωση της εγκατάστασης.</p></div><div class=ulist><div class=title>Επιλογές Τελικών Ρυθμίσεων</div><ul><li><p><code>Add User</code> - Περιγράφεται στο <a href=#bsdinstall-addusers>Προσθήκη Χρηστών</a>.</p></li><li><p><code>Root Password</code> - Περιγράφεται στο <a href=#bsdinstall-post-root>Ρύθμιση του Κωδικού του <code>root</code></a>.</p></li><li><p><code>Hostname</code> - Περιγράφεται στο <a href=#bsdinstall-hostname>Καθορισμός Ονόματος Υπολογιστή (hostname)</a>.</p></li><li><p><code>Network</code> - Περιγράφεται στο <a href=#bsdinstall-config-network-dev>Ρύθμιση Καρτών Δικτύου</a>.</p></li><li><p><code>Services</code> - Περιγράφεται στο <a href=#bsdinstall-sysconf>Επιλογή Υπηρεσιών που θα Ενεργοποιηθούν</a>.</p></li><li><p><code>Time Zone</code> - Περιγράφεται στο <a href=#bsdinstall-timezone>Ρύθμιση της Ζώνης Ώρας</a>.</p></li><li><p><code>Handbook</code> - Μεταφόρτωση και εγκατάσταση του Εγχειριδίου του FreeBSD (το οποίο διαβάζετε αυτή τη στιγμή).</p></li></ul></div><div class=paragraph><p>Με την ολοκλήρωση των τελικών ρυθμίσεων, επιλέξτε <b class=button>Exit</b> για να κλείσετε την εγκατάσταση.</p></div><div id=bsdinstall-final-modification-shell class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-modification-shell.png alt="bsdinstall final modification shell"></div><div class=title>Σχήμα 43. Χειροκίνητη Ρύθμιση</div></div><div class=paragraph><p>Το bsdinstall θα σας ρωτήσει για τυχόν επιπλέον ρυθμίσεις που πρέπει να γίνουν πριν επανεκκινήσετε στο νέο σύστημα. Επιλέξτε <b class=button>Yes</b> για να εκκινήσετε ένα κέλυφος στο νέο σύστημα ή <b class=button>No</b> για να προχωρήσετε στο τελευταίο βήμα της εγκατάστασης.</p></div><div id=bsdinstall-final-main class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-mainexit.png alt="bsdinstall mainexit"></div><div class=title>Σχήμα 44. Ολοκλήρωση της Εγκατάστασης</div></div><div class=paragraph><p>Αν χρειάζεται να κάνετε περισσότερες ή ειδικές ρυθμίσεις, μπορείτε να επιλέξετε <b class=button>Live CD</b>. Με την επιλογή αυτή, Θα ξεκινήσετε το μέσο εγκατάστασης σε κατάσταση Live CD.</p></div><div class=paragraph><p>Με την ολοκλήρωση της εγκατάστασης, επιλέξτε <b class=button>Reboot</b> για να επανεκκινήσετε τον υπολογιστή σας και να ξεκινήσετε το νέο FreeBSD σύστημά σας. Μη ξεχάσετε να αφαιρέσετε το μέσο εγκατάστασης από τον οδηγό CD (ή την USB υποδοχή), διαφορετικά το σύστημα σας ίσως ξεκινήσει ξανά από αυτό.</p></div></div><div class=sect3><h4 id=bsdinstall-freebsdboot>4.9.8. Εκκίνηση και Τερματισμός του FreeBSD<a class=anchor href=#bsdinstall-freebsdboot></a></h4><div class=sect4><h5 id=bsdinstall-freebsdboot-i386>4.9.8.1. Εκκίνηση στο FreeBSD/i386<a class=anchor href=#bsdinstall-freebsdboot-i386></a></h5><div class=paragraph><p>Κατά την εκκίνηση του FreeBSD εμφανίζονται πολλά πληροφοριακά μηνύματα. Φυσιολογικά, τα περισσότερα κυλούν εκτός της οθόνης. Μετά το τέλος της εκκίνησης εμφανίζεται η προτροπή εισόδου στο σύστημα (login). Μπορείτε να δείτε τα μηνύματα που κύλησαν εκτός οθόνης πιέζοντας το πλήκτρο <kbd>Scroll-Lock</kbd> για να να ενεργοποιήσετε την <em>προσωρινή μνήμη κύλισης</em>. Χρησιμοποιήστε έπειτα τα πλήκτρα <kbd>PgUp</kbd>, <kbd>PgDn</kbd> και τα βελάκια για να δείτε τα παλιά μηνύματα. Πιέζοντας το <kbd>Scroll-Lock</kbd> ξανά, θα επιστρέψετε στην κανονική απεικόνιση.</p></div><div class=paragraph><p>Στην προτροπή <code>login:</code> γράψτε το όνομα που δημιουργήσατε κατά την εγκατάσταση, στο παράδειγμα μας <code>asample</code>. Να αποφεύγετε να εισέρχεστε ως <code>root</code> όταν δεν είναι απαραίτητο.</p></div><div class=paragraph><p>Η δυνατότητα προς τα πίσω κύλισης των μηνυμάτων που περιγράψαμε προηγουμένως είναι περιορισμένη, επομένως δεν θα μπορέσετε με αυτό τον τρόπο να τα δείτε όλα. Μετά την είσοδο σας στο σύστημα, μπορείτε να δείτε τα μηνύματα από τη γραμμή εντολών γράφοντας <code>dmesg | less</code> στην προτροπή. Πιέστε <kbd>q</kbd> για να επιστρέψετε στη γραμμή εντολών όταν τελειώσετε.</p></div><div class=paragraph><p>Τυπικά μηνύματα εκκίνησης (έχουν παραλειφθεί οι πληροφορίες έκδοσης):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Copyright <span class=o>(</span>c<span class=o>)</span> 1992-2011 The FreeBSD Project.
Copyright <span class=o>(</span>c<span class=o>)</span> 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
        The Regents of the University of California. All rights reserved.
FreeBSD is a registered trademark of The FreeBSD Foundation.

    root@farrell.cse.buffalo.edu:/usr/obj/usr/src/sys/GENERIC amd64
CPU: Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span>2 Duo CPU     E8400  @ 3.00GHz <span class=o>(</span>3007.77-MHz K8-class CPU<span class=o>)</span>
  Origin <span class=o>=</span> <span class=s2>&#34;GenuineIntel&#34;</span>  Id <span class=o>=</span> 0x10676  Family <span class=o>=</span> 6  Model <span class=o>=</span> 17  Stepping <span class=o>=</span> 6
  <span class=nv>Features</span><span class=o>=</span>0x783fbff&lt;FPU,VME,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,CMOV,PAT,PSE36,MMX,FXSR,SSE,SSE2&gt;
  <span class=nv>Features2</span><span class=o>=</span>0x209&lt;SSE3,MON,SSSE3&gt;
  AMD <span class=nv>Features</span><span class=o>=</span>0x20100800&lt;SYSCALL,NX,LM&gt;
  AMD <span class=nv>Features2</span><span class=o>=</span>0x1&lt;LAHF&gt;
real memory  <span class=o>=</span> 536805376 <span class=o>(</span>511 MB<span class=o>)</span>
avail memory <span class=o>=</span> 491819008 <span class=o>(</span>469 MB<span class=o>)</span>
Event timer <span class=s2>&#34;LAPIC&#34;</span> quality 400
ACPI APIC Table: &lt;VBOX   VBOXAPIC&gt;
ioapic0: Changing APIC ID to 1
ioapic0 &lt;Version 1.1&gt; irqs 0-23 on motherboard
kbd1 at kbdmux0
acpi0: &lt;VBOX VBOXXSDT&gt; on motherboard
acpi0: Power Button <span class=o>(</span>fixed<span class=o>)</span>
acpi0: Sleep Button <span class=o>(</span>fixed<span class=o>)</span>
Timecounter <span class=s2>&#34;ACPI-fast&#34;</span> frequency 3579545 Hz quality 900
acpi_timer0: &lt;32-bit timer at 3.579545MHz&gt; port 0x4008-0x400b on acpi0
cpu0: &lt;ACPI CPU&gt; on acpi0
pcib0: &lt;ACPI Host-PCI bridge&gt; port 0xcf8-0xcff on acpi0
pci0: &lt;ACPI PCI bus&gt; on pcib0
isab0: &lt;PCI-ISA bridge&gt; at device 1.0 on pci0
isa0: &lt;ISA bus&gt; on isab0
atapci0: &lt;Intel PIIX4 UDMA33 controller&gt; port 0x1f0-0x1f7,0x3f6,0x170-0x177,0x376,0xd000-0xd00f at device 1.1 on pci0
ata0: &lt;ATA channel 0&gt; on atapci0
ata1: &lt;ATA channel 1&gt; on atapci0
vgapci0: &lt;VGA-compatible display&gt; mem 0xe0000000-0xe0ffffff irq 18 at device 2.0 on pci0
em0: &lt;Intel<span class=o>(</span>R<span class=o>)</span> PRO/1000 Legacy Network Connection 1.0.3&gt; port 0xd010-0xd017 mem 0xf0000000-0xf001ffff irq 19 at device 3.0 on pci0
em0: Ethernet address: 08:00:27:9f:e0:92
pci0: &lt;base peripheral&gt; at device 4.0 <span class=o>(</span>no driver attached<span class=o>)</span>
pcm0: &lt;Intel ICH <span class=o>(</span>82801AA<span class=o>)&gt;</span> port 0xd100-0xd1ff,0xd200-0xd23f irq 21 at device 5.0 on pci0
pcm0: &lt;SigmaTel STAC9700/83/84 AC97 Codec&gt;
ohci0: &lt;OHCI <span class=o>(</span>generic<span class=o>)</span> USB controller&gt; mem 0xf0804000-0xf0804fff irq 22 at device 6.0 on pci0
usbus0: &lt;OHCI <span class=o>(</span>generic<span class=o>)</span> USB controller&gt; on ohci0
pci0: &lt;bridge&gt; at device 7.0 <span class=o>(</span>no driver attached<span class=o>)</span>
acpi_acad0: &lt;AC Adapter&gt; on acpi0
atkbdc0: &lt;Keyboard controller <span class=o>(</span>i8042<span class=o>)&gt;</span> port 0x60,0x64 irq 1 on acpi0
atkbd0: &lt;AT Keyboard&gt; irq 1 on atkbdc0
kbd0 at atkbd0
atkbd0: <span class=o>[</span>GIANT-LOCKED]
psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: <span class=o>[</span>GIANT-LOCKED]
psm0: model IntelliMouse Explorer, device ID 4
attimer0: &lt;AT timer&gt; port 0x40-0x43,0x50-0x53 on acpi0
Timecounter <span class=s2>&#34;i8254&#34;</span> frequency 1193182 Hz quality 0
Event timer <span class=s2>&#34;i8254&#34;</span> frequency 1193182 Hz quality 100
sc0: &lt;System console&gt; at flags 0x100 on isa0
sc0: VGA &lt;16 virtual consoles, <span class=nv>flags</span><span class=o>=</span>0x300&gt;
vga0: &lt;Generic ISA VGA&gt; at port 0x3c0-0x3df iomem 0xa0000-0xbffff on isa0
atrtc0: &lt;AT realtime clock&gt; at port 0x70 irq 8 on isa0
Event timer <span class=s2>&#34;RTC&#34;</span> frequency 32768 Hz quality 0
ppc0: cannot reserve I/O port range
Timecounters tick every 10.000 msec
pcm0: measured ac97 <span class=nb>link </span>rate at 485193 Hz
em0: <span class=nb>link </span>state changed to UP
usbus0: 12Mbps Full Speed USB v1.0
ugen0.1: &lt;Apple&gt; at usbus0
uhub0: &lt;Apple OHCI root HUB, class 9/0, rev 1.00/1.00, addr 1&gt; on usbus0
cd0 at ata1 bus 0 scbus1 target 0 lun 0
cd0: &lt;VBOX CD-ROM 1.0&gt; Removable CD-ROM SCSI-0 device
cd0: 33.300MB/s transfers <span class=o>(</span>UDMA2, ATAPI 12bytes, PIO 65534bytes<span class=o>)</span>
cd0: Attempt to query device size failed: NOT READY, Medium not present
ada0 at ata0 bus 0 scbus0 target 0 lun 0
ada0: &lt;VBOX HARDDISK 1.0&gt; ATA-6 device
ada0: 33.300MB/s transfers <span class=o>(</span>UDMA2, PIO 65536bytes<span class=o>)</span>
ada0: 12546MB <span class=o>(</span>25694208 512 byte sectors: 16H 63S/T 16383C<span class=o>)</span>
ada0: Previously was known as ad0
Timecounter <span class=s2>&#34;TSC&#34;</span> frequency 3007772192 Hz quality 800
Root mount waiting <span class=k>for</span>: usbus0
uhub0: 8 ports with 8 removable, self powered
Trying to mount root from ufs:/dev/ada0p2 <span class=o>[</span>rw]...
Setting hostuuid: 1848d7bf-e6a4-4ed4-b782-bd3f1685d551.
Setting <span class=nb>hostid</span>: 0xa03479b2.
Entropy harvesting: interrupts ethernet point_to_point kickstart.
Starting file system checks:
/dev/ada0p2: FILE SYSTEM CLEAN<span class=p>;</span> SKIPPING CHECKS
/dev/ada0p2: clean, 2620402 free <span class=o>(</span>714 frags, 327461 blocks, 0.0% fragmentation<span class=o>)</span>
Mounting <span class=nb>local </span>file systems:.
vboxguest0 port 0xd020-0xd03f mem 0xf0400000-0xf07fffff,0xf0800000-0xf0803fff irq 20 at device 4.0 on pci0
vboxguest: loaded successfully
Setting <span class=nb>hostname</span>: machine3.example.com.
Starting Network: lo0 em0.
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x3
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
em0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>9b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM&gt;
        ether 08:00:27:9f:e0:92
        nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
        media: Ethernet autoselect <span class=o>(</span>1000baseT &lt;full-duplex&gt;<span class=o>)</span>
        status: active
Starting devd.
Starting Network: usbus0.
DHCPREQUEST on em0 to 255.255.255.255 port 67
DHCPACK from 10.0.2.2
bound to 192.168.1.142 <span class=nt>--</span> renewal <span class=k>in </span>43200 seconds.
add net ::ffff:0.0.0.0: gateway ::1
add net ::0.0.0.0: gateway ::1
add net fe80::: gateway ::1
add net ff02::: gateway ::1
ELF ldconfig path: /lib /usr/lib /usr/lib/compat /usr/local/lib
32-bit compatibility ldconfig path: /usr/lib32
Creating and/or trimming log files.
Starting syslogd.
No core dumps found.
Clearing /tmp <span class=o>(</span>X related<span class=o>)</span><span class=nb>.</span>
Updating motd:.
Configuring syscons: blanktime.
Generating public/private rsa1 key pair.
Your identification has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.
Your public key has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key<span class=s1>&#39;s randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key&#39;</span>s randomart image is:
+--[ DSA 1024]----+
|       ..     <span class=nb>.</span> .|
|      o  <span class=nb>.</span>   <span class=nb>.</span> + |
|     <span class=nb>.</span> ..   <span class=nb>.</span> E .|
|    <span class=nb>.</span> <span class=nb>.</span>  o o <span class=nb>.</span> <span class=nb>.</span> |
|     +  S <span class=o>=</span> <span class=nb>.</span>    |
|    +  <span class=nb>.</span> <span class=o>=</span> o     |
|     +  <span class=nb>.</span> <span class=k>*</span> <span class=nb>.</span>    |
|    <span class=nb>.</span> <span class=nb>.</span>  o <span class=nb>.</span>     |
|      .o. <span class=nb>.</span>      |
+-----------------+
Starting sshd.
Starting cron.
Starting background file system checks <span class=k>in </span>60 seconds.

Thu Oct  6 19:15:31 MDT 2011

FreeBSD/amd64 <span class=o>(</span>machine3.example.com<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>Η δημιουργία των κλειδιών RSA και DSA μπορεί να πάρει κάποιο χρόνο σε αργά μηχανήματα. Γίνεται όμως μόνο στην πρώτη εκκίνηση και μόνο αν έχει ρυθμιστεί το sshd για αυτόματη εκκίνηση. Οι επόμενες εκκινήσεις θα είναι ταχύτερες.</p></div><div class=paragraph><p>Το FreeBSD δεν εγκαθιστά κάποιο γραφικό περιβάλλον από προεπιλογή, αλλά υπάρχουν αρκετά διαθέσιμα προς εγκατάσταση. Δείτε το <a href=./#x11>Το Σύστημα X Window</a> για περισσότερες πληροφορίες.</p></div></div></div><div class=sect3><h4 id=bsdinstall-shutdown>4.9.9. Τερματισμός του FreeBSD<a class=anchor href=#bsdinstall-shutdown></a></h4><div class=paragraph><p>Ο σωστός τερματισμός του FreeBSD εξασφαλίζει τα δεδομένα και το υλικό του υπολογιστή σας από ζημιά. Δεν πρέπει απλώς να διακόψετε την τροφοδοσία. Αν ο χρήστης σας είναι μέλος της ομάδας <code>wheel</code>, μπορείτε να γίνετε υπερχρήστης με την εντολή <code>su</code> και την εισαγωγή του κωδικού του <code>root</code>. Διαφορετικά, συνδεθείτε ως <code>root</code> και χρησιμοποιήστε την εντολή <code>shutdown -p now</code>. Το σύστημα θα τερματίσει με το σωστό τρόπο και θα διακοπεί και η παροχή ρεύματος.</p></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε το συνδυασμό πλήκτρων <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span> για να επανεκκινήσετε το σύστημα, αλλά αυτό δεν συνίσταται κατά τη διάρκεια της κανονικής λειτουργίας.</p></div></div></div><div class=sect2><h3 id=bsdinstall-install-trouble>4.10. Αντιμετώπιση Προβλημάτων<a class=anchor href=#bsdinstall-install-trouble></a></h3><div class=paragraph><p>Η ενότητα που ακολουθεί καλύπτει την αντιμετώπιση βασικών προβλημάτων εγκατάστασης - για παράδειγμα κοινά προβλήματα που έχουν αναφερθεί από πολλούς χρήστες. Υπάρχουν επίσης κάποιες ερωτήσεις και απαντήσεις για όσους επιθυμούν να έχουν το FreeBSD ως dual boot με MS-DOS® ή Windows®.</p></div><div class=sect3><h4 id=_τι_να_κάνετε_αν_κάτι_πάει_στραβά>4.10.1. Τι να Κάνετε αν Κάτι Πάει Στραβά<a class=anchor href=#_τι_να_κάνετε_αν_κάτι_πάει_στραβά></a></h4><div class=paragraph><p>Λόγω των διάφορων περιορισμών στην αρχιτεκτονική του PC, δεν είναι δυνατόν η ανίχνευση συσκευών να είναι 100% αξιόπιστη. Υπάρχουν όμως κάποια πράγματα που μπορείτε να κάνετε αν η ανίχνευση δεν είναι επιτυχής.</p></div><div class=paragraph><p>Ελέγξτε τις <a href=http://www.FreeBSD.org/releases/>Σημειώσεις Υλικού</a> για την έκδοση του FreeBSD που χρησιμοποιείτε, για να βεβαιωθείτε ότι το υλικό σας υποστηρίζεται.</p></div><div class=paragraph><p>Αν το υλικό σας υποστηρίζεται και εξακολουθείτε να έχετε κολλήματα ή άλλα προβλήματα, θα πρέπει να δημιουργήσετε ένα <a href=./#kernelconfig>προσαρμοσμένο πυρήνα</a>. Αυτό θα σας επιτρέψει να προσθέσετε υποστήριξη για συσκευές οι οποίες δεν υπάρχουν στον πυρήνα <span class=filename>GENERIC</span>. Ο πυρήνας στο μέσο εγκατάστασης έχει δημιουργηθεί με την υπόθεση ότι οι περισσότερες συσκευές βρίσκονται στις προεπιλεγμένες ρυθμίσεις τους όσο αφορά τα IRQs, τις διευθύνσεις IO και τα κανάλια DMA. Αν έχετε αλλάξει αυτές τις ρυθμίσεις ίσως χρειαστεί να αλλάξετε τις ρυθμίσεις του πυρήνα και να τον επαναμεταγλωττίσετε για να μπορέσει το FreeBSD να εντοπίσει τις συσκευές σας.</p></div><div class=paragraph><p>Είναι επίσης πιθανό η διαδικασία ανίχνευσης για μια συσκευή που δεν είναι εγκατεστημένη να προκαλέσει πρόβλημα στην ανίχνευση μιας άλλης υπαρκτής συσκευής. Στην περίπτωση αυτή, θα πρέπει να αφαιρέσετε την ανίχνευση για τη συσκευή που δημιουργεί το πρόβλημα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Κάποια προβλήματα εγκατάστασης μπορούν να αποφευχθούν ή να μειωθούν με την αναβάθμιση firmware διάφορων συσκευών υλικού και ειδικότερα της μητρικής. Το firmware της μητρικής είναι συχνά γνωστό με τον όρο BIOS. Οι περισσότεροι κατασκευαστές μητρικών διαθέτουν μια δικτυακή τοποθεσία από όπου μπορείτε να κατεβάσετε αναβαθμισμένες εκδόσεις και ανάλογες πληροφορίες.</p></div><div class=paragraph><p>Οι κατασκευαστές συνήθως συνιστούν να μην αναβαθμίζετε το BIOS της μητρικής αν δεν υπάρχει καλός λόγος, όπως για παράδειγμα μια κρίσιμη ενημέρωση. Η ενημέρωση <em>ενδέχεται να αποτύχει</em> αφήνοντας το BIOS σε μια ενδιάμεση κατάσταση και τον υπολογιστή εκτός λειτουργίας.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_ερωτήσεις_και_απαντήσεις_στην_αντιμετώπιση_προβλημάτων>4.10.2. Ερωτήσεις και Απαντήσεις στην Αντιμετώπιση Προβλημάτων<a class=anchor href=#_ερωτήσεις_και_απαντήσεις_στην_αντιμετώπιση_προβλημάτων></a></h4></div><div class=sect3><h4 id=_το_σύστημα_μου_σταματά_να_ανταποκρίνεται_κατά_την_ανίχνευση_συσκευών_στην_εκκίνηση_ή_συμπεριφέρεται_περίεργα_κατά_την_εγκατάσταση>4.10.3. Το σύστημα μου σταματά να ανταποκρίνεται κατά την ανίχνευση συσκευών στην εκκίνηση ή συμπεριφέρεται περίεργα κατά την εγκατάσταση.<a class=anchor href=#_το_σύστημα_μου_σταματά_να_ανταποκρίνεται_κατά_την_ανίχνευση_συσκευών_στην_εκκίνηση_ή_συμπεριφέρεται_περίεργα_κατά_την_εγκατάσταση></a></h4><div class=paragraph><p>Το FreeBSD κάνει εκτεταμένη χρήση των υπηρεσιών ACPI (εφόσον υπάρχει) στις αρχιτεκτονικές i386, amd64 και ia64 ώστε να ρυθμίσει σωστά τις συσκευές κατά την εκκίνηση. Δυστυχώς υπάρχουν ακόμα κάποια προβλήματα τόσο στο ACPI όσο και στο BIOS firmware αρκετών μητρικών. Μπορείτε να απενεργοποιήσετε το ACPI θέτοντας <code>hint.acpi.0.disabled</code> στο τρίτο στάδιο του φορτωτή εκκίνησης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div><div class=paragraph><p>Καθώς η ρύθμιση αυτή χάνεται σε κάθε εκκίνηση, είναι απαραίτητο να προσθέσετε την οδηγία <code>hint.acpi.0.disabled="1"</code> στο αρχείο <span class=filename>/boot/loader.conf</span>. Μπορείτε να βρείτε περισσότερες πληροφορίες για το φορτωτή εκκίνησης στο <a href=./#boot-synopsis>Σύνοψη</a>.</p></div></div></div><div class=sect2><h3 id=using-live-cd>4.11. Χρησιμοποιώντας τη Λειτουργία Live CD<a class=anchor href=#using-live-cd></a></h3><div class=paragraph><p>Η λειτουργία live CD του FreeBSD διατίθεται στο ίδιο CD με το βασικό πρόγραμμα εγκατάστασης. Είναι χρήσιμη για όσους ακόμα αναρρωτιούνται αν το FreeBSD είναι το κατάλληλο λειτουργικό για αυτούς και θέλουν να δοκιμάσουν κάποια από τα χαρακτηριστικά του πριν το εγκαταστήσουν.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Κατά τη χρήση του live CD να έχετε υπόψη σας τα παρακάτω:</p></div><div class=ulist><ul><li><p>Για να αποκτήσετε πρόσβαση στο σύστημα θα πρέπει να περάσετε από διαδικασία εισόδου. Το όνομα χρήστη είναι <code>root</code> και ο κωδικός είναι κενός.</p></li><li><p>Καθώς το σύστημα εκτελείται απευθείας από το CD, η απόδοση του θα είναι σημαντικά χαμηλότερη σε σχέση με ένα σύστημα εγκατεστημένο σε σκληρό δίσκο.</p></li><li><p>Το live CD παρέχει μόνο γραμμή εντολών και όχι γραφικό περιβάλλον.</p></li></ul></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=basics>Chapter 5. Βασικές Έννοιες στο UNIX®<a class=anchor href=#basics></a></h2><div class=sectionbody><div class=sect2><h3 id=basics-synopsis>5.1. Σύνοψη<a class=anchor href=#basics-synopsis></a></h3><div class=paragraph><p>Το ακόλουθο κεφάλαιο θα καλύψει τις βασικές εντολές και λειτουργίες του λειτουργικού συστήματος FreeBSD. Το μεγαλύτερο μέρος αυτής της ύλης σχετίζεται με όλα τα Λ.Σ. που είναι βασισμένα στο UNIX®. Εάν η ύλη σας φαίνεται οικεία μπορείτε να διατρέξετε γρήγορα αυτό το κεφάλαιο. Εάν - αντιθέτως - είστε νέος στο FreeBSD τότε οπωσδήποτε θα πρέπει να διαβάσετε προσεκτικά ολόκληρο το κεφάλαιο.</p></div><div class=paragraph><p>Μετά την ανάγνωση του κεφαλαίου, θα γνωρίζετε:</p></div><div class=ulist><ul><li><p>Πως να χρησιμοποιείτε τις "εικονικές κονσόλες" του FreeBSD.</p></li><li><p>Πως λειτουργούν οι άδειες αρχείων στο UNIX® και θα καταλάβετε την χρήση των file flags στο FreeBSD.</p></li><li><p>Την προεπιλεγμένη διάταξη του συστήματος αρχείων του FreeBSD.</p></li><li><p>Την οργάνωση των δίσκων στο FreeBSD.</p></li><li><p>Τι είναι και πώς λειτουργεί η προσάρτηση (mount) και αποπροσάρτηση (unmount) συστημάτων αρχείων.</p></li><li><p>Τι είναι οι διεργασίες (processes), τα σήματα (signals) και οι δαίμονες (daemons).</p></li><li><p>Τι είναι το κέλυφος (shell) και πως να αλλάζετε το προεπιλεγμένο περιβάλλον εργασίας.</p></li><li><p>Πως να χρησιμοποιείτε βασικά προγράμματα επεξεργασίας κειμένου (editors).</p></li><li><p>Τι είναι οι συσκευές (devices) και τα αρχεία συσκευής (device nodes).</p></li><li><p>Ποια έκδοση εκτελέσιμων χρησιμοποιείται στο FreeBSD.</p></li><li><p>Πως να διαβάζετε τις σελίδες βοηθείας (manual pages) για περισσότερες πληροφορίες.</p></li></ul></div></div><div class=sect2><h3 id=consoles>5.2. Εικονικές Κονσόλες και Τερματικά<a class=anchor href=#consoles></a></h3><div class=paragraph><p>Μπορείτε να χειριστείτε το FreeBSD με διάφορους τρόπους. Ένας από αυτούς, είναι πληκτρολογώντας εντολές κειμένου σε ένα τερματικό. Με αυτό τον τρόπο έχετε στα χέρια σας ένα ευέλικτο και δυνατό λειτουργικό σύστημα UNIX®. Αυτή η ενότητα περιγράφει τι είναι τα "τερματικά" και οι "κονσόλες" και πως μπορούν να χρησιμοποιηθούν στο FreeBSD.</p></div><div class=sect3><h4 id=consoles-intro>5.2.1. Η Κονσόλα<a class=anchor href=#consoles-intro></a></h4><div class=paragraph><p>Εάν δεν έχετε ρυθμίσει το FreeBSD να ξεκινά αυτόματα κάποιο γραφικό περιβάλλον εργασίας, τότε αμέσως μετά την εκκίνηση του συστήματος και την ολοκλήρωση των σεναρίων εκκίνησης (startup scripts) θα εμφανιστεί η προτροπή σύνδεσης (login prompt). Θα δείτε κάτι παρόμοιο στην οθόνη σας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 <span class=o>(</span>pc3.example.org<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>Το μήνυμα μπορεί να είναι λίγο διαφορετικό στο σύστημα σας, αλλά δεν πρέπει να διαφέρει κατά πολύ. Θα εστιάσουμε την προσοχή μας στις τελευταίες δύο γραμμές. Η προτελευταία γραμμή αναφέρει:</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD/i386 (pc3.example.org) (ttyv0)</pre></div></div><div class=paragraph><p>Αυτή η γραμμή περιέχει μερικές πληροφορίες για το σύστημα που μόλις εκκινήσατε. Έχετε μπροστά σας μια κονσόλα "FreeBSD", που τρέχει με επεξεργαστή αρχιτεκτονικής x86 της Intel ή άλλον συμβατό . Το όνομα αυτής της μηχανής (όλες οι μηχανές UNIX® έχουν κάποιο όνομα) είναι <code>pc3.example.org</code>, και έχετε ανοικτό μπροστά σας το τερματικό <span class=filename>ttyv0</span> - κονσόλα του συστήματος.</p></div><div class=paragraph><p>Ολοκληρώνοντας, η τελευταία γραμμή είναι πάντα:</p></div><div class="literalblock programlisting"><div class=content><pre>login:</pre></div></div><div class=paragraph><p>Σε αυτό το μέρος θα πρέπει να πληκτρολογήσετε το "όνομα χρήστη" (username) για να συνδεθείτε στο FreeBSD. Στην επόμενη ενότητα θα περιγράψουμε ακριβώς αυτήν την διαδικασία.</p></div></div><div class=sect3><h4 id=consoles-login>5.2.2. Εισαγωγή Χρήστη στο Σύστημα FreeBSD<a class=anchor href=#consoles-login></a></h4><div class=paragraph><p>Το FreeBSD είναι ένα σύστημα πολυχρηστικό (multiuser) και πολυεπεξεργαστικό (multiprocessing). Αυτός είναι ο ακαδημαϊκός ορισμός που δίνεται συνήθως σε ένα σύστημα που μπορεί να χρησιμοποιείται από πολλούς διαφορετικούς ανθρώπους, ενώ ταυτόχρονα τρέχουν διαφορετικά προγράμματα στην ίδια μηχανή.</p></div><div class=paragraph><p>Κάθε σύστημα multiuser χρειάζεται κάποιους τρόπους ώστε να ξεχωρίζει κάθε "χρήστη" από τους υπολοίπους. Στο FreeBSD (όπως και σε όλα τα Λ.Σ. που βασίζονται στο UNIX®), αυτό επιτυγχάνεται απαιτώντας κάθε χρήστης να "είναι συνδεδεμένος (log in)" πριν να μπορεί να τρέξει προγράμματα. Κάθε χρήστης έχει ξεχωριστό όνομα (το "όνομα χρήστη ή username") και μία προσωπική δικλείδα ασφαλείας, (τον "κωδικό πρόσβασης ή password"). Αυτά θα ζητηθούν από το FreeBSD σε κάθε χρήστη πριν να του επιτραπεί να τρέξει οποιαδήποτε εφαρμογή.</p></div><div class=paragraph><p>Αμέσως μετά την ολοκλήρωση των διεργασιών εκκίνησης του FreeBSD και των σεναρίων εκκίνησης (startup scripts) , θα εμφανιστεί το σύμβολο της προτροπής (prompt) και θα σας ζητηθεί ένα έγκυρο όνομα χρήστη:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login:</code></pre></div></div><div class=paragraph><p>Για παράδειγμα, ας υποθέσουμε πως το όνομα χρήστη σας είναι <code>john</code>. Πληκτρολογήστε <code>john</code> στην προτροπή και πατήστε <kbd>Enter</kbd>. Θα ακολουθήσει μια νέα προτροπή για να δώσετε τον "κωδικό πρόσβασης (password)":</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login: john
Password:</code></pre></div></div><div class=paragraph><p>Πληκτρολογήστε τώρα τον κωδικό πρόσβασης του <code>john</code>, και πατήστε <kbd>Enter</kbd>. Ο κωδικός πρόσβασης <em>δεν είναι ορατός!</em> Δεν χρειάζεται να ανησυχείτε για αυτό. Είναι επαρκές να πούμε πως αυτό συμβαίνει για λόγους ασφαλείας.</p></div><div class=paragraph><p>Αν έχετε πληκτρολογήσει σωστά τον κωδικό πρόσβασης, τότε έχετε συνδεθεί στο FreeBSD και είστε έτοιμοι να δοκιμάσετε όλες τις διαθέσιμες εντολές UNIX®.</p></div><div class=paragraph><p>Πρέπει να δείτε το MOTD ή αλλιώς το ημερήσιο μήνυμα και στη συνέχεια την προτροπή εντολής (ένα χαρακτήρα <code>#</code>, <code>$</code>, ή <code>%</code>). Αυτό σημαίνει πως έχετε συνδεθεί επιτυχώς στο FreeBSD.</p></div></div><div class=sect3><h4 id=consoles-virtual>5.2.3. Πολλαπλές Κονσόλες<a class=anchor href=#consoles-virtual></a></h4><div class=paragraph><p>Η εκτέλεση εντολών UNIX® σε μία μόνο κονσόλα μπορεί να είναι ικανοποιητική, αλλά το FreeBSD μπορεί να τρέχει ταυτόχρονα πολλά προγράμματα. Η ύπαρξη μίας μόνο κονσόλας για πληκτρολόγηση εντολών θα ήταν πραγματικά ελλιπής για ένα Λ.Σ. όπως το FreeBSD που μπορεί να τρέχει ταυτόχρονα δεκάδες προγράμματα. Εδώ είναι που χρειάζονται οι "εικονικές κονσόλες".</p></div><div class=paragraph><p>Το FreeBSD μπορεί να ρυθμιστεί κατάλληλα ώστε να παρουσιάζεται με διάφορες εικονικές κονσόλες. Η εναλλαγή από μία εικονική κονσόλα σε οποιαδήποτε άλλη μπορεί να γίνει πατώντας μερικά πλήκτρα στο πληκτρολόγιο. Η κάθε κονσόλα έχει το δικό της κανάλι εξόδου, και καθώς εναλλάσσετε εικονικές κονσόλες το FreeBSD αποθηκεύει και επαναφέρει προσεκτικά το αντίστοιχο πληκτρολόγιο και οθόνη για κάθε κονσόλα σαν να υπήρχε πραγματική εναλλαγή.</p></div><div class=paragraph><p>Συνδυασμοί ειδικών πλήκτρων χρησιμοποιούνται από το FreeBSD για την εναλλαγή κονσολών . Μπορείτε να χρησιμοποιήσετε <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span>,έως <span class=keyseq><kbd>Alt</kbd>+<kbd>F8</kbd></span> για να μεταβείτε στις διάφορες εικονικές κονσόλες του FreeBSD.</p></div><div class=paragraph><p>Καθώς εναλλάσσεστε από τη μία κονσόλα στην άλλη, το FreeBSD αποθηκεύει και επαναφέρει προσεκτικά την αντίστοιχη οθόνη. Το αποτέλεσμα είναι ένα "οπτικό τρικ" σαν να είχαμε πολλαπλές "εικονικές" οθόνες και πληκτρολόγια που θα μπορούσαμε να χρησιμοποιήσουμε για να τρέχουμε εντολές στο FreeBSD. Τα προγράμματα που τρέχετε από μια κονσόλα δεν σταματούν να λειτουργούν όταν η κονσόλα δεν είναι ορατή. Συνεχίζουν να τρέχουν κι όταν βρίσκεστε σε διαφορετική κονσόλα.</p></div></div><div class=sect3><h4 id=consoles-ttys>5.2.4. Το Αρχείο <span class=filename>/etc/ttys</span><a class=anchor href=#consoles-ttys></a></h4><div class=paragraph><p>Η εξ' ορισμού ρύθμιση του FreeBSD θα ξεκινήσει με οκτώ εικονικές κονσόλες. Δεν πρόκειται για μια πολύπλοκη ρύθμιση και μπορείτε εύκολα να την αλλάξετε ώστε να φορτώνονται περισσότερες ή λιγότερες εικονικές κονσόλες κατά την εκκίνηση. Το πλήθος και η παραμετροποίηση των εικονικών κονσολών ρυθμίζεται στο αρχείο <span class=filename>/etc/ttys</span>.</p></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε το αρχείο <span class=filename>/etc/ttys</span> για να ρυθμίσετε τις εικονικές κονσόλες στο FreeBSD. Κάθε γραμμή του αρχείου που δεν είναι σχόλιο (οι γραμμές που δεν ξεκινούν με τον χαρακτήρα <code>#</code>) περιέχουν ρυθμίσεις για ένα τερματικό ή για μια εικονική κονσόλα. Η προκαθορισμένη έκδοση του αρχείου, η οποία περιέχεται στην διανομή FreeBSD, περιέχει εννέα εικονικές κονσόλες, εκ των οποίων οι οκτώ είναι ενεργοποιημένες. Είναι στις γραμμές που ξεκινούν με <code>ttyv</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>Για μια λεπτομερή περιγραφή κάθε στήλης του αρχείου και όλων των ρυθμίσεων που μπορούν να εφαρμοστούν για τις εικονικές κονσόλες συμβουλευτείτε την σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>.</p></div></div><div class=sect3><h4 id=consoles-singleuser>5.2.5. Κονσόλα σε Κατάσταση Ενός Χρήστη<a class=anchor href=#consoles-singleuser></a></h4><div class=paragraph><p>Μπορείτε να βρείτε μια λεπτομερή περιγραφή για το τι είναι "κατάσταση ενός χρήστη" στην ενότητα <a href=./#boot-singleuser>Κατάσταση Λειτουργίας Ενός Χρήστη</a>. Αξίζει να αναφέρουμε πως υπάρχει ενεργή μόνο μία κονσόλα όταν τρέχετε το FreeBSD σε κατάσταση ενός χρήστη. Δεν υπάρχουν διαθέσιμες εικονικές κονσόλες. Στο αρχείο <span class=filename>/etc/ttys</span> μπορείτε να βρείτε τις ρυθμίσεις σε κατάσταση ενός χρήστη. Αναζητήστε την γραμμή που ξεκινά με <code>console</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όπως αναφέρουν τα σχόλια πάνω από το <code>console</code>, μπορείτε να επεξεργαστείτε αυτήν τη γραμμή και να αντικαταστήσετε την λέξη <code>secure</code> με <code>insecure</code>. Σε αυτή την περίπτωση κατά την εκκίνηση του FreeBSD σε κατάσταση ενός χρήστη, θα σας ζητηθεί ο κωδικός πρόσβασης του υπερχρήστη <code>root</code>.</p></div><div class=paragraph><p><em>Προσέχετε όταν κάνετε την μετατροπή σε <code>insecure</code></em>. Εάν τύχει να ξεχάσετε τον κωδικό πρόσβασης του <code>root</code>, η πρόσβαση σε κατάσταση λειτουργίας ενός χρήστη μπορεί να γίνει δύσβατη. Υπάρχει ακόμη τρόπος να κάνετε εκκίνηση, αλλά ίσως να είναι δύσκολο για κάποιον που δεν γνωρίζει πολλά για τις διεργασίες και τα προγράμματα εκκίνησης του FreeBSD.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=consoles-vidcontrol>5.2.6. Αλλάζοντας την Ανάλυση (video mode) της Κονσόλας<a class=anchor href=#consoles-vidcontrol></a></h4><div class=paragraph><p>Η προεπιλεγμένη απεικόνιση της κονσόλας στο FreeBSD μπορεί να ρυθμιστεί σε ανάλυση 1024x768, 1280x1024, ή σε οποιοδήποτε άλλο μέγεθος υποστηρίζεται από την κάρτα γραφικών και την οθόνη σας. Για να χρησιμοποιήσετε διαφορετική ανάλυση, θα πρέπει πρώτα από όλα να επαναμεταγλωττίσετε τον πυρήνα σας, και να συμπεριλάβετε τις παρακάτω δύο επιλογές:</p></div><div class="literalblock programlisting"><div class=content><pre>options VESA
options SC_PIXEL_MODE</pre></div></div><div class=paragraph><p>Μετά τη μεταγλώττιση του πυρήνα με τις παραπάνω δύο επιλογές, μπορείτε να βρείτε ποιες αναλύσεις υποστηρίζονται από το υλικό σας, χρησιμοποιώντας το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>. Για να δείτε μια λίστα από τις υποστηριζόμενες αναλύσεις, δώστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol -i mode</span></code></pre></div></div><div class=paragraph><p>Η έξοδος της εντολής αυτής, είναι μια λίστα από αναλύσεις οθόνης που υποστηρίζονται από το υλικό σας. Μπορείτε έπειτα να επιλέξετε μια νέα ανάλυση, δίνοντας την ως όρισμα στην <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> σε μια κονσόλα που έχετε συνδεθεί ως <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol MODE_279</span></code></pre></div></div><div class=paragraph><p>Αν η νέα ανάλυση γίνει δεκτή, μπορείτε να την ορίσετε ως προεπιλεγμένη για κάθε εκκίνηση, με την κατάλληλη ρύθμιση στο αρχείο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;MODE_279&#34;</pre></div></div></div></div><div class=sect2><h3 id=permissions>5.3. Άδειες (Permissions)<a class=anchor href=#permissions></a></h3><div class=paragraph><p>Το FreeBSD είναι απόγονος του BSD UNIX®, και για αυτό το λόγο βασίζεται σε μερικές έννοιες κλειδιά του UNIX®. Η πρώτη και πιο σημαντική είναι πως το FreeBSD είναι ένα πολυχρηστικό (multiuser) λειτουργικό σύστημα. Το σύστημα μπορεί να εξυπηρετήσει πολλούς χρήστες που εργάζονται ταυτόχρονα και σε εντελώς ανεξάρτητες εφαρμογές. Το σύστημα είναι υπεύθυνο για τον σωστό διαμοιρασμό και τις ανάγκες διαχείρισης συσκευών hardware, περιφερειακών, μνήμης, και την σωστή κατανομή των πόρων της CPU για κάθε χρήστη.</p></div><div class=paragraph><p>Επειδή το σύστημα έχει την ικανότητα να εξυπηρετεί πολλούς χρήστες, σε οτιδήποτε διαχειρίζεται, υπάρχει μια ομάδα αδειών που ορίζει ποιος μπορεί να διαβάσει, να γράψει και να εκτελέσει αυτούς τους πόρους. Οι άδειες αποθηκεύονται σε οκτάδες διαχωρισμένες σε τρία μέρη, ένα για τον ιδιοκτήτη του αρχείου, ένα για την ομάδα στην οποία ανήκει το αρχείο, και ένα μέρος για όλους τους άλλους. Στη συνέχεια παρουσιάζεται πίνακας με τις αντιστοιχίες μεταξύ των ομάδων αδειών και των αριθμητικών τους τιμών.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Τιμή</th><th class="tableblock halign-left valign-top">Άδεια</th><th class="tableblock halign-left valign-top">Εμφάνιση σε περιεχόμενα καταλόγων</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:όχι, Εγγραφή:όχι, Εκτέλεση:όχι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>---</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:όχι, Εγγραφή:όχι, Εκτέλεση:ναι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>--x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:όχι, Εγγραφή:ναι, Εκτέλεση:όχι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-w-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:όχι, Εγγραφή:ναι, Εκτέλεση:ναι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-wx</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:ναι, Εγγραφή:όχι, Εκτέλεση:όχι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r--</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:ναι, Εγγραφή:όχι, Εκτέλεση:ναι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r-x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:ναι, Εγγραφή:ναι, Εκτέλεση:όχι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rw-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάγνωση:ναι, Εγγραφή:ναι, Εκτέλεση:ναι</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rwx</code></p></td></tr></tbody></table><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> με πρόθεμα <code>-l</code> στην γραμμή εντολών για να δείτε τα περιεχόμενα καταλόγου και παρατηρήστε πως περιέχεται μια στήλη με τις άδειες των αρχείων για τον ιδιοκτήτη, την ομάδα, και για όλους τους άλλους. Για παράδειγμα, αν δώσουμε <code>ls -l</code> σε ένα τυχαίο κατάλογο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span>
total 530
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 myfile
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 otherfile
<span class=nt>-rw-r--r--</span>  1 root  wheel    7680 Sep  5 12:31 email.txt
...</code></pre></div></div><div class=paragraph><p>Η πρώτη στήλη που παίρνουμε με την εντολή <code>ls -l</code> διαχωρίζεται ως εξής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rw-r--r--</span></code></pre></div></div><div class=paragraph><p>Ο πρώτος χαρακτήρας (από τα αριστερά) μας ενημερώνει αν πρόκειται για ένα κανονικό αρχείο, κατάλογο, ειδική συσκευή χαρακτήρων, υποδοχέα (socket), ή οποιαδήποτε άλλo αρχείο ψευδο-συσκευής. Στην περίπτωση μας, το <code>-</code> υποδηλώνει ένα κανονικό αρχείο. Οι ακόλουθοι τρεις χαρακτήρες, στο παράδειγμα μας, <code>rw-</code>, ορίζουν τις άδειες για τον ιδιοκτήτη του αρχείου. Οι τρεις επόμενοι χαρακτήρες, <code>r--</code>, ορίζουν τις άδειες για την ομάδα στην οποία ανήκει το αρχείο. Οι τελευταίοι τρεις χαρακτήρες, <code>r--</code>, ορίζουν τις άδειες για τον υπόλοιπο κόσμο. Η παύλα σημαίνει πως η άδεια είναι απενεργοποιημένη. Στην περίπτωση του αρχείου μας, οι άδειες έχουν οριστεί ώστε ο ιδιοκτήτης να μπορεί να διαβάζει και να γράφει στο αρχείο, η ομάδα να μπορεί να διαβάσει το αρχείο, και ο υπόλοιπος κόσμος να μπορεί μόνο να διαβάσει το αρχείο. Σύμφωνα με τον παραπάνω πίνακα, οι άδειες για αυτό το αρχείο είναι <code>644</code>, όπου καθένα από τα τρία ψηφία παρουσιάζει το αντίστοιχο μέρος αδειών του αρχείου.</p></div><div class=paragraph><p>Μέχρι εδώ είναι όλα καλά, αλλά όμως πως το σύστημα ελέγχει τις άδειες συσκευών; Το FreeBSD μεταχειρίζεται τις περισσότερες συσκευές σαν ένα αρχείο το οποίο τα προγράμματα μπορούν να ανοίξουν, να διαβάσουν και να γράψουν σε αυτό σαν να ήταν ένα οποιοδήποτε αρχείο. Αυτά τα ειδικά αρχεία συσκευών αποθηκεύονται στον κατάλογο <span class=filename>/dev</span>.</p></div><div class=paragraph><p>Το σύστημα μεταχειρίζεται επίσης και τους καταλόγους ως αρχεία. Έχουν άδειες ανάγνωσης, εγγραφής και εκτέλεσης. Το bit που ορίζει την εκτέλεση στους καταλόγους έχει ελαφρώς διαφορετικό νόημα από ότι στα αρχεία. Όταν ένας κατάλογος έχει οριστεί εκτελέσιμος, σημαίνει πως είναι προσπελάσιμος, δηλαδή είναι επιτρεπτό να περάσουμε σε ένα υποκατάλογο του (να κάνουμε "cd"). Αυτό επίσης σημαίνει πως επιτρέπεται η πρόσβαση σε όλα τα γνωστά (αυτό έχει να κάνει με τις άδειες των ίδιων των αρχείων) αρχεία.</p></div><div class=paragraph><p>Ειδικότερα, για να εμφανίζονται τα περιεχόμενα καταλόγου πρέπει να έχει τεθεί άδεια ανάγνωσης (read) στον κατάλογο, ενώ για να διαγραφεί ένα αρχείο του οποίου γνωρίζετε το όνομα είναι αναγκαίο να έχουν δοθεί οι άδειες εγγραφής (write) <em>και</em> εκτέλεσης (execute) στον κατάλογο που περιέχει το αρχείο.</p></div><div class=paragraph><p>Υπάρχουν κι άλλα bit αδειών, αλλά χρησιμοποιούνται κυρίως σε ειδικές περιπτώσεις όπως σε setuid binaries και sticky directories. Αν θέλετε περισσότερες πληροφορίες για τις άδειες αρχείων και πως να τις ορίζετε, συμβουλευτείτε οπωσδήποτε την σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>.</p></div><div class=sect3><h4 id=_συμβολικές_άδειες>5.3.1. Συμβολικές Άδειες<a class=anchor href=#_συμβολικές_άδειες></a></h4><div class=paragraph><p>Οι συμβολικές άδειες, μερικές φορές αναφέρονται και ως συμβολικές εκφράσεις, χρησιμοποιούν χαρακτήρες στην θέση των οκτώ τιμών για να θέτουν άδειες σε αρχεία ή καταλόγους. Οι συμβολικές εκφράσεις χρησιμοποιούν την σύνταξη (ποιος) (ενέργεια) (άδειες), όπου είναι διαθέσιμες οι ακόλουθες τιμές:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Επιλογή</th><th class="tableblock halign-left valign-top">Γράμμα</th><th class="tableblock halign-left valign-top">Σημαίνει</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(ποιος)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>u</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>User (Χρήστης)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(ποιος)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>g</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Group owner (Ομάδα που ανήκει)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(ποιος)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>o</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Other (Υπόλοιποι χρήστες)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(ποιος)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All (όλοι, "world")</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(ενέργεια)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Πρόσθεση αδειών</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(ενέργεια)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αφαίρεση αδειών</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(ενέργεια)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Άμεσος ορισμός αδειών</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(άδειες)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>r</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Read (Ανάγνωση)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(άδειες)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>w</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Write (Εγγραφή)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(άδειες)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Execute (Εκτέλεση)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(άδειες)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>t</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sticky bit</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(άδειες)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>s</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Set UID ή GID</p></td></tr></tbody></table><div class=paragraph><p>Οι τιμές εισάγονται με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> όπως πριν, αλλά με γράμματα. Για παράδειγμα, θα μπορούσατε να χρησιμοποιήσετε την ακόλουθη εντολή για να απαγορεύσετε σε άλλους χρήστες την πρόσβαση στο <em>FILE</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span><span class=nv>go</span><span class=o>=</span> FILE</code></pre></div></div><div class=paragraph><p>Μπορούν να γίνουν πάνω από μία αλλαγές στις άδειες ενός αρχείου ταυτόχρονα διαχωρίζοντας τις αλλαγές με κόμμα. Για παράδειγμα, η ακόλουθη εντολή θα αφαιρέσει στην ομάδα και στον "υπόλοιπο κόσμο" την άδεια εγγραφής, και στη συνέχεια θα προσθέσει άδεια εκτέλεσης σε όλους.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>go-w,a+x FILE</code></pre></div></div></div><div class=sect3><h4 id=_freebsd_file_flags>5.3.2. FreeBSD File Flags<a class=anchor href=#_freebsd_file_flags></a></h4><div class=paragraph><p>Πέρα από τις άδειες αρχείων που συζητήθηκαν πριν από λίγο, το FreeBSD υποστηρίζει την χρήση των "file flags." Αυτά τα flags προσθέτουν ένα επιπρόσθετο επίπεδο ασφαλείας και ελέγχου σε αρχεία, αλλά όχι σε καταλόγους.</p></div><div class=paragraph><p>Αυτά τα flags προσθέτουν ένα πρόσθετο επίπεδο ελέγχου σε αρχεία, διασφαλίζοντας μας πως σε κάποιες περιπτώσεις ακόμη κι ο <code>root</code> να μην μπορεί να διαγράψει ή να μετατρέψει αρχεία.</p></div><div class=paragraph><p>Η μετατροπή των file flags γίνεται με την <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>, χρησιμοποιώντας μια απλή διασύνδεση. Για παράδειγμα, για να ενεργοποιήσουμε το flag του συστήματος μη διαγραφής αρχείου στο αρχείο <span class=filename>file1</span>, δίνουμε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags sunlink file1</span></code></pre></div></div><div class=paragraph><p>Για να απενεργοποιήσουμε το flag του συστήματος μη διαγραφής αρχείου, απλά δίνουμε την προηγούμενη εντολή με "no" μπροστά από το <code>sunlink</code>. Παρατηρήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags nosunlink file1</span></code></pre></div></div><div class=paragraph><p>Για να δείτε τα flags ενός αρχείου, χρησιμοποιήστε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> με το πρόθεμα <code>-lo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -lo file1</span></code></pre></div></div><div class=paragraph><p>Στην έξοδο θα πρέπει να δείτε κάτι παρόμοιο με το ακόλουθο:</p></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</pre></div></div><div class=paragraph><p>Μερικά flags μπορούν να προστεθούν ή να αφαιρεθούν μόνο από τον χρήστη <code>root</code>. Στις υπόλοιπες περιπτώσεις, ο ιδιοκτήτης του αρχείου μπορεί να θέσει αυτά τα flags. Προτείνουμε στους διαχειριστές να διαβάσουν τις σελίδες βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a> για περισσότερες πληροφορίες.</p></div></div><div class=sect3><h4 id=_οι_άδειες_setuid_setgid_και_sticky>5.3.3. Οι Άδειες setuid, setgid και sticky<a class=anchor href=#_οι_άδειες_setuid_setgid_και_sticky></a></h4><div class=paragraph><p>Εκτός από τις άδειες που έχουμε συζητήσει ήδη, υπάρχουν τρεις ακόμα τις οποίες κάθε διαχειριστής πρέπει να γνωρίζει. Πρόκειται για τις άδειες <code>setuid</code>, <code>setgid</code> και <code>sticky</code>.</p></div><div class=paragraph><p>Οι παραπάνω είναι σημαντικές για κάποιες λειτουργίες στο UNIX®, καθώς παρέχουν λειτουργίες που δεν είναι φυσιολογικά διαθέσιμες στους κοινούς χρήστες. Για να τις κατανοήσετε, θα πρέπει πρώτα να καταλάβετε την διαφορά μεταξύ του πραγματικού αναγνωριστικού χρήστη (real user ID) και του ενεργού αναγνωριστικού χρήστη (effective user ID).</p></div><div class=paragraph><p>Το πραγματικό ID του χρήστη, είναι το UID στο οποίο ανήκει, ή με το οποίο ξεκινά, μια διεργασία. Το ενεργό UID, είναι το αναγνωριστικό χρήστη το οποίο εκτελεί την διεργασία. Για παράδειγμα, το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> εκτελείται με το πραγματικό ID του χρήστη που αλλάζει τον κωδικό του. Ωστόσο, για να μπορεί να διαχειριστεί την βάση δεδομένων με τους κωδικούς του συστήματος, το πρόγραμμα αυτό χρησιμοποιεί ως ενεργό ID αυτό του χρήστη <code>root</code>. Με αυτό τον τρόπο, επιτρέπεται στους απλούς χρήστες να αλλάζουν τους κωδικούς τους χωρίς να παίρνουν το μήνυμα λάθους <code>Permission Denied</code> (απαγόρευση πρόσβασης).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η επιλογή <code>nosuid</code> στην εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> θα προκαλέσει αποτυχία εκτέλεσης αυτών των εντολών, και μάλιστα χωρίς κάποιο μήνυμα λάθους. Με λίγα λόγια, η εκτέλεση τους θα αποτύχει, και ο χρήστης δεν θα ενημερωθεί για αυτό. Η επιλογή αυτή δεν είναι επίσης απόλυτα ασφαλής, καθώς (σύμφωνα με τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>) υπάρχει τρόπος να παρακαμφθεί μέσω κάποιου ενδιάμεσου <code>nosuid</code> προγράμματος (wrapper).</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μπορείτε να καθορίσετε την άδεια setuid, τοποθετώντας τον αριθμό τέσσερα (4) μπροστά από το γενικό σετ των αδειών, όπως φαίνεται στο ακόλουθο παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4755 suidexample.sh</span></code></pre></div></div><div class=paragraph><p>Οι άδειες στο αρχείο <span class=filename>suidexample.sh</span> θα φαίνονται τώρα όπως παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</pre></div></div><div class=paragraph><p>Παρατηρήστε στο παράδειγμα, ότι το <code>s</code> είναι πλέον μέλος του συνόλου αδειών που έχουν καθοριστεί για τον ιδιοκτήτη του αρχείου, και έχει αντικαταστήσει την αντίστοιχη άδεια εκτέλεσης. Με τον τρόπο αυτό λειτουργούν προγράμματα που χρειάζονται αυξημένα δικαιώματα, όπως για παράδειγμα η εντολή <code>passwd</code>.</p></div><div class=paragraph><p>Για να παρατηρήσετε αυτή τη λειτουργία την ώρα που συμβαίνει, ανοίξτε δύο τερματικά. Στο πρώτο, ξεκινήστε την εντολή <code>passwd</code> ως κανονικός χρήστης. Καθώς η εντολή εκτελείται και περιμένει για την εισαγωγή του νέου κωδικού, ελέγξτε τον πίνακα διεργασιών και αναζητήστε τις πληροφορίες του χρήστη που εκτελεί την εντολή <code>passwd</code>.</p></div><div class=paragraph><p>Στο τερματικό Α:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:</code></pre></div></div><div class=paragraph><p>Στο τερματικό Β:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps aux | grep passwd</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 <span class=nb>grep </span>passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</code></pre></div></div><div class=paragraph><p>Όπως είπαμε παραπάνω, η εντολή <code>passwd</code> εκτελείται από ένα κανονικό χρήστη, αλλά χρησιμοποιεί το ενεργό UID του χρήστη <code>root</code>.</p></div><div class=paragraph><p>Η άδεια <code>setgid</code> εκτελεί την ίδια λειτουργία όπως και η <code>setuid</code>, αλλά επιδρά στις άδειες της ομάδας (group). Όταν εκτελέσετε μια τέτοια εφαρμογή ή βοηθητικό πρόγραμμα, θα χρησιμοποιεί τις άδειες της ομάδας στην οποία ανήκει το αρχείο, και όχι του χρήστη που την ξεκίνησε.</p></div><div class=paragraph><p>Για να θέσετε την άδεια <code>setgid</code> σε ένα αρχείο, θα πρέπει να τοποθετήσετε τον αριθμό δύο (2) μπροστά από το σύνολο αδειών, στην εντολή <code>chmod</code>. Δείτε το παρακάτω παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 2755 sgidexample.sh</span></code></pre></div></div><div class=paragraph><p>Όπως και πριν, θα παρατηρήσετε τη νέα άδεια <code>s</code>, αλλά αυτή τη φορά στο σετ των αδειών της ομάδας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rwxr-sr-x</span>   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Στα παραδείγματα μας, αν και το αρχείο είναι ένα εκτελέσιμο script για κέλυφος, δεν θα εκτελεστεί με διαφορετικό ενεργό ID (EUID). Αυτό συμβαίνει γιατί σε αυτά τα scripts δεν επιτρέπεται η πρόσβαση στις κλήσεις <a href="https://man.freebsd.org/cgi/man.cgi?query=setuid&amp;sektion=2&amp;format=html">setuid(2)</a> του συστήματος.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Οι δύο πρώτες ειδικές άδειες που αναφέραμε, οι <code>setuid</code> και <code>setgid</code>, ενδεχομένως να μειώσουν την ασφάλεια του συστήματος, αφού επιτρέπουν σε προγράμματα να εκτελούνται με αυξημένα δικαιώματα. Υπάρχει ωστόσο μια τρίτη ειδική άδεια, η οποία μπορεί να αυξήσει την ασφάλεια του συστήματος: το <code>sticky bit</code>.</p></div><div class=paragraph><p>Όταν θέσετε το <code>sticky bit</code> σε ένα κατάλογο, επιτρέπεται η διαγραφή ενός αρχείου μόνο από τον ιδιοκτήτη του. Η άδεια αυτή είναι χρήσιμη για να αποφεύγεται η διαγραφή ενός αρχείου από κοινόχρηστους καταλόγους, όπως για παράδειγμα ο <span class=filename>/tmp</span>, από κάποιο χρήστη που δεν είναι ο ιδιοκτήτης του. Για να θέσετε αυτή την άδεια, τοποθετήστε τον αριθμό ένα (1) στην αρχή του σετ αδειών:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 1777 /tmp</span></code></pre></div></div><div class=paragraph><p>Μπορείτε τώρα να δείτε το αποτέλεσμα, χρησιμοποιώντας την εντολή <code>ls</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al / | grep tmp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</code></pre></div></div><div class=paragraph><p>Η άδεια <code>sticky bit</code> φαίνεται ως <code>t</code> στο τέλος του συνόλου των αδειών.</p></div></div></div><div class=sect2><h3 id=dirstructure>5.4. Δομή Καταλόγου<a class=anchor href=#dirstructure></a></h3><div class=paragraph><p>Η ιεραρχική δομή του FreeBSD είναι ένα βασικό στοιχείο που πρέπει να γνωρίζετε αν θέλετε να έχετε μια ολοκληρωμένη εικόνα του συστήματος. Η πιο σημαντική έννοια είναι αυτή του ριζικού (root) καταλόγου, "/". Αυτός ο κατάλογος προσαρτάται (mount) πρώτος κατά την εκκίνηση και περιέχει το βασικό σύστημα ικανό να ετοιμάσει το Λ.Σ. για λειτουργία multi-user. Ο root κατάλογος περιέχει επίσης σημεία προσάρτησης για άλλα συστήματα αρχείων που προσαρτώνται κατά την μετάβαση σε κατάσταση λειτουργίας multi-user.</p></div><div class=paragraph><p>Σημείο προσάρτησης (mount point) είναι ένας κατάλογος στον οποίο μπορούν να αναπτυχθούν πρόσθετα συστήματα αρχείων σε ένα γονικό σύστημα αρχείων (συνήθως στο root σύστημα αρχείων). Αυτό περιγράφεται αναλυτικά στην ενότητα <a href=#disk-organization>Οργάνωση Δίσκου</a>. Στα στάνταρντ σημεία προσάρτησης περιλαμβάνονται: οι <span class=filename>/usr</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span>, <span class=filename>/mnt</span>, και <span class=filename>/cdrom</span>. Αυτοί οι κατάλογοι συνήθως είναι καταχωρημένοι στο αρχείο <span class=filename>/etc/fstab</span>. Το <span class=filename>/etc/fstab</span> είναι ένας πίνακας αντιστοιχίας διαφόρων συστημάτων αρχείων και σημείων προσάρτησης για αναφορά στο σύστημα. Τα περισσότερα συστήματα που αναφέρονται στο <span class=filename>/etc/fstab</span> προσαρτώνται αυτόματα κατά την εκκίνηση του συστήματος από το script <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> εκτός αν περιέχεται η επιλογή <code>noauto</code>. Λεπτομέρειες μπορείτε να βρείτε στο <a href=#disks-fstab>Το Αρχείο <span class=filename>fstab</span></a>.</p></div><div class=paragraph><p>Μια πλήρη περιγραφή της ιεραρχίας του συστήματος αρχείων είναι διαθέσιμη στο <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a>. Ακολουθεί μια σύντομη ανασκόπηση με τους πιο συνήθεις καταλόγους.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Κατάλογος</th><th class="tableblock halign-left valign-top">Περιγραφή</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ριζικός (root) κατάλογος του συστήματος αρχείων.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Χρήσιμα εργαλεία για περιβάλλον ενός ή πολλαπλών χρηστών.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προγράμματα και αρχεία ρυθμίσεων που χρησιμοποιούνται κατά την εκκίνηση του λειτουργικού συστήματος.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προκαθορισμένα αρχεία ρυθμίσεων εκκίνησης, δείτε <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία συσκευών, δείτε <a href="https://man.freebsd.org/cgi/man.cgi?query=intro&amp;sektion=4&amp;format=html">intro(4)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία ρυθμίσεων συστήματος και σενάρια εκκίνησης.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προκαθορισμένα αρχεία ρυθμίσεων συστήματος, δείτε την <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία ρυθμίσεων για πράκτορες μεταφοράς ηλεκτρ. ταχυδρομείου (ΜΤΑ) όπως το <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία ρυθμίσεων <code>named</code>, δείτε <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/periodic/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Σενάρια λειτουργιών που τρέχουν σε ημερήσια, εβδομαδιαία, και μηνιαία βάση, <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>; δείτε <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία ρυθμίσεων <code>ppp</code>, δείτε τις <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/mnt/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Κενός κατάλογος που συνήθως χρησιμοποιείται από τους διαχειριστές συστημάτων ως προσωρινό σημείο προσάρτησης.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/proc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Σύστημα αρχείων διεργασιών, δείτε τις <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προγράμματα με στατική σύνδεση (static link) για ασφαλή επαναφορά συστήματος, δείτε την <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/root/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προσωπικός κατάλογος του χρήστη <code>root</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προγράμματα συστήματος και χρήσιμα εργαλεία διαχείρισης για περιβάλλον ενός ή πολλαπλών χρηστών.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προσωρινά αρχεία. Τα περιεχόμενα του <span class=filename>/tmp</span> συνήθως δεν διατηρούνται μετά από επανεκκίνηση του συστήματος. Στο <span class=filename>/tmp</span> συνήθως προσαρτάται ένα σύστημα αρχείων μνήμης. Αυτό μπορεί να επιτευχθεί αυτομάτως χρησιμοποιώντας τις σχετικές μεταβλητές tmpmfs του <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> (ή με μια καταχώρηση στον <span class=filename>/etc/fstab</span>, δείτε την <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Περιέχονται σχεδόν όλα τα βοηθητικά προγράμματα και οι εφαρμογές χρηστών.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Κοινόχρηστα βοηθητικά προγράμματα, εργαλεία προγραμματισμού, και εφαρμογές.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Στάνταρ αρχεία συμπερίληψης C (include files).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία βιβλιοθηκών.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libdata/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Διάφορα αρχεία δεδομένων βοηθητικών προγραμμάτων.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δαίμονες συστήματος & βοηθητικά προγράμματα συστήματος (εκτελούνται από άλλα προγράμματα).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τοπικά εκτελέσιμα, βιβλιοθήκες, κτλ. Επίσης είναι και ο προκαθορισμένος προορισμός για προγράμματα που εγκαθίστανται από τα ports του FreeBSD. Μέσα στον <span class=filename>/usr/local</span>, χρησιμοποιείται γενικά η διάταξη του <span class=filename>/usr</span> που περιγράφεται στο <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a>. Εξαιρούνται οι κατάλογοι σελίδων βοηθείας man, που βρίσκεται άμεσα κάτω από τον <span class=filename>/usr/local</span> και όχι κάτω από τον <span class=filename>/usr/local/share</span>, καθώς και η τεκμηρίωση κάθε port που βρίσκεται στον <span class=filename>share/doc/port</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/obj/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δέντρο προορισμού που εξαρτάται από την αρχιτεκτονική του μηχανήματος και παράγεται μεταγλωττίζοντας το δέντρο <span class=filename>/usr/src</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η Συλλογή Ports του FreeBSD (προαιρετικό).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δαίμονες συστήματος & βοηθητικά προγράμματα συστήματος (εκτελούνται από χρήστες).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/shared/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία ανεξάρτητα από την Αρχιτεκτονική του μηχανήματος.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία BSD και/ή τοπικά αρχεία πηγαίου κώδικα.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/X11R6/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Εκτελέσιμα, βιβλιοθήκες, κτλ. για την διανομή X11R6 (προαιρετικό).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία αναφοράς (log) διαφόρων χρήσεων, temporary, transient, και spool. Μερικές φορές προσαρτάται στον <span class=filename>/var</span> ένα σύστημα αρχείων μνήμης. Αυτό μπορεί να επιτευχθεί αυτόματα χρησιμοποιώντας τις σχετικές μεταβλητές varmfs του <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> (ή με μία καταχώρηση στο <span class=filename>/etc/fstab</span>, δείτε τις <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/log/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Διάφορα αρχεία συμβάντων του συστήματος.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχεία γραμματοκιβωτίου (mailbox) χρηστών.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/spool/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Διάφοροι κατάλογοι παροχέτευσης (spool) εκτυπωτών και ηλεκτρονικής αλληλογραφίας του συστήματος.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προσωρινά (temporary) αρχεία. Τα αρχεία αυτά συνήθως διατηρούνται κατά την διάρκεια επανεκκίνησης του συστήματος, εκτός αν ο <span class=filename>/var</span> είναι ένα σύστημα αρχείων μνήμης.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/yp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Απεικονίσεις (maps) NIS.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disk-organization>5.5. Οργάνωση Δίσκου<a class=anchor href=#disk-organization></a></h3><div class=paragraph><p>Η μικρότερη μονάδα οργάνωσης που χρησιμοποιεί το FreeBSD για να βρει αρχεία είναι το όνομα αρχείου. Τα ονόματα αρχείων είναι ευαίσθητα στα κεφαλαία- μικρά, το οποίο σημαίνει ότι το <span class=filename>readme.txt</span> και το <span class=filename>README.TXT</span> είναι δύο διαφορετικά αρχεία. Το FreeBSD δεν χρησιμοποιεί την επέκταση <span class=filename>.txt</span> αρχείου για να προσδιορίσει αν ένα αρχείο είναι πρόγραμμα, ή έγγραφο, ή άλλος τύπος δεδομένων.</p></div><div class=paragraph><p>Τα αρχεία αποθηκεύονται σε καταλόγους. Ένας κατάλογος μπορεί να μην περιέχει αρχεία, ή μπορεί να περιέχει εκατοντάδες αρχεία. Ένας κατάλογος μπορεί επίσης να περιέχει άλλους καταλόγους, επιτρέποντας σας να κατασκευάσετε μια ιεραρχική δομή καταλόγων όπου κατάλογοι εσωκλείουν άλλους καταλόγους. Αυτό μας επιτρέπει να οργανώσουμε τα δεδομένα μας πολύ ευκολότερα.</p></div><div class=paragraph><p>Η αναφορά σε αρχεία και καταλόγους γίνεται δίνοντας το όνομα αρχείου ή το όνομα καταλόγου, ακολουθεί μία αριστερόστροφη κάθετος, <code>/</code> και έπειτα οποιοδήποτε άλλο κατάλληλο όνομα καταλόγου. Εάν έχετε τον κατάλογο <span class=filename>foo</span>, ο οποίος περιέχει τον κατάλογο <span class=filename>bar</span>, ο οποίος περιέχει το αρχείο <span class=filename>readme.txt</span>, τότε το ολοκληρωμένο όνομα, <em>διαδρομή (path)</em> στο αρχείο είναι <span class=filename>foo/bar/readme.txt</span>.</p></div><div class=paragraph><p>Κατάλογοι και αρχεία αποθηκεύονται σε ένα σύστημα αρχείων. Κάθε σύστημα αρχείων περιέχει ένα κατάλογο στο ανώτερο επίπεδο, που ονομάζεται <em>root (ριζικός) κατάλογος</em> για το συγκεκριμένο σύστημα αρχείων. Ο root κατάλογος μπορεί να περιέχει άλλους καταλόγους.</p></div><div class=paragraph><p>Αυτό πιθανώς είναι παρόμοιο με οποιοδήποτε άλλο λειτουργικό σύστημα έχετε χρησιμοποιήσει. Ωστόσο υπάρχουν μερικές διαφορές. Για παράδειγμα, το MS-DOS® χρησιμοποιεί <code>\</code> για να διαχωρίζει ονόματα καταλόγων και αρχείων, ενώ το Mac OS® χρησιμοποιεί <code>:</code>.</p></div><div class=paragraph><p>Το FreeBSD δεν χρησιμοποιεί γράμματα οδηγών ή ονόματα οδηγών στη διαδρομή. Επομένως δεν θα πρέπει να γράφετε <span class=filename>c:/foo/bar/readme.txt</span> στο FreeBSD.</p></div><div class=paragraph><p>Αντιθέτως, ένα σύστημα αρχείων καθορίζεται ως root σύστημα αρχείων. Ο ριζικός κατάλογος του root συστήματος αρχείων αναφέρεται ως <code>/</code>. Κάθε άλλο σύστημα αρχείου <em>προσαρτάται</em> κάτω από το root σύστημα αρχείων Δεν έχει σημασία πόσους δίσκους έχετε στο FreeBSD σύστημα σας, κάθε κατάλογος εμφανίζεται να είναι μέρος του ίδιου δίσκου.</p></div><div class=paragraph><p>Ας υποθέσουμε πως έχετε τρία συστήματα αρχείων, τα ονομάζουμε <code>A</code>, <code>B</code> και <code>C</code>. Κάθε σύστημα αρχείου έχει έναν ριζικό κατάλογο, ο οποίος περιέχει δύο άλλους καταλόγους, που τους ονομάζουμε <code>A1</code>, <code>A2</code> (και παρομοίως <code>B1</code>, <code>B2</code> και <code>C1</code>, <code>C2</code>).</p></div><div class=paragraph><p>Ας θεωρήσουμε ότι το <code>A</code> είναι το root σύστημα αρχείων. Αν χρησιμοποιήσετε την εντολή <code>ls</code> για να δείτε τα περιεχόμενα αυτού του καταλόγου, θα δείτε δύο υποκαταλόγους, <code>A1</code> και <code>A2</code>. Το δέντρο του καταλόγου μοιάζει σαν αυτό:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir1.png alt="example dir1"></div></div><div class=paragraph><p>Κάθε σύστημα αρχείων πρέπει να προσαρτάται σε ένα κατάλογο διαφορετικού συστήματος αρχείων. Ας υποθέσουμε πως θέλετε να προσαρτήσετε το σύστημα αρχείου <code>B</code> στον <code>κατάλογο A1</code>. Ο ριζικός κατάλογος του <code>B</code> αντικαθιστά τον <code>A1</code>, και οι κατάλογοι του <code>B</code> εμφανίζονται αναλόγως:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir2.png alt="example dir2"></div></div><div class=paragraph><p>Όλα τα αρχεία που περιέχονται στους καταλόγους <code>B1</code> και <code>B2</code> τα βρίσκουμε με τη διαδρομή <span class=filename>/A1/B1</span> ή με <span class=filename>/A1/B2</span> αντίστοιχα. Όλα τα αρχεία που βρίσκονταν στο <span class=filename>/A1</span> είναι προσωρινά κρυμμένα. Θα επανεμφανιστούν όταν ο <code>B</code> θα <em>αποπροσαρτηθεί</em> από τον A.</p></div><div class=paragraph><p>Αν ο <code>B</code> είχε προσαρτηθεί στον <code>A2</code> τότε το διάγραμμα θα έδειχνε κάπως έτσι:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir3.png alt="example dir3"></div></div><div class=paragraph><p>και οι διαδρομές θα ήταν <span class=filename>/A2/B1</span> και <span class=filename>/A2/B2</span> αντίστοιχα.</p></div><div class=paragraph><p>Τα συστήματα αρχείων μπορούν να προσαρτώνται στην κορυφή άλλων συστημάτων. Συνεχίζοντας το τελευταίο παράδειγμα, το σύστημα αρχείου <code>C</code> θα μπορούσε να προσαρτηθεί στην κορυφή του καταλόγου <code>B1</code> στο σύστημα αρχείου <code>B</code>, οδηγώντας σε αυτήν την κατανομή:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir4.png alt="example dir4"></div></div><div class=paragraph><p>Ή ακόμη το <code>C</code> θα μπορούσε να προσαρτηθεί άμεσα στο σύστημα αρχείου <code>A</code>, κάτω από τον κατάλογο <code>A1</code>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir5.png alt="example dir5"></div></div><div class=paragraph><p>Αν γνωρίζετε το σύστημα MS-DOS®, είναι παρόμοιο, αλλά όχι ακριβώς το ίδιο, με την εντολή <code>join</code>.</p></div><div class=paragraph><p>Αυτό συνήθως δεν είναι κάτι που πρέπει να γνωρίζετε άμεσα. Τυπικά, εσείς δημιουργείτε συστήματα αρχείων όταν εγκαθιστάτε το FreeBSD και αποφασίζετε το σημείο προσάρτησης αυτών, και έπειτα δεν χρειάζεται να τα αλλάξετε εκτός αν πρόκειται να προσθέσετε ένα καινούργιο δίσκο.</p></div><div class=paragraph><p>Είναι απόλυτα δυνατόν να έχετε ένα μεγάλο root σύστημα αρχείων, και να μην χρειάζεται να δημιουργήσετε άλλα. Με αυτή την τακτική υπάρχουν μερικά μειονεκτήματα και ένα πλεονέκτημα.</p></div><div class=ulist><div class=title>Προτερήματα Πολλαπλών Συστημάτων Αρχείων</div><ul><li><p>Διαφορετικά συστήματα αρχείων μπορούν να έχουν διαφορετικές <em>επιλογές προσάρτησης</em>. Για παράδειγμα, με προσεκτικό σχεδιασμό, το root σύστημα αρχείων μπορεί να προσαρτηθεί μόνο για ανάγνωση, ώστε να είναι αδύνατη η διαγραφή ή η μετατροπή κάποιου σημαντικού αρχείου. Διαχωρίζοντας συστήματα αρχείων με δυνατότητα εγγραφής από τον χρήστη, όπως ο <span class=filename>/home</span>, επιτρέπει επίσης την προσάρτηση τους ως <em>nosuid</em>. Αυτή η επιλογή περιορίζει την χρήση εκτελέσιμων που είναι αποθηκευμένα στο σύστημα αρχείων, με ενεργοποιημένα τα bits <em>suid</em>/<em>guid</em>, βελτιώνοντας πιθανώς την ασφάλεια.</p></li><li><p>Ανάλογα με το πως θα χρησιμοποιηθεί το σύστημα αρχείων, το FreeBSD ρυθμίζει με τον καλύτερο τρόπο την διάταξη των αρχείων στο σύστημα. Επομένως ένα σύστημα που περιέχει πολλά μικρά αρχεία που μεταβάλλονται συχνά, θα έχει διαφορετική διάταξη από ένα άλλο που περιέχει λιγότερα σε αριθμό, αλλά πιο ογκώδη αρχεία. Εάν έχετε ένα μοναδικό σύστημα αρχείων, τότε χάνετε αυτή τη δυνατότητα.</p></li><li><p>Τα συστήματα αρχείων του FreeBSD είναι πολύ ισχυρά. Ωστόσο, μια αδυναμία σε κάποιο σημαντικό σημείο μπορεί ακόμη να οδηγήσει σε κατάρρευση της δομής του συστήματος αρχείων. Ο διαχωρισμός των δεδομένων σας σε πολλαπλά συστήματα αρχείων κάνει πιο εύκολη μια πιθανή επαναφορά από backup, όταν αυτό είναι αναγκαίο.</p></li></ul></div><div class=ulist><div class=title>Προτερήματα ενός Μονοκόμματου Συστήματος Αρχείου</div><ul><li><p>Τα συστήματα αρχείων είναι συγκεκριμένου σταθερού μεγέθους. Αν δημιουργήσετε ένα σύστημα αρχείων κατά την εγκατάσταση του FreeBSD και του δώσετε ένα ορισμένο μέγεθος, μπορεί αργότερα να ανακαλύψετε πως χρειάζεστε να φτιάξετε μια μεγαλύτερη κατάτμηση. Αυτό δεν είναι εύκολα πραγματοποιήσιμο δίχως backup, αναδημιουργία του συστήματος αρχείου με το νέο μέγεθος, και επαναφορά των αποθηκευμένων δεδομένων.</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Στο FreeBSD περιέχεται η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a>, η οποία επιτρέπει να αυξήσουμε το μέγεθος ενός συστήματος αρχείων κατά τη λειτουργία του, αφαιρώντας αυτόν τον περιορισμό.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Τα συστήματα αρχείων περιέχονται σε κατατμήσεις (partitions). Αυτό δεν έχει την ίδια έννοια με την κοινή χρήση του όρου κατάτμηση (όπως για παράδειγμα, η κατάτμηση του MS-DOS®), λόγω της κληρονομιάς που φέρει το FreeBSD από το UNIX®. Κάθε κατάτμηση αναγνωρίζεται από ένα λατινικό χαρακτήρα ξεκινώντας από <code>a</code> έως το <code>h</code>. Κάθε κατάτμηση μπορεί να περιέχει μόνο ένα σύστημα αρχείων, το οποίο σημαίνει πως η αναφορά στα συστήματα αρχείων γίνεται είτε από το τυπικό σημείο προσάρτησης στην ιεραρχία του συστήματος αρχείων, είτε από το λατινικό χαρακτήρα της κατάτμησης.</p></div><div class=paragraph><p>Επίσης το FreeBSD χρησιμοποιεί μέρος από το δίσκο για <em>χώρο swap</em>. Ο χώρος Swap παρέχει στο FreeBSD <em>εικονική μνήμη (virtual memory)</em>. Αυτό επιτρέπει στον υπολογιστή σας να συμπεριφέρεται σαν να είχε πολύ περισσότερη μνήμη από όσο πραγματικά έχει. Όταν το FreeBSD δεν έχει διαθέσιμη μνήμη μεταφέρει μερικά από τα δεδομένα που δεν χρησιμοποιούνται, την προκειμένη στιγμή, στον χώρο swap, και όταν τα χρειαστεί τα επαναφέρει (ενώ μεταφέρει κάποια άλλα δεδομένα στον χώρο swap).</p></div><div class=paragraph><p>Υπάρχουν κάποιες συμβάσεις σχετικά με τις κατατμήσεις</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Κατάτμηση</th><th class="tableblock halign-left valign-top">Σύμβαση</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συνήθως περιλαμβάνει το root σύστημα αρχείων</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συνήθως περιλαμβάνει τον χώρο swap</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>c</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συνήθως ιδίου μεγέθους με την περιλαμβανόμενη φέτα (slice). Αυτό επιτρέπει σε βοηθητικά προγράμματα που πρέπει να δουλέψουν σε ολόκληρο το κομμάτι (για παράδειγμα, ένας ανιχνευτής κατεστραμμένων μπλοκ) να λειτουργούν στην <code>c</code> κατάτμηση. Κανονικά δεν θα πρέπει να δημιουργείτε σύστημα αρχείων σε αυτή την κατάτμηση.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η κατάτμηση <code>d</code> είχε στο παρελθόν μια ειδική αντιστοιχία, κάτι που δεν ισχύει πλέον σήμερα, επομένως η <code>d</code> μπορεί να χρησιμοποιείται σαν μια κανονική κατάτμηση.</p></td></tr></tbody></table><div class=paragraph><p>Κάθε κατάτμηση που περιέχει ένα σύστημα αρχείων αποθηκεύεται στο FreeBSD σε μια τοποθεσία που ονομάζεται <em>φέτα (slice)</em>. Η φέτα είναι ένας όρος του FreeBSD για αυτό που κοινώς αποκαλείται κατάτμηση, και αυτό επίσης οφείλεται στην καταγωγή του FreeBSD από το UNIX®. Οι φέτες αριθμούνται αρχίζοντας από το 1 έως το 4.</p></div><div class=paragraph><p>Ο αριθμός της φέτας ακολουθεί το όνομα συσκευής μετά το πρόθεμα <code>s</code> ξεκινώντας από το 1. Επομένως, "da0<em>s1</em>" είναι η πρώτη φέτα του πρώτου οδηγού SCSI. Μπορούν να υπάρχουν μέχρι τέσσερις φέτες σε κάθε δίσκο, αλλά μπορείτε να δημιουργήσετε λογικές φέτες μέσα σε κατάλληλου τύπου φυσικές φέτες. Σε αυτές τις εκτεταμένες φέτες η αρίθμηση ξεκινάει από το 5, επομένως "ad0<em>s5</em>" είναι η πρώτη εκτεταμένη φέτα στον πρώτο δίσκο IDE. Αυτές οι συσκευές χρησιμοποιούνται από συστήματα αρχείων που πρέπει να καταλαμβάνουν μια ολόκληρη φέτα.</p></div><div class=paragraph><p>Οι φέτες, οι "επικίνδυνα αφοσιωμένοι (dangerously dedicated) " φυσικοί οδηγοί καθώς και άλλοι οδηγοί, περιέχουν <em>κατατμήσεις</em>, οι οποίες παρουσιάζονται με λατινικούς χαρακτήρες από το <code>a</code> έως το <code>h</code>. Αυτός ο χαρακτήρας αναφέρεται στο όνομα συσκευής, επομένως "da0<em>a</em>" είναι η a κατάτμηση στον πρώτο οδηγό da, ο οποίος είναι "επικίνδυνα αφοσιωμένος". Η "ad1s3<em>e</em>" είναι η πέμπτη κατάτμηση στην τρίτη φέτα του δεύτερου οδηγού δίσκου IDE.</p></div><div class=paragraph><p>Ολοκληρώνοντας, κάθε δίσκος στο σύστημα είναι μονόδρομα ορισμένος. Κάθε όνομα δίσκου ξεκινά με ένα κωδικό που υποδεικνύει τον τύπο του δίσκου, και ένα νούμερο που υποδηλώνει ποιος δίσκος είναι. Αντίθετα με τις φέτες, οι δίσκοι αριθμούνται ξεκινώντας από το 0. Οι πιο συνήθεις κωδικοί που θα συναντήσετε αναφέρονται στην <a href=#basics-dev-codes>Κωδικοί Συσκευών Δίσκων</a>.</p></div><div class=paragraph><p>Όταν γίνεται αναφορά σε μια κατάτμηση, το FreeBSD ζητά να δηλωθεί επιπλέον η ονομασία της φέτας και του δίσκου που περιέχει την κατάτμηση, ενώ στην περίπτωση που αναφέρεστε σε μια φέτα θα πρέπει να δηλώνετε το όνομα του δίσκου. Επομένως, όταν αναφέρεστε σε μια κατάτμηση χρειάζεται να δηλώνετε το όνομα του δίσκου, <code>s</code>, τον αριθμό της φέτας, και τον χαρακτήρα της κατάτμησης. Παραδείγματα μπορείτε να βρείτε στην <a href=#basics-disk-slice-part>Υποδείγματα Ονομάτων Δίσκου, Φέτας, Κατάτμησης</a>.</p></div><div class=paragraph><p>Η <a href=#basics-concept-disk-model>Εννοιολογικό Μοντέλο ενός Δίσκου</a> παρουσιάζει ένα εννοιολογικό μοντέλο για τη δομή του δίσκου που θα σας βοηθήσει να καταλάβετε καλύτερα κάποια πράγματα.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το FreeBSD πρέπει πρώτα να ρυθμίσετε τις φέτες του δίσκου, να δημιουργήσετε τις κατατμήσεις μέσα στις φέτες που θα χρησιμοποιήσετε για το FreeBSD, έπειτα να δημιουργήσετε ένα σύστημα αρχείων (ή χώρο swap) σε κάθε κατάτμηση, και τέλος να αποφασίσετε σε ποιο σημείο θα προσαρτηθεί το σύστημα αρχείων.</p></div><table id=basics-dev-codes class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 2. Κωδικοί Συσκευών Δίσκων</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Κώδικας</th><th class="tableblock halign-left valign-top">Σημαίνει</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>ad</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δίσκος ATAPI (IDE)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>da</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δίσκος SCSI άμεσης πρόσβασης</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>acd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ATAPI (IDE) CDROM</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>cd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI CDROM</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>fd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μονάδα Δισκέτας (Floppy)</p></td></tr></tbody></table><div id=basics-disk-slice-part class=exampleblock><div class=title>Παράδειγμα 4. Υποδείγματα Ονομάτων Δίσκου, Φέτας, Κατάτμησης</div><div class=content><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Ονομασία</th><th class="tableblock halign-left valign-top">Σημαίνει</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad0s1a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η πρώτη κατάτμηση (<code>a</code>) στην πρώτη φέτα (<code>s1</code>) του πρώτου δίσκου IDE (<code>ad0</code>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da1s2e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η πέμπτη κατάτμηση (<code>e</code>) στην δεύτερη φέτα (<code>s2</code>) του δεύτερου δίσκου SCSI (<code>da1</code>).</p></td></tr></tbody></table></div></div><div id=basics-concept-disk-model class=exampleblock><div class=title>Παράδειγμα 5. Εννοιολογικό Μοντέλο ενός Δίσκου</div><div class=content><div class=paragraph><p>Το διάγραμμα παρουσιάζει μια εικόνα του πρώτου δίσκου IDE που είναι προσαρτημένος στο σύστημα. Ας υποθέσουμε πως ο δίσκος έχει μέγεθος 4 GB, και περιέχει δύο φέτες των 2 GB (κατατμήσεις MS-DOS®). Η πρώτη φέτα περιέχει ένα δίσκο MS-DOS®, <span class=filename>C:</span>, και η δεύτερη φέτα μία εγκατάσταση FreeBSD. Σε αυτό το παράδειγμα, η εγκατάσταση FreeBSD έχει τρεις κατατμήσεις δεδομένων και μία κατάτμηση swap.</p></div><div class=paragraph><p>Καθεμία από τις τρεις κατατμήσεις θα περιέχει ένα σύστημα αρχείων. Η κατάτμηση <code>a</code> θα χρησιμοποιηθεί για το root σύστημα αρχείων, η <code>e</code> για τη δομή κατάλογου <span class=filename>/var</span>, και η <code>f</code> για τη δομή καταλόγου <span class=filename>/usr</span>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/disk-layout.png alt="disk layout"></div></div></div></div></div><div class=sect2><h3 id=mount-unmount>5.6. Προσάρτηση και Αποπροσάρτηση Συστημάτων Αρχείων<a class=anchor href=#mount-unmount></a></h3><div class=paragraph><p>Ένα σύστημα αρχείων αναπαριστάται καλύτερα σε μορφή δέντρου, με τις ρίζες του στο <span class=filename>/</span>. Οι κατάλογοι <span class=filename>/dev</span>, <span class=filename>/usr</span>, και άλλοι είναι κλαδιά του καταλόγου root, και μπορεί να έχουν με τη σειρά τους, τα δικά τους κλαδιά, όπως τον <span class=filename>/usr/local</span>, και ούτω καθεξής.</p></div><div class=paragraph><p>Υπάρχουν διάφοροι λόγοι για τους οποίους θα έπρεπε να τοποθετήσουμε κάποιους από αυτούς τους καταλόγους σε διαφορετικά συστήματα αρχείων. Ο κατάλογος <span class=filename>/var</span> περιέχει τους καταλόγους <span class=filename>log/</span>, <span class=filename>spool/</span>, και διάφορους άλλους τύπους προσωρινών αρχείων, και για το λόγο αυτό μπορεί να γεμίσει. Δεν θα ήταν καλή ιδέα να γεμίσει το root σύστημα αρχείων, επομένως ο διαχωρισμός του <span class=filename>/var</span> από τον <span class=filename>/</span> είναι συχνά επιθυμητός.</p></div><div class=paragraph><p>Ένας άλλος συνηθισμένος λόγος να έχουμε διάφορους καταλόγους σε διαφορετικά συστήματα αρχείων είναι όταν πρόκειται να φιλοξενηθούν σε διαφορετικούς φυσικούς δίσκους, ή είναι ξεχωριστοί εικονικοί δίσκοι, όπως συμβαίνει με το <a href=./#network-nfs>Δικτυακό Σύστημα Αρχείων (Network File System)</a>, και τους οδηγούς CDROM.</p></div><div class=sect3><h4 id=disks-fstab>5.6.1. Το Αρχείο <span class=filename>fstab</span><a class=anchor href=#disks-fstab></a></h4><div class=paragraph><p>Κατά τη <a href=./#boot>διεργασία εκκίνησης</a>, τα συστήματα αρχείων που αναφέρονται στο <span class=filename>/etc/fstab</span> προσαρτώνται αυτόματα (εκτός αν αναφέρονται με την επιλογή <code>noauto</code> ).</p></div><div class=paragraph><p>Το αρχείο <span class=filename>/etc/fstab</span> περιέχει μια σειρά από γραμμές με διάταξη όπως η ακόλουθη:</p></div><div class="literalblock programlisting"><div class=content><pre>device       /mount-point fstype     options      dumpfreq     passno</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>device</code></dt><dd><p>Όνομα συσκευής (η οποία θα πρέπει να υπάρχει), όπως εξηγείται στην <a href=./#disks-naming>Device Names</a>.</p></dd><dt class=hdlist1><code>mount-point</code></dt><dd><p>Κατάλογος (θα πρέπει να υπάρχει) στον οποίο προσαρτάται το σύστημα αρχείων.</p></dd><dt class=hdlist1><code>fstype</code></dt><dd><p>Ο τύπος του συστήματος αρχείων που θα δοθεί στην <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Το προκαθορισμένο σύστημα αρχείων του FreeBSD είναι το <code>ufs</code>.</p></dd><dt class=hdlist1><code>options</code></dt><dd><p>Το <code>rw</code> για συστήματα αρχείων ανάγνωσης- εγγραφής (read- write), ή <code>ro</code> για συστήματα αρχείων μόνο ανάγνωσης (read-only), συμπληρωμένο με όποια άλλη επιλογή μπορεί να χρειάζεστε. Μία συνήθης επιλογή είναι η <code>noauto</code> για συστήματα αρχείων που δεν προσαρτώνται αυτόματα κατά τις διεργασίες εκκίνησης του συστήματος. Άλλες επιλογές αναφέρονται στην σελίδα βοήθειας <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></dd><dt class=hdlist1><code>dumpfreq</code></dt><dd><p>Αυτό το πεδίο χρησιμοποιείται από το <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> για να ορίσει ποια συστήματα αρχείων χρειάζονται dumping. Αν το πεδίο απουσιάζει, τότε η προκαθορισμένη τιμή του είναι μηδέν.</p></dd><dt class=hdlist1><code>passno</code></dt><dd><p>Αυτό ορίζει την σειρά με την οποία θα ελέγχονται τα συστήματα αρχείων. Συστήματα αρχείων που δεν επιθυμούμε να ελεγχθούν θα πρέπει να έχουν στο πεδίο <code>passno</code> τιμή μηδέν. Το root σύστημα αρχείων (το οποίο πρέπει να ελεγχθεί πριν από όλα τα άλλα) θα έχει στο πεδίο <code>passno</code> την τιμή ένα και όλα τα άλλα συστήματα αρχείων θα έχουν στο πεδίο <code>passno</code> τιμές μεγαλύτερες από ένα. Αν περισσότερα από ένα συστήματα αρχείων έχουν την ίδια τιμή <code>passno</code> τότε το <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> θα επιχειρήσει να ελέγξει παράλληλα τα συστήματα αρχείων, αν αυτό είναι εφικτό.</p></dd></dl></div><div class=paragraph><p>Συμβουλευτείτε την σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> για περισσότερες πληροφορίες για την μορφή του αρχείου <span class=filename>/etc/fstab</span> και για τις επιλογές που μπορεί να περιέχει.</p></div></div><div class=sect3><h4 id=disks-mount>5.6.2. Η Εντολή <code>mount</code><a class=anchor href=#disks-mount></a></h4><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> είναι αυτό ακριβώς που χρειάζεστε για την προσάρτηση συστημάτων αρχείων.</p></div><div class=paragraph><p>Η βασική μορφή της είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount device mountpoint</span></code></pre></div></div><div class=paragraph><p>Υπάρχει πληθώρα επιλογών, όπως αναφέρεται στην σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, αλλά οι πιο συνήθεις είναι:</p></div><div class=dlist><div class=title>Επιλογές εντολής mount</div><dl><dt class=hdlist1><code>-a</code></dt><dd><p>Προσάρτηση όλων των συστημάτων αρχείων που αναφέρονται στο <span class=filename>/etc/fstab</span>, εκτός αυτών που φέρουν την επιλογή "noauto", εξαιρούνται μέσω της επιλογής <code>-t</code>, ή αυτών που ήδη έχουν προσαρτηθεί.</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>Κάνει τα πάντα εκτός από την πραγματική προσάρτηση του συστήματος. Αυτή η επιλογή είναι χρήσιμη σε συνεργασία με το πρόθεμα <code>-v</code> για να προσδιοριστεί τι ακριβώς προσπαθεί να κάνει η <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> την συγκεκριμένη στιγμή.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Αναγκάζει την προσάρτηση ενός μη-καθαρού συστήματος αρχείων (επικίνδυνο), ή εξαναγκάζει την ανάκληση πρόσβασης εγγραφής όταν υποβιβάζεται η προσάρτηση ενός συστήματος αρχείων ανάγνωσης-εγγραφής (read-write) σε μόνο-ανάγνωσης.</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>Προσαρτά το σύστημα αρχείων σε κατάσταση μόνο-ανάγνωσης. Είναι ακριβώς το ίδιο με τη χρήση του προθέματος <code>ro</code> με την επιλογή <code>-o</code>.</p></dd><dt class=hdlist1><code>-t</code> <em>fstype</em></dt><dd><p>Προσαρτά το υπάρχον σύστημα αρχείων, χρησιμοποιώντας τον τύπο συστήματος αρχείων που δίνεται, ή προσαρτά μόνο συστήματα αρχείων του συγκεκριμένου τύπου, εάν δοθεί μαζί με την επιλογή <code>-a</code>.</p><div class=paragraph><p>Το "ufs" είναι ο προεπιλεγμένος τύπος συστήματος αρχείων.</p></div></dd><dt class=hdlist1><code>-u</code></dt><dd><p>Ανανεώνει τις επιλογές προσάρτησης στο σύστημα αρχείων.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>Συμπεριλαμβάνει αναλυτική αναφορά.</p></dd><dt class=hdlist1><code>-w</code></dt><dd><p>Προσαρτά το σύστημα αρχείων για ανάγνωση-εγγραφή (read-write).</p></dd></dl></div><div class=paragraph><p>Η επιλογή <code>-o</code> δέχεται μία σειρά από επιλογές χωρισμένες με κόμμα, περιλαμβάνοντας τις ακόλουθες:</p></div><div class=dlist><dl><dt class=hdlist1>noexec</dt><dd><p>Δεν επιτρέπεται η λειτουργία εκτελέσιμων σε αυτό το σύστημα αρχείων. Αυτό είναι επίσης μια επιλογή ασφαλείας.</p></dd><dt class=hdlist1>nosuid</dt><dd><p>Δεν λαμβάνονται υπ' όψιν setuid ή setgid flags στο σύστημα αρχείων.</p></dd></dl></div></div><div class=sect3><h4 id=disks-umount>5.6.3. Η Εντολή <code>umount</code><a class=anchor href=#disks-umount></a></h4><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> παίρνει, ως παράμετρο, ένα εκ των σημείων προσάρτησης, το όνομα μιας συσκευής, ή τις επιλογές <code>-a</code> ή <code>-A</code>.</p></div><div class=paragraph><p>Όλοι οι τύποι δέχονται την <code>-f</code> για να εξαναγκάσουν σε αποπροσάρτηση, και την <code>-v</code> για αναλυτική αναφορά. Σας προειδοποιούμε πως η επιλογή <code>-f</code> γενικά δεν είναι καλή ιδέα. Η εξ' αναγκασμού αποπροσάρτηση μπορεί να οδηγήσει σε κατάρρευση τον υπολογιστή ή να καταστρέψει δεδομένα στο σύστημα αρχείων.</p></div><div class=paragraph><p>Οι <code>-a</code> και <code>-A</code> χρησιμοποιούνται για να αποπροσαρτήσουν όλα τα προσαρτημένα συστήματα αρχείων, σύμφωνα και με τις επιλογές που δίνονται από το <code>-t</code>, αν υπάρχει. Το <code>-A</code>, ωστόσο, δεν θα επιχειρήσει να αποπροσαρτήσει το root σύστημα αρχείων.</p></div></div></div><div class=sect2><h3 id=basics-processes>5.7. Διεργασίες<a class=anchor href=#basics-processes></a></h3><div class=paragraph><p>To FreeBSD είναι ένα λειτουργικό σύστημα multi-tasking. Αυτό σημαίνει πως κάθε στιγμή μπορούν να τρέχουν παραπάνω από ένα προγράμματα. Κάθε πρόγραμμα που τρέχει οποιαδήποτε στιγμή ονομάζεται <em>διεργασία</em> (process). Κάθε εντολή που τρέχετε ξεκινάει τουλάχιστον μία νέα διεργασία, και υπάρχουν κάποιες διεργασίες του συστήματος που τρέχουν συνέχεια για να κρατούν το σύστημα σε λειτουργία.</p></div><div class=paragraph><p>Κάθε διεργασία χαρακτηρίζεται από ένα μοναδικό αριθμό που ονομάζεται <em>ID διεργασίας</em> ή <em>PID</em>, και όπως ακριβώς συμβαίνει με τα αρχεία, κάθε διεργασία έχει έναν ιδιοκτήτη και ένα γκρουπ. Οι πληροφορίες του ιδιοκτήτη και του γκρουπ χρειάζονται για να προσδιορίζεται ποια αρχεία και συσκευές μπορεί να ανοίξει η συγκεκριμένη διεργασία, χρησιμοποιώντας τις άδειες αρχείων που συζητήσαμε νωρίτερα. Οι περισσότερες διεργασίες έχουν επίσης μία γονική διεργασία. Η γονική διεργασία είναι εκείνη η διεργασία που τις ξεκίνησε. Για παράδειγμα, εάν πληκτρολογείτε εντολές στο κέλυφος, τότε το κέλυφος είναι μία διεργασία, και κάθε εντολή που τρέχετε είναι επίσης μία διεργασία. Επομένως κάθε διεργασία που τρέχετε με αυτόν τον τρόπο θα έχει γονική διεργασία το κέλυφος σας. Η μόνη εξαίρεση είναι μία διεργασία που ονομάζεται <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. Η <code>init</code> είναι πάντα η πρώτη διεργασία, και επομένως το PID της είναι πάντα 1. Η <code>init</code> ξεκινά αυτόματα από τον πυρήνα κατά την εκκίνηση του FreeBSD.</p></div><div class=paragraph><p>Δύο ιδιαίτερα χρήσιμες εντολές για να παρατηρείτε τις διεργασίες στο σύστημα, είναι οι <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. Η εντολή <code>ps</code> χρησιμοποιείται για την προβολή μιας στατικής λίστας των τρέχοντων διεργασιών, και μπορεί να εμφανίζει το PID τους, πόση μνήμη χρησιμοποιούν, την εντολή με την οποία ξεκίνησαν, και άλλες πληροφορίες. Η εντολή <code>top</code> εμφανίζει όλες τις τρέχουσες διεργασίες, και ανανεώνει την οθόνη σας ανά λίγα δευτερόλεπτα, επομένως μπορείτε να παρατηρείτε τι ακριβώς κάνει ο υπολογιστή σας τη δεδομένη στιγμή.</p></div><div class=paragraph><p>Η <code>ps</code>, από προεπιλογή, εμφανίζει μόνο τις εντολές που τρέχουν και ανήκουν σε εσάς. Για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl <span class=o>(</span>xemacs-21.1.14<span class=o>)</span>
37393  p0  I      0:03.11 xemacs freebsd.dsl <span class=o>(</span>xemacs-21.1.14<span class=o>)</span>
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 <span class=o>(</span>dns helper<span class=o>)</span> <span class=o>(</span>navigator-linux-<span class=o>)</span>
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt <span class=nt>-y</span>
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 <span class=nt>-tcsh</span> <span class=o>(</span>tcsh<span class=o>)</span>
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx <span class=nt>--</span> <span class=nt>-bpp</span> 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc <span class=nt>--</span> <span class=nt>-bpp</span> 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</code></pre></div></div><div class=paragraph><p>Όπως μπορείτε να δείτε σε αυτό το παράδειγμα, η έξοδος από την ps προβάλλεται σε στήλες. <code>PID</code> είναι το PID της διεργασίας όπως αναφέραμε νωρίτερα. Τα PID διανέμονται από 1, έως 99999, και όταν υπερβούν το 99999 ξεκινούν από την αρχή (ένα PID δεν μπορεί να αποδοθεί ξανά αν είναι ήδη σε χρήση). Η στήλη <code>TT</code> δείχνει το τερματικό (tty) του προγράμματος που εκτελείται, και μπορεί να αγνοηθεί αυτή τη στιγμή δίχως πρόβλημα. Η <code>STAT</code> υποδεικνύει την κατάσταση του προγράμματος, και πάλι μπορεί να αγνοηθεί. Η <code>TIME</code> είναι η χρονική διάρκεια που το πρόγραμμα απασχολεί την CPU, αυτό συνήθως δεν είναι ο χρόνος εκτέλεσης αφού τα περισσότερα προγράμματα καθυστερούν με άλλες εργασίες πριν απασχολήσουν την CPU. Η τελευταία στήλη, η <code>COMMAND</code> είναι η γραμμή εντολής που δόθηκε για να τρέξει το πρόγραμμα.</p></div><div class=paragraph><p>Η <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> υποστηρίζει διάφορες επιλογές για να αλλάξει την γκάμα των πληροφοριών που εμφανίζονται. Μία από τις πιο χρήσιμες επιλογές είναι η <code>auxww</code>. Η <code>a</code> εμφανίζει πληροφορίες για όλες τις τρέχουσες διεργασίες, όχι μόνο τις δικές σας. Η <code>u</code> εμφανίζει το όνομα χρήστη του ιδιοκτήτη της διεργασίας, όπως και τη χρήσης της μνήμης. Η <code>x</code> εμφανίζει πληροφορίες σχετικά με τις διεργασίες των δαιμόνων και η <code>ww</code> αναγκάζει την <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> να εμφανίσει ολόκληρη την εντολή γραμμής για κάθε διεργασία, αφού συνήθως εμφανίζεται κομμένη λόγω του μήκους της που δεν χωρά να εμφανιστεί στην οθόνη.</p></div><div class=paragraph><p>Η έξοδος της <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> είναι παρόμοια. Ένα δείγμα εργασίας της μοιάζει σαν αυτή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top
last pid: 72257<span class=p>;</span>  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% <span class=nb>nice</span>,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K <span class=k>select   </span>2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K <span class=k>select   </span>5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K <span class=k>select   </span>0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K <span class=k>select   </span>3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K <span class=k>select   </span>1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</code></pre></div></div><div class=paragraph><p>Η έξοδος είναι χωρισμένη σε δύο τομείς. Η κεφαλίδα (οι πέντε πρώτες γραμμές) εμφανίζουν το PID της τελευταίας διεργασίας που έτρεξε, την μέση τιμή φορτίου (είναι μια μέτρηση που δείχνει πόσο απασχολημένο είναι το σύστημα), ο χρόνος λειτουργίας (uptime) του συστήματος (από την τελευταία επανεκκίνηση) και την τρέχουσα ώρα. Τα άλλα στοιχεία στην κεφαλίδα σχετίζονται με το νούμερο των διεργασιών που τρέχουν (47 σε αυτή τη περίπτωση), πόση μνήμη και χώρο swap κατέχουν και πόσο χρόνο ξοδεύει το σύστημα σε διάφορες καταστάσεις λειτουργίας της CPU.</p></div><div class=paragraph><p>Πιο κάτω ακολουθεί μια σειρά από στήλες, που περιέχουν παρόμοιες πληροφορίες με την έξοδο της ps. Όπως και νωρίτερα μπορείτε να δείτε το PID, το όνομα χρήστη, το ποσοστό χρήσης της CPU, και την εντολή με την οποία ξεκίνησε η διεργασία. Η <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> από προεπιλογή, εμφανίζει επίσης το ποσοστό μνήμης που χρησιμοποιείται από τη διεργασία. Αυτή χωρίζεται σε δύο στήλες. Η μία είναι για το συνολικό μέγεθος μνήμης που χρειάστηκε η εφαρμογή, ενώ η άλλη για το μέγεθος της μνήμης που καταναλώνει την παρούσα στιγμή. Σε αυτό το παράδειγμα μπορείτε να δείτε ότι ο <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> χρειάστηκε σχεδόν 30 MB RAM, αλλά την παρούσα στιγμή χρησιμοποιεί μόνο 9 MB.</p></div><div class=paragraph><p>Η <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> αυτόματα ανανεώνει το περιεχόμενο της κάθε δύο δευτερόλεπτα. Αυτό μπορεί να ρυθμιστεί με την επιλογή <code>s</code>.</p></div></div><div class=sect2><h3 id=basics-daemons>5.8. Δαίμονες, Σήματα, και Τερματισμός Διεργασιών<a class=anchor href=#basics-daemons></a></h3><div class=paragraph><p>Όταν χρησιμοποιείτε ένα κειμενογράφο, είναι εύκολο να τον ελέγχετε, να φορτώνετε αρχεία, και οτιδήποτε άλλο. Αυτό συμβαίνει διότι ο κειμενογράφος παρέχει αυτές τις δυνατότητες, και επίσης επειδή είναι προσαρτημένος σε ένα <em>τερματικό</em>. Μερικά προγράμματα δεν είναι σχεδιασμένα να δουλεύουν με συνεχείς χειρισμούς από τον χρήστη, και επομένως αποσυνδέονται από το τερματικό με την πρώτη ευκαιρία. Για παράδειγμα, ένας εξυπηρετητής web ξοδεύει όλο του το χρόνο στο να απαντά σε αιτήματα web, επομένως δεν χρειάζεται καμιά εισαγωγή δεδομένων από τον χρήστη. Άλλο παραπλήσιο παράδειγμα εφαρμογής, είναι τα προγράμματα μεταφοράς μηνυμάτων ηλεκτρονικής αλληλογραφίας από μια τοποθεσία σε μιαν άλλη.</p></div><div class=paragraph><p>Ονομάζουμε αυτά τα προγράμματα <em>δαίμονες (daemons)</em>. Οι δαίμονες ήταν χαρακτήρες της Ελληνικής μυθολογίας (ούτε καλοί - ούτε κακοί), ήταν απλά μικρά συνοδευτικά πνεύματα που έκαναν χρήσιμα πράγματα για την ανθρωπότητα, όπως ακριβώς και οι διακομιστές web και εξυπηρετητές ηλεκτρονικής αλληλογραφίας σήμερα κάνουν χρήσιμα πράγματα. Αυτός είναι και ο λόγος για τον οποίο η μασκότ του BSD είναι εδώ και πολύ καιρό ο χαρούμενος δαίμονας με πάνινα σπορ παπούτσια και την τρίαινα.</p></div><div class=paragraph><p>Η ονομασία των προγραμμάτων που τρέχουν σαν δαίμονες συμβατικά τελειώνει με "d". Το BIND είναι το Berkeley Internet Name Domain, αλλά το πραγματικό πρόγραμμα που τρέχει ονομάζεται <code>named</code>, το πρόγραμμα του εξυπηρετητή web Apache λέγεται <code>httpd</code>, ο δαίμονας ελέγχου των εκτυπωτών γραμμής είναι ο <code>lpd</code> και ούτω καθεξής. Αυτή είναι απλά μια σύμβαση, όχι απόλυτος κανόνας, για παράδειγμα, ο κύριος δαίμονας ηλεκτρονικής αλληλογραφίας για την εφαρμογή Sendmail ονομάζεται <code>sendmail</code>, και όχι <code>maild</code>, όπως θα ήταν αναμενόμενο.</p></div><div class=paragraph><p>Μερικές φορές θα χρειαστεί να επικοινωνείτε με τη διεργασία ενός δαίμονα. Ένας τρόπος για να γίνει αυτό είναι στέλνοντας (όπως και σε κάθε εκτελέσιμη διεργασία) <em>σήματα (signals)</em>. Υπάρχουν διάφορα σήματα που μπορείτε να στείλετε - μερικά από αυτά έχουν μια συγκεκριμένη σημασία, ενώ άλλα ερμηνεύονται μέσα από την εφαρμογή, και επομένως για να ξέρουμε πως ερμηνεύονται τα σήματα θα πρέπει να διαβάσουμε την τεκμηρίωση της εφαρμογής. Μπορείτε να στείλετε σήμα σε μια διεργασία μόνο αν σας ανήκει. Αν στείλετε σήμα σε μια διεργασία που ανήκει σε κάποιον άλλο με <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> ή <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=2&amp;format=html">kill(2)</a>, δεν θα σας επιτραπεί. Η μοναδική εξαίρεση σε αυτό, είναι ο χρήστης <code>root</code>, που μπορεί να στέλνει σήματα στις διεργασίες οποιουδήποτε άλλου χρήστη του συστήματος.</p></div><div class=paragraph><p>Το FreeBSD στέλνει επίσης σήματα σε εφαρμογές σε μερικές περιπτώσεις. Αν μία εφαρμογή είναι γραμμένη άσχημα, και προσπαθεί να προσπελάσει μνήμη που δεν της ανήκει, το FreeBSD στέλνει στη διεργασία το σήμα <em>Segmentation Violation</em> (<code>SIGSEGV</code>). Αν μια εφαρμογή χρησιμοποίησε το σύστημα ειδοποίησης <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> για να ειδοποιηθεί μετά την πάροδο μιας χρονικής περιόδου τότε το FreeBSD θα στείλει το Alarm signal (<code>SIGALRM</code>), και ούτω καθ’εξής.</p></div><div class=paragraph><p>Δύο σήματα μπορούν να χρησιμοποιηθούν για να σταματήσουν μία διαδικασία, το <code>SIGTERM</code> και το <code>SIGKILL</code>. Το <code>SIGTERM</code> είναι ο σωστός τρόπος για να σταματήσουμε μια διαδικασία. Η διεργασία <em>αντιλαμβάνεται</em> το σήμα, εκτελεί το σταμάτημα κλείνοντας όλα τα αρχεία αναφοράς (log files), που πιθανώς να είναι ανοιχτά, και γενικώς τελειώνει οτιδήποτε κάνει την συγκεκριμένη χρονική στιγμή πριν σταματήσει. Σε μερικές περιπτώσεις η διεργασία μπορεί να αγνοήσει το <code>SIGTERM</code> εάν βρίσκεται στα μισά κάποιας εργασίας που δεν μπορεί να διακοπεί.</p></div><div class=paragraph><p>Το σήμα <code>SIGKILL</code> δεν μπορεί να αγνοηθεί από μία διεργασία. Είναι σαν να λέει στη διεργασία, "Δεν με ενδιαφέρει τι κάνεις, σταμάτα τώρα αμέσως". Αν στείλετε το σήμα <code>SIGKILL</code> σε μια διαδικασία τότε το FreeBSD θα σταματήσει την διαδικασία άμεσα .</p></div><div class=paragraph><p>Άλλα σήματα που πιθανώς να θέλετε να χρησιμοποιήσετε είναι τα <code>SIGHUP</code>, <code>SIGUSR1</code>, και <code>SIGUSR2</code>. Αυτά είναι σήματα γενικής χρήσης, και όταν αποστέλλονται κάνουν διαφορετικά πράγματα ανάλογα με την εφαρμογή.</p></div><div class=paragraph><p>Ας υποθέσουμε πως αλλάξατε το αρχείο ρύθμισης του εξυπηρετητή διαδικτύου σας, και πως θα θέλατε να πείτε στον εξυπηρετητή να ξαναδιαβάσει τις ρυθμίσεις. Θα μπορούσατε να σταματήσετε και να επανεκκινήσετε το <code>httpd</code>, αλλά αυτό θα οδηγούσε σε μια χρονική περίοδο όπου ο εξυπηρετητής θα έμενε εκτός λειτουργίας, κάτι το οποίο μπορεί να είναι ανεπιθύμητο. Οι περισσότεροι δαίμονες είναι σχεδιασμένοι να απαντούν σε σήματα <code>SIGHUP</code> για την εκ νέου ανάγνωση του αρχείου ρύθμισης τους. Επομένως, αντί να σταματήσουμε και να επανεκκινήσουμε το <code>httpd</code> θα μπορούσαμε να του στείλουμε το σήμα <code>SIGHUP</code>. Επειδή δεν υπάρχει συγκεκριμένος τρόπος στην απάντηση αυτών των σημάτων, και διαφορετικοί δαίμονες έχουν διαφορετική συμπεριφορά, πρέπει να διαβάσετε πρώτα την τεκμηρίωση για τον συγκεκριμένο δαίμονα.</p></div><div class=paragraph><p>Τα σήματα στέλνονται χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a>, όπως υποδεικνύει το ακόλουθο παράδειγμα.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Στέλνοντας Σήμα σε μία Διεργασία</strong></p></div><div class=paragraph><p>Αυτό το παράδειγμα δείχνει πως να στείλετε σήμα στην <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. Το αρχείο ρύθμισης της <code>inetd</code> είναι το <span class=filename>/etc/inetd.conf</span>, και η <code>inetd</code> θα ξανα-διαβάσει αυτό το αρχείο ρύθμισης όταν θα σταλεί το σήμα <code>SIGHUP</code>.</p></div><div class="olist arabic"><ol class=arabic><li><p>Βρείτε το PID της διεργασίας, της οποίας επιθυμείτε να στείλετε το σήμα. Ενεργήστε χρησιμοποιώντας τις εντολές <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a>. Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a> χρησιμοποιείται για να ψάξει στην έξοδο μιας εντολής, για τους αλφαριθμητικούς χαρακτήρες που έχετε ορίσει. Η εντολή εκτελείται από έναν απλό χρήστη, ενώ η <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> εκτελείται από τον <code>root</code>, επομένως θα πρέπει να προσθέσετε την επιλογή <code>ax</code> στην <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps <span class=nt>-ax</span> | <span class=nb>grep </span>inetd
  198  ??  IWs    0:00.00 inetd <span class=nt>-wW</span></code></pre></div></div><div class=paragraph><p>Επομένως το PID της <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> είναι το 198. Σε μερικές περιπτώσεις μπορεί να εμφανίζεται στην έξοδο η εντολή <code>grep inetd</code>. Αυτό οφείλεται στον τρόπο με τον οποίο η <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> ψάχνει την λίστα των ενεργών διεργασιών.</p></div></li><li><p>Χρησιμοποιήστε την <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> για να στείλετε το σήμα. Επειδή η <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> τρέχει από τον <code>root</code> θα πρέπει πρώτα να χρησιμοποιήσετε <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> για να γίνετε πρώτα <code>root</code>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:
<span class=c># /bin/kill -s HUP 198</span></code></pre></div></div><div class=paragraph><p>Όπως και με τις περισσότερες εντολές στο UNIX®, η <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> δεν θα τυπώσει τίποτε στην έξοδο αν η εντολή είχε επιτυχία. Εάν στείλετε ένα σήμα σε μια διεργασία που δεν σας ανήκει θα δείτε <code>kill: <em>PID</em>: Operation not permitted</code>. Αν πληκτρολογήσετε λάθος το PID τότε ή θα στείλετε το σήμα σε λάθος διεργασία,κάτι που μπορεί να είναι άσχημο, ή, αν είστε τυχερός, θα έχετε στείλει το σήμα σε ένα PID που δεν χρησιμοποιείται τη συγκεκριμένη στιγμή, και θα δείτε <code>kill: <em>PID</em>: No such process</code>.</p></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Γιατί να χρησιμοποιήσετε την εντολή <code>/bin/kill</code>;</div><div class=paragraph><p>Πολλά κελύφη παρέχουν την εντολή <code>kill</code> ως ενσωματωμένη εντολή. Αυτό σημαίνει πως το κέλυφος θα στείλει το σήμα άμεσα, αντί να τρέξει το <span class=filename>/bin/kill</span>. Αυτό μπορεί να είναι πολύ χρήσιμο, αλλά διαφορετικά κελύφη έχουν διαφορετική σύνταξη για τον καθορισμό το όνομα του σήματος που πρέπει να αποσταλεί. Αντί λοιπόν να πρέπει να μάθουμε όλες τις περιπτώσεις ,είναι ευκολότερο απλά να χρησιμοποιούμε την εντολή <code>/bin/kill …​</code> άμεσα.</p></div></td></tr></tbody></table></div></div></div><div class=paragraph><p>Η αποστολή άλλων σημάτων μοιάζει πάρα πολύ, απλά αντικαταστήστε το <code>TERM</code> ή το <code>KILL</code> στη γραμμή εντολών με κάποιο άλλο.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Η φόνευση τυχαίων διεργασιών στο σύστημα μπορεί να είναι κακή ιδέα. Ιδιαίτερα, η <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, με PID 1, είναι πολύ ειδική. Η εκτέλεση της εντολής <code>/bin/kill -s KILL 1</code> είναι ένας γρήγορος τρόπος να σβήσετε το σύστημα σας. <em>Πάντα</em> να ελέγχετε δύο φορές τις παραμέτρους που χρησιμοποιείτε με την <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> <em>πριν</em> πιέσετε <kbd>Return</kbd>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=shells>5.9. Κελύφη<a class=anchor href=#shells></a></h3><div class=paragraph><p>Στο FreeBSD ένα μεγάλο μέρος της καθημερινής εργασίας γίνεται σε ένα περιβάλλον γραμμής εντολών ονόματι κέλυφος (shell). Η κύρια δουλειά του κελύφους είναι να παίρνει εντολές από το κανάλι εισόδου και να τις εκτελεί. Μερικά κελύφη έχουν ενσωματωμένες λειτουργίες ώστε να βοηθούν στις καθημερινές προγραμματισμένες εργασίες όπως διαχείριση αρχείων, file globbing, επεξεργασία γραμμής εντολών, μακροεντολές, και μεταβλητές περιβάλλοντος. Το FreeBSD διατίθεται με διάφορα κελύφη, όπως το <code>sh</code>, το Bourne Shell και το <code>tcsh</code>, το βελτιωμένο C-shell. Διάφορα άλλα κελύφη είναι διαθέσιμα από την Συλλογή των Ports του FreeBSD, όπως τα <code>zsh</code> και <code>bash</code>.</p></div><div class=paragraph><p>Ποιο κέλυφος να χρησιμοποιήσετε; Είναι πραγματικά θέμα γούστου. Εάν είστε προγραμματιστής σε γλώσσα C θα αισθανθείτε περισσότερο οικείος με τα κελύφη τύπου C, όπως το <code>tcsh</code>. Εάν έρχεστε από το Linux ή είστε νέος σε περιβάλλον γραμμής εντολών UNIX® μπορείτε να δοκιμάσετε το <code>bash</code>. Η ουσία είναι πως κάθε κέλυφος έχει μοναδικές ιδιότητες που μπορεί να συνεργαστούν με το περιβάλλον εργασίας της προτίμησης σας, και επομένως είναι επιλογή σας ποιο κέλυφος να χρησιμοποιήσετε.</p></div><div class=paragraph><p>Μια κοινή ιδιότητα όλων των κελυφών είναι η αυτόματη συμπλήρωση ονομάτων αρχείων. Αφού έχετε πληκτρολογήσει τα πρώτα γράμματα μιας εντολής ή ενός ονόματος αρχείου αν πιέσετε το πλήκτρο <kbd>Tab</kbd> στο πληκτρολόγιο, τότε το κέλυφος αυτόματα θα ολοκληρώσει το υπόλοιπο της εντολής ή του ονόματος αρχείου. Ας δώσουμε ένα παράδειγμα. Ας υποθέσουμε πως έχετε δύο αρχεία <span class=filename>foobar</span> και <span class=filename>foo.bar</span>. Αν θέλετε να σβήσετε το <span class=filename>foo.bar</span> θα πρέπει να πληκτρολογήσετε <code>rm fo[Tab].[Tab]</code>.</p></div><div class=paragraph><p>Το κέλυφος θα τυπώσει αυτόματα <code>rm foo[BEEP].bar</code>.</p></div><div class=paragraph><p>Το [BEEP] είναι το κουδούνι της κονσόλας, το οποίο μας πληροφορεί πως δεν ήταν δυνατόν να ολοκληρώσει το όνομα του αρχείου διότι υπάρχουν περισσότερα από ένα ονόματα αρχείων που ταιριάζουν. Όντως το <span class=filename>foobar</span> και το <span class=filename>foo.bar</span> ξεκινούν με <code>fo</code>, και το κέλυφος κατάφερε να συμπληρώσει ως το <code>foo</code>. Αν πληκτρολογήσετε επιπλέον <code>.</code>, και μετά πάλι <kbd>Tab</kbd>, το κέλυφος θα καταφέρει να συμπληρώσει το υπόλοιπο του ονόματος αρχείου για σας.</p></div><div class=paragraph><p>Άλλο ιδιαίτερο χαρακτηριστικό του κελύφους είναι η χρήση των μεταβλητών περιβάλλοντος. Οι μεταβλητές περιβάλλοντος είναι ένα ζεύγος μεταβλητών/κλειδιών αποθηκευμένα στον περιβάλλοντα χώρο του κελύφους Αυτός ο χώρος μπορεί να διαβαστεί από οποιοδήποτε πρόγραμμα που καλείται από το κέλυφος, και έτσι περιέχει πλήθος ρυθμίσεων προγραμμάτων. Ακολουθεί μία λίστα με συνήθεις μεταβλητές περιβάλλοντος και τη σημασία τους:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Μεταβλητή</th><th class="tableblock halign-left valign-top">Περιγραφή</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>USER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όνομα του τρέχοντα χρήστη.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Λίστα καταλόγων για την αναζήτηση εκτελέσιμων χωρισμένη με άνω-κάτω τελείες.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>DISPLAY</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όνομα δικτύου της οθόνης X11 που είναι διαθέσιμη για σύνδεση, αν υπάρχει.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>SHELL</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το ενεργό κέλυφος.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERM</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το όνομα του τύπου του τερματικού χρήστη. Ορίζει τις δυνατότητες του τερματικού.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERMCAP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Εγγραφή στη βάση δεδομένων κωδικών escape για διάφορες λειτουργίες τερματικών.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>OSTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ο τύπος του λειτουργικού συστήματος π.χ., FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MACHTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η αρχιτεκτονική CPU στην οποία δουλεύει το σύστημα.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>EDITOR</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ο προεπιλεγμένος κειμενογράφος του χρήστη.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PAGER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το προεπιλεγμένο πρόγραμμα σελιδοποίησης του χρήστη.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MANPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Λίστα καταλόγων για την αναζήτηση των σελίδων βοηθείας (man pages) χωρισμένη με άνω-κάτω τελείες.</p></td></tr></tbody></table><div class=paragraph><p>Ο ορισμός μιας μεταβλητής περιβάλλοντος διαφέρει κάπως από κέλυφος σε κέλυφος. Για παράδειγμα στα κελύφη τύπου-C, όπως τα <code>tcsh</code> και <code>csh</code>, θα πρέπει να χρησιμοποιήσετε την <code>setenv</code> για να ορίσετε μεταβλητές περιβάλλοντος. Σε κελύφη Bourne όπως τα <code>sh</code> και <code>bash</code>, θα πρέπει να χρησιμοποιείτε την <code>export</code> για να θέσετε τις τρέχουσες μεταβλητές περιβάλλοντος. Για παράδειγμα, για να ορίσετε ή να μετατρέψετε την μεταβλητή περιβάλλοντος <code>EDITOR</code>, σε <code>csh</code> ή <code>tcsh</code> θα πρέπει να δώσετε μια εντολή που να θέτει τη μεταβλητή <code>EDITOR</code> στο <span class=filename>/usr/local/bin/emacs</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv EDITOR /usr/local/bin/emacs</code></pre></div></div><div class=paragraph><p>Για κελύφη Bourne:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;/usr/local/bin/emacs&#34;</span></code></pre></div></div><div class=paragraph><p>Μπορείτε επίσης στα περισσότερα κελύφη να αναπτύσσετε τις μεταβλητές περιβάλλοντος τοποθετώντας μπροστά τους τον χαρακτήρα <code>$</code>. Για παράδειγμα, η <code>echo $TERM</code> θα τυπώσει την τιμή που έχουμε θέσει στην μεταβλητή, διότι το κέλυφος αναπτύσσει την <code>$TERM</code> και περνά την τιμή της στην <code>echo</code>.</p></div><div class=paragraph><p>Τα κελύφη χρησιμοποιούν μερικούς ειδικούς χαρακτήρες, που ονομάζονται meta-χαρακτήρες για εμφανίσεις ιδιαίτερων δεδομένων. Ο πιο κοινός εξ' αυτών είναι ο χαρακτήρας <code><strong></strong></code><strong>, ο οποίος αντιπροσωπεύει οποιοδήποτε αλφαριθμητικό χαρακτήρα σε ένα όνομα αρχείου. Αυτοί οι ειδικοί meta-χαρακτήρες μπορούν να χρησιμοποιηθούν για να κάνουν filename globbing. Για παράδειγμα, αν πληκτρολογήσετε <code>echo *</code> είναι σχεδόν το ίδιο με το να δώσετε <code>ls</code> διότι το κέλυφος παίρνει όλα τα αρχεία που ταιριάζουν με <code></code></strong> και τα προωθεί στην γραμμή εντολών για την <code>echo</code>.</p></div><div class=paragraph><p>Για να εμποδίσετε το κέλυφος να επεξεργαστεί αυτούς τους ειδικούς χαρακτήρες, μπορείτε να χρησιμοποιήσετε το σύμβολο διαφυγής (escape) τοποθετώντας μπροστά τους μια δεξιόστροφη κάθετο (<code>\</code>). Η <code>echo $TERM</code> τυπώνει τον τύπο του τερματικού σας, ενώ η <code>echo \$TERM</code> τυπώνει απλά <code>$TERM</code>.</p></div><div class=sect3><h4 id=changing-shells>5.9.1. Αλλάζοντας το Κέλυφος σας<a class=anchor href=#changing-shells></a></h4><div class=paragraph><p>Ο ευκολότερος τρόπος για να αλλάξετε το κέλυφος σας είναι να χρησιμοποιήσετε την εντολή <code>chsh</code>. Τρέχοντας την <code>chsh</code> θα οδηγηθείτε στον κειμενογράφο που έχετε θέσει στην μεταβλητή περιβάλλοντος <code>EDITOR</code>, ενώ αν δεν έχετε θέσει, θα οδηγηθείτε στο <code>vi</code>. Αλλάξτε κατάλληλα τη γραμμή "Shell:"</p></div><div class=paragraph><p>Μπορείτε επίσης να δώσετε στην <code>chsh</code> την επιλογή <code>-s</code>, αυτή θα θέσει το κέλυφος για σας, δίχως να χρειαστεί να χρησιμοποιήσετε τον κειμενογράφο. Για παράδειγμα, αν θέλετε να αλλάξετε το κέλυφος σας σε <code>bash</code>, η ακόλουθη εντολή είναι ακριβώς αυτό που χρειάζεστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% chsh <span class=nt>-s</span> /usr/local/bin/bash</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το κέλυφος στο οποίο επιθυμείτε να μεταβείτε <em>πρέπει</em> να είναι καταχωρημένο στο αρχείο <span class=filename>/etc/shells</span>. Αν έχετε εγκαταστήσει ένα κέλυφος από τη <a href=./#ports>συλλογή των ports</a>, τότε αυτό θα πρέπει να έχει ήδη γίνει. Αν εγκαταστήσατε το κέλυφος μόνοι σας, τότε θα πρέπει να εκτελέσετε τη διαδικασία που ακολουθεί.</p></div><div class=paragraph><p>Αν για παράδειγμα, εγκαταστήσατε το <code>bash</code> μόνοι σας και το τοποθετήσατε στον <span class=filename>/usr/local/bin</span>, τότε θα πρέπει να δώσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;/usr/local/bin/bash&#34; &gt;&gt; /etc/shells</span></code></pre></div></div><div class=paragraph><p>Και μετά ξανατρέξτε την <code>chsh</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=editors>5.10. Κειμενογράφοι<a class=anchor href=#editors></a></h3><div class=paragraph><p>Αρκετές ρυθμίσεις στο FreeBSD γίνονται με επεξεργασία αρχείων κειμένου. Για αυτό το λόγο, θα ήταν καλή ιδέα να εξοικειωθείτε με ένα κειμενογράφο. Αρκετοί περιέχονται στο βασικό σύστημα του FreeBSD και πολλοί περισσότεροι είναι διαθέσιμοι στην Συλλογή των Ports (Ports Collection).</p></div><div class=paragraph><p>Ο ευκολότερος και απλούστερος κειμενογράφος για να μάθετε ονομάζεται ee, που σημαίνει easy editor (εύκολος κειμενογράφος). Για να ξεκινήσετε τον ee, πρέπει να πληκτρολογήσετε στην γραμμή εντολών <code>ee filename</code> όπου <em>filename</em> είναι το όνομα του αρχείου που θέλετε να επεξεργαστείτε. Για παράδειγμα, για να επεξεργαστείτε το <span class=filename>/etc/rc.conf</span>, πληκτρολογείτε <code>ee /etc/rc.conf</code>. Μόλις εισέλθετε στο <code>ee</code>, όλες οι εντολές για να χειριστείτε τις λειτουργίες του κειμενογράφου αναφέρονται στο πάνω μέρος της οθόνης. Ο χαρακτήρας καπέλο <code>^</code> σημαίνει το πλήκτρο <kbd>Ctrl</kbd>, επομένως <code>^e</code> σημαίνει πως πρέπει να πληκτρολογήσετε τον συνδυασμό πλήκτρων <span class=keyseq><kbd>Ctrl</kbd>+<kbd>e</kbd></span>. Για να βγείτε από το ee, πιέζετε το πλήκτρο <kbd>Esc</kbd>, και επιλέγετε leave editor. Ο κειμενογράφος θα σας προτρέψει να σώσετε τυχόν αλλαγές, αν έχετε επεξεργαστεί το αρχείο.</p></div><div class=paragraph><p>Το FreeBSD παρέχεται επίσης με πιο εξελιγμένους κειμενογράφους όπως το ενσωματωμένο στο βασικό σύστημα vi. Το Emacs και το vim, είναι μέρος της Συλλογής των Ports του FreeBSD (<a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> και <a class=package href=https://cgit.freebsd.org/ports/tree/editors/vim/>editors/vim</a>). Αυτοί οι κειμενογράφοι προσφέρουν πολλές περισσότερες λειτουργίες και δυνατότητες, με κόστος αυξημένη πολυπλοκότητα και δυσκολία εκμάθησης. Ωστόσο αν σχεδιάζετε να επεξεργαστείτε αρκετά κείμενα, η εκμάθηση ενός ισχυρού κειμενογράφου όπως το vim ή το Emacs θα σας γλυτώσει πολύ περισσότερο χρόνο επεξεργασίας στην πορεία.</p></div><div class=paragraph><p>Πολλές εφαρμογές που χρειάζεται να αλλάξουν κάποιο αρχείο ή απαιτούν από το χρήστη να πληκτρολογήσει κάποιο κείμενο, θα ανοίξουν αυτόματα κάποιο κειμενογράφο. Για να αλλάξετε τον προεπιλεγμένο κειμενογράφο, θα πρέπει να θέσετε κατάλληλη τιμή στην μεταβλητή περιβάλλοντος <code>EDITOR</code>. Δείτε την ενότητα <a href=#shells>Κελύφη</a> για περισσότερες λεπτομέρειες.</p></div></div><div class=sect2><h3 id=basics-devices>5.11. Συσκευές και Αρχεία συσκευών<a class=anchor href=#basics-devices></a></h3><div class=paragraph><p>Συσκευή είναι ένας όρος που αναφέρεται σε σχέση με λειτουργίες hardware ενός συστήματος, περιλαμβάνοντας δίσκους, εκτυπωτές, κάρτες γραφικών και πληκτρολόγια. Κατά την εκκίνηση του FreeBSD οι περισσότερες πληροφορίες που αναγράφονται στην οθόνη είναι συσκευές που αναγνωρίζονται από το σύστημα. Μπορείτε να ξαναδείτε τα μηνύματα εκκίνησης, διαβάζοντας το <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class=paragraph><p>Για παράδειγμα, <span class=filename>acd0</span> είναι ο πρώτος οδηγός IDE CDROM, ενώ το <span class=filename>kbd0</span> αντιπροσωπεύει το πληκτρολόγιο.</p></div><div class=paragraph><p>Στις περισσότερες από αυτές τις συσκευές σε ένα λειτουργικό σύστημα UNIX® η πρόσβαση πρέπει να γίνεται διαμέσου ειδικών αρχείων που ονομάζονται αρχεία συσκευών, και είναι τοποθετημένα στον κατάλογο <span class=filename>/dev</span>.</p></div><div class=sect3><h4 id=_δημιουργώντας_αρχεία_συσκευών>5.11.1. Δημιουργώντας Αρχεία Συσκευών<a class=anchor href=#_δημιουργώντας_αρχεία_συσκευών></a></h4><div class=paragraph><p>Όταν προσθέτετε μια νέα συσκευή στο σύστημα σας, ή μεταγλωττίζετε πηγαίο κώδικα για υποστήριξη νέων οδηγών, πρέπει να δημιουργούνται νέα αρχεία συσκευών.</p></div><div class=sect4><h5 id=_devfs_device_file_system>5.11.1.1. <code>DEVFS</code> (DEVice File System)<a class=anchor href=#_devfs_device_file_system></a></h5><div class=paragraph><p>Το σύστημα αρχείων συσκευών ή, <code>DEVFS</code>, παρέχει πρόσβαση στο χώρο ονομάτων συσκευών του πυρήνα (device namespace) στο global σύστημα αρχείων του συστήματος. Αντί να δημιουργείτε και να μετατρέπετε αρχεία συσκευών, το <code>DEVFS</code> συντηρεί για σας αυτό το ιδιαίτερο σύστημα αρχείων.</p></div><div class=paragraph><p>Δείτε την σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> για περισσότερες πληροφορίες.</p></div></div></div></div><div class=sect2><h3 id=binary-formats>5.12. Τύποι Εκτελέσιμων<a class=anchor href=#binary-formats></a></h3><div class=paragraph><p>Για να καταλάβετε γιατί το FreeBSD χρησιμοποιεί τον τύπο <a href="https://man.freebsd.org/cgi/man.cgi?query=elf&amp;sektion=5&amp;format=html">elf(5)</a> θα πρέπει πρώτα να γνωρίζετε μερικά πράγματα για τους τρεις "κυρίαρχους" τύπους εκτελέσιμων για το UNIX®</p></div><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a></p><div class=paragraph><p>Ο παλαιότερος και πιο "κλασσικός" τύπος αντικειμένων του UNIX®. Χρησιμοποιεί μια μικρή και συμπαγή κεφαλίδα με ένα μαγικό νούμερο στην αρχή που συχνά χρησιμοποιείται για να χαρακτηρίζει τον τύπο (δείτε για περισσότερες πληροφορίες την <a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a>). Περιέχει τρία φορτωμένα τμήματα: .text, .data και .bss και επιπλέον ένα πίνακα συμβόλων και ένα πίνακα αλφαριθμητικών χαρακτήρων.</p></div></li><li><p>COFF</p><div class=paragraph><p>Ο τύπος αντικειμένου SVR3. Η κεφαλίδα τώρα αποτελείται από ένα πίνακα τομέων, ώστε να μπορούμε να έχουμε κάτι παραπάνω από απλά .text, .data και .bss.</p></div></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=elf&amp;sektion=5&amp;format=html">elf(5)</a></p><div class=paragraph><p>Ο διάδοχος του COFF, περιλαμβάνει πολλαπλά τμήματα και δέχεται τιμές 32 ή 64 bit. Το βασικό μειονέκτημα: Ο ELF σχεδιάστηκε με την προϋπόθεση πως θα υπήρχε μόνο ένα ABI για κάθε αρχιτεκτονική συστήματος. Αυτή η υπόθεση είναι όμως εσφαλμένη τώρα, αφού ακόμη και στον εμπορικό κόσμο του SYSV (όπου υπάρχουν τουλάχιστον τρία ABI: SRV4, Solaris, SCO) δεν ισχύει.</p></div><div class=paragraph><p>Το FreeBSD προσπαθεί να ξεπεράσει αυτό το πρόβλημα παρέχοντας ένα βοηθητικό πρόγραμμα με το οποίο μπορούμε να <em>ενσωματώσουμε (branding)</em> σε ένα εκτελέσιμο ELF τις πληροφορίες για το ABI που είναι συμβατό με αυτό. Δείτε την σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> για περισσότερες πληροφορίες.</p></div></li></ul></div><div class=paragraph><p>Το FreeBSD προέρχεται από τον "κλασσικό" χώρο και μέχρι την αρχή της σειράς 3.X, χρησιμοποιούσε τον τύπο <a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a>, μια τεχνολογία δοκιμασμένη και αποδεδειγμένη σε πολλές γενιές εκδόσεων του BSD. Αν και η μεταγλώττιση και εκτέλεση εγγενών εκτελέσιμων (και πυρήνων) τύπου ELF ήταν δυνατή στα FreeBSD συστήματα ήδη από πολύ καιρό πριν, το FreeBSD αρχικά αντιστάθηκε στην "ώθηση" για καθιέρωση του ELF ως προκαθορισμένου τύπου. Γιατί; Όταν ο κόσμος του Λίνουξ έκανε την οδυνηρή μετάβαση προς το ELF, δεν ήταν τόσο για να ξεφύγει από τον τύπο εκτελέσιμων <span class=filename>a.out</span> όσο για να αντιμετωπίσει το δύσκαμπτο δικό τους μηχανισμό κοινόχρηστων βιβλιοθηκών, ο οποίος βασίζονταν σε jump-tables και προκαλούσε μεγάλη δυσχέρεια στην κατασκευή τους, τόσο στους προγραμματιστές όσο και στους μεταπωλητές. Από τη στιγμή που τα διαθέσιμα εργαλεία του ELF προσέφεραν λύση στο πρόβλημα των κοινών βιβλιοθηκών και έγινε γενικώς αποδεκτό πως ήταν "ο δρόμος προς τα εμπρός", έγινε αποδεκτό το αναγκαίο κόστος της μεταφοράς και επιτεύχθηκε η μετακίνηση. Ο μηχανισμός κοινόχρηστων βιβλιοθηκών του FreeBSD βασίζεται σε μεγάλο βαθμό στον αντίστοιχο μηχανισμό του SunOS™ της Sun και είναι πολύ εύκολος στη χρήση.</p></div><div class=paragraph><p>Τότε, γιατί υπάρχουν τόσοι διαφορετικοί τύποι;</p></div><div class=paragraph><p>Πίσω στο σκοτεινό παρελθόν, υπήρχε απλό hardware. Αυτό το απλό hardware υποστήριζε ένα απλό, μικρό σύστημα. Το <span class=filename>a.out</span> ήταν απόλυτα κατάλληλο για την αναπαράσταση εκτελέσιμων σε αυτό το απλό σύστημα (ένα PDP-11). Όταν ο κόσμος άρχισε να μεταφέρει το UNIX® από αυτό το απλό σύστημα, διατηρήθηκε ο τύπος <span class=filename>a.out</span> γιατί ήταν ικανοποιητικός για τα πρώτα ports του UNIX® σε αρχιτεκτονικές όπως η Motorola 68k, VAXen, κτλ.</p></div><div class=paragraph><p>Μετέπειτα κάποιος λαμπρός μηχανικός hardware αποφάσισε πως αφού μπορούσε να εξαναγκάζει το λογισμικό να κάνει τόσα πρόχειρα κόλπα, θα μπορούσε επίσης να παραλείψει μερικές πύλες από το σχεδιασμό ώστε να επιτρέψει στον πυρήνα της CPU να τρέχει γρηγορότερα. Αν και διασκευάσθηκε ώστε να δουλεύει με αυτό το νέο είδος hardware (γνωστό σήμερα ως RISC), ο τύπος <span class=filename>a.out</span> ήταν τελικά ακατάλληλος για αυτό, και έτσι σχεδιάστηκαν πολλοί νέοι τύποι για να επιτευχθεί καλύτερη απόδοση από το hardware από ότι ήταν δυνατόν με τον απλό και περιοριστικό τύπο <span class=filename>a.out</span>. Εφευρέθηκαν διάφοροι τύποι όπως οι COFF, ECOFF, και μερικοί άλλοι λιγότερο γνωστοί, και ερευνήθηκαν οι περιορισμοί τους ώσπου τα πράγματα σταθεροποιήθηκαν στο ELF.</p></div><div class=paragraph><p>Επιπλέον, το μέγεθος των προγραμμάτων γινόταν όλο και μεγαλύτερο και οι δίσκοι (και η φυσική μνήμη) ήταν ακόμη σχετικά μικροί και κάπως έτσι γεννήθηκε η ιδέα της κοινής βιβλιοθήκης. Το σύστημα VM έγινε επίσης περισσότερο περίπλοκο. Κάθε μία από τις βελτιώσεις γινόταν με βάση τον τύπο <span class=filename>a.out</span>, που όμως γινόταν όλο και πιο δύσχρηστος με κάθε νέα προσθήκη. Επιπρόσθετα, ο κόσμος ήθελε να φορτώνει τμήματα δυναμικά ενώ το σύστημα ήταν σε φάση εκτέλεσης, ή να εξαλείφει μέρη προγραμμάτων αφού είχε εκτελεστεί ο κώδικας αρχικοποίησης (init) ώστε να εξοικονομηθεί φυσική μνήμη και χώρος swap. Οι γλώσσες προγραμματισμού γινόντουσαν ακόμα πιο περίπλοκες και ο κόσμος ήθελε αυτόματη φόρτωση και εκτέλεση κώδικα πριν την κλήση της main. Έγιναν πρόχειρες διορθώσεις (hacks) στον τύπο <span class=filename>a.out</span> ώστε να συμβαδίζει με όλες αυτές τις αλλαγές, και πράγματι, για μια περίοδο έδειχνε να λειτουργεί. Με τον καιρό όμως, φάνηκε ότι ο τύπος <span class=filename>a.out</span> δεν θα μπορούσε να αντεπεξέλθει σε όλα αυτά τα προβλήματα, αφού θα έπρεπε να αναπτύσσεται συνεχώς και με περίπλοκο τρόπο. Αν και το ELF έλυνε πολλά από αυτά τα προβλήματα, η μετάβαση σε αυτό ενός συστήματος που βασικά λειτουργούσε, θα οδηγούσε σε οδυνηρές καταστάσεις. Έτσι ο τύπος ELF έπρεπε να περιμένει μέχρι τη στιγμή όπου η παραμονή στο <span class=filename>a.out</span> θα δημιουργούσε περισσότερα προβλήματα από ότι η μετάβαση στο ELF.</p></div><div class=paragraph><p>Ωστόσο, όσο ο καιρός περνούσε, και τα εργαλεία μεταγλώττισης από τα οποία προέρχονται τα αντίστοιχα εργαλεία του FreeBSD (ειδικότερα ο assembler και ο loader), αναπτύχθηκαν παράλληλα σε δύο δέντρα. Το δέντρο του FreeBSD πρόσθεσε κοινές βιβλιοθήκες και διόρθωσε κάποια σφάλματα. Η ομάδα του GNU που είχε αρχικά γράψει αυτά τα προγράμματα, τα έγραψε ξανά και πρόσθεσε ευκολότερη υποστήριξη για κατασκευή cross compilers, την ενσωμάτωση διαφορετικών τύπων κατά βούληση, κλπ. Αν και πολλοί ζητούσαν να κατασκευαστούν cross compilers για FreeBSD, ήταν άτυχοι, αφού ο παλιός πηγαίος κώδικας του FreeBSD για τα as και ld τα έκανε ακατάλληλα. Η νέα αλυσίδα εργαλείων του GNU (binutils) υποστηρίζει cross compiling, ELF, κοινές βιβλιοθήκες, προεκτάσεις C++, κτλ. Επιπλέον, πολλοί τρίτοι κατασκευαστές προσφέρουν εκτελέσιμα ELF, και είναι πολύ καλό να μπορούν να εκτελεστούν στο FreeBSD.</p></div><div class=paragraph><p>Ο ELF είναι πιο εκφραστικός από τον <span class=filename>a.out</span> και περισσότερο επεκτάσιμος στο βασικό σύστημα. Τα εργαλεία ELF είναι ευκολότερα στην συντήρηση και προσφέρουν υποστήριξη για cross compilers, κάτι που είναι πολύ σημαντικό για μερικούς ανθρώπους. Μπορεί ο ELF να είναι λίγο πιο αργός από τον <span class=filename>a.out</span>, αλλά η διαφορά δεν είναι αισθητή. Υπάρχουν επίσης πολλές άλλες διαφορές μεταξύ τους, σε λεπτομέρειες όπως τον τρόπο που αντιστοιχίζουν σελίδες, που χειρίζονται τον κώδικα init, κλπ. Καμιά από αυτές δεν είναι πολύ σημαντική, αλλά ωστόσο δεν παύουν να είναι διαφορές. Με τον καιρό η υποστήριξη για το <span class=filename>a.out</span> θα απομακρυνθεί από τον πυρήνα GENERIC, και τελικά θα αφαιρεθεί εντελώς από τον πυρήνα όταν εκλείψει ολοκληρωτικά η ανάγκη εκτέλεσης παλαιών προγραμμάτων τύπου <span class=filename>a.out</span>.</p></div></div><div class=sect2><h3 id=basics-more-information>5.13. Για Περισσότερες Πληροφορίες<a class=anchor href=#basics-more-information></a></h3><div class=sect3><h4 id=basics-man>5.13.1. Σελίδες Βοηθείας<a class=anchor href=#basics-man></a></h4><div class=paragraph><p>Η πιο κατανοητή τεκμηρίωση στο FreeBSD προσφέρεται με τη μορφή των σελίδων βοηθείας (manual pages). Σχεδόν για κάθε πρόγραμμα του συστήματος δίνεται μια σύντομη αναφορά που εξηγεί τις βασικές λειτουργίες και διάφορα άλλα θέματα. Αυτές οι σελίδες προβάλλονται με την εντολή <code>man</code>. Η χρήση της εντολής <code>man</code> είναι απλή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>command</span></code></pre></div></div><div class=paragraph><p>όπου <code>command</code> είναι το όνομα της εντολής για την οποία επιθυμείτε να μάθετε περισσότερες πληροφορίες. Για παράδειγμα, για να μάθετε περισσότερα για την εντολή <code>ls</code> πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>Το online manual χωρίζεται σε τέσσερις αριθμημένες ενότητες:</p></div><div class="olist arabic"><ol class=arabic><li><p>Εντολές χρήστη.</p></li><li><p>Κλήσεις συστήματος και αριθμοί σφαλμάτων.</p></li><li><p>Συναρτήσεις των βιβλιοθηκών της C.</p></li><li><p>Οδηγοί συσκευών.</p></li><li><p>Τύποι αρχείων.</p></li><li><p>Παιχνίδια και άλλες εφαρμογές διασκέδασης.</p></li><li><p>Διάφορες πληροφορίες.</p></li><li><p>Συντήρηση συστήματος και εντολές λειτουργίας.</p></li><li><p>Ανάπτυξη πυρήνα.</p></li></ol></div><div class=paragraph><p>Σε μερικές περιπτώσεις, το ίδιο θέμα μπορεί να εμφανίζεται σε περισσότερες ενότητες των σελίδων βοηθείας. Για παράδειγμα, υπάρχει η εντολή χρήστη <code>chmod</code> και η κλήση συστήματος <code>chmod()</code>. Σε αυτή τη περίπτωση, μπορείτε να πείτε στην εντολή <code>man</code> ποια ακριβώς θέλετε επιλέγοντας την ενότητα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man 1 <span class=nb>chmod</span></code></pre></div></div><div class=paragraph><p>Με αυτόν τον τρόπο θα εμφανιστεί η σελίδα βοηθείας για την εντολή χρήστη <code>chmod</code>. Οι αναφορές σε μια ειδική ενότητα των σελίδων βοηθείας τοποθετούνται παραδοσιακά μέσα σε παρένθεση στην τυπωμένη τεκμηρίωση, επομένως το <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> αναφέρεται στην εντολή χρήστη <code>chmod</code> και το <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> αναφέρεται στην κλήση συστήματος.</p></div><div class=paragraph><p>Αυτό είναι χρήσιμο όταν γνωρίζουμε το όνομα της εντολής και απλά επιθυμούμε να μάθουμε πως να την χρησιμοποιήσουμε, αλλά τι γίνεται αν δεν γνωρίζουμε το όνομα της; Μπορείτε να χρησιμοποιήσετε το <code>man</code> για να αναζητήσετε λέξεις κλειδιά από τις περιγραφές των εντολών χρησιμοποιώντας την επιλογή <code>-k</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nt>-k</span> mail</code></pre></div></div><div class=paragraph><p>Με την εντολή αυτή θα εμφανιστεί μία λίστα από εντολές που περιέχουν την λέξη κλειδί "mail" στην περιγραφή τους. Αυτό είναι αντίστοιχο με το να χρησιμοποιήσετε την εντολή <code>apropos</code>.</p></div><div class=paragraph><p>Επομένως, βλέπετε όλες αυτές τις γουστόζικες εντολές στον <span class=filename>/usr/bin</span> αλλά δεν έχετε την παραμικρή ιδέα του τι πραγματικά κάνουν; Απλά πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% man <span class=nt>-f</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>ή</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% whatis <span class=k>*</span></code></pre></div></div><div class=paragraph><p>το οποίο κάνει ακριβώς το ίδιο πράγμα.</p></div></div><div class=sect3><h4 id=basics-info>5.13.2. GNU Info Files<a class=anchor href=#basics-info></a></h4><div class=paragraph><p>Το FreeBSD περιλαμβάνει πολλές εφαρμογές και βοηθητικά προγράμματα που έχουν δημιουργηθεί από την Free Software Foundation (FSF). Πέρα από τις σελίδες βοηθείας, τα προγράμματα αυτά παρέχονται με τεκμηρίωση μορφής hypertext σε αρχεία που ονομάζονται <code>info</code> και τα οποία μπορείτε να προβάλλετε με την εντολή <code>info</code> ή, αν έχετε εγκαταστήσει το emacs, μέσω της κατάστασης λειτουργίας info mode του emacs.</p></div><div class=paragraph><p>Για να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a>, απλά πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% info</code></pre></div></div><div class=paragraph><p>Για μια σύντομη εισαγωγή, πληκτρολογήστε <code>h</code>. Για μια γρήγορη αναφορά εντολής, πληκτρολογήστε <code>?</code>.</p></div></div></div></div></div><div class=sect1><h2 id=ports>Chapter 6. Εγκατάσταση Εφαρμογών: Πακέτα και Ports<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-synopsis>6.1. Σύνοψη<a class=anchor href=#ports-synopsis></a></h3><div class=paragraph><p>Το FreeBSD συνοδεύεται από μία πλούσια συλλογή από προγράμματα σαν μέρος του βασικού συστήματος. Όμως, λίγα μπορεί να κάνει κάποιος πριν βρεθεί στην ανάγκη να εγκαταστήσει μια πρόσθετη εφαρμογή για να υλοποιήσει μια πραγματική εργασία. Το FreeBSD παρέχει δυο συμπληρωματικές τεχνολογίες για να εγκαταστήσετε πρόσθετες εφαρμογές στο σύστημα σας: τη Συλλογή των Ports (Ports Collection, για εγκατάσταση από τον πηγαίο κώδικα), και τα πακέτα (packages, για εγκατάσταση από προ-μεταγλωττισμένα εκτελέσιμα πακέτα). Κάθε μία από τις δυο μεθόδους μπορεί να χρησιμοποιηθεί για να εγκαταστήσετε τις νεότερες εκδόσεις από τις αγαπημένες σας εφαρμογές, από τοπικά αποθηκευτικά μέσα ή απευθείας από το δίκτυο.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να εγκαθιστάτε προ-μεταγλωττισμένα πακέτα λογισμικού.</p></li><li><p>Πως να μεταγλωττίζετε πρόσθετο λογισμικό από τον πηγαίο κώδικα χρησιμοποιώντας την Συλλογή των Ports.</p></li><li><p>Πως να κάνετε απεγκατάσταση εγκαταστημένων πακέτων ή ports.</p></li><li><p>Πως να αλλάζετε τις προκαθορισμένες ρυθμίσεις που χρησιμοποιεί η Συλλογή των Ports.</p></li><li><p>Πως να βρίσκετε τα κατάλληλα πακέτα λογισμικού.</p></li><li><p>Πως να αναβαθμίζετε τις εφαρμογές σας.</p></li></ul></div></div><div class=sect2><h3 id=ports-overview>6.2. Επισκόπησή της εγκατάστασης λογισμικού<a class=anchor href=#ports-overview></a></h3><div class=paragraph><p>Αν έχετε χρησιμοποιήσει ένα UNIX® σύστημα στο παρελθόν, θα γνωρίζετε ότι η συνηθισμένη διαδικασία για την εγκατάσταση πρόσθετου λογισμικού είναι περίπου η παρακάτω:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>"Κατέβασμα" του λογισμικού, που μπορεί να διανέμεται σε μορφή πηγαίου κώδικα, ή σαν εκτελέσιμο.</p></li><li><p>Αποσυμπίεση του λογισμικού από την μορφή της διανομής του (συνήθως ένα tarball συμπιεσμένο με το <a href="https://man.freebsd.org/cgi/man.cgi?query=compress&amp;sektion=1&amp;format=html">compress(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, ή <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a>).</p></li><li><p>Εντοπισμός της τεκμηρίωσης (πιθανώς ένα αρχείο <span class=filename>INSTALL</span> ή <span class=filename>README</span> ή μερικά αρχεία μέσα σε ένα υποκατάλογο <span class=filename>doc/</span>) και ανάγνωσή τους για το πως θα εγκατασταθεί το λογισμικό.</p></li><li><p>Αν το λογισμικό διανέμεται με τη μορφή πηγαίου κώδικα, μεταγλώττιση του. Αυτό μπορεί να περιλαμβάνει την επεξεργασία ενός <span class=filename>Makefile</span>, ή την εκτέλεση ενός <code>configure</code> script, και άλλες εργασίες.</p></li><li><p>Δοκιμή και εγκατάσταση του λογισμικού.</p></li></ol></div><div class=paragraph><p>Και αυτά μόνο αν όλα πάνε καλά. Αν εγκαθιστάτε ένα λογισμικό που δεν έχει μεταφερθεί στο FreeBSD ίσως να πρέπει να τροποποιήσετε τον πηγαίο κώδικα για να δουλέψει σωστά.</p></div><div class=paragraph><p>Αν το θέλετε, μπορείτε να συνεχίσετε να εγκαθιστάτε λογισμικό με τον "παραδοσιακό" τρόπο στο FreeBSD. Όμως, το FreeBSD παρέχει δυο τεχνολογίες που μπορούν να σας γλιτώσουν από πολύ κόπο: τα πακέτα και τα ports. Την στιγμή που γράφτηκε αυτό το κείμενο, διατίθονταν με αυτόν τον τρόπο πάνω από 36000 πρόσθετες εφαρμογές.</p></div><div class=paragraph><p>Για οποιαδήποτε εφαρμογή, το αντίστοιχο FreeBSD πακέτο της είναι ένα μοναδικό αρχείο που πρέπει εσείς να "κατεβάσετε". Το πακέτο περιέχει προ-μεταγλωττισμένα αντίγραφα από όλες τις εντολές της εφαρμογής, όπως επίσης και αρχεία παραμετροποίησης ή τεκμηρίωσης. Ένα τέτοιο πακέτο σε μορφή αρχείου, μπορείτε να το χειριστείτε με τις εντολές διαχείρισής πακέτων του FreeBSD, όπως οι <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a>, και πάει λέγοντας. Η εγκατάσταση μιας νέας εφαρμογής μπορεί να γίνει με μία μόνο εντολή.</p></div><div class=paragraph><p>Ένα FreeBSD port για μία εφαρμογή είναι μια συλλογή από αρχεία σχεδιασμένα για να αυτοματοποιήσουν την διαδικασία μεταγλώττισης της εφαρμογής από τον πηγαίο κώδικα.</p></div><div class=paragraph><p>Θυμηθείτε ότι υπάρχουν μερικά βήματα που θα πρέπει λογικά να κάνετε αν μεταγλωττίσετε ένα πρόγραμμα μόνος σας ("κατέβασμα", αποσυμπίεση, προσαρμογή (patching), μεταγλώττιση, εγκατάσταση). Τα αρχεία που αποτελούν ένα port περιέχουν όλες τις απαραίτητες πληροφορίες για να επιτρέψουν στο σύστημα να κάνει όλα αυτά για εσάς. Εσείς εκτελείτε μερικές απλές εντολές, και ο πηγαίος κώδικας για την εφαρμογή αυτόματα "κατεβαίνει", αποσυμπιέζεται, προσαρμόζεται, μεταγλωττίζεται, και εγκαθίσταται για εσάς.</p></div><div class=paragraph><p>Στην πραγματικότητα, το σύστημα ports μπορεί επίσης να χρησιμοποιηθεί για να δημιουργηθούν πακέτα που μπορείτε αργότερα να διαχειριστείτε με την <code>pkg_add</code> και τις άλλες εντολές διαχείρισής πακέτων που θα αναφερθούν σε λίγο.</p></div><div class=paragraph><p>Τόσο τα πακέτα, όσο και τα ports κατανοούν τις <em>εξαρτήσεις (dependencies)</em>. Ας υποθέσουμε ότι θέλετε να εγκαταστήσετε μία εφαρμογή που εξαρτάται από μία συγκεκριμένη βιβλιοθήκη για να λειτουργήσει. Τόσο η εφαρμογή, όσο και η βιβλιοθήκη διατίθενται ως πακέτα και ports του FreeBSD. Αν χρησιμοποιήσετε την εντολή <code>pkg_add</code> ή το σύστημα των ports για να εγκαταστήσετε την εφαρμογή, αμφότερα θα παρατηρήσουν ότι η βιβλιοθήκη δεν είναι εγκατεστημένη, και αυτόματα θα την εγκαταστήσουν πριν από το πρόγραμμα.</p></div><div class=paragraph><p>Έχοντας αναφέρει ότι οι δύο τεχνολογίες είναι αρκετά όμοιες, ίσως να αναρωτιέστε γιατί το FreeBSD προσφέρει και τις δύο. Τα πακέτα και τα ports αμφότερα έχουν τα δικά τους πλεονεκτήματα, και το τι θα χρησιμοποιήσετε εξαρτάται από την δική σας προτίμηση.</p></div><div class=ulist><div class=title>Πλεονεκτήματα των Πακέτων</div><ul><li><p>Ένα συμπιεσμένο tarball πακέτου είναι συνήθως μικρότερο από το συμπιεσμένο tarball που περιέχει τον πηγαίο κώδικα για την εφαρμογή.</p></li><li><p>Τα πακέτα δεν χρειάζονται μεταγλώττιση. Για μεγάλες εφαρμογές, όπως είναι ο Mozilla, το KDE, ή το GNOME αυτό μπορεί να είναι σημαντικό, ιδιαίτερα αν βρίσκεστε σε ένα αργό μηχάνημα.</p></li><li><p>Τα πακέτα δεν απαιτούν να κατανοήσετε την διαδικασία που σχετίζεται με την μεταγλώττιση λογισμικού στο FreeBSD.</p></li></ul></div><div class=ulist><div class=title>Πλεονεκτήματα των Ports</div><ul><li><p>Τα πακέτα συνήθως είναι μεταγλωττισμένα με συντηρητικές επιλογές, επειδή πρέπει να λειτουργούν στον μέγιστο αριθμό συστημάτων. Με εγκατάσταση από το port, μπορείτε να ρυθμίσετε τις επιλογές μεταγλώττισης (για παράδειγμα) να δημιουργήσουν εκτελέσιμο κώδικα που να εκμεταλλεύεται τις ικανότητες ενός Pentium 4 ή Athlon επεξεργαστή.</p></li><li><p>Μερικές εφαρμογές έχουν επιλογές μεταγλώττισης που σχετίζονται με το τι μπορούν να κάνουν και τι όχι. Για παράδειγμα, ο Apache μπορεί να μεταγλωττιστεί με ένα ευρύ φάσμα από επιλογές. Μεταγλωττίζοντας τον από το port, δεν είναι ανάγκη να δεχτείτε τις προεπιλεγμένες επιλογές, μπορείτε να κάνετε τις δικές σας.</p><div class=paragraph><p>Σε μερικές περιπτώσεις, μπορεί να υπάρχουν πολλαπλά πακέτα για την ίδια εφαρμογή, με διαφορετικές ρυθμίσεις. Για παράδειγμα, το Ghostscript διατίθεται ως ένα πακέτο <span class=filename>ghostscript</span> και ένα πακέτο <span class=filename>ghostscript-nox11</span>, αναλόγως αν θα εγκαταστήσετε ή όχι έναν X11 server. Αυτού του τύπου οι ρυθμίσεις είναι δυνατές με τα πακέτα, αλλά γρήγορα γίνονται αδύνατες αν μία εφαρμογή έχει περισσότερες από μία ή δύο διαφορετικές ρυθμίσεις μεταγλώττισης.</p></div></li><li><p>Οι συνθήκες των αδειών διανομής από μερικές διανομές λογισμικού, απαγορεύουν την διανομή εκτελέσιμου κώδικα. Πρέπει να διανεμηθούν με την μορφή πηγαίου κώδικα.</p></li><li><p>Μερικά άτομα δεν εμπιστεύονται τα έτοιμα εκτελέσιμα. Τουλάχιστον με τον πηγαίο κώδικα, μπορείτε (θεωρητικά) να τον διαβάσετε και να ψάξετε για πιθανά προβλήματα μόνος σας.</p></li><li><p>Αν έχετε τοπικά, δικά σας patches, θα χρειαστείτε τον πηγαίο κώδικα για να τα εφαρμόσετε.</p></li><li><p>Μερικά άτομα γουστάρουν να έχουν τον πηγαίο κώδικα, ώστε να τον διαβάσουν αν βαρεθούνε, να τον αλλάξουν (hack), να δανειστούν από αυτόν (αν βέβαια το επιτρέπει η άδεια), κ.λ.π.</p></li></ul></div><div class=paragraph><p>Για να είστε ενήμερος για τα ανανεωμένα ports, εγγραφείτε στην <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>ηλεκτρονική λίστα των FreeBSD ports</a> και στην <a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>ηλεκτρονική λίστα αναφορών προβλημάτων των FreeBSD ports</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Πριν εγκαταστήσετε οποιοδήποτε εφαρμογή, πρέπει να ελέγχετε το <a href=http://vuxml.freebsd.org/>http://vuxml.freebsd.org/</a> για θέματα ασφαλείας που σχετίζονται με την εφαρμογή σας.</p></div><div class=paragraph><p>Μπορείτε επίσης να εγκαταστήσετε το <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portaudit/>ports-mgmt/portaudit</a> το οποίο αυτόματα θα ελέγχει όλες τις εγκαταστημένες εφαρμογές για γνωστά τρωτά σημεία. Έλεγχος επίσης θα πραγματοποιείται πριν τη μεταγλώττιση οποιουδήποτε port. Στο ενδιάμεσο, μπορείτε να χρησιμοποιείτε την εντολή <code>portaudit -F -a</code> αφότου έχετε πρώτα εγκαταστήσει μερικά πακέτα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το υπόλοιπο αυτού του κεφαλαίου εξηγεί πως να χρησιμοποιήσετε τα πακέτα και τα ports για να εγκαταστήσετε και να διαχειριστείτε πρόσθετο λογισμικό στο FreeBSD.</p></div></div><div class=sect2><h3 id=ports-finding-applications>6.3. Βρίσκοντας την Εφαρμογή σας<a class=anchor href=#ports-finding-applications></a></h3><div class=paragraph><p>Πριν εγκαταστήσετε οποιαδήποτε εφαρμογή πρέπει να γνωρίζετε τι θέλετε να κάνει, και πως ονομάζεται η εφαρμογή.</p></div><div class=paragraph><p>Η λίστα των διαθέσιμων εφαρμογών στο FreeBSD μεγαλώνει συνεχώς. Ευτυχώς, υπάρχουν πολλοί τρόποι να βρείτε αυτό που θέλετε:</p></div><div class=ulist><ul><li><p>Στη δικτυακή τοποθεσία του FreeBSD θα βρείτε μια λίστα από όλες τις διαθέσιμες εφαρμογές, στο <a href=https://www.FreeBSD.org/ports/>http://www.FreeBSD.org/ports/</a>. Η λίστα αυτή ανανεώνεται συχνά, ενώ υπάρχει και δυνατότητα αναζήτησης. Τα ports είναι χωρισμένα σε κατηγορίες, και μπορείτε να αναζητήσετε μία εφαρμογή είτε με το όνομα (αν το ξέρετε), ή να δείτε όλες τις εφαρμογές που είναι διαθέσιμες σε μια κατηγορία.
*</p><div class=paragraph><p>Ο Dan Langille διατηρεί το FreshPorts, στο <a href=http://www.FreshPorts.org/>http://www.FreshPorts.org/</a>. Το FreshPorts καταγράφει τις αλλαγές των εφαρμογών στο δέντρο των ports καθώς συμβαίνουν, επιτρέποντάς σας να "παρακολουθείτε" ένα ή περισσότερα ports, και μπορεί να σας στείλει email όταν αυτά ανανεώνονται.
*</p></div><div class=paragraph><p>Αν δεν γνωρίζετε το όνομα της εφαρμογής που θέλετε, δοκιμάστε να χρησιμοποιήσετε ένα site σαν το Freecode(<a href=http://www.freecode.com/>http://www.freecode.com/</a>) για να βρείτε μία εφαρμογή, και μετά μπορείτε να ελέγξετε ξανά το site του FreeBSD για να δείτε αν η εφαρμογή έχει γίνει port.</p></div></li><li><p>Αν ξέρετε το ακριβές όνομα του port, και θέλετε μόνο να βρείτε σε ποια κατηγορία είναι, μπορείτε να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=whereis&amp;sektion=1&amp;format=html">whereis(1)</a>. Απλά γράψτε <code>whereis αρχείο</code>, όπου <em>αρχείο</em> είναι το πρόγραμμα που θέλετε να εγκαταστήσετε. Αν αυτό βρίσκεται στο σύστημα σας, η εντολή θα σας πει που είναι, όπως παρακάτω:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># whereis lsof</span>
lsof: /usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Αυτό μας λέει ότι το <code>lsof</code> (ένα εργαλείο συστήματος) μπορεί να βρεθεί στον κατάλογο <span class=filename>/usr/ports/sysutils/lsof</span>.</p></div></li><li><p>Επιπρόσθετα, μπορείτε να χρησιμοποιήσετε μια απλή εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a> για να εντοπίσετε την τοποθεσία κάποιου προγράμματος μέσα στα ports. Για παράδειγμα:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/ports/*/*lsof*</span>
/usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Σημειώστε ότι το παραπάνω θα δείξει επίσης και οποιαδήποτε αρχεία έχουν κατέβει στον κατάλογο <span class=filename>/usr/ports/distfiles</span> εφόσον ταιριάζουν στην αναζήτηση.</p></div></li><li><p>Ακόμη ένας τρόπος να βρείτε ένα συγκεκριμένο port, είναι χρησιμοποιώντας τον εσωτερικό μηχανισμό αναζήτησης της Συλλογής των Ports. Γα να χρησιμοποιήσετε αυτό τον τρόπο αναζήτησης, Θα χρειαστεί να βρίσκεστε στον κατάλογο <span class=filename>/usr/ports</span>. Όταν βρεθείτε σε αυτόν τον κατάλογο, εκτελέστε το <code>make search name=όνομα—​προγράμματος</code> όπου <em>όνομα—​προγράμματος</em> είναι το όνομα του προγράμματος που θέλετε να βρείτε. Για παράδειγμα, αν αναζητάτε το <code>lsof</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make search name=lsof</span>
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span>
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps:
R-deps:</code></pre></div></div><div class=paragraph><p>Το τμήμα της εξόδου που πρέπει να προσέξετε ιδιαίτερα είναι η γραμμή "Path:", αφού αυτή σας λέει που να βρείτε το port. Οι υπόλοιπες πληροφορίες που παρέχονται δεν χρειάζονται για να εγκατασταθεί το port, για αυτό δεν θα αναλυθούν εδώ.</p></div><div class=paragraph><p>Για πιο λεπτομερή αναζήτηση μπορείτε να χρησιμοποιήσετε επίσης <code>make search key=φράση</code> όπου <em>φράση</em> είναι κάποιο κείμενο προς αναζήτηση. Αυτό αναζητά ονόματα port, σχόλια, περιγραφές και εξαρτήσεις, και μπορεί να χρησιμοποιηθεί για να βρεθούν ports που σχετίζονται με ένα συγκεκριμένο θέμα, εάν δεν γνωρίζετε το όνομα του προγράμματος που αναζητάτε.</p></div><div class=paragraph><p>Σε όλες τις παραπάνω περιπτώσεις, η φράση προς αναζήτηση είναι case-insensitive (δεν λαμβάνει υπόψη τις διαφορές κεφαλαίων-μικρών). Η αναζήτηση για το "LSOF", θα δώσει τα ίδια αποτελέσματα με την αναζήτηση για το "lsof".</p></div></li></ul></div></div><div class=sect2><h3 id=packages-using>6.4. Χρησιμοποιώντας το Σύστημα των Πακέτων<a class=anchor href=#packages-using></a></h3><div class=paragraph><p>Υπάρχουν διάφορα εργαλεία με τα οποία μπορείτε να διαχειριστείτε τα πακέτα στο FreeBSD:</p></div><div class=ulist><ul><li><p>Σε ένα σύστημα που βρίσκεται ήδη σε λειτουργία, μπορείτε να εκτελέσετε το sysinstall για να εγκαταστήσετε, να διαγράψετε, και να δείτε τις εγκατεστημένες και τις διαθέσιμες εφαρμογές. Για περισσότερες πληροφορίες, δείτε το <a href=./#packages>Εγκατάσταση Πακέτων</a>.</p></li><li><p>Τα διάφορα εργαλεία διαχείρισης μέσω της γραμμής εντολών, που αποτελούν και το αντικείμενο συζήτησης αυτής της ενότητας.</p></li></ul></div><div class=sect3><h4 id=_εγκαθιστώντας_ένα_πακέτο>6.4.1. Εγκαθιστώντας ένα Πακέτο<a class=anchor href=#_εγκαθιστώντας_ένα_πακέτο></a></h4><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε το εργαλείο <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> για να εγκαταστήσετε ένα πακέτο λογισμικού του FreeBSD από ένα τοπικά αποθηκευμένο αρχείο ή από έναν διακομιστή στο δίκτυο.</p></div><div class=exampleblock><div class=title>Παράδειγμα 6. "Κατέβασμα" ενός πακέτου χειροκίνητα και εγκατάσταση του τοπικά</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ftp -a ftp2.FreeBSD.org</span>
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server <span class=o>(</span>Version 6.00LS<span class=o>)</span> ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is <span class=k>in </span>Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system <span class=nb>type </span>is UNIX.
Using binary mode to transfer files.
ftp&gt; <span class=nb>cd</span> /pub/FreeBSD/ports/packages/sysutils/
250 CWD <span class=nb>command </span>successful.
ftp&gt; get lsof-4.56.4.tgz
<span class=nb>local</span>: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT <span class=nb>command </span>successful.
150 Opening BINARY mode data connection <span class=k>for</span> <span class=s1>&#39;lsof-4.56.4.tgz&#39;</span> <span class=o>(</span>92375 bytes<span class=o>)</span><span class=nb>.</span>
100% |<span class=k>**************************************************</span>| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received <span class=k>in </span>5.60 seconds <span class=o>(</span>16.11 KB/s<span class=o>)</span>
ftp&gt; <span class=nb>exit</span>
<span class=c># pkg_add lsof-4.56.4.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>Εάν δεν έχετε μία τοπική πηγή πακέτων (όπως είναι ένα FreeBSD CD-ROM set) τότε ίσως είναι ευκολότερο να χρησιμοποιήσετε την επιλογή <code>-r</code> για το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>. Αυτή θα κάνει το εργαλείο να καθορίσει αυτόματα τη σωστή μορφή και έκδοση και έπειτα να ανακτήσει και να εγκαταστήσει το πακέτο από ένα FTP site.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r lsof</span></code></pre></div></div><div class=paragraph><p>Το παραπάνω παράδειγμα θα "κατεβάσει" και θα εγκαταστήσει το σωστό πακέτο χωρίς περαιτέρω επέμβαση του χρήστη. Αν δεν θέλετε να χρησιμοποιήσετε το κύριο site διανομής πακέτων, μπορείτε να χρησιμοποιήσετε κάποιο mirror. Για το σκοπό αυτό, θα πρέπει να ρυθμίσετε σωστά την τιμή της <code>PACKAGESITE</code>, ώστε να παρακάμψετε τις προεπιλεγμένες ρυθμίσεις. Το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> χρησιμοποιεί το <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> για να "κατεβάσει" τα αρχεία, και αυτό με τη σειρά του χρησιμοποιεί διάφορες μεταβλητές περιβάλλοντος, περιλαμβανομένων των <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code>, και <code>FTP_PASSWORD</code>. Ίσως χρειαστεί να ρυθμίσετε μία ή περισσότερες από αυτές αν βρίσκεστε πίσω από ένα firewall, ή ίσως να χρειαστεί να χρησιμοποιήσετε έναν FTP/HTTP proxy. Δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> για την πλήρη λίστα των μεταβλητών. Προσέξτε ότι στο παραπάνω παράδειγμα χρησιμοποιείται το <code>lsof</code> αντί του <code>lsof-4.56.4</code>. Όταν γίνεται απομακρυσμένη λήψη, πρέπει να αφαιρεθεί ο αριθμός έκδοσης του πακέτου. Το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> θα "κατεβάσει" αυτόματα την τελευταία έκδοση της εφαρμογής.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> θα "κατεβάσει" την τελευταία έκδοση της εφαρμογής αν χρησιμοποιείτε FreeBSD-CURRENT ή FreeBSD-STABLE. Αν τρέχετε μια -RELEASE έκδοση, θα "κατεβάσει" την έκδοση του πακέτου που έχει μεταγλωττιστεί με την έκδοση σας. Είναι δυνατό να το αλλάξετε αυτό, αλλάζοντας την <code>PACKAGESITE</code>. Για παράδειγμα, αν τρέχετε ένα σύστημα FreeBSD 8.1-RELEASE, το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>, από προεπιλογή, θα προσπαθήσει να "κατεβάσει" πακέτα από το <code><a href=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8.1-release/Latest/ class=bare>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8.1-release/Latest/</a></code>. Αν θέλετε να αναγκάσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> να "κατεβάσει" πακέτα του FreeBSD 8-STABLE, θέστε την <code>PACKAGESITE</code> ως <code><a href=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8-stable/Latest/ class=bare>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8-stable/Latest/</a></code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Τα αρχεία των πακέτων διανέμονται σε μορφές <span class=filename>.tgz</span> και <span class=filename>.tbz</span>. Μπορείτε να τα βρείτε στο <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/</a>, ή στα CD-ROM της διανομής του FreeBSD. Κάθε CD στο FreeBSD 4-CD set (και στο PowerPak, κλπ.) περιέχει πακέτα στον κατάλογο <span class=filename>/packages</span>. Η κατηγοριοποίηση των πακέτων ακολουθεί την δομή του δέντρου <span class=filename>/usr/ports</span>. Κάθε κατηγορία έχει το δικό της κατάλογο, και κάθε πακέτο μπορεί να βρεθεί στον κατάλογο <span class=filename>All</span>.</p></div><div class=paragraph><p>Η δομή των καταλόγων του συστήματος πακέτων ταιριάζει με την αντίστοιχη των ports. Τα δύο συστήματα συνεργάζονται μεταξύ τους για να δημιουργήσουν το συνολικό σύστημα πακέτων/ports.</p></div></div><div class=sect3><h4 id=_διαχείριση_των_πακέτων>6.4.2. Διαχείριση των Πακέτων<a class=anchor href=#_διαχείριση_των_πακέτων></a></h4><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a> είναι ένα εργαλείο που παραθέτει και περιγράφει τα διάφορα πακέτα που είναι εγκαταστημένα.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info</span>
cvsup-16.1          A general network file distribution system optimized <span class=k>for </span>CV
docbook-1.2         Meta-port <span class=k>for </span>the different versions of the DocBook DTD
...</code></pre></div></div><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_version&amp;sektion=1&amp;format=html">pkg_version(1)</a> είναι ένα εργαλείο που συνοψίζει τις εκδόσεις όλων των εγκαταστημένων πακέτων. Συγκρίνει την έκδοση κάθε πακέτου, με την τρέχουσα έκδοση που βρίσκεται στο δέντρο των ports.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version</span>
cvsup                       <span class=o>=</span>
docbook                     <span class=o>=</span>
...</code></pre></div></div><div class=paragraph><p>Τα σύμβολα στην δεύτερη στήλη δηλώνουν την σχετική ηλικία μεταξύ των εγκατεστημένων εκδόσεων και των εκδόσεων που είναι διαθέσιμες στο τοπικό δέντρο των ports.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Σύμβολο</th><th class="tableblock halign-left valign-top">Σημασία</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η έκδοση του εγκατεστημένου πακέτου ταιριάζει με αυτή που είναι διαθέσιμη στο τοπικό δέντρο των ports.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>&lt;</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η εγκατεστημένη έκδοση είναι παλαιότερη από αυτή που είναι διαθέσιμη στο δέντρο των ports.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η εγκατεστημένη έκδοση είναι νεότερη από αυτή που είναι διαθέσιμη στο τοπικό δέντρο των ports. (Το τοπικό δέντρο των ports είναι πιθανότατα απαρχαιωμένο.)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>?</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το εγκατεστημένο πακέτο δεν βρίσκεται στα περιεχόμενα των ports. (Αυτό μπορεί να συμβεί, για παράδειγμα, αν ένα εγκατεστημένο port έχει αφαιρεθεί από την Συλλογή των Ports, ή έχει μετονομαστεί.)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Υπάρχουν πολλαπλές εκδόσεις του πακέτου.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>!</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το εγκατεστημένο πακέτο υπάρχει στο index, αλλά για κάποιο λόγο το <code>pkg_version</code> δεν κατάφερε να συγκρίνει την έκδοση του εγκατεστημένου πακέτου με την αντίστοιχη καταχώρηση στο index.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_αφαιρώντας_ένα_πακέτο>6.4.3. Αφαιρώντας ένα Πακέτο<a class=anchor href=#_αφαιρώντας_ένα_πακέτο></a></h4><div class=paragraph><p>Για να αφαιρέσετε ένα εγκατεστημένο πακέτο λογισμικού, χρησιμοποιήστε το εργαλείο <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete xchat-1.7.1</span></code></pre></div></div><div class=paragraph><p>Σημειώστε ότι το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a> απαιτεί το πλήρες όνομα και αριθμό έκδοσης του πακέτου. Η παραπάνω εντολή δεν θα λειτουργήσει αν δώσετε απλώς <em>xchat</em> αντί για <em>xchat-1.7.1</em>. Είναι ωστόσο εύκολο να χρησιμοποιήσετε την <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_version&amp;sektion=1&amp;format=html">pkg_version(1)</a> για να βρείτε την έκδοση του εγκατεστημένου πακέτου. Αντί για αυτό, μπορείτε επίσης να χρησιμοποιήσετε ένα μπαλαντέρ:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete xchat\*</span></code></pre></div></div><div class=paragraph><p>Στην περίπτωση αυτή, θα διαγραφούν όλα τα πακέτα που τα ονόματα τους αρχίζουν με <code>xchat</code>.</p></div></div><div class=sect3><h4 id=_διάφορα>6.4.4. Διάφορα<a class=anchor href=#_διάφορα></a></h4><div class=paragraph><p>Όλες οι πληροφορίες για τα πακέτα είναι αποθηκευμένες στον κατάλογο <span class=filename>/var/db/pkg</span>. Στα αρχεία αυτού του καταλόγου, θα βρείτε τη περιγραφή κάθε πακέτου, καθώς και τη λίστα των αρχείων που εγκαθιστά.</p></div></div></div><div class=sect2><h3 id=ports-using>6.5. Χρησιμοποιώντας την Συλλογή των Ports<a class=anchor href=#ports-using></a></h3><div class=paragraph><p>Τα παρακάτω τμήματα δίνουν βασικές οδηγίες χρήσης της Συλλογής των Ports για εγκατάσταση ή διαγραφή προγραμμάτων στο σύστημα σας. Μπορείτε να βρείτε λεπτομερή περιγραφή των διαθέσιμων επιλογών του <code>make</code> και των μεταβλητών περιβάλλοντος στο <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div><div class=sect3><h4 id=ports-tree>6.5.1. Ανακτώντας την Συλλογή των Ports<a class=anchor href=#ports-tree></a></h4><div class=paragraph><p>Πριν μπορέσετε να εγκαταστήσετε προγράμματα μέσω των ports, πρέπει πρώτα να ανακτήσετε την Συλλογή των Ports. Πρόκειται ουσιαστικά για μια συλλογή από <span class=filename>Makefiles</span>, patches, και αρχεία περιγραφής που τοποθετούνται στο <span class=filename>/usr/ports</span>.</p></div><div class=paragraph><p>Όταν εγκαταστήσατε το FreeBSD σύστημα σας, το sysinstall σας ρώτησε αν θέλατε να εγκαταστήσετε την Συλλογή των Ports. Αν επιλέξατε όχι, μπορείτε να ακολουθήσετε αυτές τις οδηγίες για να ανακτήσετε την Συλλογή των Ports:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Μέθοδος CVSup</strong></p></div><div class=paragraph><p>Αυτή είναι μια γρήγορη μέθοδος για να ανακτήσετε και να διατηρήσετε ένα ανανεωμένο αντίγραφο της Συλλογής των Ports, χρησιμοποιώντας το πρωτόκολλο CVSup. Αν θέλετε να μάθετε περισσότερα για το CVSup, δείτε το <a href=./#cvsup-mirrors>Χρησιμοποιώντας το CVSup</a>.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Η υλοποίηση του CVSup που περιλαμβάνεται σε ένα σύστημα FreeBSD, ονομάζεται csup.</p></div></div></div><div class=paragraph><p>Σιγουρευθείτε ότι το <span class=filename>/usr/ports</span> είναι άδειο πριν εκτελέσετε το csup για πρώτη φορά! Εάν έχετε ήδη ανακτήσει τη Συλλογή των Ports μέσω κάποιας άλλης πηγής, το csup δεν θα διαγράψει patches που έχουν αφαιρεθεί στο μεταξύ.</p></div><div class="olist arabic"><ol class=arabic><li><p>Εκτελέστε το <code>csup</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># csup -L 2 -h cvsup.FreeBSD.org /usr/shared/examples/cvsup/ports-supfile</span></code></pre></div></div><div class=paragraph><p>Αλλάξτε το <em>cvsup.FreeBSD.org</em> με έναν κοντινό σας διακομιστή CVSup. Δείτε το <a href=./#cvsup-mirrors>CVSup Mirrors</a> (<a href=./#cvsup-mirrors>Τοποθεσίες CVSup</a>) για την πλήρη λίστα των mirror sites.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν θέλετε, μπορείτε να χρησιμοποιήσετε το δικό σας <span class=filename>ports-supfile</span>, ώστε να αποφύγετε (για παράδειγμα) να δηλώσετε τον διακομιστή CVSup στην γραμμή εντολών.</p></div><div class="sidebarblock procedure"><div class=content><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Σε αυτή την περίπτωση, ως <code>root</code>, αντιγράψτε το <span class=filename>/usr/shared/examples/cvsup/ports-supfile</span> σε μία νέα τοποθεσία, όπως το <span class=filename>/root</span> ή τον δικό σας home κατάλογο.</p></li><li><p>Τροποποιήστε το <span class=filename>ports-supfile</span>.</p></li><li><p>Αλλάξτε το <em>CHANGE_THIS.FreeBSD.org</em> με έναν κοντινό σας διακομιστή CVSup.Δείτε το <a href=./#cvsup-mirrors>CVSup Mirrors</a> (<a href=./#cvsup-mirrors>Τοποθεσίες CVSup</a>) για την πλήρη λίστα των mirror sites.</p></li><li><p>Εκτελέστε τώρα το <code>csup</code>, με τον ακόλουθο τρόπο:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># csup -L 2 /root/ports-supfile</span></code></pre></div></div></li></ol></div></div></div></td></tr></tbody></table></div></li><li><p>Εκτελώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> αργότερα, θα "κατεβάσει" και θα εφαρμόσει όλες τις πρόσφατες αλλαγές στην Συλλογή των Ports, εκτός από το να επανα-μεταγλωττίσει τα ports για το σύστημα σας.</p></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Μέθοδος Portsnap</strong></p></div><div class=paragraph><p>Το Portsnap είναι ένα εναλλακτικό σύστημα για την διανομή της Συλλογής των Ports. Παρακαλώ ελέγξτε το <a href=./#updating-upgrading-portsnap>Χρησιμοποιώντας το Portsnap</a> για μία λεπτομερή περιγραφή όλων των χαρακτηριστικών της εφαρμογής.</p></div><div class="olist arabic"><ol class=arabic><li><p>"Κατεβάστε" ένα συμπιεσμένο snapshot της Συλλογής των Ports <span class=filename>/var/db/portsnap</span>. Αν θέλετε, μπορείτε να αποσυνδεθείτε από το Διαδίκτυο μετά από αυτό το βήμα.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span></code></pre></div></div></li><li><p>Αν εκτελείτε το Portsnap για πρώτη φορά, κάντε εξαγωγή του snapshot μέσα στο <span class=filename>/usr/ports</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span></code></pre></div></div><div class=paragraph><p>Εάν ήδη έχετε ένα γεμάτο <span class=filename>/usr/ports</span> και απλώς το ανανεώνετε, εκτελέστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap update</span></code></pre></div></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Μέθοδος Sysinstall</strong></p></div><div class=paragraph><p>Αυτή η μέθοδος χρησιμοποιεί το sysinstall για την εγκατάσταση της Συλλογής των Ports από το μέσο εγκατάστασης. Σημειώστε ότι με αυτό τον τρόπο θα εγκαταστήσετε το παλαιό αντίγραφο της Συλλογής των Ports, που αντιστοιχεί στην ημερομηνία της έκδοσης του FreeBSD που χρησιμοποιείτε. Εάν έχετε πρόσβαση στο Διαδίκτυο, πρέπει πάντα να χρησιμοποιείτε μία από τις μεθόδους που αναφέρθηκαν πιο πάνω.</p></div><div class="olist arabic"><ol class=arabic><li><p>Ως <code>root</code>, εκτελέστε το <code>sysinstall</code> όπως φαίνεται παρακάτω:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysinstall</span></code></pre></div></div></li><li><p>Επιλέξτε το <span class=guimenuitem>Configure</span>, και πιέστε <kbd>Enter</kbd>.</p></li><li><p>Επιλέξτε το <span class=guimenuitem>Distributions</span>, και πιέστε <kbd>Enter</kbd>.</p></li><li><p>Μετακινηθείτε στο <span class=guimenuitem>ports</span>, και πιέστε <kbd>Space</kbd>.</p></li><li><p>Μετακινηθείτε στο <span class=guimenuitem>Exit</span>, και πιέστε <kbd>Enter</kbd>.</p></li><li><p>Επιλέξτε το μέσο εγκατάστασης της επιθυμίας σας, όπως CDROM, FTP, και πάει λέγοντας.</p></li><li><p>Μετακινηθείτε στο <span class=guimenuitem>Exit</span> και πιέστε <kbd>Enter</kbd>.</p></li><li><p>Πιέστε <kbd>X</kbd> για να βγείτε από το sysinstall.</p></li></ol></div></div></div></div><div class=sect3><h4 id=ports-skeleton>6.5.2. Εγκαθιστώντας Ports<a class=anchor href=#ports-skeleton></a></h4><div class=paragraph><p>Το πρώτο πράγμα που πρέπει να διευκρινιστεί σχετικά με την Συλλογή των Ports είναι η έννοια του όρου "skeleton (σκελετός)". Με λίγα λόγια, ένα port skeleton είναι η ελάχιστη συλλογή αρχείων που καθοδηγούν ένα σύστημα FreeBSD ώστε να μεταγλωττίσει και να εγκαταστήσει σωστά ένα πρόγραμμα. Κάθε port skeleton περιέχει:</p></div><div class=ulist><ul><li><p>Ένα <span class=filename>Makefile</span>. Το <span class=filename>Makefile</span> περιέχει διάφορες δηλώσεις που ορίζουν πως πρέπει να μεταγλωττιστεί η εφαρμογή και που πρέπει να εγκατασταθεί στο σύστημά σας.</p></li><li><p>Ένα αρχείο <span class=filename>distinfo</span>. Αυτό το αρχείο περιέχει πληροφορίες για τα αρχεία που πρέπει να "κατέβουν" για την μεταγλώττιση του port, και τα checksums τους (χρησιμοποιώντας το <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a>), για να επιβεβαιωθεί ότι τα αρχεία δεν έχουν αλλοιωθεί κατά την διάρκεια της μεταφοράς τους.</p></li><li><p>Έναν κατάλογο <span class=filename>files</span>. Αυτός ο κατάλογος περιέχει τα patches που επιτρέπουν στο πρόγραμμα να μεταγλωττιστεί και εγκατασταθεί στο FreeBSD σύστημα σας. Τα patches είναι μικρά αρχεία που ορίζουν αλλαγές σε συγκεκριμένα αρχεία. Είναι σε μορφή κοινού κειμένου, και βασικά λένε "Αφαίρεσε την γραμμή 10" ή "Μετέτρεψε τη γραμμή 26 σε αυτό …​". Τα patches είναι επίσης γνωστά ως "diffs" επειδή δημιουργούνται με το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>.</p><div class=paragraph><p>Αυτός ο κατάλογος μπορεί να περιέχει και άλλα αρχεία που χρησιμοποιούνται για να μεταγλωττιστεί το port.</p></div></li><li><p>Ένα αρχείο <span class=filename>pkg-descr</span>. Αυτό είναι μία πιο λεπτομερής, συχνά πολλών γραμμών, περιγραφή του προγράμματος.</p></li><li><p>Ένα αρχείο <span class=filename>pkg-plist</span>. Αυτό περιέχει μια λίστα όλων των αρχείων που θα εγκατασταθούν από το port. Επίσης καθοδηγεί το σύστημα των ports τι αρχεία να αφαιρέσει κατά την απεγκατάσταση.</p></li></ul></div><div class=paragraph><p>Μερικά ports έχουν και άλλα αρχεία, όπως το <span class=filename>pkg-message</span>. Το σύστημα των ports χρησιμοποιεί αυτά τα αρχεία για να χειριστεί ειδικές περιστάσεις. Αν θέλετε περισσότερες λεπτομέρειες για αυτά τα αρχεία, και τα ports γενικότερα, δείτε το <a href=https://docs.freebsd.org/en/books/porters-handbook/>FreeBSD Porter’s Handbook</a>.</p></div><div class=paragraph><p>Το port περιέχει οδηγίες για το πως να μεταγλωττιστεί ο πηγαίος κώδικας, αλλά δεν περιέχει τον πηγαίο κώδικα. Μπορείτε να προμηθευτείτε τον πηγαίο κώδικα από ένα CD-ROM ή από το Διαδίκτυο. Ο πηγαίος κώδικας διανέμεται με οποιοδήποτε τρόπο επιθυμεί ο δημιουργός του. Συχνά είναι ένα tarred και gzipped αρχείο, αλλά μπορεί να είναι συμπιεσμένος με κάποιο άλλο εργαλείο ή να είναι ακόμα και ασυμπίεστος. Ο πηγαίος κώδικας του προγράμματος, σε οποιαδήποτε μορφή κι αν διατίθεται, λέγεται "distfile". Οι δύο μέθοδοι για να εγκαταστήσετε ένα FreeBSD port περιγράφονται παρακάτω.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Πρέπει να συνδεθείτε ως <code>root</code> για να εγκαταστήσετε ports.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Πριν εγκαταστήσετε οποιαδήποτε port, πρέπει να σιγουρευτείτε ότι έχετε μία ανανεωμένη Συλλογή των Ports, και πρέπει να ελέγξετε το <a href=http://vuxml.freebsd.org/>http://vuxml.freebsd.org/</a> για θέματα ασφαλείας σχετικά με το port που ενδιαφέρεστε.</p></div><div class=paragraph><p>Αν θέλετε να ελέγχετε αυτόματα για τυχόν προβλήματα ασφαλείας πριν από κάθε εγκατάσταση νέας εφαρμογής, μπορείτε να χρησιμοποιήσετε το portaudit. Θα βρείτε αυτό το εργαλείο στην Συλλογή των Ports (<a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portaudit/>ports-mgmt/portaudit</a>). Είναι καλή ιδέα να εκτελέσετε το <code>portaudit -F</code> πριν εγκαταστήσετε ένα νέο port, για να ανακτήσετε την τρέχουσα βάση δεδομένων προβλημάτων ασφαλείας. Αντίστοιχος έλεγχος και ανανέωση της βάσης δεδομένων εκτελείται επίσης αυτόματα κατά τον καθημερινό έλεγχο ασφαλείας του συστήματος. Για περισσότερες πληροφορίες διαβάστε τις σελίδες manual <a href="https://man.freebsd.org/cgi/man.cgi?query=portaudit&amp;sektion=1&amp;format=html">portaudit(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η Συλλογή των Ports προϋποθέτει ότι έχετε λειτουργική σύνδεση με το Διαδίκτυο. Εάν δεν έχετε, θα χρειαστεί να βάλετε μόνος σας ένα αντίγραφο του distfile μέσα στο <span class=filename>/usr/ports/distfiles</span>.</p></div><div class=paragraph><p>Αρχικά, μετακινηθείτε στον κατάλογο του port που θέλετε να εγκαταστήσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span></code></pre></div></div><div class=paragraph><p>Μόλις βρεθείτε στον κατάλογο <span class=filename>lsof</span>, θα δείτε τον port skeleton. Το επόμενο βήμα είναι να μεταγλωττίσετε, ή να "κτίσετε (build)", το port. Αυτό γίνεται απλά πληκτρολογώντας <code>make</code> στην γραμμή εντολών. Όταν το κάνετε, θα δείτε κάτι όπως αυτό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make</span>
<span class=o>&gt;&gt;</span> lsof_4.57D.freebsd.tar.gz doesn<span class=s1>&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.57
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.57
===&gt;  Applying FreeBSD patches for lsof-4.57
===&gt;  Configuring for lsof-4.57
...
[configure output snipped]
...
===&gt;  Building for lsof-4.57
...
[compilation output snipped]
...
#</span></code></pre></div></div><div class=paragraph><p>Προσέξτε ότι μόλις η μεταγλώττιση ολοκληρωθεί θα επιστρέψετε στην γραμμή εντολών. Το επόμενο βήμα είναι να εγκαταστήσετε το port. Για να το εγκαταστήσετε, χρειάζεται απλώς να προσθέσετε μια λέξη στην εντολή <code>make</code>, και αυτή η λέξη είναι <code>install</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make install</span>
<span class=o>===&gt;</span>  Installing <span class=k>for </span>lsof-4.57
...
<span class=o>[</span>installation output snipped]
...
<span class=o>===&gt;</span>   Generating temporary packing list
<span class=o>===&gt;</span>   Compressing manual pages <span class=k>for </span>lsof-4.57
<span class=o>===&gt;</span>   Registering installation <span class=k>for </span>lsof-4.57
<span class=o>===&gt;</span>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Μόλις επιστρέψετε στην γραμμή εντολών, θα πρέπει να μπορείτε να εκτελέσετε την εφαρμογή που μόλις εγκαταστήσατε. Θα δείτε μια προειδοποίηση ασφαλείας, επειδή το <code>lsof</code> είναι ένα πρόγραμμα που τρέχει με αυξημένα προνόμια. Κατά την μεταγλώττιση και εγκατάσταση των ports, θα πρέπει να προσέχετε οποιαδήποτε προειδοποίηση εμφανιστεί.</p></div><div class=paragraph><p>Μια καλή ιδέα, είναι να διαγράψετε τον υποκατάλογο που περιέχει όλα τα προσωρινά αρχεία που χρησιμοποιήθηκαν κατά την μεταγλώττιση. Όχι μόνο καταναλώνουν πολύτιμο χώρο, άλλα μπορεί να προκαλέσουν προβλήματα αργότερα όταν θα θελήσετε να εγκαταστήσετε μια νεότερη έκδοση του port.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make clean</span>
<span class=o>===&gt;</span>  Cleaning <span class=k>for </span>lsof-4.57
<span class=c>#</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μπορείτε να γλιτώσετε δύο πρόσθετα βήματα απλώς εκτελώντας <code>make install clean</code> αντί για <code>make</code>, <code>make install</code> και <code>make clean</code> ως τρία ξεχωριστά βήματα.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μερικά κελύφη κρατάνε μια λίστα από τις εντολές που βρίσκονται διαθέσιμες στους καταλόγους που αναφέρονται στην μεταβλητή περιβάλλοντος <code>PATH</code>, για να επιταχύνουν τις αναζητήσεις για τα εκτελέσιμα αρχεία αυτών των εντολών. Αν χρησιμοποιείτε ένα από αυτά τα κελύφη, θα πρέπει να χρησιμοποιήσετε την εντολή <code>rehash</code> μετά την εγκατάσταση ενός port, πριν μπορέσετε να χρησιμοποιήσετε τις νέες εντολές. Αυτή η εντολή λειτουργεί σε κελύφη όπως το <code>tcsh</code>. Χρησιμοποιήστε την εντολή <code>hash -r</code> για κελύφη όπως το <code>sh</code>. Δείτε την τεκμηρίωση του κελύφους σας για περισσότερες πληροφορίες.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μερικά προϊόντα τρίτων κατασκευαστών σε DVD-ROM, όπως το FreeBSD Toolkit από το <a href=http://www.freebsdmall.com/>FreeBSD Mall</a>, περιέχουν distfiles. Αυτά μπορούν να χρησιμοποιηθούν με την Συλλογή των Ports. Προσαρτήστε το DVD-ROM στο <span class=filename>/cdrom</span>. Αν χρησιμοποιείτε κάποιο διαφορετικό σημείο προσάρτησης, ρυθμίστε την μεταβλητή <code>CD_MOUNTPTS</code> του make. Τα αναγκαία distfiles θα χρησιμοποιηθούν αυτόματα αν υπάρχουν στο δισκάκι.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Πρέπει να γνωρίζετε ότι οι άδειες μερικών ports δεν επιτρέπουν την διανομή τους σε CD-ROM. Αυτό μπορεί να οφείλεται π.χ. στο ότι πρέπει να συμπληρώσετε μια φόρμα εγγραφής πριν "κατεβάσετε" την εφαρμογή, ή στο ότι δεν επιτρέπεται η επαναδιανομή, ή σε κάποιο άλλο λόγο. Εάν θέλετε να εγκαταστήσετε ένα port που δεν περιλαμβάνεται στο CD-ROM, θα χρειαστεί να είστε συνδεδεμένος στο Διαδίκτυο για να το επιτύχετε.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το σύστημα των ports χρησιμοποιεί το <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> για να "κατεβάσει" τα αρχεία. Το <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> χρησιμοποιεί διάφορες μεταβλητές περιβάλλοντος, περιλαμβανομένων των <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code>, και <code>FTP_PASSWORD</code>. Ίσως χρειαστεί να ρυθμίσετε μία ή περισσότερες αν βρίσκεστε πίσω από ένα firewall, ή ίσως να χρειαστεί να χρησιμοποιήσετε έναν FTP/HTTP proxy. Δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> για μια πλήρη λίστα των μεταβλητών αυτών.</p></div><div class=paragraph><p>Για χρήστες που δεν μπορούν να είναι συνδεδεμένοι όλη την ώρα, διατίθεται η επιλογή <code>make fetch</code>. Απλώς εκτελέστε την εντολή στον κατάλογο (<span class=filename>/usr/ports</span>) και τα απαραίτητα αρχεία θα "κατέβουν" για εσάς. Η εντολή αυτή θα λειτουργήσει και σε υποκαταλόγους, όπως για παράδειγμα: <span class=filename>/usr/ports/net</span>. Προσέξτε ότι αν ένα port εξαρτάται από βιβλιοθήκες ή άλλα ports, η εντολή αυτή <em>δεν</em> θα ανακτήσει τα distfiles τους. Αντικαταστήστε το <code>fetch</code> με το <code>fetch-recursive</code> αν θέλετε μαζί με το port να ανακτήσετε και όλες τις εξαρτήσεις του.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μπορείτε να μεταγλωττίσετε όλα τα ports σε μία κατηγορία ή ακόμα και σε όλες, εκτελώντας το <code>make</code> στον αρχικό κατάλογο, όπως με την προαναφερθείσα <code>make fetch</code> μέθοδο. Αυτό όμως είναι επικίνδυνο, γιατί μερικά ports δεν μπορούν να συνυπάρχουν. Σε άλλες περιπτώσεις, μερικά ports μπορεί να εγκαταστήσουν δυο διαφορετικά αρχεία με το με το ίδιο όνομα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Σε μερικές σπάνιες περιπτώσεις, οι χρήστες μπορεί να χρειάζεται να ανακτήσουν τα tarballs από ένα site διαφορετικό από τα <code>MASTER_SITES</code> (η τοποθεσία από όπου "κατεβαίνουν" τα αρχεία). Μπορείτε να αλλάξετε την επιλογή <code>MASTER_SITES</code> με την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/directory</span>
<span class=c># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre></div></div><div class=paragraph><p>Σε αυτό το παράδειγμα αλλάξαμε την επιλογή <code>MASTER_SITES</code> σε <code>ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μερικά ports επιτρέπουν (ή απαιτούν) να δώσετε επιλογές μεταγλώττισης που μπορούν να ενεργοποιήσουν/απενεργοποιήσουν τμήματα της εφαρμογής που είναι αχρείαστα, συγκεκριμένες επιλογές ασφαλείας, και άλλες τροποποιήσεις. Κοινά παραδείγματα τέτοιων ports είναι τα <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/security/gpgme/>security/gpgme</a>, και το <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a>. Όταν υπάρχουν διαθέσιμες τέτοιες επιλογές, θα εμφανιστεί στην οθόνη σας σχετικό μήνυμα.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_παρακάμπτοντας_τους_προεπιλεγμένους_καταλόγους_των_ports>6.5.2.1. Παρακάμπτοντας τους Προεπιλεγμένους Καταλόγους των Ports<a class=anchor href=#_παρακάμπτοντας_τους_προεπιλεγμένους_καταλόγους_των_ports></a></h5><div class=paragraph><p>Μερικές φορές είναι χρήσιμο (ή επιτακτικό) να χρησιμοποιήσετε ένα διαφορετικό κατάλογο εργασίας και εγκατάστασης. Οι μεταβλητές <code>WRKDIRPREFIX</code> και <code>PREFIX</code> μπορούν να παρακάμψουν τους προεπιλεγμένους καταλόγους. Για παράδειγμα, η εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=/usr/home/example/ports install</span></code></pre></div></div><div class=paragraph><p>θα μεταγλωττίσει το port στο <span class=filename>/usr/home/example/ports</span> και θα εγκαταστήσει τα πάντα στο <span class=filename>/usr/local</span>, ενώ η εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make PREFIX=/usr/home/example/local install</span></code></pre></div></div><div class=paragraph><p>θα μεταγλωττίσει το port στο <span class=filename>/usr/ports</span> και θα το εγκαταστήσει στο <span class=filename>/usr/home/example/local</span>.</p></div><div class=paragraph><p>Και φυσικά η εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre></div></div><div class=paragraph><p>θα συνδυάσει και τα δυο (είναι πολύ μεγάλη για να την δείξουμε εδώ, άλλα πρέπει να πήρατε την γενική ιδέα).</p></div><div class=paragraph><p>Εναλλακτικά, αυτές οι μεταβλητές μπορούν να ρυθμιστούν ως μέρος του περιβάλλοντος σας. Διαβάστε την σελίδα manual για το κέλυφος σας, για να βρείτε τις σχετικές οδηγίες.</p></div></div><div class=sect4><h5 id=_αντιμετωπίζοντας_το_imake>6.5.2.2. Αντιμετωπίζοντας το <code>imake</code><a class=anchor href=#_αντιμετωπίζοντας_το_imake></a></h5><div class=paragraph><p>Μερικά ports που χρησιμοποιούν το <code>imake</code> (μέρος του X Window System) δεν συνεργάζονται σωστά με το <code>PREFIX</code>, και επιμένουν να εγκατασταθούν στο <span class=filename>/usr/X11R6</span>. Όμοια, μερικά Perl ports αγνοούν το <code>PREFIX</code> και εγκαθίστανται στο δέντρο Perl. Το να κάνετε αυτά τα ports να σέβονται το <code>PREFIX</code> είναι μία δύσκολη ή αδύνατη δουλειά.</p></div></div><div class=sect4><h5 id=_επαναρύθμιση_επιλογών_ports>6.5.2.3. Επαναρύθμιση Επιλογών Ports<a class=anchor href=#_επαναρύθμιση_επιλογών_ports></a></h5><div class=paragraph><p>Όταν μεταγλωττίζετε κάποια ports, μπορεί να εμφανιστεί στην οθόνη σας ένα μενού επιλογών (βασισμένο σε ncurses) το οποίο να σας επιτρέπει να αλλάξετε διάφορες επιλογές μεταγλώττισης. Δεν είναι σπάνιο κάποιοι χρήστες να θέλουν να επισκεφτούν ξανά αυτό το μενού, για να προσθέσουν, να αφαιρέσουν ή να αλλάξουν κάποιες επιλογές, μετά την μεταγλώττιση του port. Μια επιλογή είναι να μετακινηθείτε στον κατάλογο του port και να γράψετε <code>make config</code>, με το οποίο θα εμφανιστεί ξανά το μενού με τις προηγούμενες ρυθμίσεις σας ήδη επιλεγμένες. Μια άλλη δυνατότητα, είναι να χρησιμοποιήσετε την εντολή <code>make showconfig</code>, με την οποία θα δείτε όλες τις επιλεγμένες ρυθμίσεις του port. Τέλος, μια ακόμα επιλογή είναι να εκτελέσετε την εντολή <code>make rmconfig</code> η οποία θα αφαιρέσει όλες τις αποθηκευμένες επιλογές και θα σας επιτρέψει να ξεκινήσετε ξανά από την αρχή. Όλες αυτές οι επιλογές, και ακόμα περισσότερες, εξηγούνται στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div></div></div><div class=sect3><h4 id=ports-removing>6.5.3. Αφαιρώντας Εγκατεστημένα Ports<a class=anchor href=#ports-removing></a></h4><div class=paragraph><p>Τώρα που γνωρίσατε πως να εγκαθιστάτε ports, πιθανώς θα αναρωτιέστε πως αφαιρούνται, στην περίπτωση που εγκαταστήσατε ένα και αργότερα αποφασίσατε ότι εγκαταστήσατε το λάθος port. Θα αφαιρέσουμε το προηγούμενο παράδειγμα (που ήταν το <code>lsof</code> για όσους δεν το πρόσεξαν). Τα ports αφαιρούνται όπως και τα πακέτα (το αναλύσαμε στην ενότητα <a href=#packages-using>Χρησιμοποιώντας το Σύστημα των Πακέτων</a>), χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete lsof-4.57</span></code></pre></div></div></div><div class=sect3><h4 id=ports-upgrading>6.5.4. Αναβαθμίζοντας τα Ports<a class=anchor href=#ports-upgrading></a></h4><div class=paragraph><p>Αρχικά, δείτε τα παρωχημένα ports για τα οποία υπάρχουν διαθέσιμες νεότερες εκδόσεις στην Συλλογή των Ports, με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_version&amp;sektion=1&amp;format=html">pkg_version(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -v</span></code></pre></div></div><div class=sect4><h5 id=ports-file-updating>6.5.4.1. <span class=filename>/usr/ports/UPDATING</span><a class=anchor href=#ports-file-updating></a></h5><div class=paragraph><p>Μόλις ανανεώσετε την Συλλογή των Ports, πρέπει να ελέγξετε το αρχείο <span class=filename>/usr/ports/UPDATING</span>, πριν επιχειρήσετε την αναβάθμιση ενός port. Αυτό το αρχείο περιγράφει διάφορα πιθανά προβλήματα, καθώς και ενδεχόμενα πρόσθετα βήματα που πρέπει να εκτελέσετε όταν ανανεώνετε ένα port. Παραδείγματα των παραπάνω, είναι η αλλαγή μορφής κάποιων αρχείων, αλλαγή στην τοποθεσία των αρχείων ρυθμίσεων, ή άλλες ασυμβατότητες με παλαιότερες εκδόσεις.</p></div><div class=paragraph><p>Αν το <span class=filename>UPDATING</span> αναιρεί κάτι που διαβάσατε εδώ, θεωρήστε ότι ισχύει το <span class=filename>UPDATING</span>.</p></div></div><div class=sect4><h5 id=portupgrade>6.5.4.2. Αναβαθμίζοντας Ports με το Portupgrade<a class=anchor href=#portupgrade></a></h5><div class=paragraph><p>Το εργαλείο portupgrade είναι σχεδιασμένο για να αναβαθμίζει εύκολα εγκατεστημένα ports. Διατίθεται από το <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> port. Εγκαταστήστε το όπως κάθε port, χρησιμοποιώντας την εντολή <code>make install clean</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Η εντολή <code>pkgdb -F</code> θα διαβάσει και θα διορθώσει όλες τις ασυνέπειες που ίσως υπάρχουν στη λίστα των εγκατεστημένων ports. Είναι καλή ιδέα είναι να την εκτελείτε συχνά, ενδεχομένως πριν από κάθε αναβάθμιση.</p></div><div class=paragraph><p>Όταν εκτελείτε το <code>portupgrade -a</code>, το portupgrade θα αρχίσει να αναβαθμίζει όλα τα παρωχημένα ports που είναι εγκατεστημένα στο σύστημα σας. Χρησιμοποιήστε την επιλογή <code>-i</code> αν θέλετε να σας ρωτά για επιβεβαίωση για κάθε ξεχωριστή αναβάθμιση.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -ai</span></code></pre></div></div><div class=paragraph><p>Αν θέλετε να αναβαθμίσετε μόνο μία συγκεκριμένη εφαρμογή, και όχι όλα τα διαθέσιμα ports, χρησιμοποιήστε το <code>portupgrade pkgname</code>. Συμπεριλάβετε την επιλογή <code>-R</code> αν το portupgrade πρέπει πρώτα να αναβαθμίσει όλα τα ports που απαιτούνται για την συγκεκριμένη εφαρμογή.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -R firefox</span></code></pre></div></div><div class=paragraph><p>Για να χρησιμοποιήσετε πακέτα αντί για ports στην εγκατάσταση, δώστε την επιλογή <code>-P</code>. Με αυτή την επιλογή το portupgrade αναζητά τους τοπικούς καταλόγους που ορίζονται στο <code>PKG_PATH</code>, ή ανακτά τα πακέτα από απομακρυσμένα sites εάν δεν βρεθούν τοπικά. Αν τα πακέτα δεν μπορούν να ανακτηθούν με τους παραπάνω τρόπους, το portupgrade θα χρησιμοποιήσει τα ports. Για να αποφύγετε εντελώς την χρήση των ports, καθορίστε την επιλογή <code>-PP</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PR gnome2</span></code></pre></div></div><div class=paragraph><p>Για να ανακτήσετε απλώς τα distfiles (ή τα πακέτα, αν έχετε ορίσει την επιλογή <code>-P</code>) χωρίς να μεταγλωττίσετε ή να εγκαταστήσετε τίποτα, χρησιμοποιήστε το <code>-F</code>. Για περισσότερες πληροφορίες, δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=portupgrade&amp;sektion=1&amp;format=html">portupgrade(1)</a>.</p></div></div><div class=sect4><h5 id=portmanager>6.5.4.3. Αναβαθμίζοντας Ports με το Portmanager<a class=anchor href=#portmanager></a></h5><div class=paragraph><p>Το Portmanager είναι ένα ακόμα εργαλείο για εύκολη αναβάθμιση εγκατεστημένων ports. Διατίθεται από το <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmanager/>ports-mgmt/portmanager</a> port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmanager</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Όλα τα εγκατεστημένα ports μπορούν να αναβαθμιστούν χρησιμοποιώντας αυτή την απλή εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager -u</span></code></pre></div></div><div class=paragraph><p>Μπορείτε να προσθέσετε την επιλογή <code>-ui</code> στην παραπάνω εντολή (<code>portmanager -u -ui</code>) για να ερωτηθείτε να επιβεβαιώσετε κάθε βήμα που θα εκτελέσει το Portmanager. Το Portmanager μπορεί επίσης να χρησιμοποιηθεί για να εγκαταστήσετε νέα ports στο σύστημα. Σε αντίθεση με την εντολή <code>make install clean</code>, το Portmanager θα αναβαθμίσει όλες τις εξαρτήσεις πριν την μεταγλώττιση και εγκατάσταση του επιλεγμένου port.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager x11/gnome2</span></code></pre></div></div><div class=paragraph><p>Αν υπάρχουν προβλήματα που σχετίζονται με τις εξαρτήσεις ενός επιλεγμένου port, μπορείτε να χρησιμοποιήσετε το Portmanager για να τις επανα-μεταγλωττίσει όλες με την σωστή σειρά. Μόλις τελειώσει με τις εξαρτήσεις, θα επανα-μεταγλωττίσει και το προβληματικό port.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager graphics/gimp -f</span></code></pre></div></div><div class=paragraph><p>Για περισσότερες πληροφορίες δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=portmanager&amp;sektion=1&amp;format=html">portmanager(1)</a>.</p></div></div><div class=sect4><h5 id=portmaster>6.5.4.4. Αναβαθμίζοντας τα Ports μέσω του Portmaster<a class=anchor href=#portmaster></a></h5><div class=paragraph><p>Το Portmaster είναι ένα ακόμα εργαλείο για την αναβάθμιση των εγκατεστημένων ports. Το Portmaster σχεδιάστηκε ώστε να χρησιμοποιεί τα εργαλεία που παρέχει το "βασικό" σύστημα (δεν εξαρτάται από άλλα ports) και χρησιμοποιεί τις πληροφορίες του <span class=filename>/var/db/pkg</span> για να καθορίσει ποια ports θα αναβαθμίσει. Είναι διαθέσιμο μέσω του port <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmaster</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Το Portmaster ομαδοποιεί τα ports σε τέσσερις κατηγορίες:</p></div><div class=ulist><ul><li><p>Root ports (δεν εξαρτώνται από άλλα, και ούτε άλλα εξαρτώνται από αυτά)</p></li><li><p>Trunk ports (δεν εξαρτώνται από άλλα, ωστόσο κάποια πακέτα εξαρτώνται από αυτά)</p></li><li><p>Branch ports (έχουν εξαρτήσεις και προς τις δύο κατευθύνσεις)</p></li><li><p>Leaf ports (εξαρτώνται από άλλα, αλλά όχι το αντίθετο)</p></li></ul></div><div class=paragraph><p>Μπορείτε να δείτε μια λίστα όλων των εγκατεστημένων ports και να ψάξετε για ενημερωμένες εκδόσεις, χρησιμοποιώντας την επιλογή <code>-L</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -L</span>
<span class=o>===&gt;&gt;&gt;</span> Root ports <span class=o>(</span>No dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> ispell-3.2.06_18
<span class=o>===&gt;&gt;&gt;</span> screen-4.0.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: screen-4.0.3_1
<span class=o>===&gt;&gt;&gt;</span> tcpflow-0.21_1
<span class=o>===&gt;&gt;&gt;</span> 7 root ports
...
<span class=o>===&gt;&gt;&gt;</span> Branch ports <span class=o>(</span>Have dependencies, are depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> apache-2.2.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: apache-2.2.8
...
<span class=o>===&gt;&gt;&gt;</span> Leaf ports <span class=o>(</span>Have dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> automake-1.9.6_2
<span class=o>===&gt;&gt;&gt;</span> bash-3.1.17
        <span class=o>===&gt;&gt;&gt;</span> New version available: bash-3.2.33
...
<span class=o>===&gt;&gt;&gt;</span> 32 leaf ports

<span class=o>===&gt;&gt;&gt;</span> 137 total installed ports
        <span class=o>===&gt;&gt;&gt;</span> 83 have new versions available</code></pre></div></div><div class=paragraph><p>Μπορείτε να αναβαθμίσετε όλα τα εγκατεστημένα ports με την παρακάτω απλή εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -a</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Από προεπιλογή, το Portmaster θα δημιουργήσει αντίγραφο ασφαλείας του εγκατεστημένου πακέτου πριν το διαγράψει. Αν η εγκατάσταση της νέας έκδοσης είναι επιτυχής, το Portmaster θα σβήσει το αντίγραφο αυτό. Αν χρησιμοποιήσετε την επιλογή <code>-b</code>, το Portmaster δεν θα σβήσει αυτόματα το αντίγραφο. Αν χρησιμοποιήσετε την επιλογή <code>-i</code>, θα θέσετε το Portmaster σε διαδραστική λειτουργία, όπου θα σας ζητάει επιβεβαίωση πριν την αναβάθμιση κάθε port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν αντιμετωπίσετε λάθη κατά τη διαδικασία της αναβάθμισης, μπορείτε να χρησιμοποιήσετε την επιλογή <code>-f</code> για να αναβαθμίσετε και να μεταγλωττίσετε ξανά όλα τα ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>Μπορείτε επίσης να χρησιμοποιήσετε το Portmaster για να εγκαταστήσετε νέα ports στο σύστημα σας, αναβαθμίζοντας και όλες τις εξαρτήσεις τους πριν τη μεταγλώττιση και εγκατάσταση τους:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster shells/bash</span></code></pre></div></div><div class=paragraph><p>Παρακαλούμε δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a> για περισσότερες πληροφορίες.</p></div></div></div><div class=sect3><h4 id=ports-disk-space>6.5.5. Ports και Αποθηκευτικός Χώρος<a class=anchor href=#ports-disk-space></a></h4><div class=paragraph><p>Η Συλλογή των Ports καταναλώνει διαθέσιμο χώρο στο δίσκο με την πάροδο του χρόνου. Μετά την μεταγλώττιση και εγκατάσταση λογισμικού από τα ports, πρέπει πάντα να θυμάστε να καθαρίζετε τους προσωρινούς καταλόγους <span class=filename>work</span> χρησιμοποιώντας την εντολή <code>make clean</code>. Mπορείτε να καθαρίσετε όλη την Συλλογή των Ports με την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -C</span></code></pre></div></div><div class=paragraph><p>Με την πάροδο του χρόνου, θα συσσωρευτούν πολλά αρχεία διανομής πηγαίου κώδικα στον κατάλογο <span class=filename>distfiles</span>. Μπορείτε να τα αφαιρέσετε χειροκίνητα, ή μπορείτε να χρησιμοποιήσετε την ακόλουθη εντολή για να διαγράψετε όλα τα distfiles που δεν σχετίζονται πλέον με κανένα port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -D</span></code></pre></div></div><div class=paragraph><p>Ή για να αφαιρέσετε όλα τα distfiles που δεν σχετίζονται με κανένα port που βρίσκεται εγκατεστημένο στο σύστημα σας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -DD</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το εργαλείο <code>portsclean</code> εγκαθίσταται ως μέρος του portupgrade.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μην ξεχνάτε να αφαιρείτε τα εγκατεστημένα ports όταν δεν τα χρειάζεστε πλέον. Ένα καλό εργαλείο για να αυτοματοποιηθεί αυτή η εργασία, είναι το port <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg_cutleaves/>ports-mgmt/pkg_cutleaves</a>.</p></div></div></div><div class=sect2><h3 id=ports-nextsteps>6.6. Ενέργειες μετά την Εγκατάσταση<a class=anchor href=#ports-nextsteps></a></h3><div class=paragraph><p>Μετά την εγκατάσταση μιας νέας εφαρμογής, λογικά θα θέλετε να διαβάσετε ότι τεκμηρίωση υπάρχει, να τροποποιήσετε τα αρχεία ρυθμίσεων που χρειάζεται, να βεβαιωθείτε ότι η εφαρμογή ξεκινάει κατά την εκκίνηση (αν είναι daemon), κ.λ.π.</p></div><div class=paragraph><p>Τα ακριβή βήματα που θα χρειαστούν για να ρυθμίσετε κάθε εφαρμογή, θα είναι προφανώς διαφορετικά. Όμως, αν μόλις εγκαταστήσατε μια νέα εφαρμογή και αναρωτιέστε "Τώρα τι;" οι παρακάτω συμβουλές μπορεί να σας βοηθήσουν:</p></div><div class=ulist><ul><li><p>Χρησιμοποιήστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a> για να δείτε τι αρχεία εγκαταστάθηκαν, και που. Για παράδειγμα, αν μόλις εγκαταστήσατε το FooPackage version 1.0.0, τότε η εντολή:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info -L foopackage-1.0.0 | less</span></code></pre></div></div><div class=paragraph><p>θα σας δείξει όλα τα αρχεία που εγκαταστάθηκαν από αυτό το πακέτο. Προσέξτε τα αρχεία στον κατάλογο <span class=filename>man/</span>, που θα είναι σελίδες manual, τους κατάλογους <span class=filename>etc/</span>, όπου θα είναι τα αρχεία ρυθμίσεων, και το <span class=filename>doc/</span>, όπου θα βρίσκεται πιο περιεκτική τεκμηρίωση.</p></div><div class=paragraph><p>Αν δεν είστε σίγουρος ποια έκδοση της εφαρμογής εγκαταστήσατε, μια εντολή όπως αυτή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info | grep -i foopackage</span></code></pre></div></div><div class=paragraph><p>θα βρει όλα τα εγκατεστημένα πακέτα που έχουν το <em>foopackage</em> στο όνομα του πακέτου. Αντικαταστήστε το <em>foopackage</em> στην γραμμή εντολών με το πακέτο που αναζητάτε.</p></div></li><li><p>Μόλις δείτε που βρίσκονται τα manual pages της εφαρμογής, δείτε τα με την <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a>. Όμοια, δείτε τα παραδείγματα των αρχείων ρύθμισης, και όποια άλλη πρόσθετη τεκμηρίωση διατίθεται.</p></li><li><p>Αν υπάρχει web site για την εφαρμογή, ελέγξτε το για πρόσθετη τεκμηρίωση, συχνές ερωτήσεις (FAQ), και άλλα. Αν δεν είστε σίγουρος για την διεύθυνσή του web site, ίσως το βρείτε στην έξοδο της εντολής:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info foopackage-1.0.0</span></code></pre></div></div><div class=paragraph><p>Αν υπάρχει γραμμή <code>WWW:</code>, θα πρέπει να έχει το URL για το web site της εφαρμογής.</p></div></li><li><p>Ports που πρέπει να ξεκινούν κατά την εκκίνηση (όπως διακομιστές Internet) συνήθως εγκαθιστούν ένα script στο <span class=filename>/usr/local/etc/rc.d</span>. Πρέπει να ελέγξετε το script για την ορθότητα του και να το τροποποιήσετε ή να το μετονομάσετε αν χρειάζεται. Δείτε το <a href=./#configtuning-starting-services>Εκκινώντας Υπηρεσίες</a> για περισσότερες πληροφορίες.</p></li></ul></div></div><div class=sect2><h3 id=ports-broken>6.7. Αντιμετωπίζοντας Χαλασμένα Ports<a class=anchor href=#ports-broken></a></h3><div class=paragraph><p>Αν έρθετε αντιμέτωπος με ένα port το οποίο δεν λειτουργεί, υπάρχουν κάποια πράγματα που μπορείτε να κάνετε:</p></div><div class="olist arabic"><ol class=arabic><li><p>Δείτε αν εκκρεμεί κάποια διόρθωση για το port στο <a href=https://www.FreeBSD.org/support/#gnats>Problem Report database</a>. Εάν ναι, μπορείτε να χρησιμοποιήσετε τη προτεινόμενη διόρθωση.</p></li><li><p>Ζητήστε βοήθεια από τον συντηρητή του port. Πληκτρολογήστε <code>make maintainer</code> ή διαβάστε το <span class=filename>Makefile</span> για να βρείτε την διεύθυνση email του συντηρητή. Στο μήνυμα σας, θυμηθείτε να συμπεριλάβετε το όνομα και την έκδοση του port (στείλτε τη γραμμή <code>$FreeBSD:</code> από το <span class=filename>Makefile</span>) καθώς και την έξοδο του σφάλματος.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μερικά ports δεν συντηρούνται από κάποιο συγκεκριμένο άτομο, αλλά από κάποια <a href=https://docs.freebsd.org/el/articles/mailing-list-faq/>mailing list</a>. Πολλές, αν όχι όλες, από αυτές τις διευθύνσεις έχουν την μορφή <a href=mailto:freebsd-listname@FreeBSD.org>freebsd-listname@FreeBSD.org</a>. Παρακαλούμε να το έχετε υπόψη σας κατά τη διατύπωση των ερωτήσεων σας.</p></div><div class=paragraph><p>Συγκεκριμένα, τα ports που φαίνονται ότι συντηρούνται από το <a href=mailto:ports@FreeBSD.org>ports@FreeBSD.org</a>, δεν συντηρούνται από κανέναν στην πραγματικότητα. Διορθώσεις και υποστήριξη, αν υπάρχουν, έρχονται γενικά από την κοινότητα που συμμετέχει στην συγκεκριμένη mailing list. Χρειαζόμαστε πάντοτε περισσότερους εθελοντές!</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν δεν λάβετε απάντηση, μπορείτε να χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> για να στείλετε μια αναφορά σφάλματος (δείτε το <a href=https://docs.freebsd.org/el/articles/problem-reports/>Γράφοντας Αναφορές Σφάλματος για το FreeBSD</a>).</p></div></li><li><p>Διορθώστε το! Το <a href=https://docs.freebsd.org/en/books/porters-handbook/>Porter’s Handbook</a> περιέχει λεπτομερείς πληροφορίες για την υποδομή των "Ports" ώστε να μπορείτε να διορθώσετε το περιστασιακό προβληματικό port ή ακόμα και να δημιουργήσετε ένα δικό σας port!</p></li><li><p>Ανακτήστε το πακέτο από ένα κοντινό σας FTP site. Η "κύρια" συλλογή πακέτων βρίσκεται στο <code>ftp.FreeBSD.org</code>, στον <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/>κατάλογο πακέτων</a>. Πριν τη χρησιμοποιήσετε, ελέγξτε <em>πρώτα</em> το <a href=./#mirrors-ftp>τοπικό σας mirror</a>. Τα πακέτα είναι πιο σίγουρο ότι θα λειτουργήσουν, από το να προσπαθείτε να μεταγλωττίσετε τον πηγαίο κώδικα, και η διαδικασία τελειώνει πιο γρήγορα. Χρησιμοποιήστε το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> για να εγκαταστήσετε το πακέτο στο σύστημα σας.</p></li></ol></div></div></div></div><div class=sect1><h2 id=x11>Chapter 7. Το Σύστημα X Window<a class=anchor href=#x11></a></h2><div class=sectionbody><div class=sect2><h3 id=x11-synopsis>7.1. Σύνοψη<a class=anchor href=#x11-synopsis></a></h3><div class=paragraph><p>Το FreeBSD χρησιμοποιεί το X11 για να παρέχει στους χρήστες ένα ισχυρό γραφικό περιβάλλον εργασίας. Το περιβάλλον X11 είναι μια υλοποίηση ανοικτού κώδικα του συστήματος X Window που υλοποιείται στο Xorg (καθώς και σε άλλο λογισμικό που δεν περιγράφεται εδώ). Η προεπιλεγμένη και επίσημη διανομή του X11 είναι το Xorg, ο X11 server που αναπτύχθηκε από το X.Org Foundation με άδεια χρήσης αρκετά όμοια με αυτή που χρησιμοποιείται από το FreeBSD. Υπάρχουν επίσης διαθέσιμοι εμπορικοί X servers για το FreeBSD.</p></div><div class=paragraph><p>Για περισσότερες πληροφορίες που σχετίζονται με τις κάρτες γραφικών που υποστηρίζονται από το περιβάλλον X11, δείτε την δικτυακή τοποθεσία <a href=http://www.x.org/>Xorg</a>.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Τα διάφορα τμήματα του συστήματος X Window, και πως συνεργάζονται μεταξύ τους.</p></li><li><p>Πως να εγκαταστήσετε και να ρυθμίσετε το περιβάλλον X11.</p></li><li><p>Πως να εγκαταστήσετε και να ρυθμίσετε διαφορετικούς διαχειριστές παραθύρων (window managers).</p></li><li><p>Πως να χρησιμοποιήσετε TrueType® γραμματοσειρές στο X11.</p></li><li><p>Πως να ρυθμίσετε το σύστημα σας για σύνδεση (login) μέσω γραφικού περιβάλλοντος (XDM).</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να ξέρετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=x-understanding>7.2. Κατανόηση του περιβάλλοντος X11<a class=anchor href=#x-understanding></a></h3><div class=paragraph><p>Η χρήση του περιβάλλοντος X11 για πρώτη φορά μπορεί να προκαλέσει μια μικρή ταραχή σε όποιον έχει συνηθίσει σε άλλα γραφικά περιβάλλοντα, όπως τα Microsoft® Windows® ή το Mac OS®.</p></div><div class=paragraph><p>Γενικά, δεν είναι απαραίτητο να καταλαβαίνετε με κάθε λεπτομέρεια των διαφόρων τμημάτων του X11 και πώς αλληλεπιδρούν μεταξύ τους. Κάποιες βασικές γνώσεις όμως, είναι χρήσιμες και βοηθούν στο να εκμεταλλευτείτε καλύτερα τις δυνατότητες του X11.</p></div><div class=sect3><h4 id=_γιατί_λέγεται_x11_το_περιβάλλον_εργασίας>7.2.1. Γιατί λέγεται X11 το περιβάλλον εργασίας;<a class=anchor href=#_γιατί_λέγεται_x11_το_περιβάλλον_εργασίας></a></h4><div class=paragraph><p>Το X δεν είναι το πρώτο περιβάλλον εργασίας που γράφτηκε για συστήματα UNIX®, αλλά είναι σήμερα το πιο δημοφιλές. Η αρχική ομάδα ανάπτυξης του X είχε δουλέψει σε ένα άλλο σύστημα πριν γράψει το X. Το όνομα του παλιότερου συστήματος ήταν "W" (από την Αγγλική λέξη "window"). Το γράμμα X ήταν απλά το επόμενο γράμμα στο Λατινικό αλφάβητο.</p></div><div class=paragraph><p>Μπορείτε να αναφέρεσθε στο X με τα ονόματα "X", "X Window System", "X11", καθώς και με μερικούς άλλους όρους. Προσοχή όμως: κάποιοι άνθρωποι θεωρούν προσβλητικό τον όρο "X Windows". Για περισσότερες πληροφορίες σχετικά με αυτό, δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a>.</p></div></div><div class=sect3><h4 id=_το_μοντέλο_πελάτηδιακομιστή_των_x11>7.2.2. Το Μοντέλο Πελάτη/Διακομιστή των X11<a class=anchor href=#_το_μοντέλο_πελάτηδιακομιστή_των_x11></a></h4><div class=paragraph><p>Το περιβάλλον X11 έχει σχεδιαστεί από την αρχή έτσι ώστε να έχει εγγενή δικτυακή υποστήριξη, με βάση ένα μοντέλο "πελάτη-διακομιστή".</p></div><div class=paragraph><p>Στο μοντέλο λειτουργίας του X11, ο "διακομιστής X" εκτελείται στον υπολογιστή στον οποίο έχει συνδεθεί το πληκτρολόγιο, η οθόνη και το ποντίκι. Ο διακομιστής X είναι υπεύθυνος για τη διαχείριση της οθόνης, της εισόδου από το πληκτρολόγιο, το ποντίκι, και άλλες συσκευές εισόδου ή εξόδου (για παράδειγμα, μια "ταμπλέτα" μπορεί να χρησιμοποιείται ως συσκευή εισόδου και ένας video-προβολέας ως εναλλακτική συσκευή εξόδου). Κάθε εφαρμογή X (π.χ. το XTerm ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>) είναι ένας "πελάτης". Ένας πελάτης στέλνει μηνύματα στον διακομιστή όπως "Παρακαλώ σχεδίασε ένα παράθυρο σε αυτές τις συντεταγμένες", και ο διακομιστής στέλνει πίσω μηνύματα όπως "Ο χρήστης μόλις πάτησε το πλήκτρο OK".</p></div><div class=paragraph><p>Σε ένα σπίτι ή ένα μικρό γραφείο, ο διακομιστής και οι πελάτες X συχνά εκτελούνται στον ίδιο υπολογιστή. Όμως, είναι απόλυτα εφικτό να εκτελείται ο διακομιστής X σε έναν λιγότερο ισχυρό επιτραπέζιο υπολογιστή, και να εκτελούνται οι εφαρμογές X (οι πελάτες) σε ένα, ας πούμε, ισχυρό και ακριβό μηχάνημα που εξυπηρετεί το γραφείο. Σε αυτό το σενάριο η επικοινωνία μεταξύ των πελατών X και του διακομιστή γίνεται μέσω δικτύου.</p></div><div class=paragraph><p>Αυτό προκαλεί σύγχυση σε ορισμένους, επειδή η ορολογία του X είναι ακριβώς αντίθετη από ότι περίμεναν. Οι χρήστες συνήθως περιμένουν ο "διακομιστής X" να είναι ένα μεγάλο ισχυρό μηχάνημα σε ένα δωμάτιο και ο "πελάτης X" να είναι το μηχάνημα του γραφείου τους.</p></div><div class=paragraph><p>Είναι σημαντικό να θυμάστε ότι ο διακομιστής X είναι το μηχάνημα με την οθόνη και το πληκτρολόγιο, και οι πελάτες X είναι τα προγράμματα που εμφανίζουν τα παράθυρα.</p></div><div class=paragraph><p>Δεν υπάρχει τίποτα στο πρωτόκολλο που να αναγκάζει τα μηχανήματα των πελατών και του διακομιστή να εκτελούνται στο ίδιο λειτουργικό σύστημα, ή ακόμη να εκτελούνται στον ίδιο τύπο υπολογιστή. Είναι απόλυτα εφικτό να εκτελείται ένας διακομιστής X στα Microsoft® Windows® ή στο Mac OS® της Apple, και υπάρχουν διαθέσιμες διάφορες ελεύθερες και εμπορικές εφαρμογές που κάνουν ακριβώς αυτό.</p></div></div><div class=sect3><h4 id=_ο_διαχειριστής_παραθύρων>7.2.3. Ο Διαχειριστής Παραθύρων<a class=anchor href=#_ο_διαχειριστής_παραθύρων></a></h4><div class=paragraph><p>Η φιλοσοφία σχεδιασμού του X μοιάζει πολύ με την φιλοσοφία σχεδιασμού του UNIX®, "εργαλεία, όχι πολιτική". Αυτό σημαίνει ότι το X δεν προσπαθεί να υπαγορεύσει πως θα υλοποιηθεί μια εργασία. Αντίθετα, παρέχονται εργαλεία στον χρήστη, και είναι δική του ευθύνη να αποφασίσει πως θα τα χρησιμοποιήσει.</p></div><div class=paragraph><p>Αυτή η φιλοσοφία επεκτείνεται στο ότι το X δεν υπαγορεύει πως πρέπει να εμφανίζονται τα παράθυρα στην οθόνη, πως θα μετακινηθούν με το ποντίκι, τι συνδυασμοί πλήκτρων πρέπει να χρησιμοποιηθούν για να μετακινηθούμε μεταξύ των παραθύρων (π.χ., <span class=keyseq><kbd>Alt</kbd>+<kbd>Tab</kbd></span>, στην περίπτωση των Microsoft® Windows®), πώς πρέπει να μοιάζουν οι μπάρες τίτλων σε κάθε παράθυρο, αν θα έχουν ή όχι πλήκτρα κλεισίματος πάνω τους, κ.o.κ.</p></div><div class=paragraph><p>Αντίθετα, το X αναθέτει αυτήν την ευθύνη σε μία εφαρμογή που ονομάζεται "Διαχειριστής Παραθύρων". Υπάρχουν πάρα πολλοί διαχειριστές παραθύρων διαθέσιμοι για το περιβάλλον X. Ορισμένοι από αυτούς είναι οι: AfterStep, Blackbox, ctwm, Enlightenment, fvwm, Sawfish, twm, Window Maker, και πολλοί άλλοι. Κάθε ένας από αυτούς τους διαχειριστές παραθύρων έχει διαφορετική αίσθηση και εμφάνιση. Μερικοί από αυτούς υποστηρίζουν "εικονικές επιφάνειες εργασίας", μερικοί επιτρέπουν προσαρμοσμένους συνδυασμούς πλήκτρων για την διαχείριση της επιφάνειας εργασίας, μερικοί έχουν ένα πλήκτρο "Start" ή κάτι παρόμοιο, μερικοί υποστηρίζουν "θέματα" (themes), επιτρέποντας την ολοκληρωτική αλλαγή εμφάνισης με την εφαρμογή ενός νέου θέματος. Οι διαχειριστές παραθύρων που έχουμε αναφέρει ως τώρα, και πολλοί άλλοι, είναι διαθέσιμοι στην κατηγορία <span class=filename>x11-wm</span> της Συλλογής των Ports.</p></div><div class=paragraph><p>Επιπλέον, τα δύο πιο δημοφιλή ολοκληρωμένα περιβάλλοντα εργασίας, το KDE και το GNOME, έχουν τον δικό τους διαχειριστή παραθύρων που είναι ενσωματωμένος με το υπόλοιπο περιβάλλον εργασίας.</p></div><div class=paragraph><p>Κάθε διαχειριστής παραθύρων έχει επίσης και διαφορετικό μηχανισμό ρύθμισης: μερικοί ρυθμίζονται συμπληρώνοντας με χειροκίνητο τρόπο ένα αρχείο ρυθμίσεων, άλλοι διαθέτουν γραφικά εργαλεία για τις περισσότερες ρυθμίσεις. Υπάρχει ακόμα κι ένας (Sawfish) που έχει αρχείο ρυθμίσεων γραμμένο σε μια διάλεκτο της γλώσσας Lisp.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Πολιτική Εστίασης</div><div class=paragraph><p>Άλλο ένα θέμα για το οποίο είναι υπεύθυνος ο διαχειριστής παραθύρων είναι η "πολιτική εστίασης" του ποντικιού. Κάθε σύστημα παραθύρων χρειάζεται κάποιο τρόπο επιλογής του παραθύρου που θα δέχεται αυτά που πληκτρολογούνται, και θα πρέπει να φαίνεται κάπως ότι αυτό το παράθυρο είναι ενεργό.</p></div><div class=paragraph><p>Μία γνωστή πολιτική εστίασης λέγεται "click-to-focus". Αυτό το μοντέλο χρησιμοποιείται στα Microsoft® Windows®, όπου ένα παράθυρο γίνεται ενεργό αν δεχτεί ένα πάτημα του ποντικιού.</p></div><div class=paragraph><p>Το X δεν υποστηρίζει καμία συγκεκριμένη πολιτική εστίασης. Αντίθετα, ο διαχειριστής παραθύρων ελέγχει ποίο παράθυρο έχει εστιαστεί κάθε στιγμή. Διαφορετικοί διαχειριστές παραθύρων υποστηρίζουν διαφορετικές μεθόδους εστίασης. Όλοι τους υποστηρίζουν την μέθοδο click to focus, και οι περισσότεροι από αυτούς υποστηρίζουν και αρκετές άλλες.</p></div><div class=paragraph><p>Οι πιο δημοφιλείς μέθοδοι εστίασης είναι:</p></div><div class=dlist><dl><dt class=hdlist1>focus-follows-mouse</dt><dd><p>Το παράθυρο που βρίσκεται κάτω από τον δείκτη του ποντικιού είναι το παράθυρο που έχει την εστίαση. Το ενεργό παράθυρο δεν είναι απαραίτητο να είναι αυτό που βρίσκεται πάνω από όλα τα άλλα. Η εστίαση αλλάζει με την στόχευση ενός άλλου παραθύρου, χωρίς να είναι απαραίτητο το κλικ πάνω του.</p></dd><dt class=hdlist1>sloppy-focus</dt><dd><p>Αυτή η πολιτική είναι μια μικρή επέκταση του focus-follows-mouse. Με την πολιτική εστίασης focus-follows-mouse, αν το ποντίκι βρεθεί πάνω από το αρχικό (root) παράθυρο (ή το παρασκήνιο) δεν υπάρχει εστίαση σε κανένα παράθυρο, και ότι πληκτρολογείται απλώς χάνεται. Με τη sloppy-focus, η εστίαση αλλάζει μόνο αν ο δείκτης βρεθεί πάνω από ένα νέο παράθυρο, και όχι όταν φεύγει από το τρέχον παράθυρο.</p></dd><dt class=hdlist1>click-to-focus</dt><dd><p>Το ενεργό παράθυρο επιλέγεται με κλικ του ποντικιού. Το παράθυρο τότε "ανασηκώνεται", και εμφανίζεται μπροστά από όλα τα άλλα παράθυρα. Ότι πληκτρολογηθεί θα οδηγηθεί σε αυτό το παράθυρο, ακόμα και αν ο δείκτης μετακινηθεί σε άλλο παράθυρο.</p></dd></dl></div><div class=paragraph><p>Πολλοί διαχειριστές παραθύρων υποστηρίζουν ακόμα πιο εξωτικές πολιτικές εστίασης, καθώς και παραλλαγές των παραπάνω. Συμβουλευθείτε την τεκμηρίωση του εκάστοτε διαχειριστή παραθύρων για περισσότερες λεπτομέρειες.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_γραφικά_στοιχεία_διεπαφής_widgets>7.2.4. Γραφικά Στοιχεία Διεπαφής (Widgets)<a class=anchor href=#_γραφικά_στοιχεία_διεπαφής_widgets></a></h4><div class=paragraph><p>Η προσέγγιση του X να διαθέτει εργαλεία και όχι να υπαγορεύει τον τρόπο χρήσης τους, διευρύνεται και στα γραφικά στοιχεία διεπαφής (widgets) που φαίνονται στην οθόνη σε κάθε εφαρμογή.</p></div><div class=paragraph><p>Τα "widgets" είναι ένας όρος για όλα τα αντικείμενα στο περιβάλλον του χρήστη που μπορεί κάποιος να κάνει κλικ ή να τα χειριστεί με κάποιον τρόπο: πλήκτρα, πλαίσια επιλογής, πλήκτρα εναλλαγής, εικονίδια, λίστες, και άλλα. Τα Microsoft® Windows® τα ονομάζουν "controls (χειριστήρια)".</p></div><div class=paragraph><p>Τα Microsoft® Windows® και το Mac OS® της Apple έχουν και τα δύο πολύ αυστηρή πολιτική γραφικών στοιχείων διεπαφής. Οι προγραμματιστές εφαρμογών πρέπει υποτίθεται να εξασφαλίσουν ότι οι εφαρμογές τους θα έχουν κοινή αίσθηση και εμφάνιση (look and feel). Στο X, δεν θεωρήθηκε απαραίτητο να γίνει επιβολή ενός συγκεκριμένου στυλ γραφικών, ή να τεθούν κάποια υποχρεωτικά γραφικά στοιχεία διεπαφής.</p></div><div class=paragraph><p>Σαν αποτέλεσμα, μην περιμένετε τις εφαρμογές για X να έχουν κοινή εμφάνιση. Υπάρχουν διάφορες δημοφιλείς συλλογές γραφικών στοιχείων διεπαφής και παραλλαγές τους, συμπεριλαμβανομένης και της αυθεντικής Athena συλλογής γραφικών στοιχείων διεπαφής του MIT, Motif® (παραλλαγή της οποίας είναι και η συλλογή γραφικών στοιχείων διεπαφής των Microsoft® Windows®, με λοξές γωνίες και τρεις διαβαθμίσεις του γκρι), το OpenLook, και άλλα.</p></div><div class=paragraph><p>Οι περισσότερες νέες X εφαρμογές σήμερα χρησιμοποιούν μια συλλογή γραφικών στοιχείων διεπαφής με μοντέρνα εμφάνιση, είτε το Qt, που χρησιμοποιείται από το KDE, είτε το GTK+, που χρησιμοποιείται από το GNOME. Από αυτή την άποψη, υπάρχει κάποια σύγκλιση στην εμφάνιση του UNIX® desktop, το οποίο οπωσδήποτε κάνει τα πράγματα ευκολότερα για τον νέο χρήστη.</p></div></div></div><div class=sect2><h3 id=x-install>7.3. Εγκατάσταση του X11<a class=anchor href=#x-install></a></h3><div class=paragraph><p>Το Xorg είναι η προεπιλεγμένη υλοποίηση X11 για το FreeBSD. Το Xorg είναι ο διακομιστής Χ της υλοποίησης X Window System του X.Org Foundation, και είναι ανοικτού κώδικα. Ο Xorg είναι βασισμένος στον κώδικα του XFree86™ 4.4RC2 και του X11R6.6. Η έκδοση του Xorg που διατίθεται από την Συλλογή των Ports του FreeBSD είναι η 7.7.</p></div><div class=paragraph><p>Για να μεταγλωττίσετε και να εγκαταστήσετε το Xorg από την Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/xorg</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Για να μεταγλωττίσετε ολόκληρο το Xorg σιγουρευθείτε ότι έχετε το λιγότερο 4 GB ελεύθερο χώρο διαθέσιμο.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Εναλλακτικά, το X11 μπορεί να εγκατασταθεί άμεσα από πακέτα. Υπάρχουν διαθέσιμα έτοιμα πακέτα του Χ11 για χρήση με το εργαλείο <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>. Αν χρησιμοποιήσετε τη δυνατότητα του <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> για λήψη μέσω δικτύου, δεν θα πρέπει στην γραμμή εντολών να δώσετε τον αριθμό έκδοσης (version number) του πακέτου. Το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> θα "κατεβάσει" αυτόματα την τελευταία έκδοση της εφαρμογής.</p></div><div class=paragraph><p>Έτσι, για να γίνει η λήψη και η εγκατάσταση του Xorg, απλώς εκτελέστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r xorg</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Τα παραπάνω παραδείγματα θα εγκαταστήσουν ολόκληρη την διανομή X11 που περιλαμβάνει διακομιστές, πελάτες, γραμματοσειρές κλπ. Διατίθενται επίσης ξεχωριστά, τμηματικά πακέτα και ports για το X11.</p></div><div class=paragraph><p>Για να εγκαταστήσετε την ελάχιστη δυνατή διανομή X11, μπορείτε εναλλακτικά να χρησιμοποιήσετε το port <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg-minimal/>x11/xorg-minimal</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το υπόλοιπο του κεφαλαίου θα σας εξηγήσει πως ρυθμίζεται το X11, και πως να στήσετε ένα παραγωγικό desktop περιβάλλον.</p></div></div><div class=sect2><h3 id=x-config>7.4. Ρύθμιση του X11<a class=anchor href=#x-config></a></h3><div class=sect3><h4 id=_πριν_ξεκινήσετε>7.4.1. Πριν ξεκινήσετε<a class=anchor href=#_πριν_ξεκινήσετε></a></h4><div class=paragraph><p>Στις περισσότερες περιπτώσεις, το Χ11 ρυθμίζεται αυτόματα. Αν το σύστημα σας είναι παλιό ή διαθέτει εξεζητημένα εξαρτήματα, θα είναι χρήσιμο να μαζέψετε κάποιες επιπλέον πληροφορίες σχετικά με το υλικό σας πριν ξεκινήσετε τη ρύθμιση.</p></div><div class=ulist><ul><li><p>Συχνότητες λειτουργίας της οθόνης σας</p></li><li><p>Chipset της κάρτας γραφικών</p></li><li><p>Μνήμη της κάρτας γραφικών</p></li></ul></div><div class=paragraph><p>Η ανάλυση της οθόνης και ο ρυθμός ανανέωσης προσδιορίζονται από τις οριζόντιες και κατακόρυφες συχνότητες συγχρονισμού της οθόνης. Σχεδόν όλες οι οθόνες υποστηρίζουν αυτόματη ανίχνευση αυτών των τιμών. Κάποια μοντέλα δεν παρέχουν αυτές τις τιμές τις οποίες θα πρέπει να βρείτε στο εγχειρίδιο της οθόνης ή στην ιστοσελίδα του κατασκευαστή.</p></div><div class=paragraph><p>Το chipset (ολοκληρωμένο κύκλωμα) της κάρτας γραφικών ανιχνεύεται επίσης αυτόματα και χρησιμοποιείται για να επιλεγεί το κατάλληλο πρόγραμμα οδήγησης. Είναι ωστόσο χρήσιμο να γνωρίζετε το μοντέλο για την περίπτωση που η αυτόματη ανίχνευση δεν είναι επιτυχής.</p></div><div class=paragraph><p>Η μνήμη της κάρτας γραφικών καθορίζει την ανάλυση και το βάθος χρώματος στο οποίο μπορεί να δουλέψει το σύστημα.</p></div></div><div class=sect3><h4 id=_ρύθμιση_του_x11>7.4.2. Ρύθμιση του X11<a class=anchor href=#_ρύθμιση_του_x11></a></h4><div class=paragraph><p>Το Xorg χρησιμοποιεί το HAL για την αυτόματη ανίχνευση του πληκτρολογίου και του ποντικιού. Τα ports <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/hal/>sysutils/hal</a> και <a class=package href=https://cgit.freebsd.org/ports/tree/devel/dbus/>devel/dbus</a> εγκαθίστανται ως εξαρτήσεις του <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a>, αλλά θα πρέπει να ενεργοποιηθούν με τις ακόλουθες εγγραφές στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hald_enable=&#34;YES&#34;
dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Θα πρέπει να ξεκινήσετε τις υπηρεσίες αυτές (είτε χειροκίνητα, είτε κάνοντας επανεκκίνηση) πριν συνεχίσετε με τη ρύθμιση ή την χρήση του Xorg.</p></div><div class=paragraph><p>Το Xorg μπορεί συχνά να λειτουργήσει χωρίς καμιά επιπλέον ρύθμιση, γράφοντας απλώς στη γραμμή εντολών:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div><div class=paragraph><p>Σε κάποιες περιπτώσεις, η αυτόματη ρύθμιση μπορεί να μη λειτουργήσει σωστά, ή να μη ρυθμίσει τις συσκευές ακριβώς όπως επιθυμείτε. Στις περιπτώσεις αυτές, θα χρειαστεί να κάνετε χειροκίνητες ρυθμίσεις.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Κάποια γραφικά περιβάλλοντα, όπως το GNOME το KDE ή το XFCE, διαθέτουν εργαλεία που επιτρέπουν στο χρήστη να ρυθμίσει με εύκολο τρόπο διάφορες παραμέτρους της οθόνης, όπως η ανάλυση. Αν η προεπιλεγμένη ρύθμιση δεν είναι αποδεκτή, και σκοπεύετε να εγκαταστήσετε κάποιο από αυτά τα περιβάλλοντα, μπορείτε να συνεχίσετε με την εγκατάσταση του, και να ολοκληρώσετε τις ρυθμίσεις σας χρησιμοποιώντας το κατάλληλο γραφικό εργαλείο.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το πρώτο βήμα είναι η δημιουργία ενός αρχικού αρχείου ρυθμίσεων. Ως root, απλώς εκτελέστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -configure</span></code></pre></div></div><div class=paragraph><p>Αυτό θα δημιουργήσει ένα πρότυπο αρχείο ρυθμίσεων του X11 στον κατάλογο <span class=filename>/root</span> με το όνομα <span class=filename>xorg.conf.new</span> (είτε χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> είτε συνδεθείτε απευθείας, η μεταβλητή καταλόγου <code>$HOME</code> αλλάζει δείχνοντας τον κατάλογο του root). Το X11 θα προσπαθήσει να ανιχνεύσει το υποσύστημα γραφικών του συστήματος και να δημιουργήσει ένα αρχείο ρυθμίσεων που θα φορτώνει τους σωστούς οδηγούς συσκευών για το υλικό που ανιχνεύθηκε στο σύστημα σας.</p></div><div class=paragraph><p>Το επόμενο βήμα είναι ο έλεγχος των υπάρχοντων ρυθμίσεων για να επιβεβαιώσετε ότι το Xorg λειτουργεί με το υποσύστημα γραφικών του συστήματος σας. Πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -config xorg.conf.new -retro</span></code></pre></div></div><div class=paragraph><p>Εάν εμφανιστεί ένα μαύρο και γκρι πλέγμα και ένας δείκτης ποντικιού με μορφή X, η ρύθμιση ήταν επιτυχής. Για να τερματίσετε τη δοκιμή, μεταβείτε στην εικονική κονσόλα από την οποία την ξεκινήσατε, πιέζοντας <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Fn</kbd></span> (<kbd>F1</kbd> για την πρώτη εικονική κονσόλα) και πιέστε <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μπορείτε επίσης να χρησιμοποιήσετε τον συνδυασμό πλήκτρων <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Backspace</kbd></span> για τον τερματισμό του προγράμματος. Για να τον ενεργοποιήσετε, δώστε την παρακάτω εντολή σε κάποιο τερματικό του X:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setxkbmap <span class=nt>-option</span> terminate:ctrl_alt_bksp</code></pre></div></div><div class=paragraph><p>Εναλλακτικά, δημιουργήστε ένα αρχείο ρυθμίσεων πληκτρολογίου για το hald με την ονομασία <span class=filename>x11-input.fdi</span> και αποθηκεύστε το στον κατάλογο <span class=filename>/usr/local/etc/hal/fdi/policy</span>. Το αρχείο αυτό θα πρέπει να περιέχει τις παρακάτω γραμμές:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.capabilities&#34; contains=&#34;input.keyboard&#34;&gt;
	  &lt;merge key=&#34;input.x11_options.XkbOptions&#34; type=&#34;string&#34;&gt;terminate:ctrl_alt_bksp&lt;/merge&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>Θα χρειαστεί να επανεκκινήσετε το μηχάνημα σας για να εξαναγκάσετε το hald να διαβάσει αυτό το αρχείο.</p></div><div class=paragraph><p>Θα πρέπει επίσης να προσθέσετε την παρακάτω γραμμή στο αρχείο <span class=filename>xorg.conf.new</span>, στην ενότητα <code>ServerLayout</code> ή <code>ServerFlags</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option	&#34;DontZap&#34;	&#34;off&#34;</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Αν το ποντίκι δεν λειτουργεί, θα χρειαστεί να το ρυθμίσετε πριν συνεχίσετε. Δείτε το <a href=./#mouse>Ρυθμίσεις Ποντικιού (Mouse Settings)</a> στο κεφάλαιο εγκατάστασης του FreeBSD. Επιπρόσθετα, στις πρόσφατες εκδόσεις του Xorg, οι ενότητες <code>InputDevice</code> στο <span class=filename>xorg.conf</span> αγνοούνται καθώς γίνεται χρήση των συσκευών που ανιχνεύθηκαν αυτόματα. Για να επαναφέρετε την παλιά συμπεριφορά, προσθέστε την παρακάτω γραμμή στην ενότητα <code>ServerLayout</code> ή <code>ServerFlags</code> του αρχείου ρυθμίσεων:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;AutoAddDevices&#34; &#34;false&#34;</pre></div></div><div class=paragraph><p>Θα μπορείτε έπειτα να ρυθμίσετε τις συσκευές εισόδου όπως στις προηγούμενες εκδόσεις του Xorg, χρησιμοποιώντας και όποιες άλλες επιλογές χρειάζεστε (π.χ. εναλλαγή πληκτρολογίου).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όπως εξηγήσαμε και προηγουμένως, ο δαίμονας hald αναλαμβάνει να ανιχνεύσει αυτόματα το πληκτρολόγιο σας. Υπάρχει περίπτωση να μην γίνει σωστή ανίχνευση του μοντέλου ή της διάταξης, ωστόσο κάποια γραφικά περιβάλλοντα όπως το GNOME το KDE και το Xfce παρέχουν τα δικά τους εργαλεία για τη ρύθμιση του. Μπορείτε όμως να ρυθμίσετε τις ιδιότητες του πληκτρολογίου και απευθείας, είτε μέσω του βοηθητικού προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=setxkbmap&amp;sektion=1&amp;format=html">setxkbmap(1)</a> είτε με την προσθήκη ενός κανόνα στο hald.</p></div><div class=paragraph><p>Για παράδειγμα, αν κάποιος θέλει να χρησιμοποιήσει ένα πληκτρολόγιο 102 πλήκτρων με γαλλική διάταξη, θα πρέπει να δημιουργήσει ένα αρχείο ρυθμίσεων για το hald με το όνομα <span class=filename>x11-input.fdi</span> και να το αποθηκεύσει στον κατάλογο <span class=filename>/usr/local/etc/hal/fdi/policy</span>. Το αρχείο αυτό θα περιέχει τις παρακάτω γραμμές:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.capabilities&#34; contains=&#34;input.keyboard&#34;&gt;
	  &lt;merge key=&#34;input.x11_options.XkbModel&#34; type=&#34;string&#34;&gt;pc102&lt;/merge&gt;
	  &lt;merge key=&#34;input.x11_options.XkbLayout&#34; type=&#34;string&#34;&gt;fr&lt;/merge&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>Αν το αρχείο αυτό υπάρχει ήδη, απλώς αντιγράψτε τις παραπάνω γραμμές μέσα στο υπάρχον περιεχόμενο.</p></div><div class=paragraph><p>Θα πρέπει να επανεκκινήσετε το μηχάνημα σας για να εξαναγκάσετε το hald να διαβάσει το αρχείο.</p></div><div class=paragraph><p>Μπορείτε επίσης να κάνετε την ίδια ρύθμιση μέσα από ένα τερματικό στα Χ ή ακόμα και από ένα script, εκτελώντας την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setxkbmap <span class=nt>-model</span> pc102 <span class=nt>-layout</span> fr</code></pre></div></div><div class=paragraph><p>Μπορείτε να βρείτε τις διαθέσιμες επιλογές πληκτρολογίων και διατάξεων στο αρχείο <span class=filename>/usr/local/shared/X11/xkb/rules/base.lst</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Έπειτα, προσαρμόστε το αρχείο ρυθμίσεων <span class=filename>xorg.conf.new</span> στις προτιμήσεις σας. Ανοίξτε το με έναν συντάκτη κειμένου όπως ο <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> ή ο <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>. Αν η οθόνη σας είναι παλιό ή εξεζητημένο μοντέλο και δεν υποστηρίζει αυτόματη ανίχνευση των συχνοτήτων λειτουργίας της, μπορείτε να τις καταχωρίσετε χειροκίνητα στο <span class=filename>xorg.conf.new</span> στην ενότητα <code>"Monitor"</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
        Identifier   &#34;Monitor0&#34;
        VendorName   &#34;Monitor Vendor&#34;
        ModelName    &#34;Monitor Model&#34;
        HorizSync    30-107
        VertRefresh  48-120
EndSection</pre></div></div><div class=paragraph><p>Οι περισσότερες οθόνες υποστηρίζουν αυτόματη ανίχνευση των συχνοτήτων λειτουργίας, καθιστώντας έτσι αχρείαστη τη χειροκίνητη καταχώριση αυτών των τιμών. Για τις λίγες περιπτώσεις που δε υποστηρίζεται η αυτόματη ανίχνευση, συνίσταται να χρησιμοποιήσετε τις τιμές που δίνει ο κατασκευαστής για να αποφύγετε πιθανές βλάβες στο υλικό σας.</p></div><div class=paragraph><p>Το X επιτρέπει τη χρήση των δυνατοτήτων DPMS (Energy Star) σε οθόνες που υποστηρίζουν την αντίστοιχη λειτουργία. Το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=xset&amp;sektion=1&amp;format=html">xset(1)</a> ελέγχει τους χρόνους και μπορεί να επιβάλλει τις καταστάσεις standby, suspend, ή off. Αν θέλετε να ενεργοποιήσετε τις δυνατότητες DPMS της οθόνης σας, πρέπει να προσθέσετε την ακόλουθη γραμμή στο Section monitor:</p></div><div class="literalblock programlisting"><div class=content><pre>        Option       &#34;DPMS&#34;</pre></div></div><div class=paragraph><p>Όσο το αρχείο ρυθμίσεων <span class=filename>xorg.conf.new</span> είναι ακόμα ανοικτό σε έναν συντάκτη κειμένου, επιλέξτε την ανάλυση και το βάθος χρωμάτων που επιθυμείτε. Αυτό καθορίζεται στο Section <code>"Screen"</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
        Identifier &#34;Screen0&#34;
        Device     &#34;Card0&#34;
        Monitor    &#34;Monitor0&#34;
        DefaultDepth 24
        SubSection &#34;Display&#34;
                Viewport  0 0
                Depth     24
                Modes     &#34;1024x768&#34;
        EndSubSection
EndSection</pre></div></div><div class=paragraph><p>Η μεταβλητή <code>DefaultDepth</code> ορίζει το προεπιλεγμένο βάθος χρώματος που θα χρησιμοποιηθεί. Μπορείτε να την παρακάμψετε με τον διακόπτη <code>-depth</code> στη γραμμή εντολών του <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a>. Η επιλογή <code>Modes</code> ορίζει την ανάλυση με την οποία θα λειτουργεί η οθόνη σε ένα συγκεκριμένο βάθος χρωμάτων. Προσέξτε ότι υποστηρίζονται μόνο κανονικές καταστάσεις VESA, όπως ορίζονται από το υποσύστημα γραφικών του συστήματος. Στο παραπάνω παράδειγμα, το καθορισμένο βάθος χρωμάτων είναι εικοσιτέσσερα bits ανά pixel. Σε αυτό το βάθος χρωμάτων, η αποδεκτή ανάλυση είναι 1024Χ768 pixels.</p></div><div class=paragraph><p>Τέλος, αποθηκεύστε το αρχείο ρυθμίσεων και ελέγξτε το με την μέθοδο ελέγχου που εξηγήσαμε παραπάνω.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ένα από τα εργαλεία που μπορεί να σας βοηθήσουν κατά την διαδικασία επίλυσης προβλημάτων, είναι τα αρχεία X11 log, που περιέχουν πληροφορίες για κάθε συσκευή που επικοινωνεί με τον διακομιστή X11. Τα αρχεία Xorg log ονομάζονται με την μορφή <span class=filename>/var/log/Xorg.0.log</span>. Το ακριβές όνομα ενός log μπορεί να είναι <span class=filename>Xorg.0.log</span> έως <span class=filename>Xorg.8.log</span> και πάει λέγοντας.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν όλα είναι καλά, το αρχείο ρυθμίσεων πρέπει να τοποθετηθεί σε μια κοινή τοποθεσία ώστε να εντοπίζεται από το <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a>. Αυτή συνήθως είναι η <span class=filename>/etc/X11/xorg.conf</span> ή <span class=filename>/usr/local/etc/X11/xorg.conf</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp xorg.conf.new /etc/X11/xorg.conf</span></code></pre></div></div><div class=paragraph><p>Η διαδικασία ρύθμισης του X11 έχει τώρα ολοκληρωθεί. Το Xorg μπορείτε να το ξεκινήσετε με το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a>. Ο διακομιστής X11 μπορεί επίσης να εκκινήσει με τη βοήθεια του <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div></div><div class=sect3><h4 id=_εξειδικευμένα_θέματα_ρυθμίσεων>7.4.3. Εξειδικευμένα Θέματα Ρυθμίσεων<a class=anchor href=#_εξειδικευμένα_θέματα_ρυθμίσεων></a></h4><div class=sect4><h5 id=_ρυθμίσεις_για_τα_intel_i810_graphics_chipsets>7.4.3.1. Ρυθμίσεις για τα Intel® <code>i810</code> Graphics Chipsets<a class=anchor href=#_ρυθμίσεις_για_τα_intel_i810_graphics_chipsets></a></h5><div class=paragraph><p>Για να χρησιμοποιήσετε κάρτα βασισμένη στα Intel® i810 integrated chipsets, απαιτείται το <span class=filename>agpgart</span>, η διεπαφή προγραμματισμού των X11 για το AGP. Δείτε την σελίδα manual του προγράμματος οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> για περισσότερες πληροφορίες.</p></div><div class=paragraph><p>Mε αυτό τον τρόπο, η ρύθμιση του υλικού σας θα μπορεί να γίνει όπως και σε κάθε άλλη κάρτα γραφικών. Προσοχή, σε συστήματα χωρίς ενσωματωμένο τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a>, ο οδηγός δεν θα φορτωθεί με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Ο οδηγός αυτός πρέπει να βρίσκεται στον πυρήνα κατά την εκκίνηση, είτε στατικά μεταγλωττισμένος, είτε με χρήση του <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect4><h5 id=_προσθέτοντας_μια_widescreen_επίπεδη_οθόνη>7.4.3.2. Προσθέτοντας μια Widescreen Επίπεδη Οθόνη<a class=anchor href=#_προσθέτοντας_μια_widescreen_επίπεδη_οθόνη></a></h5><div class=paragraph><p>Αυτό το τμήμα προϋποθέτει μερικές γνώσεις εξειδικευμένων ρυθμίσεων. Αν οι προσπάθειες με τα συνήθη εργαλεία ρυθμίσεων δεν καταλήξουν σε μια ρύθμιση που να λειτουργεί, υπάρχουν αρκετές πληροφορίες στα αρχεία log που μπορούν να σας βοηθήσουν. Ωστόσο, είναι απαραίτητη η χρήση ενός συντάκτη κειμένου.</p></div><div class=paragraph><p>Οι τρέχουσες αναλύσεις widescreen (WSXGA, WSXGA+, WUXGA, WXGA, WXGA+, κ.α.) υποστηρίζουν formats και aspect ratios (αναλογίες) 16:10 και 16:9 που μπορεί να δημιουργήσουν προβλήματα. Παραδείγματα μερικών κοινών αναλύσεων για αναλογία 16:10 είναι τα:</p></div><div class=ulist><ul><li><p>2560x1600</p></li><li><p>1920x1200</p></li><li><p>1680x1050</p></li><li><p>1440x900</p></li><li><p>1280x800</p></li></ul></div><div class=paragraph><p>Κάποια στιγμή, η ρύθμιση θα γίνεται πολύ απλά προσθέτοντας την ανάλυση ως ένα πιθανό <code>Mode</code> στο <code>Section "Screen"</code> όπως εδώ:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
Identifier &#34;Screen0&#34;
Device     &#34;Card0&#34;
Monitor    &#34;Monitor0&#34;
DefaultDepth 24
SubSection &#34;Display&#34;
	Viewport  0 0
	Depth     24
	Modes     &#34;1680x1050&#34;
EndSubSection
EndSection</pre></div></div><div class=paragraph><p>Το Xorg είναι αρκετά έξυπνο ώστε να ανακτήσει τις πληροφορίες της ανάλυσης της widescreen οθόνης μέσω των πληροφοριών I2C/DDC, γνωρίζοντας έτσι τι μπορεί να χειριστεί η οθόνη όσο αφορά τις συχνότητες και τις αναλύσεις.</p></div><div class=paragraph><p>Αν αυτές οι <code>ModeLines</code> δεν υπάρχουν στους οδηγούς, μπορεί να χρειαστεί να τις δώσετε εσείς στο Xorg. Χρησιμοποιώντας το <span class=filename>/var/log/Xorg.0.log</span> μπορείτε να ανακτήσετε αρκετές πληροφορίες ώστε να δημιουργήσετε μόνοι σας ένα <code>ModeLine</code> που να λειτουργεί. Απλώς αναζητήστε πληροφορίες που θα μοιάζουν με αυτό:</p></div><div class="literalblock programlisting"><div class=content><pre>(II) MGA(0): Supported additional Video Mode:
(II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
(II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
(II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
(II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz</pre></div></div><div class=paragraph><p>Αυτές ονομάζονται πληροφορίες EDID. Η δημιουργία ενός <code>ModeLine</code> από αυτές, γίνεται βάζοντας απλώς τους αριθμούς στη σωστή σειρά:</p></div><div class="literalblock programlisting"><div class=content><pre>ModeLine &lt;name&gt; &lt;clock&gt; &lt;4 horiz. timings&gt; &lt;4 vert. timings&gt;</pre></div></div><div class=paragraph><p>Τελικά, το <code>ModeLine</code> στο <code>Section "Monitor"</code> στο παράδειγμα μας θα μοιάζει με αυτό:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
Identifier      &#34;Monitor1&#34;
VendorName      &#34;Bigname&#34;
ModelName       &#34;BestModel&#34;
ModeLine        &#34;1680x1050&#34; 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option          &#34;DPMS&#34;
EndSection</pre></div></div><div class=paragraph><p>Τώρα που έχετε τελειώσει με αυτά τα απλά βήματα, το X θα πρέπει να λειτουργήσει στη νέα widescreen οθόνη σας.</p></div></div></div></div><div class=sect2><h3 id=x-fonts>7.5. Χρήση Γραμματοσειρών στο X11<a class=anchor href=#x-fonts></a></h3><div class=sect3><h4 id=type1>7.5.1. Γραμματοσειρές τύπου Type1<a class=anchor href=#type1></a></h4><div class=paragraph><p>Οι προκαθορισμένες γραμματοσειρές που συνοδεύουν το X11 δεν είναι ιδανικές για εφαρμογές επιτραπέζιας τυπογραφίας. Οι μεγάλες γραμματοσειρές παρουσίασης φαίνονται οδοντωτές και ερασιτεχνικές, και οι μικρές γραμματοσειρές στο <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> είναι σχεδόν ακατάληπτες. Ευτυχώς όμως, υπάρχουν διαθέσιμες αρκετές, υψηλής ποιότητας γραμματοσειρές Type1 (PostScript®) που μπορούν να χρησιμοποιηθούν άμεσα από το X11. Για παράδειγμα, η συλλογή γραμματοσειρών URW (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/urwfonts/>x11-fonts/urwfonts</a>) περιέχει εκδόσεις υψηλής ποιότητας των συνηθισμένων type1 γραμματοσειρών (Times Roman™, Helvetica™, Palatino™ και άλλες). Η συλλογή Freefonts (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/>x11-fonts/freefonts</a>) περιέχει πολλές περισσότερες γραμματοσειρές, αλλά οι περισσότερες από αυτές είναι για λογισμικό γραφικών όπως το Gimp, και δεν είναι κατάλληλες για γραμματοσειρές οθόνης. Ακόμη, το X11 μπορεί με ελάχιστο κόπο να ρυθμιστεί ώστε να χρησιμοποιεί TrueType® γραμματοσειρές. Για περισσότερες λεπτομέρειες, δείτε την σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> ή το <a href=#truetype>τμήμα σχετικά με τις γραμματοσειρές TrueType®</a>.</p></div><div class=paragraph><p>Για να εγκαταστήσετε τις παραπάνω συλλογές γραμματοσειρών Type1 από την Συλλογή των Ports, εκτελέστε τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fonts/urwfonts</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Με παρόμοιο τρόπο μπορείτε να εγκαταστήσετε και την freefont ή άλλες συλλογές. Για να ανιχνεύσει ο X server αυτές τις γραμματοσειρές, προσθέστε την κατάλληλη γραμμή στο αρχείο ρυθμίσεων του (<span class=filename>/etc/X11/xorg.conf</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath &#34;/usr/local/lib/X11/fonts/URW/&#34;</pre></div></div><div class=paragraph><p>Εναλλακτικά, εκτελέστε στην γραμμή εντολών μιας συνόδου X:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/lib/X11/fonts/URW
% xset fp rehash</code></pre></div></div><div class=paragraph><p>Αυτό θα λειτουργήσει, αλλά όταν τερματίσει η σύνοδος X, οι ρυθμίσεις θα χαθούν, εκτός αν προστεθούν στο αρχείο εκκίνησης (το <span class=filename>~/.xinitrc</span> για μία συνηθισμένη σύνοδο μέσω <code>startx</code>, η το <span class=filename>~/.xsession</span> αν συνδέεστε μέσω ενός γραφικού διαχειριστή σύνδεσης όπως ο XDM). Ένας ακόμη τρόπος είναι να χρησιμοποιήσετε το αρχείο <span class=filename>/usr/local/etc/fonts/local.conf</span>: δείτε το τμήμα <a href=#antialias>anti-aliasing (εξομάλυνσης)</a>.</p></div></div><div class=sect3><h4 id=truetype>7.5.2. Γραμματοσειρές TrueType®<a class=anchor href=#truetype></a></h4><div class=paragraph><p>Το Xorg έχει ενσωματωμένη υποστήριξη απεικόνισης γραμματοσειρών TrueType®. Υπάρχουν δύο διαφορετικά modules (αρθρώματα) που μπορούν να ενεργοποιήσουν αυτήν την λειτουργία. Σε αυτό το παράδειγμα χρησιμοποιείται το freetype module επειδή είναι πιο συνεργάσιμο με τα άλλα back-ends απεικόνισης γραμματοσειρών. Για να ενεργοποιήσετε το freetype module, απλώς προσθέστε την παρακάτω γραμμή στο τμήμα <code>"Module"</code> του αρχείου <span class=filename>/etc/X11/xorg.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>Load  &#34;freetype&#34;</pre></div></div><div class=paragraph><p>Τώρα, δημιουργήστε έναν κατάλογο για τις γραμματοσειρές TrueType® (για παράδειγμα, <span class=filename>/usr/local/lib/X11/fonts/TrueType</span>) και αντιγράψτε όλες τις γραμματοσειρές TrueType® σε αυτόν. Προσέξτε ότι οι γραμματοσειρές TrueType® δεν μπορούν να είναι από ένα σύστημα Macintosh® πρέπει να είναι σε μορφή UNIX®/MS-DOS®/Windows® για να λειτουργούν στο X11. Μόλις αντιγραφούν τα αρχεία στον κατάλογο, χρησιμοποιήστε το ttmkfdir για να δημιουργήσετε το αρχείο <span class=filename>fonts.dir</span>, ώστε ο X font renderer να γνωρίζει την ύπαρξη των νέων αυτών αρχείων. Το <code>ttmkfdir</code> διατίθεται από την Συλλογή των Ports του FreeBSD ως <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/ttmkfdir/>x11-fonts/ttmkfdir</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/lib/X11/fonts/TrueType</span>
<span class=c># ttmkfdir -o fonts.dir</span></code></pre></div></div><div class=paragraph><p>Τώρα, πρoσθέστε τον κατάλογο TrueType® στη διαδρομή των fonts. Αυτό γίνεται με τον ίδιο τρόπο που περιγράψαμε παραπάνω στις <a href=#type1>Type1</a> γραμματοσειρές, χρησιμοποιώντας το</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/lib/X11/fonts/TrueType
% xset fp rehash</code></pre></div></div><div class=paragraph><p>ή απλά προσθέστε μια γραμμή <code>FontPath</code> στο αρχείο <span class=filename>xorg.conf</span>.</p></div><div class=paragraph><p>Αυτό ήταν. Τώρα ο <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>, το Gimp, το StarOffice™, και όλες οι άλλες εφαρμογές X πρέπει να αναγνωρίζουν τις εγκαταστημένες TrueType® γραμματοσειρές. Πολύ μικρές γραμματοσειρές (όπως αυτές που φαίνονται στο κείμενο μιας ιστοσελίδας σε υψηλή ανάλυση) και πολύ μεγάλες γραμματοσειρές (στο StarOffice™) θα φαίνονται τώρα πολύ καλύτερα.</p></div></div><div class=sect3><h4 id=antialias>7.5.3. Anti-Aliased Γραμματοσειρές<a class=anchor href=#antialias></a></h4><div class=paragraph><p>Όλες οι γραμματοσειρές X11 που βρίσκονται στο <span class=filename>/usr/local/lib/X11/fonts/</span> και το <span class=filename>~/.fonts/</span> είναι αυτόματα διαθέσιμες για anti-aliasing σε εφαρμογές Xft-aware, συμπεριλαμβανομένων του KDE, GNOME και Firefox.</p></div><div class=paragraph><p>Για να ελέγξετε ποίες γραμματοσειρές είναι anti-aliased, ή να ρυθμίσετε τις ιδιότητες του anti-aliasing, δημιουργήστε (ή τροποποιήστε, αν ήδη υπάρχει) το αρχείο <span class=filename>/usr/local/etc/fonts/local.conf</span>. Μέσω αυτού του αρχείου μπορούν να ρυθμιστούν αρκετά εξειδικευμένα χαρακτηριστικά του συστήματος γραμματοσειρών Xft. Αυτό το τμήμα περιγράφει μόνο μερικές απλές δυνατότητες. Για περισσότερες λεπτομέρειες, δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a>.</p></div><div class=paragraph><p>Το αρχείο αυτό πρέπει να είναι μορφής XML. Δώστε μεγάλη προσοχή στα πεζά / κεφαλαία, και σιγουρευθείτε ότι όλα τα tags έχουν κλείσει σωστά. Το αρχείο ξεκινά με την συνηθισμένη επικεφαλίδα XML και ένα ορισμό DOCTYPE, και έπειτα ακολουθεί το <code>&lt;fontconfig></code> tag:</p></div><div class="literalblock programlisting"><div class=content><pre>      &lt;?xml version=&#34;1.0&#34;?&gt;
      &lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;&gt;
      &lt;fontconfig&gt;</pre></div></div><div class=paragraph><p>Όπως είπαμε προηγουμένως, όλες οι γραμματοσειρές στο <span class=filename>/usr/local/lib/X11/fonts/</span> όπως και στο <span class=filename>~/.fonts/</span> διατίθενται ήδη σε Xft-aware εφαρμογές. Αν θέλετε να προσθέσετε και άλλους καταλόγους εκτός από αυτούς τους δύο, προσθέστε μια γραμμή παρόμοια με αυτή που ακολουθεί στο <span class=filename>/usr/local/etc/fonts/local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;dir&gt;/path/to/my/fonts&lt;/dir&gt;</pre></div></div><div class=paragraph><p>Αφού προσθέσετε νέες γραμματοσειρές, και ειδικότερα νέους καταλόγους γραμματοσειρών, πρέπει να εκτελέσετε την ακόλουθη εντολή για να αναδημιουργήσετε την cache γραμματοσειρών:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fc-cache -f</span></code></pre></div></div><div class=paragraph><p>Το anti-aliasing κάνει τα άκρα ελαφρώς συγκεχυμένα, κάνοντας έτσι τα πολύ μικρά γράμματα πιο αναγνώσιμα, και αφαιρεί τις "κλίμακες" (σκαλοπάτια) από τα μεγάλα γράμματα, αλλά μπορεί να προκαλέσει ενοχλήσεις στα μάτια αν χρησιμοποιηθεί σε κανονικά μεγέθη. Για να εξαιρέσετε από το anti-aliasing μεγέθη γραμματοσειρών μικρότερα από 14 point, προσθέστε αυτές τις γραμμές:</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;font&#34;&gt;
            &lt;test name=&#34;size&#34; compare=&#34;less&#34;&gt;
                &lt;double&gt;14&lt;/double&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;
                &lt;bool&gt;false&lt;/bool&gt;
            &lt;/edit&gt;
        &lt;/match&gt;
        &lt;match target=&#34;font&#34;&gt;
            &lt;test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;&gt;
                &lt;double&gt;14&lt;/double&gt;
            &lt;/test&gt;
            &lt;edit mode=&#34;assign&#34; name=&#34;antialias&#34;&gt;
                &lt;bool&gt;false&lt;/bool&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p>Το spacing (διαστήματα) σε μερικές monospaced γραμματοσειρές μπορεί επίσης να είναι ακατάλληλο όταν χρησιμοποιείται anti-aliasing. Αυτό φαίνεται να αποτελεί ιδιαίτερο πρόβλημα με το KDE. Μια διόρθωση για αυτό, είναι να επιβάλλετε στο spacing την τιμή 100 για αυτές τις γραμματοσειρές. Προσθέστε τις ακόλουθες γραμμές:</p></div><div class="literalblock programlisting"><div class=content><pre>       &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
           &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
               &lt;string&gt;fixed&lt;/string&gt;
           &lt;/test&gt;
           &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
               &lt;string&gt;mono&lt;/string&gt;
           &lt;/edit&gt;
        &lt;/match&gt;
        &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
            &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                &lt;string&gt;console&lt;/string&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                &lt;string&gt;mono&lt;/string&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p>(αυτό μετονομάζει τα άλλα κοινά ονόματα των fixed γραμματοσειρών ως <code>"mono"</code>), και έπειτα προσθέστε:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
             &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                 &lt;string&gt;mono&lt;/string&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;spacing&#34; mode=&#34;assign&#34;&gt;
                 &lt;int&gt;100&lt;/int&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class=paragraph><p>Συγκεκριμένες γραμματοσειρές, όπως οι Helvetica, μπορεί να εμφανίζουν πρόβλημα όταν είναι anti-aliased. Το πρόβλημα συχνά εκδηλώνεται ως μία γραμματοσειρά κομμένη κάθετα στην μέση. Στην χειρότερη περίπτωση, μπορεί να κάνει κάποιες εφαρμογές να καταρρεύσουν. Για να το αποφύγετε αυτό, μπορείτε να προσθέσετε το ακόλουθο στο <span class=filename>local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
             &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                 &lt;string&gt;Helvetica&lt;/string&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                 &lt;string&gt;sans-serif&lt;/string&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class=paragraph><p>Μόλις τελειώσετε την μετατροπή του <span class=filename>local.conf</span> σιγουρευθείτε ότι κλείσατε το αρχείο με το <code>&lt;/fontconfig></code> tag. Αν δεν το κάνετε, οι αλλαγές σας θα αγνοηθούν.</p></div><div class=paragraph><p>Τέλος, οι χρήστες μπορούν να προσθέσουν τις δικές τους ρυθμίσεις μέσω των προσωπικών τους αρχείων <span class=filename>.fonts.conf</span>. Για να γίνει αυτό, κάθε χρήστης πρέπει απλώς να δημιουργήσει ένα <span class=filename>~/.fonts.conf</span>. Αυτό το αρχείο πρέπει να είναι επίσης XML μορφής.</p></div><div class=paragraph><p>Κάτι τελευταίο: σε μία LCD οθόνη, μπορεί να είναι επιθυμητός ο δειγματισμός sub-pixel. Ο δειγματισμός χειρίζεται χωριστά τα (οριζόντια διαχωρισμένα) κόκκινα, πράσινα και μπλε στοιχεία ώστε να βελτιώσει την οριζόντια ανάλυση. Τα αποτελέσματα μπορεί να είναι δραματικά καλύτερα. Για να τον ενεργοποιήσετε, προσθέστε την παρακάτω γραμμή κάπου στο αρχείο <span class=filename>local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;font&#34;&gt;
             &lt;test qual=&#34;all&#34; name=&#34;rgba&#34;&gt;
                 &lt;const&gt;unknown&lt;/const&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;
                 &lt;const&gt;rgb&lt;/const&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ανάλογα με τον τύπο της οθόνης, το <code>rgb</code> μπορεί να χρειαστεί να αλλάξει σε <code>bgr</code>, <code>vrgb</code> ή <code>vbgr</code>: πειραματιστείτε και δείτε ποίο λειτουργεί καλύτερα.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x-xdm>7.6. Ο X Display Manager<a class=anchor href=#x-xdm></a></h3><div class=sect3><h4 id=_εισαγωγή>7.6.1. Εισαγωγή<a class=anchor href=#_εισαγωγή></a></h4><div class=paragraph><p>Ο X Display Manager (XDM) είναι ένα προαιρετικό μέρος του συστήματος X Windows που χρησιμοποιείται για διαχείριση συνδέσεων (logins). Αυτό είναι χρήσιμο σε πολλές περιπτώσεις, όπως σε απλά "X Terminals", σε desktop μηχανήματα, καθώς και σε διακομιστές μεγάλων δικτύων. Αφού το σύστημα X Windows είναι ανεξάρτητο πρωτοκόλλων και δικτύων, υπάρχει μεγάλο εύρος πιθανών ρυθμίσεων για την λειτουργία X πελατών και διακομιστών σε διαφορετικά μηχανήματα συνδεδεμένα σε ένα δίκτυο. Ο XDM παρέχει ένα γραφικό περιβάλλον για την επιλογή του διακομιστή με τον οποίο θα γίνει η σύνδεση, και για την είσοδο πληροφοριών πιστοποίησης όπως του ονόματος χρήστη και του κωδικού πρόσβασης.</p></div><div class=paragraph><p>Σκεφθείτε τον XDM ως μια εφαρμογή που παρέχει τις ίδιες δυνατότητες στον χρήστη με το εργαλείο <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> (δείτε το <a href=./#term-config>Ρύθμιση</a> για λεπτομέρειες). Το XDM εκτελεί συνδέσεις (logins) στον διακομιστή και έπειτα εκτελεί ένα διαχειριστή συνεδρίας (session manager, συνήθως έναν X διαχειριστή παραθύρων, window manager) για λογαριασμό του χρήστη. Ο XDM έπειτα περιμένει να τερματίσει αυτό το πρόγραμμα, που σηματοδοτεί ότι ο χρήστης τελείωσε και πρέπει να αποσυνδεθεί. Σε αυτό το σημείο, ο XDM μπορεί να εμφανίσει ξανά την οθόνη εισόδου (login) και την οθόνη επιλογής γραφικής σύνδεσης ώστε να συνδεθεί ένας άλλος χρήστης.</p></div></div><div class=sect3><h4 id=_χρήση_του_xdm>7.6.2. Χρήση του XDM<a class=anchor href=#_χρήση_του_xdm></a></h4><div class=paragraph><p>Για να ξεκινήσετε να χρησιμοποιείτε το XDM, εγκαταστήστε το port <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xdm/>x11/xdm</a> (δεν εγκαθίσταται από προεπιλογή στις πρόσφατες εκδόσεις του Xorg). Μπορείτε έπειτα να βρείτε τον δαίμονα XDM στο <span class=filename>/usr/local/bin/xdm</span>. Αυτό το πρόγραμμα μπορεί να εκτελεστεί οποιαδήποτε στιγμή ως <code>root</code> και θα ξεκινήσει να διαχειρίζεται την οθόνη του X στο τοπικό μηχάνημα. Αν ο XDM πρέπει να εκτελείται κάθε φορά που εκκινείται το μηχάνημα, ένας βολικός τρόπος είναι η προσθήκη μιας γραμμής στο <span class=filename>/etc/ttys</span>. Για περισσότερες πληροφορίες σχετικά με την μορφή και την χρήση αυτού του αρχείου, δείτε το <a href=./#term-etcttys>Προσθέτοντας μια Καταχώριση στο /etc/ttys</a>. Υπάρχει μία γραμμή στο αρχικό <span class=filename>/etc/ttys</span> αρχείο για την εκτέλεση του XDM σε ένα εικονικό τερματικό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ttyv8   <span class=s2>&#34;/usr/local/bin/xdm -nodaemon&#34;</span>  xterm   off secure</code></pre></div></div><div class=paragraph><p>Αρχικά αυτή η λειτουργία είναι απενεργοποιημένη - για να την ενεργοποιήσετε αλλάξτε το πεδίο 5 από <code>off</code> σε <code>on</code> και επαννεκίνηστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> χρησιμοποιώντας τις οδηγίες του <a href=./#term-hup>Εξαναγκάστε την init να Ξαναδιαβάσει το /etc/ttys</a>. Το πρώτο πεδίο, το όνομα του τερματικού που θα διαχειρίζεται το πρόγραμμα, είναι το <code>ttyv8</code>. Αυτό σημαίνει ότι ο XDM θα εκτελείται στο 9ο εικονικό τερματικό.</p></div></div><div class=sect3><h4 id=_ρύθμιση_του_xdm>7.6.3. Ρύθμιση του XDM<a class=anchor href=#_ρύθμιση_του_xdm></a></h4><div class=paragraph><p>Ο κατάλογος ρυθμίσεων του XDM βρίσκεται στο <span class=filename>/usr/local/lib/X11/xdm</span>. Σε αυτόν τον κατάλογο υπάρχουν πολλά αρχεία που χρησιμοποιούνται για να αλλάξουν την συμπεριφορά και εμφάνιση του XDM. Τυπικά, θα βρείτε τα παρακάτω αρχεία:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Αρχείο</th><th class="tableblock halign-left valign-top">Περιγραφή</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xaccess</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Κανόνες πιστοποίησης πελατών.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xresources</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προκαθορισμένες τιμές X resource.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xservers</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Λίστα απομακρυσμένων και τοπικών οθονών (Χ displays) στις οποίες θα γίνεται διαχείριση.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsession</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Προεπιλεγμένο script συνόδων για logins.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsetup_</span>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Script για την εκτέλεση εντολών πριν την εμφάνιση του περιβάλλοντος σύνδεσης (login screen).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-config</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ρυθμίσεις για όλες τις απεικονίσεις (displays) που εκτελούνται σε αυτό το μηχάνημα.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-errors</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Λάθη που δημιουργούνται από το πρόγραμμα.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-pid</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το ID της διεργασίας του τρέχοντος XDM.</p></td></tr></tbody></table><div class=paragraph><p>Επίσης σε αυτόν τον κατάλογο υπάρχουν μερικά scripts και προγράμματα που χρησιμοποιούνται για να ρυθμίσουν την επιφάνεια εργασίας όταν εκτελείται το XDM. Θα περιγράψουμε περιληπτικά το σκοπό καθενός από αυτά τα αρχεία. Η ακριβής σύνταξη και χρήση όλων αυτών των αρχείων περιγράφεται στο <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div><div class=paragraph><p>Η προκαθορισμένη ρύθμιση είναι ένα απλό ορθογώνιο παράθυρο σύνδεσης με το όνομα του μηχανήματος να φαίνεται στην κορυφή με μεγάλα γράμματα και τις προτροπές "Login:" και "Password:" από κάτω. Αυτό είναι ένα καλό σημείο εκκίνησης για να αλλάξετε την εμφάνιση του XDM.</p></div><div class=sect4><h5 id=_xaccess>7.6.3.1. Xaccess<a class=anchor href=#_xaccess></a></h5><div class=paragraph><p>Το πρωτόκολλο για σύνδεση με απεικονίσεις που ελέγχονται από το XDM ονομάζεται X Display Manager Connection Protocol (XDMCP). Το αρχείο αυτό είναι ένα σύνολο κανόνων για των έλεγχο των συνδέσεων XDMCP από απομακρυσμένα μηχανήματα. Αγνοείται, εκτός και αν το <span class=filename>xdm-config</span> έχει ρυθμιστεί ώστε να δέχεται εισερχόμενες συνδέσεις. Η προεπιλογή είναι να μην επιτρέπεται σε κανένα πελάτη να συνδεθεί.</p></div></div><div class=sect4><h5 id=_xresources>7.6.3.2. Xresources<a class=anchor href=#_xresources></a></h5><div class=paragraph><p>Πρόκειται για το αρχείο προκαθορισμένων τιμών για τις εφαρμογές εμφάνισης του παράθυρου σύνδεσης (login) και επιλογέα απεικόνισης (display chooser). Μέσα από αυτό μπορεί να τροποποιηθεί η εμφάνιση του προγράμματος login. Η μορφή του είναι ίδια με το αρχείο app-defaults που περιγράφεται στην τεκμηρίωση του X11.</p></div></div><div class=sect4><h5 id=_xservers>7.6.3.3. Xservers<a class=anchor href=#_xservers></a></h5><div class=paragraph><p>Αυτή είναι μια λίστα των απομακρυσμένων σταθμών που πρέπει να εμφανίζονται ως επιλογές στο πρόγραμμα (chooser).</p></div></div><div class=sect4><h5 id=_xsession>7.6.3.4. Xsession<a class=anchor href=#_xsession></a></h5><div class=paragraph><p>Αυτό είναι το προκαθορισμένο session script που εκτελεί το XDM μετά τη σύνδεση κάποιου χρήστη. Κανονικά, κάθε χρήστης θα έχει ένα τροποποιημένο, δικό του, session script στο <span class=filename>~/.xsession</span> που θα παρακάμπτει αυτό το script.</p></div></div><div class=sect4><h5 id=_xsetup>7.6.3.5. Xsetup_*<a class=anchor href=#_xsetup></a></h5><div class=paragraph><p>Τα αρχεία αυτά εκτελούνται αυτόματα πριν την εμφάνιση των παραθύρων επιλογής ή σύνδεσης. Υπάρχει ένα script για κάθε display που χρησιμοποιείται, που ονομάζεται <span class=filename>Xsetup_</span> με το νούμερο του display στο τέλος (για παράδειγμα <span class=filename>Xsetup_0</span>). Κανονικά αυτά τα scripts θα εκτελούν ένα ή δυο προγράμματα στο παρασκήνιο όπως π.χ. το <code>xconsole</code>.</p></div></div><div class=sect4><h5 id=_xdm_config>7.6.3.6. xdm-config<a class=anchor href=#_xdm_config></a></h5><div class=paragraph><p>Το αρχείο αυτό περιέχει ρυθμίσεις στην μορφή των app-defaults, που εφαρμόζονται σε κάθε display που διαχειρίζεται η συγκεκριμένη εγκατάσταση.</p></div></div><div class=sect4><h5 id=_xdm_errors>7.6.3.7. xdm-errors<a class=anchor href=#_xdm_errors></a></h5><div class=paragraph><p>Το αρχείο αυτό περιέχει την έξοδο των διακομιστών X που προσπαθεί να εκτελέσει το XDM. Αν ένα display που προσπαθεί να εκκινήσει o XDM κολλήσει για κάποιο λόγο, καλό είναι να αναζητήσετε εδώ τυχόν μηνύματα σφαλμάτων. Τα μηνύματα αυτά καταγράφονται και στα αρχεία χρηστών <span class=filename>~/.xsession-errors</span>.</p></div></div></div><div class=sect3><h4 id=_διατηρώντας_έναν_διακομιστή_απομακρυσμένων_συνδέσεων>7.6.4. Διατηρώντας έναν Διακομιστή Απομακρυσμένων Συνδέσεων<a class=anchor href=#_διατηρώντας_έναν_διακομιστή_απομακρυσμένων_συνδέσεων></a></h4><div class=paragraph><p>Για να συνδέονται και άλλοι πελάτες στον διακομιστή οθόνης, τροποποιήστε τους κανόνες ελέγχου πρόσβασης, και ενεργοποιήστε τις εισερχόμενες συνδέσεις. Τα παραπάνω είναι, από προεπιλογή ρυθμισμένα σε συντηρητικές τιμές. Για να κάνετε το XDM να δέχεται συνδέσεις, αρχικά μετατρέψτε σε σχόλιο την παρακάτω γραμμή στο αρχείο <span class=filename>xdm-config</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span> SECURITY: <span class=k>do </span>not listen <span class=k>for </span>XDMCP or Chooser requests
<span class=o>!</span> Comment out this line <span class=k>if </span>you want to manage X terminals with xdm
DisplayManager.requestPort:     0</code></pre></div></div><div class=paragraph><p>και μετά επανεκκινήστε τον XDM. Να έχετε υπόψιν σας ότι τα σχόλια στα αρχεία app-defaults ξεκινούν με τον χαρακτήρα "!", και όχι τον συνήθη "#". Μπορεί να επιθυμείτε πιο αυστηρούς κανόνες ελέγχου πρόσβασης. Δείτε τα παραδείγματα στο <span class=filename>Xaccess</span>, και συμβουλευθείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div></div><div class=sect3><h4 id=_αντικαταστάτες_του_xdm>7.6.5. Αντικαταστάτες του XDM<a class=anchor href=#_αντικαταστάτες_του_xdm></a></h4><div class=paragraph><p>Υπάρχουν αρκετοί αντικαταστάτες για το πρόγραμμα XDM. Ένας από αυτούς, ο KDM (έρχεται με το KDE) αναλύεται αργότερα σε αυτό το κεφάλαιο. Ο KDM display manager προσφέρει πολλά προτερήματα στα γραφικά και διακοσμητικά στοιχεία, όπως επίσης και την δυνατότητα να επιλέγουν οι χρήστες τον επιθυμητό διαχειριστή παραθύρων την στιγμή της σύνδεσης.</p></div></div></div><div class=sect2><h3 id=x11-wm>7.7. Γραφικά Περιβάλλοντα<a class=anchor href=#x11-wm></a></h3><div class=paragraph><p>Αυτό το τμήμα περιγράφει μερικά γραφικά περιβάλλοντα που διατίθενται για το X στο FreeBSD. Η έννοια "γραφικό περιβάλλον" μπορεί να σημαίνει οτιδήποτε, από έναν απλό διαχειριστή παραθύρων μέχρι ένα ολοκληρωμένα πακέτο desktop εφαρμογών, όπως το KDE ή το GNOME.</p></div><div class=sect3><h4 id=x11-wm-gnome>7.7.1. GNOME<a class=anchor href=#x11-wm-gnome></a></h4><div class=sect4><h5 id=x11-wm-gnome-about>7.7.1.1. Σχετικά με το GNOME<a class=anchor href=#x11-wm-gnome-about></a></h5><div class=paragraph><p>Το GNOME είναι ένα φιλικό προς τον χρήστη γραφικό περιβάλλον που επιτρέπει στους χρήστες να χρησιμοποιούν και να ρυθμίζουν εύκολα τους υπολογιστές τους. Το GNOME διαθέτει ένα panel (για την εκκίνηση εφαρμογών και την προβολή κατάστασης), επιφάνεια εργασίας (όπου εμφανίζονται δεδομένα και εφαρμογές), ένα πλήθος από διαδεδομένα εργαλεία και εφαρμογές, καθώς και ένα σύνολο τυποποιήσεων που επιτρέπει στις εφαρμογές να συνεργάζονται μεταξύ τους και να δείχνουν ένα συνεπές περιβάλλον εργασίας. Οι χρήστες άλλων λειτουργικών συστημάτων ή περιβάλλoντων θα αισθάνονται σαν στο σπίτι τους χρησιμοποιώντας το πανίσχυρο γραφικό περιβάλλον που παρέχει το GNOME. Περισσότερες πληροφορίες σχετικά με το GNOME στο FreeBSD μπορούν να βρεθούν στο διαδικτυακό τόπο του <a href=http://www.FreeBSD.org/gnome>FreeBSD GNOME Project</a>. Η τοποθεσία περιέχει επίσης και αναλυτικά FAQs σχετικά με την εγκατάσταση, την ρύθμιση, και την διαχείριση του GNOME.</p></div></div><div class=sect4><h5 id=x11-wm-gnome-install>7.7.1.2. Εγκατάσταση του GNOME<a class=anchor href=#x11-wm-gnome-install></a></h5><div class=paragraph><p>Το GNOME μπορεί να εγκατασταθεί εύκολα από πακέτα ή από την Συλλογή των Ports:</p></div><div class=paragraph><p>Για να εγκαταστήσετε το έτοιμο πακέτο του GNOME από το δίκτυο, απλώς πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnome2</span></code></pre></div></div><div class=paragraph><p>Για να μεταγλωττίσετε το GNOME από τον πηγαίο κώδικα, χρησιμοποιήστε την Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/gnome2</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Το GNOME χρειάζεται το σύστημα αρχείων <span class=filename>/proc</span> για να λειτουργήσει σωστά. Προσθέστε τη γραμμή</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>στο αρχείο <span class=filename>/etc/fstab</span> για να γίνεται αυτόματα προσάρτηση του <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a> κατά την εκκίνηση του συστήματος.</p></div><div class=paragraph><p>Μόλις εγκατασταθεί το GNOME, θα πρέπει να ρυθμιστεί ο διακομιστής X ώστε να εκκινεί το GNOME αντί για τον προκαθορισμένο διαχειριστή παραθύρων.</p></div><div class=paragraph><p>Ο ευκολότερος τρόπος για να εκκινήσετε το GNOME είναι με το GDM, τον GNOME Display Manager. Το GDM εγκαθίσταται ως μέρος του GNOME, αλλά είναι ανενεργό αρχικά. Μπορεί να ενεργοποιηθεί με την προσθήκη της γραμμής</p></div><div class="literalblock programlisting"><div class=content><pre>gdm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>στο αρχείο <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Μόλις κάνετε επανεκκίνηση, το GDM θα ξεκινήσει αυτόματα.</p></div><div class=paragraph><p>Επιπρόσθετα, είναι χρήσιμο να ξεκινούν όλες οι υπηρεσίες τις οποίες απαιτεί το GNOME ταυτόχρονα με την εκκίνηση του GDM. Για να γίνεται αυτό προσθέστε τη γραμμή</p></div><div class="literalblock programlisting"><div class=content><pre>gnome_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>στο αρχείο <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Το GNOME μπορεί επίσης να ξεκινήσει από την γραμμή εντολών ρυθμίζοντας κατάλληλα το αρχείο <span class=filename>.xinitrc</span>. Αν υπάρχει ήδη το αρχείο <span class=filename>.xinitrc</span>, απλώς αντικαταστήστε την γραμμή που εκκινεί τον τρέχοντα διαχειριστή παραθύρων με μία που να εκκινεί το /usr/local/bin/gnome-session. Αν δεν θέλετε να κάνετε περισσότερες ρυθμίσεις στο αρχείο, χρειάζεται απλά να γράψετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;/usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Έπειτα, πληκτρολογήστε <code>startx</code>, και θα ξεκινήσει το γραφικό περιβάλλον του GNOME</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν χρησιμοποιείτε κάποιο παλαιότερο display manager, όπως το XDM, το παραπάνω δεν θα λειτουργήσει. Στην περίπτωση αυτή, δημιουργήστε ένα εκτελέσιμο αρχείο <span class=filename>.xsession</span> το οποίο να περιέχει την ίδια εντολή. Τροποποιήστε το αρχείο <span class=filename>.xsession</span> και αντικαταστήστε την εντολή του τρέχοντος διαχειριστή παραθύρων με το /usr/local/bin/gnome-session:</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;#!/bin/sh&#34;</span> <span class=o>&gt;</span> ~/.xsession
% <span class=nb>echo</span> <span class=s2>&#34;/usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;&gt;</span> ~/.xsession
% <span class=nb>chmod</span> +x ~/.xsession</code></pre></div></div><div class=paragraph><p>Άλλη μια επιλογή είναι να ρυθμιστεί ο display manager ώστε να επιτρέπει την επιλογή του διαχειριστή παραθύρων κατά την σύνδεση. Το τμήμα <a href=#x11-wm-kde-details>Λεπτομέρειες KDE</a> εξηγεί πως μπορεί να γίνει αυτό μέσω του KDM, του display manager του KDE.</p></div></div></div><div class=sect3><h4 id=x11-wm-kde>7.7.2. KDE<a class=anchor href=#x11-wm-kde></a></h4><div class=sect4><h5 id=x11-wm-kde-about>7.7.2.1. Σχετικά με το KDE<a class=anchor href=#x11-wm-kde-about></a></h5><div class=paragraph><p>Το KDE είναι ένα σύγχρονο, εύκολο στη χρήση, γραφικό περιβάλλον. Μερικά πράγματα που προσφέρει το KDE στον χρήστη είναι:</p></div><div class=ulist><ul><li><p>Ένα όμορφο σύγχρονο περιβάλλον</p></li><li><p>Ένα περιβάλλον με πλήρη δικτυακή διαφάνεια</p></li><li><p>Ένα ενσωματωμένο σύστημα βοήθειας που επιτρέπει εύκολη, συνεπή πρόσβαση στην βοήθεια για την χρήση του KDE και των εφαρμογών του</p></li><li><p>Συνεπής εμφάνιση και συμπεριφορά όλων των εφαρμογών του KDE</p></li><li><p>Τυποποιημένα menu και γραμμές εργαλείων (toolbars), συνδυασμοί πλήκτρων, χρωματικοί συνδυασμοί, κλπ.</p></li><li><p>Διεθνείς ρυθμίσεις: το KDE διατίθεται σε περισσότερες από 55 γλώσσες</p></li><li><p>Κεντρικό και συνεπές σύστημα ρυθμίσεων βασισμένο σε διαλόγους</p></li><li><p>Μεγάλο αριθμό χρήσιμων εφαρμογών, σχεδιασμένων ειδικά για το KDE</p></li></ul></div><div class=paragraph><p>Το KDE συνοδεύεται από έναν περιηγητή (browser) που ονομάζεται Konqueror, και ανταγωνίζεται σοβαρά τους άλλους περιηγητές των συστημάτων UNIX®. Περισσότερες πληροφορίες για το KDE μπορείτε να βρείτε στο <a href=http://www.kde.org/>KDE website</a>. Για πληροφορίες σχετικές με το FreeBSD και το KDE, συμβουλευθείτε τον διαδικτυακό τόπο του <a href=http://freebsd.kde.org/>KDE/FreeBSD</a>.</p></div><div class=paragraph><p>Υπάρχουν διαθέσιμες δύο εκδόσεις του KDE για το FreeBSD. Η Έκδοση 3, κυκλοφορεί αρκετό καιρό και είναι ακόμα διαθέσιμη στη Συλλογή των Ports αν και δεν συντηρείται πλέον και παρουσιάζει προβλήματα. Η έκδοση 4 ανανεώνεται συνεχώς και είναι η προεπιλογή των χρηστών του KDE. Οι δύο αυτές εκδόσεις μπορούν κάλιστα να συνυπάρχουν στον ίδιο υπολογιστή.</p></div></div><div class=sect4><h5 id=x11-wm-kde-install>7.7.2.2. Εγκατάσταση του KDE<a class=anchor href=#x11-wm-kde-install></a></h5><div class=paragraph><p>Όπως και με το GNOME ή κάθε άλλο γραφικό περιβάλλον, το λογισμικό μπορεί να εγκατασταθεί εύκολα μέσω πακέτων ή από την Συλλογή των Ports:</p></div><div class=paragraph><p>Για να εγκαταστήσετε το KDE 3 μέσω πακέτων από το δίκτυο, απλώς πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r kde</span></code></pre></div></div><div class=paragraph><p>Για να εγκαταστήσετε το KDE 4 μέσω πακέτων από το δίκτυο, απλώς πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r kde4</span></code></pre></div></div><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> θα ανακτήσει αυτόματα την τελευταία έκδοση της εφαρμογής.</p></div><div class=paragraph><p>Για να μεταγλωττίσετε το KDE 3 από τον πηγαίο κώδικα, χρησιμοποιήστε τη Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde3</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Για να μεταγλωττίσετε το KDE 4 από τον πηγαίο κώδικα, χρησιμοποιήστε τη Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Αφού εγκατασταθεί το KDE, θα πρέπει να ρυθμιστεί ο διακομιστής X ώστε να το εκκινεί αντί για τον προκαθορισμένο διαχειριστή παραθύρων. Αυτό γίνεται με την αλλαγή του αρχείου <span class=filename>.xinitrc</span>:</p></div><div class=paragraph><p>Για το KDE 3:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec startkde&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Για το KDE 4:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/kde4/bin/startkde&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Τώρα, όποτε το X Window System εκκινείται μέσω του <code>startx</code>, το γραφικό περιβάλλον θα είναι το KDE.</p></div><div class=paragraph><p>Αν χρησιμοποιείτε κάποιο display manager όπως το XDM, η ρύθμιση είναι λίγο διαφορετική. Θα πρέπει αντί για το <span class=filename>.xinitrc</span> να τροποποιήσετε το <span class=filename>.xsession</span>. Οδηγίες για το KDM δίνονται αργότερα στο κεφάλαιο αυτό.</p></div></div></div><div class=sect3><h4 id=x11-wm-kde-details>7.7.3. Περισσότερες Λεπτομέρειες για το KDE<a class=anchor href=#x11-wm-kde-details></a></h4><div class=paragraph><p>Τώρα που το KDE έχει εγκατασταθεί στο σύστημα, μπορείτε να ανακαλύψετε τις περισσότερες λειτουργίες μέσω των σελίδων βοήθειας ή δοκιμάζοντας μενού και επιλογές. Οι χρήστες των Windows® η του Mac® θα αισθάνονται σαν στο σπίτι τους.</p></div><div class=paragraph><p>Η καλύτερη βοήθεια για το KDE είναι η on-line τεκμηρίωση. Το KDE συνοδεύεται από τον δικό του περιηγητή, τον Konqueror, πολλές χρήσιμες εφαρμογές, και αναλυτική τεκμηρίωση. Το υπόλοιπο αυτής της ενότητας συζητά τεχνικά θέματα που είναι δύσκολο να ανακαλυφθούν με δοκιμές.</p></div><div class=sect4><h5 id=x11-wm-kde-kdm>7.7.3.1. Ο KDE Display Manager<a class=anchor href=#x11-wm-kde-kdm></a></h5><div class=paragraph><p>Ο διαχειριστής ενός πολυχρηστικού συστήματος θέλει ενδεχομένως η σύνδεση των χρηστών να γίνεται μέσω γραφικού περιβάλλοντος. Όπως περιγράψαμε πρίν, μπορεί να χρησιμοποιηθεί το <a href=#x-xdm>XDM</a>. Όμως, το KDE περιέχει μια εναλλακτική επιλογή, το KDM, το οποίο έχει σχεδιαστεί να είναι ποίο ελκυστικό και παρέχει περισσότερες επιλογές κατά τη σύνδεση. Συγκεκριμένα, οι χρήστες μπορούν εύκολα να επιλέξουν (μέσω μενού) ποίο γραφικό περιβάλλον (KDE, GNOME, ή κάποιο άλλο) θα εκτελεστεί μετά την σύνδεση τους.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε το KDM, θα πρέπει να επεξεργαστείτε κάποια αρχεία, τα οποία είναι διαφορετικά ανάλογα με την έκδοση του KDE που θα χρησιμοποιήσετε.</p></div><div class=paragraph><p>Για το KDE 3, θα πρέπει να τροποποιήσετε την εγγραφή για το <code>ttyv8</code> στο <span class=filename>/etc/ttys</span>, όπως φαίνεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyv8 &#34;/usr/local/bin/kdm -nodaemon&#34; xterm on secure</pre></div></div><div class=paragraph><p>Για το KDE 4, θα πρέπει να προσαρτήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a> και να προσθέσετε την παρακάτω γραμμή στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kdm4_enable=&#34;YES&#34;</pre></div></div></div></div><div class=sect3><h4 id=x11-wm-xfce>7.7.4. Xfce<a class=anchor href=#x11-wm-xfce></a></h4><div class=sect4><h5 id=x11-wm-xfce-about>7.7.4.1. Σχετικά με το Xfce<a class=anchor href=#x11-wm-xfce-about></a></h5><div class=paragraph><p>Το Xfce είναι ένα γραφικό περιβάλλον που στηρίζεται στην βιβλιοθήκη GTK+ που χρησιμοποιείται και από το GNOME, αλλά είναι πολύ πιο ελαφρύ και προορίζεται για όσους θέλουν ένα απλό, αποτελεσματικό γραφικό περιβάλλον που είναι εύκολο να χρησιμοποιηθεί και να ρυθμιστεί. Οπτικά, μοιάζει πολύ με το CDE, που συναντάται σε εμπορικά συστήματα UNIX®. Μερικά από τα χαρακτηριστικά του Xfce είναι:</p></div><div class=ulist><ul><li><p>Ένα απλό, εύκολο στην χρήση γραφικό περιβάλλον</p></li><li><p>Πλήρως παραμετροποιήσιμο με το ποντίκι, με drag and drop, κλπ.</p></li><li><p>Κεντρικό panel παρόμοιο με του CDE, με μενού, μικρο-εφαρμογές και πλήκτρα εκκίνησης εφαρμογών</p></li><li><p>Ολοκληρωμένος διαχειριστής παραθύρων, διαχειριστής αρχείων, διαχειριστής ήχου, συμβατότητα με το GNOME, και άλλα</p></li><li><p>Δυνατότητα χρήσης θεμάτων (themes, αφού χρησιμοποιεί το GTK+)</p></li><li><p>Γρήγορο, ελαφρύ και αποτελεσματικό: ιδανικό για παλαιότερα/πιο αργά μηχανήματα ή μηχανήματα με λίγη μνήμη</p></li></ul></div><div class=paragraph><p>Περισσότερες πληροφορίες για το Xfce μπορείτε να βρείτε στη <a href=http://www.xfce.org/>δικτυακή τοποθεσία του Xfce</a>.</p></div></div><div class=sect4><h5 id=x11-wm-xfce-install>7.7.4.2. Εγκατάσταση του Xfce<a class=anchor href=#x11-wm-xfce-install></a></h5><div class=paragraph><p>Υπάρχει (την ώρα που γράφονται αυτές οι γραμμές) έτοιμο πακέτο για το Xfce. Για να το εγκαταστήσετε, απλώς πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r xfce4</span></code></pre></div></div><div class=paragraph><p>Εναλλακτικά, για να το μεταγλωττίσετε από τον πηγαίο κώδικα, χρησιμοποιήστε την Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-wm/xfce4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Τώρα, πείτε στον διακομιστή X να εκκινήσει το Xfce την επόμενη φορά που θα γίνει εκκίνηση του γραφικού περιβάλλοντος. Απλώς πληκτρολογήστε το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;/usr/local/bin/startxfce4&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Την επόμενη φορά που θα εκκινήσετε το Χ, θα εμφανιστεί το Xfce. Όπως και προηγουμένως, αν χρησιμοποιείτε κάποιο display manager όπως το XDM, δημιουργήστε ένα αρχείο <span class=filename>.xsession</span>, όπως περιγράφεται στην παράγραφο του <a href=#x11-wm-gnome>GNOME</a>, αλλά με την εντολή <span class=filename>/usr/local/bin/startxfce4</span>, ή ρυθμίστε τον display manager να επιτρέπει την επιλογή γραφικού περιβάλλοντος, όπως περιγράφεται στην παράγραφο σχετικά με το <a href=#x11-wm-kde-kdm>kdm</a>.</p></div><div class=paragraph><p>path: "/books/handbook/partii/"
---
:leveloffset: +1</p></div></div></div></div></div></div><h1 id=desktop class=sect0>Part II: Desktop Εφαρμογές<a class=anchor href=#desktop></a></h1><div class=sect1><h2 id=desktop-synopsis>Chapter 8. Σύνοψη<a class=anchor href=#desktop-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Το FreeBSD μπορεί να εκτελέσει μια ευρεία γκάμα desktop εφαρμογών, όπως φυλλομετρητές (browsers) και επεξεργαστές κειμένου. Οι περισσότερες από αυτές είναι διαθέσιμες ως πακέτα (packages) ή μπορούν να εγκατασταθούν αυτόματα από την Συλλογή των Ports. Πολλοί νέοι χρήστες αναμένουν να βρουν τέτοιου είδους εφαρμογές στο desktop τους. Το κεφάλαιο αυτό θα σας δείξει πως να εγκαταστήσετε χωρίς κόπο τις πιο δημοφιλείς desktop εφαρμογές, είτε από πακέτα είτε από τη Συλλογή των Ports.</p></div><div class=paragraph><p>Σημειώστε ότι όταν εγκαθιστάτε προγράμματα από τη Συλλογή των Ports, γίνεται μεταγλώττιση από τον πηγαίο κώδικα. Αυτό μπορεί να χρειαστεί πολύ χρόνο, καθώς εξαρτάται από το πρόγραμμα το οποίο μεταγλωττίζετε και την υπολογιστική ισχύ του μηχανήματός σας. Αν το χρονικό διάστημα το οποίο χρειάζεται η μεταγλώττιση είναι απαγορευτικά μεγάλο, μπορείτε να εγκαταστήσετε τα περισσότερα προγράμματα της Συλλογής των Ports από προ-μεταγλωττισμένα πακέτα.</p></div><div class=paragraph><p>Καθώς το FreeBSD διαθέτει συμβατότητα με εκτελέσιμα προγράμματα για Linux, πολλές εφαρμογές που αναπτύχθηκαν αρχικά για το Linux είναι διαθέσιμες για το desktop σας. Σας συνιστούμε θερμά να διαβάσετε το <a href=./#linuxemu>Συμβατότητα με Εκτελέσιμα του Linux</a> πριν εγκαταστήσετε οποιαδήποτε από τις εφαρμογές Linux. Πολλά από τα ports που χρησιμοποιούν τη συμβατότητα με Linux έχουν ονόματα που ξεκινούν με "linux-". Θυμηθείτε το όταν ψάχνετε για κάποιο συγκεκριμένο port, για παράδειγμα με την <a href="https://man.freebsd.org/cgi/man.cgi?query=whereis&amp;sektion=1&amp;format=html">whereis(1)</a>. Στο κείμενο που ακολουθεί θεωρείται ότι έχετε ενεργοποιήσει την συμβατότητα με εκτελέσιμα προγράμματα Linux πριν εγκαταστήσετε οποιαδήποτε από τις εφαρμογές του Linux.</p></div><div class=paragraph><p>Οι κατηγορίες που καλύπτονται από αυτό το κεφάλαιο είναι οι εξής:</p></div><div class=ulist><ul><li><p>Φυλλομετρητές (όπως Firefox, Opera, KonquerorChromium)</p></li><li><p>Εφαρμογές γραφείου (όπως KOffice, AbiWord, The GIMP, OpenOffice.org, LibreOffice)</p></li><li><p>Προγράμματα προβολής εγγράφων (όπως Acrobat Reader®, gv, Xpdf, GQview)</p></li><li><p>Χρηματοοικονομικές εφαρμογές (όπως GnuCash, Gnumeric, Abacus)</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο θα πρέπει:</p></div><div class=ulist><ul><li><p>Να ξέρετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li><li><p>Να ξέρετε πως να εγκαταστήσετε πρόσθετο λογισμικό Linux (<a href=./#linuxemu>Συμβατότητα με Εκτελέσιμα του Linux</a>).</p></li></ul></div><div class=paragraph><p>Για πληροφορίες σχετικά με την εγκατάσταση πολυμεσικού περιβάλλοντος διαβάστε το <a href=./#multimedia>Πολυμέσα</a>. Αν θέλετε να ρυθμίσετε και να χρησιμοποιήσετε κάποια υπηρεσία ηλεκτρονικού ταχυδρομείου δείτε το <a href=./#mail>Ηλεκτρονικό Ταχυδρομείο</a>.</p></div></div></div><div class=sect1><h2 id=desktop-browsers>Chapter 9. Φυλλομετρητές (Browsers)<a class=anchor href=#desktop-browsers></a></h2><div class=sectionbody><div class=paragraph><p>Το FreeBSD δεν έχει προεγκατεστημένο κάποιο συγκεκριμένο φυλλομετρητή. Στον κατάλογο <a href=http://www.FreeBSD.org/ports/www.html>www</a> της συλλογής Ports μπορείτε να βρείτε αρκετούς φυλλομετρητές, έτοιμους για εγκατάσταση. Αν δεν έχετε χρόνο για να μεταγλωττίσετε ότι χρειάζεστε (ίσως χρειαστείτε αρκετή ώρα), πολλοί από αυτούς είναι διαθέσιμοι και ως έτοιμα πακέτα.</p></div><div class=paragraph><p>Τα KDE και GNOME, ως πλήρη περιβάλλοντα εργασίας, παρέχουν τους δικούς τους φυλλομετρητές HTML. Δείτε το <a href=./#x11-wm>Γραφικά Περιβάλλοντα</a> για περισσότερες πληροφορίες σχετικά με την εγκατάσταση τους.</p></div><div class=paragraph><p>Αν ενδιαφέρεστε για ελαφρείς (από άποψη κατανάλωσης πόρων) φυλλομετρητές, δείτε τις ακόλουθες εφαρμογές στη συλλογή των Ports: <a class=package href=https://cgit.freebsd.org/ports/tree/www/dillo2/>www/dillo2</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/www/links/>www/links</a>, ή <a class=package href=https://cgit.freebsd.org/ports/tree/www/w3m/>www/w3m</a>.</p></div><div class=paragraph><p>Το τμήμα αυτό καλύπτει τις παρακάτω εφαρμογές:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Όνομα Εφαρμογής</th><th class="tableblock halign-left valign-top">Άδεια</th><th class="tableblock halign-left valign-top">Πακέτο</th><th class="tableblock halign-left valign-top">Απαιτούμενοι Πόροι</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MPL 2.0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chromium</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BSD-3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/chromium</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Iridium browser</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BSD-3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/iridium-browser</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Falkon</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MPL 2.0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/falkon-qtonly</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GPL 2.0 ή νεότερη</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x11-fm/konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>μεσαία</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnome Web (Epiphany)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GPL 3.0 ή νεότερη</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/epiphany</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>μεσαία</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>qutebrowser</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GPL 3.0 ή νεότερη</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/qutebrowser</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>μεσαία</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Dillo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GPL 3.0 ή νεότερη</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/dillo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Links</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GPL 2.0 ή νεότερη</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/links</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>w3m</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MIT</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>www/w3m</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td></tr></tbody></table><div class=sect2><h3 id=_firefox>9.1. Firefox<a class=anchor href=#_firefox></a></h3><div class=paragraph><p>Ο Firefox είναι ένας μοντέρνος, ελεύθερος, ανοιχτός και σταθερός φυλλομετρητής, ο οποίος είναι πλήρως προσαρμοσμένος για χρήση στο FreeBSD. Διαθέτει μηχανή απεικόνισης η οποία εναρμονίζεται πλήρως με τις τυποποιήσεις της HTML, και δυνατότητες όπως εμφάνιση πολλαπλών σελίδων σε tabs, μπλοκάρισμα αναδυόμενων παραθύρων (popups), πρόσθετα προγράμματα, βελτιωμένη ασφάλεια και πολλά ακόμη. Ο Firefox βασίζεται στον αρχικό πηγαίο κώδικα του Mozilla.</p></div><div class=paragraph><p>Εγκαταστήστε το πακέτο γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox</span></code></pre></div></div><div class=paragraph><p>Η παραπάνω εντολή θα εγκαταστήσει την τελευταία σταθερή έκδοση του Firefox. Αν θέλετε να εγκαταστήσετε την παλιά έκδοση εκτεταμένης υποστήριξης (Extended Support Release, ESR), πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox-esr</span></code></pre></div></div><div class=paragraph><p>Μπορείτε επίσης να χρησιμοποιήσετε την Συλλογή των Ports αν προτιμάτε να μεταγλωττίσετε από τον πηγαίο κώδικα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/firefox</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Για τον Firefox ESR, αντικαταστήστε στην παραπάνω εντολή τη λέξη <code>firefox</code> με <code>firefox-esr</code>.</p></div></div><div class=sect2><h3 id=_opera>9.2. Opera<a class=anchor href=#_opera></a></h3><div class=paragraph><p>Ο Opera είναι ένας φυλλομετρητής με πλήρεις δυνατότητες και συμβατός με τα πρότυπα. Έρχεται επίσης με ενσωματωμένο πρόγραμμα ανάγνωσης ταχυδρομείου (mail) και ειδήσεων (news), πρόγραμμα για IRC, αναγνώστη για RSS/Atom και πολλά ακόμα. Παρ’όλα αυτά, ο Opera είναι μια σχετικά ελαφριά και πολύ γρήγορη εφαρμογή. Έρχεται σε δύο τύπους: μια "εγγενής" έκδοση για το FreeBSD και μια έκδοση που εκτελείται μέσω της συμβατότητας με το Linux.</p></div><div class=paragraph><p>Για να χρησιμοποιήσετε την FreeBSD έκδοση του Opera, εγκαταστήστε το πακέτο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r opera</span></code></pre></div></div><div class=paragraph><p>Ορισμένες τοποθεσίες FTP δεν διαθέτουν όλα τα πακέτα, αλλά μπορείτε να έχετε το ίδιο αποτέλεσμα μέσω της συλλογής των Ports, γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/opera</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Για να εγκαταστήσετε την Linux έκδοση του Opera, αντικαταστήστε με <code>linux-opera</code> το <code>opera</code> στα παραπάνω παραδείγματα.</p></div><div class=paragraph><p>Το πρόσθετο Adobe® Flash™ δεν είναι διαθέσιμο για το FreeBSD. Διατίθεται ωστόσο μια έκδοση κατάλληλη για το Linux®. Για να την χρησιμοποιήσετε θα πρέπει αρχικά να εγκαταστήσετε το port <a class=package href=https://cgit.freebsd.org/ports/tree/www/linux-f10-flashplugin11/>www/linux-f10-flashplugin11</a> και έπειτα το port <a class=package href=https://cgit.freebsd.org/ports/tree/www/opera-linuxplugins/>www/opera-linuxplugins</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/linux-f11-flashplugin10</span>
<span class=c># make install clean</span>
<span class=c># cd /usr/ports/www/opera-linuxplugins</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Μπορείτε να ελέγξετε εύκολα την ύπαρξη του plugin: ξεκινήστε τον φυλλομετρητή σας, γράψτε <code>opera:plugins</code> στη γραμμή διευθύνσεων και πιέστε <kbd>Enter</kbd>. Θα πρέπει να δείτε μια λίστα με όλα τα διαθέσιμα πρόσθετα.</p></div><div class=paragraph><p>Για να προσθέσετε το πρόσθετο της Java™, ακολουθήστε τις <a href=#moz-java-plugin>αντίστοιχες οδηγίες για τον Firefox</a>.</p></div></div><div class=sect2><h3 id=_konqueror>9.3. Konqueror<a class=anchor href=#_konqueror></a></h3><div class=paragraph><p>Ο Konqueror είναι κομμάτι του KDE αλλά μπορεί να χρησιμοποιηθεί και έξω από το KDE με την εγκατάσταση του <a class=package href=https://cgit.freebsd.org/ports/tree/x11/kdebase3/>x11/kdebase3</a>. Ο Konqueror είναι πολύ περισσότερο από ένας απλός φυλλομετρητής, είναι επίσης διαχειριστής αρχείων και πρόγραμμα προβολής αρχείων πολυμέσων.</p></div><div class=paragraph><p>Ο Konqueror διατίθεται επίσης με ένα σετ από plugins, στο <a class=package href=https://cgit.freebsd.org/ports/tree/misc/konq-plugins/>misc/konq-plugins</a>.</p></div><div class=paragraph><p>Ο Konqueror υποστηρίζει τόσο το WebKit όσο και το δικό του KHTML. Το WebKit χρησιμοποιείται από πολλούς σύγχρονους φυλλομετρητές, συμπεριλαμβανομένου και του Chromium. Για να χρησιμοποιήσετε το WebKit με τον Konqueror στο FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/kwebkitpart</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Μετά την εγκατάσταση, στον Konqueror κάντε κλικ στο "Settings", "Configure Konqueror" και τέλος στο "Change KHTML to WebKit".</p></div><div class=paragraph><p>Ο Konqueror υποστηρίζει επίσης Flash™ και οι σχετικές οδηγίες (How To) είναι διαθέσιμες στο <a href=http://freebsd.kde.org/howtos/konqueror-flash.php>http://freebsd.kde.org/howtos/konqueror-flash.php</a>.</p></div></div><div class=sect2><h3 id=_chromium>9.4. Chromium<a class=anchor href=#_chromium></a></h3><div class=paragraph><p>Ο Chromium είναι μια εφαρμογή browser ανοικτού κώδικα που στοχεύει στη βελτίωση της εμπειρίας του χρήστη παρέχοντας ένα φυλλομετρητή ο οποίος είναι ασφαλέστερος, ταχύτερος και πιο σταθερός. Ο Chromium παρέχει δυνατότητα εμφάνισης σελίδων σε καρτέλες, αποκλεισμό αναδυόμενων παραθύρων (popup blocker), πρόσθετα (extensions) και πολλά ακόμα. Ο Chromium είναι το Έργο ανοικτού κώδικα στο οποίο βασίζεται ο φυλλομετρητής Google Chrome.</p></div><div class=paragraph><p>Ο Chromium μπορεί να εγκατασταθεί από πακέτο, με την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r chromium</span></code></pre></div></div><div class=paragraph><p>Εναλλακτικά, μπορείτε να μεταγλωττίσετε τον Chromium χρησιμοποιώντας τη Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/chromium</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ο Chromium εγκαθιστάται ως <span class=filename>/usr/local/bin/chrome</span> και όχι ως <span class=filename>/usr/local/bin/chromium</span>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=chromium-java-plugin>9.5. Ο Chromium και το Πρόσθετο της Java™<a class=anchor href=#chromium-java-plugin></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Στην ενότητα αυτή θεωρούμε ότι έχετε ήδη εγκαταστήσει τον Chromium.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Εγκαταστήστε το OpenJDK 6 μέσω της Συλλογής των Ports, γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/java/openjdk6</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Έπειτα, εγκαταστήστε το <a class=package href=https://cgit.freebsd.org/ports/tree/java/icedtea-web/>java/icedtea-web</a> από τη Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/java/icedtea-web</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Ξεκινήστε τον Chromium και πληκτρολογήστε <code>about:plugins</code> στη γραμμή διευθύνσεων. Θα πρέπει να δείτε το IcedTea-Web να εμφανίζεται ως ένα από τα πρόσθετα.</p></div><div class=paragraph><p>Αν το πρόσθετο δεν εμφανίζεται στον Chromium, εκτελέστε τις παρακάτω εντολές και επανεκκινήστε το φυλλομετρητή σας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /usr/local/shared/chromium/plugins</span>
<span class=c>#  ln -s /usr/local/lib/IcedTeaPlugin.so \</span>
  /usr/local/shared/chromium/plugins/</code></pre></div></div></div><div class=sect2><h3 id=chromium-flash-plugin>9.6. Ο Chromium και το Πρόσθετο Adobe® Flash™<a class=anchor href=#chromium-flash-plugin></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Στην ενότητα αυτή θεωρούμε ότι έχετε ήδη εγκαταστήσει τον Chromium.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για τη ρύθμιση του Chromium για χρήση με το πρόσθετο Adobe® Flash™, χρησιμοποιήστε τις <a href=#moz-flash-plugin>οδηγίες για τον Firefox</a>. Στον προηγούμενο σύνδεσμο θα βρείτε πλήρεις οδηγίες για την εγκατάσταση του Adobe® Flash™ στο FreeBSD. Δεν απαιτούνται επιπλέον βήματα, καθώς ο Chromium μπορεί να χρησιμοποιήσει κάποια πρόσθετα από άλλους φυλλομετρητές.</p></div></div></div></div><div class=sect1><h2 id=desktop-productivity>Chapter 10. Εφαρμογές Γραφείου<a class=anchor href=#desktop-productivity></a></h2><div class=sectionbody><div class=paragraph><p>Όσο αφορά τις εφαρμογές γραφείου, οι νέοι χρήστες συχνά αναζητούν μια καλή σουίτα εφαρμογών ή ένα φιλικό επεξεργαστή κειμένου. Αν και κάποια <a href=./#x11-wm>γραφικά περιβάλλοντα</a> όπως το KDE παρέχουν τη δική τους σουίτα εφαρμογών γραφείου, δεν υπάρχει ωστόσο προεπιλεγμένη εφαρμογή. Το FreeBSD παρέχει ότι χρειάζεστε, άσχετα από το περιβάλλον εργασίας σας.</p></div><div class=paragraph><p>Το τμήμα αυτό καλύπτει τις παρακάτω εφαρμογές:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Όνομα Εφαρμογής</th><th class="tableblock halign-left valign-top">Απαιτούμενοι Πόροι</th><th class="tableblock halign-left valign-top">Εγκατάσταση από Ports</th><th class="tableblock halign-left valign-top">Βασικές Εξαρτήσεις</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ ή GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The Gimp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>OpenOffice.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>πολλοί (βαριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εξαιρετικά βαριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>JDK™, Mozilla</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LibreOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σχετικά βαριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>τεράστια</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ ή KDE/ GNOME ή JDK™</p></td></tr></tbody></table><div class=sect2><h3 id=_koffice>10.1. KOffice<a class=anchor href=#_koffice></a></h3><div class=paragraph><p>Η κοινότητα του KDE εξοπλίζει το γραφικό της περιβάλλον με μια σουίτα εφαρμογών γραφείου που μπορεί να χρησιμοποιηθεί και έξω από το KDE. Περιλαμβάνει τα τέσσερα βασικά προγράμματα που μπορείτε επίσης να βρείτε και σε άλλες σουίτες γραφείου. Το KWord είναι ο επεξεργαστής κειμένου, το KSpread είναι το πρόγραμμα υπολογιστικών φύλλων, το KPresenter διαχειρίζεται τις παρουσιάσεις, ενώ το Kontour σας επιτρέπει να δημιουργήσετε έγγραφα με γραφικά.</p></div><div class=paragraph><p>Πριν εγκαταστήσετε το τελευταίο KOffice, βεβαιωθείτε ότι έχετε ανανεωμένη έκδοση του KDE.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το KOffice για το KDE4 ως πακέτο, δώστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r koffice-kde4</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο, μπορείτε να χρησιμοποιήσετε την Συλλογή των Ports. Για παράδειγμα, για να εγκαταστήσετε το KOffice για το KDE4, πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/koffice-kde4</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_abiword>10.2. AbiWord<a class=anchor href=#_abiword></a></h3><div class=paragraph><p>Το AbiWord είναι ένα ελεύθερο πρόγραμμα επεξεργασίας κειμένου, όμοιο στην αίσθηση και την εμφάνιση με το Microsoft® Word. Είναι κατάλληλο για την πληκτρολόγηση άρθρων, γραμμάτων, αναφορών, υπενθυμίσεων κ.ο.κ. Είναι πολύ γρήγορο, έχει αρκετές δυνατότητες και είναι ιδιαίτερα φιλικό στο χρήστη.</p></div><div class=paragraph><p>Το AbiWord μπορεί να εισάγει ή να εξάγει αρχεία διάφορων μορφών, περιλαμβανομένων και κάποιων κλειστών όπως το <span class=filename>.doc</span> της Microsoft®.</p></div><div class=paragraph><p>Το AbiWord είναι διαθέσιμο ως πακέτο. Μπορείτε να το εγκαταστήσετε γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r abiword</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο για κάποιο λόγο, μπορείτε να το μεταγλωττίσετε από την Συλλογή των Ports. Σε αυτή την περίπτωση πιθανώς να εγκαταστήσετε νεώτερη έκδοση σε σχέση με το έτοιμο πακέτο. Μπορείτε να το κάνετε ως εξής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/abiword</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_το_gimp>10.3. Το GIMP<a class=anchor href=#_το_gimp></a></h3><div class=paragraph><p>Το The GIMP είναι ένα ιδιαίτερα εξελιγμένο πρόγραμμα διαχείρισης γραφικών για δημιουργία εικόνων ή επεξεργασία φωτογραφιών. Μπορεί να χρησιμοποιηθεί ως απλό πρόγραμμα ζωγραφικής ή σαν σουίτα επεξεργασίας και διόρθωσης φωτογραφιών. Περιέχει μεγάλο αριθμό από plugins ενώ διαθέτει και scripting interface. Το The GIMP μπορεί να διαβάσει και να γράψει μεγάλο φάσμα αρχείων εικόνας. Περιλαμβάνει επίσης διεπαφές διασύνδεσης με σαρωτές και tablets.</p></div><div class=paragraph><p>Μπορείτε να εγκαταστήσετε το πακέτο δίνοντας την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gimp</span></code></pre></div></div><div class=paragraph><p>Αν η τοποθεσία FTP που χρησιμοποιείτε δεν διαθέτει αυτό το πακέτο, μπορείτε να χρησιμοποιήσετε την Συλλογή των Ports. Ο κατάλογος <a href=http://www.FreeBSD.org/ports/>graphics</a> της Συλλογής των Ports περιέχει επίσης και το The Gimp Manual (εγχειρίδιο χρήσης). Δείτε παρακάτω πως να το εγκαταστήσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gimp</span>
<span class=c># make install clean</span>
<span class=c># cd /usr/ports/graphics/gimp-manual-pdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ο κατάλογος <a href=http://www.FreeBSD.org/ports/>graphics</a> της συλλογής των Ports έχει επίσης την υπό εξέλιξη έκδοση της εφαρμογής The GIMP στο <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp-devel/>graphics/gimp-devel</a>. Μπορείτε να βρείτε την HTML έκδοση του εγχειριδίου, The Gimp Manual στο <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp-manual-html/>graphics/gimp-manual-html</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_openoffice_org>10.4. OpenOffice.org<a class=anchor href=#_openoffice_org></a></h3><div class=paragraph><p>Το OpenOffice.org περιέχει όλες τις απαραίτητες εφαρμογές σε μια πλήρη σουίτα εφαρμογών γραφείου: επεξεργαστή κειμένου, υπολογιστικό φύλλο, διαχειριστή παρουσιάσεων και πρόγραμμα σχεδίασης. Το περιβάλλον εργασίας του είναι πολύ όμοιο με άλλες σουίτες γραφείου, και μπορεί να χρησιμοποιήσει διάφορους δημοφιλείς τύπους αρχείων. Είναι διαθέσιμο σε πολλές διαφορετικές γλώσσες, τόσο ως προς το περιβάλλον εργασίας όσο και ως προς τα λεξικά και τον ορθογραφικό έλεγχο.</p></div><div class=paragraph><p>Ο επεξεργαστής κειμένου του OpenOffice.org χρησιμοποιεί εγγενώς μορφή αρχείου XML για αυξημένη φορητότητα και ευελιξία. Το πρόγραμμα υπολογιστικών φύλλων διαθέτει γλώσσα μακροεντολών και μπορεί να διασυνδεθεί με εξωτερικές βάσεις δεδομένων. Το OpenOffice.org είναι σταθερή εφαρμογή και εκτελείται εγγενώς στα Windows®, το Solaris™, το Linux, το FreeBSD, καθώς και στο Mac OS® X. Περισσότερες πληροφορίες για το OpenOffice.org μπορείτε να βρείτε στη <a href=http://www.openoffice.org/>δικτυακή τοποθεσία του OpenOffice.org</a>. Για πληροφορίες σχετικά με την έκδοση για FreeBSD, καθώς και για απευθείας κατέβασμα πακέτων, χρησιμοποιήστε την δικτυακή τοποθεσία <a href=http://porting.openoffice.org/freebsd/>FreeBSD OpenOffice.org Porting Team</a>.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το OpenOffice.org, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r openoffice.org</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν χρησιμοποιείτε -RELEASE έκδοση του FreeBSD, το παραπάνω πρέπει να δουλέψει. Διαφορετικά, θα πρέπει να δείτε την δικτυακή τοποθεσία του FreeBSD OpenOffice.org Porting Team για να κατεβάσετε και να εγκαταστήσετε το αντίστοιχο πακέτο χρησιμοποιώντας την <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>. Τόσο η τρέχουσα όσο και η υπό εξέλιξη έκδοση είναι διαθέσιμες για κατέβασμα από την παραπάνω τοποθεσία.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Από τη στιγμή που το πακέτο εγκατασταθεί, πρέπει να γράψετε απλώς την παρακάτω εντολή για να εκτελέσετε το OpenOffice.org:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice.org</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Κατά την πρώτη εκκίνηση, θα σας γίνουν διάφορες ερωτήσεις και θα δημιουργηθεί ένας κατάλογος με όνομα <span class=filename>.openoffice.org</span> μέσα στον προσωπικό σας κατάλογο.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν τα πακέτα του OpenOffice.org δεν είναι διαθέσιμα, έχετε πάντα την επιλογή να μεταγλωττίσετε το αντίστοιχο port. Ωστόσο, να έχετε υπόψη σας ότι αυτό απαιτεί αρκετό χώρο στο δίσκο και θα χρειαστεί και πάρα πολύ χρόνο για να ολοκληρωθεί.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/openoffice.org-3</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν θέλετε να δημιουργήσετε μια έκδοση με τις δικές σας τοπικές ρυθμίσεις, αντικαταστήστε την προηγούμενη γραμμή εντολών με την επόμενη:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=your_language install clean</span></code></pre></div></div><div class=paragraph><p>Πρέπει να αντικαταστήσετε το <em>your_language</em> με το σωστό ISO κωδικό για τη γλώσσα σας. Η λίστα με τους υποστηριζόμενους κωδικούς γλωσσών είναι διαθέσιμη στο αρχείο <span class=filename>files/Makefile.localized</span>, το οποίο βρίσκεται στον κατάλογο του port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μόλις γίνει αυτό, μπορείτε να ξεκινήσετε την εφαρμογή OpenOffice.org δίνοντας την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice.org</code></pre></div></div></div><div class=sect2><h3 id=_libreoffice>10.5. LibreOffice<a class=anchor href=#_libreoffice></a></h3><div class=paragraph><p>Το LibreOffice είναι μια ελεύθερη σουίτα εφαρμογών γραφείου η οποία αναπτύσσεται από το <a href=http://www.documentfoundation.org/>The Document Foundation</a>. Είναι συμβατή με τις άλλες γνωστές σουίτες γραφείου και διατίθεται για τις περισσότερες πλατφόρμες. Πρόκειται για fork της γνωστής εφαρμογής OpenOffice.org η οποία περιλαμβάνει όλα τα απαραίτητα μιας σουίτας γραφείου: επεξεργαστή κειμένου, υπολογιστικό φύλλο, πρόγραμμα παρουσιάσεων, πρόγραμμα σχεδίασης και ένα εργαλείο για δημιουργία και επεξεργασία μαθηματικών τύπων. Διατίθεται σε πλήθος γλωσσών - η διεθνής υποστήριξη επεκτείνεται μάλιστα τόσο στο περιβάλλον όσο και στα επιπλέον προγράμματα ελέγχου ορθογραφίας και λεξικών.</p></div><div class=paragraph><p>Ο επεξεργαστής κειμένου του OpenOffice χρησιμοποιεί εγγενώς μορφή αρχείου XML το οποίο εξασφαλίζει αυξημένη φορητότητα και ευελιξία. Το υπολογιστικό φύλλο διαθέτει μια γλώσσα μακροεντολών και μπορεί να διασυνδεθεί με εξωτερικές βάσεις δεδομένων. Το LibreOffice είναι ήδη σταθερό και διατίθεται σε εκδόσεις για Windows®, Linux®, FreeBSD και Mac OS® X. Για περισσότερες πληροφορίες σχετικά με το LibreOffice επισκεφθείτε την <a href=http://www.libreoffice.org/>δικτυακή τοποθεσία του</a>.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το LibreOffice από έτοιμο πακετό, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r libreoffice</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το παραπάνω θα λειτουργήσει αν τρέχετε κάποιο επίσημο -RELEASE του FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μετά την εγκατάσταση του πακέτου, πληκτρολογήστε το παρακάτω για να εκτελέσετε το LibreOffice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% libreoffice</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Κατά την πρώτη εκκίνηση, θα σας γίνουν κάποιες ερωτήσεις και θα δημιουργηθεί ένας κατάλογος <span class=filename>.libreoffice</span> μέσα στον προσωπικό σας κατάλογο.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν δεν υπάρχουν διαθέσιμα πακέτα για το LibreOffice, έχετε επίσης την επιλογή να το μεταγλωττίσετε από το αντίστοιχο port. Θα πρέπει ωστόσο να γνωρίζετε ότι απαιτείται αρκετός χώρος στο δίσκο και αρκετός χρόνος για τη μεταγλώττιση.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/libreoffice</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν θέλετε να δημιουργήσετε μια έκδοση με υποστήριξη κάποιας συγκεκριμένης γλώσσας, αντικαταστήστε την προηγούμενη εντολή με:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=your_language install clean</span></code></pre></div></div><div class=paragraph><p>Θα πρέπει να αντικαταστήσετε το <em>your_language</em> με το σωστό ISO κωδικό της γλώσσας που επιθυμείτε να χρησιμοποιήσετε. Για να βρείτε τον κωδικό, δείτε το αρχείο <span class=filename>Makefile</span> του port και ειδικότερα την ενότητα <code>pre-fetch</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μπορείτε έπειτα να εκτελέσετε το LibreOffice χρησιμοποιώντας την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% libreoffice</code></pre></div></div></div></div></div><div class=sect1><h2 id=desktop-viewers>Chapter 11. Προγράμματα Προβολής Εγγράφων<a class=anchor href=#desktop-viewers></a></h2><div class=sectionbody><div class=paragraph><p>Πρόσφατα έχουν γίνει αρκετά δημοφιλείς κάποιες νέες μορφές αρχείων. Τα προγράμματα προβολής που απαιτούνται για τα αρχεία αυτά ίσως να μην είναι διαθέσιμα στο βασικό σύστημα. Στο τμήμα αυτό θα δούμε πως μπορείτε να τα εγκαταστήσετε.</p></div><div class=paragraph><p>Το τμήμα αυτό καλύπτει τις εφαρμογές:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Όνομα Εφαρμογής</th><th class="tableblock halign-left valign-top">Απαιτούμενοι Πόροι</th><th class="tableblock halign-left valign-top">Εγκατάσταση από Ports</th><th class="tableblock halign-left valign-top">Βασικές Εξαρτήσεις</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Acrobat Reader®</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δυαδική συμβατότητα με Linux (Linux Binary Compatibility)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Xaw3d</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeType</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GQview</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ ή GNOME</p></td></tr></tbody></table><div class=sect2><h3 id=_acrobat_reader>11.1. Acrobat Reader®<a class=anchor href=#_acrobat_reader></a></h3><div class=paragraph><p>Πολλά έγγραφα διανέμονται πλέον ως αρχεία PDF το οποίο σημαίνει "Portable Document Format" (Φορητή Μορφή Εγγράφου). Ένα από τα συνιστώμενα προγράμματα προβολής για αυτό τον τύπο αρχείων είναι το Acrobat Reader®, το οποίο η Adobe διαθέτει για Linux. Καθώς το FreeBSD μπορεί να χρησιμοποιήσει εκτελέσιμα του Linux, η εφαρμογή είναι επίσης διαθέσιμη για το FreeBSD.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το Acrobat Reader® 8 από τη Συλλογή των Ports, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/acroread8</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Δεν υπάρχει διαθέσιμο πακέτο, λόγω περιορισμών στην άδεια χρήσης.</p></div></div><div class=sect2><h3 id=_gv>11.2. gv<a class=anchor href=#_gv></a></h3><div class=paragraph><p>Το gv είναι ένα πρόγραμμα προβολής εγγράφων για αρχεία PostScript® και PDF. Είναι αρχικά βασισμένο στην εφαρμογή ghostview αλλά έχει καλύτερη εμφάνιση χάρη στη βιβλιοθήκη Xaw3d. Είναι γρήγορο, και το interface του είναι ξεκάθαρο. Το gv έχει πολλές δυνατότητες, όπως προσανατολισμό και μέγεθος χαρτιού, εμφάνιση υπό κλίμακα και βελτίωση εμφάνισης γραμματοσειρών (antialias). Σχεδόν κάθε λειτουργία του μπορεί να εκτελεστεί τόσο από το πληκτρολόγιο όσο και από το ποντίκι.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το gv ως πακέτο, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gv</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο, μπορείτε να χρησιμοποιήσετε την Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/gv</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_xpdf>11.3. Xpdf<a class=anchor href=#_xpdf></a></h3><div class=paragraph><p>Αν θέλετε ένα μικρό πρόγραμμα προβολής αρχείων PDF για το FreeBSD, το Xpdf είναι ελαφρύ και αποδοτικό. Απαιτεί ελάχιστους πόρους και είναι ιδιαίτερα σταθερό. Χρησιμοποιεί τις βασικές γραμματοσειρές των X και δεν απαιτεί χρήση του Motif® ή άλλης εργαλειοθήκης των Χ.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το Xpdf ως πακέτο, δώστε την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r xpdf</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο ή προτιμάτε να χρησιμοποιήσετε την Συλλογή των Ports, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/xpdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Μόλις ολοκληρωθεί η εγκατάσταση, μπορείτε να ξεκινήσετε το Xpdf και να χρησιμοποιήσετε το δεξί πλήκτρο του ποντικιού για να ενεργοποιήσετε το μενού.</p></div></div><div class=sect2><h3 id=_gqview>11.4. GQview<a class=anchor href=#_gqview></a></h3><div class=paragraph><p>Το GQview είναι ένας διαχειριστής εικόνων. Μπορείτε να δείτε ένα αρχείο με ένα απλό κλικ, να ξεκινήσετε ένα εξωτερικό πρόγραμμα επεξεργασίας, να δείτε προεπισκόπηση σε μορφή thumbnail και πολλά άλλα. Διαθέτει επίσης προβολή παρουσίασης και κάποιες βασικές λειτουργίες αρχείων. Μπορείτε να διαχειριστείτε συλλογές εικόνων και να βρείτε με εύκολο τρόπο τις διπλές. Το GQview μπορεί να χρησιμοποιηθεί για προβολή σε πλήρη οθόνη και υποστηρίζει τοπικές / διεθνείς ρυθμίσεις.</p></div><div class=paragraph><p>Αν θέλετε να εγκαταστήσετε το GQview ως πακέτο, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gqview</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο, ή προτιμάτε να χρησιμοποιήσετε την Συλλογή των Ports, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gqview</span>
<span class=c># make install clean</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=desktop-finance>Chapter 12. Χρηματοοικονομικές Εφαρμογές<a class=anchor href=#desktop-finance></a></h2><div class=sectionbody><div class=paragraph><p>Αν, για οποιοδήποτε λόγο, θέλετε να διαχειρίζεστε τα χρηματοοικονομικά σας μέσω του FreeBSD desktop σας, υπάρχουν κάποιες ισχυρές και εύκολες στη χρήση εφαρμογές, έτοιμες προς εγκατάσταση. Ορισμένες από αυτές είναι συμβατές με διαδεδομένες μορφές αρχείων, όπως αυτές που χρησιμοποιούνται στα έγγραφα του Quicken ή του Excel.</p></div><div class=paragraph><p>Το τμήμα αυτό καλύπτει τις εφαρμογές:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Όνομα Εφαρμογής</th><th class="tableblock halign-left valign-top">Απαιτούμενοι Πόροι</th><th class="tableblock halign-left valign-top">Εγκατάσταση Από Ports</th><th class="tableblock halign-left valign-top">Βασικές Εξαρτήσεις</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Abacus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ελαφριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tcl/Tk</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>λίγοι (ελαφριά)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>βαριά</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect2><h3 id=_gnucash>12.1. GnuCash<a class=anchor href=#_gnucash></a></h3><div class=paragraph><p>Το GnuCash είναι μέρος της προσπάθειας του GNOME να παρέχει φιλικές εφαρμογές στους τελικούς χρήστες. Με το GnuCash, μπορείτε να κρατάτε λογαριασμό των εσόδων και εξόδων σας, των τραπεζικών σας λογαριασμών και των μετοχών σας. Διαθέτει περιβάλλον εργασίας το οποίο είναι εύκολο στη χρήση χωρίς να χρειάζεται ιδιαίτερη εκμάθηση, αλλά είναι ταυτόχρονα και πολύ επαγγελματικό.</p></div><div class=paragraph><p>Το GnuCash παρέχει έξυπνο σύστημα καταχώρησης, ιεραρχικό σύστημα λογαριασμών, πολλά πλήκτρα συντομεύσεων πληκτρολογίου, καθώς και μεθόδους αυτόματης συμπλήρωσης. Μπορεί να διαχωρίσει μια συναλλαγή σε πολλά λεπτομερή τμήματα. Το GnuCash μπορεί να εισάγει και να συγχωνεύσει αρχεία QIF του Quicken. Μπορεί επίσης να χειριστεί τις περισσότερες διεθνείς μορφές ημερομηνιών και νομισματικών μονάδων.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το GnuCash στο σύστημα σας, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnucash</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο, μπορείτε να χρησιμοποιήσετε την Συλλογή των Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/gnucash</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_gnumeric>12.2. Gnumeric<a class=anchor href=#_gnumeric></a></h3><div class=paragraph><p>Το Gnumeric είναι ένα υπολογιστικό φύλλο και αποτελεί μέρος του περιβάλλοντος εργασίας GNOME. Διαθέτει βολική αυτόματη "πρόβλεψη" της εισόδου του χρήστη σύμφωνα με τη μορφή του κελιού καθώς και σύστημα αυτόματης συμπλήρωσης (autofill) για διάφορες ακολουθίες. Μπορεί να εισάγει αρχεία διάφορων δημοφιλών μορφών, όπως αυτά που χρησιμοποιούνται στο Excel, το Lotus 1-2-3, ή το Quattro Pro. Το Gnumeric υποστηρίζει γραφήματα μέσω του προγράμματος γραφικών <a class=package href=https://cgit.freebsd.org/ports/tree/math/guppi/>math/guppi</a>. Έχει μεγάλο αριθμό ενσωματωμένων συναρτήσεων και επιτρέπει όλες τις συνήθεις μορφές κελιών, όπως αριθμούς, νομισματικές μονάδες, ημερομηνίες, ώρες και πολλές ακόμα.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το Gnumeric ως πακέτο, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnumeric</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο, μπορείτε να χρησιμοποιήσετε την Συλλογή των Ports, γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/math/gnumeric</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_abacus>12.3. Abacus<a class=anchor href=#_abacus></a></h3><div class=paragraph><p>Το Abacus είναι ένα μικρό και εύκολο στη χρήση υπολογιστικό φύλλο. Περιλαμβάνει πολλές ενσωματωμένες συναρτήσεις οι οποίες είναι χρήσιμες σε διάφορα πεδία, όπως η στατιστική, τα χρηματοοικονομικά και τα μαθηματικά. Μπορεί να εισάγει και να εξάγει αρχεία του Excel. Το Abacus μπορεί να παράγει έξοδο μορφής PostScript®.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το Abacus ως πακέτο, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r abacus</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο, μπορείτε να χρησιμοποιήσετε την Συλλογή των Ports, γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/deskutils/abacus</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_kmymoney>12.4. KMyMoney<a class=anchor href=#_kmymoney></a></h3><div class=paragraph><p>Το KMyMoney είναι μια εφαρμογή διαχείρισης των προσωπικών σας οικονομικών, φτιαγμένη για το περιβάλλον KDE. To KMyMoney στοχεύει να παρέχει και να ενσωματώσει όλες τις λειτουργίες που διατίθενται σε αντίστοιχες εμπορικές εφαρμογές. Το KMyMoney μπορεί να εισάγει αρχεία του προτύπου QIF (Quicken Interchange Format), να τηρεί καταγραφή των επενδύσεων σας, να χειρίζεται πολλαπλές νομισματικές μονάδες και να παρέχει πλήθος αναφορών. Μέσα από ξεχωριστό plugin, παρέχεται επίσης η δυνατότητα εισαγωγής αρχείων OFX.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το KMyMoney ως πακέτο, εκτελέστε την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r kmymoney2</span></code></pre></div></div><div class=paragraph><p>Αν το πακέτο δεν είναι διαθέσιμο, μπορείτε να χρησιμοποιήσετε την Συλλογή των Ports, όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/kmymoney2</span>
<span class=c># make install clean</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=desktop-summary>Chapter 13. Περίληψη<a class=anchor href=#desktop-summary></a></h2><div class=sectionbody><div class=paragraph><p>Αν και το FreeBSD είναι δημοφιλές στους παροχείς Internet (ISPs) για την απόδοση και τη σταθερότητα του, είναι επίσης έτοιμο και για καθημερινή χρήση ως desktop. Με αρκετές χιλιάδες εφαρμογές διαθέσιμες ως <a href=http://www.FreeBSD.org/applications/>πακέτα</a> ή <a href=http://www.FreeBSD.org/ports/>ports</a>, μπορείτε να δημιουργήσετε το τέλειο desktop που καλύπτει όλες τις ανάγκες σας.</p></div><div class=paragraph><p>Παρακάτω, φαίνεται μια γρήγορη περίληψη όλων των desktop εφαρμογών που παρουσιάστηκαν σε αυτό το κεφάλαιο:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Όνομα Εφαρμογής</th><th class="tableblock halign-left valign-top">Όνομα Πακέτου</th><th class="tableblock halign-left valign-top">Όνομα Port</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Opera</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>opera</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/opera/>www/opera</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>firefox</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chromium</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>chromium</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/chromium/>www/chromium</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>koffice-kde4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/koffice-kde4/>editors/koffice-kde4</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>abiword</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/abiword/>editors/abiword</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The GIMP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gimp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp/>graphics/gimp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>OpenOffice.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>openoffice</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/openoffice.org-3/>editors/openoffice.org-3</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LibreOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>libreoffice</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/libreoffice/>editors/libreoffice</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Acrobat Reader®</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acroread</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/acroread8/>print/acroread8</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gv</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/gv/>print/gv</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>xpdf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xpdf/>graphics/xpdf</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GQview</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gqview</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gqview/>graphics/gqview</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gnucash</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/finance/gnucash/>finance/gnucash</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gnumeric</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/math/gnumeric/>math/gnumeric</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Abacus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>abacus</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/deskutils/abacus/>deskutils/abacus</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>kmymoney2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/finance/kmymoney2/>finance/kmymoney2</a></p></td></tr></tbody></table></div></div><div class=sect1><h2 id=multimedia>Chapter 14. Πολυμέσα<a class=anchor href=#multimedia></a></h2><div class=sectionbody><div class=sect2><h3 id=multimedia-synopsis>14.1. Σύνοψη<a class=anchor href=#multimedia-synopsis></a></h3><div class=paragraph><p>Το FreeBSD υποστηρίζει μεγάλη ποικιλία από κάρτες ήχου, επιτρέποντας σας έτσι να απολαύσετε υψηλής πιστότητας ήχο από τον υπολογιστή σας. Περιλαμβάνεται η δυνατότητα να εγγράψετε και να αναπαράγετε ήχο MPEG Audio Layer 3 (MP3), WAV, και Ogg Vorbis καθώς και πολλά άλλα formats. Το FreeBSD Ports Collection επίσης περιέχει εφαρμογές που σας επιτρέπουν να επεξεργαστείτε τον ηχογραφημένο σας ήχο, να προσθέσετε ηχητικά εφέ, και να ελέγξετε συσκευές MIDI.</p></div><div class=paragraph><p>Με λίγο πειραματισμό, το FreeBSD μπορεί να υποστηρίξει αναπαραγωγή αρχείων video και DVD. Ο αριθμός των εφαρμογών που κωδικοποιούν, μετατρέπουν, και αναπαράγουν διάφορους τύπους video είναι πιο περιορισμένος από τον αριθμό των εφαρμογών ήχου. Για παράδειγμα, όταν γράφηκε αυτό το κείμενο, δεν υπήρχε καμιά καλή εφαρμογή επανακωδικοποίησης στη συλλογή των Ports του FreeBSD, που θα μπορούσε να χρησιμοποιηθεί για μετατροπή μεταξύ formats, όπως το <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a>. Παρ' όλα αυτά, το τοπίο σε αυτό τον τομέα, και όσο αφορά το λογισμικό, αλλάζει ραγδαία.</p></div><div class=paragraph><p>Το κεφάλαιο αυτό θα περιγράψει τα απαραίτητα βήματα για τη ρύθμιση της κάρτας ήχου σας. Η ρύθμιση και εγκατάσταση του X11 (<a href=./#x11>Το Σύστημα X Window</a>) έχει ήδη φροντίσει για τα πιθανά προβλήματα υλικού της κάρτας γραφικών σας, αν και μπορεί να χρειάζεται να εφαρμόσετε κάποιες ακόμα μικρο-ρυθμίσεις για καλύτερη αναπαραγωγή.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να ρυθμίσετε το σύστημα σας ώστε να αναγνωρίζεται η κάρτα ήχου σας.</p></li><li><p>Μεθόδους για να ελέγξετε τη λειτουργία της κάρτας σας.</p></li><li><p>Πως να επιλύσετε προβλήματα σχετικά με τις ρυθμίσεις ήχου.</p></li><li><p>Πως να αναπαράγετε και να κωδικοποιήσετε MP3 και άλλους τύπους αρχείων ήχου.</p></li><li><p>Πως υποστηρίζεται το video από τον X server.</p></li><li><p>Κάποια ports αναπαραγωγής/κωδικοποίησης video που δίνουν καλά αποτελέσματα.</p></li><li><p>Πως να αναπαράγετε DVD, και αρχεία <span class=filename>.mpg</span> και <span class=filename>.avi</span>.</p></li><li><p>Πως να κάνετε rip το περιεχόμενο CD και DVD σε αρχεία.</p></li><li><p>Πως να ρυθμίσετε μια κάρτα τηλεόρασης.</p></li><li><p>Πως να ρυθμίσετε ένα σαρωτή εικόνων.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να ξέρετε πως θα ρυθμίσετε και θα εγκαταστήσετε νέο πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Αν προσπαθήσετε να προσαρτήσετε μουσικά CD με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> θα προκληθεί κατ' ελάχιστον σφάλμα, ή στη χειρότερη περίπτωση <em>kernel panic</em>. Τέτοια μέσα έχουν εξειδικευμένες κωδικοποιήσεις που διαφέρουν από το συνηθισμένο σύστημα αρχείων ISO.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=sound-setup>14.2. Ρύθμιση της Κάρτας Ήχου<a class=anchor href=#sound-setup></a></h3><div class=sect3><h4 id=sound-device>14.2.1. Ρυθμίζοντας το Σύστημα<a class=anchor href=#sound-device></a></h4><div class=paragraph><p>Πριν ξεκινήσετε, θα πρέπει να ξέρετε το μοντέλο της κάρτας που έχετε, το ολοκληρωμένο κύκλωμα που χρησιμοποιεί, καθώς και αν είναι PCI ή ISA. Το FreeBSD υποστηρίζει μεγάλη ποικιλία καρτών ήχου, τόσο PCI όσο και ISA. Ελέγξτε τις υποστηριζόμενες συσκευές ήχου στις <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>Σημειώσεις Υλικού</a> για να δείτε αν η κάρτα σας υποστηρίζεται. Στις Σημειώσεις Υλικού αναφέρεται επίσης ποιο πρόγραμμα οδήγησης υποστηρίζει την κάρτα σας.</p></div><div class=paragraph><p>Για να χρησιμοποιήσετε την συσκευή ήχου που διαθέτετε, θα πρέπει να φορτώσετε τον κατάλληλο οδηγό συσκευής. Αυτό μπορεί να επιτευχθεί με δύο τρόπους. Ο ευκολότερος είναι απλώς να φορτώσετε ένα module (άρθρωμα) για την κάρτα ήχου στον πυρήνα, χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>, με τη βοήθεια της γραμμής εντολών:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_emu10k1</span></code></pre></div></div><div class=paragraph><p>ή προσθέτοντας την κατάλληλη γραμμή στο αρχείο <span class=filename>/boot/loader.conf</span> όπως παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>snd_emu10k1_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Τα παραπάνω παραδείγματα είναι για μια κάρτα ήχου Creative SoundBlaster® Live!. Υπάρχουν διαθέσιμα και άλλα modules για κάρτες ήχου και μπορείτε να τα δείτε στο αρχείο <span class=filename>/boot/defaults/loader.conf</span>. Αν δεν είστε σίγουρος για το πρόγραμμα οδήγησης που πρέπει να χρησιμοποιήσετε, μπορείτε να προσπαθήσετε να φορτώσετε το module <span class=filename>snd_driver</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_driver</span></code></pre></div></div><div class=paragraph><p>Πρόκειται για ένα μετα-πρόγραμμα οδήγησης, το οποίο φορτώνει με μιας όλα τα κοινά προγράμματα οδήγησης για κάρτες ήχου. Με τον τρόπο αυτό μπορείτε να επιταχύνετε την ανίχνευση για το σωστό οδηγό. Μπορείτε επίσης να φορτώσετε όλα τα προγράμματα οδήγησης μέσω του αρχείου <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Αν επιθυμείτε να βρείτε το επιλεγμένο πρόγραμμα οδήγησης της κάρτας σας μετά τη φόρτωση του <span class=filename>snd_driver</span>, μπορείτε να ελέγξετε το αρχείο <span class=filename>/dev/sndstat</span> με την βοήθεια της εντολής <code>cat /dev/sndstat</code>.</p></div><div class=paragraph><p>Μια δεύτερη μέθοδος είναι να μεταγλωττίσετε την υποστήριξη της κάρτας ήχου σας, στατικά, απευθείας στον πυρήνα. Το παρακάτω τμήμα παρέχει τις πληροφορίες που χρειάζεστε για να προσθέσετε υποστήριξη για το υλικό σας με αυτό τον τρόπο. Για περισσότερες πληροφορίες σχετικά με την μεταγλώττιση του πυρήνα, δείτε το <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>.</p></div><div class=sect4><h5 id=_δημιουργώντας_προσαρμοσμένο_πυρήνα_με_υποστήριξη_ήχου>14.2.1.1. Δημιουργώντας Προσαρμοσμένο Πυρήνα με Υποστήριξη Ήχου<a class=anchor href=#_δημιουργώντας_προσαρμοσμένο_πυρήνα_με_υποστήριξη_ήχου></a></h5><div class=paragraph><p>Αρχικά, πρέπει να προσθέσετε το γενικό πρόγραμμα οδήγησης ήχου (audio framework driver) <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> στον πυρήνα σας. Θα χρειαστεί να προσθέσετε την ακόλουθη γραμμή στο αρχείο ρυθμίσεων του πυρήνα:</p></div><div class="literalblock programlisting"><div class=content><pre>device sound</pre></div></div><div class=paragraph><p>Έπειτα, θα πρέπει να προσθέσετε υποστήριξη για την κάρτα ήχου σας. Πρέπει να γνωρίζετε από πριν ποιο πρόγραμμα οδήγησης την υποστηρίζει. Ελέγξτε τη λίστα των υποστηριζόμενων καρτών στις <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>Σημειώσεις Υλικού</a>, για να καθορίσετε το σωστό οδηγό για την δική σας. Για παράδειγμα, ή Creative SoundBlaster® Live!, υποστηρίζεται από τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_emu10k1&amp;sektion=4&amp;format=html">snd_emu10k1(4)</a>. Για να προσθέσετε υποστήριξη για αυτή την κάρτα, χρησιμοποιήστε την ακόλουθη γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_emu10k1</pre></div></div><div class=paragraph><p>Βεβαιωθείτε ότι διαβάσατε την σελίδα του manual για το πρόγραμμα οδήγησης, ώστε να χρησιμοποιήσετε τη σωστή σύνταξη. Η ακριβής σύνταξη για κάθε υποστηριζόμενη κάρτα ήχου στο αρχείο ρυθμίσεων πυρήνα, μπορεί να βρεθεί επίσης στο αρχείο <span class=filename>/usr/src/sys/conf/NOTES</span>.</p></div><div class=paragraph><p>Για κάρτα ήχου τύπου ISA που δεν είναι Plug’N’Play μπορεί να χρειαστεί να δώσετε στον πυρήνα πληροφορίες σχετικά με τις ρυθμίσεις της (όπως το IRQ, θύρα I/O κλπ), όπως γίνεται τυπικά σε αυτές τις περιπτώσεις. Αυτό μπορεί να γίνει μέσω του αρχείου <span class=filename>/boot/device.hints</span>. Κατά τη διαδικασία της εκκίνησης, ο <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> θα διαβάσει το αρχείο και θα μεταβιβάσει τις ρυθμίσεις στον πυρήνα. Για παράδειγμα, μια παλιά Creative SoundBlaster® 16 ISA μη-PnP κάρτα χρησιμοποιεί το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> σε συνδυασμό με το <code>snd_sb16</code>. Για την κάρτα αυτή πρέπει να προστεθούν οι παρακάτω γραμμές στο αρχείο ρυθμίσεων πυρήνα:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_sbc
device snd_sb16</pre></div></div><div class=paragraph><p>και οι παρακάτω γραμμές στο αρχείο <span class=filename>/boot/device.hints</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sbc.0.at=&#34;isa&#34;
hint.sbc.0.port=&#34;0x220&#34;
hint.sbc.0.irq=&#34;5&#34;
hint.sbc.0.drq=&#34;1&#34;
hint.sbc.0.flags=&#34;0x15&#34;</pre></div></div><div class=paragraph><p>Στην περίπτωση αυτή, η κάρτα χρησιμοποιεί τη θύρα I/O <code>0x220</code> και το IRQ <code>5</code>.</p></div><div class=paragraph><p>Η σύνταξη που χρησιμοποιείται στο αρχείο <span class=filename>/boot/device.hints</span> εξηγείται στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> καθώς και στη σελίδα manual του αντίστοιχου προγράμματος οδήγησης.</p></div><div class=paragraph><p>Οι ρυθμίσεις που φαίνονται παραπάνω είναι οι προεπιλεγμένες. Σε ορισμένες περιπτώσεις, μπορεί να χρειαστεί να αλλάξετε το IRQ ή άλλες ρυθμίσεις ώστε να ταιριάζουν με τις ρυθμίσεις της κάρτας σας. Δείτε τη σελίδα manual της <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> για περισσότερες πληροφορίες σχετικά με την κάρτα αυτή.</p></div></div></div><div class=sect3><h4 id=sound-testing>14.2.2. Δοκιμάζοντας την Κάρτα Ήχου<a class=anchor href=#sound-testing></a></h4><div class=paragraph><p>Αφού κάνετε επανεκκίνηση με τον νέο πυρήνα (ή αφού φορτώσετε το απαραίτητο module), Θα πρέπει να δείτε μηνύματα σχετικά με την κάρτα ήχου στην προσωρινή μνήμη (buffer) καταγραφής του συστήματος (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>) αντίστοιχα με τα παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pcm0: &lt;Intel ICH3 <span class=o>(</span>82801CA<span class=o>)&gt;</span> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: <span class=o>[</span>GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</code></pre></div></div><div class=paragraph><p>Η κατάσταση της κάρτας ήχου μπορεί να ελεγχθεί μέσω του αρχείου <span class=filename>/dev/sndstat</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /dev/sndstat</span>
FreeBSD Audio Driver <span class=o>(</span>newpcm<span class=o>)</span>
Installed devices:
pcm0: &lt;Intel ICH3 <span class=o>(</span>82801CA<span class=o>)&gt;</span> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich <span class=o>(</span>1p/2r/0v channels duplex default<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Τα μηνύματα στο σύστημα σας μπορεί να είναι διαφορετικά. Αν δεν δείτε συσκευές τύπου <span class=filename>pcm</span>, επιστρέψτε και ελέγξτε τα βήματα που κάνατε προηγουμένως. Κοιτάξτε το αρχείο ρυθμίσεων πυρήνα και βεβαιωθείτε ότι έχετε επιλέξει το σωστό πρόγραμμα οδήγησης. Για συνήθη προβλήματα και την αντιμετώπιση τους, δείτε το τμήμα <a href=#troubleshooting>Συνηθισμένα Προβλήματα</a>.</p></div><div class=paragraph><p>Αν όλα πάνε καλά, η κάρτα ήχου σας θα λειτουργεί. Αν ο οδηγός CD ή DVD που διαθέτετε είναι συνδεμένος με την κάρτα ήχου μέσω της αναλογικής του εξόδου, μπορείτε να βάλετε ένα μουσικό CD και να το αναπαράγετε με το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=cdcontrol&amp;sektion=1&amp;format=html">cdcontrol(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdcontrol <span class=nt>-f</span> /dev/acd0 play 1</code></pre></div></div><div class=paragraph><p>Άλλες εφαρμογές, όπως το <a class=package href=https://cgit.freebsd.org/ports/tree/audio/workman/>audio/workman</a> παρέχουν φιλικότερο περιβάλλον εργασίας. Ίσως θέλετε να εγκαταστήσετε μια εφαρμογή όπως το <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> για να αναπαράγετε αρχεία ήχου MP3.</p></div><div class=paragraph><p>Ένας άλλος γρήγορος τρόπος για να ελέγξετε την κάρτα ήχου σας, είναι να στείλετε δεδομένα στην συσκευή <span class=filename>/dev/dsp</span>, όπως παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>filename <span class=o>&gt;</span> /dev/dsp</code></pre></div></div><div class=paragraph><p>όπου το <span class=filename>filename</span> μπορεί να είναι οποιοδήποτε αρχείο. Η παραπάνω εντολή θα πρέπει να παράγει κάποιο ήχο (θόρυβο) επιβεβαιώνοντας τη σωστή λειτουργία της κάρτας ήχου.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Τα αρχεία συσκευών <span class=filename>/dev/dsp*</span> δημιουργούνται αυτόματα όταν χρειάζεται. Δεν υπάρχουν αν δεν χρησιμοποιούνται και δεν θα εμφανιστούν στην έξοδο της <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a></p></div></td></tr></tbody></table></div><div class=paragraph><p>Η ένταση ήχου της κάρτας μπορεί να αλλάξει μέσω της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a>. Περισσότερες πληροφορίες μπορείτε να βρείτε στην σελίδα του manual της <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a>.</p></div><div class=sect4><h5 id=troubleshooting>14.2.2.1. Συνηθισμένα Προβλήματα<a class=anchor href=#troubleshooting></a></h5><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Πρόβλημα</th><th class="tableblock halign-left valign-top">Λύση</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb_dspwr(XX) timed out</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δεν είναι σωστά ρυθμισμένη η θύρα I/O.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bad irq XX</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το IRQ δεν είναι σωστά ρυθμισμένο. Βεβαιωθείτε ότι το IRQ που έχετε δηλώσει είναι το ίδιο με αυτό που έχει ρυθμιστεί στην κάρτα.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: gus pcm not attached, out of memory</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δεν υπάρχει αρκετή διαθέσιμη μνήμη για να γίνει χρήση της συσκευής.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: can’t open /dev/dsp!</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ελέγξτε με την βοήθεια της εντολής <code>fstat | grep dsp</code> αν κάποια άλλη εφαρμογή απασχολεί τη συγκεκριμένη συσκευή. Συνήθεις ύποπτοι είναι η εφαρμογή esound καθώς και το σύστημα υποστήριξης ήχου του περιβάλλοντος KDE.</p></td></tr></tbody></table><div class=paragraph><p>Ένα ακόμα πρόβλημα δημιουργείται από ορισμένες σύγχρονες κάρτες γραφικών οι οποίες περιέχουν μια δική τους συσκευή ήχου για χρήση μέσω συνδέσεων HDMI ή αντίστοιχων. Σε ορισμένες περιπτώσεις, είναι πιθανόν αυτή η συσκευή να εντοπισθεί πριν την κανονική κάρτα ήχου με αποτέλεσμα να πάρει τη θέση της προεπιλεγμένης συσκευής ήχου. Για να ελέγξετε αν συμβαίνει αυτό, εκτελέστε την εντολή dmesg και ψάξτε για τη λέξη <code>pcm</code>. Η έξοδος θα μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1
...</pre></div></div><div class=paragraph><p>Στο παράδειγμα μας, η κάρτα γραφικών (<code>NVidia</code>) εντοπίστηκε πριν την κανονική κάρτα ήχου (<code>Realtek ALC889</code>). Για να χρησιμοποιήσετε την πραγματική κάρτα ήχου ως την προεπιλεγμένη συσκευή ήχου, αλλάξτε το <code>hw.snd.default_unit</code> όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.snd.default_unit=n</span></code></pre></div></div><div class=paragraph><p>Το <em>n</em> είναι ο αριθμός της συσκευής που θα χρησιμοποιηθεί, στο παράδειγμα μας το <code>4</code>. Προσθέστε την παρακάτω γραμμή στο <span class=filename>/etc/sysctl.conf</span> για να γίνει μόνιμη αυτή η αλλαγή:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.snd.default_unit=4</pre></div></div></div></div><div class=sect3><h4 id=sound-multiple-sources>14.2.3. Χρησιμοποιώντας Πολλαπλές Πηγές Ήχου<a class=anchor href=#sound-multiple-sources></a></h4><div class=paragraph><p>Είναι πολλές φορές επιθυμητό να έχουμε πολλαπλές πηγές ήχου που να αναπαράγονται ταυτόχρονα, όπως όταν για παράδειγμα το esound ή το artsd δεν επιτρέπουν κοινή χρήση της συσκευής ήχου σε κάποια συγκεκριμένη εφαρμογή.</p></div><div class=paragraph><p>Το FreeBSD επιτρέπει αυτή τη λειτουργία μέσω των <em>Εικονικών Καναλιών Ήχου (Virtual Sound Channels)</em>, τα οποία μπορούν να ενεργοποιηθούν μέσω των δυνατοτήτων που παρέχονται από το <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Τα Εικονικά Κανάλια σας επιτρέπουν να πολυπλέξετε τους ήχους που αναπαράγει η κάρτα σας, αναμιγνύοντας τον ήχο στον πυρήνα.</p></div><div class=paragraph><p>Για να ρυθμίσετε το πλήθος των εικονικών καναλιών, υπάρχουν τρεις ρυθμίσεις sysctl που μπορούν να γίνουν αν είστε ο χρήστης <code>root</code>, όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl dev.pcm.0.play.vchans=4</span>
<span class=c># sysctl dev.pcm.0.rec.vchans=4</span>
<span class=c># sysctl hw.snd.maxautovchans=4</span></code></pre></div></div><div class=paragraph><p>Το παραπάνω παράδειγμα παραχωρεί τέσσερα εικονικά κανάλια, τα οποία άνετα επαρκούν για καθημερινή χρήση. Οι τιμές <code>dev.pcm.0.play.vchans=4</code> και <code>dev.pcm.0.rec.vchans=4</code> αναφέρονται στον αριθμό των εικονικών καναλιών που διαθέτει η συσκευή <span class=filename>pcm0</span> για αναπαραγωγή και εγγραφή, και μπορούν να ρυθμιστούν μετά την προσάρτηση της συσκευής. Η μεταβλητή <code>hw.snd.maxautovchans</code> είναι ο αριθμός των εικονικών καναλιών που παραχωρούνται σε μια νέα συσκευή ήχου όταν αυτή προσαρτάται μέσω της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Καθώς το module <span class=filename>pcm</span> μπορεί να φορτωθεί ανεξάρτητα από τα προγράμματα οδήγησης του υλικού, το <code>hw.snd.maxautovchans</code> μπορεί να αποθηκεύσει το μέγιστο πλήθος των εικονικών καναλιών που θα παραχωρηθούν σε όσες συσκευές ήχου προσαρτηθούν αργότερα. Δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> για περισσότερες λεπτομέρειες.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Δεν μπορείτε να αλλάξετε τον αριθμό των εικονικών καναλιών μιας συσκευής όσο αυτή είναι σε χρήση. Πρώτα κλείστε όσα προγράμματα χρησιμοποιούν τη συσκευή, όπως προγράμματα αναπαραγωγής μουσικής ή δαίμονες ήχου.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η σωστή συσκευή <span class=filename>pcm</span> αποδίδεται αυτόματα και διάφανα σε κάθε πρόγραμμα που ζητά να χρησιμοποιήσει το <span class=filename>/dev/dsp0</span>.</p></div></div><div class=sect3><h4 id=_ρυθμίζοντας_προεπιλεγμένες_τιμές_για_τα_κανάλια_του_μίκτη>14.2.4. Ρυθμίζοντας Προεπιλεγμένες Τιμές για τα Κανάλια του Μίκτη<a class=anchor href=#_ρυθμίζοντας_προεπιλεγμένες_τιμές_για_τα_κανάλια_του_μίκτη></a></h4><div class=paragraph><p>Οι προεπιλεγμένες τιμές για τα διάφορα κανάλια του μίκτη, είναι ενσωματωμένες στον πηγαίο κώδικα του προγράμματος οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a>. Υπάρχουν πολλές διαφορετικές εφαρμογές και δαίμονες που σας επιτρέπουν να αλλάξετε τιμές στο μίκτη, απομνημονεύοντας τις μεταξύ διαδοχικών κλήσεων, αλλά ή λύση αυτή δεν είναι και η καλύτερη. Είναι δυνατόν να ορίσετε προεπιλεγμένες τιμές μίξης σε επίπεδο προγράμματος οδήγησης. Αυτό μπορεί να επιτευχθεί με την ρύθμιση κατάλληλων τιμών στο αρχείο <span class=filename>/boot/device.hints</span>, π.χ.:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.pcm.0.vol=&#34;50&#34;</pre></div></div><div class=paragraph><p>Το παραπάνω ρυθμίζει την ένταση του ήχου στην προεπιλεγμένη τιμή 50, όταν φορτωθεί το module <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a>.</p></div></div></div><div class=sect2><h3 id=sound-mp3>14.3. Ήχος MP3<a class=anchor href=#sound-mp3></a></h3><div class=paragraph><p>Τα αρχεία ήχου MP3 (MPEG Layer 3 Audio) επιτυγχάνουν ποιότητα ήχου πολύ κοντά στο μουσικό CD, και είναι καλό να έχετε δυνατότητα αναπαραγωγής τους στο FreeBSD σύστημα σας.</p></div><div class=sect3><h4 id=mp3-players>14.3.1. Προγράμματα Αναπαραγωγής MP3<a class=anchor href=#mp3-players></a></h4><div class=paragraph><p>Το πιο δημοφιλές, με μεγάλη διαφορά, πρόγραμμα αναπαραγωγής MP3 για το Χ11, είναι η εφαρμογή XMMS (X Multimedia System). Μπορείτε να χρησιμοποιήσετε τα skins του Winamp με το XMMS καθώς το γραφικό του περιβάλλον είναι σχεδόν όμοιο με το Winamp της Nullsoft. Το XMMS έχει επίσης ενσωματωμένη δυνατότητα χρήσης plug-ins.</p></div><div class=paragraph><p>Το XMMS μπορεί να εγκατασταθεί από το port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xmms/>multimedia/xmms</a> ή από πακέτο.</p></div><div class=paragraph><p>Το περιβάλλον του XMMS το καθιστά εύκολο στη χρήση, καθώς διαθέτει λίστα αναπαραγωγής (playlist), γραφικό ισοσταθμιστή και άλλες λειτουργίες. Όσοι είναι εξοικειωμένοι με το Winamp θα βρουν το XMMS απλό στη χρήση του.</p></div><div class=paragraph><p>Το port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> είναι ένα εναλλακτικό πρόγραμμα αναπαραγωγής MP3 μέσω της γραμμής εντολών.</p></div><div class=paragraph><p>Το mpg123 μπορεί να εκτελεστεί καθορίζοντας τη συσκευή ήχου και το αρχείο MP3 στη γραμμή εντολών. Θεωρώντας ότι η συσκευή ήχου είναι το <span class=filename>/dev/dsp1.0</span> και θέλετε να αναπαράγετε το αρχείο <em>Foobar-GreatestHits.mp3</em>, θα χρησιμοποιήσετε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3</span>
High Performance MPEG 1.0/2.0/2.5 Audio Player <span class=k>for </span>Layer 1, 2 and 3.
Version 0.59r <span class=o>(</span>1999/Jun/15<span class=o>)</span><span class=nb>.</span> Written and copyrights by Michael Hipp.
Uses code from various people. See <span class=s1>&#39;README&#39;</span> <span class=k>for </span>more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</code></pre></div></div></div><div class=sect3><h4 id=rip-cd>14.3.2. Αποθήκευση (Rip) Αρχείων από Μουσικά CD<a class=anchor href=#rip-cd></a></h4><div class=paragraph><p>Πριν κωδικοποιήσετε ένα ολόκληρο CD ή ένα κομμάτι από CD σε αρχείο MP3, θα πρέπει να αντιγράψετε τα μουσικά δεδομένα από το CD στο σκληρό σας δίσκο. Αυτό γίνεται γράφοντας τα δεδομένα τύπου CDDA (CD Digital Audio) σε αρχεία WAV.</p></div><div class=paragraph><p>Το εργαλείο <code>cdda2wav</code>, το οποίο ανήκει στη συλλογή εργαλείων <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> μπορεί να χρησιμοποιηθεί τόσο για την ανάκτηση των δεδομένων ήχου από μουσικά CD, όσο και πληροφοριών που σχετίζονται με αυτά.</p></div><div class=paragraph><p>Έχοντας το μουσικό CD στον οδηγό, μπορείτε να χρησιμοποιήσετε την ακόλουθη εντολή (ως <code>root</code>) για να αποθηκεύσετε ένα ολόκληρο CD σε χωριστά (ανά κομμάτι) αρχεία WAV:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -B</span></code></pre></div></div><div class=paragraph><p>Το cdda2wav υποστηρίζει οδηγούς CDROM τύπου ATAPI (IDE). Για να διαβάσετε δεδομένα από μια συσκευή IDE, χρησιμοποιήστε το όνομα συσκευής αντί για τον αριθμό μονάδας SCSI. Για παράδειγμα, για να αποθηκεύσετε το κομμάτι 7 από ένα οδηγό IDE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D /dev/acd0 -t 7</span></code></pre></div></div><div class=paragraph><p>Το <code>-D <em>0,1,0</em></code> δείχνει τη συσκευή SCSI <span class=filename>0,1,0</span>, που αντιστοιχεί στην έξοδο της εντολής <code>cdrecord -scanbus</code>.</p></div><div class=paragraph><p>Για να διαβάσετε μεμονωμένα κομμάτια, χρησιμοποιήστε την επιλογή <code>-t</code> όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 7</span></code></pre></div></div><div class=paragraph><p>Το παράδειγμα αυτό διαβάζει το κομμάτι επτά του μουσικού CD. Για να διαβάσετε μια σειρά από κομμάτια, για παράδειγμα από το ένα ως το επτά, καθορίστε μια περιοχή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 1+7</span></code></pre></div></div><div class=paragraph><p>Μπορείτε επίσης να χρησιμοποιήσετε το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> για να διαβάσετε μουσικά κομμάτια από οδηγούς ATAPI. Διαβάστε το <a href=./#duplicating-audiocds>Duplicating Audio CDs</a> για περισσότερες πληροφορίες σχετικά με αυτή τη δυνατότητα.</p></div></div><div class=sect3><h4 id=mp3-encoding>14.3.3. Κωδικοποιώντας MP3<a class=anchor href=#mp3-encoding></a></h4><div class=paragraph><p>Στις μέρες μας, το προτιμώμενο πρόγραμμα κωδικοποίησης είναι το Lame. Μπορείτε να το βρείτε στη συλλογή των ports, στο <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a>.</p></div><div class=paragraph><p>Χρησιμοποιώντας τα αρχεία WAV που έχετε αποθηκεύσει, μπορείτε να μετατρέψετε το αρχείο <span class=filename>audio01.wav</span> σε <span class=filename>audio01.mp3</span> με την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lame -h -b 128 \</span>
<span class=nt>--tt</span> <span class=s2>&#34;Foo Song Title&#34;</span> <span class=se>\</span>
<span class=nt>--ta</span> <span class=s2>&#34;FooBar Artist&#34;</span> <span class=se>\</span>
<span class=nt>--tl</span> <span class=s2>&#34;FooBar Album&#34;</span> <span class=se>\</span>
<span class=nt>--ty</span> <span class=s2>&#34;2001&#34;</span> <span class=se>\</span>
<span class=nt>--tc</span> <span class=s2>&#34;Ripped and encoded by Foo&#34;</span> <span class=se>\</span>
<span class=nt>--tg</span> <span class=s2>&#34;Genre&#34;</span> <span class=se>\</span>
audio01.wav audio01.mp3</code></pre></div></div><div class=paragraph><p>Τα 128 kbits είναι η τυπικά χρησιμοποιούμενη ποιότητα για αρχεία MP3. Ωστόσο, πολλοί προτιμούν μεγαλύτερη ποιότητα όπως 160 ή 192. Όσο μεγαλύτερος είναι ο ρυθμός δεδομένων (bitrate), τόσο περισσότερο χώρο αποθήκευσης θα χρειάζεται το αρχείο MP3 που θα προκύψει, ωστόσο και η ποιότητα θα είναι υψηλότερη. Η επιλογή <code>-h</code> ενεργοποιεί τη δυνατότητα "υψηλότερης ποιότητας αλλά ελαφρά πιο αργής κωδικοποίησης". Οι επιλογές που ξεκινούν με <code>--t</code> δείχνουν ετικέτες (tags) ID3, οι οποίες συνήθως περιέχουν πληροφορίες σχετικές με το τραγούδι και οι οποίες μπορούν να ενσωματωθούν μέσα σε αρχεία MP3. Μπορείτε να βρείτε περισσότερες επιλογές σχετικά με την κωδικοποίηση, αν συμβουλευτείτε τη σελίδα manual του προγράμματος lame.</p></div></div><div class=sect3><h4 id=mp3-decoding>14.3.4. Αποκωδικοποιώντας MP3<a class=anchor href=#mp3-decoding></a></h4><div class=paragraph><p>Για να μπορέσετε να γράψετε μουσικό CD από αρχεία MP3, θα πρέπει να τα μετατρέψετε ξανά σε μορφή ασυμπίεστου αρχείου WAV. Τόσο το XMMS όσο και το mpg123 υποστηρίζουν εξαγωγή αρχείου MP3 σε ασυμπίεστη μορφή αρχείου.</p></div><div class=paragraph><p>Γράφοντας στο Δίσκο μέσω του XMMS:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Ξεκινήστε το XMMS.</p></li><li><p>Κάντε δεξί κλικ στο παράθυρο της εφαρμογής για να ανοίξετε το μενού του XMMS.</p></li><li><p>Επιλέξτε <code>Preferences</code> από τα <code>Options</code>.</p></li><li><p>Αλλάξτε το Output Plugin σε "Disk Writer Plugin".</p></li><li><p>Πιέστε <code>Configure</code>.</p></li><li><p>Γράψτε (ή επιλέξτε browse) ένα κατάλογο για να αποθηκεύσετε τα αποσυμπιεσμένα αρχεία.</p></li><li><p>Φορτώστε το αρχείο MP3 στο XMMS όπως συνήθως, με την ένταση στο 100% και τις ρυθμίσεις EQ ανενεργές.</p></li><li><p>Πιέστε το <code>Play</code>. Το XMMS θα φαίνεται ότι αναπαράγει το MP3, αλλά δεν θα ακούγεται κανείς ήχος. Στην πραγματικότητα αναπαράγει το MP3 σε αρχείο.</p></li><li><p>Όταν τελειώσετε, βεβαιωθείτε ότι επαναφέρατε τη ρύθμιση του προεπιλεγμένου Output Plugin στην προηγούμενη επιλογή της, για να μπορέσετε να ακούσετε ξανά αρχεία MP3.</p></li></ol></div><div class=paragraph><p>Γράφοντας στην έξοδο μέσω του mpg123:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Εκτελέστε <code>mpg123 -s audio01.mp3 > audio01.pcm</code></p></li></ol></div><div class=paragraph><p>Το XMMS γράφει αρχεία σε μορφή WAV, ενώ το mpg123 μετατρέπει το MP3 σε μη- επεξεργασμένα (raw) δεδομένα ήχου PCM. Και οι δύο αυτές μορφές μπορούν να χρησιμοποιηθούν με την εφαρμογή cdrecord για τη δημιουργία μουσικών CD. Για την εφαρμογή <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> θα πρέπει να χρησιμοποιήσετε δεδομένα PCM. Αν χρησιμοποιήσετε αρχεία WAV θα παρατηρήσετε ένα μικρό ήχο (tick) στην αρχή κάθε κομματιού. Ο ήχος αυτός προέρχεται από την επικεφαλίδα (header) του αρχείου WAV. Μπορείτε να αφαιρέσετε την επικεφαλίδα με τη βοήθεια του προγράμματος SoX (μπορείτε να το εγκαταστήσετε από το port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a> ή το αντίστοιχο πακέτο):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sox <span class=nt>-t</span> wav <span class=nt>-r</span> 44100 <span class=nt>-s</span> <span class=nt>-w</span> <span class=nt>-c</span> 2 track.wav track.raw</code></pre></div></div><div class=paragraph><p>Διαβάστε το <a href=./#creating-cds>Creating and Using CD Media</a> για περισσότερες πληροφορίες σχετικά με τη χρήση CD εγγραφής στο FreeBSD</p></div></div></div><div class=sect2><h3 id=video-playback>14.4. Αναπαραγωγή Video<a class=anchor href=#video-playback></a></h3><div class=paragraph><p>Η αναπαραγωγή video είναι μια καινούρια και ραγδαία αναπτυσσόμενη περιοχή εφαρμογών. Θα χρειαστεί να δείξετε υπομονή. Δεν πρόκειται να λειτουργήσουν όλα τόσο ομαλά όπως στον ήχο.</p></div><div class=paragraph><p>Πριν ξεκινήσετε, θα πρέπει να γνωρίζετε το μοντέλο της κάρτας γραφικών που έχετε καθώς και το ολοκληρωμένο κύκλωμα που χρησιμοποιεί. Αν και το Xorg υποστηρίζει μεγάλη γκάμα από κάρτες γραφικών, αυτές που παρέχουν καλή απόδοση είναι λιγότερες. Για να πάρετε μια λίστα των εκτεταμένων δυνατοτήτων που υποστηρίζονται από την κάρτα σας, χρησιμοποιήστε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=xdpyinfo&amp;sektion=1&amp;format=html">xdpyinfo(1)</a> την ώρα που εκτελούνται τα X11.</p></div><div class=paragraph><p>Είναι γενικά καλή ιδέα να έχετε ένα μικρό αρχείο MPEG το οποίο μπορεί να χρησιμοποιηθεί για δοκιμές διαφορετικών επιλογών και προγραμμάτων αναπαραγωγής. Κάποια προγράμματα αναπαραγωγής DVD αναζητούν από προεπιλογή το δίσκο DVD στη συσκευή <span class=filename>/dev/dvd</span>. Σε ορισμένα το όνομα της συσκευής είναι ενσωματωμένο στον κώδικα του προγράμματος. Για το λόγο αυτό, ίσως είναι χρήσιμο να φτιάξετε συμβολικές συνδέσεις προς τις πραγματικές συσκευές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /dev/acd0 /dev/dvd</span>
<span class=c># ln -sf /dev/acd0 /dev/rdvd</span></code></pre></div></div><div class=paragraph><p>Σημειώστε ότι λόγω της φύσης του συστήματος <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>, αυτού του είδους οι συνδέσεις δεν παραμένουν μετά την επανεκκίνηση του συστήματος σας. Για να δημιουργούνται οι συμβολικές συνδέσεις αυτόματα σε κάθε εκκίνηση του συστήματος σας, προσθέστε τις ακόλουθες γραμμές στο αρχείο <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>link acd0 dvd
link acd0 rdvd</pre></div></div><div class=paragraph><p>Επιπρόσθετα, η αποκωδικοποίηση DVD, η οποία χρειάζεται κλήση ειδικών λειτουργιών του DVD-ROM, απαιτεί και άδεια εγγραφής (write permission) στις συσκευές DVD.</p></div><div class=paragraph><p>Για τη βελτίωση της λειτουργίας της κοινόχρηστης μνήμης του συστήματος X11, συνίσταται να αυξήσετε τις τιμές κάποιων μεταβλητών <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</pre></div></div><div class=sect3><h4 id=video-interface>14.4.1. Προσδιορισμός Δυνατοτήτων Κάρτας Γραφικών<a class=anchor href=#video-interface></a></h4><div class=paragraph><p>Υπάρχουν αρκετοί διαφορετικοί τρόποι για την απεικόνιση video στο X11. Το τι θα δουλέψει τελικά, εξαρτάται σε μεγάλο βαθμό από το υλικό σας. Κάθε μέθοδος που περιγράφουμε παρακάτω θα δώσει διαφορετική ποιότητα σε διαφορετικό υλικό. Επίσης, η αναπαραγωγή video στο X11 είναι ένα θέμα στο οποίο πρόσφατα δίνεται μεγάλη σημασία, και πιθανόν θα υπάρχουν αρκετές βελτιώσεις σε κάθε νέα έκδοση του Xorg.</p></div><div class=paragraph><p>Κατάλογος κοινών διεπαφών video:</p></div><div class="olist arabic"><ol class=arabic><li><p>X11: Συνηθισμένη έξοδος του X11 με χρήση κοινόχρηστης μνήμης.</p></li><li><p>XVideo: μια επέκταση της διεπαφής X11 που υποστηρίζει αναπαραγωγή video σε οποιαδήποτε σχεδιάσιμη επιφάνεια του X11.</p></li><li><p>SDL: Simple Directmedia Layer.</p></li><li><p>DGA: Direct Graphics Access.</p></li><li><p>SVGAlib: Επίπεδο γραφικών χαμηλού επιπέδου για κονσόλα.</p></li></ol></div><div class=sect4><h5 id=video-interface-xvideo>14.4.1.1. XVideo<a class=anchor href=#video-interface-xvideo></a></h5><div class=paragraph><p>Το Xorg διαθέτει μια επέκταση που ονομάζεται <em>XVideo</em> (γνωστή και ως Xvideo, Xv, xv) και το οποίο επιτρέπει την απευθείας απεικόνιση video σε σχεδιάσιμα αντικείμενα μέσω ειδικής επιτάχυνσης. Η επέκταση αυτή παρέχει αναπαραγωγή πολύ καλής ποιότητας, ακόμα και σε μηχανήματα χαμηλών προδιαγραφών.</p></div><div class=paragraph><p>Για να δείτε αν χρησιμοποιείται η επέκταση, χρησιμοποιήστε την εντολή <code>xvinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xvinfo</code></pre></div></div><div class=paragraph><p>Το XVideo υποστηρίζεται από την κάρτα σας αν το αποτέλεσμα δείχνει όπως παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
  Adaptor <span class=c>#0: &#34;Savage Streams Engine&#34;</span>
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      <span class=s2>&#34;XV_COLORKEY&#34;</span> <span class=o>(</span>range 0 to 16777215<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 2110<span class=o>)</span>
      <span class=s2>&#34;XV_BRIGHTNESS&#34;</span> <span class=o>(</span>range <span class=nt>-128</span> to 127<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
      <span class=s2>&#34;XV_CONTRAST&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_SATURATION&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_HUE&#34;</span> <span class=o>(</span>range <span class=nt>-180</span> to 180<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      <span class=nb>id</span>: 0x32595559 <span class=o>(</span>YUY2<span class=o>)</span>
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x32315659 <span class=o>(</span>YV12<span class=o>)</span>
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x30323449 <span class=o>(</span>I420<span class=o>)</span>
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x36315652 <span class=o>(</span>RV16<span class=o>)</span>
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      <span class=nb>id</span>: 0x35315652 <span class=o>(</span>RV15<span class=o>)</span>
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      <span class=nb>id</span>: 0x31313259 <span class=o>(</span>Y211<span class=o>)</span>
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</code></pre></div></div><div class=paragraph><p>Παρατηρήστε επίσης ότι τα formats που εμφανίζονται (YUV2, YUV12, κ.λ.π.) δεν διατίθενται σε όλες τις εκδόσεις του XVideo, και η απουσία τους μπορεί να επηρεάσει κάποια προγράμματα αναπαραγωγής.</p></div><div class=paragraph><p>Αν το αποτέλεσμα δείχνει κάπως έτσι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
no adaptors present</code></pre></div></div><div class=paragraph><p>Τότε πιθανώς το XVideo δεν υποστηρίζεται από την κάρτα σας.</p></div><div class=paragraph><p>Αν το XVideo δεν υποστηρίζεται από την κάρτα σας, αυτό σημαίνει απλά ότι θα είναι πιο δύσκολο ο υπολογιστής σας να ανταποκριθεί στις υπολογιστικές απαιτήσεις της απεικόνισης video. Ωστόσο, ανάλογα με την κάρτα γραφικών και τον επεξεργαστή σας, είναι ακόμα πιθανόν να έχετε ικανοποιητική αναπαραγωγή. Ίσως πρέπει να διαβάσετε μεθόδους για τη βελτίωση της απόδοσης, στα προχωρημένα θέματα, <a href=#video-further-reading>Επιπλέον Διάβασμα</a>.</p></div></div><div class=sect4><h5 id=video-interface-SDL>14.4.1.2. Το Επίπεδο Simple Directmedia Layer<a class=anchor href=#video-interface-SDL></a></h5><div class=paragraph><p>Το Simple Directmedia Layer, SDL, προορίζονταν να γίνει ένα επίπεδο συμβατότητας μεταξύ των Microsoft® Windows®, BeOS, και του UNIX®, επιτρέποντας ανάπτυξη εφαρμογών ήχου και εικόνας, κατάλληλες για κάθε μια από αυτές τις πλατφόρμες (cross-platform). Το επίπεδο SDL παρέχει χαμηλού επιπέδου πρόσβαση στο υλικό, και σε ορισμένες περιπτώσεις μπορεί να είναι πιο αποδοτικό από την διεπαφή X11.</p></div><div class=paragraph><p>Το SDL μπορεί να βρεθεί στο <a class=package href=https://cgit.freebsd.org/ports/tree/devel/sdl12/>devel/sdl12</a>.</p></div></div><div class=sect4><h5 id=video-interface-DGA>14.4.1.3. Το Επίπεδο Direct Graphics Access<a class=anchor href=#video-interface-DGA></a></h5><div class=paragraph><p>Το Direct Graphics Access είναι μια επέκταση του X11 που επιτρέπει σε ένα πρόγραμμα να προσπεράσει τον X server και να αλλάξει απευθείας τα περιεχόμενα του framebuffer (μνήμης γραφικών). Δεδομένου ότι βασίζεται σε διαχείριση μνήμης χαμηλού επιπέδου, τα προγράμματα που το χρησιμοποιούν πρέπει να εκτελούνται ως <code>root</code>.</p></div><div class=paragraph><p>Η επέκταση DGA μπορεί να ελεγχθεί και να μετρηθεί ως προς την απόδοση της με το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=dga&amp;sektion=1&amp;format=html">dga(1)</a>. Όταν εκτελείται η εντολή <code>dga</code>, αλλάζει τα χρώματα της οθόνης σε κάθε πίεση ενός πλήκτρου. Για να ακυρώσετε την εκτέλεση, πιέστε <kbd>q</kbd>.</p></div></div></div><div class=sect3><h4 id=video-ports>14.4.2. Πακέτα και Ports που Σχετίζονται με Video<a class=anchor href=#video-ports></a></h4><div class=paragraph><p>Το τμήμα αυτό περιγράφει το λογισμικό που διατίθεται στη συλλογή των ports του FreeBSD και το οποίο μπορεί να χρησιμοποιηθεί για αναπαραγωγή video. Ο τομέας της αναπαραγωγής video είναι ιδιαίτερα ενεργός όσο αφορά την ανάπτυξη λογισμικού, και έτσι οι δυνατότητες των εφαρμογών πιθανώς να αποκλίνουν κάπως από αυτές που περιγράφονται εδώ.</p></div><div class=paragraph><p>Είναι αρχικά σημαντικό να γνωρίζετε ότι αρκετές από τις εφαρμογές video που εκτελούνται στο FreeBSD αναπτύχθηκαν αρχικά ως εφαρμογές Linux. Πολλές από αυτές τις εφαρμογές είναι ακόμα ποιότητας beta. Κάποια από τα προβλήματα που μπορεί να συναντήσετε στις εφαρμογές video του FreeBSD περιλαμβάνουν:</p></div><div class="olist arabic"><ol class=arabic><li><p>Μια εφαρμογή δεν μπορεί να αναπαράγει ένα αρχείο που δημιουργήθηκε από κάποια άλλη.</p></li><li><p>Μια εφαρμογή δεν μπορεί να αναπαράγει ένα αρχείο που δημιούργησε η ίδια.</p></li><li><p>Η ίδια εφαρμογή, σε δυο διαφορετικά μηχανήματα, και αφού έχει μεταγλωττιστεί σε κάθε μηχάνημα ειδικά για αυτό, αναπαράγει το ίδιο αρχείο με διαφορετικό τρόπο.</p></li><li><p>Κάποιο φαινομενικά απλό φίλτρο, όπως αυτό της αλλαγής μεγέθους εικόνας (rescaling), έχει ως αποτέλεσμα την δημιουργία κακής ποιότητας video (τεχνουργημάτων) εξαιτίας προβληματικής ρουτίνας μεγέθυνσης</p></li><li><p>Κάποια εφαρμογή τερματίζεται απότομα συχνά.</p></li><li><p>Δεν εγκαθίσταται η τεκμηρίωση του προγράμματος κατά την εγκατάσταση του port, ενώ μπορεί να βρεθεί είτε στο δικτυακό τόπο του προγράμματος είτε στον κατάλογο <span class=filename>work</span> του port.</p></li></ol></div><div class=paragraph><p>Πολλές από τις εφαρμογές αυτές μπορεί επίσης να παρουσιάσουν συμπτώματα "Linux-ισμού". Μπορεί δηλ. να εμφανίζουν προβλήματα που οφείλονται στον τρόπο με τον οποίο υλοποιούνται κάποιες στάνταρ βιβλιοθήκες στις διανομές του Linux, ή ίσως οι συγγραφείς να έχουν θεωρήσει ως δεδομένες κάποιες δυνατότητες του πυρήνα όπως υπάρχουν στο Linux. Τα προβλήματα αυτά δεν είναι σίγουρο ότι ανακαλύπτονται και διορθώνονται πάντα από τους συντηρητές του port, το οποίο μπορεί να οδηγήσει σε προβλήματα όπως τα παρακάτω:</p></div><div class="olist arabic"><ol class=arabic><li><p>Χρήση του αρχείου <span class=filename>/proc/cpuinfo</span> για την ανίχνευση των δυνατοτήτων του επεξεργαστή.</p></li><li><p>Κακή χρήση των threads (νημάτων) το οποίο οδηγεί το πρόγραμμα σε κόλλημα αντί για κανονικό τερματισμό στο τέλος της εκτέλεσης.</p></li><li><p>Χρήση λογισμικού που δεν υπάρχει ακόμα στη συλλογή των ports του FreeBSD σε συνδυασμό με την εφαρμογή.</p></li></ol></div><div class=paragraph><p>Μέχρι στιγμής οι συγγραφείς των εφαρμογών αυτών έχουν αποδειχθεί συνεργάσιμοι με τους συντηρητές των ports, ώστε να ελαχιστοποιηθούν οι επεμβάσεις που χρειάζονται για την μετατροπή (porting) των εφαρμογών.</p></div><div class=sect4><h5 id=video-mplayer>14.4.2.1. MPlayer<a class=anchor href=#video-mplayer></a></h5><div class=paragraph><p>Ο MPlayer είναι μια εφαρμογή αναπαραγωγής video που αναπτύχθηκε πρόσφατα και εξελίσσεται ταχύτατα. Οι στόχοι της ομάδας ανάπτυξης του MPlayer είναι η ταχύτητα και η ευελιξία στο Linux και στα άλλα Unix. Η δημιουργία του ξεκίνησε όταν ο αρχηγός της ομάδας ανάπτυξης κουράστηκε να αντιμετωπίζει τα προβλήματα αναπαραγωγής των μέχρι τότε διαθέσιμων προγραμμάτων. Κάποιοι υποστηρίζουν ότι το γραφικό περιβάλλον θυσιάστηκε για να δημιουργηθεί μια ομοιόμορφη σχεδίαση. Ωστόσο, μόλις συνηθίσετε τις επιλογές που δίνονται από τη γραμμή εντολών και τα αντίστοιχα πλήκτρα, θα μπορέσετε να τον χρησιμοποιήσετε αρκετά καλά.</p></div><div class=sect5><h6 id=video-mplayer-building>14.4.2.1.1. Μεταγλώττιση του MPlayer<a class=anchor href=#video-mplayer-building></a></h6><div class=paragraph><p>Ο MPlayer βρίσκεται στο <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mplayer/>multimedia/mplayer</a>. Ο MPlayer κάνει πλήθος ελέγχων του υλικού κατά τη διαδικασία της μεταγλώττισης, φτιάχνοντας έτσι ένα εκτελέσιμο το οποίο δεν έχει φορητότητα από ένα σύστημα σε ένα άλλο. Για το σκοπό αυτό, είναι σημαντικό να τον εγκαταστήσετε από τα ports και όχι από έτοιμο πακέτο. Επιπρόσθετα, μπορείτε να καθορίσετε πλήθος επιλογών στην γραμμή εντολών του <code>make</code> όπως περιγράφεται στο <span class=filename>Makefile</span> και κατά την έναρξη της διαδικασίας μεταγλώττισης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mplayer</span>
<span class=c># make</span>
N - O - T - E

Take a careful look into the Makefile <span class=k>in </span>order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either <span class=nb>install</span>
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html</code></pre></div></div><div class=paragraph><p>Οι προεπιλεγμένες επιλογές μάλλον είναι κατάλληλες για τους περισσότερους χρήστες. Αν ωστόσο χρειάζεστε τον αποκωδικοποιητή XviD, θα πρέπει να καθορίσετε την επιλογή <code>WITH_XVID</code> στην γραμμή εντολών. Μπορείτε επίσης να ορίσετε την προεπιλεγμένη συσκευή DVD χρησιμοποιώντας την επιλογή <code>WITH_DVD_DEVICE</code>, διαφορετικά θα χρησιμοποιηθεί η προεπιλεγμένη συσκευή <span class=filename>/dev/acd0</span>.</p></div><div class=paragraph><p>Όταν γράφονταν αυτό το κείμενο, το port του MPlayer δημιουργούσε επίσης την τεκμηρίωση του προγράμματος και δύο εκτελέσιμα, τον <code>mplayer</code>, και τον <code>mencoder</code>, το οποίο είναι ένα εργαλείο για επανακωδικοποίηση video.</p></div><div class=paragraph><p>Η HTML τεκμηρίωση του MPlayer είναι ιδιαίτερα πληροφοριακή. Αν ο αναγνώστης βρει ότι οι πληροφορίες αυτού του κεφαλαίου όσο αφορά το υλικό και τις διεπαφές video είναι ελλιπείς, η τεκμηρίωση του MPlayer αποτελεί ένα ιδιαίτερα αναλυτικό συμπλήρωμα. Θα πρέπει σίγουρα να διαθέσετε χρόνο για να διαβάσετε την τεκμηρίωση του MPlayer αν αναζητάτε πληροφορίες σχετικά με την υποστήριξη video στο UNIX®.</p></div></div><div class=sect5><h6 id=video-mplayer-using>14.4.2.1.2. Χρησιμοποιώντας τον MPlayer<a class=anchor href=#video-mplayer-using></a></h6><div class=paragraph><p>Κάθε χρήστης του MPlayer πρέπει να δημιουργήσει ένα υποκατάλογο <span class=filename>.mplayer</span> μέσα στον προσωπικό του κατάλογο. Για να δημιουργήσετε τον απαραίτητο υποκατάλογο, μπορείτε να γράψετε το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/ports/multimedia/mplayer
% make install-user</code></pre></div></div><div class=paragraph><p>Οι επιλογές της γραμμής εντολών του <code>mplayer</code> περιγράφονται στη σελίδα του manual. Για ακόμα περισσότερες λεπτομέρειες, υπάρχει τεκμηρίωση σε μορφή HTML. Στο τμήμα αυτό θα περιγράψουμε μερικές μόνο κοινές χρήσεις.</p></div><div class=paragraph><p>Για να αναπαράγετε ένα αρχείο, όπως το <span class=filename>testfile.avi</span>, μέσω ενός από τα αρκετά video interfaces χρησιμοποιήστε την επιλογή <code>-vo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> xv testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> sdl testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> x11 testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga testfile.avi</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo &#39;sdl:dga&#39; testfile.avi</span></code></pre></div></div><div class=paragraph><p>Αξίζει τον κόπο να δοκιμάσετε όλες αυτές τις επιλογές, καθώς η απόδοση τους εξαρτάται από πολλούς παράγοντες και διαφοροποιείται αρκετά ανάλογα με το υλικό του υπολογιστή σας.</p></div><div class=paragraph><p>Για αναπαραγωγή από DVD, αντικαταστήστε το <span class=filename>testfile.avi</span> με <code>dvd://<em>N</em> -dvd-device <em>DEVICE</em></code> όπου το <em>N</em> είναι ο αριθμός του τίτλου (title number) που επιθυμείτε να αναπαράγετε και <span class=filename>DEVICE</span> είναι το όνομα συσκευής του DVD-ROM. Για παράδειγμα, για να αναπαράγετε τον τίτλο 3 από τη συσκευή <span class=filename>/dev/dvd</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo xv dvd://3 -dvd-device /dev/dvd</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η προεπιλεγμένη συσκευή DVD μπορεί να καθοριστεί κατά τη διάρκεια της μεταγλώττισης του MPlayer port μέσω της επιλογής <code>WITH_DVD_DEVICE</code>. Από προεπιλογή, η συσκευή αυτή είναι η <span class=filename>/dev/acd0</span>. Μπορείτε να βρείτε περισσότερες πληροφορίες στο αρχείο <span class=filename>Makefile</span> του port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για τα πλήκτρα που χρησιμοποιούνται για παύση, διακοπή, μετακίνηση κλπ. κατά τη διάρκεια της αναπαραγωγής, συμβουλευτείτε την βοήθεια που μπορείτε να δείτε εκτελώντας <code>mplayer -h</code> ή διαβάστε τη σελίδα του manual.</p></div><div class=paragraph><p>Επιπρόσθετα, σημαντικές επιλογές αναπαραγωγής είναι: <code>-fs -zoom</code> το οποίο ενεργοποιεί απεικόνιση σε πλήρη οθόνη και το <code>-framedrop</code> το οποίο βοηθάει στην αύξηση της απόδοσης.</p></div><div class=paragraph><p>Για να μείνει το μέγεθος της γραμμής εντολών το δυνατόν μικρό, ο χρήστης μπορεί να δημιουργήσει ένα αρχείο <span class=filename>.mplayer/config</span> και να ορίσει εκεί τις προεπιλεγμένες επιλογές:</p></div><div class="literalblock programlisting"><div class=content><pre>vo=xv
fs=yes
zoom=yes</pre></div></div><div class=paragraph><p>Τέλος, ο <code>mplayer</code> μπορεί να χρησιμοποιηθεί για την εξαγωγή (rip) ενός τίτλου DVD σε ένα αρχείο <span class=filename>.vob</span> file. Για την εξαγωγή του δεύτερου τίτλου από ένα DVD, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</span></code></pre></div></div><div class=paragraph><p>Το αρχείο εξόδου, <span class=filename>out.vob</span>, θα είναι τύπου MPEG και μπορείτε να το μεταχειριστείτε μέσω άλλων πακέτων video που περιγράφονται σε αυτό το τμήμα.</p></div></div><div class=sect5><h6 id=video-mencoder>14.4.2.1.3. mencoder<a class=anchor href=#video-mencoder></a></h6><div class=paragraph><p>Πριν χρησιμοποιήσετε το <code>mencoder</code> είναι καλή ιδέα να εξοικειωθείτε με τις επιλογές που αναφέρονται στην τεκμηρίωση HTML. Υπάρχει σελίδα manual, αλλά δεν είναι πολύ χρήσιμη χωρίς την HTML τεκμηρίωση. Υπάρχουν πάρα πολλοί τρόποι για να βελτιώσετε την ποιότητα, να μειώσετε το ρυθμό δεδομένων (bitrate) να αλλάξετε μορφή αρχείου, και κάποια από αυτά τα κόλπα μπορεί να κάνουν τη διαφορά μεταξύ καλής και κακής απόδοσης. Εδώ θα δείτε μερικά παραδείγματα για να ξεκινήσετε. Πρώτα μια απλή αντιγραφή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> copy <span class=nt>-ovc</span> copy <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>Λανθασμένοι συνδυασμοί στη γραμμή εντολών, μπορεί να δώσουν αρχεία εξόδου τα οποία δεν μπορεί να αναπαράγει ούτε ο ίδιος ο <code>mplayer</code>. Έτσι, αν απλώς θέλετε να κάνετε rip ένα αρχείο, μείνετε στην επιλογή <code>-dumpfile</code> του <code>mplayer</code>.</p></div><div class=paragraph><p>Για να μετατρέψετε το <span class=filename>input.avi</span> σε codec MPEG4 με ήχο MPEG3 (απαιτείται το <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> mp3lame <span class=nt>-lameopts</span> <span class=nv>br</span><span class=o>=</span>192 <span class=se>\</span>
	 <span class=nt>-ovc</span> lavc <span class=nt>-lavcopts</span> <span class=nv>vcodec</span><span class=o>=</span>mpeg4:vhq <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>Με τον τρόπο αυτό παράγεται έξοδος που μπορεί να αναπαραχθεί από τον <code>mplayer</code> και το <code>xine</code>.</p></div><div class=paragraph><p>Μπορείτε να αντικαταστήσετε το <span class=filename>input.avi</span> με την επιλογή <code>dvd://1 -dvd-device /dev/dvd</code> και να το εκτελέσετε ως <code>root</code> για να επανακωδικοποιήσετε απευθείας ένα τίτλο DVD. Μια και πιθανώς δεν θα μείνετε ικανοποιημένος με το αποτέλεσμα από την πρώτη φορά, σας συνιστούμε να κατεβάσετε τον τίτλο σε ένα αρχείο και να δουλέψετε σε αυτό.</p></div></div></div><div class=sect4><h5 id=video-xine>14.4.2.2. Το Πρόγραμμα Αναπαραγωγής xine<a class=anchor href=#video-xine></a></h5><div class=paragraph><p>Το xine είναι ένα project με ευρύ σκοπό, το οποίο προορίζεται όχι μόνο να γίνει ένα πρόγραμμα όλα σε ένα όσο αφορά το video, αλλά επίσης στο να παράγει μια επαναχρησιμοποιήσιμη βασική βιβλιοθήκη και ένα αρθρωτό εκτελέσιμο το οποίο μπορεί να επεκταθεί με πρόσθετα (plugins). Μπορείτε να το εγκαταστήσετε τόσο από πακέτο, όσο και από το port, <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xine/>multimedia/xine</a>.</p></div><div class=paragraph><p>Το xine είναι ακόμα κάπως χοντροκομμένο, αλλά σίγουρα έχει ξεκινήσει καλά. Στην πράξη, το xine χρειάζεται είτε γρήγορο επεξεργαστή και κάρτα γραφικών, ή υποστήριξη της επέκτασης XVideo. Το γραφικό περιβάλλον είναι χρησιμοποιήσιμο, αλλά κάπως αδέξια φτιαγμένο.</p></div><div class=paragraph><p>Την ώρα που γράφονταν αυτές οι γραμμές δεν διανέμονταν module μαζί με την εφαρμογή xine, ικανό να αναπαράγει DVD με CSS κωδικοποίηση. Υπάρχουν εκδόσεις από τρίτους κατασκευαστές οι οποίες έχουν ενσωματωμένο το παραπάνω module αλλά καμιά από αυτές δεν βρίσκεται στην συλλογή των ports του FreeBSD.</p></div><div class=paragraph><p>Σε σύγκριση με τον MPlayer, το xine κάνει περισσότερα για το χρήστη, αλλά την ίδια στιγμή, δεν επιτρέπει τόσο λεπτομερειακό έλεγχο. Το xine αποδίδει καλύτερα σε λειτουργία XVideo.</p></div><div class=paragraph><p>Από προεπιλογή, το xine θα ξεκινήσει σε γραφικό περιβάλλον (GUI). Μπορείτε να χρησιμοποιήσετε το μενού για να ανοίξετε ένα συγκεκριμένο αρχείο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine</code></pre></div></div><div class=paragraph><p>Εναλλακτικά, μπορείτε να το καλέσετε να αναπαράγει ένα αρχείο απευθείας από την γραμμή εντολών, χωρίς τη χρήση του GUI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine <span class=nt>-g</span> <span class=nt>-p</span> mymovie.avi</code></pre></div></div></div><div class=sect4><h5 id=video-ports-transcode>14.4.2.3. Τα Βοηθητικά Προγράμματα transcode<a class=anchor href=#video-ports-transcode></a></h5><div class=paragraph><p>Η εφαρμογή transcode δεν είναι πρόγραμμα αναπαραγωγής, αλλά μια σουίτα εργαλείων για επανακωδικοποίηση αρχείων video και ήχου. Με την εφαρμογή transcode, έχετε την δυνατότητα να αναμίξετε αρχεία video, να επισκευάσετε χαλασμένα αρχεία, χρησιμοποιώντας εργαλεία της γραμμής εντολών τα οποία χειρίζονται δεδομένα από τα κανάλια <span class=filename>stdin/stdout</span>.</p></div><div class=paragraph><p>Μεγάλο πλήθος εφαρμογών μπορούν να καθοριστούν κατά τη διάρκεια της μεταγλώττισης του port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/transcode/>multimedia/transcode</a> και συνιστούμε την ακόλουθη γραμμή εντολών για τη μεταγλώττιση του transcode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \</span>
<span class=nv>WITH_MJPEG</span><span class=o>=</span><span class=nb>yes</span> <span class=nt>-DWITH_XVID</span><span class=o>=</span><span class=nb>yes</span></code></pre></div></div><div class=paragraph><p>Οι προτεινόμενες επιλογές είναι κατάλληλες για τους περισσότερους χρήστες.</p></div><div class=paragraph><p>Για να σας δείξουμε τις ικανότητες του <code>transcode</code>, δείτε ένα παράδειγμα μετατροπής αρχείου DivX σε PAL MPEG-1 (PAL VCD):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% transcode <span class=nt>-i</span> input.avi <span class=nt>-V</span> <span class=nt>--export_prof</span> vcd-pal <span class=nt>-o</span> output_vcd
% mplex <span class=nt>-f</span> 1 <span class=nt>-o</span> output_vcd.mpg output_vcd.m1v output_vcd.mpa</code></pre></div></div><div class=paragraph><p>Το αρχείο MPEG που προκύπτει, το <span class=filename>output_vcd.mpg</span>, μπορεί να αναπαραχθεί από τον MPlayer. Μπορείτε επίσης να γράψετε το αρχείο σε ένα CD-R για να δημιουργήσετε ένα Video CD, και στην περίπτωση αυτή θα χρειαστεί να εγκαταστήσετε τα προγράμματα <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/vcdimager/>multimedia/vcdimager</a> και <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a>.</p></div><div class=paragraph><p>Υπάρχει σελίδα manual για το <code>transcode</code>, αλλά πρέπει επίσης να συμβουλευτείτε το <a href=http://www.transcoding.org/cgi-bin/transcode>transcode wiki</a> για περισσότερες πληροφορίες και παραδείγματα.</p></div></div></div><div class=sect3><h4 id=video-further-reading>14.4.3. Επιπλέον Διάβασμα<a class=anchor href=#video-further-reading></a></h4><div class=paragraph><p>Υπάρχει ραγδαία εξέλιξη στα διαθέσιμα πακέτα video για το FreeBSD. Είναι αρκετά πιθανό ότι στο άμεσο μέλλον πολλά από τα προβλήματα που αναφέρονται εδώ θα έχουν επιλυθεί. Στο ενδιάμεσο διάστημα, όσοι ενδιαφέρονται να χρησιμοποιήσουν τις δυνατότητες A/V του FreeBSD στο έπακρο θα πρέπει να συνδυάσουν γνώσεις από διάφορα FAQ και tutorials και να χρησιμοποιήσουν αρκετές διαφορετικές εφαρμογές. Το τμήμα αυτό υπάρχει ακριβώς για να δείξει στον αναγνώστη που μπορεί να βρει τέτοιες πρόσθετες πληροφορίες.</p></div><div class=paragraph><p>Η <a href=http://www.mplayerhq.hu/DOCS/>Τεκμηρίωση του Mplayer </a>είναι αρκετά πληροφοριακή όσο αφορά το τεχνικό επίπεδο. Αν έχετε σκοπό να αποκτήσετε υψηλό ποσοστό εμπειρίας σε σχέση με το video στο UNIX®, θα πρέπει οπωσδήποτε να την συμβουλευτείτε. Η λίστα αλληλογραφίας του MPlayer είναι εχθρική σε όποιον δεν έχει κάνει τον κόπο να διαβάσει την τεκμηρίωση, έτσι αν σκοπεύετε να κάνετε αναφορές σφαλμάτων, βεβαιωθείτε ότι την έχετε διαβάσει.</p></div><div class=paragraph><p>Το <a href=http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html>xine HOWTO</a> περιέχει ένα κεφάλαιο σχετικά με την βελτίωση της απόδοσης, το οποίο είναι κοινό για όλα τα προγράμματα αναπαραγωγής.</p></div><div class=paragraph><p>Τέλος, υπάρχουν κάποιες άλλες πολλά υποσχόμενες εφαρμογές που ίσως επιθυμείτε να δοκιμάσετε:</p></div><div class=ulist><ul><li><p>Το <a href=http://avifile.sourceforge.net/>Avifile</a> το οποίο είναι επίσης port, <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/avifile/>multimedia/avifile</a>.</p></li><li><p>Το <a href=http://www.dtek.chalmers.se/groups/dvd/>Ogle</a> το οποίο είναι επίσης port, <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/ogle/>multimedia/ogle</a>.</p></li><li><p>Το <a href=http://xtheater.sourceforge.net/>Xtheater</a></p></li><li><p>Το <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a>, το οποίο είναι εφαρμογή DVD authoring ανοικτού κώδικα.</p></li></ul></div></div></div><div class=sect2><h3 id=tvcard>14.5. Ρύθμιση Κάρτας Τηλεόρασης<a class=anchor href=#tvcard></a></h3><div class=sect3><h4 id=_εισαγωγή_2>14.5.1. Εισαγωγή<a class=anchor href=#_εισαγωγή_2></a></h4><div class=paragraph><p>Οι κάρτες τηλεόρασης σας επιτρέπουν να βλέπετε τηλεόραση, κανονική ή καλωδιακή, στον υπολογιστή σας. Οι περισσότερες από αυτές δέχονται επίσης σήμα σύνθετου (composite) video, μέσω εισόδου RCA ή S-video, και κάποιες από αυτές διαθέτουν και ραδιοφωνικό δέκτη FM.</p></div><div class=paragraph><p>Το FreeBSD παρέχει υποστήριξη για κάρτες TV τύπου PCI που χρησιμοποιούν τα ολοκληρωμένα κυκλώματα σύλληψης video, Brooktree Bt848/849/878/879 ή Conexant CN-878/Fusion 878a με το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>. Θα πρέπει επίσης να βεβαιωθείτε ότι η κάρτα έρχεται με δέκτη που υποστηρίζεται. Συμβουλευτείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> για να δείτε τη λίστα των υποστηριζόμενων δεκτών.</p></div></div><div class=sect3><h4 id=_εγκαθιστώντας_το_πρόγραμμα_οδήγησης>14.5.2. Εγκαθιστώντας το Πρόγραμμα Οδήγησης<a class=anchor href=#_εγκαθιστώντας_το_πρόγραμμα_οδήγησης></a></h4><div class=paragraph><p>Για να χρησιμοποιήσετε την κάρτα θα πρέπει να φορτώσετε το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>, προσθέτοντας την ακόλουθη γραμμή στο αρχείο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Εναλλακτικά, μπορείτε να προσθέσετε στατική υποστήριξη για την κάρτα στο πυρήνα σας, και για το σκοπό αυτό προσθέστε τις ακόλουθες γραμμές στο αρχείο ρυθμίσεων του πυρήνα:</p></div><div class="literalblock programlisting"><div class=content><pre>device  bktr
device  iicbus
device  iicbb
device  smbus</pre></div></div><div class=paragraph><p>Οι επιπρόσθετοι οδηγοί συσκευών είναι απαραίτητοι, επειδή τα εξαρτήματα της κάρτας επικοινωνούν μεταξύ τους διαμέσου ενός διαύλου I2C. Αφού κάνετε τις απαραίτητες αλλαγές στο αρχείο, μεταγλωττίστε και εγκαταστήστε το νέο πυρήνα.</p></div><div class=paragraph><p>Μόλις τελειώσετε με αυτή τη διαδικασία, θα πρέπει να επανεκκινήσετε το σύστημα σας. Κατά τη διάρκεια της εκκίνησης, θα πρέπει να δείτε κάποια μηνύματα από την κάρτα σας, όπως τα παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</pre></div></div><div class=paragraph><p>Φυσικά, τα μηνύματα αυτά θα διαφέρουν ανάλογα με το υλικό σας. Ωστόσο θα πρέπει να ελέγξετε ότι ανιχνεύθηκε σωστά ο δέκτης. Είναι δυνατόν να αλλάξετε κάποιες από τις παραμέτρους που ανιχνεύθηκαν χρησιμοποιώντας MIBs του <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> καθώς και επιλογές στο αρχείο ρυθμίσεων πυρήνα. Για παράδειγμα, να θέλετε να επιβάλετε ο δέκτης να είναι τύπου Philips SECAM, θα πρέπει να προσθέσετε την ακόλουθη γραμμή στο αρχείο ρυθμίσεων του πυρήνα σας:</p></div><div class="literalblock programlisting"><div class=content><pre>options OVERRIDE_TUNER=6</pre></div></div><div class=paragraph><p>ή μπορείτε να χρησιμοποιήσετε απευθείας το <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.bt848.tuner=6</span></code></pre></div></div><div class=paragraph><p>Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> καθώς και το αρχείο <span class=filename>/usr/src/sys/conf/NOTES</span> για περισσότερες λεπτομέρειες σχετικά με τις διαθέσιμες επιλογές.</p></div></div><div class=sect3><h4 id=_χρήσιμες_εφαρμογές>14.5.3. Χρήσιμες Εφαρμογές<a class=anchor href=#_χρήσιμες_εφαρμογές></a></h4><div class=paragraph><p>Για να χρησιμοποιήσετε την κάρτα τηλεόρασης, θα πρέπει να εγκαταστήσετε μια από τις παρακάτω εφαρμογές:</p></div><div class=ulist><ul><li><p>Το <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/fxtv/>multimedia/fxtv</a> παρέχει δυνατότητα να δείτε τηλεόραση σε παράθυρο, καθώς και την δυνατότητα σύλληψης εικόνας / ήχου / video.</p></li><li><p>Το <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xawtv/>multimedia/xawtv</a> είναι επίσης εφαρμογή τηλεόρασης, με δυνατότητες όμοιες με το fxtv.</p></li><li><p>Το <a class=package href=https://cgit.freebsd.org/ports/tree/misc/alevt/>misc/alevt</a> αποκωδικοποιεί και απεικονίζει Videotext/Teletext.</p></li><li><p>Το <a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmradio/>audio/xmradio</a> είναι μια εφαρμογή για να χρησιμοποιήσετε το δέκτη FM που είναι ενσωματωμένος σε κάποιες κάρτες τηλεόρασης.</p></li><li><p>Το <a class=package href=https://cgit.freebsd.org/ports/tree/audio/wmtune/>audio/wmtune</a> είναι μια βολική desktop εφαρμογή για ραδιοφωνικούς δέκτες.</p></li></ul></div><div class=paragraph><p>Μπορείτε να βρείτε περισσότερες εφαρμογές στη συλλογή των Ports του FreeBSD.</p></div></div><div class=sect3><h4 id=_αντιμετώπιση_προβλημάτων>14.5.4. Αντιμετώπιση Προβλημάτων<a class=anchor href=#_αντιμετώπιση_προβλημάτων></a></h4><div class=paragraph><p>Αν αντιμετωπίσετε κάποιο πρόβλημα με την κάρτα τηλεόρασης, θα πρέπει πρώτα να ελέγξετε αν το ολοκληρωμένο σύλληψης video καθώς και ο δέκτης υποστηρίζονται από το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> και αν έχετε χρησιμοποιήσει τις σωστές ρυθμίσεις στις επιλογές σας. Για επιπλέον υποστήριξη καθώς και διάφορες ερωτήσεις σχετικά με την κάρτα σας, ίσως θέλετε να επικοινωνήσετε με τη λίστα <a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>ηλεκτρονική λίστα του FreeBSD για τα πολυμέσα</a> και να διαβάσετε τις παλιότερες δημοσιεύσεις από τα αρχεία της λίστας.</p></div></div></div><div class=sect2><h3 id=mythtv>14.6. MythTV<a class=anchor href=#mythtv></a></h3><div class=paragraph><p>Το MythTV είναι ένα πρόγραμμα τύπου PVR (Προσωπικός καταγραφέας video).</p></div><div class=paragraph><p>Στον κόσμο του Linux® το MythTV είναι ένα γνωστό πρόγραμμα με πολλές εξαρτήσεις οι οποίες δυσκολεύουν την εγκατάσταση του. Το port του FreeBSD απλοποιεί το μεγαλύτερο μέρος της διαδικασίας αλλά ορισμένα τμήματα του πρέπει να εγκατασταθούν χειροκίνητα. Η ενότητα αυτή περιέχει οδηγίες που θα σας βοηθήσουν να ρυθμίσετε το MythTV.</p></div><div class=sect3><h4 id=_υλικό>14.6.1. Υλικό<a class=anchor href=#_υλικό></a></h4><div class=paragraph><p>Το MythTV έχει σχεδιαστεί να χρησιμοποιεί το V4L για την πρόσβαση σε συσκευές video όπως κωδικοποιητές (encoders) και δέκτες. Τη δεδομένη στιγμή, το MythTV λειτουργεί καλύτερα με κάρτες DVB-S/C/T με διασύνδεση USB που υποστηρίζονται από το <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/webcamd/>multimedia/webcamd</a> καθώς το webcamd παρέχει μια εφαρμογή χρήστη για το V4L. Οποιαδήποτε κάρτα DVB που υποστηρίζεται από το webcamd θα πρέπει φυσιολογικά να λειτουργεί με το MythTV. Μπορείτε ωστόσο να βρείτε <a href=http://wiki.freebsd.org/WebcamCompat>εδώ</a> μια λίστα με δοκιμάσμενες κάρτες. Για κάρτες τις Hauppauge μπορείτε να βρείτε προγράμματα οδήγησης στα πακέτα <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvr250/>multimedia/pvr250</a> και <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvrxxx/>multimedia/pvrxxx</a>, αλλά να έχετε υπόψη σας ότι χρησιμοποιούν μια μη-τυποποιημένη διεπαφή η οποία δεν λειτουργεί με εκδόσεις του MythTV μεταγενέστερες της 0.23.</p></div><div class=paragraph><p>Το <a href=http://wiki.freebsd.org/HTPC>HTPC</a> περιέχει μια λίστα όλων των διαθέσιμων προγραμμάτων οδήγησης DVB.</p></div></div><div class=sect3><h4 id=_εξαρτήσεις>14.6.2. Εξαρτήσεις<a class=anchor href=#_εξαρτήσεις></a></h4><div class=paragraph><p>Καθώς το MythTV είναι ευέλικτο και αρθρωτό, επιτρέπει στο χρήστη να έχει το frontend και το backend σε διαφορετικά μηχανήματα.</p></div><div class=paragraph><p>Για το frontend, απαιτείται το <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv-frontend/>multimedia/mythtv-frontend</a> και ο εξυπηρετητής X τον οποίο μπορείτε να βρείτε στο <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a>. Ιδανικά, ο υπολογιστής που θα εκτελεί το frontend θα πρέπει επίσης να έχει μια κάρτα γραφικών η οποία να υποστηρίζει XvMC και προαιρετικά ένα τηλεχειριστήριο συμβατό με LIRC.</p></div><div class=paragraph><p>Για το backend, χρειάζεται το <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv/>multimedia/mythtv</a> όπως και μια βάση δεδομένων MySQL™ και προαιρετικά ένας δέκτης και αποθηκευτικός χώρος για εγγραφές. Το πακέτο για την MySQL™ θα πρέπει να εγκατασταθεί αυτόματα ως εξάρτηση κατά την εγκατάσταση του <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv/>multimedia/mythtv</a>.</p></div></div><div class=sect3><h4 id=_εγκατάσταση_mythtv>14.6.3. Εγκατάσταση MythTV<a class=anchor href=#_εγκατάσταση_mythtv></a></h4><div class=paragraph><p>Για να εγκαταστήσετε το MythTV, χρησιμοποιήστε τα παρακάτω βήματα. Αρχικά εγκαταστήστε το MythTV από την Συλλογή των Ports του FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mythtv</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>Εγκαταστήστε τη βάση δεδομένων του MythTV:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mysql -uroot -p &lt; /usr/local/shared/mythtv/database/mc.sql</span></code></pre></div></div><div class=paragraph><p>Ρυθμίστε το backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mythtv-setup</span></code></pre></div></div><div class=paragraph><p>Ξεκινήστε το backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;mythbackend_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># /usr/local/etc/rc.d/mythbackend start</span></code></pre></div></div></div></div><div class=sect2><h3 id=scanners>14.7. Σαρωτές Εικόνας<a class=anchor href=#scanners></a></h3><div class=sect3><h4 id=_εισαγωγή_3>14.7.1. Εισαγωγή<a class=anchor href=#_εισαγωγή_3></a></h4><div class=paragraph><p>Στο FreeBSD η πρόσβαση σε σαρωτές παρέχεται από το SANE (Scanner Access Now Easy) API το οποίο διατίθεται μέσα από την συλλογή των Ports του FreeBSD. Το SANE χρησιμοποιεί επίσης κάποιους οδηγούς συσκευών του FreeBSD για να αποκτήσει πρόσβαση στο υλικό του σαρωτή.</p></div><div class=paragraph><p>Το FreeBSD υποστηρίζει σαρωτές SCSI και USB. Βεβαιωθείτε ότι ο σαρωτής σας υποστηρίζεται από το SANE πριν ξεκινήσετε οποιαδήποτε εγκατάσταση και ρύθμιση. Το SANE διαθέτει μια λίστα <a href=http://www.sane-project.org/sane-supported-devices.html>υποστηριζόμενων συσκευών</a> η οποία παρέχει πληροφορίες για την υποστήριξη κάθε σαρωτή και την εξέλιξη της. Σε συστήματα πριν το FreeBSD 8.X θα βρείτε επίσης τη λίστα των υποστηριζόμενων USB σαρωτών στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=uscanner&amp;sektion=4&amp;format=html">uscanner(4)</a>.</p></div></div><div class=sect3><h4 id=_ρύθμιση_του_πυρήνα>14.7.2. Ρύθμιση του Πυρήνα<a class=anchor href=#_ρύθμιση_του_πυρήνα></a></h4><div class=paragraph><p>Όπως είπαμε παραπάνω, υποστηρίζονται σαρωτές τόσο SCSI όσο και USB. Ανάλογα με το τρόπο διασύνδεσης του σαρωτή σας, θα χρειαστείτε διαφορετικούς οδηγούς συσκευών.</p></div><div class=sect4><h5 id=scanners-kernel-usb>14.7.2.1. Διασύνδεση USB<a class=anchor href=#scanners-kernel-usb></a></h5><div class=paragraph><p>Ο πυρήνας <span class=filename>GENERIC</span>, από προεπιλογή, περιέχει τους οδηγούς συσκευών που απαιτούνται για την υποστήριξη σαρωτών USB. Αν αποφασίσετε να χρησιμοποιήσετε εξειδικευμένο πυρήνα, βεβαιωθείτε ότι έχετε τις ακόλουθες γραμμές στο αρχείο ρυθμίσεων σας:</p></div><div class="literalblock programlisting"><div class=content><pre>device usb
device uhci
device ohci
device ehci</pre></div></div><div class=paragraph><p>Σε συστήματα πριν το FreeBSD 8.X, θα χρειαστείτε επίσης την παρακάτω γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>device uscanner</pre></div></div><div class=paragraph><p>Σε αυτές τις εκδόσεις του FreeBSD, η υποστήριξη των σαρωτών USB γίνεται μέσω της συσκευής <a href="https://man.freebsd.org/cgi/man.cgi?query=uscanner&amp;sektion=4&amp;format=html">uscanner(4)</a>. Από το FreeBSD 8.0 και μετά, η υποστήριξη αυτή παρέχεται απευθείας από τη βιβλιοθήκη <a href="https://man.freebsd.org/cgi/man.cgi?query=libusb&amp;sektion=3&amp;format=html">libusb(3)</a>.</p></div><div class=paragraph><p>Αφού επανεκκινήσετε με το σωστό πυρήνα, συνδέστε το USB σαρωτή σας. Θα πρέπει να δείτε μια γραμμή σχετική με την ανίχνευση του σαρωτή στην προσωρινή μνήμη μηνυμάτων του συστήματος (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ugen0.2: &lt;EPSON&gt; at usbus0</code></pre></div></div><div class=paragraph><p>ή σε ένα σύστημα FreeBSD 7.X:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</code></pre></div></div><div class=paragraph><p>Τα μηνύματα αυτά δείχνουν ότι ο σαρωτής μας χρησιμοποιεί την συσκευή <span class=filename>/dev/ugen0.2</span> ή την συσκευή <span class=filename>/dev/uscanner0</span> ανάλογα με την έκδοση του FreeBSD που χρησιμοποιείται. Στο παράδειγμα μας, χρησιμοποιήσαμε ένα σαρωτή EPSON Perfection® 1650 USB.</p></div></div><div class=sect4><h5 id=_διασύνδεση_τύπου_scsi>14.7.2.2. Διασύνδεση Τύπου SCSI<a class=anchor href=#_διασύνδεση_τύπου_scsi></a></h5><div class=paragraph><p>Αν ο σαρωτής σας έρχεται με διασύνδεση τύπου SCSI, είναι σημαντικό να γνωρίζετε τι κάρτα ελεγκτή SCSI θα χρησιμοποιήσετε. Ανάλογα με το ολοκληρωμένο κύκλωμα της κάρτας SCSI που χρησιμοποιείται, θα πρέπει να ρυθμίσετε κατάλληλα το αρχείο ρυθμίσεων πυρήνα. Ο πυρήνας <span class=filename>GENERIC</span> υποστηρίζει τους πιο κοινούς ελεγκτές SCSI. Βεβαιωθείτε ότι διαβάσατε το αρχείο <span class=filename>NOTES</span> και προσθέστε τη σωστή γραμμή στο αρχείο ρυθμίσεων πυρήνα. Εκτός από το πρόγραμμα οδήγησης του ελεγκτή SCSI, θα πρέπει ακόμα να έχετε τις ακόλουθες γραμμές στο αρχείο ρυθμίσεων του πυρήνα σας:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device pass</pre></div></div><div class=paragraph><p>Μόλις μεταγλωττίσετε και εγκαταστήσετε τον πυρήνα, θα μπορέσετε να δείτε τις συσκευές στην προσωρινή μνήμη μηνυμάτων συστήματος, κατά τη διάρκεια της εκκίνησης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</code></pre></div></div><div class=paragraph><p>Αν ο σαρωτής σας δεν ήταν ενεργοποιημένος κατά την εκκίνηση του συστήματος σας, είναι ακόμα δυνατόν να εξαναγκάσετε τον εντοπισμό του, εκτελώντας ανίχνευση του διαύλου SCSI με την βοήθεια της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol rescan all</span>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</code></pre></div></div><div class=paragraph><p>Ο σαρωτής θα εμφανιστεί τότε στη λίστα των συσκευών SCSI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 <span class=o>(</span>pass0,da0<span class=o>)</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 <span class=o>(</span>pass1,da1<span class=o>)</span>
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 <span class=o>(</span>pass3<span class=o>)</span>
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 <span class=o>(</span>pass2,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Περισσότερες πληροφορίες σχετικά με τις συσκευές SCSI είναι διαθέσιμες στις σελίδες manual <a href="https://man.freebsd.org/cgi/man.cgi?query=scsi&amp;sektion=4&amp;format=html">scsi(4)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>.</p></div></div></div><div class=sect3><h4 id=_ρύθμιση_του_sane>14.7.3. Ρύθμιση του SANE<a class=anchor href=#_ρύθμιση_του_sane></a></h4><div class=paragraph><p>Το σύστημα SANE χωρίζεται σε δύο κομμάτια: στο backend (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>) και στο frontend (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a>). Το backend παρέχει πρόσβαση στον ίδιο το σαρωτή. Στη λίστα <a href=http://www.sane-project.org/sane-supported-devices.html>υποστηριζόμενων συσκευών</a> του SANE μπορείτε να βρείτε ποιο backend υποστηρίζει τον σαρωτή σας. Είναι υποχρεωτικό να βρείτε το σωστό backend για να μπορέσετε να χρησιμοποιήσετε το σαρωτή σας. Το τμήμα του frontend παρέχει το γραφικό περιβάλλον εργασίας για τη σάρωση (xscanimage).</p></div><div class=paragraph><p>Το πρώτο βήμα είναι να εγκαταστήσετε το port ή το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>. Μετά χρησιμοποιήστε την εντολή <code>sane-find-scanner</code> για να ελέγξετε την ανίχνευση του σαρωτή σας από το σύστημα SANE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found SCSI scanner <span class=s2>&#34;AGFA SNAPSCAN 600 1.10&#34;</span> at /dev/pass3</code></pre></div></div><div class=paragraph><p>Η έξοδος θα σας δείξει το είδος σύνδεσης του σαρωτή καθώς και το όνομα συσκευής που χρησιμοποιείται για τη σύνδεση με το σύστημα σας. Το όνομα του κατασκευαστή και του μοντέλου ίσως να μην εμφανιστούν, αλλά αυτό δεν είναι σημαντικό.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ορισμένοι USB σαρωτές απαιτούν τη φόρτωση firmware. Η διαδικασία εξηγείται στη σελίδα manual του backend. Θα πρέπει επίσης να διαβάσετε τις σελίδες manual <a href="https://man.freebsd.org/cgi/man.cgi?query=sane-find-scanner&amp;sektion=1&amp;format=html">sane-find-scanner(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=linprocfs&amp;sektion=7&amp;format=html">linprocfs(7)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Πρέπει τώρα να ελέγξουμε αν ο σαρωτής θα αναγνωριστεί από το frontend πρόγραμμα σάρωσης. Από προεπιλογή, το SANE backend έρχεται με ένα εργαλείο γραμμής εντολών, το <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a>. Η εντολή αυτή σας επιτρέπει την απαρίθμηση των συσκευών και τη σάρωσης εικόνας από τη γραμμή εντολών. Η επιλογή <code>-L</code> χρησιμοποιείται για την απαρίθμηση των συσκευών σάρωσης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>snapscan:/dev/pass3<span class=s1>&#39; is a AGFA SNAPSCAN 600 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Ή για παράδειγμα με τον σαρωτή που χρησιμοποιήσαμε στο <a href=#scanners-kernel-usb>Διασύνδεση USB</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=s1>&#39;epson2:libusb:/dev/usb:/dev/ugen0.2&#39;</span> is a Epson GT-8200 flatbed scanner</code></pre></div></div><div class=paragraph><p>Η παραπάνω έξοδος προέρχεται από ένα σύστημα FreeBSD 8.X και η γραμμή <code>'epson2:libusb:/dev/usb:/dev/ugen0.2'</code> μας πληροφορεί για το όνομα του backend (<code>epson2</code>) και το όνομα της συσκευής (<code>/dev/ugen0.2</code>) που χρησιμοποιεί ο σαρωτής μας.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν δεν δείτε έξοδο, ή δείτε ένα μήνυμα ότι δεν ανιχνεύθηκε σαρωτής, σημαίνει ότι το <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a> δεν μπόρεσε να αναγνωρίσει το σαρωτή. Αν συμβεί αυτό, θα χρειαστεί να επεξεργαστείτε το αρχείο ρυθμίσεων του backend και να ορίσετε το σαρωτή που θα χρησιμοποιηθεί. Ο κατάλογος <span class=filename>/usr/local/etc/sane.d/</span> περιέχει όλα τα αρχεία ρυθμίσεων του backend. Το πρόβλημα αναγνώρισης εμφανίζεται σε ορισμένα μοντέλα USB σαρωτών.</p></div><div class=paragraph><p>Για παράδειγμα, με το σαρωτή USB που χρησιμοποιείται στο <a href=#scanners-kernel-usb>Διασύνδεση USB</a>, η εντολή <code>sane-find-scanner</code> δίνει τις ακόλουθες πληροφορίες:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found USB scanner <span class=o>(</span>UNKNOWN vendor and product<span class=o>)</span> at device /dev/uscanner0</code></pre></div></div><div class=paragraph><p>Ο σαρωτής βρέθηκε, χρησιμοποιεί διασύνδεση USB και το όνομα συσκευής του είναι <span class=filename>/dev/uscanner0</span>. Τώρα πρέπει να δούμε αν αναγνωρίζεται και σωστά:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged <span class=k>in</span>, turned on and detected by the
sane-find-scanner tool <span class=o>(</span><span class=k>if </span>appropriate<span class=o>)</span><span class=nb>.</span> Please <span class=nb>read </span>the documentation
which came with this software <span class=o>(</span>README, FAQ, manpages<span class=o>)</span>.</code></pre></div></div><div class=paragraph><p>Αφού ο σαρωτής δεν αναγνωρίστηκε, θα χρειαστεί να επεξεργαστούμε το αρχείο <span class=filename>/usr/local/etc/sane.d/epson2.conf</span>. Το μοντέλο σαρωτή που χρησιμοποιήθηκε ήταν το EPSON Perfection® 1650, έτσι ξέρουμε ότι ο σαρωτής θα χρησιμοποιεί το backend <code>epson2</code>. Βεβαιωθείτε ότι διαβάσατε τα βοηθητικά σχόλια στα αρχεία ρυθμίσεων του backend. Είναι αρκετά απλό να αλλάξετε γραμμές: Μετατρέψτε σε σχόλια όσες γραμμές δείχνουν λάθος τύπο διασύνδεσης για το σαρωτή σας (στην περίπτωση μας θα μετατρέψουμε σε σχόλια όλες τις γραμμές που ξεκινάνε με τη λέξη <code>scsi</code> καθώς ο σαρωτής μας χρησιμοποιεί διασύνδεση USB), και προσθέστε στο τέλος του αρχείου μια γραμμή που να ορίζει το είδος διασύνδεσης και το όνομα συσκευής που χρησιμοποιείτε. Στην περίπτωση μας προσθέσαμε την ακόλουθη γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>usb /dev/uscanner0</pre></div></div><div class=paragraph><p>Σας παρακαλούμε να βεβαιωθείτε ότι διαβάσατε τα σχόλια που παρέχονται στο αρχείο ρυθμίσεων του backend καθώς και στις αντίστοιχες σελίδες manual για περισσότερες λεπτομέρειες καθώς και για τη σύνταξη που πρέπει να χρησιμοποιήσετε. Μπορούμε τώρα να επιβεβαιώσουμε ότι ο σαρωτής αναγνωρίζεται:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>epson:/dev/uscanner0<span class=s1>&#39; is a Epson GT-8200 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Ο USB σαρωτής μας αναγνωρίστηκε. Δεν είναι σημαντικό ότι η μάρκα και το μοντέλο δεν ταιριάζουν ακριβώς με το δικό μας. Το βασικό σημείο είναι το πεδίο <code>epson:/dev/uscanner0'</code>, το οποίο δείχνει το σωστό backend και όνομα συσκευής.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μόλις η εντολή <code>scanimage -L</code> μπορέσει να δει το σαρωτή, η ρύθμιση έχει ολοκληρωθεί. Η συσκευή είναι έτοιμη να χρησιμοποιηθεί.</p></div><div class=paragraph><p>Αν και η <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a> μας επιτρέπει να σαρώσουμε εικόνα από τη γραμμή εντολών, είναι προτιμότερο να χρησιμοποιήσουμε κάποιο πρόγραμμα σε γραφικό περιβάλλον για την εργασία αυτή. Το SANE μας προσφέρει ένα απλό αλλά αποδοτικό γραφικό περιβάλλον: το xscanimage (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a>).</p></div><div class=paragraph><p>Το Xsane (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a>) είναι επίσης ένα δημοφιλές frontend πρόγραμμα σάρωσης. To frontend αυτό προσφέρει προχωρημένες δυνατότητες, όπως διαφορετικούς τρόπους σάρωσης (φωτοτυπία, fax, κλπ) διόρθωση χρωμάτων, πολλαπλή σάρωση κ.α. Και οι δύο αυτές εφαρμογές διατίθενται επίσης σαν πρόσθετο (plugin) πρόγραμμα για χρήση με το GIMP.</p></div></div><div class=sect3><h4 id=_δίνοντας_σε_άλλους_χρήστες_πρόσβαση_στο_σαρωτή_σας>14.7.4. Δίνοντας σε Άλλους Χρήστες Πρόσβαση στο Σαρωτή σας<a class=anchor href=#_δίνοντας_σε_άλλους_χρήστες_πρόσβαση_στο_σαρωτή_σας></a></h4><div class=paragraph><p>Όλες οι παραπάνω λειτουργίες έγιναν με τα προνόμια του χρήστη <code>root</code>. Μπορεί ωστόσο, να θέλετε να δώσετε πρόσβαση στο σαρωτή σας και σε άλλους χρήστες. Ο χρήστης χρειάζεται άδεια ανάγνωσης και εγγραφής στο αρχείο συσκευής που χρησιμοποιείται από το σαρωτή. Σαν παράδειγμα, ο σαρωτής μας χρησιμοποιεί το αρχείο συσκευής <span class=filename>/dev/ugen0.2</span> το οποίο στην πραγματικότητα είναι ένας συμβολικός δεσμός προς το πραγματικό αρχείο συσκευής, το <span class=filename>/dev/usb/0.2.0</span> (μπορείτε να το επιβεβαιώσετε εύκολα με μια ματιά στον κατάλογο <span class=filename>/dev</span>). Τόσο ο συμβολικός δεσμός όσο και το αρχείο συσκευής ανήκουν στις ομάδες <code>wheel</code> και <code>operator</code>. Αν προσθέσουμε το χρήστη <code><em>joe</em></code> σε αυτές τις ομάδες, θα μπορεί να χρησιμοποιήσει το σαρωτή. Για λόγους ασφαλείας όμως θα πρέπει να είμαστε ιδιαίτερα προσεκτικοί όταν προσθέτουμε ένα χρήστη σε μια ομάδα, ειδικά αν πρόκειται για την <code>wheel</code>. Μια καλύτερη λύση θα ήταν να δημιουργήσουμε μια ομάδα ειδικά για τη χρήση των συσκευών USB, και να επιτρέψουμε πρόσβαση στον σαρωτή στα μέλη της ομάδας αυτής.</p></div><div class=paragraph><p>Για παράδειγμα, θα χρησιμοποιήσουμε μια ομάδα με το όνομα <code><em>usb</em></code>. Το πρώτο βήμα είναι η δημιουργία αυτής της ομάδας με τη βοήθεια της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd usb</span></code></pre></div></div><div class=paragraph><p>Θα πρέπει έπειτα να αλλάξουμε τα δικαιώματα του συμβολικού δεσμού <span class=filename>/dev/ugen0.2</span> και του αρχείου συσκευής <span class=filename>/dev/ugen0.2.0</span> ώστε να είναι προσβάσιμα από την ομάδα <code>usb</code> με δυνατότητα εγγραφής (δικαιώματα <code>0660</code> ή <code>0664</code>). Από προεπιλογή, μόνο ο ιδιοκτήτης αυτών των αρχείων (ο <code>root</code>) έχει τα απαραίτητα δικαιώματα εγγραφής. Όλα τα παραπάνω μπορούν να γίνουν με τις παρακάτω γραμμές στο αρχείο <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path ugen0.2 mode 660 group usb
add path usb/0.2.0 mode 0660 group usb</pre></div></div><div class=paragraph><p>Οι χρήστες του FreeBSD 7.X θα χρειαστούν τις παρακάτω γραμμές, με το σωστό αρχείο συσκευής (τις περισσότερες φορές θα είναι το <span class=filename>/dev/uscanner0</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path uscanner0 mode 0660 group usb</pre></div></div><div class=paragraph><p>Έπειτα, προσθέστε την ακόλουθη γραμμή στο αρχείο <span class=filename>/etc/rc.conf</span> και επανεκκινήστε το μηχάνημα:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Περισσότερες πληροφορίες σχετικά με αυτές τις γραμμές, μπορείτε να βρείτε στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>.</p></div><div class=paragraph><p>Έπειτα από τα παραπάνω βήματα, για να δώσετε πρόσβαση στο USB σαρωτή σε κάποιο χρήστη, αρκεί να προσθέσετε το λογαριασμό του στην ομάδα <code><em>usb</em></code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod usb -m joe</span></code></pre></div></div><div class=paragraph><p>Για περισσότερες λεπτομέρειες, διαβάστε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=kernelconfig>Chapter 15. Ρυθμίζοντας τον Πυρήνα του FreeBSD<a class=anchor href=#kernelconfig></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelconfig-synopsis>15.1. Σύνοψη<a class=anchor href=#kernelconfig-synopsis></a></h3><div class=paragraph><p>Ο πυρήνας είναι η καρδιά του λειτουργικού συστήματος FreeBSD. Είναι υπεύθυνος για τη διαχείριση της μνήμης, την επιβολή των ρυθμίσεων ασφαλείας, τη δικτύωση, την πρόσβαση στο δίσκο, και πολλά άλλα. Ένα συνεχώς αυξανόμενο μέρος του FreeBSD μπορεί να ρυθμιστεί δυναμικά, αλλά υπάρχουν ακόμα περιπτώσεις οι οποίες απαιτούν ρυθμίσεις και μεταγλώττιση του πυρήνα του FreeBSD με προσαρμοσμένες παραμέτρους.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Για ποιους λόγους μπορεί να χρειαστεί να φτιάξετε ένα προσαρμοσμένο πυρήνα.</p></li><li><p>Πως να γράψετε ένα αρχείο ρυθμίσεων πυρήνα, ή να αλλάξετε ένα υπάρχον αρχείο ρυθμίσεων.</p></li><li><p>Πως να χρησιμοποιήσετε το αρχείο ρυθμίσεων του πυρήνα για να φτιάξετε και να μεταγλωττίσετε ένα νέο πυρήνα.</p></li><li><p>Πως να εγκαταστήσετε το νέο πυρήνα.</p></li><li><p>Πως να επιλύσετε τυχόν προβλήματα με το νέο πυρήνα.</p></li></ul></div><div class=paragraph><p>Όλες οι εντολές που εμφανίζονται σε αυτό το κεφάλαιο ως παραδείγματα πρέπει να εκτελεστούν ως <code>root</code> για να είναι επιτυχείς.</p></div></div><div class=sect2><h3 id=kernelconfig-custom-kernel>15.2. Γιατί να Φτιάξετε Προσαρμοσμένο Πυρήνα;<a class=anchor href=#kernelconfig-custom-kernel></a></h3><div class=paragraph><p>Κατά παράδοση, το FreeBSD είχε αυτό που αποκαλούμε "μονολιθικό" πυρήνα. Αυτό σημαίνει ότι ο πυρήνας ήταν ένα μεγάλο πρόγραμμα, υποστήριζε ένα σταθερό αριθμό συσκευών, και αν θέλατε να αλλάξετε τη συμπεριφορά του, θα έπρεπε να μεταγλωττίσετε καινούριο και να επανεκκινήσετε τον υπολογιστή σας με αυτόν.</p></div><div class=paragraph><p>Σήμερα, το FreeBSD κινείται ταχύτατα προς ένα μοντέλο όπου οι περισσότερες λειτουργίες του πυρήνα περιέχονται σε modules (αρθρώματα) τα οποία μπορούν να φορτωθούν και να αποφορτωθούν κατά απαίτηση, δυναμικά στον πυρήνα. Αυτό επιτρέπει στον πυρήνα να προσαρμόζεται σε υλικό το οποίο ενεργοποιείται τη δεδομένη στιγμή (όπως για παράδειγμα όταν εισέρχεται μια κάρτα PCMCIA σε ένα φορητό υπολογιστή). Επίσης επιτρέπει στον πυρήνα να επεκτείνει δυναμικά τη λειτουργικότητά του, προσθέτοντας χαρακτηριστικά τα οποία δεν ήταν απαραίτητα όταν είχε μεταγλωττιστεί αρχικά. Αυτού του είδους ο πυρήνας είναι γνωστός ως modular (αρθρωτός).</p></div><div class=paragraph><p>Παρ' όλα αυτά, είναι ακόμα απαραίτητο να γίνουν κάποιες στατικές ρυθμίσεις στον πυρήνα. Σε ορισμένες περιπτώσεις, αυτό συμβαίνει επειδή η συγκεκριμένη λειτουργία είναι τόσο στενά συνδεμένη με τον πυρήνα ώστε δεν μπορεί να φορτωθεί δυναμικά. Σε άλλες, συμβαίνει επειδή απλά κανείς δεν έχει ακόμα ασχοληθεί να γράψει ένα δυναμικό module που να παρέχει αυτή τη λειτουργικότητα.</p></div><div class=paragraph><p>Η δημιουργία προσαρμοσμένου πυρήνα είναι από τις πλέον σημαντικές τελετουργίες κάθε προχωρημένου χρήστη του BSD. Η διαδικασία αυτή, αν και χρονοβόρα, θα αποβεί ιδιαίτερα ωφέλιμη για το FreeBSD σύστημα σας. Σε αντίθεση με τον πυρήνα <span class=filename>GENERIC</span>, ο οποίος πρέπει να υποστηρίξει μεγάλο εύρος συσκευών, ένας προσαρμοσμένος πυρήνας περιέχει υποστήριξη μόνο για το υλικό του <em>δικού σας</em> υπολογιστή. Έτσι έχετε κάποια οφέλη, όπως:</p></div><div class=ulist><ul><li><p>Ταχύτερη εκκίνηση. Καθώς ο πυρήνας θα ανιχνεύει μόνο το υλικό που έχετε στο σύστημα σας, ο χρόνος που χρειάζεται για την εκκίνηση του συστήματος σας θα μειωθεί δραματικά.</p></li><li><p>Χαμηλότερη κατανάλωση μνήμης. Ένας προσαρμοσμένος πυρήνας, συχνά χρησιμοποιεί λιγότερη μνήμη από τον πυρήνα <span class=filename>GENERIC</span>, αφού απουσιάζουν από αυτόν συσκευές και χαρακτηριστικά που δεν χρησιμοποιούνται. Αυτό είναι σημαντικό, καθώς ο πυρήνας βρίσκεται πάντα φορτωμένος στη φυσική μνήμη, μειώνοντας έτσι τη μνήμη που είναι διαθέσιμη για εφαρμογές. Για το λόγο αυτό, ο προσαρμοσμένος πυρήνας είναι ιδιαίτερα χρήσιμος σε συστήματα με μικρό μέγεθος φυσικής μνήμης (RAM).</p></li><li><p>Επιπρόσθετη υποστήριξη συσκευών. Ο προσαρμοσμένος πυρήνας σας επιτρέπει να προσθέσετε υποστήριξη για συσκευές οι οποίες δεν υπάρχουν στον <span class=filename>GENERIC</span> πυρήνα, όπως για παράδειγμα για κάρτες ήχου.</p></li></ul></div></div><div class=sect2><h3 id=kernelconfig-devices>15.3. Ανακαλύπτοντας τις Συσκευές του Συστήματος σας<a class=anchor href=#kernelconfig-devices></a></h3><div class=paragraph><p>Πριν ξεκινήσετε με τη ρύθμιση του πυρήνα σας, θα ήταν σκόπιμο να κάνετε μια απογραφή υλικού του υπολογιστή σας. Σε περιπτώσεις που το FreeBSD δεν είναι το βασικό σας λειτουργικό σύστημα, μπορείτε εύκολα να δημιουργήσετε αυτή τη λίστα, εξετάζοντας τις ρυθμίσεις του τρέχοντος λειτουργικού συστήματος. Για παράδειγμα, η Διαχείριση Συσκευών (Device Manager) της Microsoft® δείχνει συνήθως σημαντικές πληροφορίες σχετικά με τις εγκατεστημένες συσκευές. Μπορείτε να βρείτε την Διαχείριση Συσκευών στον πίνακα ελέγχου.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μερικές εκδόσεις των Microsoft® Windows® διαθέτουν ένα εικονίδιο με τίτλο Σύστημα (System). Από την οθόνη που εμφανίζεται μπορείτε να επιλέξετε την Διαχείριση Συσκευών.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν δεν υπάρχει άλλο λειτουργικό σύστημα στον υπολογιστή, ο διαχειριστής θα πρέπει να βρει αυτές τις πληροφορίες χειροκίνητα. Μια μέθοδος είναι με τη χρήση του βοηθητικού προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> και της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a>. Τα περισσότερα προγράμματα οδήγησης του FreeBSD διαθέτουν σελίδα manual, η οποία δείχνει το υποστηριζόμενο υλικό. Κατά τη διάρκεια της εκκίνησης, εμφανίζεται μια λίστα με τις συσκευές που ανιχνεύθηκαν. Για παράδειγμα, οι παρακάτω γραμμές δείχνουν ότι το πρόγραμμα οδήγησης <span class=filename>psm</span> εντόπισε ένα ποντίκι:</p></div><div class="literalblock programlisting"><div class=content><pre>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: [GIANT-LOCKED]
psm0: [ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</pre></div></div><div class=paragraph><p>Αυτό το πρόγραμμα οδήγησης θα πρέπει να περιληφθεί στο αρχείο ρυθμίσεων του προσαρμοσμένου πυρήνα σας, ή να φορτωθεί δυναμικά μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>.</p></div><div class=paragraph><p>Σε ορισμένες περιπτώσεις, η έξοδος της <code>dmesg</code> μπορεί να δείχνει μόνο τα μηνύματα του συστήματος και όχι τα αποτελέσματα της ανίχνευσης συσκευών. Στις περιπτώσεις αυτές, μπορείτε να δείτε την επιθυμητή έξοδο στα περιεχόμενα του αρχείου <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class=paragraph><p>Μια άλλη μέθοδος για την ανίχνευση του υλικού, είναι μέσω του βοηθητικού προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a>, το οποίο παρέχει πιο αναλυτική περιγραφή. Για παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre>ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
vendor     = &#39;Atheros Communications Inc.&#39;
device     = &#39;AR5212 Atheros AR5212 802.11abg wireless&#39;
class      = network
subclass   = ethernet</pre></div></div><div class=paragraph><p>Η παραπάνω έξοδος, που λήφθηκε μέσω της εντολής <code>pciconf -lv</code>, δείχνει ότι το πρόγραμμα οδήγησης <span class=filename>ath</span> εντόπισε μια συσκευή ασύρματου Ethernet. Μπορείτε να δείτε την αντίστοιχη σελίδα manual του προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>, χρησιμοποιώντας την εντολή <code>man ath</code>.</p></div><div class=paragraph><p>Μπορείτε επίσης να πάρετε χρήσιμες πληροφορίες από την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a>, αν δώσετε την επιλογή <code>-k</code>. Στο παραπάνω παράδειγμα, δίνοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>....<span class=sb>`</span>Atheros<span class=sb>`</span>
....</code></pre></div></div><div class=paragraph><p>Θα δείτε μια λίστα από σελίδες manual που περιέχουν τη συγκεκριμένη λέξη:</p></div><div class="literalblock programlisting"><div class=content><pre>ath(4)                   - Atheros IEEE 802.11 wireless network driver
ath_hal(4)               - Atheros Hardware Access Layer (HAL)</pre></div></div><div class=paragraph><p>Έχοντας διαθέσιμη την απογραφή υλικού του υπολογιστή σας, η διαδικασία δημιουργίας προσαρμοσμένου πυρήνα σίγουρα φαίνεται λιγότερο αποθαρρυντική.</p></div></div><div class=sect2><h3 id=kernelconfig-modules>15.4. Προγράμματα Οδήγησης, Υποσυστήματα και Αρθρώματα (modules)<a class=anchor href=#kernelconfig-modules></a></h3><div class=paragraph><p>Πριν δημιουργήσετε ένα προσαρμοσμένο πυρήνα, θα πρέπει πρώτα να σκεφτείτε για ποιους λόγους τον χρειάζεστε. Σε πολλές περιπτώσεις, η υποστήριξη κάποιας συγκεκριμένης συσκευής μπορεί να επιτευχθεί με την χρήση κάποιου αρθρώματος (module).</p></div><div class=paragraph><p>Τα αρθρώματα του πυρήνα βρίσκονται στον κατάλογο <span class=filename>/boot/kernel/</span> και μπορούν να φορτωθούν δυναμικά στον πυρήνα που εκτελείται τη δεδομένη στιγμή, με τη χρήση της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Τα περισσότερα, αν και όχι όλα, τα προγράμματα οδήγησης στον πυρήνα, διατίθενται και σε μορφή αρθρώματος· έχουν επίσης τη δική του σελίδα βοήθειας το καθένα. Για παράδειγμα, στην προηγούμενη ενότητα, είδαμε το πρόγραμμα οδήγησης ασύρματου Ethernet <span class=filename>ath</span>. Η σελίδα βοήθειας για αυτή τη συσκευή αναφέρει:</p></div><div class="literalblock programlisting"><div class=content><pre>Alternatively, to load the driver as a module at boot time, place the
following line in man:loader.conf[5]:

      if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Όπως αναφέρεται στις οδηγίες, αν βάλετε την γραμμή <code>if_ath_load="YES"</code> στο αρχείο <span class=filename>/boot/loader.conf</span>, το άρθρωμα θα φορτωθεί δυναμικά κατά την εκκίνηση του συστήματος σας.</p></div><div class=paragraph><p>Σε μερικές περιπτώσεις ωστόσο, δεν υπάρχει άρθρωμα που να σχετίζεται με κάποιο πρόγραμμα οδήγησης. Αυτό ισχύει περισσότερο για κάποια ιδιαίτερα υποσυστήματα και πολύ σημαντικά προγράμματα οδήγησης. Για παράδειγμα, το πρόγραμμα οδήγησης του συστήματος αρχείων fast file system (FFS) απαιτείται να είναι ενσωματωμένο στον πυρήνα. Το ίδιο συμβαίνει και με την υποστήριξη δικτύου (INET). Δυστυχώς, ο μόνος τρόπος για να δείτε αν ένα πρόγραμμα οδήγησης πρέπει να είναι υποχρεωτικά ενσωματωμένο στον πυρήνα, είναι να ελέγξετε αν υπάρχει το αντίστοιχο άρθρωμα.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Είναι αρκετά εύκολο να αφαιρέσετε την υποστήριξη για κάποια συσκευή ή άλλη επιλογή, και να καταλήξετε με ένα πυρήνα που δεν μπορεί να ξεκινήσει. Για παράδειγμα, αν βγάλετε το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> από το αρχείο ρυθμίσεων του πυρήνα σας, αν το σύστημα σας χρησιμοποιεί δίσκους ATA δεν θα μπορεί να ξεκινήσει. Στην περίπτωση αυτή θα πρέπει να βάλετε την αντίστοιχη γραμμή στο αρχείο <span class=filename>loader.conf</span> για να φορτώσετε το σχετικό άρθρωμα. Αν δεν είστε σίγουροι, ελέγξτε για την ύπαρξη του αρθρώματος και απλώς αφήστε την υποστήριξη ενσωματωμένη στον πυρήνα.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-building>15.5. Δημιουργία και Εγκατάσταση Προσαρμοσμένου Πυρήνα<a class=anchor href=#kernelconfig-building></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Χρειάζεται να έχετε εγκαταστήσει όλο τον πηγαίο κώδικα του FreeBSD για να μεταγλωττίσετε τον πυρήνα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αρχικά, θα κάνουμε μια γρήγορη παρουσίαση του καταλόγου στον οποίο γίνεται η μεταγλώττιση του πυρήνα. Όλοι οι κατάλογοι που θα αναφέρουμε βρίσκονται κάτω από τον κατάλογο <span class=filename>/usr/src/sys</span> ο οποίος είναι επίσης προσβάσιμος μέσω της διαδρομής <span class=filename>/sys</span>. Υπάρχει εδώ ένας αριθμός υποκαταλόγων ο οποίος αντιπροσωπεύει διαφορετικά τμήματα του πυρήνα, αλλά οι πλέον σημαντικοί για το σκοπό μας είναι οι <span class=filename>arch/conf</span>, όπου θα επεξεργαστείτε τις ρυθμίσεις για τον προσαρμοσμένο πυρήνα σας, και ο <span class=filename>compile</span>, που είναι ο χώρος εργασίας στον οποίο θα γίνει η μεταγλώττιση του. Ο <em>arch</em> αντιπροσωπεύει ένα από τα <span class=filename>i386</span>, <span class=filename>amd64</span>, <span class=filename>ia64</span>, <span class=filename>powerpc</span>, <span class=filename>sparc64</span>, ή <span class=filename>pc98</span> (ένας εναλλακτικός τύπος PC, διαδεδομένος στην Ιαπωνία). Οτιδήποτε βρίσκεται μέσα στον συγκεκριμένο κατάλογο μιας αρχιτεκτονικής, σχετίζεται μόνο με την αρχιτεκτονική αυτή. Το υπόλοιπο του κώδικα, είναι ανεξάρτητο από την αρχιτεκτονική και κοινό σε κάθε πλατφόρμα όπου θα μπορούσε να μεταγλωττιστεί το FreeBSD. Παρατηρήστε τη λογική οργάνωση της δομής των καταλόγων, όπου κάθε υποστηριζόμενη συσκευή, σύστημα αρχείων και επιλογή βρίσκεται στο δικό της κατάλογο.</p></div><div class=paragraph><p>Στα παραδείγματα αυτού του κεφαλαίου υποθέτουμε ότι χρησιμοποιείτε την αρχιτεκτονική i386. Αν χρησιμοποιείτε διαφορετική αρχιτεκτονική, θα χρειαστεί να αλλάξετε τα ονόματα των καταλόγων και διαδρομών ώστε να συμβαδίζουν με αυτή.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν δεν υπάρχει ο κατάλογος <span class=filename>/usr/src/</span> στο σύστημα σας (ή αν είναι άδειος), τότε δεν έχετε εγκαταστήσει τον πηγαίο κώδικα. Ο ευκολότερος τρόπος για να εγκαταστήσετε τον πλήρη πηγαίο κώδικα, είναι να μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> όπως περιγράφεται στο <a href=./#synching>Συγχρονίζοντας τον Πηγαίο σας Κώδικα</a>. Θα πρέπει επίσης να δημιουργήσετε ένα συμβολικό δεσμό προς τον κατάλογο <span class=filename>/usr/src/sys/</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /usr/src/sys /sys</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Έπειτα, μετακινηθείτε στον κατάλογο <span class=filename>arch/conf</span> και αντιγράψτε το αρχείο ρυθμίσεων <span class=filename>GENERIC</span> στο όνομα το οποίο θέλετε να δώσετε στο νέο σας πυρήνα. Για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf</span>
<span class=c># cp GENERIC MYKERNEL</span></code></pre></div></div><div class=paragraph><p>Κατά παράδοση, το όνομα αυτό γράφεται εξ' ολοκλήρου με κεφαλαία γράμματα και αν έχετε πολλά μηχανήματα FreeBSD με διαφορετικό υλικό, είναι καλή ιδέα να του δώσετε το όνομα του μηχανήματος. Για το παράδειγμα μας, θα το αποκαλούμε <span class=filename>MYKERNEL</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Δεν είναι γενικά καλή ιδέα να αποθηκεύσετε το αρχείο ρυθμίσεων σας απευθείας στον κατάλογο <span class=filename>/usr/src</span>. Αν αντιμετωπίσετε προβλήματα, ίσως μπείτε στον πειρασμό να διαγράψετε απλώς τον κατάλογο <span class=filename>/usr/src</span> και να ξεκινήσετε από την αρχή. Συνήθως λίγα δευτερόλεπτα μετά από αυτό θα συνειδητοποιήσετε ότι έχετε επίσης διαγράψει το αρχείο ρυθμίσεων του πυρήνα σας. Επίσης, μην επεξεργάζεστε απευθείας το αρχείο <span class=filename>GENERIC</span>, καθώς μπορεί οι αλλαγές σας να χαθούν την επόμενη φορά που θα <a href=./#updating-upgrading>ανανεώσετε τον πηγαίο σας κώδικα</a>.</p></div><div class=paragraph><p>Καλό θα είναι να αποθηκεύσετε το αρχείο ρυθμίσεων σε άλλο κατάλογο και να δημιουργήσετε ένα συμβολικό δεσμό προς το αρχείο, στον κατάλογο <span class=filename>i386</span>.</p></div><div class=paragraph><p>Για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf</span>
<span class=c># mkdir /root/kernels</span>
<span class=c># cp GENERIC /root/kernels/MYKERNEL</span>
<span class=c># ln -s /root/kernels/MYKERNEL</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Τώρα, τροποποιήστε το αρχείο <span class=filename>MYKERNEL</span> με τον επεξεργαστή κειμένου που προτιμάτε. Αν ξεκινάτε μόλις τώρα, πιθανόν ο μόνος διαθέσιμος επεξεργαστής κειμένου να είναι το vi, ο οποίος είναι αρκετά πολύπλοκος για να τον εξηγήσουμε εδώ, αλλά καλύπτεται αρκετά καλά από πλήθος βιβλίων στην <a href=./#bibliography>βιβλιογραφία</a>. Ωστόσο, το FreeBSD διαθέτει επίσης ένα ευκολότερο επεξεργαστή κειμένου, τον ee ο οποίος είναι η κατάλληλη επιλογή αν είστε αρχάριος. Αλλάξτε κατά βούληση τα σχόλια στην αρχή του αρχείου ρυθμίσεων ώστε να αντανακλούν τις αλλαγές που έχετε κάνει και οι οποίες το διαχωρίζουν από το <span class=filename>GENERIC</span>.</p></div><div class=paragraph><p>Αν έχετε δημιουργήσει πυρήνα στο SunOS™ ή σε κάποιο άλλο λειτουργικό σύστημα τύπου BSD, το μεγαλύτερο μέρος αυτού του αρχείου θα σας φανεί γνωστό. Από την άλλη, αν έρχεστε από κάποιο άλλο λειτουργικό, όπως το DOS το αρχείο ρυθμίσεων <span class=filename>GENERIC</span> ίσως να σας είναι δύσκολο στην κατανόηση, για το λόγο αυτό ακολουθήστε αργά και προσεκτικά τις περιγραφές του τμήματος <a href=./#kernelconfig-config>Αρχείο Ρυθμίσεων</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν <a href=./#updating-upgrading>συγχρονίσετε τον πηγαίο κώδικα</a> με τις τελευταίες αλλαγές του FreeBSD project, να διαβάσετε το αρχείο <span class=filename>/usr/src/UPDATING</span> πριν προχωρήσετε σε οποιοδήποτε βήμα αναβάθμισης. Το αρχείο αυτό περιγράφει πιθανά σημαντικά προβλήματα ή περιοχές που χρειάζονται ιδιαίτερη προσοχή όσο αφορά τον ανανεωμένο πηγαίο κώδικα. Το αρχείο <span class=filename>/usr/src/UPDATING</span> ταιριάζει πάντα με την έκδοση του πηγαίου κώδικα του FreeBSD που έχετε, και είναι για αυτό το λόγο πιο ενημερωμένο σε σχέση με ότι διαβάσετε στο παρόν βιβλίο.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Θα πρέπει τώρα να μεταγλωττίσετε τον πηγαίο κώδικα του πυρήνα.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Μεταγλώττιση του Πυρήνα</strong></p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Χρειάζεται να έχετε εγκαταστήσει όλο τον πηγαίο κώδικα του FreeBSD για να μεταγλωττίσετε τον πυρήνα.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>Μετακινηθείτε στον κατάλογο <span class=filename>/usr/src</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>Μεταγλωττίστε τον πυρήνα:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>Εγκαταστήστε το νέο πυρήνα:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li></ol></div></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Από προεπιλογή, όταν δημιουργείτε ένα προσαρμοσμένο πυρήνα, δημιουργούνται επίσης και <em>όλα</em> τα modules (αρθρώματα) πυρήνα. Αν θέλετε να κάνετε πιο γρήγορη ανανέωση του πυρήνα ή να δημιουργήσετε μόνο συγκεκριμένα modules, θα πρέπει να τροποποιήσετε το αρχείο <span class=filename>/etc/make.conf</span> πριν ξεκινήσετε τη δημιουργία του πυρήνα:</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</pre></div></div><div class=paragraph><p>Στη μεταβλητή αυτή δίνετε μια λίστα των modules που θέλετε να δημιουργηθούν, αντί να δημιουργηθούν όλα.</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_MODULES = linux acpi sound ntfs</pre></div></div><div class=paragraph><p>Στη μεταβλητή αυτή δίνετε μια λίστα βασικών (top level) modules που θέλετε να παραλείψετε κατά τη διαδικασία δημιουργίας. Για άλλες μεταβλητές που ίσως είναι χρήσιμες στη διαδικασία δημιουργίας πυρήνα, δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ο νέος πυρήνας θα αντιγραφεί στον κατάλογο <span class=filename>/boot/kernel</span> με το όνομα <span class=filename>/boot/kernel/kernel</span> ενώ ο παλιός πυρήνας θα μετακινηθεί στο <span class=filename>/boot/kernel.old/kernel</span>. Τερματίστε τώρα το σύστημα σας και επανεκκινήστε για να χρησιμοποιήσετε το νέο πυρήνα. Αν κάτι πάει στραβά, υπάρχουν κάποιες πληροφορίες για <a href=./#kernelconfig-trouble>Αντιμετώπιση Προβλημάτων</a> που ίσως σας φανούν χρήσιμες, στο τέλος αυτού του κεφαλαίου. Βεβαιωθείτε ότι διαβάσατε το τμήμα που εξηγεί πως να επαναφέρετε το σύστημα σας σε περίπτωση που ο νέος πυρήνας <a href=./#kernelconfig-noboot>δεν εκκινεί</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Άλλα αρχεία που σχετίζονται με τη διαδικασία εκκίνησης, όπως ο <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> και οι ρυθμίσεις του, βρίσκονται στον κατάλογο <span class=filename>/boot</span>. Εξειδικευμένα modules ή modules τρίτων κατασκευαστών μπορούν να τοποθετηθούν στον κατάλογο <span class=filename>/boot/kernel</span>, αν και οι χρήστες θα πρέπει να γνωρίζουν ότι είναι σημαντικό τα modules να είναι σε συγχρονισμό με τον πυρήνα. Modules τα οποία δεν προορίζονται για εκτέλεση με τον τρέχοντα πυρήνα, μπορούν να προκαλέσουν αστάθεια ή εσφαλμένη λειτουργία του συστήματος σας.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-config>15.6. Το Αρχείο Ρυθμίσεων<a class=anchor href=#kernelconfig-config></a></h3><div class=paragraph><p>Η γενική μορφή ενός αρχείου ρυθμίσεων πυρήνα, είναι αρκετά απλή. Κάθε γραμμή περιέχει μια λέξη-κλειδί και ένα ή περισσότερα ορίσματα. Για λόγους απλότητας, οι περισσότερες γραμμές περιέχουν μόνο ένα όρισμα. Οτιδήποτε βρίσκεται μετά το σύμβολο <code>#</code> θεωρείται σχόλιο και αγνοείται. Στα επόμενα τμήματα θα βρείτε περιγραφή για τις λέξεις-κλειδιά, με τη σειρά που εμφανίζονται στο αρχείο ρυθμίσεων <span class=filename>GENERIC</span>. <a id=kernelconfig-options></a>Για εξαντλητική λίστα των παραμέτρων και συσκευών που εξαρτώνται από την αρχιτεκτονική, δείτε το αρχείο <span class=filename>NOTES</span> το οποίο βρίσκεται στον ίδιο κατάλογο με το αρχείο <span class=filename>GENERIC</span>. Για επιλογές και ρυθμίσεις που είναι ανεξάρτητες από την αρχιτεκτονική, δείτε το αρχείο <span class=filename>/usr/src/sys/conf/NOTES</span>.</p></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε την οδηγία <code>include</code> στα αρχεία ρυθμίσεων. Η οδηγία αυτή επιτρέπει την λογική συμπερίληψη ενός άλλου αρχείου ρυθμίσεων μέσα στο τρέχον, κάνοντας πιο εύκολη τη συντήρηση του όταν οι αλλαγές που χρειάζονται είναι λίγες σε σχέση με το αρχικό αρχείο. Για παράδειγμα, αν χρειάζεστε ένα πυρήνα <span class=filename>GENERIC</span> με λίγες μόνο παραπάνω επιλογές ή προγράμματα οδήγησης, μπορείτε να δημιουργήσετε ένα μικρό αρχείο διαφορών σε σχέση με τον <span class=filename>GENERIC</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT</pre></div></div><div class=paragraph><p>Πολλοί διαχειριστές βρίσκουν ότι αυτό το μοντέλο προσφέρει σημαντικά πλεονεκτήματα σε σχέση με τον παραδοσιακό τρόπο συγγραφής αρχείων ρυθμίσεων από το μηδέν: το τοπικό αρχείο ρυθμίσεων περιέχει μόνο τις διαφορές από ένα πυρήνα <span class=filename>GENERIC</span>. Καθώς γίνονται αναβαθμίσεις στο σύστημα, τα νέα χαρακτηριστικά και δυνατότητες που προστίθενται στον <span class=filename>GENERIC</span> θα προστεθούν και στον προσαρμοσμένο πυρήνα, εκτός αν το αποτρέψετε χρησιμοποιώντας το <code>nooptions</code> ή το <code>nodevice</code>. Το υπόλοιπο αυτού του κεφαλαίου, εξηγεί το περιεχόμενο ενός τυπικού αρχείου ρυθμίσεων και το ρόλο που έχουν οι διάφορες επιλογές και τα προγράμματα οδήγησης που εμφανίζονται σε αυτό.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Για να δημιουργήσετε ένα αρχείο το οποίο να περιέχει όλες τις διαθέσιμες επιλογές, όπως γίνεται συνήθως για δοκιμές, εκτελέστε την ακόλουθη εντολή ως <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf &amp;&amp; make LINT</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Το παρακάτω είναι ένα παράδειγμα του αρχείου ρυθμίσεων <span class=filename>GENERIC</span> με επιπρόσθετα διευκρινιστικά σχόλια όπου είναι απαραίτητο. Το παράδειγμα θα πρέπει να ταιριάζει αρκετά καλά με το αντίγραφο του αρχείου πού έχετε στο <span class=filename>/usr/src/sys/i386/conf/GENERIC</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>machine		i386</pre></div></div><div class=paragraph><p>Πρόκειται για την αρχιτεκτονική του μηχανήματος. Πρέπει να είναι <code>amd64</code>, <code>i386</code>, <code>ia64</code>, <code>pc98</code>, <code>powerpc</code>, ή <code>sparc64</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</pre></div></div><div class=paragraph><p>Η παραπάνω επιλογή καθορίζει τον τύπο της CPU που έχετε στο σύστημα σας. Μπορεί να έχετε παραπάνω από μια τέτοιες γραμμές (αν για παράδειγμα δεν είστε σίγουρος αν θα πρέπει να χρησιμοποιήσετε <code>I586_CPU</code> ή <code>I686_CPU</code>), αλλά για ένα προσαρμοσμένο πυρήνα είναι καλύτερα να καθορίσετε μόνο τη CPU που έχετε. Αν δεν είστε σίγουρος για τον τύπο της CPU μπορείτε να ελέγξετε το αρχείο <span class=filename>/var/run/dmesg.boot</span> για να δείτε τα μηνύματα εκκίνησης του συστήματος σας.</p></div><div class="literalblock programlisting"><div class=content><pre>ident          GENERIC</pre></div></div><div class=paragraph><p>Αυτό είναι το αναγνωριστικό όνομα του πυρήνα. Θα πρέπει να το αλλάξετε στο όνομα που δώσατε στον πυρήνα σας, π.χ. <code>MYKERNEL</code> αν έχετε ακολουθήσει τις οδηγίες από το προηγούμενο μας παράδειγμα. Η τιμή που θα βάλετε στο αλφαριθμητικό <code>ident</code> θα εκτυπώνεται όταν εκκινείτε με τον συγκεκριμένο πυρήνα, και έτσι είναι χρήσιμο να δώσετε στο νέο πυρήνα ένα διαφορετικό όνομα αν θέλετε να το ξεχωρίζετε από το συνηθισμένο πυρήνα σας (αν π.χ. θέλετε να φτιάξετε ένα πειραματικό πυρήνα).</p></div><div class="literalblock programlisting"><div class=content><pre>#To statically compile in device wiring instead of /boot/device.hints
#hints          &#34;GENERIC.hints&#34;         # Default places to look for devices.</pre></div></div><div class=paragraph><p>Το αρχείο <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> χρησιμοποιείται για τον καθορισμό επιλογών που σχετίζονται με τους οδηγούς συσκευών. Η προεπιλεγμένη θέση την οποία ελέγχει ο <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> κατά την εκκίνηση είναι το <span class=filename>/boot/device.hints</span>. Χρησιμοποιώντας την επιλογή <code>hints</code> μπορείτε να ενσωματώσετε στατικά τις οδηγίες αυτές μέσα στον πυρήνα. Στην περίπτωση αυτή δεν υπάρχει λόγος να δημιουργήσετε το αρχείο <span class=filename>device.hints</span> στον κατάλογο <span class=filename>/boot</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</pre></div></div><div class=paragraph><p>Η φυσιολογική διαδικασία δημιουργίας του FreeBSD περιλαμβάνει πληροφορίες εκσφαλμάτωσης (debugging) όταν ο πυρήνας δημιουργείται με την επιλογή <code>-g</code>, επιτρέποντας έτσι την χρήση τους όταν δοθούν στο <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SCHED_ULE         # ULE scheduler</pre></div></div><div class=paragraph><p>Ο προεπιλεγμένος scheduler του FreeBSD. Κρατήστε την επιλογή αυτή.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PREEMPTION         # Enable kernel thread preemption</pre></div></div><div class=paragraph><p>Επιτρέπει σε νήματα του πυρήνα να προσπεραστούν από άλλα, υψηλότερης προτεραιότητας. Βοηθάει στην αύξηση απόκρισης του συστήματος και επιτρέπει σε νήματα διακοπών (interrupts) να εκτελεστούν πιο γρήγορα, αντί να μένουν σε αναμονή.</p></div><div class="literalblock programlisting"><div class=content><pre>options          INET              # InterNETworking</pre></div></div><div class=paragraph><p>Υποστήριξη δικτύου. Αφήστε την επιλογή αυτή ενεργοποιημένη, ακόμα και αν δεν σκοπεύετε να συνδεθείτε σε κάποιο δίκτυο. Τα περισσότερα προγράμματα χρειάζονται έστω και την εσωτερική (loopback) δικτύωση (τη δυνατότητα δηλ. να κάνουν συνδέσεις δικτύου μέσα στο ίδιο σας το μηχάνημα), καθιστώντας την επιλογή αυτή ουσιαστικά υποχρεωτική.</p></div><div class="literalblock programlisting"><div class=content><pre>options          INET6             # IPv6 communications protocols</pre></div></div><div class=paragraph><p>Η επιλογή αυτή ενεργοποιεί τα πρωτόκολλα επικοινωνίας IPv6.</p></div><div class="literalblock programlisting"><div class=content><pre>options          FFS               # Berkeley Fast Filesystem</pre></div></div><div class=paragraph><p>Πρόκειται για το βασικό σύστημα αρχείων του σκληρού δίσκου. Αφήστε την επιλογή αυτή ενεργοποιημένη, αν ξεκινάτε από το σκληρό δίσκο.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SOFTUPDATES       # Enable FFS Soft Updates support</pre></div></div><div class=paragraph><p>Η επιλογή αυτή ενεργοποιεί τα Soft Updates στον πυρήνα, το οποίο βοηθάει την επιτάχυνση της εγγραφής στους δίσκους. Ακόμα και αν η λειτουργία αυτή παρέχεται από τον πυρήνα, θα πρέπει επίσης να ενεργοποιηθεί για συγκεκριμένους δίσκους. Δείτε την έξοδο της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> για να δείτε αν είναι ενεργοποιημένα τα Soft Updates στους δίσκους του συστήματος σας. Αν δεν δείτε την επιλογή <code>soft-updates</code> θα χρειαστεί να την ενεργοποιήσετε με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> (για υπάρχοντα συστήματα αρχείων) ή <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> (για νέα συστήματα αρχείων).</p></div><div class="literalblock programlisting"><div class=content><pre>options          UFS_ACL           # Support for access control lists</pre></div></div><div class=paragraph><p>Με την επιλογή αυτή, ενεργοποιείται η υποστήριξη του πυρήνα για λίστες ελέγχου πρόσβασης (access control lists). Τα ACLs εξαρτιούνται από τη χρήση εκτεταμένων ιδιοτήτων και από το σύστημα αρχείων UFS2, και περιγράφονται με λεπτομέρεια στο <a href=./#fs-acl>File System Access Control Lists</a>. Τα ACLs είναι ενεργοποιημένα από προεπιλογή, και δεν θα πρέπει να τα απενεργοποιήσετε από τον πυρήνα αν έχουν χρησιμοποιηθεί στο παρελθόν σε κάποιο σύστημα αρχείων, καθώς αυτό θα τα αφαιρέσει από τα αρχεία, αλλάζοντας έτσι τον τρόπο προστασίας τους με απρόβλεπτους τρόπους.</p></div><div class="literalblock programlisting"><div class=content><pre>options          UFS_DIRHASH       # Improve performance on big directories</pre></div></div><div class=paragraph><p>Με την επιλογή αυτή, περιλαμβάνονται λειτουργίες που αυξάνουν την ταχύτητα πρόσβασης του δίσκου σε μεγάλους καταλόγους, με κόστος τη χρήση επιπρόσθετης μνήμης. Φυσιολογικά, θα θέλετε να κρατήσετε την επιλογή αυτή σε ένα μεγάλο εξυπηρετητή ή σταθμό εργασίας, και να την αφαιρέσετε όταν χρησιμοποιείτε το FreeBSD σε ένα μικρό σύστημα όπου η μνήμη είναι περιορισμένη και η ταχύτητα πρόσβασης στο δίσκο είναι λιγότερο σημαντική, όπως για παράδειγμα σε ένα firewall.</p></div><div class="literalblock programlisting"><div class=content><pre>options          MD_ROOT           # MD is a potential root device</pre></div></div><div class=paragraph><p>Με την επιλογή αυτή ενεργοποιείται η υποστήριξη χρήσης ενός εικονικού δίσκου στη μνήμη RAM (ramdrive) για χρήση ως συσκευή root.</p></div><div class="literalblock programlisting"><div class=content><pre>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</pre></div></div><div class=paragraph><p>Το δικτυακό σύστημα αρχείων. Αν δεν έχετε σκοπό να προσαρτήσετε συστήματα αρχείων από άλλο εξυπηρετητή αρχείων UNIX® μέσω TCP/IP, μπορείτε να μετατρέψετε αυτές τις γραμμές σε σχόλια.</p></div><div class="literalblock programlisting"><div class=content><pre>options          MSDOSFS           # MSDOS Filesystem</pre></div></div><div class=paragraph><p>Το σύστημα αρχείων του MS-DOS®. Αν δεν σκοπεύετε να προσαρτήσετε δίσκο DOS κατά την εκκίνηση, μπορείτε με ασφάλεια να μετατρέψετε την επιλογή αυτή σε σχόλιο. Η υποστήριξη θα φορτωθεί αυτόματα την πρώτη φορά που θα προσαρτήσετε κατάτμηση DOS όπως περιγράψαμε παραπάνω. Επίσης, το εξαιρετικό πρόγραμμα <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> σας επιτρέπει να έχετε πρόσβαση σε δισκέτες DOS χωρίς να χρειάζεται να τις προσαρτήσετε και να αποπροσαρτήσετε (και επίσης δεν απαιτεί τη χρήση του <code>MSDOSFS</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>options          CD9660            # ISO 9660 Filesystem</pre></div></div><div class=paragraph><p>Το σύστημα αρχείων ISO 9660 για CDROM. Μετατρέψτε το σε σχόλιο αν δεν έχετε οδηγό CDROM ή αν σπάνια προσαρτάτε CD δεδομένων (καθώς θα φορτωθεί δυναμικά την πρώτη φορά που θα προσαρτήσετε τέτοιο CD ). Τα μουσικά CD δεν χρειάζονται αυτό το σύστημα αρχείων.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PROCFS            # Process filesystem (requires PSEUDOFS)</pre></div></div><div class=paragraph><p>Αυτό το σύστημα αρχείων περιέχει τις διεργασίες του συστήματος. Πρόκειται για ένα "εικονικό" σύστημα αρχείων το οποίο προσαρτάται στον κατάλογο <span class=filename>/proc</span> και επιτρέπει σε προγράμματα όπως το <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> να δίνουν περισσότερες πληροφορίες για τις διεργασίες που εκτελούνται. Η χρήση του <code>PROCFS</code> δεν απαιτείται στις περισσότερες περιπτώσεις, καθώς τα περισσότερα εργαλεία παρακολούθησης και εκσφαλμάτωσης έχουν προσαρμοστεί να εκτελούνται χωρίς το <code>PROCFS</code>. Στις νέες εγκαταστάσεις, αυτό το σύστημα αρχείων δεν προσαρτάται από προεπιλογή.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PSEUDOFS          # Pseudo-filesystem framework</pre></div></div><div class=paragraph><p>Πυρήνες που χρησιμοποιούν το <code>PROCFS</code> πρέπει επίσης να παρέχουν υποστήριξη για το <code>PSEUDOFS</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          GEOM_PART_GPT     # GUID Partition Tables.</pre></div></div><div class=paragraph><p>Προσθέτει υποστήριξη για <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>Πίνακα Κατατμήσεων GUID</a>. Το GPT δίνει δυνατότητα ύπαρξης μεγάλου αριθμού κατατμήσεων στο δίσκο, μέχρι 128 με τις τυπικές ρυθμίσεις.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</pre></div></div><div class=paragraph><p>Συμβατότητα με το 4.3BSD. Αφήστε την επιλογή αυτή ενεργή: κάποια προγράμματα θα συμπεριφέρονται παράξενα αν την απενεργοποιήσετε.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD4   # Compatible with FreeBSD4</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται για την υποστήριξη εφαρμογών που έχουν μεταγλωττιστεί σε παλιότερες εκδόσεις του FreeBSD και οι οποίες χρησιμοποιούν παλιές διεπαφές και κλήσεις συστήματος. Συνίσταται να υπάρχει αυτή η επιλογή σε όλα τα συστήματα i386™ τα οποία εκτελούν παλιότερες εφαρμογές. Αρχιτεκτονικές όπως η ia64 και η sparc64 που άρχισαν να υποστηρίζονται από την έκδοση 5.Χ και μετά δεν χρειάζονται αυτή την επιλογή.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD5   # Compatible with FreeBSD5</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται στο για την υποστήριξη εφαρμογών που έχουν μεταγλωττιστεί στο FreeBSD 5.X και χρησιμοποιούν τις αντίστοιχες κλήσεις αυτού του συστήματος.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD6   # Compatible with FreeBSD6</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται στο για την υποστήριξη εφαρμογών που έχουν μεταγλωττιστεί στο FreeBSD 6.X και χρησιμοποιούν τις αντίστοιχες κλήσεις αυτού του συστήματος.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD7   # Compatible with FreeBSD75</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται στο για την υποστήριξη εφαρμογών που έχουν μεταγλωττιστεί στο FreeBSD 7.X και χρησιμοποιούν τις αντίστοιχες κλήσεις αυτού του συστήματος.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI</pre></div></div><div class=paragraph><p>Με την επιλογή αυτή ο πυρήνας περιμένει 5 δευτερόλεπτα πριν ανιχνεύσει κάθε συσκευή SCSI στο σύστημα σας. Αν έχετε μόνο IDE δίσκους μπορείτε να την αγνοήσετε, διαφορετικά μπορείτε να δοκιμάσετε να μειώσετε τον αριθμό αυτό, για να επιταχύνετε την εκκίνηση. Φυσικά, αν το κάνετε αυτό και ανακαλύψετε ότι το FreeBSD έχει πρόβλημα στην αναγνώριση των συσκευών σας, θα πρέπει να την ανεβάσετε ξανά.</p></div><div class="literalblock programlisting"><div class=content><pre>options          KTRACE            # ktrace(1) support</pre></div></div><div class=paragraph><p>Η επιλογή αυτή ενεργοποιεί το tracing των διεργασιών του πυρήνα, το οποίο είναι χρήσιμο στην εκσφαλμάτωση.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVSHM           # SYSV-style shared memory</pre></div></div><div class=paragraph><p>Η επιλογή αυτή ενεργοποιεί την κοινόχρηστη μνήμη σύμφωνα με το πρότυπο του System V. Η πλέον κοινή χρήση της, είναι η επέκταση XSHM στα Χ η οποία χρησιμοποιείται αυτόματα από πολλές βαριές εφαρμογές γραφικών για καλύτερη ταχύτητα. Αν χρησιμοποιείτε Χ, σίγουρα θέλετε να περιλάβετε αυτή την επιλογή.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVMSG           # SYSV-style message queues</pre></div></div><div class=paragraph><p>Υποστήριξη για μηνύματα του System V. Η επιλογή αυτή προσθέτει μόνο μερικές εκατοντάδες bytes στον πυρήνα.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVSEM           # SYSV-style semaphores</pre></div></div><div class=paragraph><p>Υποστήριξη σηματοφορέων του System V. Χρησιμοποιείται λιγότερο συχνά, αλλά προσθέτει μόνο μερικές εκατοντάδες bytes στον πυρήνα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η επιλογή <code>-p</code> της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=ipcs&amp;sektion=1&amp;format=html">ipcs(1)</a> θα σας δείξει ποιες διεργασίες χρησιμοποιούν κάθε μια από αυτές τις λειτουργίες του System V.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</pre></div></div><div class=paragraph><p>Επεκτάσεις πραγματικού χρόνου (Real-time) που προστέθηκαν στο POSIX® το 1993. Χρησιμοποιείται από κάποιες εφαρμογές στη συλλογή των ports (όπως το StarOffice™).</p></div><div class="literalblock programlisting"><div class=content><pre>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</pre></div></div><div class=paragraph><p>Η επιλογή αυτή είναι απαραίτητη για τη δημιουργία του αρχείου συσκευής πληκτρολογίου στον κατάλογο <span class=filename>/dev</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</pre></div></div><div class=paragraph><p>Το Giant είναι το όνομα ενός συστήματος αμοιβαίου αποκλεισμού (sleep mutex) το οποίο προστατεύει ένα μεγάλο αριθμό πόρων του πυρήνα. Στις μέρες μας, αυτό θεωρείται ανεπίτρεπτο από πλευράς απόδοσης και αντικαθίσταται με κλειδώματα τα οποία προστατεύουν συγκεκριμένους πόρους. Η επιλογή <code>ADAPTIVE_GIANT</code> επιτρέπει στο Giant να συμπεριληφθεί στο σετ των mutexes που μπορούν να εκτελεστούν επιλεκτικά. Έτσι, αν ένα νήμα θέλει να κλειδώσει το Giant mutex, αλλά αυτό είναι ήδη κλειδωμένο από ένα νήμα σε μια άλλη CPU, το πρώτο νήμα θα συνεχίσει να εκτελείται, και θα περιμένει για την απελευθέρωση του κλειδώματος. Φυσιολογικά, το νήμα θα επέστρεφε στην κατάσταση ύπνου (sleep) και θα περίμενε για την επόμενη ευκαιρία εκτέλεσης του. Αν δεν είστε σίγουρος, αφήστε αυτή την επιλογή ενεργή.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σημειώστε ότι από το FreeBSD 8.0-RELEASE και τις επόμενες εκδόσεις, όλα τα mutexes έχουν από προεπιλογή τη δυνατότητα προσαρμογής, εκτός αν έχει επίτηδες γίνει διαφορετική ρύθμιση, χρησιμοποιώντας την επιλογή <code>NO_ADAPTIVE_MUTEXES</code> κατά τη μεταγλώττιση. Το Giant έχει επίσης δυνατότητα προσαρμογής πλέον, και έτσι η επιλογή <code>ADAPTIVE_GIANT</code> έχει αφαιρεθεί από το αρχείο ρυθμίσεων πυρήνα.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          apic               # I/O APIC</pre></div></div><div class=paragraph><p>Η συσκευή apic επιτρέπει τη χρήση του I/O APIC για την παράδοση των interrupts (διακοπών). Η συσκευή apic μπορεί να χρησιμοποιηθεί τόσο σε πυρήνες για ένα επεξεργαστή (UP) όσο και για πολλαπλούς (SMP), αλλά στη δεύτερη περίπτωση είναι απαραίτητη. Προσθέστε την επιλογή <code>options SMP</code> για να έχετε υποστήριξη πολλαπλών επεξεργαστών.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η συσκευή apic υπάρχει μόνο στην αρχιτεκτονική i386, η γραμμή αυτή δεν θα πρέπει να χρησιμοποιηθεί σε άλλες αρχιτεκτονικές.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          eisa</pre></div></div><div class=paragraph><p>Θα πρέπει να συμπεριλάβετε την επιλογή αυτή αν έχετε μητρική με δίαυλο τύπου EISA. Ενεργοποιείται έτσι η αυτόματη ανίχνευση και ρύθμιση όλων των συσκευών στο δίαυλο EISA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          pci</pre></div></div><div class=paragraph><p>Θα πρέπει να συμπεριλάβετε αυτή την επιλογή αν έχετε μητρική με δίαυλο PCI. Ενεργοποιείται έτσι η αυτόματη ανίχνευση των καρτών PCI και η επικοινωνία μεταξύ των διαύλων PCI και ISA.</p></div><div class="literalblock programlisting"><div class=content><pre># Floppy drives
device          fdc</pre></div></div><div class=paragraph><p>Πρόκειται για τον ελεγκτή μονάδας δισκέτας.</p></div><div class="literalblock programlisting"><div class=content><pre># ATA and ATAPI devices
device          ata</pre></div></div><div class=paragraph><p>Αυτός ο οδηγός υποστηρίζει όλες τις συσκευές τύπου ATA και ATAPI. Χρειάζεστε μόνο μια καταχώρηση <code>device ata</code> για να ανιχνεύσει ο πυρήνας όλες τις συσκευές ATA/ATAPI τύπου PCI στα σύγχρονα μηχανήματα.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atadisk                 # ATA disk drives</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται μαζί με το <code>device ata</code> για την υποστήριξη δίσκων ATA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ataraid                 # ATA RAID drives</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται μαζί με το <code>device ata</code> για την υποστήριξη δίσκων ATA RAID.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapicd                 # ATAPI CDROM drives</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται μαζί με το <code>device ata</code> για την υποστήριξη οδηγών ATAPI CDROM.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapifd                 # ATAPI floppy drives</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται μαζί με το <code>device ata</code> για την υποστήριξη οδηγών δισκέτας ATAPI.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapist                 # ATAPI tape drives</pre></div></div><div class=paragraph><p>Η επιλογή αυτή απαιτείται μαζί με το <code>device ata</code> για την υποστήριξη μονάδων ταινίας ATAPI.</p></div><div class="literalblock programlisting"><div class=content><pre>options         ATA_STATIC_ID           # Static device numbering</pre></div></div><div class=paragraph><p>Με την επιλογή αυτή, ο αριθμός του ελεγκτή γίνεται στατικός. Χωρίς αυτή, οι αριθμοί συσκευών αποδίδονται δυναμικά.</p></div><div class="literalblock programlisting"><div class=content><pre># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr&#39;)
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</pre></div></div><div class=paragraph><p>Ελεγκτές SCSI. Μπορείτε να μετατρέψετε σε σχόλιο οποιονδήποτε δεν έχετε στο σύστημα σας. Αν το σύστημα σας έχει μόνο συσκευές IDE, μπορείτε να αφαιρέσετε όλες τις γραμμές. Οι γραμμές τύπου <code>*_REG_PRETTY_PRINT</code> χρησιμοποιούνται για να δίνουν περισσότερες διαγνωστικές πληροφορίες για τους αντίστοιχους οδηγούς.</p></div><div class="literalblock programlisting"><div class=content><pre># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</pre></div></div><div class=paragraph><p>Περιφερειακά SCSI. Μπορείτε και πάλι να μετατρέψετε σε σχόλιο όσες συσκευές δεν έχετε, ή αν έχετε μόνο συσκευές IDE, μπορείτε να αφαιρέσετε εντελώς αυτές τις γραμμές.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ο οδηγός USB <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> και κάποιοι άλλοι οδηγοί χρησιμοποιούν το υποσύστημα SCSI αν και δεν είναι πραγματικές SCSI συσκευές. Για το λόγο αυτό, σιγουρευτείτε ότι δεν αφαιρέσατε την υποστήριξη SCSI αν περιλαμβάνονται τέτοιοι οδηγοί στο αρχείο ρύθμισης του πυρήνα σας.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          hptrr      # Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</pre></div></div><div class=paragraph><p>Υποστηριζόμενοι ελεγκτές RAID. Αν δεν έχετε κανένα από αυτούς, μπορείτε να τους μετατρέψετε σε σχόλια ή να τους αφαιρέσετε εντελώς.</p></div><div class="literalblock programlisting"><div class=content><pre># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</pre></div></div><div class=paragraph><p>Ο ελεγκτής πληκτρολογίου (<code>atkbdc</code>) παρέχει υπηρεσίες I/O για πληκτρολόγια τύπου AT και συσκευές κατάδειξης (ποντίκια) τύπου PS/2. Ο ελεγκτής απαιτείται για τη λειτουργία του οδηγού πληκτρολογίου (<code>atkbd</code>) και του οδηγού συσκευής κατάδειξης PS/2 (<code>psm</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>device          atkbd      # AT keyboard</pre></div></div><div class=paragraph><p>Ο οδηγός <code>atkbd</code>, μαζί με τον ελεγκτή <code>atkbdc</code>, παρέχει πρόσβαση σε πληκτρολόγιο τύπου AT 84 ή εκτεταμένου AT το οποίο συνδέεται στον ελεγκτή πληκτρολογίου.</p></div><div class="literalblock programlisting"><div class=content><pre>device          psm        # PS/2 mouse</pre></div></div><div class=paragraph><p>Χρησιμοποιήστε αυτή τη συσκευή αν το ποντίκι σας συνδέεται στην θύρα PS/2.</p></div><div class="literalblock programlisting"><div class=content><pre>device          kbdmux        # keyboard multiplexer</pre></div></div><div class=paragraph><p>Βασική υποστήριξη πολυπλεξίας πληκτρολογίων. Αν δε σκοπεύετε να χρησιμοποιήσετε περισσότερα από ένα πληκτρολόγια στο σύστημα σας, μπορείτε με ασφάλεια να αφαιρέσετε αυτή τη γραμμή.</p></div><div class="literalblock programlisting"><div class=content><pre>device          vga        # VGA video card driver</pre></div></div><div class=paragraph><p>Το πρόγραμμα οδήγησης της κάρτας γραφικών.</p></div><div class="literalblock programlisting"><div class=content><pre>device          splash     # Splash screen and screen saver support</pre></div></div><div class=paragraph><p>Γραφική οθόνη (splash) κατά την εκκίνηση! Η συσκευή αυτή χρησιμοποιείται επίσης από τα προγράμματα προφύλαξης οθόνης (κονσόλας).</p></div><div class="literalblock programlisting"><div class=content><pre># syscons is the default console driver, resembling an SCO console
device          sc</pre></div></div><div class=paragraph><p>Ο οδηγός <code>sc</code> είναι ο προεπιλεγμένος οδηγός κονσόλας και προσομοιώνει κονσόλα τύπου SCO. Καθώς τα περισσότερα προγράμματα πλήρους οθόνης αποκτούν πρόσβαση στην κονσόλα μέσω κάποιας βιβλιοθήκης βάσης δεδομένων τερματικών όπως το <span class=filename>termcap</span>, δεν θα πρέπει να έχει σημασία αν χρησιμοποιήσετε αυτόν τον οδηγό ή τον <code>vt</code> ο οποίος είναι συμβατός με κονσόλα <code>VT220</code>. Μετά την είσοδο σας στο σύστημα, θέστε την μεταβλητή <code>TERM</code> στην τιμή <code>scoansi</code> αν κάποια προγράμματα πλήρους οθόνης έχουν πρόβλημα όταν χρησιμοποιείται αυτή η κονσόλα.</p></div><div class="literalblock programlisting"><div class=content><pre># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</pre></div></div><div class=paragraph><p>Πρόκειται για ένα οδηγό κονσόλας συμβατό με VT220, και με προς τα πίσω συμβατότητα με VT100/102. Λειτουργεί καλά σε κάποιους φορητούς υπολογιστές που έχουν ασυμβατότητα υλικού με τον <code>sc</code>. Μετά την είσοδο σας στο σύστημα, θέστε την μεταβλητή <code>TERM</code> σε <code>vt100</code> ή <code>vt220</code>. Ο οδηγός μπορεί επίσης να αποδειχθεί χρήσιμος όταν συνδέεστε σε μεγάλο αριθμό από διαφορετικά μηχανήματα μέσω δικτύου, όπου δεν υπάρχουν καταχωρήσεις για τη συσκευή <code>sc</code> στο <span class=filename>termcap</span> ή <span class=filename>terminfo</span> - το <code>vt100</code> θα πρέπει να είναι διαθέσιμο πρακτικά σε κάθε πλατφόρμα.</p></div><div class="literalblock programlisting"><div class=content><pre>device          agp</pre></div></div><div class=paragraph><p>Συμπεριλάβετε τη συσκευή αυτή αν έχετε AGP κάρτα στο σύστημα σας. Θα ενεργοποιήσετε με αυτό τον τρόπο την υποστήριξη για AGP και AGP GART για μητρικές που υποστηρίζουν αυτές τις λειτουργίες.</p></div><div class="literalblock programlisting"><div class=content><pre># Power management support (see NOTES for more options)
#device          apm</pre></div></div><div class=paragraph><p>Υποστήριξη Advanced Power Management (προχωρημένης διαχείρισης ισχύος). Χρήσιμο για φορητά, αν και η επιλογή αυτή, από προεπιλογή, είναι ανενεργή στον πυρήνα <span class=filename>GENERIC</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Add suspend/resume support for the i8254.
device           pmtimer</pre></div></div><div class=paragraph><p>Πρόγραμμα οδήγησης μετρητή χρόνου (Timer) για συμβάντα που σχετίζονται με διαχείριση ενέργειας όπως το APM και το ACPI.</p></div><div class="literalblock programlisting"><div class=content><pre># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</pre></div></div><div class=paragraph><p>Υποστήριξη PCMCIA. Την χρειάζεστε αν χρησιμοποιείτε φορητό υπολογιστή.</p></div><div class="literalblock programlisting"><div class=content><pre># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</pre></div></div><div class=paragraph><p>Πρόκειται για τις σειριακές θύρες οι οποίες είναι γνωστές στον κόσμο του MS-DOS®/Windows® ως θύρες <span class=filename>COM</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν έχετε εσωτερικό μόντεμ στη θύρα <span class=filename>COM4</span> και έχετε και σειριακή θύρα <span class=filename>COM2</span>, θα πρέπει να αλλάξετε το IRQ του μόντεμ στο 2 (για περίεργους τεχνικούς λόγους, IRQ2 = IRQ 9) για να μπορέσετε να το χρησιμοποιήσετε από το FreeBSD. Αν έχετε κάρτα πολλαπλών σειριακών εξόδων, ελέγξτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> για περισσότερες πληροφορίες σχετικά με τις σωστές τιμές που πρέπει να προσθέσετε στο <span class=filename>/boot/device.hints</span>. Κάποιες κάρτες γραφικών (ειδικά αυτές που βασίζονται σε ολοκληρωμένα S3) χρησιμοποιούν διευθύνσεις IO μορφής <code>0x*2e8</code>, και καθώς πολλές φτηνές σειριακές κάρτες δεν αποκωδικοποιούν πλήρως τη 16 bit περιοχή διευθύνσεων, συγκρούονται με τις κάρτες αυτές, καθιστώντας έτσι πρακτικά άχρηστη τη θύρα <span class=filename>COM4</span>.</p></div><div class=paragraph><p>Κάθε σειριακή πόρτα χρειάζεται να έχει μια μοναδική IRQ (εκτός αν χρησιμοποιείτε κάρτα πολλαπλών σειριακών που υποστηρίζει κοινή χρήση interrupts), και έτσι δεν μπορούν να χρησιμοποιηθούν τα προεπιλεγμένα interrupts για την <span class=filename>COM3</span> και την <span class=filename>COM4</span>.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Parallel port
device          ppc</pre></div></div><div class=paragraph><p>Πρόκειται για την παράλληλη θύρα στο δίαυλο ISA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ppbus      # Parallel port bus (required)</pre></div></div><div class=paragraph><p>Παρέχει υποστήριξη για το δίαυλο της παράλληλης θύρας.</p></div><div class="literalblock programlisting"><div class=content><pre>device          lpt        # Printer</pre></div></div><div class=paragraph><p>Παρέχει υποστήριξη για εκτυπωτές παράλληλης θύρας.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Χρειάζεστε και τα τρία παραπάνω για να ενεργοποιήσετε την υποστήριξη εκτυπωτή παράλληλης θύρας.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          plip       # TCP/IP over parallel</pre></div></div><div class=paragraph><p>Πρόκειται για το πρόγραμμα οδήγησης δικτύου μέσω παράλληλης θύρας.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ppi        # Parallel port interface device</pre></div></div><div class=paragraph><p>Πρόγραμμα I/O γενικής χρήσης ("geek port") + IEEE1284 I/O.</p></div><div class="literalblock programlisting"><div class=content><pre>#device         vpo        # Requires scbus and da</pre></div></div><div class=paragraph><p>Χρησιμοποιείται για μονάδα δισκέτας Iomega Zip. Απαιτεί υποστήριξη από τους οδηγούς <code>scbus</code> και <code>da</code>. Η καλύτερη απόδοση επιτυγχάνεται με θύρα σε κατάσταση λειτουργίας EPP 1.9.</p></div><div class="literalblock programlisting"><div class=content><pre>#device         puc</pre></div></div><div class=paragraph><p>Ενεργοποιήστε αυτή τη συσκευή αν έχετε μια "χαζή" σειριακή ή παράλληλη PCI κάρτα η οποία υποστηρίζεται από το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=puc&amp;sektion=4&amp;format=html">puc(4)</a> (glue driver).</p></div><div class="literalblock programlisting"><div class=content><pre># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (Tulip)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (Typhoon)
device          vx         # 3Com 3c590, 3c595 (Vortex)</pre></div></div><div class=paragraph><p>Διάφορα προγράμματα οδήγησης για PCI κάρτες δικτύου. Μετατρέψτε σε σχόλιο ή αφαιρέστε τελείως όσες δεν υπάρχουν στο σύστημα σας.</p></div><div class="literalblock programlisting"><div class=content><pre># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the &#39;device miibus&#39; line in order to use these NICs!
device          miibus     # MII bus support</pre></div></div><div class=paragraph><p>Η υποστήριξη διαύλου MII απαιτείται για κάποιες κάρτες δικτύου Ethernet PCI 10/100, ειδικά για αυτές που χρησιμοποιούν πομποδέκτη συμβατό με MII ή έχουν διεπαφή ελέγχου που λειτουργεί παρόμοια με τον MII. Προσθέτοντας <code>device miibus</code> στο αρχείο ρύθμισης του πυρήνα, θα έχετε υποστήριξη για το γενικό API του miibus και για όλους τους οδηγούς PHY, συμπεριλαμβανομένου και ενός γενικού για PHYs που δεν υποστηρίζονται από κάποιο συγκεκριμένο οδηγό.</p></div><div class="literalblock programlisting"><div class=content><pre>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over &#39;lnc&#39;)
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (Starfire)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 EPIC)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (Boomerang, Cyclone)</pre></div></div><div class=paragraph><p>Προγράμματα οδήγησης που χρησιμοποιούν τον κώδικα του διαύλου ελέγχου MII.</p></div><div class="literalblock programlisting"><div class=content><pre># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# &#39;device ed&#39; requires &#39;device miibus&#39;
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC&#39;s 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</pre></div></div><div class=paragraph><p>Προγράμματα οδήγησης καρτών Ethernet τύπου ISA. Δείτε το αρχείο <span class=filename>/usr/src/sys/i386/conf/NOTES</span> για λεπτομέρειες σχετικά με το ποιες κάρτες υποστηρίζονται από ποιον οδηγό.</p></div><div class="literalblock programlisting"><div class=content><pre># Wireless NIC cards
device          wlan            # 802.11 support</pre></div></div><div class=paragraph><p>Γενική υποστήριξη του 802.11. Η γραμμή αυτή απαιτείται για ασύρματη δικτύωση.</p></div><div class="literalblock programlisting"><div class=content><pre>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</pre></div></div><div class=paragraph><p>Υποστήριξη κρυπτογράφησης για συσκευές 802.11. Οι γραμμές αυτές χρειάζονται αν σκοπεύετε να χρησιμοποιήσετε κρυπτογράφηση και πρωτόκολλα ασφαλείας 802.11i.</p></div><div class="literalblock programlisting"><div class=content><pre>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC&#39;s
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</pre></div></div><div class=paragraph><p>Υποστήριξη για διάφορες ασύρματες κάρτες.</p></div><div class="literalblock programlisting"><div class=content><pre># Pseudo devices
device   loop          # Network loopback</pre></div></div><div class=paragraph><p>Πρόκειται για τη γενική συσκευή εσωτερικού δικτύου (loopback) του TCP/IP. Η σύνδεση μέσω telnet ή FTP στο <code>localhost</code> (γνωστό επίσης και ως <code>127.0.0.1</code>) πραγματοποιείται μέσω αυτής της συσκευής. Η ύπαρξη αυτής της συσκευής είναι <em>υποχρεωτική</em>.</p></div><div class="literalblock programlisting"><div class=content><pre>device   random        # Entropy device</pre></div></div><div class=paragraph><p>Κρυπτογραφικά ασφαλής γεννήτρια τυχαίων αριθμών.</p></div><div class="literalblock programlisting"><div class=content><pre>device   ether         # Ethernet support</pre></div></div><div class=paragraph><p>Η γραμμή <code>ether</code> απαιτείται μόνο αν έχετε κάρτα δικτύου Ethernet. Περιέχει γενικό κώδικα για το πρωτόκολλο Ethernet.</p></div><div class="literalblock programlisting"><div class=content><pre>device   sl            # Kernel SLIP</pre></div></div><div class=paragraph><p>Η γραμμή <code>sl</code> παρέχει υποστήριξη SLIP. Η υποστήριξη αυτή έχει σχεδόν ολοκληρωτικά ξεπεραστεί από το PPP, το οποίο είναι ευκολότερο στη ρύθμιση, υποστηρίζει καλύτερα τις συνδέσεις μέσω μόντεμ, και παρέχει καλύτερες δυνατότητες.</p></div><div class="literalblock programlisting"><div class=content><pre>device   ppp           # Kernel PPP</pre></div></div><div class=paragraph><p>Η γραμμή αυτή είναι για υποστήριξη PPP μέσω του πυρήνα για επιλογικές (dial-up) συνδέσεις. Υπάρχει επίσης μια έκδοση PPP η οποία υλοποιείται ως εφαρμογή χρήστη (userland), χρησιμοποιεί το <code>tun</code> και προσφέρει περισσότερη ευελιξία και λειτουργίες όπως κλήση κατά απαίτηση (demand dialing).</p></div><div class="literalblock programlisting"><div class=content><pre>device   tun           # Packet tunnel.</pre></div></div><div class=paragraph><p>Η συσκευή αυτή χρησιμοποιείται από το πρόγραμμα PPP χρήστη (userland). Δείτε το τμήμα <a href=#userppp>PPP</a> αυτού του βιβλίου για περισσότερες πληροφορίες.</p></div><div class="literalblock programlisting"><div class=content><pre>device   pty           # Pseudo-ttys (telnet etc)</pre></div></div><div class=paragraph><p>Πρόκειται για συσκευή "ψευδό-τερματικού" ή προσομοίωσης θύρας login. Χρησιμοποιείται για εισερχόμενες συνδέσεις <code>telnet</code> και <code>rlogin</code>, από το xterm, και από κάποιες άλλες εφαρμογές όπως το Emacs.</p></div><div class="literalblock programlisting"><div class=content><pre>device   md            # Memory disks</pre></div></div><div class=paragraph><p>Ψευτό-συσκευές δίσκου με χρήση μνήμης (ramdrives).</p></div><div class="literalblock programlisting"><div class=content><pre>device   gif           # IPv6 and IPv4 tunneling</pre></div></div><div class=paragraph><p>Η συσκευή αυτή υλοποιεί IPv6 σε IPv4 tunneling, IPv4 σε IPv6 tunneling, IPv4 σε IPv4 tunneling, και IPv6 σε IPv6 tunneling. Η συσκευή <code>gif</code> "αυτό-κλωνοποιείται", και δημιουργεί τα αντίστοιχα αρχεία συσκευών όπως απαιτούνται.</p></div><div class="literalblock programlisting"><div class=content><pre>device   faith         # IPv6-to-IPv4 relaying (translation)</pre></div></div><div class=paragraph><p>Αυτή η ψεύδο-συσκευή συλλαμβάνει πακέτα που στέλνονται προς αυτήν και τα ανακατευθύνει προς το δαίμονα μετάφρασης του IPv4/IPv6.</p></div><div class="literalblock programlisting"><div class=content><pre># The `bpf&#39; device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that &#39;bpf&#39; is required for DHCP.
device   bpf           # Berkeley packet filter</pre></div></div><div class=paragraph><p>Πρόκειται για το φίλτρο πακέτων Berkeley. Αυτή η ψεύδο-συσκευή επιτρέπει σε κάρτες δικτύου να λειτουργούν σε κατάσταση promiscuous (πλήρους ακρόασης), συλλαμβάνοντας με αυτό τον τρόπο κάθε πακέτο ενός δικτύου (π.χ. Ethernet). Τα πακέτα αυτά μπορεί να αποθηκεύονται στο δίσκο ή να εξετάζονται με τη βοήθεια του προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η συσκευή <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> χρησιμοποιείται επίσης από το <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> για την ανάκτηση της διεύθυνσης IP της προεπιλεγμένης πύλης κ.ο.κ. Αν χρησιμοποιείτε DHCP, αφήστε αυτή την επιλογή ενεργοποιημένη.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # Human Interface Devices
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</pre></div></div><div class=paragraph><p>Υποστήριξη για διάφορες συσκευές USB.</p></div><div class="literalblock programlisting"><div class=content><pre># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</pre></div></div><div class=paragraph><p>Υποστήριξη για διάφορες συσκευές Firewire.</p></div><div class=paragraph><p>Για περισσότερες πληροφορίες και επιπλέον συσκευές που υποστηρίζονται από το FreeBSD, δείτε το αρχείο <span class=filename>/usr/src/sys/i386/conf/NOTES</span>.</p></div><div class=sect3><h4 id=_λειτουργία_με_μεγάλη_ποσότητα_μνήμης_pae>15.6.1. Λειτουργία με Μεγάλη Ποσότητα Μνήμης (PAE)<a class=anchor href=#_λειτουργία_με_μεγάλη_ποσότητα_μνήμης_pae></a></h4><div class=paragraph><p>Μηχανήματα με μεγάλη ποσότητα μνήμης, χρειάζονται πρόσβαση σε μνήμη που υπερβαίνει το όριο των 4 gigabytes των Εικονικών Διευθύνσεων Χρήστη+Πυρήνα (User+Kernel Virtual Address, KVA). Εξαιτίας αυτού του περιορισμού, η Intel πρόσθεσε υποστήριξη για 36bit φυσικών διευθύνσεων, από τον επεξεργαστή Pentium® Pro και μετά.</p></div><div class=paragraph><p>Η δυνατότητα Επέκτασης Φυσικών Διευθύνσεων, (Physical Address Extension, PAE) των Intel® Pentium® Pro και μεταγενέστερων CPU, επιτρέπει χρήση μνήμης ως 64 gigabytes. To FreeBSD παρέχει υποστήριξη για τη δυνατότητα αυτή μέσω της ρύθμισης πυρήνα <code>PAE</code>, η οποία διατίθεται για όλες τις τρέχουσες σταθερές εκδόσεις του FreeBSD. Λόγω περιορισμών στην αρχιτεκτονική του συστήματος μνήμης της Intel, δεν γίνεται διάκριση για τη μνήμη που βρίσκεται πάνω ή κάτω από τα 4 gigabytes. Η μνήμη που εκχωρείται πάνω από τα 4 gigabytes, απλώς προστίθεται στο μέγεθος της διαθέσιμης μνήμης.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε την υποστήριξη PAE στον πυρήνα, απλώς προσθέστε την ακόλουθη γραμμή στο αρχείο των ρυθμίσεων σας:</p></div><div class="literalblock programlisting"><div class=content><pre>options		    PAE</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η υποστήριξη PAE στο FreeBSD είναι διαθέσιμη μόνο για επεξεργαστές αρχιτεκτονικής Intel® IA-32. Θα πρέπει επίσης να σημειώσουμε ότι η υποστήριξη PAE στο FreeBSD δεν έχει δοκιμαστεί εκτεταμένα, και θα πρέπει να θεωρείται ποιότητας beta σε σχέση με τα άλλα σταθερά χαρακτηριστικά του FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η υποστήριξη PAE στο FreeBSD υπόκειται σε κάποιους περιορισμούς:</p></div><div class=ulist><ul><li><p>Μια διαδικασία δεν έχει πρόσβαση σε περισσότερα από 4 gigabytes χώρου VM.</p></li><li><p>Οδηγοί συσκευών που δεν χρησιμοποιούν τη διεπαφή <a href="https://man.freebsd.org/cgi/man.cgi?query=bus_dma&amp;sektion=9&amp;format=html">bus_dma(9)</a> ίσως προκαλέσουν καταστροφή δεδομένων σε ένα PAE πυρήνα και για το λόγο αυτό δεν συνίσταται η χρήση τους. Στο FreeBSD παρέχεται ένα αρχείο ρυθμίσεων <span class=filename>PAE</span> στο οποίο έχουν εξαιρεθεί όλα τα προγράμματα οδήγησης που είναι γνωστό ότι δεν δουλεύουν σε πυρήνα τύπου PAE.</p></li><li><p>Κάποιες μεταβλητές συστήματος (system tunables) εξακριβώνουν τη χρήση της μνήμης, βλέποντας το ποσό της διαθέσιμης φυσικής μνήμης. Αυτές οι μεταβλητές μπορεί να χρησιμοποιήσουν αδικαιολόγητα μεγάλη ποσότητα μνήμης, λόγω της φύσης του συστήματος PAE. Ένα τέτοιο παράδειγμα είναι η ρύθμιση sysctl <code>kern.maxvnodes</code> η οποία ελέγχει το μέγιστο αριθμό vnodes που επιτρέπονται στον πυρήνα. Είναι σκόπιμο να ρυθμίσετε αυτή και άλλες παρόμοιες παραμέτρους σε λογικές τιμές.</p></li><li><p>Ίσως χρειαστεί να ρυθμίσετε τις εικονικές διευθύνσεις του πυρήνα (KVA) ή να μειώσετε την ποσότητα κάποιου συγκεκριμένου πόρου που έχει μεγάλη χρήση (δείτε παραπάνω) για να αποφύγετε την εξάντληση του KVA. Μπορείτε να αυξήσετε το μέγεθος του KVA μέσω της επιλογής <code>KVA_PAGES</code>.</p></li></ul></div><div class=paragraph><p>Για λόγους σταθερότητας και απόδοσης, σας συμβουλεύουμε να διαβάσετε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>. Επίσης η σελίδα <a href="https://man.freebsd.org/cgi/man.cgi?query=pae&amp;sektion=4&amp;format=html">pae(4)</a> περιέχει ενημερωμένες πληροφορίες σχετικά με την υποστήριξη PAE στο FreeBSD.</p></div></div></div><div class=sect2><h3 id=kernelconfig-trouble>15.7. Αν Κάτι Πάει Λάθος<a class=anchor href=#kernelconfig-trouble></a></h3><div class=paragraph><p>Υπάρχουν τέσσερις κατηγορίες προβλημάτων που μπορούν να παρουσιαστούν όταν δημιουργείτε ένα προσαρμοσμένο πυρήνα:</p></div><div class=dlist><dl><dt class=hdlist1>Αποτυχία της εντολής <code>config</code></dt><dd><p>Αν η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> αποτυγχάνει όταν της δίνετε την περιγραφή του πυρήνα σας, έχετε κατά πάσα πιθανότητα, κάνει κάποιο απλό λάθος. Ευτυχώς, η <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> θα σας δείξει τον αριθμό γραμμής στον οποίο συνάντησε το πρόβλημα, και έτσι θα μπορέσετε εύκολα να το εντοπίσετε. Για παράδειγμα, αν δείτε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>config: line 17: syntax error</code></pre></div></div><div class=paragraph><p>Βεβαιωθείτε ότι η λέξη-κλειδί στη γραμμή αυτή είναι σωστή, συγκρίνοντας τη με την αντίστοιχη στο αρχείο <span class=filename>GENERIC</span> ή σε άλλο αρχείο αναφοράς.</p></div></dd><dt class=hdlist1>Αποτυχία της εντολής <code>make</code></dt><dd><p>Αν αποτυγχάνει η εντολή <code>make</code>, συνήθως αυτό σημαίνει κάποιο λάθος στο αρχείο ρυθμίσεων το οποίο δεν είναι αρκετά σοβαρό για να το καταλάβει η <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a>. Κοιτάξτε ξανά το αρχείο ρυθμίσεων σας και αν ακόμα δεν μπορείτε να εντοπίσετε το πρόβλημα, στείλτε το μαζί με το αρχείο με mail στην <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>ηλεκτρονική λίστα γενικών ερωτήσεων του FreeBSD</a> και θα εντοπιστεί πολύ γρήγορα.</p><div class=dlist><dl><dt class=hdlist1>Ο πυρήνας δεν εκκινεί:<a id=kernelconfig-noboot></a></dt><dd><p>Αν ο νέος σας πυρήνας δεν εκκινεί ή αποτυγχάνει να αναγνωρίσει τις συσκευές σας, μην πανικοβάλλεστε! Ευτυχώς, το FreeBSD έχει ένα εξαιρετικό μηχανισμό για να επανέλθετε από μη-συμβατούς πυρήνες. Απλώς επιλέξτε τον πυρήνα από τον οποίο θέλετε να ξεκινήσετε μέσω του συστήματος εκκίνησης (boot loader) του FreeBSD. Έχετε πρόσβαση σε αυτό, την ώρα που εμφανίζεται το μενού επιλογών εκκίνησης. Επιλέξτε "Escape to a loader prompt", αριθμός έξι. Στην προτροπή που εμφανίζεται, γράψτε την εντολή <code>boot kernel.old</code> ή το όνομα αρχείου ενός άλλου πυρήνα που ξεκινάει κανονικά. Όταν φτιάχνετε ένα νέο πυρήνα, είναι πάντα καλή ιδέα να έχετε πρόχειρο ένα πυρήνα που ξέρετε ότι δουλεύει.</p><div class=paragraph><p>Αφού εκκινήσετε με ένα καλό πυρήνα, μπορείτε να ελέγξετε το αρχείο ρυθμίσεων σας από την αρχή, και να προσπαθήσετε ξανά. Μια χρήσιμη πηγή πληροφοριών είναι το αρχείο <span class=filename>/var/log/messages</span> το οποίο μεταξύ άλλων καταγράφει όλα τα μηνύματα του πυρήνα από κάθε επιτυχημένη εκκίνηση. Επίσης η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> θα σας δείξει όλα τα μηνύματα του πυρήνα της τρέχουσας εκκίνησης.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν έχετε πρόβλημα στη δημιουργία πυρήνα, βεβαιωθείτε ότι έχετε κρατήσει ένα πυρήνα <span class=filename>GENERIC</span>, ή κάποιο άλλο που γνωρίζετε ότι λειτουργεί, χρησιμοποιώντας ένα διαφορετικό όνομα ώστε να μη διαγραφεί στην επόμενη μεταγλώττιση. Δεν μπορείτε να βασιστείτε στον πυρήνα <span class=filename>kernel.old</span>, γιατί κάθε φορά που εγκαθιστάτε νέο πυρήνα, το <span class=filename>kernel.old</span> αντικαθίσταται με τον τελευταίο εγκατεστημένο πυρήνα, ο οποίος μπορεί να μην λειτουργεί. Επίσης, όσο το δυνατόν πιο σύντομα, μετακινήστε τον πυρήνα που λειτουργεί στην σωστή θέση, <span class=filename>/boot/kernel</span>, διαφορετικά εντολές όπως η <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> ίσως να μη λειτουργούν σωστά. Για να το κάνετε αυτό, απλώς μετονομάστε τον κατάλογο που περιέχει τον καλό πυρήνα, π.χ:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /boot/kernel /boot/kernel.bad</span>
<span class=c># mv /boot/kernel.good /boot/kernel</span></code></pre></div></div></td></tr></tbody></table></div></dd></dl></div></dd><dt class=hdlist1>Ο νέος πυρήνας λειτουργεί, αλλά η <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> δεν λειτουργεί πλέον</dt><dd><p>Αν εγκαταστήσετε πυρήνα διαφορετικής έκδοσης από αυτόν με τον οποίο έχουν φτιαχτεί τα εργαλεία συστήματος, για παράδειγμα εάν βάλετε ένα πυρήνα της σειράς -CURRENT σε ένα σύστημα -RELEASE, πολλές από τις εντολές που σχετίζονται με την κατάσταση του συστήματος όπως ή <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> και η <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a> δεν θα λειτουργούν πλέον. Θα πρέπει να <a href=./#makeworld>μεταγλωττίσετε και να εγκαταστήσετε όλο το βασικό σύστημα (world)</a> χρησιμοποιώντας ίδια έκδοση του πηγαίου κώδικα με αυτή του πυρήνα σας. Αυτός είναι και ένας λόγος για τον οποίο δεν είναι συνήθως καλή ιδέα να χρησιμοποιείτε διαφορετική έκδοση πυρήνα από το υπόλοιπο του λειτουργικού συστήματος.</p></dd></dl></div></div></div></div><div class=sect1><h2 id=printing>Chapter 16. Εκτυπώσεις<a class=anchor href=#printing></a></h2><div class=sectionbody><div class=sect2><h3 id=printing-synopsis>16.1. Σύνοψη<a class=anchor href=#printing-synopsis></a></h3><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε το FreeBSD για να κάνετε εκτυπώσεις σε διάφορους τύπους εκτυπωτών, από τον παλαιότερο κρουστικό ως τον πιο σύγχρονο laser εκτυπωτή, καθώς και οποιασδήποτε άλλης τεχνολογίας ανάμεσα τους, και να δημιουργήσετε εκτυπώσεις υψηλής ποιότητας με τις εφαρμογές που εκτελείτε.</p></div><div class=paragraph><p>Το FreeBSD μπορεί επίσης να ρυθμιστεί ώστε να λειτουργεί ως εξυπηρετητής εκτυπώσεων δικτύου. Με αυτή τη δυνατότητα το FreeBSD μπορεί να λαμβάνει εργασίες εκτύπωσης από διάφορους άλλους υπολογιστές, συμπεριλαμβανομένων υπολογιστών FreeBSD, Windows® και Mac OS®. Το FreeBSD μπορεί να εξασφαλίζει ότι μόνο μια εργασία θα τυπώνεται κάθε χρονική στιγμή και μπορεί να τηρεί στατιστικά για τους χρήστες και τα μηχανήματα που θα κάνουν τις περισσότερες εκτυπώσεις, να παράγει σελίδες "banner" που να δείχνουν σε ποιόν ανήκει η κάθε εκτύπωση, και πολλά άλλα.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να ρυθμίσετε την ουρά εκτυπώσεων (print spooler) του FreeBSD.</p></li><li><p>Πως να εγκαθιστάτε φίλτρα εκτύπωσης, να χειρίζεστε ειδικές εργασίες εκτύπωσης (π.χ. τη μετατροπή εισερχόμενων κειμένων σε μορφές εκτύπωσης που είναι κατανοητές από τους εκτυπωτές σας).</p></li><li><p>Πως να ενεργοποιήσετε σελίδες τύπου κεφαλίδας ή banner στις εκτυπώσεις σας.</p></li><li><p>Πως να εκτυπώνετε σε εκτυπωτές που είναι συνδεδεμένοι σε άλλους υπολογιστές.</p></li><li><p>Πως να εκτυπώνετε σε εκτυπωτές που είναι συνδεδεμένοι απευθείας στο δίκτυο.</p></li><li><p>Πως να ελέγχετε τους περιορισμούς εκτύπωσης, συμπεριλαμβανομένων των περιορισμών μεγέθους των εργασιών εκτύπωσης, και πως να παρεμποδίζετε την δυνατότητα εκτύπωσης σε συγκεκριμένους χρήστες.</p></li><li><p>Πως να κρατήσετε στατιστικά για τον εκτυπωτή, και καταγραφή για τη χρήση του εκτυπωτή από κάθε χρήστη.</p></li><li><p>Πως να αντιμετωπίσετε προβλήματα στις εκτυπώσεις.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να γνωρίζετε πως να ρυθμίσετε και να εγκαταστήσετε ένα νέο πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=printing-intro-spooler>16.2. Εισαγωγή<a class=anchor href=#printing-intro-spooler></a></h3><div class=paragraph><p>Για να χρησιμοποιήσετε εκτυπωτές στο FreeBSD, θα χρειαστεί να ρυθμίσετε τη λειτουργία τους με το σύστημα παροχέτευσης (spooling) εκτυπωτών γραμμής του Berkeley, γνωστό επίσης και ως σύστημα παροχέτευσης LPD, ή απλά LPD. Αυτό είναι το προκαθορισμένο σύστημα ελέγχου εκτυπωτών στο FreeBSD. Το κεφάλαιο αυτό είναι μια εισαγωγή στο LPD και θα σας καθοδηγήσει στις ρυθμίσεις του.</p></div><div class=paragraph><p>Εάν σας είναι οικείο το LPD ή κάποιο άλλο σύστημα παροχέτευσης εκτυπωτών, τότε μπορείτε να μεταπηδήσετε στην ενότητα <a href=#printing-intro-setup>Βασική Εγκατάσταση</a>.</p></div><div class=paragraph><p>Το LPD μπορεί να ελέγχει εξ' ολοκλήρου όλες τις λειτουργίες των εκτυπωτών ενός υπολογιστή. Είναι κυρίως υπεύθυνο για ένα πλήθος λειτουργιών:</p></div><div class=ulist><ul><li><p>Ελέγχει την πρόσβαση σε απευθείας συνδεμένους εκτυπωτές και εκτυπωτές προσαρτημένους σε άλλους κόμβους στο δίκτυο.</p></li><li><p>Επιτρέπει σε χρήστες να στέλνουν αρχεία προς εκτύπωση. Οι αποστολές αυτές είναι γνωστές ως <em>εργασίες (jobs)</em>.</p></li><li><p>Διατηρεί <em>ουρά αναμονής (queue)</em> για κάθε εκτυπωτή, ώστε να προλαμβάνει την ταυτόχρονη πρόσβαση από πολλούς χρήστες.</p></li><li><p>Μπορεί να εκτυπώνει <em>σελίδες κεφαλίδας</em> (γνωστές επίσης ως <em>banner</em> ή <em>σελίδες burst</em>) ώστε οι χρήστες να μπορούν εύκολα να ξεχωρίσουν τις εργασίες τους μέσα στην στοίβα εκτυπώσεων.</p></li><li><p>Φροντίζει για την ορθότητα των παραμέτρων επικοινωνίας των εκτυπωτών που είναι συνδεδεμένοι σε σειριακές θύρες.</p></li><li><p>Μπορεί μέσω του δικτύου να στείλει εργασίες σε σύστημα παροχέτευσης LPD διαφορετικού υπολογιστή.</p></li><li><p>Μπορεί να εκτελέσει διάφορα φίλτρα για να προσαρμόσει εργασίες ώστε να είναι δυνατή η εκτύπωση τους σε εκτυπωτές που χρησιμοποιούν διαφορετικές γλώσσες ή έχουν διαφορετικές δυνατότητες.</p></li><li><p>Μπορεί να κάνει καταμέτρηση χρήσης του εκτυπωτή.</p></li></ul></div><div class=paragraph><p>Μέσω του αρχείου ρύθμισης (<span class=filename>/etc/printcap</span>), και με τη βοήθεια ειδικών προγραμμάτων φίλτρων, μπορείτε να ενεργοποιήσετε το σύστημα LPD να κάνει όλες ή κάποιες από τις παραπάνω εργασίες σε μια μεγάλη γκάμα συσκευών εκτύπωσης.</p></div><div class=sect3><h4 id=printing-intro-why>16.2.1. Γιατί θα πρέπει να χρησιμοποιείτε τον Spooler<a class=anchor href=#printing-intro-why></a></h4><div class=paragraph><p>Αν είστε ο μοναδικός χρήστης του συστήματος, θα αναρωτιέστε γιατί θα έπρεπε να ενδιαφερθείτε για τον spooler αφού δεν χρειάζεστε έλεγχο πρόσβασης, σελίδες κεφαλίδας, ή αναφορές εκτύπωσης. Αν και μπορείτε να ενεργοποιήσετε την άμεση πρόσβαση στον εκτυπωτή, είναι καλύτερα να χρησιμοποιείτε τον spooler για τους παρακάτω λόγους:</p></div><div class=ulist><ul><li><p>το LPD εκτυπώνει τις εργασίες στο παρασκήνιο, δεν χρειάζεται να περιμένετε να αντιγραφούν τα δεδομένα στον εκτυπωτή.</p></li><li><p>Το LPD μπορεί άνετα να εκτελεί μια εργασία εκτύπωσης διαμέσου φίλτρων και να προσθέτει κεφαλίδες ημερομηνίας/ώρας ή να μετατρέπει κάποιο ειδικό τύπο αρχείου (όπως ένα αρχείο TeX DVI) σε ένα τύπο κατανοητό από τον εκτυπωτή σας. Αυτές οι διαδικασίες δεν χρειάζεται να γίνονται χειροκίνητα.</p></li><li><p>Πολλά από τα ελεύθερα και εμπορικά διαθέσιμα προγράμματα που παρέχουν διευκολύνσεις στην εκτύπωση, συνήθως επιζητούν να επικοινωνήσουν με τον spooler του συστήματος σας. Ρυθμίζοντας το σύστημα παροχέτευσης, θα μπορείτε ευκολότερα να υποστηρίζετε λογισμικό τρίτων, που μπορεί ήδη να έχετε ή που πρόκειται να εγκαταστήσετε στο μέλλον.</p></li></ul></div></div></div><div class=sect2><h3 id=printing-intro-setup>16.3. Βασική Εγκατάσταση<a class=anchor href=#printing-intro-setup></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα αρχεία συσκευών για τις σειριακές θύρες μετονομάστηκαν από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν την τεκμηρίωση που ακολουθεί με βάση αυτές τις αλλαγές.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να χρησιμοποιήσετε εκτυπωτές με το σύστημα παροχέτευσης LPD, θα πρέπει να εγκαταστήσετε τόσο το hardware του εκτυπωτή σας όσο και το λογισμικό LPD. Αυτό το έγγραφο περιγράφει την εγκατάσταση σε δύο στάδια:</p></div><div class=ulist><ul><li><p>Δείτε την ενότητα <a href=#printing-simple>Βασικές Ρυθμίσεις Εκτυπωτών</a> για να μάθετε πως γίνεται η σύνδεση εκτυπωτών, με ποιο τρόπο επικοινωνεί το LPD με τους εκτυπωτές, και πως να εκτυπώνετε απλά αρχεία κειμένου.</p></li><li><p>Δείτε την ενότητα <a href=#printing-advanced>Ρυθμίσεις Εκτυπωτών για Προχωρημένους</a> για να μάθετε πως να εκτυπώνετε αρχεία ειδικής μορφής διαφόρων τύπων, πως να εκτυπώνετε σελίδες κεφαλίδας, πως να εκτυπώνετε σε ένα δίκτυο, πως να ελέγχετε την πρόσβαση στους εκτυπωτές, και πως να χρησιμοποιείτε την καταγραφή εκτυπώσεων.</p></li></ul></div><div class=sect3><h4 id=printing-simple>16.3.1. Βασικές Ρυθμίσεις Εκτυπωτών<a class=anchor href=#printing-simple></a></h4><div class=paragraph><p>Αυτή η ενότητα περιγράφει πως να ρυθμίσετε το hardware του εκτυπωτή και το λογισμικό LPD. Παρέχει βασικές γνώσεις για τα εξής θέματα:</p></div><div class=ulist><ul><li><p>Η Ενότητα <a href=#printing-hardware>Ρυθμίσεις Hardware</a> υποδεικνύει πως να συνδέσετε τον εκτυπωτή σε μια θύρα του υπολογιστή σας.</p></li><li><p>Η Ενότητα <a href=#printing-software>Ρυθμίσεις Λογισμικού</a> υποδεικνύει πως να εγκαταστήσετε το αρχείο ρύθμισης του συστήματος παροχέτευσης LPD: το αρχείο <span class=filename>/etc/printcap</span>.</p></li></ul></div><div class=paragraph><p>Αν προσπαθείτε να εγκαταστήσετε έναν εκτυπωτή που δέχεται δεδομένα μέσω πρωτοκόλλου δικτύου και όχι μέσω διασύνδεσης τοπικής θύρας, τότε δείτε την ενότητα <a href=#printing-advanced-network-net-if>Εκτυπωτές Με Συνδέσεις Δικτύου</a>.</p></div><div class=paragraph><p>Αν και αυτή η ενότητα ονομάζεται "Βασικές Ρυθμίσεις Εκτυπωτών", στην πραγματικότητα είναι αρκετά περίπλοκη. Το δυσκολότερο στάδιο στην εγκατάσταση είναι η επιτυχής λειτουργία στην επικοινωνία του εκτυπωτή με τον υπολογιστή σας και το σύστημα παροχέτευσης LPD. Οι επιλογές για προχωρημένους, όπως οι σελίδες κεφαλίδας και αναφοράς είναι σχετικά εύκολες να επιτευχθούν, μετά την επιτυχή ρύθμιση της βασικής λειτουργίας εκτύπωσης.</p></div><div class=sect4><h5 id=printing-hardware>16.3.1.1. Ρυθμίσεις Hardware<a class=anchor href=#printing-hardware></a></h5><div class=paragraph><p>Αυτή η ενότητα εξηγεί τους διάφορους τρόπους σύνδεσης του εκτυπωτή με τον υπολογιστή σας. Περιγράφει τους διάφορους τύπους θυρών και καλωδίων, και τις ρυθμίσεις που πρέπει να κάνετε στον πυρήνα για να ενεργοποιήσετε την επικοινωνία μεταξύ FreeBSD και εκτυπωτή.</p></div><div class=paragraph><p>Αν ήδη έχετε καταφέρει να συνδέσετε τον εκτυπωτή σας και έχετε εκτυπώσει επιτυχώς σε άλλο λειτουργικό σύστημα, τότε μπορείτε να μεταβείτε κατευθείαν στην ενότητα <a href=#printing-software>Ρυθμίσεις Λογισμικού</a>.</p></div><div class=sect5><h6 id=printing-ports>16.3.1.1.1. Θύρες και Καλώδια<a class=anchor href=#printing-ports></a></h6><div class=paragraph><p>Οι εκτυπωτές που διατίθενται σήμερα για χρήση με Η/Υ παρέχονται με μία ή περισσότερες εκ των ακολούθων τριών διασυνδέσεων:</p></div><div class=ulist><ul><li><p>Οι <em>Σειριακές</em> διασυνδέσεις, γνωστές και ως RS-232 ή θύρες COM, χρησιμοποιούν την σειριακή θύρα του υπολογιστή σας για να στείλουν δεδομένα στον εκτυπωτή. Οι σειριακές διασυνδέσεις είναι συνήθεις στην βιομηχανία κατασκευής Η/Υ και τα καλώδια είναι εκτενώς διαδεδομένα και επίσης εύκολα να κατασκευαστούν. Οι σειριακές διασυνδέσεις μερικές φορές χρειάζονται ειδικά καλώδια και μπορεί να σας ζητηθούν πολύπλοκες επικοινωνιακές ρυθμίσεις. Οι περισσότερες σειριακές θύρες των Η/Υ έχουν μέγιστη ταχύτητα μετάδοσης 115200 bps, κάνοντας δύσκολη την εργασία εκτύπωσης γραφικών μεγάλων διαστάσεων.</p></li><li><p>Οι <em>Παράλληλες</em> διασυνδέσεις χρησιμοποιούν την παράλληλη θύρα του υπολογιστή σας για να στέλνουν δεδομένα στον εκτυπωτή. Οι παράλληλες διασυνδέσεις είναι διαδεδομένες στο εμπόριο και είναι γρηγορότερες από τις σειριακές RS-232. Τα καλώδια διατίθενται έτοιμα, αλλά είναι δυσκολότερο να κατασκευαστούν χειρωνακτικά. Με τις παράλληλες διασυνδέσεις δεν προβλέπονται επιλογές ρύθμισης επικοινωνίας, κάνοντας την ρύθμιση τους εξαιρετικά απλή.</p><div class=paragraph><p>Οι παράλληλες διασυνδέσεις είναι γνωστές και ως διασυνδέσεις "Centronics", ονομασία προερχόμενη από τον τύπο του ακροδέκτη του εκτυπωτή.</p></div></li><li><p>Οι διασυνδέσεις USB, συντομογραφία από το Universal Serial Bus, δουλεύουν σε ακόμη μεγαλύτερες ταχύτητες από την παράλληλη και την RS-232 σειριακή διασύνδεση. Τα καλώδια τους είναι απλά και φτηνά. Η USB είναι ανώτερη από την Σειριακή RS-232 και από την Παράλληλη στην εκτύπωση, αλλά δυστυχώς δεν υποστηρίζεται καλά από τα συστήματα UNIX®. Ένας τρόπος για να αποφύγετε αυτό το πρόβλημα είναι να αγοράσετε εκτυπωτή που φέρει διασύνδεση USB και Παράλληλη, όπως συμβαίνει με πολλούς εκτυπωτές.</p></li></ul></div><div class=paragraph><p>Γενικά, οι Παράλληλες διασυνδέσεις προσφέρουν συνήθως μίας κατεύθυνσης επικοινωνία (από τον υπολογιστή στον εκτυπωτή) ενώ η σειριακή και η USB δίνουν αμφίδρομη. Στο FreeBSD οι πιο πρόσφατες παράλληλες θύρες (EPP και ECP) καταφέρνουν αμφίδρομη επικοινωνία με τους εκτυπωτές, όταν χρησιμοποιούνται καλώδια που συμμορφώνονται με το πρότυπο IEEE-1284.</p></div><div class=paragraph><p>Η αμφίδρομη επικοινωνία με εκτυπωτές διαμέσου παράλληλης θύρας μπορεί να επιτευχθεί γενικά με δύο τρόπους. Ο πρώτος τρόπος χρησιμοποιεί ένα προσαρμοσμένο πρόγραμμα οδήγησης εκτυπωτή, ώστε να μπορεί το FreeBSD να συνομιλεί στην γλώσσα του εκτυπωτή. Αυτό είναι σύνηθες με εκτυπωτές inkjet και μπορεί επίσης να χρησιμοποιηθεί για αναφορές διαθέσιμης ποσότητας μελανιού και για άλλες πληροφορίες λειτουργίας. Η δεύτερη μέθοδος χρησιμοποιείται όταν ο εκτυπωτής έχει δυνατότητα υποστήριξης PostScript®.</p></div><div class=paragraph><p>Οι εργασίες PostScript® είναι στην πραγματικότητα προγράμματα που αποστέλλονται στον εκτυπωτή, δεν είναι απαραίτητο να παράγουν εκτυπώσεις, ενώ μπορούν να επιστρέψουν το αποτέλεσμα τους απευθείας στον υπολογιστή. Το PostScript® χρησιμοποιεί αμφίδρομη επικοινωνία για να ενημερώσει τον υπολογιστή για τυχόν προβλήματα, όπως σφάλματα στο πρόγραμμα PostScript® ή μπλοκάρισμα τροφοδοσίας χαρτιού. Οι χρήστες σας, θα σας είναι ευγνώμονες για αυτές τις πληροφορίες. Επιπλέον, ο καλύτερος τρόπος για να κάνετε σωστή καταμέτρηση με ένα αμφίδρομο εκτυπωτή PostScript® είναι: να ρωτήσετε τον εκτυπωτή για την συνολική καταμέτρηση των σελίδων του (πόσες σελίδες εκτύπωσε σε όλη τη διάρκεια ζωής του), μετά να αποστείλετε την εργασία του χρήστη, και έπειτα να ξαναρωτήσετε για την καταμέτρηση των σελίδων του. Αφαιρέστε τις δύο τιμές και θα γνωρίζετε πόσες σελίδες να χρεώσετε στον χρήστη.</p></div></div><div class=sect5><h6 id=printing-parallel>16.3.1.1.2. Παράλληλες Θύρες<a class=anchor href=#printing-parallel></a></h6><div class=paragraph><p>Για να συνδέσετε έναν εκτυπωτή σε παράλληλη θύρα, συνδέστε το καλώδιο Centronics μεταξύ εκτυπωτή και υπολογιστή. Οι οδηγίες που συνοδεύουν τον εκτυπωτή και τον υπολογιστή θα σας καθοδηγήσουν να ολοκληρώσετε την σύνδεση.</p></div><div class=paragraph><p>Θυμηθείτε ποια παράλληλη θύρα χρησιμοποιείτε στον υπολογιστή. Η πρώτη παράλληλη θύρα στο FreeBSD είναι η <span class=filename>ppc0</span>, η δεύτερη είναι η <span class=filename>ppc1</span>, και ούτω καθεξής. Το όνομα συσκευής του εκτυπωτή χρησιμοποιεί την ίδια αρίθμηση: <span class=filename>/dev/lpt0</span> για τον εκτυπωτή στην πρώτη παράλληλη θύρα κ.τ.λ.</p></div></div><div class=sect5><h6 id=printing-serial>16.3.1.1.3. Σειριακές Θύρες<a class=anchor href=#printing-serial></a></h6><div class=paragraph><p>Για να συνδέσετε έναν εκτυπωτή χρησιμοποιώντας σειριακή διασύνδεση, συνδέστε το κατάλληλο σειριακό καλώδιο μεταξύ εκτυπωτή και υπολογιστή. Οι οδηγίες που συνοδεύουν τον εκτυπωτή και τον υπολογιστή σας, θα σας καθοδηγήσουν να ολοκληρώσετε την σύνδεση.</p></div><div class=paragraph><p>Αν δεν είστε σίγουροι ποιο είναι το "κατάλληλο σειριακό καλώδιο", μπορείτε να δοκιμάσετε μία από τις ακόλουθες εναλλακτικές:</p></div><div class=ulist><ul><li><p>Ένα καλώδιο <em>modem</em> ενώνει κάθε pin του ακροδέκτη από τη μια πλευρά του καλωδίου κατευθείαν με το αντίστοιχο pin του ακροδέκτη στο άλλο άκρο. Αυτός ο τύπος καλωδίου είναι γνωστός και ως καλώδιο "DTE-to-DCE".</p></li><li><p>Ένα καλώδιο <em>null-modem</em> ενώνει κατευθείαν μερικά pins, ανταλλάσσει μερικά άλλα (για παράδειγμα, τα pins αποστολής και λήψης), ενώ βραχυκυκλώνει μερικά άλλα, εσωτερικά, στο προστατευτικό κάλυμμα κάθε ακροδέκτη. Αυτός ο τύπος καλωδίου είναι γνωστός και ως καλώδιο "DTE-to-DTE".</p></li><li><p>Ένα καλώδιο <em>σειριακού εκτυπωτή</em>, που απαιτείται από κάποιους λιγότερο συνηθισμένους εκτυπωτές, είναι σαν το καλώδιο null-modem, αλλά στέλνει ισοδύναμα σήματα και στα δύο άκρα αντί να τα βραχυκυκλώνει εσωτερικά.</p></li></ul></div><div class=paragraph><p>Θα πρέπει επίσης να ρυθμίσετε τις παραμέτρους επικοινωνίας του εκτυπωτή, συνήθως από τον μπροστινό πίνακα ελέγχου ή από τους DIP διακόπτες του. Επιλέξτε την μέγιστη τιμή <code>bps</code> (bits per second = bits ανά δευτερόλεπτο, αναφέρεται και ως <em>ρυθμός baud</em>) που υποστηρίζουν ο υπολογιστής και ο εκτυπωτής σας. Επιλέξτε 7 ή 8 data bits, none, even, ή odd parity, και 1 ή 2 stop bits. Επίσης επιλέξτε ένα πρωτόκολλο ελέγχου ροής: είτε none, ή XON/XOFF (αναφέρεται και ως έλεγχος ροής "in-band" ή "software"). Να θυμάστε αυτές τις ρυθμίσεις, για το στάδιο ρύθμισης λογισμικού που ακολουθεί.</p></div></div></div><div class=sect4><h5 id=printing-software>16.3.1.2. Ρυθμίσεις Λογισμικού<a class=anchor href=#printing-software></a></h5><div class=paragraph><p>Αυτή η ενότητα περιγράφει τις αναγκαίες ρυθμίσεις που πρέπει να γίνουν στο λογισμικό για να μπορείτε να εκτυπώνετε με το σύστημα παροχέτευσης εκτυπωτών LPD στο FreeBSD.</p></div><div class=paragraph><p>Μια γενική άποψη των ενεργειών που πρέπει να ακολουθήσετε είναι:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Ρυθμίστε τον πυρήνα σας, αν είναι αναγκαίο, για την θύρα που χρησιμοποιείτε για τον εκτυπωτή σας. Οι απαραίτητες ρυθμίσεις περιγράφονται στην ενότητα <a href=#printing-kernel>Ρυθμίσεις Πυρήνα</a>.</p></li><li><p>Ρυθμίστε την κατάσταση επικοινωνίας για την παράλληλη θύρα, αν πρόκειται να την χρησιμοποιήσετε. Η ενότητα <a href=#printing-parallel-port-mode>Ρυθμίσεις Κατάστασης Επικοινωνίας για την Παράλληλη Θύρα</a> περιέχει λεπτομέρειες.</p></li><li><p>Ελέγξτε αν το λειτουργικό σύστημα μπορεί να στείλει δεδομένα στον εκτυπωτή. Η ενότητα <a href=#printing-testing>Έλεγχος Επικοινωνίας του Εκτυπωτή</a> παρέχει μερικές συμβουλές για το πως θα μπορούσε να γίνει ο έλεγχος.</p></li><li><p>Ρυθμίστε το LPD για τον εκτυπωτή σας, τροποποιώντας το αρχείο <span class=filename>/etc/printcap</span>. Θα βρείτε οδηγίες για αυτές τις ρυθμίσεις σε επόμενο τμήμα αυτού του κεφαλαίου.</p></li></ol></div><div class=sect5><h6 id=printing-kernel>16.3.1.2.1. Ρυθμίσεις Πυρήνα<a class=anchor href=#printing-kernel></a></h6><div class=paragraph><p>Ο πυρήνας του λειτουργικού συστήματος έχει μεταγλωττιστεί έτσι ώστε να δουλεύει με ένα συγκεκριμένο σύνολο συσκευών. Η σειριακή και η παράλληλη διασύνδεση του εκτυπωτή είναι μέρος αυτού του συνόλου. Επομένως, ίσως να είναι αναγκαίο να προσθέσετε υποστήριξη για κάποια πρόσθετη σειριακή ή παράλληλη θύρα, αν δεν είναι ήδη ρυθμισμένη στον πυρήνα σας.</p></div><div class=paragraph><p>Για να ελέγξετε αν ο πυρήνας σας μπορεί να υποστηρίξει μια σειριακή διασύνδεση, πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep sioN /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>Όπου <em>N</em> είναι ο αριθμός της σειριακής θύρας, ξεκινώντας από το μηδέν. Αν δείτε στην έξοδο του τερματικού σας κάτι παρόμοιο με:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio2 at port 0x3e8-0x3ef irq 5 on isa
sio2: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>τότε ο πυρήνας υποστηρίζει αυτή τη θύρα.</p></div><div class=paragraph><p>Για να ελέγξετε αν ο πυρήνας σας υποστηρίζει παράλληλες διασυνδέσεις, πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep ppcN /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>Όπου <em>N</em> είναι ο αριθμός της παράλληλης θύρας, ξεκινώντας από το μηδέν. Αν δείτε στην έξοδο του τερματικού σας κάτι παρόμοιο με:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppc0: &lt;Parallel port&gt; at port 0x378-0x37f irq 7 on isa0
ppc0: SMC-like chipset <span class=o>(</span>ECP/EPP/PS2/NIBBLE<span class=o>)</span> <span class=k>in </span>COMPATIBLE mode
ppc0: FIFO with 16/16/8 bytes threshold</code></pre></div></div><div class=paragraph><p>τότε ο πυρήνας υποστηρίζει αυτή τη θύρα.</p></div><div class=paragraph><p>Για να μπορεί το λειτουργικό σύστημα να αναγνωρίζει και να χρησιμοποιεί την θύρα (παράλληλη ή σειριακή) για τον εκτυπωτή σας, ίσως χρειαστεί να επαναπροσαρμόσετε τον πυρήνα σας.</p></div><div class=paragraph><p>Για την υποστήριξη σειριακής θύρας, δείτε την ενότητα στις ρυθμίσεις του πυρήνα. Για την υποστήριξη παράλληλης θύρας, δείτε την ίδια ενότητα <em>και</em> την ενότητα που ακολουθεί.</p></div></div></div><div class=sect4><h5 id=printing-parallel-port-mode>16.3.1.3. Ρυθμίσεις Κατάστασης Επικοινωνίας για την Παράλληλη Θύρα<a class=anchor href=#printing-parallel-port-mode></a></h5><div class=paragraph><p>Όταν χρησιμοποιείτε την παράλληλη διασύνδεση, μπορείτε να επιλέξετε αν η επικοινωνία του FreeBSD με τον εκτυπωτή θα είναι τύπου interrupt-driven ή polled. Ο γενικός οδηγός συσκευής του εκτυπωτή (<a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a>) στο FreeBSD χρησιμοποιεί το σύστημα <a href="https://man.freebsd.org/cgi/man.cgi?query=ppbus&amp;sektion=4&amp;format=html">ppbus(4)</a>, το οποίο ελέγχει την θύρα του chipset με τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=ppc&amp;sektion=4&amp;format=html">ppc(4)</a>.</p></div><div class=ulist><ul><li><p>Η μέθοδος <em>interrupt-driven</em> είναι προεπιλεγμένη στον πυρήνα GENERIC. Με αυτή τη μέθοδο, το λειτουργικό σύστημα χρησιμοποιεί ένα σήμα IRQ για να προσδιορίσει αν ο εκτυπωτής είναι έτοιμος για δεδομένα.</p></li><li><p>Η μέθοδος <em>polled</em> οδηγεί το λειτουργικό σύστημα να ζητά κατά επανάληψη από τον εκτυπωτή αν είναι έτοιμος για πρόσθετα δεδομένα. Όταν απαντήσει θετικά, ο πυρήνας στέλνει πρόσθετα δεδομένα.</p></li></ul></div><div class=paragraph><p>Η μέθοδος interrupt-driven είναι συνήθως κάπως γρηγορότερη αλλά χρησιμοποιεί μια πολύτιμη γραμμή IRQ. Έχει παρατηρηθεί πως κάποιοι σύγχρονοι εκτυπωτές HP δε δουλεύουν σωστά σε κατάσταση interrupt, πιθανώς λόγω κάποιων (όχι απόλυτα εξακριβωμένων) προβλημάτων συγχρονισμού. Αυτοί οι εκτυπωτές χρειάζονται την μέθοδο polled. Θα πρέπει να χρησιμοποιείτε την αποτελεσματικότερη κατάσταση λειτουργίας. Κάποιοι εκτυπωτές δουλεύουν και στις δυο καταστάσεις, αλλά είναι οδυνηρά αργοί στην κατάσταση λειτουργίας interrupt.</p></div><div class=paragraph><p>Μπορείτε να ρυθμίσετε την κατάσταση επικοινωνίας με δύο τρόπους: ρυθμίζοντας τον πυρήνα ή χρησιμοποιώντας το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a>.</p></div><div class=paragraph><p><em>Για να θέσετε την κατάσταση επικοινωνίας ρυθμίζοντας τον πυρήνα:</em></p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Επεξεργαστείτε το αρχείο ρύθμισης του πυρήνα. Δείτε την καταχώριση <code>ppc0</code>. Αν εγκαθιστάτε την δεύτερη παράλληλη θύρα, τότε χρησιμοποιείστε <code>ppc1</code>. Για την τρίτη θύρα <code>ppc2</code> και ούτω καθεξής.</p><div class=ulist><ul><li><p>Αν επιθυμείτε κατάσταση λειτουργίας interrupt-driven, επεξεργαστείτε την ακόλουθη γραμμή:</p><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.irq=&#34;N&#34;</pre></div></div><div class=paragraph><p>στο αρχείο <span class=filename>/boot/device.hints</span> και αντικαταστήστε το <em>N</em> με τον σωστό αριθμό IRQ. Το αρχείο ρύθμισης του πυρήνα πρέπει επίσης να περιέχει τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=ppc&amp;sektion=4&amp;format=html">ppc(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>device ppc</code></pre></div></div></li><li><p>Αν επιθυμείτε κατάσταση λειτουργίας polled, διαγράψτε από το αρχείο <span class=filename>/boot/device.hints</span>, την ακόλουθη γραμμή:</p><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.irq=&#34;N&#34;</pre></div></div></li></ul></div><div class=paragraph><p>Σε μερικές περιπτώσεις, το παραπάνω δεν είναι αρκετό για να θέσετε την θύρα σε κατάσταση polled. Τις περισσότερες φορές το πρόβλημα προέρχεται από τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, ο οποίος έχει την ευχέρεια να εξετάζει και να προσαρτά συσκευές, και επομένως, να ελέγχει τον τρόπο πρόσβασης στην θύρα του εκτυπωτή. Θα πρέπει να ελέγξετε τις ρυθμίσεις του <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> για να διορθώσετε αυτό το πρόβλημα.</p></div></li><li><p>Αποθηκεύστε το αρχείο. Ρυθμίστε, μεταγλωττίστε, και εγκαταστήστε τον πυρήνα, και έπειτα κάντε επανεκκίνηση. Για περισσότερες λεπτομέρειες, δείτε τις <a href=./#kernelconfig>ρυθμίσεις του πυρήνα</a>.</p></li></ol></div><div class=paragraph><p><em>Για να θέσετε την κατάσταση επικοινωνίας με το</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a>:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Πληκτρολογήστε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptcontrol -i -d /dev/lptN</span></code></pre></div></div><div class=paragraph><p>για να θέσετε την κατάσταση λειτουργίας interrupt-driven για το <code>lptN</code>.</p></div></li><li><p>Πληκτρολογήστε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptcontrol -p -d /dev/lptN</span></code></pre></div></div><div class=paragraph><p>για να θέσετε την κατάσταση λειτουργίας polled για το <code>lptN</code>.</p></div></li></ol></div><div class=paragraph><p>Θα μπορούσατε να καταχωρίσετε αυτές τις εντολές στο δικό σας αρχείο <span class=filename>/etc/rc.local</span>. Έτσι θα εκτελούνται αυτόματα κατά την εκκίνηση του συστήματος σας. Για περισσότερες πληροφορίες δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a>.</p></div></div><div class=sect4><h5 id=printing-testing>16.3.1.4. Έλεγχος Επικοινωνίας του Εκτυπωτή<a class=anchor href=#printing-testing></a></h5><div class=paragraph><p>Πριν συνεχίσουμε να ρυθμίζουμε το σύστημα παροχέτευσης, θα πρέπει να βεβαιωθείτε ότι το λειτουργικό σύστημα μπορεί να στείλει επιτυχώς δεδομένα στον εκτυπωτή σας. Είναι ευκολότερο να κάνουμε ξεχωριστά την αποσφαλμάτωση επικοινωνίας του εκτυπωτή και την αποσφαλμάτωση του συστήματος παροχέτευσης.</p></div><div class=paragraph><p>Θα ελέγξουμε τον εκτυπωτή στέλνοντας μερικά δεδομένα κειμένου. Για εκείνους τους εκτυπωτές που μπορούν να εκτυπώνουν άμεσα τους χαρακτήρες που έχουν αποσταλεί, το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> είναι τέλειο: Παράγει όλους τους εκτυπώσιμους χαρακτήρες (96) ASCII σε 96 γραμμές.</p></div><div class=paragraph><p>Για εκτυπωτές PostScript® (ή που βασίζονται σε άλλη γλώσσα), θα χρειαστεί να κάνουμε ένα πιο πολύπλοκο τεστ. Ένα μικρό πρόγραμμα PostScript®, όπως αυτό που ακολουθεί, επαρκεί:</p></div><div class="literalblock programlisting"><div class=content><pre>%!PS
100 100 moveto 300 300 lineto stroke
310 310 moveto /Helvetica findfont 12 scalefont setfont
(Is this thing working?) show
showpage</pre></div></div><div class=paragraph><p>Ο παραπάνω κώδικας PostScript® μπορεί να τοποθετηθεί σε ένα αρχείο και να χρησιμοποιηθεί όπως υποδεικνύουν τα παραδείγματα στις ακόλουθες ενότητες.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όταν αυτό το έγγραφο αναφέρεται σε μια γλώσσα εκτυπωτή, εννοείται μια γλώσσα όπως η PostScript®, αλλά όχι η PCL της Hewlett Packard - η PCL είναι μια γλώσσα ευρείας λειτουργικότητας η οποία επιτρέπει την ανάμιξη απλού κειμένου με ακολουθίες διαφυγής. Η PostScript® δεν μπορεί να εκτυπώσει άμεσα απλό κείμενο, και αυτός είναι ακριβώς ο τύπος της γλώσσας εκτυπωτή που θα πρέπει να διευθετήσουμε κατάλληλα.</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=printing-checking-parallel>16.3.1.4.1. Έλεγχος Παράλληλου Εκτυπωτή<a class=anchor href=#printing-checking-parallel></a></h6><div class=paragraph><p>Αυτή η ενότητα υποδεικνύει πως να ελέγξετε αν το FreeBSD μπορεί να επικοινωνήσει με έναν εκτυπωτή συνδεδεμένο σε παράλληλη θύρα.</p></div><div class=paragraph><p><em>Για να ελέγξετε έναν εκτυπωτή σε παράλληλη θύρα:</em></p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Γίνετε <code>root</code> με <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>.</p></li><li><p>Στείλτε δεδομένα στον εκτυπωτή.</p><div class=ulist><ul><li><p>Αν ο εκτυπωτής μπορεί να εκτυπώσει απλό κείμενο, τότε χρησιμοποιήστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>. Πληκτρολογήστε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptest &gt; /dev/lptN</span></code></pre></div></div><div class=paragraph><p>Όπου <em>N</em> είναι ο αριθμός της παράλληλης θύρας, ξεκινώντας από το μηδέν.</p></div></li><li><p>Εάν ο εκτυπωτής καταλαβαίνει PostScript® ή κάποια άλλη γλώσσα εκτυπωτών, τότε στείλτε ένα μικρό πρόγραμμα στον εκτυπωτή. Πληκτρολογήστε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat &gt; /dev/lptN</span></code></pre></div></div><div class=paragraph><p>Έπειτα πληκτρολογήστε το πρόγραμμα μία προς μία γραμμή, <em>προσεκτικά</em>, γιατί δεν μπορείτε να επεξεργαστείτε μια γραμμή αφότου έχετε πιέσει το πλήκτρο <code>RETURN</code> ή <code>ENTER</code>. Αφού τελειώσετε με την καταχώριση του προγράμματος, πιέστε <code>CONTROL+D</code>, ή άλλο πλήκτρο τερματισμού αρχείου.</p></div><div class=paragraph><p>Εναλλακτικά, μπορείτε να τοποθετήσετε το πρόγραμμα σε ένα αρχείο και να πληκτρολογήσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat file &gt; /dev/lptN</span></code></pre></div></div></li></ul></div><div class=paragraph><p>Όπου <em>file</em> είναι το όνομα του αρχείου που περιέχει το πρόγραμμα που θέλετε να στείλετε στον εκτυπωτή.</p></div></li></ol></div><div class=paragraph><p>Θα δείτε κάτι να εκτυπώνεται. Μην ανησυχείτε αν το κείμενο δεν φαίνεται σωστό. Θα το διορθώσουμε αργότερα.</p></div></div><div class=sect5><h6 id=printing-checking-serial>16.3.1.4.2. Έλεγχος Σειριακού Εκτυπωτή<a class=anchor href=#printing-checking-serial></a></h6><div class=paragraph><p>Αυτή η ενότητα υποδεικνύει πως να ελέγξετε αν το FreeBSD μπορεί να επικοινωνήσει με έναν εκτυπωτή συνδεδεμένο σε σειριακή θύρα.</p></div><div class=paragraph><p><em>Για να ελέγξετε έναν εκτυπωτή σε σειριακή θύρα:</em></p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Γίνετε <code>root</code> με <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>.</p></li><li><p>Επεξεργαστείτε το αρχείο <span class=filename>/etc/remote</span>. Προσθέστε την ακόλουθη καταχώριση:</p><div class="literalblock programlisting"><div class=content><pre>printer:dv=/dev/port:br#bps-rate:pa=parity</pre></div></div><div class=paragraph><p>Όπου <em>port</em> είναι η καταχώριση συσκευής για την σειριακή πόρτα (<code>ttyu0</code>, <code>ttyu1</code>, κτλ.), <em>bps-rate</em> είναι η ταχύτητα bits-per-second επικοινωνίας με τον εκτυπωτή, και <em>parity</em> η ισοτιμία που απαιτείται από τον εκτυπωτή (<code>even</code>, <code>odd</code>, <code>none</code>, ή <code>zero</code>).</p></div><div class=paragraph><p>Παρακάτω φαίνεται ένα υπόδειγμα καταχώρισης, για έναν εκτυπωτή συνδεδεμένο μέσω σειριακής γραμμής στην τρίτη σειριακή θύρα με ταχύτητα 19200 bps και χωρίς parity:</p></div><div class="literalblock programlisting"><div class=content><pre>printer:dv=/dev/ttyu2:br#19200:pa=none</pre></div></div></li><li><p>Συνδεθείτε στον εκτυπωτή με <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>. Πληκτρολογήστε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip printer</span></code></pre></div></div><div class=paragraph><p>Αν αυτό το στάδιο δεν δουλεύει, επεξεργαστείτε πάλι το αρχείο <span class=filename>/etc/remote</span> και προσπαθήστε το χρησιμοποιώντας <span class=filename>/dev/cuaaN</span> αντί για <span class=filename>/dev/ttyuN</span>.</p></div></li><li><p>Στείλτε δεδομένα στον εκτυπωτή.</p><div class=ulist><ul><li><p>Αν ο εκτυπωτής μπορεί να εκτυπώσει απλό κείμενο, χρησιμοποιήστε <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>. Γράψτε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nv>$lptest</span></code></pre></div></div></li><li><p>Εάν ο εκτυπωτής καταλαβαίνει PostScript® ή κάποια άλλη γλώσσα εκτυπωτών, τότε στείλτε ένα μικρό πρόγραμμα στον εκτυπωτή. Πληκτρολογήστε το πρόγραμμα, μία προς μία γραμμή, <em>πολύ προσεκτικά</em>, καθώς ο εκτυπωτής μπορεί να ερμηνεύει διαφορετικά την χρήση χαρακτήρων όπως το backspace ή άλλων που παράγονται από διάφορα πλήκτρα επεξεργασίας. Μπορεί επίσης να χρειαστεί να πληκτρολογήσετε κάποιο ειδικό πλήκτρο τερματισμού αρχείου για τον εκτυπωτή ώστε να γνωρίζει πότε ολοκληρώνεται το πρόγραμμα. Για εκτυπωτές PostScript®, πιέστε <code>CONTROL+D</code>.</p><div class=paragraph><p>Εναλλακτικά, μπορείτε να τοποθετήσετε το πρόγραμμα σε ένα αρχείο και να πληκτρολογήσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=o>&gt;</span>file</code></pre></div></div></li></ul></div><div class=paragraph><p>Όπου <em>file</em> είναι το όνομα του αρχείου που περιέχει το πρόγραμμα. Αφού το <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> στείλει το αρχείο, πιέστε το κατάλληλο πλήκτρο τερματισμού αρχείου, αν απαιτείται.</p></div></li></ol></div><div class=paragraph><p>Θα δείτε κάτι να εκτυπώνεται. Μην ανησυχείτε αν το κείμενο δεν φαίνεται σωστό. Θα το διορθώσουμε αργότερα.</p></div></div></div><div class=sect4><h5 id=printing-printcap>16.3.1.5. Ενεργοποίηση του Spooler: το Αρχείο <span class=filename>/etc/printcap</span><a class=anchor href=#printing-printcap></a></h5><div class=paragraph><p>Σε αυτό το σημείο, ο εκτυπωτής σας θα πρέπει να είναι συνδεμένος, ο πυρήνας σας ρυθμισμένος να επικοινωνεί μαζί του (αν χρειάζεται), και έχετε πετύχει να στείλετε κάποια δοκιμαστικά δεδομένα στον εκτυπωτή. Είστε τώρα έτοιμοι να ρυθμίσετε το LPD για να ελέγχετε την πρόσβαση στον εκτυπωτή σας.</p></div><div class=paragraph><p>Μπορείτε να ρυθμίσετε το LPD με επεξεργασία του αρχείου <span class=filename>/etc/printcap</span>. Το σύστημα παροχέτευσης LPD διαβάζει αυτό το αρχείο κάθε φορά που χρησιμοποιείται ο spooler, επομένως πιθανές αναβαθμίσεις του μπαίνουν άμεσα σε εφαρμογή.</p></div><div class=paragraph><p>Είναι εύκολο να κατανοήσετε την μορφή του αρχείου <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a>. Χρησιμοποιήστε τον κειμενογράφο που προτιμάτε για να κάνετε αλλαγές στο <span class=filename>/etc/printcap</span>. Η μορφή του είναι παρόμοια με άλλα αρχεία περιγραφής δυνατοτήτων, όπως τα <span class=filename>/usr/shared/misc/termcap</span> και <span class=filename>/etc/remote</span>. Δείτε την <a href="https://man.freebsd.org/cgi/man.cgi?query=cgetent&amp;sektion=3&amp;format=html">cgetent(3)</a> για λεπτομερείς πληροφορίες σχετικά με την μορφή του αρχείου.</p></div><div class=paragraph><p>Η πιο απλή ρύθμιση του spooler αποτελείται από τα ακόλουθα βήματα:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Επιλέξτε ένα όνομα (και λίγα βολικά παρωνύμια) για τον εκτυπωτή, και τοποθετήστε τα στο αρχείο <span class=filename>/etc/printcap</span>. Δείτε την ενότητα <a href=#printing-naming>Ονοματοδότηση Εκτυπωτή</a> για περισσότερες πληροφορίες σχετικά με την ονομασία των εκτυπωτών.</p></li><li><p>Απενεργοποιήστε τις σελίδες κεφαλίδας (είναι ενεργές από προεπιλογή) εισάγοντας την ικανότητα <code>sh</code>. Για περισσότερες πληροφορίες δείτε την ενότητα <a href=#printing-no-header-pages>Παρεμπόδιση Σελίδων Κεφαλίδας</a>.</p></li><li><p>Δημιουργήστε ένα κατάλογο παροχέτευσης, και καθορίστε την τοποθεσία του με την ικανότητα <code>sd</code>. Για περισσότερες πληροφορίες δείτε την ενότητα <a href=#printing-spooldir>Δημιουργία Καταλόγου Παροχέτευσης</a>.</p></li><li><p>Καθορίστε την κατάλληλη καταχώριση <span class=filename>/dev</span> για τον εκτυπωτή, και σημειώστε τη στο <span class=filename>/etc/printcap</span> με την ικανότητα <code>lp</code>. Για περισσότερες πληροφορίες, δείτε την ενότητα <a href=#printing-device>Αναγνώριση της Συσκευής Εκτύπωσης</a>. Επίσης, αν ο εκτυπωτής είναι σε σειριακή θύρα, εγκαταστήστε τις παραμέτρους επικοινωνίας με την ικανότητα <code>ms#</code> η οποία αναλύεται στην ενότητα <a href=#printing-commparam>Ρυθμίσεις Παραμέτρων Επικοινωνίας του Spooler</a>.</p></li><li><p>Εγκαταστήστε φίλτρα εισόδου απλού κειμένου. Δείτε την ενότητα <a href=#printing-textfilter>Εγκατάσταση Φίλτρου Κειμένου</a> για περισσότερες πληροφορίες.</p></li><li><p>Ελέγξτε την εγκατάσταση εκτυπώνοντας οτιδήποτε με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>. Περισσότερες πληροφορίες είναι διαθέσιμες στις ενότητες <a href=#printing-trying>Δοκιμή του Spooler</a> και <a href=#printing-troubleshooting>Εντοπισμός Βλαβών</a>.</p></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Εκτυπωτές που βασίζονται σε γλώσσες εκτύπωσης, όπως οι εκτυπωτές PostScript®, δεν μπορούν να εκτυπώσουν άμεσα απλό κείμενο. Ο απλός τρόπος ρύθμισης που δείξαμε παραπάνω και που θα περιγράψουμε εκτενέστερα στις επόμενες ενότητες, προϋποθέτει πως αν ρυθμίζετε έναν τέτοιο εκτυπωτή θα μπορείτε να εκτυπώσετε μόνον αρχεία γραμμένα στη γλώσσα του.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Οι χρήστες συνήθως νομίζουν πως μπορούν να εκτυπώσουν απλό κείμενο σε όλους τους εκτυπωτές που είναι εγκατεστημένοι στο σύστημα τους. Τα προγράμματα που χρησιμοποιούν το LPD για να εκτυπώσουν, κάνουν ακριβώς την ίδια υπόθεση. Αν προσπαθείτε να εγκαταστήσετε έναν τέτοιο εκτυπωτή και θέλετε να μπορείτε να τυπώνετε εργασίες στην γλώσσα του εκτυπωτή αλλά <em>και</em> σε απλό κείμενο, σας συνιστούμε να προσθέσετε ένα επιπλέον βήμα στην διαδικασία εγκατάστασης που περιγράψαμε παραπάνω: Εγκαταστήστε ένα πρόγραμμα αυτόματης μετατροπής από απλό κείμενο σε PostScript (ή σε άλλη γλώσσα εκτυπωτή). Η ενότητα <a href=#printing-advanced-if-conversion>Συμβατότητα Εργασιών Απλού Κειμένου σε εκτυπωτές PostScript®</a> εξηγεί πως να ενεργήσετε.</p></div><div class=sect5><h6 id=printing-naming>16.3.1.5.1. Ονοματοδότηση Εκτυπωτή<a class=anchor href=#printing-naming></a></h6><div class=paragraph><p>Το πρώτο (εύκολο) βήμα είναι να επιλέξετε όνομα για τον εκτυπωτή σας. Δεν έχει σημασία αν θα προτιμήσετε ένα λειτουργικό ή κάποιο εξωτικό όνομα αφού μπορείτε επίσης να προσθέσετε και μερικά παρωνύμια (aliases) για τον ίδιο εκτυπωτή.</p></div><div class=paragraph><p>Τουλάχιστον ένας από τους εκτυπωτές που αναφέρονται στο <span class=filename>/etc/printcap</span> θα πρέπει να έχει το παρωνύμιο <code>lp</code>. Αυτή είναι η ονομασία του προεπιλεγμένου εκτυπωτή. Εάν οι χρήστες δεν έχουν την μεταβλητή περιβάλλοντος <code>PRINTER</code> και δεν αναφέρουν κάποιο όνομα εκτυπωτή στην γραμμή εντολών με οποιαδήποτε εντολή LPD, τότε ο <code>lp</code> θα είναι ο προεπιλεγμένος εκτυπωτής για τις εκτυπώσεις τους.</p></div><div class=paragraph><p>Επίσης, είναι κοινή πρακτική το τελευταίο alias του εκτυπωτή να είναι μια πλήρης περιγραφή του εκτυπωτή, που να περιλαμβάνει τον κατασκευαστή και το μοντέλο.</p></div><div class=paragraph><p>Αφού επιλέξετε μια ονομασία και μερικά συνήθη παρωνύμια, καταχωρίστε τα στο αρχείο <span class=filename>/etc/printcap</span>. Το όνομα του εκτυπωτή θα πρέπει να αναφέρεται πρώτο στο αριστερό άκρο. Διαχωρίστε κάθε παρωνύμιο με μια κάθετη μπάρα και τοποθετήστε μια άνω-κάτω τελεία μετά το τελευταίο παρωνύμιο.</p></div><div class=paragraph><p>Στο ακόλουθο παράδειγμα, ξεκινάμε με ένα εντελώς βασικό <span class=filename>/etc/printcap</span> που ορίζει δύο εκτυπωτές (έναν εκτυπωτή γραμμής Diablo 630 και έναν εκτυπωτή PostScript® laser Panasonic KX-P4455):</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose
#
rattan|line|diablo|lp|Diablo 630 Line Printer:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:</pre></div></div><div class=paragraph><p>Σε αυτό το παράδειγμα, ο πρώτος εκτυπωτής ονομάζεται <code>rattan</code> και έχει ως παρωνύμια τα <code>line</code>, <code>diablo</code>, <code>lp</code>, και <code>Diablo 630 Line Printer</code>. Από τη στιγμή που έχει το παρωνύμιο <code>lp</code>, είναι και ο προεπιλεγμένος εκτυπωτής. Ο δεύτερος ονομάζεται <code>bamboo</code>, και έχει ως παρωνύμια τα <code>ps</code>, <code>PS</code>, <code>S</code>, <code>panasonic</code>, και <code>Panasonic KX-P4455 PostScript v51.4</code>.</p></div></div><div class=sect5><h6 id=printing-no-header-pages>16.3.1.5.2. Παρεμπόδιση Σελίδων Κεφαλίδας<a class=anchor href=#printing-no-header-pages></a></h6><div class=paragraph><p>Το σύστημα παροχέτευσης LPD, από προεπιλογή, εκτυπώνει μια <em>σελίδα κεφαλίδας</em> για κάθε εργασία. Η σελίδα κεφαλίδας περιλαμβάνει το όνομα χρήστη που αιτήθηκε την εργασία, τον υπολογιστή από τον οποίον προήλθε η εργασία, και το όνομα της εργασίας, με μεγάλους όμορφους χαρακτήρες. Δυστυχώς αυτό το πρόσθετο κείμενο ακολουθεί την διαδικασία αποσφαλμάτωσης της εγκατάστασης ενός απλού εκτυπωτή, επομένως θα παρεμποδίσουμε τις σελίδες κεφαλίδας.</p></div><div class=paragraph><p>Για την παρεμπόδιση των σελίδων κεφαλίδας, προσθέστε την ικανότητα <code>sh</code> στην καταχώριση για τον εκτυπωτή στο αρχείο <span class=filename>/etc/printcap</span>. Εδώ βλέπετε ένα παράδειγμα του <span class=filename>/etc/printcap</span> με προσθήκη της <code>sh</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - no header pages anywhere
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:</pre></div></div><div class=paragraph><p>Παρατηρήστε πως χειριστήκαμε σωστά τη μορφή: η πρώτη γραμμή ξεκινά στην αριστερή στήλη, και οι ακόλουθες γραμμές είναι στοιχισμένες (indented). Κάθε γραμμή καταχώρισης (εκτός από την τελευταία) τελειώνει με μια αριστερόστροφη κάθετο.</p></div></div><div class=sect5><h6 id=printing-spooldir>16.3.1.5.3. Δημιουργία Καταλόγου Παροχέτευσης<a class=anchor href=#printing-spooldir></a></h6><div class=paragraph><p>Το επόμενο βήμα στον απλό τρόπο εγκατάστασης είναι η δημιουργία ενός <em>καταλόγου παροχέτευσης (spool)</em>, όπου θα φιλοξενούνται οι εργασίες εκτύπωσης έως ότου να εκτυπωθούν και όπου επίσης φυλάσσονται και κάποια άλλα βοηθητικά αρχεία του συστήματος εκτύπωσης.</p></div><div class=paragraph><p>Λόγω της μεταβαλλόμενης φύσης των καταλόγων παροχέτευσης, συνηθίζεται να τοποθετούνται κάτω από τον κατάλογο <span class=filename>/var/spool</span>. Δεν είναι αναγκαίο να παίρνετε αντίγραφα ασφαλείας των καταλόγων παροχέτευσης. Η επαναδημιουργία τους είναι τόσο απλή όσο να τρέξουμε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=mkdir&amp;sektion=1&amp;format=html">mkdir(1)</a>.</p></div><div class=paragraph><p>Είναι επίσης συνηθισμένο να ονομάζεται ο κατάλογος με το ίδιο όνομα με τον εκτυπωτή, όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/spool/printer-name</span></code></pre></div></div><div class=paragraph><p>Ωστόσο, αν έχετε αρκετούς εκτυπωτές στο δίκτυο, ίσως επιθυμείτε να τοποθετήσετε τους καταλόγους παροχέτευσης κάτω από ένα μοναδικό κατάλογο που θα χρησιμοποιείται αποκλειστικά για εκτυπώσεις με το LPD. Θα κάνουμε ακριβώς αυτό για τα παραδείγματα μας με τους εκτυπωτές <code>rattan</code> και <code>bamboo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/spool/lpd</span>
<span class=c># mkdir /var/spool/lpd/rattan</span>
<span class=c># mkdir /var/spool/lpd/bamboo</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Εάν οι εργασίες των χρηστών περιέχουν προσωπικά δεδομένα, μπορεί να θέλετε να προστατέψετε τον κατάλογο παροχέτευσης με κάποιο τρόπο, ώστε να μην είναι δημόσια προσβάσιμος. Οι κατάλογοι παροχέτευσης θα πρέπει να ανήκουν και να είναι αναγνώσιμοι, εγγράψιμοι και με δυνατότητα αναζήτησης από τον χρήστη daemon και από την ομάδα daemon, από κανέναν άλλο. Για τους εκτυπωτές του παραδείγματος:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown daemon:daemon /var/spool/lpd/rattan</span>
<span class=c># chown daemon:daemon /var/spool/lpd/bamboo</span>
<span class=c># chmod 770 /var/spool/lpd/rattan</span>
<span class=c># chmod 770 /var/spool/lpd/bamboo</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Τέλος, πρέπει να ενημερώσετε το LPD για αυτούς τους καταλόγους χρησιμοποιώντας το αρχείο <span class=filename>/etc/printcap</span>. Προσδιορίστε την διαδρομή του καταλόγου παροχέτευσης με την ικανότητα <code>sd</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added spooling directories
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:</pre></div></div><div class=paragraph><p>Σημειώστε πως το όνομα του εκτυπωτή ξεκινά στην πρώτη στήλη, ενώ όλες οι άλλες καταχωρίσεις που περιγράφουν τον εκτυπωτή θα πρέπει να είναι στοιχισμένες και κάθε τέλος γραμμής να φέρει χαρακτήρα διαφυγής με αριστερόστροφη κάθετο.</p></div><div class=paragraph><p>Εάν δεν προσδιορίσετε τον κατάλογο παροχέτευσης μέσω του <code>sd</code>, τότε το σύστημα παροχέτευσης θα χρησιμοποιήσει τον προεπιλεγμένο <span class=filename>/var/spool/lpd</span>.</p></div></div><div class=sect5><h6 id=printing-device>16.3.1.5.4. Αναγνώριση της Συσκευής Εκτύπωσης<a class=anchor href=#printing-device></a></h6><div class=paragraph><p>Στην ενότητα <a href=#printing-hardware>Ρυθμίσεις Hardware</a> αναγνωρίσαμε τη θύρα, και κατά συνέπεια την καταχώριση του καταλόγου <span class=filename>/dev</span> που θα χρησιμοποιήσει το FreeBSD για να επικοινωνήσει με τον εκτυπωτή. Τώρα, θα δώσουμε στο LPD αυτή την πληροφορία. Όταν το σύστημα παροχέτευσης έχει μια εργασία να εκτυπώσει, θα ανοίξει αυτή την ειδική συσκευή για λογαριασμό του προγράμματος φίλτρου (που είναι υπεύθυνο για το πέρασμα των δεδομένων στον εκτυπωτή).</p></div><div class=paragraph><p>Προσδιορίστε την διαδρομή της καταχώρισης <span class=filename>/dev</span> στο αρχείο <span class=filename>/etc/printcap</span> χρησιμοποιώντας την ικανότητα <code>lp</code>.</p></div><div class=paragraph><p>Στο τρέχον παράδειγμα μας, ας υποθέσουμε ότι ο <code>rattan</code> είναι στην πρώτη παράλληλη θύρα, και ο <code>bamboo</code> είναι στην έκτη σειριακή πόρτα. Οι νέες καταχωρίσεις στο <span class=filename>/etc/printcap</span> θα είναι:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - identified what devices to use
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:</pre></div></div><div class=paragraph><p>Αν δεν καθορίσετε σε κάποιον εκτυπωτή την ικανότητα <code>lp</code> στο αρχείο <span class=filename>/etc/printcap</span>, το LPD χρησιμοποιεί από προεπιλογή το <span class=filename>/dev/lp</span>. Το <span class=filename>/dev/lp</span> δεν υπάρχει την δεδομένη στιγμή στο FreeBSD.</p></div><div class=paragraph><p>Εάν ο εκτυπωτής που εγκαθιστάτε είναι συνδεδεμένος σε παράλληλη θύρα, διαβάστε απευθείας την ενότητα με τίτλο <a href=#printing-textfilter>Εγκατάσταση Φίλτρου Κειμένου</a>. Διαφορετικά, ακολουθήστε προσεκτικά τις οδηγίες που ακολουθούν στην επόμενη ενότητα.</p></div></div><div class=sect5><h6 id=printing-commparam>16.3.1.5.5. Ρυθμίσεις Παραμέτρων Επικοινωνίας του Spooler<a class=anchor href=#printing-commparam></a></h6><div class=paragraph><p>Για εκτυπωτές σε σειριακή πόρτα, το LPD μπορεί να ρυθμίσει την ταχύτητα σε bps, το parity, και άλλες παραμέτρους σειριακής επικοινωνίας για λογαριασμό του προγράμματος φίλτρου που στέλνει δεδομένα στον εκτυπωτή. Αυτό είναι πλεονέκτημα γιατί:</p></div><div class=ulist><ul><li><p>Σας επιτρέπει να δοκιμάσετε διάφορες παραμέτρους επικοινωνίας προσθέτοντας τις απλά με επεξεργασία του αρχείου <span class=filename>/etc/printcap</span>. Δεν χρειάζεται να επαναμεταγλωττίσετε το πρόγραμμα φίλτρου.</p></li><li><p>Επιτρέπει στο σύστημα παροχέτευσης να χρησιμοποιεί το ίδιο πρόγραμμα για πολλαπλούς εκτυπωτές, οι οποίοι μπορεί να έχουν διαφορετικές σειριακές ρυθμίσεις επικοινωνίας.</p></li></ul></div><div class=paragraph><p>Οι ακόλουθες ικανότητες του <span class=filename>/etc/printcap</span> ελέγχουν τις παραμέτρους σειριακής επικοινωνίας των συσκευών που αναφέρονται στην ικανότητα <code>lp</code>:</p></div><div class=dlist><dl><dt class=hdlist1><code>br#bps-rate</code></dt><dd><p>Ορίζει την ταχύτητα επικοινωνίας της συσκευής σε <em>bps-rate</em>, όπου το <em>bps-rate</em> μπορεί να είναι 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, ή 115200 bits-per-second.</p></dd><dt class=hdlist1><code>ms#stty-mode</code></dt><dd><p>Ορίζει τις επιλογές της συσκευής τερματικού μετά το άνοιγμα της συσκευής. Η <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> εξηγεί τις διαθέσιμες επιλογές.</p></dd></dl></div><div class=paragraph><p>Όταν το LPD ανοίγει την συσκευή που ορίζεται από την ικανότητα <code>lp</code>, υιοθετεί τα χαρακτηριστικά της συσκευής με ικανότητα <code>ms#</code>. Έχουν ιδιαίτερο ενδιαφέρον οι καταστάσεις λειτουργίας <code>parenb</code>, <code>parodd</code>, <code>cs5</code>, <code>cs6</code>, <code>cs7</code>, <code>cs8</code>, <code>cstopb</code>, <code>crtscts</code>, και <code>ixon</code>, που εξηγούνται στην σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a>.</p></div><div class=paragraph><p>Ας προσθέσουμε στο παράδειγμα μας έναν εκτυπωτή στην έκτη σειριακή θύρα. Θα θέσουμε την ταχύτητα bps σε 38400. Για την κατάσταση λειτουργίας θα θέσουμε , no parity με <code>-parenb</code>, χαρακτήρες 8-bit με <code>cs8</code>, no modem control με <code>clocal</code> και έλεγχο ροής μέσω hardware με <code>crtscts</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:</pre></div></div></div><div class=sect5><h6 id=printing-textfilter>16.3.1.5.6. Εγκατάσταση Φίλτρου Κειμένου<a class=anchor href=#printing-textfilter></a></h6><div class=paragraph><p>Τώρα είμαστε έτοιμοι να πούμε στο LPD ποιο φίλτρο κειμένου να χρησιμοποιήσει για να στείλει εργασίες στον εκτυπωτή. Το φίλτρο κειμένου, γνωστό και ως <em>φίλτρο εισόδου</em>, είναι ένα πρόγραμμα που εκτελεί το LPD όταν υπάρχει εργασία προς εκτύπωση. Όταν το LPD εκτελεί το φίλτρο κειμένου για κάποιον εκτυπωτή, θέτει την standard input του φίλτρου στην εργασία εκτύπωσης, και την standard output στην συσκευή του εκτυπωτή που ορίζεται με την ικανότητα <code>lp</code>. Το φίλτρο αναμένεται να αναγνώσει την εργασία από την standard input, να εκτελέσει όλες τις απαραίτητες μεταγλωττίσεις για τον εκτυπωτή, και να γράψει το αποτέλεσμα στην standard output, το οποίο και θα εκτυπωθεί. Για περισσότερες πληροφορίες για τα φίλτρα κειμένου, δείτε την ενότητα <a href=#printing-advanced-filters>Φίλτρα</a>.</p></div><div class=paragraph><p>Για την απλή εγκατάσταση των εκτυπωτών μας, το φίλτρο κειμένου μπορεί να είναι ένα μικρό shell script που απλά θα εκτελεί την εντολή <code>/bin/cat</code> για να στέλνει εργασίες στον εκτυπωτή. Το FreeBSD έρχεται με άλλο ένα φίλτρο, το <span class=filename>lpf</span> που χειρίζεται δυνατότητες backspacing και υπογράμμισης για εκτυπωτές που ίσως να μην χειρίζονται σωστά αυτές τις λειτουργίες. Και φυσικά, μπορείτε να χρησιμοποιήσετε οποιοδήποτε άλλο πρόγραμμα φίλτρου επιθυμείτε. Το φίλτρο <code>lpf</code> περιγράφεται λεπτομερώς στην ενότητα <a href=#printing-advanced-lpf>lpf: ένα Φίλτρο Κειμένου</a>.</p></div><div class=paragraph><p>Θα ξεκινήσουμε δημιουργώντας το shell script <span class=filename>/usr/local/libexec/if-simple</span> σαν ένα απλό φίλτρο κειμένου. Τοποθετήστε το ακόλουθο κείμενο στο αρχείο χρησιμοποιώντας τον κειμενογράφο που προτιμάτε:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# if-simple - Simple text input filter for lpd
# Installed in /usr/local/libexec/if-simple
#
# Simply copies stdin to stdout.  Ignores all filter arguments.

/bin/cat &amp;&amp; exit 0
exit 2</pre></div></div><div class=paragraph><p>Κάντε το αρχείο εκτελέσιμο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/if-simple</span></code></pre></div></div><div class=paragraph><p>Και ενημερώστε το LPD να το χρησιμοποιήσει, ορίζοντας το με την ικανότητα <code>if</code> στο αρχείο <span class=filename>/etc/printcap</span>. Θα το προσθέσουμε στους δύο εκτυπωτές από το προηγούμενο παράδειγμα στο <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added text filter
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:\
        :if=/usr/local/libexec/if-simple:</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μπορείτε να βρείτε ένα αντίγραφο του script <span class=filename>if-simple</span> στον κατάλογο <span class=filename>/usr/shared/examples/printing</span>.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_ενεργοποίηση_του_lpd>16.3.1.5.7. Ενεργοποίηση του LPD<a class=anchor href=#_ενεργοποίηση_του_lpd></a></h6><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> εκτελείται από το <span class=filename>/etc/rc</span>, και ελέγχεται από την μεταβλητή <code>lpd_enable</code>. Η μεταβλητή αυτή έχει προεπιλεγμένη τιμή <code>NO</code>. Αν δεν το έχετε κάνει ακόμα, προσθέστε την ακόλουθη γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>στο αρχείο <span class=filename>/etc/rc.conf</span>, και επανεκκινήστε το σύστημα σας, ή απλά εκτελέστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpd</span></code></pre></div></div></div><div class=sect5><h6 id=printing-trying>16.3.1.5.8. Δοκιμή του Spooler<a class=anchor href=#printing-trying></a></h6><div class=paragraph><p>Φτάσατε στο τέλος της απλής εγκατάστασης του LPD. Θα αφήσουμε για αργότερα τα συγχαρητήρια, αφού ακόμη θα πρέπει να ελέγξουμε την εγκατάσταση και να διορθώσουμε οποιοδήποτε πρόβλημα έχει προκύψει. Για να ελέγξετε την εγκατάσταση προσπαθήστε να εκτυπώσετε κάτι. Για να εκτυπώσετε με το σύστημα LPD, χρησιμοποιήστε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, η οποία αποστέλλει μία εργασία προς εκτύπωση.</p></div><div class=paragraph><p>Μπορείτε να συνδυάσετε την <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> με το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>, για το οποίο κάναμε μια εισαγωγή στην ενότητα <a href=#printing-testing>Έλεγχος Επικοινωνίας του Εκτυπωτή</a>, για τον έλεγχο κειμένου.</p></div><div class=paragraph><p><em>Για τον έλεγχο μιας απλής εγκατάστασης LPD:</em></p></div><div class=paragraph><p>Πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptest 20 5 | lpr -Pprinter-name</span></code></pre></div></div><div class=paragraph><p>Όπου <em>printer-name</em> είναι το όνομα ενός εκτυπωτή (ή το alias) που αναφέρεται στο <span class=filename>/etc/printcap</span>. Για να ελέγξετε τον προεπιλεγμένο εκτυπωτή, πληκτρολογήστε <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> χωρίς το πρόθεμα <code>-P</code>. Αν ο εκτυπωτής σας χρησιμοποιεί PostScript®, πρέπει να στείλετε ένα πρόγραμμα PostScript®, αντί να χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>. Για να τα καταφέρετε, τοποθετήστε το πρόγραμμα σε ένα αρχείο και πληκτρολογήστε <code>lpr file</code>.</p></div><div class=paragraph><p>Σε έναν εκτυπωτή PostScript®, η εκτύπωση θα είναι το αποτέλεσμα του προγράμματος που στείλατε. Αν χρησιμοποιείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>, τότε το αποτέλεσμα θα μοιάζει με το ακόλουθο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span><span class=s2>&#34;#</span><span class=nv>$%</span><span class=s2>&amp;&#39;()*+,-./01234
&#34;</span><span class=c>#$%&amp;&#39;()*+,-./012345</span>
<span class=c>#$%&amp;&#39;()*+,-./0123456</span>
<span class=nv>$%</span>&amp;<span class=s1>&#39;()*+,-./01234567
%&amp;&#39;</span><span class=o>()</span><span class=k>*</span>+,-./012345678</code></pre></div></div><div class=paragraph><p>Για περαιτέρω έλεγχο του εκτυπωτή, δοκιμάστε να κατεβάσετε μεγαλύτερα προγράμματα (για εκτυπωτές που χρησιμοποιούν γλώσσα προγραμματισμού) ή τρέξτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> με διαφορετικά προθέματα. Για παράδειγμα, η εντολή <code>lptest 80 60</code> θα παράγει 60 γραμμές των 80 χαρακτήρων η καθεμία.</p></div><div class=paragraph><p>Αν ο εκτυπωτής δεν δουλεύει, δείτε την ενότητα <a href=#printing-troubleshooting>Εντοπισμός Βλαβών</a>.</p></div></div></div></div></div><div class=sect2><h3 id=printing-advanced>16.4. Ρυθμίσεις Εκτυπωτών για Προχωρημένους<a class=anchor href=#printing-advanced></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα αρχεία συσκευών για τις σειριακές θύρες μετονομάστηκαν από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν την τεκμηρίωση που ακολουθεί με βάση αυτές τις αλλαγές.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αυτή η ενότητα περιγράφει φίλτρα για την εκτύπωση ειδικής μορφής αρχείων, σελίδων κεφαλίδας, για εκτυπώσεις μέσω δικτύου, καθώς και για τον έλεγχο πρόσβασης και την καταμέτρηση χρήσης των εκτυπωτών.</p></div><div class=sect3><h4 id=printing-advanced-filter-intro>16.4.1. Φίλτρα<a class=anchor href=#printing-advanced-filter-intro></a></h4><div class=paragraph><p>Αν και το LPD μπορεί να χειριστεί πρωτόκολλα δικτύων, λίστες αναμονής, έλεγχο πρόσβασης, και άλλες παραμέτρους των εκτυπώσεων, το κύριο μέρος της <em>πραγματικής</em> εργασίας γίνεται με τα <em>φίλτρα</em>. Τα φίλτρα είναι προγράμματα που επικοινωνούν με τον εκτυπωτή και χειρίζονται τις εξαρτήσεις της συσκευής και άλλες ειδικές απαιτήσεις της. Στην απλή εγκατάσταση εκτυπωτή, εγκαταστήσαμε ένα φίλτρο απλού κειμένου ιδιαίτερα απλής μορφής, που θα πρέπει να δουλεύει με τους περισσότερους εκτυπωτές (ενότητα <a href=#printing-textfilter>Εγκατάσταση Φίλτρου Κειμένου</a>).</p></div><div class=paragraph><p>Ωστόσο, για να μπορέσετε να εκμεταλλευτείτε τις δυνατότητες μετατροπών μορφής, ελέγχου πρόσβασης και καταμέτρησης, και τυχόν ειδικές δυνατότητες του εκτυπωτή σας, θα πρέπει να καταλάβετε πως δουλεύουν τα φίλτρα. Σε τελική ανάλυση, θα είναι ευθύνη των φίλτρων να χειρίζονται όλες αυτές τις παραμέτρους. Τα κακά νέα είναι πως τις περισσότερες φορές θα πρέπει να παρέχετε <em>εσείς οι ίδιοι</em> τα φίλτρα σας. Τα καλά νέα είναι πως γενικώς υπάρχουν αρκετά διαθέσιμα, και αν δεν υπάρχουν, είναι σχετικά εύκολο να τα γράψετε.</p></div><div class=paragraph><p>Επίσης, το FreeBSD διατίθεται με ένα φίλτρο, το <span class=filename>/usr/libexec/lpr/lpf</span>, που δουλεύει με πολλούς εκτυπωτές που μπορούν να εκτυπώσουν απλό κείμενο. (Χειρίζεται backspacing και tabs στο αρχείο, και κάνει καταμέτρηση, αλλά τίποτα περισσότερο.) Υπάρχουν, επίσης, διάφορα άλλα φίλτρα και συστατικά τους στην Συλλογή των Ports του FreeBSD.</p></div><div class=paragraph><p>Σε αυτή την ενότητα θα βρείτε: :</p></div><div class=ulist><ul><li><p>Η ενότητα <a href=#printing-advanced-filters>Πως δουλεύουν τα Φίλτρα</a>, προσπαθεί να δώσει μια γενική άποψη για τις αρμοδιότητες των φίλτρων στις διεργασίες εκτύπωσης. Θα πρέπει να διαβάσετε αυτή την ενότητα για να μπορείτε να καταλάβετε τι "πραγματικά" συμβαίνει όταν το LPD χρησιμοποιεί φίλτρα. Αυτές οι γνώσεις θα σας βοηθήσουν να προλαμβάνετε και να αποσφαλματώνετε προβλήματα που μπορούν να συμβούν καθώς εγκαθιστάτε όλο και περισσότερα φίλτρα σε κάθε εκτυπωτή σας.</p></li><li><p>Το LPD αναμένει πως κάθε εκτυπωτής είναι ικανός, από προεπιλογή, να εκτυπώσει απλό κείμενο. Αυτό όμως είναι πρόβλημα για εκτυπωτές PostScript® (ή άλλους που βασίζονται σε γλώσσες προγραμματισμού) οι οποίοι δεν μπορούν να εκτυπώσουν άμεσα απλό κείμενο. Η ενότητα <a href=#printing-advanced-if-conversion>Συμβατότητα Εργασιών Απλού Κειμένου σε εκτυπωτές PostScript®</a> σας εξηγεί τι θα πρέπει να κάνετε για να ξεπεράσετε αυτό το πρόβλημα. Θα πρέπει να διαβάσετε αυτή την ενότητα αν έχετε εκτυπωτή PostScript®.</p></li><li><p>Το PostScript® είναι δημοφιλής μορφή εξόδου για πολλά προγράμματα. Μερικοί άνθρωποι προτιμούν και να γράφουν κατευθείαν σε κώδικα PostScript®. Δυστυχώς, οι εκτυπωτές PostScript® έχουν μεγάλο κόστος. Η ενότητα <a href=#printing-advanced-ps>Προσομοίωση PostScript® για εκτυπωτές που δεν το υποστηρίζουν</a> εξηγεί λεπτομερώς πως να μετατρέψετε ένα φίλτρο κειμένου για εκτυπωτές ώστε να λαμβάνει και να τυπώνει δεδομένα PostScript® σε εκτυπωτές που <em>δεν είναι PostScript®</em>. Θα πρέπει να διαβάσετε αυτήν την ενότητα αν είστε κάτοχος εκτυπωτή που δεν υποστηρίζει PostScript®.</p></li><li><p>Η ενότητα <a href=#printing-advanced-convfilters>Φίλτρα Μετατροπής</a> περιγράφει μια αυτοματοποιημένη διαδικασία για την μετατροπή αρχείων ειδικής μορφής, όπως δεδομένα γραφικών ή στοιχειοθεσίας, σε μια μορφή κατανοητή από τον εκτυπωτή σας. Μετά την ανάγνωση αυτής της ενότητας, θα πρέπει να είστε σε θέση να ρυθμίσετε τους εκτυπωτές σας με τέτοιο τρόπο ώστε πληκτρολογώντας <code>lpr -t</code> οι χρήστες σας να μπορούν να εκτυπώσουν δεδομένα troff, ή με <code>lpr -d</code> δεδομένα TeX DVI, ή με <code>lpr -v</code> να εκτυπώνουν εικόνες δεδομένων ράστερ, και ούτω καθεξής. Σας συμβουλεύουμε να διαβάσετε αυτή την ενότητα.</p></li><li><p>Η ενότητα <a href=#printing-advanced-of>Φίλτρα Εξόδου</a> περιγράφει ένα χαρακτηριστικό του LPD που δεν χρησιμοποιείται συχνά: τα φίλτρα εξόδου. Μπορείτε να προσπεράσετε αυτή την ενότητα, εκτός αν τυπώνετε σελίδες κεφαλίδας (δείτε τις <a href=#printing-advanced-header-pages>Σελίδες Κεφαλίδας</a>).</p></li><li><p>Η ενότητα <a href=#printing-advanced-lpf>lpf: ένα Φίλτρο Κειμένου</a> περιγράφει το <code>lpf</code>, ένα πραγματικά πλήρες, αν και απλό, φίλτρο κειμένου για εκτυπωτές γραμμής (και εκτυπωτές laser που μπορούν να λειτουργήσουν και ως εκτυπωτές γραμμής) που περιέχεται στο FreeBSD. Αν χρειάζεστε ένα γρήγορο τρόπο για να κάνετε την καταμέτρηση σελίδων να δουλεύει σε απλό κείμενο, ή αν έχετε κάποιον εκτυπωτή που βγάζει καπνούς όταν βλέπει χαρακτήρες backspace, θα πρέπει οπωσδήποτε να εξετάσετε την περίπτωση του <code>lpf</code>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μπορείτε να βρείτε αντίγραφο των διάφορων scripts που αναφέρονται παρακάτω, στον κατάλογο <span class=filename>/usr/shared/examples/printing</span>.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=printing-advanced-filters>16.4.1.1. Πως Δουλεύουν τα Φίλτρα<a class=anchor href=#printing-advanced-filters></a></h5><div class=paragraph><p>Όπως αναφέραμε προηγουμένως, φίλτρο είναι ένα εκτελέσιμο πρόγραμμα που ενεργοποιείται από το LPD για να χειρίζεται το τμήμα της επικοινωνίας με τον εκτυπωτή που εξαρτάται από τον τύπο της ίδιας της συσκευής.</p></div><div class=paragraph><p>Όταν το LPD θέλει να εκτυπώσει ένα αρχείο μιας εργασίας, ξεκινά το πρόγραμμα του φίλτρου. Θέτει ως standard input του φίλτρου το αρχείο που πρέπει να εκτυπωθεί, ως standard output τον ίδιο τον εκτυπωτή και ως standard error το αρχείο αναφοράς σφαλμάτων (αναφέρεται στην ικανότητα <code>lf</code> του <span class=filename>/etc/printcap</span>, ή από προεπιλογή το <span class=filename>/dev/console</span>).</p></div><div class=paragraph><p>Το φίλτρο που θα ξεκινήσει το LPD καθώς και οι παράμετροι του φίλτρου, εξαρτώνται από το τι έχετε δηλώσει στο αρχείο <span class=filename>/etc/printcap</span> και από το τι παραμέτρους έχει καθορίσει ο ίδιος ο χρήστης για την εργασία με την γραμμή εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>. Για παράδειγμα, αν ο χρήστης πληκτρολογήσει <code>lpr -t</code>, το LPD θα ξεκινήσει το φίλτρο troff, που υποδηλώνεται με την ικανότητα <code>tf</code> για τον εκτυπωτή προορισμού. Αν ο χρήστης επιθυμεί να εκτυπώσει απλό κείμενο, θα ξεκινήσει το φίλτρο <code>if</code> (αυτό πράγματι ισχύει τις περισσότερες φορές: δείτε τα <a href=#printing-advanced-of>Φίλτρα Εξόδου</a> για λεπτομέρειες).</p></div><div class=paragraph><p>Υπάρχουν τρεις τύποι φίλτρων που μπορείτε να προσδιορίσετε στο <span class=filename>/etc/printcap</span>:</p></div><div class=ulist><ul><li><p>Το <em>φίλτρο κειμένου</em>, επονομαζόμενο και ως <em>φίλτρο εισόδου</em> στην τεκμηρίωση του LPD, χειρίζεται εκτυπώσεις κανονικού κειμένου. Θεωρήστε το ως το προεπιλεγμένο φίλτρο. Το LPD αναμένει πως όλοι οι εκτυπωτές, από προεπιλογή, είναι σε θέση να εκτυπώσουν απλό κείμενο, και είναι δουλειά του φίλτρου κειμένου να βεβαιωθεί ότι τα backspaces, τα tabs, και όλοι οι άλλοι ειδικοί χαρακτήρες δεν πρόκειται να προβληματίσουν τον εκτυπωτή. Εάν βρίσκεστε σε ένα περιβάλλον όπου θα πρέπει να καταμετρήσετε την χρήση των εκτυπωτών, το φίλτρο κειμένου θα πρέπει επίσης να καταμετρήσει τις εκτυπωμένες σελίδες, συνήθως μετρώντας τον αριθμό των εκτυπωμένων γραμμών και συγκρίνοντας τον με τον αριθμό των γραμμών που υποστηρίζει ο εκτυπωτής ανά σελίδα. Το φίλτρο κειμένου ξεκινά με την ακόλουθη λίστα παραμέτρων:</p><div class=paragraph><p><code>filter-name</code> [ -c ] -w<em>width</em> -l<em>length</em> -i<em>indent</em> -n <em>login</em> -h <em>host</em> <em>acct-file</em></p></div><div class=paragraph><p>όπου</p></div><div class=dlist><dl><dt class=hdlist1><code>-c</code></dt><dd><p>εμφανίζεται αν η εργασία έχει αποσταλεί με <code>lpr -l</code></p></dd><dt class=hdlist1><code><em>width</em></code></dt><dd><p>είναι η τιμή από την ικανότητα <code>pw</code> (πλάτος σελίδας - page width) όπως προσδιορίζεται στο <span class=filename>/etc/printcap</span>, με προεπιλεγμένη τιμή το 132</p></dd><dt class=hdlist1><code><em>length</em></code></dt><dd><p>είναι η τιμή από την ικανότητα <code>pl</code> (μήκος σελίδας - page length), με προεπιλεγμένη τιμή το 66</p></dd><dt class=hdlist1><code><em>indent</em></code></dt><dd><p>είναι το μέγεθος της εσοχής (indentation) από το <code>lpr -i</code>, με προεπιλεγμένη τιμή 0</p></dd><dt class=hdlist1><code><em>login</em></code></dt><dd><p>είναι το καταγεγραμμένο όνομα χρήστη που εκτυπώνει το αρχείο</p></dd><dt class=hdlist1><code><em>host</em></code></dt><dd><p>είναι το όνομα του υπολογιστή από τον οποίο στάλθηκε η εργασία</p></dd><dt class=hdlist1><code><em>acct-file</em></code></dt><dd><p>είναι το όνομα του αρχείου καταμέτρησης από την ικανότητα <code>af</code>.</p></dd></dl></div></li><li><p>Ένα <em>φίλτρο μετατροπής</em> μετατρέπει ένα αρχείο ειδικής μορφής σε ένα τύπο αρχείου κατάλληλο για εκτύπωση από τον συγκεκριμένο εκτυπωτή. Για παράδειγμα, τα δεδομένα στοιχειοθεσίας ditroff δεν μπορούν να εκτυπωθούν κατευθείαν, αλλά μπορείτε να εγκαταστήσετε ένα φίλτρο μετατροπής αρχείων ditroff, ώστε να μετατρέψετε τα δεδομένα ditroff σε μια μορφή που ο εκτυπωτής να μπορεί να αφομοιώσει και να τυπώσει. Θα μάθετε περισσότερα στην ενότητα <a href=#printing-advanced-convfilters>Φϊλτρα Μετατροπής</a>. Τα φίλτρα μετατροπής επίσης χρειάζονται για να κάνετε αρίθμηση/καταμέτρηση, αν χρειάζεστε καταμέτρηση των εκτυπώσεων σας. Τα φίλτρα μετατροπής ξεκινούν με τις ακόλουθες παραμέτρους:</p><div class=paragraph><p><code>filter-name</code> -x<em>pixel-width</em> -y<em>pixel-height</em> -n <em>login</em> -h <em>host</em> <em>acct-file</em> όπου <em>pixel-width</em> είναι η τιμή από την ικανότητα px (προεπιλεγμένη τιμή 0) και <em>pixel-height</em> είναι η τιμή από την ικανότητα py (προεπιλεγμένη τιμή 0).</p></div></li><li><p>Το <em>φίλτρο εξόδου</em> χρησιμοποιείται μόνον αν δεν υπάρχει φίλτρο κειμένου, ή αν είναι ενεργοποιημένες οι σελίδες κεφαλίδας. Διαβάστε τη σχετική ενότητα <a href=#printing-advanced-of>Φίλτρα Εξόδου</a>, αν και από την εμπειρία μας μπορούμε να σας πούμε ότι χρησιμοποιούνται σπάνια. Υπάρχουν μόνο δύο παράμετροι για τα φίλτρα εξόδου:</p><div class=paragraph><p><code>filter-name</code> -w<em>width</em> -l<em>length</em> οι οποίες είναι πανομοιότυπες με τις παραμέτρους <code>-w</code> και <code>-l</code> των φίλτρων κειμένου.</p></div></li></ul></div><div class=paragraph><p>Τα φίλτρα θα πρέπει επίσης να <em>τερματίζουν</em> με κάποια από τις ακόλουθες καταστάσεις εξόδου:</p></div><div class=dlist><dl><dt class=hdlist1>exit 0</dt><dd><p>Αν το φίλτρο τύπωσε επιτυχώς το αρχείο.</p></dd><dt class=hdlist1>exit 1</dt><dd><p>Αν το φίλτρο απέτυχε να τυπώσει το αρχείο, αλλά θέλει το LPD να προσπαθήσει να εκτυπώσει το αρχείο ξανά. Το LPD θα ξεκινήσει ξανά το φίλτρο αν γίνει έξοδος με αυτή την κατάσταση.</p></dd><dt class=hdlist1>exit 2</dt><dd><p>Αν το φίλτρο απέτυχε να εκτυπώσει το αρχείο και δεν θέλει το LPD να προσπαθήσει ξανά. Το LPD θα απορρίψει το αρχείο.</p></dd></dl></div><div class=paragraph><p>Το φίλτρο κειμένου που έρχεται με την κανονική έκδοση του FreeBSD, <span class=filename>/usr/libexec/lpr/lpf</span>, εκμεταλλεύεται τις παραμέτρους πλάτους και μήκους σελίδας για να προσδιορίσει πότε να αποστείλει το form feed και πως να κάνει καταμέτρηση. Χρησιμοποιεί τις παραμέτρους για login, host, και αρχείου καταμέτρησης για να δημιουργήσει τις σχετικές εγγραφές καταμέτρησης.</p></div><div class=paragraph><p>Αν είστε στη διαδικασία επιλογής φίλτρων, ελέγξτε αν είναι συμβατά με το LPD. Αν είναι συμβατά, τότε πρέπει να υποστηρίζουν την λίστα παραμέτρων που περιγράψαμε προηγουμένως. Αν σχεδιάζετε να γράψατε τα δικά σας φίλτρα γενικής χρήσης, τότε πρέπει να τα κάνετε να υποστηρίζουν την ίδια λίστα παραμέτρων και κωδικών εξόδου.</p></div></div><div class=sect4><h5 id=printing-advanced-if-conversion>16.4.1.2. Συμβατότητα Εργασιών Απλού Κειμένου σε Εκτυπωτές PostScript®<a class=anchor href=#printing-advanced-if-conversion></a></h5><div class=paragraph><p>Αν είστε ο μοναδικός χρήστης του Η/Υ σας και του εκτυπωτή PostScript® (ή άλλης γλώσσας εκτυπωτών), και είστε σίγουροι πως δεν πρόκειται να στείλετε ποτέ εκτυπώσεις απλού κειμένου στον εκτυπωτή σας και πως δεν θα χρησιμοποιήσετε τις υπηρεσίες των διαφόρων προγραμμάτων σας που θα θελήσουν να στείλουν απλό κείμενο στον εκτυπωτή σας, τότε δεν χρειάζεται να ασχοληθείτε καθόλου με αυτή την ενότητα.</p></div><div class=paragraph><p>Αλλά, αν επιθυμείτε να στείλετε τόσο εργασίες PostScript® όσο και απλού κειμένου στον εκτυπωτή σας, τότε σας προτρέπουμε να προσθέσετε κάποιες ρυθμίσεις στην εγκατάσταση σας. Για να γίνει αυτό, θα πρέπει το φίλτρο κειμένου να ανιχνεύει αν η τρέχουσα εργασία είναι απλό κείμενο ή PostScript®. Όλες οι εργασίες PostScript® πρέπει να ξεκινούν με <code>%!</code> (αν ο εκτυπωτής σας χρησιμοποιεί άλλη γλώσσα, συμβουλευθείτε την τεκμηρίωση του). Αν είναι αυτοί οι πρώτοι δύο χαρακτήρες, τότε έχουμε PostScript®, και η υπόλοιπη εργασία μπορεί να σταλεί απευθείας στον εκτυπωτή. Αν δεν είναι αυτοί οι πρώτοι δύο χαρακτήρες, τότε το φίλτρο θα μετατρέψει το κείμενο σε PostScript® και θα τυπώσει το αποτέλεσμα.</p></div><div class=paragraph><p>Πως γίνεται αυτό;</p></div><div class=paragraph><p>Αν είστε κάτοχος σειριακού εκτυπωτή, ένας καλός τρόπος για να γίνει αυτό εφικτό είναι να εγκαταστήσετε το <code>lprps</code>. Το <code>lprps</code> είναι ένα φίλτρο εκτύπωσης PostScript® που επικοινωνεί αμφίδρομα με τον εκτυπωτή. Ενημερώνει το αρχείο κατάστασης του εκτυπωτή με αναλυτικές πληροφορίες, ώστε οι χρήστες και οι διαχειριστές να μπορούν να δουν επακριβώς ποια είναι η κατάσταση του εκτυπωτή (όπως <code>χαμηλή στάθμη toner</code> ή <code>πρόβλημα χαρτιού</code>). Ακόμη πιο σημαντικό είναι πως περιέχει το πρόγραμμα <code>psif</code> που ανιχνεύει αν η εισερχόμενη εργασία είναι απλού κειμένου και καλεί το <code>textps</code> (ένα άλλο πρόγραμμα που περιέχεται στο <code>lprps</code>) να το μετατρέψει σε PostScript®. Τέλος χρησιμοποιείται το <code>lprps</code> για να αποστείλει την εργασία στον εκτυπωτή.</p></div><div class=paragraph><p>Το <code>lprps</code> είναι μέρος της Συλλογής των Ports του FreeBSD (δείτε <a href=./#ports>Η Συλλογή των Ports</a>). Φυσικά, μπορείτε να το κατεβάσετε, να το μεταγλωττίσετε και να το εγκαταστήσετε μόνοι σας. Μετά την εγκατάσταση του <code>lprps</code>, απλά προσδιορίστε τη διαδρομή προς το πρόγραμμα <code>psif</code> που είναι μέρος του <code>lprps</code>. Αν εγκαταστήσατε το <code>lprps</code> από την Συλλογή των Ports, τότε για τον σειριακό σας εκτυπωτή PostScript® χρησιμοποιήστε την ακόλουθη καταχώριση στο αρχείο <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/psif:</pre></div></div><div class=paragraph><p>Θα πρέπει επίσης να καθορίσετε την ικανότητα <code>rw</code> η οποία ορίζει ότι το LPD θα χειρίζεται τον εκτυπωτή σε κατάσταση ανάγνωσης και εγγραφής.</p></div><div class=paragraph><p>Αν έχετε παράλληλο εκτυπωτή PostScript® (και για το λόγο αυτό δεν μπορείτε να χρησιμοποιήσετε αμφίδρομη επικοινωνία με τον εκτυπωτή, όπως απαιτείται από το <code>lprps</code>), μπορείτε να χρησιμοποιήσετε το ακόλουθο shell script ως φίλτρο κειμένου:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psif - Print PostScript or plain text on a PostScript printer
#  Script version; NOT the version that comes with lprps
#  Installed in /usr/local/libexec/psif
#

IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

if [ &#34;$first_two_chars&#34; = &#34;%!&#34; ]; then
    #
    #  PostScript job, print it.
    #
    echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; printf &#34;\004&#34; &amp;&amp; exit 0
    exit 2
else
    #
    #  Plain text, convert it, then print it.
    #
    ( echo &#34;$first_line&#34;; cat ) | /usr/local/bin/textps &amp;&amp; printf &#34;\004&#34; &amp;&amp; exit 0
    exit 2
fi</pre></div></div><div class=paragraph><p>Στο παραπάνω script, το <code>textps</code> είναι ένα πρόγραμμα που εγκαταστήσαμε ξεχωριστά για να μετατρέπουμε απλό κείμενο σε PostScript®. Μπορείτε να χρησιμοποιείτε οποιοδήποτε πρόγραμμα μετατροπής από κείμενο- σε-PostScript®. Η Συλλογή των Ports (δείτε <a href=./#ports>Η Συλλογή των Ports</a>) περιέχει επίσης ένα πλήρες πρόγραμμα μετατροπής από κείμενο σε PostScript®, το <code>a2ps</code> που ίσως επιθυμείτε να διερευνήσετε.</p></div></div><div class=sect4><h5 id=printing-advanced-ps>16.4.1.3. Προσομοίωση PostScript® για Εκτυπωτές που δεν το Υποστηρίζουν<a class=anchor href=#printing-advanced-ps></a></h5><div class=paragraph><p>Το PostScript® είναι το <em>de facto</em> πρότυπο για στοιχειοθεσία και εκτύπωση υψηλής ποιότητας. Ωστόσο, το PostScript® είναι κάπως <em>δαπανηρό</em> πρότυπο. Ευτυχώς, η Aladdin Enterprises παρέχει ένα παρεμφερές ελεύθερο PostScript® που ονομάζεται Ghostscript και δουλεύει άψογα στο FreeBSD. Το Ghostscript διαβάζει τα περισσότερα αρχεία PostScript® και μπορεί να αποδώσει τις σελίδες τους σε μεγάλη γκάμα συσκευών, συμπεριλαμβάνοντας πολλούς τύπους εκτυπωτών που δεν υποστηρίζουν PostScript®. Εγκαθιστώντας το Ghostscript και χρησιμοποιώντας ένα ειδικό φίλτρο κειμένου για τον εκτυπωτή σας, μπορείτε να κάνετε τον κοινό εκτυπωτή σας να λειτουργεί σαν ένας πραγματικός εκτυπωτής PostScript®.</p></div><div class=paragraph><p>Το Ghostscript βρίσκεται στην Συλλογή των Ports του FreeBSD, και μάλιστα σε πολλές εκδόσεις. Η πιο διαδεδομένη είναι το <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript-gpl/>print/ghostscript-gpl</a>.</p></div><div class=paragraph><p>Για να κάνετε προσομοίωση PostScript®, πρέπει το φίλτρο κειμένου να ανιχνεύσει αν εκτυπώνετε αρχείο PostScript®. Εάν όχι, τότε το φίλτρο θα περάσει το αρχείο κατευθείαν στον εκτυπωτή. Διαφορετικά, θα χρησιμοποιήσει το Ghostscript για να μετατρέψει αρχικά το αρχείο σε ένα τύπο που θα καταλαβαίνει ο εκτυπωτής.</p></div><div class=paragraph><p>Ιδού ένα παράδειγμα: το ακόλουθο script είναι ένα φίλτρο κειμένου για εκτυπωτές Hewlett Packard DeskJet 500. Για άλλους εκτυπωτές, αντικαταστήστε το όρισμα <code>-sDEVICE</code> στην εντολή <code>gs</code> (Ghostscript). (Πληκτρολογήστε <code>gs -h</code> για να δείτε την λίστα συσκευών που υποστηρίζει η τρέχουσα εγκατάσταση του Ghostscript.)</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  ifhp - Print Ghostscript-simulated PostScript on a DeskJet 500
#  Installed in /usr/local/libexec/ifhp

#
#  Treat LF as CR+LF (to avoid the &#34;staircase effect&#34; on HP/PCL
#  printers):
#
printf &#34;\033&amp;k2G&#34; || exit 2

#
#  Read first two characters of the file
#
IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

if [ &#34;$first_two_chars&#34; = &#34;%!&#34; ]; then
    #
    #  It is PostScript; use Ghostscript to scan-convert and print it.
    #
    /usr/local/bin/gs -dSAFER -dNOPAUSE -q -sDEVICE=djet500 \
      -sOutputFile=- - &amp;&amp; exit 0
else
    #
    #  Plain text or HP/PCL, so just print it directly; print a form feed
    #  at the end to eject the last page.
    #
    echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; printf &#34;\033&amp;l0H&#34; &amp;&amp;
exit 0
fi

exit 2</pre></div></div><div class=paragraph><p>Τέλος, χρειάζεται να ενημερώσετε το LPD για το φίλτρο με την ικανότητα <code>if</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/ifhp:</pre></div></div><div class=paragraph><p>Αυτό είναι όλο. Μπορείτε να πληκτρολογήσετε <code>lpr plain.text</code> και <code>lpr whatever.ps</code> και τα δύο θα εκτυπωθούν επιτυχώς.</p></div></div><div class=sect4><h5 id=printing-advanced-convfilters>16.4.1.4. Φίλτρα Μετατροπής<a class=anchor href=#printing-advanced-convfilters></a></h5><div class=paragraph><p>Το επόμενο βήμα μετά την ολοκλήρωση της απλής εγκατάστασης που περιγράψαμε στις <a href=#printing-simple>Βασικές Ρυθμίσεις Εκτυπωτών</a>, είναι συνήθως η εγκατάσταση φίλτρων μετατροπής για τους τύπους αρχείων που προτιμάτε (εκτός από απλό κείμενο ASCII).</p></div><div class=sect5><h6 id=_γιατί_να_εγκαταστήσετε_φίλτρα_μετατροπής>16.4.1.4.1. Γιατί να εγκαταστήσετε Φίλτρα Μετατροπής;<a class=anchor href=#_γιατί_να_εγκαταστήσετε_φίλτρα_μετατροπής></a></h6><div class=paragraph><p>Τα φίλτρα μετατροπής κάνουν την εκτύπωση διαφόρων τύπων αρχείων εύκολη υπόθεση. Για παράδειγμα, ας υποθέσουμε ότι έχουμε να κάνουμε αρκετή εργασία με το σύστημα στοιχειοθεσίας TeX, και ότι έχουμε εκτυπωτή PostScript®. Κάθε φορά που δημιουργούμε ένα αρχείο DVI με το TeX, δεν μπορούμε να εκτυπώσουμε κατευθείαν έως ότου να μετατρέψουμε το αρχείο DVI σε PostScript®. Η ακολουθία εντολών που πρέπει να ακολουθήσουμε είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dvips seaweed-analysis.dvi
% lpr seaweed-analysis.ps</code></pre></div></div><div class=paragraph><p>Με την χρήση ενός φίλτρου μετατροπής για αρχεία DVI, μπορούμε να αποφύγουμε την μετατροπή που πρέπει να κάνουμε κάθε φορά χειροκίνητα, καλώντας το LPD να κάνει τη δουλειά για μας. Τώρα, κάθε φορά που έχουμε ένα αρχείο DVI, για να το τυπώσουμε χρειάζεται μόνο ένα βήμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-d</span> seaweed-analysis.dvi</code></pre></div></div><div class=paragraph><p>Έχουμε αναθέσει στο LPD να κάνει τη μετατροπή του αρχείου DVI προσθέτοντας του την επιλογή <code>-d</code>. Η ενότητα <a href=#printing-lpr-options-format>Επιλογές Μορφοποίησης και Μετατροπής</a> περιέχει τους πίνακες επιλογής μετατροπών.</p></div><div class=paragraph><p>Για κάθε επιλογή μετατροπής που θέλετε να υποστηρίζετε από ένα εκτυπωτή, πρέπει να εγκαταστήσετε ένα <em>φίλτρο μετατροπής</em> και να ορίσετε την διαδρομή του στο αρχείο <span class=filename>/etc/printcap</span>. Ένα φίλτρο μετατροπής είναι σαν το φίλτρο κειμένου στην απλή εγκατάσταση εκτυπωτή (δείτε την ενότητα <a href=#printing-textfilter>Εγκατάσταση Φίλτρου Κειμένου</a>) με μόνη διαφορά πως αντί το φίλτρο να εκτυπώνει απλό κείμενο, μετατρέπει το αρχείο σε μια διαφορετική μορφή ώστε να είναι κατανοητό από τον εκτυπωτή.</p></div></div><div class=sect5><h6 id=_ποιο_φίλτρο_μετατροπής_θα_πρέπει_να_εγκαταστήσω>16.4.1.4.2. Ποιο Φίλτρο Μετατροπής θα Πρέπει να Εγκαταστήσω;<a class=anchor href=#_ποιο_φίλτρο_μετατροπής_θα_πρέπει_να_εγκαταστήσω></a></h6><div class=paragraph><p>Θα πρέπει να εγκαθιστάτε τα φίλτρα μετατροπής που νομίζετε πως θα χρησιμοποιήσετε. Αν εκτυπώνετε αρκετά δεδομένα DVI, τότε είναι λογικό να συμπεριλάβετε ένα φίλτρο μετατροπής DVI. Αν εκτυπώνετε συχνά δεδομένα troff, θα θέλετε να εγκαταστήσετε ένα φίλτρο troff.</p></div><div class=paragraph><p>Ο ακόλουθος πίνακας συνοψίζει τα φίλτρα με τα οποία συνεργάζεται το LPD, τις καταχωρίσεις της αντίστοιχης ικανότητας στο αρχείο <span class=filename>/etc/printcap</span>, και πως να τις καλέσετε μέσω της εντολής <code>lpr</code>:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Τύπος αρχείου</th><th class="tableblock halign-left valign-top">Ικανότητα /etc/printcap</th><th class="tableblock halign-left valign-top">Παράμετρος εντολής lpr</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cifplot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-c</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DVI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>df</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-d</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>plot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-g</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ditroff</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>nf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-n</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>FORTRAN text</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-f</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>troff</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>tf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-f</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>raster</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>vf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-v</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>plain text</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>if</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>none, <code>-p</code>, or <code>-l</code></p></td></tr></tbody></table><div class=paragraph><p>Στο παράδειγμα μας, αν χρησιμοποιήσουμε <code>lpr -d</code> σημαίνει ότι ο εκτυπωτής χρειάζεται την ικανότητα <code>df</code> στην καταχώριση του στο <span class=filename>/etc/printcap</span>.</p></div><div class=paragraph><p>Αν και κάποιοι μπορεί να ισχυριστούν το αντίθετο, μερικοί τύποι αρχείων όπως είναι τα κείμενα και γραφικά FORTRAN είναι ξεπερασμένα. Μπορείτε να δώσετε νέα πνοή σε αρχεία αυτού του τύπου (ή και οποιασδήποτε άλλης μορφής εξόδου), εγκαθιστώντας προσαρμοσμένα φίλτρα. Για παράδειγμα, ας υποθέσουμε ότι θα θέλατε να εκτυπώσετε κατευθείαν αρχεία Printerleaf (αρχεία προερχόμενα από το πρόγραμμα επιτραπέζιας τυπογραφίας Interleaf), αλλά δεν θα εκτυπώσετε ποτέ διαγράμματα (plots). Θα μπορούσατε να εγκαταστήσετε ένα φίλτρο μετατροπής αρχείων Printerleaf υπό την ικανότητα <code>gf</code> και να εκπαιδεύσετε τους χρήστες σας ότι η εντολή <code>lpr -g</code> σημαίνει "τύπωσε αρχεία Printerleaf."</p></div></div><div class=sect5><h6 id=_εγκατάσταση_φίλτρων_μετατροπών>16.4.1.4.3. Εγκατάσταση Φίλτρων Μετατροπών<a class=anchor href=#_εγκατάσταση_φίλτρων_μετατροπών></a></h6><div class=paragraph><p>Από τη στιγμή που τα φίλτρα μετατροπής είναι προγράμματα που δεν ανήκουν στο βασικό σύστημα εγκατάστασης του FreeBSD, είναι πιο σωστό να εγκατασταθούν στον κατάλογο <span class=filename>/usr/local</span>. Ένας συνήθης προορισμός των προγραμμάτων αυτών είναι ο κατάλογος <span class=filename>/usr/local/libexec</span>, μια που πρόκειται για εξειδικευμένα προγράμματα που εκτελούνται μόνο από το LPD. Οι απλοί χρήστες δεν θα χρειαστεί ποτέ να τα εκτελέσουν.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε ένα φίλτρο μετατροπής, προσδιορίστε τη διαδρομή του στο αρχείο <span class=filename>/etc/printcap</span>, αλλάζοντας την κατάλληλη ικανότητα στον εκτυπωτή που επιθυμείτε να το χρησιμοποιήσετε.</p></div><div class=paragraph><p>Στο παράδειγμα μας, θα προσθέσουμε το φίλτρο μετατροπής DVI στην καταχώριση μας για τον εκτυπωτή με το όνομα <code>bamboo</code>. Ακολουθεί, λοιπόν, το παράδειγμα για το αρχείο <span class=filename>/etc/printcap</span>, με την νέα ικανότητα <code>df</code> για τον εκτυπωτή <code>bamboo</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added df filter for bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Το φίλτρο DVI είναι ένα shell script που ονομάζεται <span class=filename>/usr/local/libexec/psdf</span>, το οποίο και παραθέτουμε παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psdf - DVI to PostScript printer filter
#  Installed in /usr/local/libexec/psdf
#
# Invoked by lpd when user runs lpr -d
#
exec /usr/local/bin/dvips -f | /usr/local/libexec/lprps &#34;$@&#34;</pre></div></div><div class=paragraph><p>Αυτό το script τρέχει το <code>dvips</code> σε κατάσταση φίλτρου (με την παράμετρο <code>-f</code>) στην standard input, από όπου και λαμβάνει την εργασία προς εκτύπωση. Αυτό ξεκινά το φίλτρο εκτύπωσης PostScript® <code>lprps</code> (δείτε την ενότητα <a href=#printing-advanced-if-conversion>Συμβατότητα Εργασιών Απλού Κειμένου σε εκτυπωτές PostScript®</a>) δίνοντας του και τις παραμέτρους που πέρασε το LPD στο παραπάνω script. Το <code>lprps</code> θα χρησιμοποιήσει αυτές τις παραμέτρους για την καταμέτρηση των εκτυπωμένων σελίδων.</p></div></div><div class=sect5><h6 id=_ακόμα_μερικά_παραδείγματα_φίλτρων_μετατροπής>16.4.1.4.4. Ακόμα μερικά Παραδείγματα Φίλτρων Μετατροπής<a class=anchor href=#_ακόμα_μερικά_παραδείγματα_φίλτρων_μετατροπής></a></h6><div class=paragraph><p>Από τη στιγμή που δεν υπάρχει αυτοματοποιημένη μέθοδος για την εγκατάσταση των φίλτρων μετατροπής, ας μας επιτραπεί να παρέχουμε μερικά ακόμη παραδείγματα. Μπορείτε να τα χρησιμοποιήσετε σαν οδηγό για την δημιουργία των δικών σας φίλτρων. Αν νομίζετε πως είναι κατάλληλα για την περίπτωση σας μπορείτε να τα χρησιμοποιήσετε και κατευθείαν.</p></div><div class=paragraph><p>Αυτό το παράδειγμα script είναι ένα φίλτρο μετατροπής ράστερ (αρχείου GIF για την ακρίβεια) για έναν εκτυπωτή Hewlett Packard LaserJet III-Si:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpvf - Convert GIF files into HP/PCL, then print
#  Installed in /usr/local/libexec/hpvf

PATH=/usr/X11R6/bin:$PATH; export PATH
giftopnm | ppmtopgm | pgmtopbm | pbmtolj -resolution 300 \
    &amp;&amp; exit 0 \
    || exit 2</pre></div></div><div class=paragraph><p>Δουλεύει ως εξής: μετατρέπει το αρχείο GIF σε ένα γενικό φορητό τύπο anymap, εν συνεχεία το μετατρέπει σε ένα φορητό τύπο graymap, έπειτα σε ένα φορητό τύπο bitmap, και τέλος το μετατρέπει σε δεδομένα συμβατά με PCL για τον LaserJet.</p></div><div class=paragraph><p>Εδώ είναι το αρχείο <span class=filename>/etc/printcap</span> με μια καταχώριση για έναν εκτυπωτή που χρησιμοποιεί το παραπάνω φίλτρο:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sh:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:\
        :vf=/usr/local/libexec/hpvf:</pre></div></div><div class=paragraph><p>Το ακόλουθο script είναι ένα φίλτρο μετατροπής δεδομένων troff από το σύστημα στοιχειοθεσίας groff για τον εκτυπωτή PostScript® με όνομα <code>bamboo</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  pstf - Convert groff&#39;s troff data into PS, then print.
#  Installed in /usr/local/libexec/pstf
#
exec grops | /usr/local/libexec/lprps &#34;$@&#34;</pre></div></div><div class=paragraph><p>Το παραπάνω script χρησιμοποιεί πάλι το <code>lprps</code> για να χειριστεί την επικοινωνία με τον εκτυπωτή. Αν ο εκτυπωτής ήταν σε παράλληλη πόρτα τότε θα είχαμε, αντιθέτως, χρησιμοποιήσει το ακόλουθο script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  pstf - Convert groff&#39;s troff data into PS, then print.
#  Installed in /usr/local/libexec/pstf
#
exec grops</pre></div></div><div class=paragraph><p>Εδώ είναι η καταχώριση που χρειάζεται να προσθέσουμε στο <span class=filename>/etc/printcap</span> για να ενεργοποιήσουμε το φίλτρο:</p></div><div class="literalblock programlisting"><div class=content><pre>:tf=/usr/local/libexec/pstf:</pre></div></div><div class=paragraph><p>Εδώ είναι ένα παράδειγμα που μας επιτρέπει να εκτυπώσουμε παλαιό κώδικα της FORTRAN. Είναι ένα φίλτρο κειμένου για FORTRAN για οποιονδήποτε εκτυπωτή μπορεί να εκτυπώσει κατευθείαν απλό κείμενο. Θα το εγκαταστήσουμε για έναν εκτυπωτή που ονομάζεται <code>teak</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# hprf - FORTRAN text filter for LaserJet 3si:
# Installed in /usr/local/libexec/hprf
#

printf &#34;\033&amp;k2G&#34; &amp;&amp; fpr &amp;&amp; printf &#34;\033&amp;l0H&#34; &amp;&amp;
 exit 0
exit 2</pre></div></div><div class=paragraph><p>Και θα προσθέσουμε αυτή τη γραμμή στο <span class=filename>/etc/printcap</span> για να ενεργοποιήσουμε το φίλτρο για τον εκτυπωτή <code>teak</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>:rf=/usr/local/libexec/hprf:</pre></div></div><div class=paragraph><p>Και ένα τελευταίο κάπως περίπλοκο παράδειγμα: Θα προσθέσουμε ένα φίλτρο DVI στον εκτυπωτή LaserJet <code>teak</code> που αναφέραμε προηγούμενα. Καταρχήν το εύκολο μέρος: αναβαθμίζουμε το <span class=filename>/etc/printcap</span> με την τοποθεσία όπου βρίσκεται το φίλτρο DVI:</p></div><div class="literalblock programlisting"><div class=content><pre>:df=/usr/local/libexec/hpdf:</pre></div></div><div class=paragraph><p>Τώρα, το δύσκολο μέρος: η κατασκευή του φίλτρου. Θα χρειαστούμε ένα πρόγραμμα μετατροπής από DVI-σε-LaserJet/PCL. Στην Συλλογή των Ports του FreeBSD (δείτε <a href=./#ports>Συλλογή των Ports</a>) υπάρχει ένα τέτοιο πρόγραμμα: Το όνομα του πακέτου είναι <code>dvi2xx</code>. Η εγκατάσταση του πακέτου, μας παρέχει ακριβώς το πρόγραμμα που χρειαζόμαστε, το <code>dvilj2p</code>, το οποίο μετατρέπει τον κώδικα DVI σε κώδικα συμβατό με LaserJet IIp, LaserJet III, και LaserJet 2000.</p></div><div class=paragraph><p>Το <code>dvilj2p</code> κάνει το φίλτρο <code>hpdf</code> αρκετά περίπλοκο από τη στιγμή που το <code>dvilj2p</code> δε μπορεί να διαβάσει από το standard input. Χρειάζεται να δουλέψει με κάποιο όνομα αρχείου. Ακόμη χειρότερα, το όνομα του αρχείου πρέπει να τελειώνει σε <span class=filename>.dvi</span> κι επομένως η χρήση του <span class=filename>/dev/fd/0</span> ως standard input είναι προβληματική. Θα μπορούσαμε να αντιμετωπίσουμε το πρόβλημα δημιουργώντας (συμβολικούς) δεσμούς με κάποιο προσωρινό όνομα αρχείου (που να τελειώνει σε <span class=filename>.dvi</span>) για το <span class=filename>/dev/fd/0</span>, και με αυτό τον τρόπο να εξαναγκάσουμε το <code>dvilj2p</code> να διαβάζει από το standard input.</p></div><div class=paragraph><p>Ακόμη ένα πρόβλημα που προκύπτει είναι το γεγονός πως δεν μπορούμε να χρησιμοποιήσουμε το <span class=filename>/tmp</span> για τον προσωρινό δεσμό. Οι συμβολικοί δεσμοί ανήκουν στον χρήστη και στην ομάδα <code>bin</code>, ενώ το φίλτρο τρέχει σαν χρήστης <code>daemon</code>. Επίσης στον κατάλογο <span class=filename>/tmp</span> είναι ενεργό το sticky bit. Το φίλτρο μπορεί να δημιουργήσει το δεσμό, αλλά δεν θα είναι ικανό να τον εξαλείψει και να τον αφαιρέσει από τη στιγμή που αυτός θα ανήκει σε διαφορετικό χρήστη.</p></div><div class=paragraph><p>Αντίθετα, το φίλτρο θα φτιάξει το συμβολικό link στον τρέχοντα κατάλογο, που είναι ο κατάλογος παροχέτευσης (spooling) (και που προσδιορίζεται από την ικανότητα <code>sd</code> στο <span class=filename>/etc/printcap</span>). Αυτό είναι το τέλειο μέρος για να δουλεύουν τα φίλτρα, ειδικά λόγω του ότι (μερικές φορές) υπάρχει περισσότερες ελεύθερος χώρος στο δίσκο στον κατάλογο παροχέτευσης (spool) από ότι στο <span class=filename>/tmp</span>.</p></div><div class=paragraph><p>Και τελικά, ιδού το φίλτρο:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpdf - Print DVI data on HP/PCL printer
#  Installed in /usr/local/libexec/hpdf

PATH=/usr/local/bin:$PATH; export PATH

#
#  Define a function to clean up our temporary files.  These exist
#  in the current directory, which will be the spooling directory
#  for the printer.
#
cleanup() {
   rm -f hpdf$$.dvi
}

#
#  Define a function to handle fatal errors: print the given message
#  and exit 2.  Exiting with 2 tells LPD to do not try to reprint the
#  job.
#
fatal() {
    echo &#34;$@&#34; 1&gt;&amp;2
    cleanup
    exit 2
}

#
#  If user removes the job, LPD will send SIGINT, so trap SIGINT
#  (and a few other signals) to clean up after ourselves.
#
trap cleanup 1 2 15

#
#  Make sure we are not colliding with any existing files.
#
cleanup

#
#  Link the DVI input file to standard input (the file to print).
#
ln -s /dev/fd/0 hpdf$$.dvi || fatal &#34;Cannot symlink /dev/fd/0&#34;

#
#  Make LF = CR+LF
#
printf &#34;\033&amp;k2G&#34; || fatal &#34;Cannot initialize printer&#34;

#
#  Convert and print.  Return value from dvilj2p does not seem to be
#  reliable, so we ignore it.
#
dvilj2p -M1 -q -e- dfhp$$.dvi

#
#  Clean up and exit
#
cleanup
exit 0</pre></div></div></div><div class=sect5><h6 id=printing-advanced-autoconv>16.4.1.4.5. Αυτοματοποιημένες Μετατροπές: Μία Εναλλακτική στα Φίλτρα Μετατροπής<a class=anchor href=#printing-advanced-autoconv></a></h6><div class=paragraph><p>Όλα τα φίλτρα μετατροπής μπορεί να πληρούν το περιβάλλον εκτυπώσεων σας, αλλά υποχρεώνουν τον χρήστη να προσδιορίζει (στην γραμμή εντολών του <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>) ποιό από αυτά θα χρησιμοποιηθεί. Αν οι χρήστες σας δεν είναι ιδιαίτερα εξοικειωμένοι με τους Η/Υ, το να πρέπει να αναφέρουν κάθε φορά ένα φίλτρο πιθανώς να είναι ενοχλητικό. Είναι ακόμα χειρότερο ωστόσο να γίνει λανθασμένη επιλογή φίλτρου, το οποίο θα εκτελεστεί σε ακατάλληλο για αυτό τύπο αρχείου, και θα προκαλέσει την σπατάλη εκατοντάδων σελίδων χαρτιού.</p></div><div class=paragraph><p>Αντί να εγκαταστήσετε οποιοδήποτε φίλτρο μετατροπής, μπορεί να θέλετε να δοκιμάσετε να έχετε ένα φίλτρο κειμένου (αφού είναι το προεπιλεγμένο φίλτρο) που να ανιχνεύει τον τύπο του αρχείου που έχει ζητηθεί να εκτυπωθεί και να εκτελεί αυτόματα το κατάλληλο φίλτρο μετατροπής. Εργαλεία σαν το <code>file</code> μπορούν να σας βοηθήσουν. Μπορεί να είναι δύσκολο να προσδιοριστούν οι διαφορές μεταξύ <em>κάποιων</em> τύπων αρχείων-αλλά, φυσικά, μπορείτε πάντα να παρέχετε φίλτρα μετατροπής ειδικά για αυτές τις περιπτώσεις.</p></div><div class=paragraph><p>Η Συλλογή των Ports του FreeBSD έχει ένα φίλτρο κειμένου που εκτελεί αυτόματες μετατροπές και ονομάζεται <code>apsfilter</code>. Μπορεί να ανιχνεύει απλό κείμενο, PostScript®, DVI και σχεδόν οποιοδήποτε τύπο αρχείου, να εκτελεί την κατάλληλη μετατροπή, και να εκτυπώνει.</p></div></div></div><div class=sect4><h5 id=printing-advanced-of>16.4.1.5. Φίλτρα Εξόδου<a class=anchor href=#printing-advanced-of></a></h5><div class=paragraph><p>Το σύστημα παροχέτευσης LPD υποστηρίζει έναν ακόμη τύπο φίλτρου που ίσως να μην έχετε εξερευνήσει ακόμα: το φίλτρο εξόδου. Το φίλτρο εξόδου προορίζεται μόνο για εκτύπωση απλού κειμένου, όπως το φίλτρο κειμένου, αλλά με πολλές απλοποιήσεις. Εάν χρησιμοποιείτε φίλτρο εξόδου αλλά όχι φίλτρο κειμένου, τότε:</p></div><div class=ulist><ul><li><p>Το LPD ξεκινά ένα φίλτρο εξόδου μόνο μια φορά για όλη την εργασία, αντί ένα χωριστό για κάθε αρχείο της εργασίας.</p></li><li><p>Το LPD δεν φροντίζει να αναγνωρίσει την αρχή ή το τέλος των αρχείων μέσα στην ίδια την εργασία όταν χρησιμοποιείται το φίλτρο εξόδου.</p></li><li><p>Το LPD δεν περνάει στο φίλτρο τα δεδομένα εισόδου του χρήστη ή το όνομα του μηχανήματος, επομένως δεν προορίζεται για καταμέτρηση εκτυπωμένων σελίδων. Το φίλτρο εξόδου δέχεται μόνος τις παραμέτρους:
+<code>filter-name</code> -w<em>width</em> -l<em>length</em></p><div class=paragraph><p>Όπου το <em>width</em> είναι από την ικανότητα <code>pw</code> και το <em>length</em> είναι από την ικανότητα <code>pl</code> για τον συγκεκριμένο εκτυπωτή.</p></div></li></ul></div><div class=paragraph><p>Μην παρασύρεστε από την απλότητα του φίλτρου εξόδου. Αν επιθυμείτε κάθε αρχείο μιας εργασίας να ξεκινά σε μια νέα σελίδα, το φίλτρο εξόδου <em>δεν κάνει για σας</em>. Χρησιμοποιήστε ένα φίλτρο κειμένου (γνωστό και ως φίλτρο εισόδου). Δείτε την ενότητα <a href=#printing-textfilter>Εγκατάσταση Φίλτρου Κειμένου</a>. Επιπλέον, ένα φίλτρο εξόδου είναι στην πραγματικότητα <em>πιο περίπλοκο</em> αφού πρέπει να εξετάζει την ροή των byte που αποστέλλεται προς αυτό για ειδικούς χαρακτήρες flag και πρέπει να στέλνει σήματα στον εαυτό του για λογαριασμό του LPD.</p></div><div class=paragraph><p>Ωστόσο, ένα φίλτρο εξόδου είναι <em>αναγκαίο</em> αν θέλετε σελίδες κεφαλίδας και χρειάζεται να στέλνετε ακολουθίες διαφυγής ή άλλες ακολουθίες αρχικοποίησης προκειμένου να τις εκτυπώσετε. (Αλλά είναι επίσης <em>μάταιο</em> αν θέλετε να χρεώνετε σελίδες κεφαλίδας στον λογαριασμό του αντίστοιχου χρήστη, από τη στιγμή που το LPD δεν στέλνει καμιά πληροφορία για τον χρήστη ή τον υπολογιστή στο φίλτρο εξόδου.)</p></div><div class=paragraph><p>Το LPD επιτρέπει την συνύπαρξη ενός φίλτρου εξόδου και άλλων φίλτρων (κειμένου ή διαφορετικού τύπου) στον ίδιο εκτυπωτή. Σε αυτές τις περιπτώσεις, το LPD θα ξεκινά το φίλτρο εξόδου μόνο για την εκτύπωση της σελίδας κεφαλίδας (δείτε την ενότητα <a href=#printing-advanced-header-pages>Σελίδες Κεφαλίδας</a>). Το LPD θα αναμένει το φίλτρο εξόδου να <em>σταματήσει από μόνο του</em> όταν του στείλει δύο bytes: ένα ASCII 031 ακολουθούμενο από ένα ASCII 001. Όταν ένα φίλτρο εξόδου βλέπει αυτά τα δύο bytes (031, 001), θα πρέπει να σταματά στέλνοντας σήμα <code>SIGSTOP</code> στον εαυτό του. Όταν το LPD ολοκληρώσει την εκτέλεση και των υπολοίπων φίλτρων, θα επανεκκινήσει το φίλτρο εξόδου στέλνοντας του το σήμα <code>SIGCONT</code>.</p></div><div class=paragraph><p>Αν υπάρχει φίλτρο εξόδου, αλλά <em>δεν υπάρχει</em> φίλτρο κειμένου και το LPD δουλεύει σε εργασία απλού κειμένου, το LPD χρησιμοποιεί το φίλτρο εξόδου για την εκτέλεση της εργασίας. Όπως αναφέραμε και παραπάνω, το φίλτρο εξόδου θα εκτυπώσει κάθε αρχείο εργασίας στη σειρά, δίχως δυνατότητα παρεμβολής κενής σελίδας ή άλλων ρυθμίσεων στην τροφοδοσία χαρτιού, και πιθανώς αυτό να <em>μην</em> είναι επιθυμητό. Σχεδόν σε όλες τις περιπτώσεις, θα χρειαστείτε ένα φίλτρο κειμένου.</p></div><div class=paragraph><p>Το πρόγραμμα <code>lpf</code>, που αναφέραμε νωρίτερα σαν φίλτρο κειμένου, μπορεί να τρέξει και σαν φίλτρο εξόδου. Αν χρειάζεστε ένα γρήγορο φίλτρο εξόδου αλλά δεν θέλετε να γράψετε τον κώδικα ανίχνευσης των byte και τον κώδικα αποστολής σημάτων, δοκιμάστε το <code>lpf</code>. Μπορείτε επίσης να χρησιμοποιήσετε το <code>lpf</code> μέσα από ένα shell script το οποίο θα χειρίζεται τους κωδικούς αρχικοποίησης που ίσως να χρειάζεται ο εκτυπωτής.</p></div></div><div class=sect4><h5 id=printing-advanced-lpf>16.4.1.6. <code>lpf</code>: ένα Φίλτρο Κειμένου<a class=anchor href=#printing-advanced-lpf></a></h5><div class=paragraph><p>Το πρόγραμμα <span class=filename>/usr/libexec/lpr/lpf</span> που παρέχεται με τη διανομή εκτελέσιμων του FreeBSD είναι ένα φίλτρο κειμένου (φίλτρο εισόδου) που μπορεί να παραγραφοποιεί την έξοδο (εργασίες που έχουν σταλεί με <code>lpr -i</code>), να επιτρέπει την διέλευση literal χαρακτήρων (εργασίες που έχουν σταλεί με <code>lpr -l</code>), να ρυθμίζει την θέση εκτύπωσης με τη χρήση χαρακτήρων backspace και tab στην εργασία, και να κάνει καταμέτρηση των εκτυπωμένων σελίδων. Επίσης μπορεί να ενεργεί και σαν φίλτρο εξόδου.</p></div><div class=paragraph><p>Το <code>lpf</code> είναι κατάλληλο για διάφορα περιβάλλοντα εκτύπωσης. Αν και δεν έχει δυνατότητα αποστολής ακολουθιών αρχικοποίησης στον εκτυπωτή, είναι εύκολο να γράψετε ένα shell script για να κάνετε την απαραίτητη αρχικοποίηση και να εκτελέσετε έπειτα το <code>lpf</code>.</p></div><div class=paragraph><p>Για να κάνει σωστά καταμέτρηση σελίδων, το <code>lpf</code> χρειάζεται κατάλληλες τιμές για τις ικανότητες <code>pw</code> και <code>pl</code> στο αρχείο <span class=filename>/etc/printcap</span>. Χρησιμοποιεί αυτές τις τιμές για να προσδιορίσει πόσο κείμενο μπορεί να χωρέσει σε μία σελίδα και από πόσες σελίδες αποτελείται η εργασία του χρήστη. Για περισσότερες πληροφορίες σχετικά με την καταμέτρηση σελίδων, συμβουλευτείτε την <a href=#printing-advanced-acct>Καταμέτρηση Χρήσης Εκτυπωτών</a>.</p></div></div></div><div class=sect3><h4 id=printing-advanced-header-pages>16.4.2. Σελίδες Κεφαλίδας<a class=anchor href=#printing-advanced-header-pages></a></h4><div class=paragraph><p>Αν έχετε <em>αρκετούς</em> χρήστες, και όλοι τους χρησιμοποιούν διάφορους εκτυπωτές, τότε πιθανώς να θεωρείτε τις <em>σελίδες κεφαλίδας</em> ως αναγκαίο κακό.</p></div><div class=paragraph><p>Οι σελίδες κεφαλίδας, γνωστές επίσης και ως <em>banner</em> ή <em>σελίδες burst</em> αναγνωρίζουν σε ποιον ανήκουν οι εργασίες μετά την εκτύπωση τους. Συνήθως τυπώνονται με μεγάλα, έντονα γράμματα, και ίσως με διακοσμητικά περιγράμματα, ώστε σε μια στοίβα εκτυπώσεων να ξεχωρίζουν από τα πραγματικά έγγραφα εργασιών των χρηστών. Επιτρέπουν έτσι στους χρήστες να βρίσκουν γρήγορα τις εργασίες τους. Το προφανές μειονέκτημα σε μια σελίδα κεφαλίδας είναι πως πρόκειται να εκτυπωθεί μια ακόμα σελίδα για κάθε μία εργασία. Η εφήμερη χρησιμότητα τους διαρκεί λίγα λεπτά, και ο προορισμός τους είναι ο κάδος αχρήστων/ανακύκλωσης. (Παρατηρήστε πως οι σελίδες κεφαλίδας είναι ανά εργασία, και όχι ανά αρχείο σε μια εργασία, επομένως το αχρηστευμένο χαρτί ίσως να μην είναι τόσο πολύ).</p></div><div class=paragraph><p>Το σύστημα LPD μπορεί να παρέχει αυτόματα σελίδες κεφαλίδας για τις εκτυπώσεις σας, <em>αν</em> ο εκτυπωτής σας μπορεί να εκτυπώσει άμεσα απλό κείμενο. Αν έχετε εκτυπωτή PostScript®, θα χρειαστείτε ένα εξωτερικό πρόγραμμα για να δημιουργήσετε την σελίδα κεφαλίδας. Δείτε το <a href=#printing-advanced-header-pages-ps>Σελίδες Κεφαλίδας σε Εκτυπωτές PostScript®</a>.</p></div><div class=sect4><h5 id=printing-advanced-header-pages-enabling>16.4.2.1. Ενεργοποίηση Σελίδων Κεφαλίδας<a class=anchor href=#printing-advanced-header-pages-enabling></a></h5><div class=paragraph><p>Στην ενότητα <a href=#printing-simple>Βασικές Ρυθμίσεις Εκτυπωτών</a>, απενεργοποιήσαμε τις σελίδες κεφαλίδας με την καταχώριση <code>sh</code> (σημαίνει "suppress header") στο αρχείο <span class=filename>/etc/printcap</span>. Για να ενεργοποιήσετε τις σελίδες κεφαλίδας για κάποιον εκτυπωτή, απλά αφαιρέστε την ικανότητα <code>sh</code>.</p></div><div class=paragraph><p>Ακούγεται εύκολο, δεν νομίζετε;</p></div><div class=paragraph><p>Έτσι είναι. <em>Ίσως</em> χρειαστεί να παρέχετε ένα φίλτρο εξόδου για να στείλετε εντολές αρχικοποίησης στον εκτυπωτή. Εδώ είναι ένα παράδειγμα φίλτρου εξόδου για εκτυπωτές συμβατούς με τον τύπο PCL της Hewlett Packard:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpof - Output filter for Hewlett Packard PCL-compatible printers
#  Installed in /usr/local/libexec/hpof

printf &#34;\033&amp;k2G&#34; || exit 2
exec /usr/libexec/lpr/lpf</pre></div></div><div class=paragraph><p>Προσδιορίστε την διαδρομή προς το φίλτρο εξόδου στην ικανότητα <code>of</code>. Δείτε την ενότητα <a href=#printing-advanced-of>Φίλτρα Εξόδου</a> για περισσότερες πληροφορίες.</p></div><div class=paragraph><p>Εδώ είναι ένα παράδειγμα αρχείου <span class=filename>/etc/printcap</span> για τον εκτυπωτή <code>teak</code> από το προηγούμενο παράδειγμα. Ενεργοποιήσαμε τις σελίδες κεφαλίδας και προσθέσαμε το παραπάνω φίλτρο εξόδου:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:\
        :vf=/usr/local/libexec/hpvf:\
        :of=/usr/local/libexec/hpof:</pre></div></div><div class=paragraph><p>Τώρα, όταν οι χρήστες εκτυπώνουν εργασίες στον <code>teak</code>, θα παίρνουν και μία σελίδα κεφαλίδας ανά εργασία. Αν οι χρήστες θέλουν να ξοδεύουν χρόνο ψάχνοντας για τις εκτυπώσεις τους, μπορούν να παρεμποδίσουν τις σελίδες κεφαλίδας αποστέλλοντας τις εργασίες τους με <code>lpr -h</code>. Δείτε την ενότητα <a href=#printing-lpr-options-misc>Επιλογές Σελίδων Κεφαλίδας</a> για περισσότερες επιλογές του <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το LPD στέλνει το χαρακτήρα αλλαγής σελίδας (form feed) αμέσως μετά τη σελίδα κεφαλίδας. Αν ο εκτυπωτής σας χρησιμοποιεί διαφορετικό χαρακτήρα ή ακολουθία χαρακτήρων για την αλλαγή σελίδας, προσδιορίστε τα με την ικανότητα <code>ff</code> στο αρχείο <span class=filename>/etc/printcap</span>.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=printing-advanced-header-pages-controlling>16.4.2.2. Έλεγχος Σελίδων Κεφαλίδας<a class=anchor href=#printing-advanced-header-pages-controlling></a></h5><div class=paragraph><p>Μετά την ενεργοποίηση των σελίδων κεφαλίδας, το LPD θα παράγει μία <em>επιμήκη κεφαλίδα</em>, μία ολόκληρη σελίδα με μεγάλα γράμματα που προσδιορίζει τον χρήστη, τον υπολογιστή (host), και την εργασία. Εδώ είναι ένα παράδειγμα (η <code>kelly</code> εκτύπωσε την εργασία με όνομα "outline" από τον υπολογιστή <code>rose</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>      k                   ll       ll
      k                    l        l
      k                    l        l
      k   k     eeee       l        l     y    y
      k  k     e    e      l        l     y    y
      k k      eeeeee      l        l     y    y
      kk k     e           l        l     y    y
      k   k    e    e      l        l     y   yy
      k    k    eeee      lll      lll     yyy y
                                               y
                                          y    y
                                           yyyy

                                   ll
                          t         l        i
                          t         l
       oooo    u    u   ttttt       l       ii     n nnn     eeee
      o    o   u    u     t         l        i     nn   n   e    e
      o    o   u    u     t         l        i     n    n   eeeeee
      o    o   u    u     t         l        i     n    n   e
      o    o   u   uu     t  t      l        i     n    n   e    e
       oooo     uuu u      tt      lll      iii    n    n    eeee

      r rrr     oooo     ssss     eeee
      rr   r   o    o   s    s   e    e
      r        o    o    ss      eeeeee
      r        o    o      ss    e
      r        o    o   s    s   e    e
      r         oooo     ssss     eeee

                                              Job:  outline
                                              Date: Sun Sep 17 11:04:58 1995</code></pre></div></div><div class=paragraph><p>Το LPD προσθέτει μια εντολή αλλαγής σελίδας (form feed) μετά από αυτό το κείμενο έτσι ώστε η εργασία να ξεκινήσει σε νέα σελίδα (εκτός αν έχετε προσδιορίσει την ικανότητα <code>sf</code> (suppress form feeds) για τον εκτυπωτή στο αρχείο <span class=filename>/etc/printcap</span>).</p></div><div class=paragraph><p>Αν προτιμάτε, το LPD μπορεί να φτιάξει μια <em>μικρότερου μήκους κεφαλίδα</em>. Προσδιορίστε <code>sb</code> (short banner) στο αρχείο <span class=filename>/etc/printcap</span>. Η σελίδα κεφαλίδας θα μοιάζει σαν αυτή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>rose:kelly  Job: outline  Date: Sun Sep 17 11:07:51 1995</code></pre></div></div><div class=paragraph><p>Το LPD τυπώνει (από προεπιλογή) πρώτα την σελίδα κεφαλίδας, και μετά την εργασία. Για να αντιστρέψετε την σειρά, χρησιμοποιήστε την ικανότητα <code>hl</code> (header last) στο αρχείο <span class=filename>/etc/printcap</span>.</p></div></div><div class=sect4><h5 id=printing-advanced-header-pages-accounting>16.4.2.3. Καταμέτρηση με Σελίδες Κεφαλίδας<a class=anchor href=#printing-advanced-header-pages-accounting></a></h5><div class=paragraph><p>Η χρήση των προεγκατεστημένων σελίδων κεφαλίδας του LPD ουσιαστικά υποχρεώνουν την τήρηση του παρακάτω κανόνα όταν κάνουμε καταμέτρηση χρήσης του εκτυπωτή: Οι σελίδες κεφαλίδας πρέπει να διατίθενται <em>ελεύθερα (δίχως χρέωση)</em>.</p></div><div class=paragraph><p>Γιατί;</p></div><div class=paragraph><p>Διότι το φίλτρο εξόδου είναι το μοναδικό εξωτερικό πρόγραμμα που έχει τον έλεγχο στην εκτύπωση της κεφαλίδας και θα μπορούσε να κάνει καταμέτρηση, αλλά ωστόσο δεν παρέχει καμία πληροφορία για <em>τον χρήστη ή τον υπολογιστή</em> ή κάποιο άλλο αρχείο καταμέτρησης, επομένως δεν γνωρίζει σε ποιόν να αποδώσει την χρήση του εκτυπωτή. Δεν αρκεί απλά να "προσθέσετε μία ακόμη σελίδα στην καταμέτρηση" τροποποιώντας το φίλτρο κειμένου ή οποιοδήποτε άλλο φίλτρο μετατροπής (το οποίο διαθέτει τις πληροφορίες χρήστη και υπολογιστή), από τη στιγμή που οι χρήστες έχουν την δυνατότητα να παρεμποδίσουν τις σελίδες κεφαλίδας με <code>lpr -h</code>. Θα μπορούσαν πάλι να χρεωθούν για σελίδες κεφαλίδας που δεν εκτύπωσαν. Βασικά, η <code>lpr -h</code> θα είναι η προτιμώμενη επιλογή σε ένα περιβάλλον που οι χρήστες έχουν οικολογική συνείδηση, αλλά δεν μπορείτε πραγματικά να παροτρύνετε οποιονδήποτε να τη χρησιμοποιήσει.</p></div><div class=paragraph><p><em>Δεν είναι αρκετό</em> απλά κάθε φίλτρο σας να δημιουργεί τη δικιά του σελίδα κεφαλίδας (έτσι ώστε να μπορεί να χρεώνει με αυτό τον τρόπο). Αν οι χρήστες επιθυμούν την επιλογή παρεμπόδισης των σελίδων κεφαλίδας με <code>lpr -h</code>, θα συνεχίσουν να τις παραλαμβάνουν - και να χρεώνονται για αυτές - αφού το LPD δεν έχει δυνατότητα να περάσει σε οποιοδήποτε φίλτρο την επιλογή <code>-h</code>.</p></div><div class=paragraph><p>Επομένως, ποιες επιλογές έχετε;</p></div><div class=paragraph><p>Μπορείτε:</p></div><div class=ulist><ul><li><p>Να αποδεχθείτε την υπόδειξη του LPD και να παρέχετε τις σελίδες κεφαλίδας ελεύθερα.</p></li><li><p>Να εγκαταστήσετε εναλλακτικές λύσεις αντί του LPD, όπως το LPRng. Η ενότητα <a href=#printing-lpd-alternatives>Εναλλακτικές Λύσεις για τον Στάνταρ Spooler</a> δίνει περισσότερες πληροφορίες για άλλες εφαρμογές παροχέτευσης που μπορείτε να χρησιμοποιήσετε αντί για το LPD.</p></li><li><p>Να γράψετε ένα <em>έξυπνο</em> φίλτρο εξόδου. Υπό κανονικές συνθήκες, ένα "φίλτρο εξόδου" δεν κάνει τίποτε παραπάνω από την αρχικοποίηση ενός εκτυπωτή ή μερικές απλές μετατροπές χαρακτήρων. Είναι κατάλληλο για σελίδες κεφαλίδας και για εργασίες απλού κειμένου (όταν δεν υπάρχει φίλτρο (εισόδου) κειμένου). Αλλά αν υπάρχει φίλτρο κειμένου για εργασίες απλού κειμένου, τότε το LPD θα ενεργοποιεί το φίλτρο εξόδου μόνο για τις σελίδες κεφαλίδας. Και το φίλτρο εξόδου μπορεί να αναλύει το κείμενο της σελίδας κεφαλίδας που δημιουργεί το LPD για να προσδιορίζει τον χρήστη και τον υπολογιστή, ώστε να χρεώνει τις σελίδες κεφαλίδας. Το μόνο επιπλέον πρόβλημα με αυτή τη μέθοδο είναι πως το φίλτρο εξόδου εξακολουθεί να μη γνωρίζει ποιό αρχείο καταμέτρησης να χρησιμοποιήσει (δεν του έχει δοθεί το όνομα του αρχείου από την ικανότητα <code>af</code>), αλλά αν το όνομα του αρχείου σας είναι γνωστό, μπορείτε να το ενσωματώσετε απευθείας στον κώδικα του φίλτρου εξόδου. Για να διευκολύνετε την διαδικασία ανάλυσης, χρησιμοποιήστε την ικανότητα <code>sh</code> (short header) στο <span class=filename>/etc/printcap</span>. Ίσως πάλι όλα αυτά να είναι υπερβολικά κοπιαστικά, ενώ είναι σίγουρο πως οι χρήστες θα εκτιμήσουν τον γενναιόδωρο διαχειριστή συστήματος που επιτρέπει ελεύθερα τις σελίδες κεφαλίδας.</p></li></ul></div></div><div class=sect4><h5 id=printing-advanced-header-pages-ps>16.4.2.4. Σελίδες Κεφαλίδας σε Εκτυπωτές PostScript®<a class=anchor href=#printing-advanced-header-pages-ps></a></h5><div class=paragraph><p>Όπως περιγράψαμε παραπάνω, το LPD μπορεί να δημιουργήσει μία σελίδα κεφαλίδας απλού κειμένου, κατάλληλη για πολλούς εκτυπωτές. Οι εκτυπωτές PostScript®, φυσικά, δεν μπορούν να τυπώσουν κατευθείαν απλό κείμενο, επομένως αυτή η δυνατότητα του LPD για τις σελίδες κεφαλίδας είναι άχρηστη σε αυτή την περίπτωση.</p></div><div class=paragraph><p>Ένας προφανής τρόπος να παρέχονται σελίδες κεφαλίδας είναι να δημιουργούνται από κάθε φίλτρο μετατροπής και το φίλτρο κειμένου. Τα φίλτρα θα πρέπει να δέχονται ως παραμέτρους το όνομα του χρήστη και του υπολογιστή ώστε να δημιουργούν την κατάλληλη σελίδα κεφαλίδας. Το μειονέκτημα αυτής της μεθόδου είναι πως οι χρήστες θα εκτυπώνουν πάντα σελίδα κεφαλίδας, ακόμη κι αν αποστέλλουν την εργασία τους με <code>lpr -h</code>.</p></div><div class=paragraph><p>Επιτρέψτε μας να εξερευνήσουμε αυτή τη μέθοδο. Το ακόλουθο script δέχεται τρεις παραμέτρους (το όνομα χρήστη - login name, το όνομα του υπολογιστή - host name, και το όνομα εργασίας) και δημιουργεί μία απλή σελίδα κεφαλίδας PostScript®:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  make-ps-header - make a PostScript header page on stdout
#  Installed in /usr/local/libexec/make-ps-header
#

#
#  These are PostScript units (72 to the inch).  Modify for A4 or
#  whatever size paper you are using:
#
page_width=612
page_height=792
border=72

#
#  Check arguments
#
if [ $# -ne 3 ]; then
    echo &#34;Usage: `basename $0` &lt;user&gt; &lt;host&gt; &lt;job&gt;&#34; 1&gt;&amp;2
    exit 1
fi

#
#  Save these, mostly for readability in the PostScript, below.
#
user=$1
host=$2
job=$3
date=`date`

#
#  Send the PostScript code to stdout.
#
exec cat &lt;&lt;EOF
%!PS

%
%  Make sure we do not interfere with user&#39;s job that will follow
%
save

%
%  Make a thick, unpleasant border around the edge of the paper.
%
$border $border moveto
$page_width $border 2 mul sub 0 rlineto
0 $page_height $border 2 mul sub rlineto
currentscreen 3 -1 roll pop 100 3 1 roll setscreen
$border 2 mul $page_width sub 0 rlineto closepath
0.8 setgray 10 setlinewidth stroke 0 setgray

%
%  Display user&#39;s login name, nice and large and prominent
%
/Helvetica-Bold findfont 64 scalefont setfont
$page_width ($user) stringwidth pop sub 2 div $page_height 200 sub moveto
($user) show

%
%  Now show the boring particulars
%
/Helvetica findfont 14 scalefont setfont
/y 200 def
[ (Job:) (Host:) (Date:) ] {
200 y moveto show /y y 18 sub def }
forall

/Helvetica-Bold findfont 14 scalefont setfont
/y 200 def
[ ($job) ($host) ($date) ] {
        270 y moveto show /y y 18 sub def
} forall

%
% That is it
%
restore
showpage
EOF</pre></div></div><div class=paragraph><p>Τώρα, καθένα από τα φίλτρα μετατροπής και το φίλτρο κειμένου μπορούν να καλέσουν το script, πρώτα για να δημιουργήσουν τη σελίδα κεφαλίδας, και έπειτα για να εκτυπώσουν την εργασία του χρήστη. Ακολουθεί το φίλτρο μετατροπής DVI που δείξαμε νωρίτερα, ειδικά διαμορφωμένο για να φτιάξουμε μια σελίδα κεφαλίδας:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psdf - DVI to PostScript printer filter
#  Installed in /usr/local/libexec/psdf
#
#  Invoked by lpd when user runs lpr -d
#

orig_args=&#34;$@&#34;

fail() {
    echo &#34;$@&#34; 1&gt;&amp;2
    exit 2
}

while getopts &#34;x:y:n:h:&#34; option; do
    case $option in
        x|y)  ;; # Ignore
        n)    login=$OPTARG ;;
        h)    host=$OPTARG ;;
        *)    echo &#34;LPD started `basename $0` wrong.&#34; 1&gt;&amp;2
              exit 2
              ;;
    esac
done

[ &#34;$login&#34; ] || fail &#34;No login name&#34;
[ &#34;$host&#34; ] || fail &#34;No host name&#34;

( /usr/local/libexec/make-ps-header $login $host &#34;DVI File&#34;
  /usr/local/bin/dvips -f ) | eval /usr/local/libexec/lprps $orig_args</pre></div></div><div class=paragraph><p>Παρατηρήστε πως το φίλτρο πρέπει να αναλύσει την λίστα παραμέτρων για να προσδιορίσει το όνομα χρήστη και υπολογιστή. Η μέθοδος ανάλυσης είναι παρόμοια και για τα υπόλοιπα φίλτρα μετατροπής. Το φίλτρο κειμένου παίρνει ένα ελαφρώς διαφορετικό σετ παραμέτρων, (δείτε την ενότητα <a href=#printing-advanced-filters>Πως δουλεύουν τα Φίλτρα</a>).</p></div><div class=paragraph><p>Όπως αναφέραμε προηγούμενα, ο παραπάνω σχεδιασμός, αν και πραγματικά απλός, απενεργοποιεί την επιλογή "παρεμπόδισης σελίδων κεφαλίδας" (την επιλογή <code>-h</code>) του <code>lpr</code>. Αν οι χρήστες επιθυμούν να σώσουν ένα δέντρο (ή λίγα χρήματα, αν χρεώνετε τις σελίδες κεφαλίδας), δεν θα υπάρχει τρόπος για να γίνει αυτό, από τη στιγμή που κάθε εκτύπωση μέσω των φίλτρων θα συνοδεύεται και από μια σελίδα κεφαλίδας για κάθε εργασία.</p></div><div class=paragraph><p>Για να επιτρέψετε στους χρήστες να απενεργοποιούν τις σελίδες κεφαλίδας ανά εργασία, θα πρέπει να χρησιμοποιήσετε το τέχνασμα που παρουσιάσαμε στην ενότητα <a href=#printing-advanced-header-pages-accounting>Καταμέτρηση με Σελίδες Κεφαλίδας</a>: δηλαδή να γράψετε ένα φίλτρο εξόδου που να αναλύει την σελίδα κεφαλίδας που δημιουργείται από το LPD και να κατασκευάζει μια PostScript® έκδοση. Αν ο χρήστης στείλει μια εργασία με <code>lpr -h</code>, τότε ούτε το LPD, ούτε το φίλτρο εξόδου θα φτιάξουν σελίδα κεφαλίδας. Σε όλες τις άλλες περιπτώσεις, το φίλτρο εξόδου θα διαβάζει το κείμενο από το LPD και θα στέλνει τον κατάλληλο κώδικα PostScript® στον εκτυπωτή ώστε να εκτυπώνεται η σελίδα κεφαλίδας.</p></div><div class=paragraph><p>Αν έχετε εκτυπωτή PostScript® με σειριακή σύνδεση, μπορείτε να κάνετε χρήση της <code>lprps</code>, η οποία συνοδεύεται από ένα φίλτρο εξόδου, το <code>psof</code>, το οποία κάνει τα παραπάνω. Σημειώστε πως το <code>psof</code> δεν χρεώνει για τις σελίδες κεφαλίδας.</p></div></div></div><div class=sect3><h4 id=printing-advanced-network-printers>16.4.3. Εκτυπώσεις μέσω Δικτύου<a class=anchor href=#printing-advanced-network-printers></a></h4><div class=paragraph><p>Το FreeBSD υποστηρίζει τις εκτυπώσεις μέσω δικτύου: μπορεί να στείλει εργασίες σε απομακρυσμένους εκτυπωτές. Η έννοια της δικτυακής εκτύπωσης αναφέρεται γενικά σε δύο διαφορετικά πράγματα:</p></div><div class=ulist><ul><li><p>Πρόσβαση σε εκτυπωτή συνδεδεμένο σε απομακρυσμένο υπολογιστή (host). Εγκαθιστάτε έναν εκτυπωτή με συμβατική σειριακή ή παράλληλη σύνδεση σε ένα υπολογιστή. Έπειτα, ρυθμίζετε το LPD για να ενεργοποιηθεί η πρόσβαση στον εκτυπωτή από άλλους υπολογιστές του δικτύου. Η ενότητα <a href=#printing-advanced-network-rm>Εκτυπωτές Εγκατεστημένοι σε Απομακρυσμένους Υπολογιστές</a> εξηγεί τις απαραίτητες ενέργειες.</p></li><li><p>Πρόσβαση σε εκτυπωτή συνδεδεμένο κατευθείαν στο δίκτυο. Εκτός (ή αντί) της συμβατικής σειριακής ή παράλληλης θύρας, ο εκτυπωτής πρέπει να έχει επιπρόσθετα μια δικτυακή διασύνδεση. Ένας τέτοιος εκτυπωτής δουλεύει ως εξής:</p><div class=ulist><ul><li><p>Μπορεί να καταλαβαίνει το πρωτόκολλο LPD και να δημιουργεί ουρά αναμονής για τις εργασίες που προέρχονται από απομακρυσμένους υπολογιστές. Σε αυτή την περίπτωση, ενεργεί σαν ένας κανονικός υπολογιστής που εκτελεί το LPD. Ακολουθήστε την ίδια διαδικασία με την ενότητα <a href=#printing-advanced-network-rm>Εκτυπωτές Εγκατεστημένοι σε Απομακρυσμένους Υπολογιστές</a> για να εγκαταστήσετε αυτόν τον εκτυπωτή.</p></li><li><p>Μπορεί να υποστηρίζει σύνδεση δικτυακής ροής δεδομένων (data stream). Σε αυτή την περίπτωση, "συνδέετε" τον εκτυπωτή σε έναν υπολογιστή συνδεδεμένο στο δίκτυο, ο οποίος θα είναι υπεύθυνος για την παροχέτευση των εργασιών και την αποστολή τους στον εκτυπωτή. Η ενότητα <a href=#printing-advanced-network-net-if>Εκτυπωτές Με Συνδέσεις Δικτύου</a> δίνει μερικές συμβουλές για την εγκατάσταση εκτυπωτών αυτού του τύπου.</p></li></ul></div></li></ul></div><div class=sect4><h5 id=printing-advanced-network-rm>16.4.3.1. Εκτυπωτές Εγκατεστημένοι σε Απομακρυσμένους Υπολογιστές<a class=anchor href=#printing-advanced-network-rm></a></h5><div class=paragraph><p>Το σύστημα παροχέτευσης LPD έχει ενσωματωμένη υποστήριξη για την αποστολή εργασιών σε άλλους υπολογιστές που εκτελούν το LPD (ή που είναι συμβατοί με το LPD). Αυτό το χαρακτηριστικό σας επιτρέπει να εγκαταστήσετε έναν εκτυπωτή σε ένα υπολογιστή και να έχετε πρόσβαση σε αυτόν από άλλους. Επίσης δουλεύει και με εκτυπωτές που έχουν δικτυακές διασυνδέσεις που καταλαβαίνουν το πρωτόκολλο LPD.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε αυτόν τον τύπο απομακρυσμένης εκτύπωσης, εγκαταστήστε πρώτα έναν εκτυπωτή σε ένα υπολογιστή, τον <em>υπολογιστή εκτύπωσης (printer host)</em>, χρησιμοποιώντας την απλή εγκατάσταση εκτυπωτή που περιγράφεται στην ενότητα <a href=#printing-simple>Βασικές Ρυθμίσεις Εκτυπωτών</a>. Κάντε όσες προχωρημένες ρυθμίσεις χρειάζεστε όπως αναφέρεται στις <a href=#printing-advanced>Ρυθμίσεις Εκτυπωτών για Προχωρημένους</a>. Ελέγξτε τον εκτυπωτή και δείτε αν δουλεύει με τα χαρακτηριστικά του LPD που έχετε ενεργοποιήσει. Επίσης βεβαιωθείτε πως ο <em>τοπικός υπολογιστής (local host)</em> είναι εξουσιοδοτημένος να χρησιμοποιεί τις υπηρεσίες του LPD στον <em>απομακρυσμένο υπολογιστή (remote host)</em> (δείτε <a href=#printing-advanced-restricting-remote>Παρεμπόδιση Εργασιών από Απομακρυσμένους Υπολογιστές</a>).</p></div><div class=paragraph><p>Εάν χρησιμοποιείτε εκτυπωτή με δικτυακή διασύνδεση που είναι συμβατός με το LPD, τότε ο <em>ο υπολογιστής εκτύπωσης (printer host)</em> είναι ο εν λόγω εκτυπωτής, και το <em>όνομα του εκτυπωτή</em> είναι το όνομα που έχετε ορίσει για τον εκτυπωτή. Δείτε την τεκμηρίωση που συνοδεύει τον εκτυπωτή σας και/ή την κάρτα δικτύου του.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Αν χρησιμοποιείτε Hewlett Packard Laserjet με όνομα εκτυπωτή <code>text</code> θα γίνονται αυτόματα οι μετατροπές από LF σε CRLF, επομένως δεν χρειάζεται να τρέξετε το script <span class=filename>hpif</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Επομένως, στους υπόλοιπους υπολογιστές όπου επιθυμείτε να έχετε πρόσβαση στον εκτυπωτή, απλά κάντε μια καταχώριση στο αρχείο <span class=filename>/etc/printcap</span> με τα ακόλουθα στοιχεία:</p></div><div class="olist arabic"><ol class=arabic><li><p>Ονομάστε την καταχώριση όπως επιθυμείτε: Για δική σας ευκολία πιθανώς να θέλετε να χρησιμοποιήσετε το ίδιο όνομα και τα ίδια παρωνύμια με αυτά του υπολογιστή εκτύπωσης.</p></li><li><p>Αφήστε την ικανότητα <code>lp</code> κενή, για την ακρίβεια (<code>:lp=:</code>).</p></li><li><p>Δημιουργήστε ένα κατάλογο spooling και προσδιορίστε την τοποθεσία του με την ικανότητα <code>sd</code>. Το LPD θα αποθηκεύει εδώ τις εργασίες πριν την αποστολή τους στον υπολογιστή εκτύπωσης.</p></li><li><p>Τοποθετήστε το όνομα του υπολογιστή εκτύπωσης στην ικανότητα <code>rm</code>.</p></li><li><p>Τοποθετήστε το όνομα του εκτυπωτή στην ικανότητα <code>rp</code>, στον <em>υπολογιστή εκτύπωσης</em>.</p></li></ol></div><div class=paragraph><p>Αυτό είναι όλο. Δεν χρειάζεται να δημιουργήσετε λίστα φίλτρων μετατροπής, διαστάσεις σελίδας, ή οτιδήποτε άλλο στο αρχείο <span class=filename>/etc/printcap</span>.</p></div><div class=paragraph><p>Εδώ είναι ένα παράδειγμα. Ο υπολογιστής <code>rose</code> έχει δύο εκτυπωτές, τον <code>bamboo</code> και τον <code>rattan</code>. Θέλουμε να ενεργοποιήσουμε τις εκτυπώσεις σε αυτούς τους εκτυπωτές για τους χρήστες του απομακρυσμένου υπολογιστή <code>orchid</code>. Εδώ είναι το αρχείο <span class=filename>/etc/printcap</span> του υπολογιστή <code>orchid</code> (δείτε πιο πίσω στην ενότητα <a href=#printing-advanced-header-pages-enabling>Ενεργοποίηση Σελίδων Κεφαλίδας</a>). Ήδη έχει μια καταχώριση για τον εκτυπωτή <code>teak</code>. Εδώ προσθέσαμε τις απαραίτητες καταχωρίσεις για τους δύο εκτυπωτές του υπολογιστή <code>rose</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid - added (remote) printers on rose
#

#
#  teak is local; it is connected directly to orchid:
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/ifhp:\
        :vf=/usr/local/libexec/vfhp:\
        :of=/usr/local/libexec/ofhp:

#
#  rattan is connected to rose; send jobs for rattan to rose:
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/rattan:

#
#  bamboo is connected to rose as well:
#
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :lp=:rm=rose:rp=bamboo:sd=/var/spool/lpd/bamboo:</pre></div></div><div class=paragraph><p>Το μόνο που απομένει είναι να δημιουργήσουμε τους καταλόγους spooling στον κόμβο <code>orchid</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/rattan /var/spool/lpd/bamboo</span>
<span class=c># chmod 770 /var/spool/lpd/rattan /var/spool/lpd/bamboo</span>
<span class=c># chown daemon:daemon /var/spool/lpd/rattan /var/spool/lpd/bamboo</span></code></pre></div></div><div class=paragraph><p>Τώρα, οι χρήστες του <code>orchid</code> μπορούν να εκτυπώνουν στον <code>rattan</code> και στον <code>bamboo</code>. Αν, για παράδειγμα, ένας χρήστης του <code>orchid</code> πληκτρολογήσει:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> bamboo <span class=nt>-d</span> sushi-review.dvi</code></pre></div></div><div class=paragraph><p>το σύστημα LPD στον <code>orchid</code> θα αντιγράψει την εργασία στον κατάλογο spooling <span class=filename>/var/spool/lpd/bamboo</span> και θα σημειώσει πως πρόκειται για εργασία DVI. Μόλις ο υπολογιστής <code>rose</code> έχει διαθέσιμο χώρο στον κατάλογο spooling του <code>bamboo</code>, τα δύο LPDs θα μεταφέρουν το αρχείο στον <code>rose</code>. Το αρχείο θα μπει σε ουρά αναμονής στον υπολογιστή <code>rose</code> έως ότου εκτυπωθεί. Θα μετατραπεί από DVI σε PostScript® (αφού ο <code>bamboo</code> είναι εκτυπωτής PostScript®) στον υπολογιστή <code>rose</code>.</p></div></div><div class=sect4><h5 id=printing-advanced-network-net-if>16.4.3.2. Εκτυπωτές με Συνδέσεις Δικτύου<a class=anchor href=#printing-advanced-network-net-if></a></h5><div class=paragraph><p>Συχνά, όταν αγοράζετε κάρτα δικτύου για εκτυπωτή, έχετε τη δυνατότητα επιλογής δύο εκδόσεων: η μία είναι προσομοίωση του spooler (η πιο ακριβή έκδοση) ενώ η άλλη απλά σας επιτρέπει να στέλνετε δεδομένα μέσω αυτής σαν να χρησιμοποιούσατε μια σειριακή ή παράλληλη θύρα (η φτηνή έκδοση). Αυτή η ενότητα περιγράφει πως να χρησιμοποιείτε την φτηνή έκδοση. Για την πιο ακριβή έκδοση μπορείτε να βρείτε περισσότερες πληροφορίες στην προηγούμενη ενότητα <a href=#printing-advanced-network-rm>Εκτυπωτές Εγκατεστημένοι σε Απομακρυσμένους Υπολογιστές</a>.</p></div><div class=paragraph><p>Η μορφή του αρχείου <span class=filename>/etc/printcap</span> σας επιτρέπει να ορίσετε τη διασύνδεση - σειριακή ή παράλληλη - που θα χρησιμοποιήσετε, και (αν χρησιμοποιείτε σειριακή διασύνδεση) τον ρυθμό baud, πιθανούς ελέγχους ροής, καθυστερήσεις για tabs, μετατροπές για χαρακτήρες νέας γραμμής, και άλλα. Αλλά δεν υπάρχει τρόπος να ορίσετε μια σύνδεση σε εκτυπωτή που ακούει σε θύρα TCP/IP ή άλλο τύπο δικτύου.</p></div><div class=paragraph><p>Για να στείλετε δεδομένα σε ένα δικτυακό εκτυπωτή, χρειάζεται να αναπτύξετε προγράμματα επικοινωνίας που να καλούνται από φίλτρα κειμένου και φίλτρα μετατροπής. Εδώ έχουμε ένα τέτοιο παράδειγμα: το script <code>netprint</code> παίρνει όλα τα δεδομένα από το standard input και τα στέλνει σε έναν εκτυπωτή συνδεδεμένο στο δίκτυο. Ορίζουμε στο <code>netprint</code> το όνομα του εκτυπωτή ως πρώτη παράμετρο, και τον αριθμό θύρας στην οποία συνδέεται ως δεύτερη. Σημειώστε πως αυτός ο τρόπος υποστηρίζει μόνο επικοινωνία μιας κατεύθυνσης (από το FreeBSD στον εκτυπωτή). Πολλοί δικτυακοί εκτυπωτές υποστηρίζουν αμφίδρομη επικοινωνία, και είναι πολύ πιθανό να επιθυμείτε να εκμεταλλευτείτε τα προτερήματα τους (για να ελέγχετε την κατάσταση του εκτυπωτή, για καταμέτρηση εκτυπώσεων, κλπ.).</p></div><div class="literalblock programlisting"><div class=content><pre>#!/usr/bin/perl
#
#  netprint - Text filter for printer attached to network
#  Installed in /usr/local/libexec/netprint
#
$#ARGV eq 1 || die &#34;Usage: $0 &lt;printer-hostname&gt; &lt;port-number&gt;&#34;;

$printer_host = $ARGV[0];
$printer_port = $ARGV[1];

require &#39;sys/socket.ph&#39;;

($ignore, $ignore, $protocol) = getprotobyname(&#39;tcp&#39;);
($ignore, $ignore, $ignore, $ignore, $address)
    = gethostbyname($printer_host);

$sockaddr = pack(&#39;S n a4 x8&#39;, &amp;AF_INET, $printer_port, $address);

socket(PRINTER, &amp;PF_INET, &amp;SOCK_STREAM, $protocol)
    || die &#34;Can&#39;t create TCP/IP stream socket: $!&#34;;
connect(PRINTER, $sockaddr) || die &#34;Can&#39;t contact $printer_host: $!&#34;;
while (&lt;STDIN&gt;) { print PRINTER; }
exit 0;</pre></div></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε αυτό το script σε διάφορα φίλτρα. Ας υποθέσουμε πως έχουμε έναν εκτυπωτή γραμμής Diablo 750-N συνδεδεμένο στο δίκτυο. Ο εκτυπωτής δέχεται δεδομένα προς εκτύπωση στην θύρα 5100. Το όνομα του εκτυπωτή στο δίκτυο είναι <code>scrivener</code>. Εδώ είναι το φίλτρο κειμένου για τον εκτυπωτή:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  diablo-if-net - Text filter for Diablo printer `scrivener&#39; listening
#  on port 5100.   Installed in /usr/local/libexec/diablo-if-net
#
exec /usr/libexec/lpr/lpf &#34;$@&#34; | /usr/local/libexec/netprint scrivener 5100</pre></div></div></div></div><div class=sect3><h4 id=printing-advanced-restricting>16.4.4. Έλεγχος Πρόσβασης και Περιορισμοί στη Χρήση των Εκτυπωτών<a class=anchor href=#printing-advanced-restricting></a></h4><div class=paragraph><p>Αυτή η ενότητα δίνει πληροφορίες για τον έλεγχο πρόσβασης και τον περιορισμό χρήσης των εκτυπωτών. Το σύστημα LPD σας επιτρέπει να ελέγχετε ποιός μπορεί να έχει πρόσβαση σε κάθε εκτυπωτή, τόσο τοπικά όσο και απομακρυσμένα, και επίσης αν μπορούν οι χρήστες να εκτυπώνουν πολλαπλά αντίγραφα, πόσο μεγάλες μπορούν να είναι οι εργασίες τους, και πόσο μεγάλες μπορούν να γίνουν οι ουρές αναμονής (print queues).</p></div><div class=sect4><h5 id=printing-advanced-restricting-copies>16.4.4.1. Περιορισμός Εκτύπωσης Πολλαπλών Αντιγράφων<a class=anchor href=#printing-advanced-restricting-copies></a></h5><div class=paragraph><p>Το σύστημα LPD διευκολύνει τους χρήστες να εκτυπώσουν πολλαπλά αντίγραφα ενός αρχείου. Οι χρήστες μπορούν να εκτυπώνουν εργασίες με <code>lpr -#5</code> (για παράδειγμα) και να παίρνουν πέντε αντίγραφα κάθε αρχείου της εργασίας εκτύπωσης. Το αν αυτό είναι καλό, εξαρτάται από εσάς.</p></div><div class=paragraph><p>Αν πιστεύετε πως τα πολλαπλά αντίγραφα δημιουργούν άσκοπη καταπόνηση των εκτυπωτών σας, μπορείτε να απενεργοποιήσετε την επιλογή <code>-<mark></mark></code> στο <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> προσθέτοντας την ικανότητα <code>sc</code> στο αρχείο <span class=filename>/etc/printcap</span>. Όταν οι χρήστες αποστέλλουν εργασίες με την επιλογή <code>-</code>, θα βλέπουν:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>lpr: multiple copies are not allowed</code></pre></div></div><div class=paragraph><p>Σημειώστε πως αν έχετε ρυθμίσει πρόσβαση σε έναν εκτυπωτή απομακρυσμένα (δείτε την ενότητα <a href=#printing-advanced-network-rm>Εκτυπωτές Εγκατεστημένοι σε Απομακρυσμένους Υπολογιστές</a>), θα χρειαστεί να προσθέσετε την ικανότητα <code>sc</code> σε όλα τα απομακρυσμένα αρχεία <span class=filename>/etc/printcap</span>, διαφορετικά οι χρήστες θα έχουν ακόμη την δυνατότητα να αποστέλλουν εργασίες πολλαπλών αντιγράφων χρησιμοποιώντας διαφορετικό κόμβο.</p></div><div class=paragraph><p>Εδώ είναι ένα παράδειγμα. Αυτό είναι το αρχείο <span class=filename>/etc/printcap</span> για τον κόμβο <code>rose</code>. Ο εκτυπωτής <code>rattan</code> είναι δυνατό μηχάνημα και επιτρέπει την εκτύπωση πολλαπλών αντιγράφων, αλλά ο εκτυπωτής laser <code>bamboo</code> είναι πιο ευαίσθητο, επομένως θα απενεργοποιήσουμε τη δυνατότητα πολλαπλών αντιγράφων προσθέτοντας την ικανότητα <code>sc</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - restrict multiple copies on bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Τώρα, θα χρειαστεί να προσθέσουμε επίσης την ικανότητα <code>sc</code> στο αρχείο <span class=filename>/etc/printcap</span> του κόμβου <code>orchid</code> (και ενώ βρισκόμαστε σε αυτό, επιτρέψτε μας να απενεργοποιήσουμε τα πολλαπλά αντίγραφα για τον εκτυπωτή <code>teak</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid - no multiple copies for local
#  printer teak or remote printer bamboo
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:sc:\
        :if=/usr/local/libexec/ifhp:\
        :vf=/usr/local/libexec/vfhp:\
        :of=/usr/local/libexec/ofhp:

rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/rattan:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :lp=:rm=rose:rp=bamboo:sd=/var/spool/lpd/bamboo:sc:</pre></div></div><div class=paragraph><p>Χρησιμοποιώντας την ικανότητα <code>sc</code>, προλαμβάνουμε την χρήση των εντολών <code>lpr -#</code>, αλλά δεν έχουμε ακόμη την δυνατότητα να παρεμποδίσουμε τους χρήστες να τρέξουν την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> πολλές φορές, ή να αποστείλουν το ίδιο αρχείο πολλές φορές σε μία μοναδική εργασία, όπως εδώ:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr forsale.sign forsale.sign forsale.sign forsale.sign forsale.sign</code></pre></div></div><div class=paragraph><p>Υπάρχουν πολλοί τρόποι πρόληψης αυτών των ενεργειών (συμπεριλαμβάνοντας και την περίπτωση να το αγνοήσετε) που είστε ελεύθεροι να εξερευνήσετε.</p></div></div><div class=sect4><h5 id=printing-advanced-restricting-access>16.4.4.2. Περιορίζοντας την Πρόσβαση σε Εκτυπωτές<a class=anchor href=#printing-advanced-restricting-access></a></h5><div class=paragraph><p>Μπορείτε να ελέγχετε ποιός μπορεί να εκτυπώνει σε ποιόν εκτυπωτή χρησιμοποιώντας τους μηχανισμούς ομάδων (groups) του UNIX® και την ικανότητα <code>rg</code> στο <span class=filename>/etc/printcap</span>. Απλά τοποθετήστε τους χρήστες που θέλετε να έχουν πρόσβαση σε κάποιον εκτυπωτή σε μια συγκεκριμένη ομάδα (χρηστών), και δηλώστε αυτή την ομάδα στην ικανότητα <code>rg</code>.</p></div><div class=paragraph><p>Όλοι οι χρήστες που δεν ανήκουν στην ομάδα (συμπεριλαμβανομένου και του <code>root</code>) θα δέχονται το ακόλουθο μήνυμα: <code>lpr: Not a member of the restricted group</code> όταν προσπαθούν να εκτυπώσουν στον ελεγχόμενο εκτυπωτή.</p></div><div class=paragraph><p>Όπως και με την ικανότητα <code>sc</code> (περιορισμού πολλαπλών αντιγράφων), θα χρειαστεί να προσδιορίσετε την <code>rg</code> στους απομακρυσμένους κόμβους που θα έχουν πρόσβαση στους εκτυπωτές σας, αν νομίζετε πως αυτό είναι σωστό (δείτε την ενότητα <a href=#printing-advanced-network-rm>Εκτυπωτές Εγκατεστημένοι σε Απομακρυσμένους Υπολογιστές</a>).</p></div><div class=paragraph><p>Για παράδειγμα, θα αφήσουμε για όλους ελεύθερη την πρόσβαση στον εκτυπωτή <code>rattan</code>, αλλά μόνο οι χρήστες της ομάδας <code>artists</code> θα μπορούν να χρησιμοποιήσουν τον <code>bamboo</code>. Εδώ είναι το γνωστό μας <span class=filename>/etc/printcap</span> για τον κόμβο <code>rose</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - restricted group for bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Επιτρέψτε μας να μην αλλάξουμε το αρχείο <span class=filename>/etc/printcap</span> από το άλλο παράδειγμα (για τον υπολογιστή <code>orchid</code>). Φυσικά, οποιοσδήποτε χρήστης του <code>orchid</code> μπορεί να εκτυπώσει στον <code>bamboo</code>. Ίσως όμως να επιτρέπουμε μόνον σε συγκεκριμένους χρήστες την πρόσβαση στον υπολογιστή <code>orchid</code>, και θέλουμε αυτοί οι χρήστες να έχουν πρόσβαση στον εκτυπωτή. Ή ίσως πάλι, και όχι.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Επιτρέπεται μόνο μια περιορισμένη ομάδα ανά εκτυπωτή.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=printing-advanced-restricting-sizes>16.4.4.3. Έλεγχος Μεγέθους των Απεσταλμένων Εργασιών<a class=anchor href=#printing-advanced-restricting-sizes></a></h5><div class=paragraph><p>Αν πολλοί χρήστες έχουν πρόσβαση στους εκτυπωτές σας, πιθανώς να χρειάζεται να θέσετε ένα ανώτατο όριο στο επιτρεπόμενο μέγεθος αρχείων που μπορούν να αποστείλουν οι χρήστες για εκτύπωση. Ακόμα και αν υπάρχει αρκετός χώρος στο σύστημα αρχείων που φιλοξενεί τους καταλόγους spool, θα πρέπει ωστόσο να βεβαιωθείτε ότι επαρκεί για τις εργασίες όλων των χρηστών.</p></div><div class=paragraph><p>Το LPD σας επιτρέπει να οριοθετήσετε το μέγιστο αριθμό bytes που περιέχει μια εργασία, με την ικανότητα <code>mx</code>. Η μονάδα μέτρησης είναι σε <code>BUFSIZ</code> blocks, τα οποία είναι 1024 bytes. Αν θέσετε μηδέν σε αυτή την ικανότητα, δεν θα υπάρχουν όρια στο μέγεθος των αρχείων. Ωστόσο, αν δεν έχει οριστεί η ικανότητα <code>mx</code>, τότε θα χρησιμοποιείται η προεπιλεγμένη τιμή των 1000 blocks.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το όριο εφαρμόζεται στα <em>αρχεία</em> μιας εργασίας, και <em>όχι</em> στο συνολικό μέγεθος της εργασίας.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το LPD δεν θα απορρίψει ένα αρχείο που ξεπερνά το όριο μεγέθους που έχετε θέσει. Αντιθέτως, θα το τοποθετήσει στην ουρά αναμονής με μέγεθος ίσο με το μέγιστο επιτρεπτό, το οποίο και θα εκτυπώσει τελικά. Το υπόλοιπο αρχείο απορρίπτεται. Αν αυτός είναι σωστός ή λανθασμένος τρόπος αντιμετώπισης για την υπέρβαση του ορίου, είναι θέμα προς συζήτηση.</p></div><div class=paragraph><p>Ας οριοθετήσουμε στο παράδειγμα μας τους εκτυπωτές <code>rattan</code> και <code>bamboo</code>. Επειδή τα αρχεία PostScript® των <code>artists</code> τείνουν προς μεγάλα μεγέθη, θα θέσουμε ένα όριο πέντε megabytes. Δεν θα θέσουμε όρια για τον εκτυπωτή γραμμής απλού κειμένου:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose
#

#
#  No limit on job size:
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:mx#0:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

#
#  Limit of five megabytes:
#
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:mx#5000:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Και πάλι, τα όρια εφαρμόζονται μόνο για τους τοπικούς χρήστες. Αν έχετε ενεργοποιήσει απομακρυσμένη πρόσβαση για τους εκτυπωτές σας, τα όρια αυτά δεν ισχύουν για τους απομακρυσμένους χρήστες. Θα χρειαστεί να προσδιορίσετε με την ικανότητα <code>mx</code> και τα απομακρυσμένα αρχεία <span class=filename>/etc/printcap</span>. Δείτε την ενότητα <a href=#printing-advanced-network-rm>Εκτυπωτές Εγκατεστημένοι σε Απομακρυσμένους Υπολογιστές</a> για περισσότερες πληροφορίες σχετικά με τις εκτυπώσεις από απομακρυσμένους υπολογιστές.</p></div><div class=paragraph><p>Υπάρχει και άλλος εξειδικευμένος τρόπος περιορισμού του μεγέθους εργασιών για απομακρυσμένους εκτυπωτές. Δείτε την ενότητα <a href=#printing-advanced-restricting-remote>Περιορισμός Εργασιών από Απομακρυσμένους Υπολογιστές</a>.</p></div></div><div class=sect4><h5 id=printing-advanced-restricting-remote>16.4.4.4. Περιορισμός Εργασιών από Απομακρυσμένους Υπολογιστές<a class=anchor href=#printing-advanced-restricting-remote></a></h5><div class=paragraph><p>Το σύστημα παροχέτευσης LPD παρέχει διάφορους τρόπους περιορισμού των εργασιών από απομακρυσμένους υπολογιστές:</p></div><div class=dlist><dl><dt class=hdlist1>Παρεμπόδιση υπολογιστών</dt><dd><p>Μπορείτε να ελέγχετε από ποιους απομακρυσμένους υπολογιστές θα δέχεται αιτήσεις εκτύπωσης το τοπικό LPD, χρησιμοποιώντας τα αρχεία <span class=filename>/etc/hosts.equiv</span> και <span class=filename>/etc/hosts.lpd</span>. Το LPD ελέγχει να δει αν η εισερχόμενη αίτηση προέρχεται από έναν υπολογιστή που αναφέρεται σε κάποιο από τα δύο αρχεία. Αν όχι, το LPD απορρίπτει την αίτηση.</p><div class=paragraph><p>Η μορφή αυτών των αρχείων είναι απλή: ένα όνομα υπολογιστή ανά γραμμή. Παρατηρήστε πως το αρχείο <span class=filename>/etc/hosts.equiv</span> χρησιμοποιείται και από το πρωτόκολλο <a href="https://man.freebsd.org/cgi/man.cgi?query=ruserok&amp;sektion=3&amp;format=html">ruserok(3)</a>, και επηρεάζει προγράμματα όπως το <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> και το <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, επομένως να είστε προσεκτικοί.</p></div><div class=paragraph><p>Για παράδειγμα, εδώ είναι το αρχείο <span class=filename>/etc/hosts.lpd</span> στον υπολογιστή <code>rose</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>orchid
violet
madrigal.fishbaum.de</pre></div></div><div class=paragraph><p>Αυτό σημαίνει πως ο <code>rose</code> δέχεται αιτήσεις από τους υπολογιστές <code>orchid</code>, <code>violet</code>, και <code>madrigal.fishbaum.de</code>. Αν κάποιος άλλος υπολογιστής προσπαθήσει να αποκτήσει πρόσβαση στο LPD του <code>rose</code>, η εργασία θα απορριφθεί.</p></div></dd><dt class=hdlist1>Περιορισμοί στο Μέγεθος</dt><dd><p>Μπορείτε να ελέγχετε πόσος ελεύθερος χώρος πρέπει να απομένει στο σύστημα αρχείων όπου βρίσκεται ο κατάλογος spool. Δημιουργήστε ένα αρχείο με όνομα <span class=filename>minfree</span> στον κατάλογο spool για τον τοπικό εκτυπωτή. Εισάγετε σε αυτό το αρχείο έναν αριθμό που αντιπροσωπεύει πόσα blocks δίσκου (512 bytes) ελεύθερου χώρου πρέπει να υπάρχουν για να είναι δεκτή μια απομακρυσμένη εργασία.</p><div class=paragraph><p>Αυτό σας επιτρέπει να είστε βέβαιοι πως οι απομακρυσμένοι χρήστες δεν θα γεμίσουν το σύστημα αρχείων σας. Μπορείτε επίσης να το χρησιμοποιήσετε για να δώσετε μερική προτεραιότητα στους τοπικούς χρήστες: οι τοπικοί χρήστες θα μπορούν να στέλνουν εργασίες στην ουρά αναμονής ακόμη και όταν ο ελεύθερος χώρος του δίσκου έχει πέσει κάτω από τον αριθμό που αναφέρεται στο αρχείο <span class=filename>minfree</span>.</p></div><div class=paragraph><p>Για παράδειγμα, ας προσθέσουμε ένα αρχείο <span class=filename>minfree</span> για τον εκτυπωτή <code>bamboo</code>. Εξετάζουμε το <span class=filename>/etc/printcap</span> για να βρούμε τον κατάλογο spool για αυτόν τον εκτυπωτή. Εδώ είναι η καταχώριση για τον <code>bamboo</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:mx#5000:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:mx#5000:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Ο κατάλογος spool καθορίζεται στην ικανότητα <code>sd</code>. Θα θέσουμε τρία megabytes (ισοδυναμεί με 6144 disk blocks) ως το μέγεθος του ελεύθερου χώρου που πρέπει να υπάρχει στο σύστημα αρχείων, ώστε το LPD να δέχεται απομακρυσμένες εργασίες:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo 6144 &gt; /var/spool/lpd/bamboo/minfree</span></code></pre></div></div></dd><dt class=hdlist1>Περιορισμοί χρηστών</dt><dd><p>Μπορείτε να ελέγχετε ποιός απομακρυσμένος χρήστης μπορεί να εκτυπώνει στους τοπικούς εκτυπωτές ορίζοντας την ικανότητα <code>rs</code> στο <span class=filename>/etc/printcap</span>. Όταν εμφανίζεται η <code>rs</code> σε μια καταχώριση κάποιου τοπικά συνδεδεμένου εκτυπωτή, το LPD θα δεχθεί εργασίες από απομακρυσμένους υπολογιστές <em>αν</em> ο χρήστης που αποστέλλει την εργασία έχει λογαριασμό στον τοπικό υπολογιστή και με το ίδιο όνομα χρήστη. Διαφορετικά, το LPD θα απορρίψει την εργασία.</p><div class=paragraph><p>Αυτή η ικανότητα είναι ιδιαίτερα χρήσιμη σε περιβάλλοντα όπου υπάρχουν (για παράδειγμα) διαφορετικά επιχειρησιακά τμήματα που μοιράζονται το δίκτυο, και κάποιοι χρήστες πρέπει να υπερβαίνουν τα σύνορα του τμήματος. Δημιουργώντας λογαριασμούς στα συστήματα σας, θα μπορούν να χρησιμοποιούν τους εκτυπωτές σας από το δικό τους τμήμα της επιχείρησης. Αν επιθυμείτε να τους επιτρέπετε να χρησιμοποιούν <em>μόνο</em> τους εκτυπωτές και όχι τα μηχανήματα σας, τότε μπορείτε να δημιουργήσετε λογαριασμούς "token", δίχως προσωπικούς καταλόγους και με κέλυφος που δεν μπορεί να χρησιμοποιηθεί, όπως το <span class=filename>/usr/bin/false</span>.</p></div></dd></dl></div></div></div><div class=sect3><h4 id=printing-advanced-acct>16.4.5. Καταμέτρηση Χρήσης Εκτυπωτών<a class=anchor href=#printing-advanced-acct></a></h4><div class=paragraph><p>Αποφασίσατε ότι χρειάζεται να χρεώνετε για τις εκτυπώσεις σας. Και γιατί όχι; Το χαρτί και το μελάνι κοστίζουν χρήματα. Και επιπλέον υπάρχει κόστος συντήρησης - οι εκτυπωτές αποτελούνται από κινητά μέρη και έχουν την τάση να χαλάνε. Έχετε εξετάσει τους εκτυπωτές σας, τον τρόπο που χρησιμοποιούνται, και το κόστος συντήρησης και έχετε υπολογίσει μια χρέωση ανά σελίδα (ή ανά μέτρο, ανά πόδι, ή άλλη μονάδα μέτρησης). Το θέμα είναι τώρα πως μπορείτε πραγματικά να ξεκινήσετε να καταμετράτε τις εκτυπώσεις σας.</p></div><div class=paragraph><p>Τα άσχημα νέα είναι πως το σύστημα παροχέτευσης του LPD δεν παρέχει πολύ βοήθεια σε αυτόν τον τομέα. Η καταμέτρηση εξαρτάται σε μεγάλο βαθμό από τον τύπο του εκτυπωτή που χρησιμοποιείτε, τους τύπους αρχείων που εκτυπώνετε, και τις <em>δικές σας</em> απαιτήσεις για την χρέωση των εκτυπώσεων.</p></div><div class=paragraph><p>Για την καταμέτρηση, θα πρέπει να μετατρέψετε το φίλτρο κειμένου (για τη χρέωση εργασιών απλού κειμένου) του εκτυπωτή και τα φίλτρα μετατροπής (για τη χρέωση όλων των άλλων τύπων αρχείων) ώστε να μετρούν σελίδες ή να ζητούν να μάθουν από τον εκτυπωτή τον αριθμό των εκτυπωμένων σελίδων. Δεν θα σας βοηθήσει ιδιαίτερα η χρήση φίλτρου εξόδου, από τη στιγμή που δεν μπορεί να κάνει καταμέτρηση. Δείτε την ενότητα <a href=#printing-advanced-filter-intro>Φίλτρα</a>.</p></div><div class=paragraph><p>Γενικά, υπάρχουν δύο τρόποι για να κάνετε καταμέτρηση:</p></div><div class=ulist><ul><li><p>Η <em>Περιοδική καταμέτρηση</em> είναι ο πιο συνηθισμένος τρόπος, πιθανώς γιατί είναι ο ευκολότερος. Κάθε φορά που κάποιος εκτυπώνει μια εργασία, το φίλτρο δημιουργεί ένα αρχείο καταγραφής όπου αναφέρει τον χρήστη, τον υπολογιστή, και τον αριθμό των σελίδων. Κάθε μήνα, εξάμηνο, χρόνο, ή άλλη χρονική περίοδο της αρεσκείας σας, συλλέγετε τα αρχεία καταγραφής για τους διάφορους εκτυπωτές, λογαριάζετε τις σελίδες που αναλογούν στους χρήστες, και χρεώνετε αναλόγως. Έπειτα σβήνετε τα στοιχεία από τα αρχεία καταγραφής, ξεκινώντας από καθαρή κατάσταση για την επόμενη περίοδο.</p></li><li><p>Η <em>Καταμέτρηση κατά τη χρήση</em> είναι λιγότερο γνωστή, ίσως επειδή είναι πιο δύσκολος τρόπος. Σε αυτή τη μέθοδο τα φίλτρα χρεώνουν τους χρήστες για τις εκτυπώσεις τους αμέσως μόλις αυτές πραγματοποιηθούν. Όπως και με την καταγραφή χρήσης δίσκου (disk quotas), η καταμέτρηση είναι άμεση. Μπορείτε να προλαμβάνετε την χρήση εκτυπωτών από χρήστες που έχουν χτυπήσει κόκκινο, και μπορείτε να παρέχετε στους χρήστες ένα τρόπο για να ελέγχουν και να ρυθμίζουν τον "όγκο εκτυπώσεων (print quotas)." Αλλά αυτή η μέθοδος προϋποθέτει λίγο κώδικα βάσεων δεδομένων για την καταγραφή χρηστών και των εν λόγω μεγεθών.</p></li></ul></div><div class=paragraph><p>Το σύστημα παροχέτευσης LPD υποστηρίζει εύκολα και τις δύο μεθόδους: από τη στιγμή που πρέπει εσείς να παρέχετε τα φίλτρα (τις περισσότερες φορές), θα πρέπει επίσης να παρέχετε και τον κώδικα καταμέτρησης. Αλλά υπάρχει και ένα καλό σε αυτή την υπόθεση: έχετε απεριόριστη ευελιξία στις μεθόδους καταμέτρησης. Για παράδειγμα, μπορείτε να επιλέξετε περιοδική ή κατά τη χρήση καταμέτρηση. Μπορείτε να επιλέξετε τις πληροφορίες που θα καταγράφονται: ονόματα χρηστών, ονόματα υπολογιστών, τύπους εργασιών, τυπωμένες σελίδες, τετραγωνικά μέτρα χαρτιού που χρησιμοποιήθηκε, πόσος χρόνος χρειάστηκε για να γίνει η εκτύπωση, και πολλά ακόμα. Και όλα αυτά γίνονται μετατρέποντας τα φίλτρα για να αποθηκεύουν αυτές τις πληροφορίες.</p></div><div class=sect4><h5 id=_γρήγορη_και_πρόχειρη_καταμέτρηση_εκτυπώσεων>16.4.5.1. Γρήγορη και Πρόχειρη Καταμέτρηση Εκτυπώσεων<a class=anchor href=#_γρήγορη_και_πρόχειρη_καταμέτρηση_εκτυπώσεων></a></h5><div class=paragraph><p>Το FreeBSD διατίθεται με δύο προγράμματα που μπορούν να παρέχουν άμεσα απλή περιοδική καταμέτρηση. Είναι το φίλτρο κειμένου <code>lpf</code>, που περιγράφεται στην ενότητα <a href=#printing-advanced-lpf>lpf: ένα Φίλτρο Κειμένου</a>, και το <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>, ένα πρόγραμμα που συλλέγει και αθροίζει καταχωρίσεις από αρχεία καταμετρήσεων.</p></div><div class=paragraph><p>Όπως αναφέραμε στην ενότητα των φίλτρων (<a href=#printing-advanced-filters>Φίλτρα</a>), το LPD ξεκινά τα φίλτρα κειμένου και μετατροπής περνώντας στην γραμμή εντολών του φίλτρου και το όνομα του αρχείου καταγραφής. Τα φίλτρα μπορούν να χρησιμοποιήσουν αυτή την παράμετρο για να ξέρουν που να γράφουν τις καταχωρίσεις καταμέτρησης. Το όνομα του αρχείου καταμέτρησης φαίνεται στην ικανότητα <code>af</code> στο <span class=filename>/etc/printcap</span>, και αν δεν ορίζεται η πλήρης διαδρομή του, χρησιμοποιείται η σχετική διαδρομή ως προς τον κατάλογο spool.</p></div><div class=paragraph><p>Το LPD ξεκινά το <code>lpf</code> με παραμέτρους πλάτους και μήκους σελίδας (από τις ικανότητες <code>pw</code> και <code>pl</code>). Το <code>lpf</code> χρησιμοποιεί αυτές τις παραμέτρους για να προσδιορίσει την ποσότητα χαρτιού που χρησιμοποιήθηκε. Μετά την αποστολή του αρχείου στον εκτυπωτή, γράφει μια καταχώριση καταμέτρησης στο αρχείο καταγραφής. Οι καταχωρίσεις μοιάζουν με τις παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>2.00 rose:andy
3.00 rose:kelly
3.00 orchid:mary
5.00 orchid:mary
2.00 orchid:zhang</pre></div></div><div class=paragraph><p>Θα πρέπει να χρησιμοποιείτε ξεχωριστό αρχείο καταγραφής για κάθε εκτυπωτή, αφού το <code>lpf</code> δεν έχει ενσωματωμένη δυνατότητα κλειδώματος αρχείου (file locking), και δύο <code>lpf</code> μπορούν να καταστρέψουν το ένα την καταχώριση του άλλου αν πρόκειται να γράψουν ταυτόχρονα στο ίδιο αρχείο. Ένας εύκολος τρόπος για να βεβαιώσετε την μοναδικότητα αρχείου καταγραφής ανά εκτυπωτή είναι να χρησιμοποιήσετε την ικανότητα <code>af=acct</code> στο <span class=filename>/etc/printcap</span>. Έτσι, κάθε αρχείο καταγραφής θα βρίσκεται στον κατάλογο spool του αντίστοιχου εκτυπωτή, σε ένα αρχείο με όνομα <span class=filename>acct</span>.</p></div><div class=paragraph><p>Όταν είστε έτοιμοι να χρεώσετε τους χρήστες για τις εκτυπώσεις, εκτελέστε το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>. Απλά μεταβείτε στον κατάλογο spool για τον εκτυπωτή που κάνετε καταμέτρηση και πληκτρολογήστε <code>pac</code>. Θα εμφανιστεί ένας απολογισμός με χρεώσεις σε δολάρια, όπως βλέπετε στη συνέχεια:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  Login               pages/feet   runs    price
orchid:kelly                5.00    1   <span class=nv>$ </span> 0.10
orchid:mary                31.00    3   <span class=nv>$ </span> 0.62
orchid:zhang                9.00    1   <span class=nv>$ </span> 0.18
rose:andy                   2.00    1   <span class=nv>$ </span> 0.04
rose:kelly                177.00  104   <span class=nv>$ </span> 3.54
rose:mary                  87.00   32   <span class=nv>$ </span> 1.74
rose:root                  26.00   12   <span class=nv>$ </span> 0.52

total                     337.00  154   <span class=nv>$ </span> 6.74</code></pre></div></div><div class=paragraph><p>Παρακάτω είναι οι παράμετροι που δέχεται το <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>:</p></div><div class=dlist><dl><dt class=hdlist1><code>-P<em>printer</em></code></dt><dd><p>Για ποιό <em>printer</em> να κάνει απολογισμό. Αυτή η επιλογή δουλεύει μόνο αν υπάρχει η πλήρης διαδρομή στην ικανότητα <code>af</code> στο <span class=filename>/etc/printcap</span>.</p></dd><dt class=hdlist1><code>-c</code></dt><dd><p>Ταξινομεί το αποτέλεσμα ανά κόστος αντί της αλφαβητικής ταξινόμησης των χρηστών.</p></dd><dt class=hdlist1><code>-m</code></dt><dd><p>Αγνοεί το όνομα του υπολογιστή στα αρχεία καταγραφής. Με αυτή την επιλογή, ο χρήστης <code>smith</code> στον υπολογιστή <code>alpha</code> είναι ο ίδιος χρήστης με τον <code>smith</code> στον υπολογιστή <code>gamma</code>. Χωρίς την επιλογή αυτή, είναι διαφορετικοί χρήστες.</p></dd><dt class=hdlist1><code>-p<em>price</em></code></dt><dd><p>Υπολογίζει τις χρεώσεις με <em>price</em> (τιμή) σε δολάρια ανά σελίδα ή ανά πόδι αντί για την τιμή από την ικανότητα <code>pc</code> στο <span class=filename>/etc/printcap</span>, ή αλλιώς δύο σεντς (από προεπιλογή). Μπορείτε να ορίσετε ως <em>price</em> μια τιμή με δεκαδικά ψηφία (floating point).</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>Αντιστρέφει την σειρά ταξινόμησης.</p></dd><dt class=hdlist1><code>-s</code></dt><dd><p>Δημιουργεί ένα αρχείο απολογισμού των καταμετρήσεων και καθαρίζει τα περιεχόμενα των αρχείων καταγραφής.</p></dd><dt class=hdlist1><em>name…​</em></dt><dd><p>Τυπώνει πληροφορίες αναφοράς μόνο για τα συγκεκριμένα <em>name</em> (ονόματα) χρηστών.</p></dd></dl></div><div class=paragraph><p>Στον προεπιλεγμένο απολογισμό που παράγει το <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>, βλέπετε των αριθμό των τυπωμένων σελίδων ανά χρήστη από τους διάφορους υπολογιστές. Αν, στο χώρο σας, ο υπολογιστής δεν έχει σημασία (γιατί οι χρήστες μπορούν να χρησιμοποιήσουν οποιονδήποτε θέλουν), εκτελέστε την εντολή <code>pac -m</code>, για να δημιουργήσετε τον ακόλουθο απολογισμό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  Login               pages/feet   runs    price
andy                        2.00    1   <span class=nv>$ </span> 0.04
kelly                     182.00  105   <span class=nv>$ </span> 3.64
mary                      118.00   35   <span class=nv>$ </span> 2.36
root                       26.00   12   <span class=nv>$ </span> 0.52
zhang                       9.00    1   <span class=nv>$ </span> 0.18

total                     337.00  154   <span class=nv>$ </span> 6.74</code></pre></div></div><div class=paragraph><p>Για τον ορισμό ποσοστού χρέωσης σε δολάρια, το <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> χρησιμοποιεί την ικανότητα <code>pc</code> στο αρχείο <span class=filename>/etc/printcap</span> (προεπιλεγμένη τιμή 200, ή 2 σεντς ανά σελίδα). Προσδιορίστε σε αυτήν την ικανότητα, σε εκατοστά του σεντ, την τιμή ανά σελίδα ή ανά πόδι που θέλετε να χρεώνετε για τις εκτυπώσεις. Μπορείτε να προσπεράσετε αυτή την τιμή όταν τρέχετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> με την επιλογή <code>-p</code>. H μονάδα μέτρησης για την επιλογή <code>-p</code> είναι σε δολάρια, όχι σε εκατοστά του σεντ. Για παράδειγμα,</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pac -p1.50</span></code></pre></div></div><div class=literalblock><div class=content><pre>ορίζει κόστος κάθε σελίδας ένα δολάριο και πενήντα σεντς. Μπορείτε πραγματικά να έχετε πολλά έσοδα χρησιμοποιώντας αυτές τις χρεώσεις.</pre></div></div><div class=paragraph><p>Τέλος, εκτελώντας <code>pac -s</code> θα αποθηκεύσετε τις πληροφορίες του απολογισμού σε ένα αρχείο καταγραφής απολογισμού, που θα έχει το ίδιο όνομα με το αρχείο καταγραφής του εκτυπωτή, αλλά με κατάληξη <code>_sum</code>. Έπειτα καθαρίζεται το αρχείο καταγραφής. Όταν εκτελέσετε πάλι το <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>, θα ξαναδιαβάσει το αρχείο απολογισμού, για να πάρει τα αρχικά σύνολα, και θα προσθέσει τις πληροφορίες από το κανονικό αρχείο καταγραφής.</p></div></div><div class=sect4><h5 id=_πως_μπορείτε_να_μετρήσετε_τις_τυπωμένες_σελίδες>16.4.5.2. Πως Μπορείτε να Μετρήσετε τις Τυπωμένες Σελίδες;<a class=anchor href=#_πως_μπορείτε_να_μετρήσετε_τις_τυπωμένες_σελίδες></a></h5><div class=paragraph><p>Για να μετρήσετε τις τυπωμένες σελίδες με έστω στοιχειώδη λεπτομέρεια, θα πρέπει να προσδιορίσετε πόσο χαρτί χρειάζεται μια εργασία. Αυτό είναι το ουσιαστικότερο πρόβλημα στην καταμέτρηση εκτυπώσεων.</p></div><div class=paragraph><p>Για εργασίες απλού κειμένου, το πρόβλημα δεν είναι δύσκολο να λυθεί: Μετράτε πόσες γραμμές υπάρχουν σε μια εργασία και τις συγκρίνετε με πόσες γραμμές μπορεί να τυπώσει ο εκτυπωτής σας σε μια σελίδα. Μην ξεχάσετε να συμπεριλάβετε τα backspaces που προκαλούν υπερτύπωση, ή επιμήκης λογικές γραμμές που αναδιπλώνονται σε περισσότερες από μία φυσικές γραμμές.</p></div><div class=paragraph><p>Το φίλτρο κειμένου <code>lpf</code> (που παρουσιάσαμε στο <a href=#printing-advanced-lpf>lpf: ένα Φίλτρο Κειμένου</a>) λαμβάνει υπόψιν του αυτά τα στοιχεία όταν κάνει καταμέτρηση. Αν γράφετε κάποιο φίλτρο κειμένου που χρειάζεται να κάνει καταμέτρηση, ίσως να θέλετε να ελέγξετε τον πηγαίο κώδικα του <code>lpf</code>.</p></div><div class=paragraph><p>Πως χειρίζεστε όμως τους υπόλοιπους τύπους αρχείων;</p></div><div class=paragraph><p>Για τις μετατροπές από DVI-σε-LaserJet ή από DVI-σε-PostScript®, μπορείτε να κάνετε το φίλτρο σας να αναλύει την έξοδο του <code>dvilj</code> ή του <code>dvips</code> και να ελέγχει πόσες σελίδες δημιουργήθηκαν από τη μετατροπή. Ίσως μπορέσετε να κάνετε κάτι παρόμοιο και με διαφορετικούς τύπους αρχείων και προγράμματα μετατροπής</p></div><div class=paragraph><p>Ωστόσο, όλες αυτές οι μέθοδοι έχουν το μειονέκτημα πως ο εκτυπωτής πιθανώς στην πραγματικότητα να μην εκτυπώσει όλες τις σελίδες. Για παράδειγμα, θα μπορούσε να μπλοκαριστεί το χαρτί, ή να τελειώσει το τόνερ, ή ακόμη να συμβεί και έκρηξη -ενώ ο χρήστης θα συνεχίσει να χρεώνεται.</p></div><div class=paragraph><p>Τι θα μπορούσατε να κάνετε;</p></div><div class=paragraph><p>Υπάρχει μόνο ένας <em>σίγουρος</em> τρόπος για να κάνετε καταμέτρηση <em>ακριβείας</em>. Να πάρετε έναν εκτυπωτή που να μπορεί να σας πει πόσο χαρτί χρησιμοποιεί, και να τον συνδέσετε μέσω σειριακής θύρας ή μέσω δικτύου. Σχεδόν όλοι οι εκτυπωτές PostScript® υποστηρίζουν αυτή την δυνατότητα. Θα βρείτε και άλλους τύπους και κατασκευαστές που κάνουν επίσης το ίδιο (για παράδειγμα, οι laser εκτυπωτές δικτύου της Imagen). Μετατρέψτε τα φίλτρα για αυτούς τους εκτυπωτές ώστε να καταγράφουν τις τυπωμένες σελίδες μετά την ολοκλήρωση της εκάστοτε εργασίας εκτύπωσης, και ρυθμίστε τους να κρατούν αρχεία καταγραφής με <em>μόνο</em> αυτή την πληροφορία. Δεν χρειάζεται καταμέτρηση γραμμών ούτε αναφορά σφαλμάτων.</p></div><div class=paragraph><p>Φυσικά, πάντα έχετε τη δυνατότητα να φανείτε γενναιόδωρος και να παρέχετε τις εκτυπώσεις σας δωρεάν.</p></div></div></div></div><div class=sect2><h3 id=printing-using>16.5. Χρήση Εκτυπωτών<a class=anchor href=#printing-using></a></h3><div class=paragraph><p>Αυτή η ενότητα περιγράφει πως να χρησιμοποιείτε τους εκτυπωτές που έχετε εγκαταστήσει στο FreeBSD. Οι βασικές εντολές για τον τελικό χρήστη είναι οι ακόλουθες:</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a></dt><dd><p>Εκτύπωση εργασιών</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a></dt><dd><p>Έλεγχος ουράς αναμονής (print queue) του εκτυπωτή</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a></dt><dd><p>Διαγραφή εργασιών από την ουρά αναμονής</p></dd></dl></div><div class=paragraph><p>Υπάρχει επίσης μια εντολή για τους διαχειριστές, η <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>, που περιγράφεται στην ενότητα <a href=#printing-lpc>Διαχείριση Εκτυπωτών</a>, και χρησιμοποιείται για να ελέγχει τους εκτυπωτές και τις ουρές αναμονής.</p></div><div class=paragraph><p>Και οι τρεις εντολές <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a>, και <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> δέχονται την επιλογή <code>-P <em>printer-name</em></code> με την οποία καθορίζεται σε ποιον εκτυπωτή ή ουρά αναμονής θα ενεργήσουν, όπως αναφέρεται στο αρχείο <span class=filename>/etc/printcap</span>. Αυτό σας επιτρέπει να αποστείλετε, να διαγράψετε, και να ελέγξετε εργασίες σε διάφορους εκτυπωτές. Αν δεν χρησιμοποιείτε την επιλογή <code>-P</code>, τότε οι εντολές χρησιμοποιούν τον εκτυπωτή που αναφέρεται στη μεταβλητή περιβάλλοντος <code>PRINTER</code>. Τέλος, αν δεν έχετε θέσει μια μεταβλητή περιβάλλοντος <code>PRINTER</code>, οι εντολές εκτελούνται με τον προεπιλεγμένο εκτυπωτή που ονομάζεται <code>lp</code>.</p></div><div class=paragraph><p>Από δω και στο εξής, με την ορολογία <em>προεπιλεγμένος εκτυπωτής</em> θα εννοούμε τον εκτυπωτή που αναφέρεται στην μεταβλητή περιβάλλοντος <code>PRINTER</code>, ή αν δεν υπάρχει, τον εκτυπωτή με το όνομα <code>lp</code>.</p></div><div class=sect3><h4 id=printing-lpr>16.5.1. Εκτύπωση Εργασιών<a class=anchor href=#printing-lpr></a></h4><div class=paragraph><p>Για να εκτυπώσετε αρχεία, πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr filename ...</code></pre></div></div><div class=paragraph><p>Θα εκτυπωθούν όλα τα αναφερόμενα αρχεία στον προεπιλεγμένο εκτυπωτή. Αν δεν αναφέρετε αρχεία, το <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> διαβάζει δεδομένα από το standard input. Για παράδειγμα, αυτή η εντολή θα εκτυπώσει μερικά σημαντικά αρχεία του συστήματος:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr /etc/host.conf /etc/hosts.equiv</code></pre></div></div><div class=paragraph><p>Για να επιλέξετε ένα συγκεκριμένο εκτυπωτή, πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> printer-name filename ...</code></pre></div></div><div class=paragraph><p>Στο παράδειγμα μας θα εκτυπωθεί μια μεγάλη λίστα αρχείων του τρέχοντος καταλόγου στον εκτυπωτή που ονομάζεται <code>rattan</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span> | lpr <span class=nt>-P</span> rattan</code></pre></div></div><div class=paragraph><p>Αφού δεν αναφέρονται ονόματα αρχείων στην εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, το <code>lpr</code> διαβάζει τα δεδομένα που θα εκτυπώσει από το standard input, τα οποία είναι η έξοδος της εντολής <code>ls -l</code>.</p></div><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> μπορεί να δεχθεί ένα μεγάλο αριθμό επιλογών για να ελέγχει την μορφοποίηση, να μετατρέπει αρχεία, να δημιουργεί πολλαπλά αντίγραφα, κ.λ.π. Για περισσότερες πληροφορίες, δείτε την ενότητα <a href=#printing-lpr-options>Επιλογές Εκτύπωσης</a>.</p></div></div><div class=sect3><h4 id=printing-lpq>16.5.2. Έλεγχος Εργασιών<a class=anchor href=#printing-lpq></a></h4><div class=paragraph><p>Όταν εκτυπώνετε με το <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, τα δεδομένα που θέλετε να εκτυπώσετε τοποθετούνται σε ένα πακέτο (package) που ονομάζεται "εργασία εκτύπωσης (print job)", η οποία αποστέλλεται στο σύστημα παροχέτευσης LPD. Κάθε εκτυπωτής έχει μια ουρά αναμονής εργασιών, και η εργασία σας αναμένει μαζί με άλλες δικές σας και άλλων χρηστών. Ο εκτυπωτής τις εκτυπώνει με την σειρά άφιξης στην ουρά αναμονής.</p></div><div class=paragraph><p>Για να εμφανίσετε την ουρά αναμονής για τον προεπιλεγμένο εκτυπωτή, πληκτρολογήστε <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a>. Για κάποιον συγκεκριμένο εκτυπωτή, χρησιμοποιήστε την επιλογή <code>-P</code>. Για παράδειγμα, η εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-P</span> bamboo</code></pre></div></div><div class=paragraph><p>εμφανίζει την ουρά αναμονής για τον εκτυπωτή με το όνομα <code>bamboo</code>. Ακολουθεί ένα παράδειγμα εξόδου της εντολής <code>lpq</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bamboo is ready and printing
Rank   Owner    Job  Files                              Total Size
active kelly    9    /etc/host.conf, /etc/hosts.equiv   88 bytes
2nd    kelly    10   <span class=o>(</span>standard input<span class=o>)</span>                   1635 bytes
3rd    mary     11   ...                                78519 bytes</code></pre></div></div><div class=paragraph><p>Εμφανίζονται τρεις εργασίες στη λίστα αναμονής για τον <code>bamboo</code>. Στην πρώτη εργασία, που έχει σταλεί από τον χρήστη kelly, έχει αποδοθεί ο "αριθμός εργασίας (job number)" 9. Κάθε εργασία ενός εκτυπωτή χαρακτηρίζεται από ένα μοναδικό τέτοιο αριθμό. Τις περισσότερες φορές μπορείτε να τον αγνοήσετε, αλλά θα τον χρειαστείτε αν θέλετε να διαγράψετε κάποια εργασία. Δείτε την ενότητα <a href=#printing-lprm>Διαγραφή Εργασιών</a> για περισσότερες πληροφορίες.</p></div><div class=paragraph><p>Η εργασία με το νούμερο εννέα αποτελείται από δύο αρχεία. Τα πολλαπλά αρχεία που δόθηκαν στη γραμμή εντολών του <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> θεωρούνται μέρος μίας μόνο εργασίας. Αυτή είναι και η τρέχουσα ενεργή εργασία (παρατηρήστε τη λέξη <code>active</code> της στήλης "Rank"), που σημαίνει πως η εργασία εκτυπώνεται αυτή τη στιγμή. Η δεύτερη εργασία αποτελείται από δεδομένα που έχουν περάσει στην standard input της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>. Η τρίτη εργασία προέρχεται από τον χρήστη <code>mary</code>, και πρόκειται για μια πολύ ογκώδη εργασία. Το όνομα διαδρομής του αρχείου που πρόκειται να εκτυπωθεί είναι πολύ μεγάλο για να χωρέσει στη στήλη, και για αυτό η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> απλά το συμβολίζει με τρεις τελείες.</p></div><div class=paragraph><p>Η πρώτη γραμμή της εξόδου από την <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> είναι επίσης πολύ χρήσιμη: μας ενημερώνει για το τι κάνει την παρούσα στιγμή ο εκτυπωτής (ή τουλάχιστον για το τι πιστεύει το LPD πως κάνει ο εκτυπωτής αυτή τη στιγμή).</p></div><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> επίσης υποστηρίζει την επιλογή <code>-l</code> για να δημιουργήσει μια μεγάλη, λεπτομερή λίστα. Ακολουθεί ένα παράδειγμα του <code>lpq -l</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>waiting <span class=k>for </span>bamboo to become ready <span class=o>(</span>offline ?<span class=o>)</span>
kelly: 1st				 <span class=o>[</span>job 009rose]
       /etc/host.conf                    73 bytes
       /etc/hosts.equiv                  15 bytes

kelly: 2nd				 <span class=o>[</span>job 010rose]
       <span class=o>(</span>standard input<span class=o>)</span>                  1635 bytes

mary: 3rd                                <span class=o>[</span>job 011rose]
      /home/orchid/mary/research/venus/alpha-regio/mapping 78519 bytes</code></pre></div></div></div><div class=sect3><h4 id=printing-lprm>16.5.3. Αφαίρεση Εργασιών<a class=anchor href=#printing-lprm></a></h4><div class=paragraph><p>Αν αλλάξετε γνώμη για μια εργασία που είχατε αποστείλει προς εκτύπωση, μπορείτε να την αφαιρέσετε από την λίστα αναμονής με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a>. Μπορείτε ακόμη να χρησιμοποιήσετε την <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> για να αφαιρέσετε μια ενεργή εργασία, αλλά πιθανόν κάποιο μέρος της να εκτυπωθεί έτσι και αλλιώς.</p></div><div class=paragraph><p>Για να αφαιρέσετε μια εργασία από τον προεπιλεγμένο εκτυπωτή, χρησιμοποιήστε πρώτα την <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> για να βρείτε τον αριθμό της. Έπειτα πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lprm job-number</code></pre></div></div><div class=paragraph><p>Για να αφαιρέσετε μια εργασία από κάποιον συγκεκριμένο εκτυπωτή, προσθέστε την επιλογή <code>-P</code>. Η ακόλουθη εντολή αφαιρεί την εργασία με αριθμό 10 από την ουρά αναμονής για τον εκτυπωτή <code>bamboo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lprm <span class=nt>-P</span> bamboo 10</code></pre></div></div><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> έχει μερικές συντομεύσεις:</p></div><div class=dlist><dl><dt class=hdlist1>lprm -</dt><dd><p>Αφαιρεί όλες τις εργασίες (για τον προεπιλεγμένο εκτυπωτή) που ανήκουν σε εσάς.</p></dd><dt class=hdlist1>lprm <em>user</em></dt><dd><p>Αφαιρεί όλες τις εργασίες (για τον προεπιλεγμένο εκτυπωτή) που ανήκουν στον <em>χρήστη (user)</em>. Ο υπερχρήστης (superuser) μπορεί να αφαιρέσει εργασίες άλλων χρηστών, εσείς μπορείτε να αφαιρέσετε μόνο τις δικές σας.</p></dd><dt class=hdlist1>lprm</dt><dd><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> χωρίς αριθμό εργασίας, όνομα χρήστη, ή <code>-</code> που εμφανίζεται στην γραμμή εντολών, αφαιρεί την τρέχουσα ενεργή εργασία στον προεπιλεγμένο εκτυπωτή, αν ανήκει σε σάς. Ο υπερχρήστης (superuser) μπορεί να αφαιρέσει οποιαδήποτε ενεργή εργασία.</p></dd></dl></div><div class=paragraph><p>Για να δουλέψετε σε κάποιον συγκεκριμένο εκτυπωτή αντί του προεπιλεγμένου, απλά χρησιμοποιήστε την επιλογή <code>-P</code> με τις παραπάνω συντομεύσεις. Για παράδειγμα, η ακόλουθη εντολή αφαιρεί όλες τις εργασίες του τρέχοντος χρήστη από την ουρά αναμονής του εκτυπωτή <code>rattan</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lprm <span class=nt>-P</span> rattan -</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν εργάζεστε σε περιβάλλον δικτύου, η <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> θα σας επιτρέψει να αφαιρέσετε εργασίες μόνο από τον υπολογιστή που τις έχετε στείλει, ανεξάρτητα αν ο εκτυπωτής είναι προσβάσιμος και από άλλους υπολογιστές. Η ακόλουθη εντολή επιδεικνύει ακριβώς αυτό το χαρακτηριστικό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> rattan myfile
% rlogin orchid
% lpq <span class=nt>-P</span> rattan
Rank   Owner	  Job  Files                          Total Size
active seeyan	  12	...                           49123 bytes
2nd    kelly      13   myfile                         12 bytes
% lprm <span class=nt>-P</span> rattan 13
rose: Permission denied
% <span class=nb>logout</span>
% lprm <span class=nt>-P</span> rattan 13
dfA013rose dequeued
cfA013rose dequeued</code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=printing-lpr-options>16.5.4. Πέρα από το Απλό Κείμενο: Περισσότερες Επιλογές Εκτύπωσης<a class=anchor href=#printing-lpr-options></a></h4><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> υποστηρίζει μια γκάμα επιλογών για τον έλεγχο μορφοποίησης κειμένου, μετατροπής γραφικών και άλλων μορφών αρχείων, παραγωγής πολλαπλών αντιγράφων, χειρισμού εργασιών, και άλλα. Οι επιλογές αυτές περιγράφονται στην παρούσα ενότητα.</p></div><div class=sect4><h5 id=printing-lpr-options-format>16.5.4.1. Επιλογές Μορφοποίησης και Μετατροπής<a class=anchor href=#printing-lpr-options-format></a></h5><div class=paragraph><p>Οι ακόλουθες επιλογές της <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> ελέγχουν την μορφοποίηση των αρχείων της εργασίας εκτύπωσης. Χρησιμοποιήστε τις αν η εργασία σας δεν περιέχει απλό κείμενο ή αν επιθυμείτε να μορφοποιήσετε απλό κείμενο διαμέσου του εργαλείου <a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a>.</p></div><div class=paragraph><p>Για παράδειγμα, η ακόλουθη εντολή τυπώνει ένα αρχείο DVI (από το σύστημα στοιχειοθεσίας TeX) με όνομα <span class=filename>fish-report.dvi</span> στον εκτυπωτή με όνομα <code>bamboo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> bamboo <span class=nt>-d</span> fish-report.dvi</code></pre></div></div><div class=paragraph><p>Αυτές οι επιλογές εφαρμόζονται σε κάθε αρχείο της εργασίας, και έτσι δεν μπορείτε να αναμίξετε (ας πούμε) αρχεία DVI και ditroff μαζί στην ίδια εργασία. Απλώς στείλτε τα αρχεία σαν διαφορετικές εργασίες, χρησιμοποιώντας διαφορετικές επιλογές μετατροπής για κάθε εργασία.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όλες αυτές οι επιλογές εκτός της <code>-p</code> και της <code>-T</code> απαιτούν εγκατεστημένα φίλτρα μετατροπής για τον εκτυπωτή προορισμού. Για παράδειγμα, η επιλογή <code>-d</code> απαιτεί το φίλτρο μετατροπής DVI. Η ενότητα <a href=#printing-advanced-convfilters>Φίλτρα Μετατροπής</a> δίνει περισσότερες λεπτομέρειες.</p></div></td></tr></tbody></table></div><div class=dlist><dl><dt class=hdlist1><code>-c</code></dt><dd><p>Εκτυπώνει αρχεία cifplot.</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>Εκτυπώνει αρχεία DVI.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Εκτυπώνει αρχεία κειμένου FORTRAN.</p></dd><dt class=hdlist1><code>-g</code></dt><dd><p>Εκτυπώνει δεδομένα σχεδίασης (plot).</p></dd><dt class=hdlist1><code>-i <em>number</em></code></dt><dd><p>Εκτυπώνει την έξοδο με εσοχή <em>number</em> στηλών. Αν παραλείψετε το <em>number</em>, η εσοχή θα είναι 8 στήλες. Αυτή η επιλογή δουλεύει μόνο με ορισμένα φίλτρα μετατροπής.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μην τοποθετείτε κενό διάστημα μεταξύ του <code>-i</code> και του αριθμού.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><code>-l</code></dt><dd><p>Εκτυπώνει δεδομένα κειμένου κατά γράμμα (literal), συμπεριλαμβάνοντας και τους χαρακτήρες ελέγχου.</p></dd><dt class=hdlist1><code>-n</code></dt><dd><p>Εκτυπώνει δεδομένα ditroff (δεδομένα troff ανεξάρτητα από τη συσκευή).</p></dd><dt class=hdlist1>-p</dt><dd><p>Μορφοποιεί το απλό κείμενο με την <a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a> πριν να το εκτυπώσει. Δείτε την <a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a> για περισσότερες πληροφορίες.</p></dd><dt class=hdlist1><code>-T <em>title</em></code></dt><dd><p>Χρησιμοποιεί το <em>title</em> στην κεφαλίδα του <a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a> αντί για το όνομα αρχείου. Αυτή η επιλογή επιδρά μόνο όταν χρησιμοποιείται με την επιλογή <code>-p</code></p></dd><dt class=hdlist1><code>-t</code></dt><dd><p>Εκτυπώνει δεδομένα troff.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>Εκτυπώνει δεδομένα ράστερ.</p></dd></dl></div><div class=paragraph><p>Εδώ είναι ένα παράδειγμα: αυτή η εντολή εκτυπώνει μια κομψά μορφοποιημένη έκδοση της σελίδας βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> στον προεπιλεγμένο εκτυπωτή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zcat /usr/shared/man/man1/ls.1.gz | troff <span class=nt>-t</span> <span class=nt>-man</span> | lpr <span class=nt>-t</span></code></pre></div></div><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=zcat&amp;sektion=1&amp;format=html">zcat(1)</a> αποσυμπιέζει τον πηγαίο κώδικα της σελίδας βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> και τον περνάει στην εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=troff&amp;sektion=1&amp;format=html">troff(1)</a>, η οποία τον μορφοποιεί και δημιουργεί στην έξοδο της δεδομένα GNU troff, τα αποστέλλει στην <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, η οποία με τη σειρά της αποστέλλει την εργασία στο LPD. Επειδή χρησιμοποιήσαμε την επιλογή <code>-t</code> στο <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, ο spooler, κατά τη διάρκεια της εκτύπωσης, θα μετατρέψει την έξοδο GNU troff σε ένα τύπο δεδομένων κατανοητό από τον προεπιλεγμένο εκτυπωτή.</p></div></div><div class=sect4><h5 id=printing-lpr-options-job-handling>16.5.4.2. Επιλογές Χειρισμού Εργασιών<a class=anchor href=#printing-lpr-options-job-handling></a></h5><div class=paragraph><p>Οι ακόλουθες επιλογές του <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> οδηγούν το LPD να χειριστεί τις εργασίες με ειδικό τρόπο:</p></div><div class=dlist><dl><dt class=hdlist1>-# <em>copies</em></dt><dd><p>Δημιουργεί έναν αριθμό <em>copies</em> (αντιγράφων) για κάθε αρχείο της εργασίας αντί για ένα μόνο αντίγραφο. Ο διαχειριστής μπορεί να απενεργοποιήσει αυτή την επιλογή για να μειώσει την καταπόνηση των εκτυπωτών και να ενθαρρύνει την χρήση φωτοτυπικών μηχανημάτων. Δείτε την ενότητα <a href=#printing-advanced-restricting-copies>Περιορισμός Εκτύπωσης Πολλαπλών Αντιγράφων</a>.</p><div class=paragraph><p>Σε αυτό το παράδειγμα, εκτυπώνουμε στον προεπιλεγμένο εκτυπωτή τρία αντίγραφα του <span class=filename>parser.c</span> και τρία αντίγραφα του <span class=filename>parser.h</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr -#3 parser.c parser.h</code></pre></div></div></dd><dt class=hdlist1>-m</dt><dd><p>Αποστολή mail μετά την ολοκλήρωση εκτύπωσης της εργασίας. Με αυτή την επιλογή, το σύστημα LPD στέλνει mail στο λογαριασμό σας μόλις ολοκληρωθεί ο χειρισμός εκτύπωσης της εργασίας σας. Στο μήνυμα του, θα σας ενημερώσει αν η εργασία ολοκληρώθηκε επιτυχώς ή αν παρουσιάστηκε σφάλμα και (συχνά) ποιό ήταν το σφάλμα.</p></dd><dt class=hdlist1>-s</dt><dd><p>Δεν αντιγράφει τα αρχεία στον κατάλογο spool, αλλά αντί για αυτό, δημιουργεί συμβολικές συντομεύσεις (symbolic links) προς αυτά.</p><div class=paragraph><p>Αν εκτυπώνετε μια μεγάλη εργασία, ίσως θέλετε να χρησιμοποιήσετε αυτή την επιλογή. Θα σας γλυτώσει χώρο στον κατάλογο spool (ίσως η εργασία σας να υπερβαίνει τον ελεύθερο χώρο του συστήματος αρχείων που περιέχει τον κατάλογο spool). Επίσης θα κερδίσετε χρόνο αφού το LPD δεν θα χρειαστεί να αντιγράψει όλη την εργασία σας στον κατάλογο spool.</p></div><div class=paragraph><p>Αυτό, ωστόσο, έχει και ένα μειονέκτημα: από τη στιγμή που το LPD θα κάνει αναφορά κατευθείαν στο πρωτότυπο αρχείο, δεν θα έχετε δυνατότητα να μετατρέψετε ή να διαγράψετε το αρχείο έως ότου εκτυπωθεί.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν εκτυπώνετε σε ένα απομακρυσμένο εκτυπωτή, το LPD πιθανώς θα χρειαστεί τελικά να αντιγράψει τα αρχεία από τον τοπικό υπολογιστή στον απομακρυσμένο, επομένως η επιλογή <code>-s</code> σε αυτή την περίπτωση εξοικονομεί χώρο στον τοπικό κατάλογο spool, αλλά όχι στον απομακρυσμένο. Εξακολουθεί ωστόσο να είναι ιδιαίτερα χρήσιμη.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>-r</dt><dd><p>Απομακρύνει τα αρχεία της εργασίας μετά την αντιγραφή τους στον κατάλογο spool, ή μετά την εκτύπωση τους με την επιλογή <code>-s</code>. Να είστε προσεκτικοί με αυτή την επιλογή!</p></dd></dl></div></div><div class=sect4><h5 id=printing-lpr-options-misc>16.5.4.3. Επιλογές Σελίδων Κεφαλίδας<a class=anchor href=#printing-lpr-options-misc></a></h5><div class=paragraph><p>Αυτές οι επιλογές του <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> ρυθμίζουν το κείμενο που κανονικά εμφανίζεται στην σελίδα κεφαλίδας της εργασίας. Αν οι σελίδες κεφαλίδας παρεμποδίζονται για τον συγκεκριμένο εκτυπωτή, αυτές οι επιλογές δεν έχουν καμία επίδραση. Δείτε την ενότητα <a href=#printing-advanced-header-pages>Σελίδες Κεφαλίδας</a> για πληροφορίες σχετικά με τις ρυθμίσεις των σελίδων κεφαλίδας.</p></div><div class=dlist><dl><dt class=hdlist1>-C <em>text</em></dt><dd><p>Αντικαθιστά το όνομα υπολογιστή στη σελίδα κεφαλίδας με <em>text</em>. Το όνομα υπολογιστή που εμφανίζεται είναι, από προεπιλογή, το όνομα του υπολογιστή από τον οποίο έγινε η αποστολή της εργασίας.</p></dd><dt class=hdlist1>-J <em>text</em></dt><dd><p>Αντικαθιστά το όνομα εργασίας στη σελίδα κεφαλίδας με <em>text</em>. Το όνομα εργασίας που εμφανίζεται από προεπιλογή, είναι το όνομα του πρώτου αρχείου της εργασίας, ή <span class=filename>stdin</span> αν η εκτύπωση γίνεται από το standard input.</p></dd><dt class=hdlist1>-h</dt><dd><p>Δεν εκτυπώνει σελίδα κεφαλίδας.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ανάλογα με τις ρυθμίσεις, αυτή η επιλογή ίσως να μην έχει επίδραση λόγω του τρόπου με τον οποίο δημιουργούνται οι σελίδες κεφαλίδας. Για περισσότερες λεπτομέρειες, δείτε την ενότητα <a href=#printing-advanced-header-pages>Σελίδες Κεφαλίδας</a>.</p></div></td></tr></tbody></table></div></dd></dl></div></div></div><div class=sect3><h4 id=printing-lpc>16.5.5. Διαχείριση Εκτυπωτών<a class=anchor href=#printing-lpc></a></h4><div class=paragraph><p>Ως διαχειριστής, χρειάστηκε να εγκαταστήσετε, να ρυθμίσετε και να δοκιμάσετε τους εκτυπωτές σας. Χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>, μπορείτε να επικοινωνήσετε με τους εκτυπωτές σας με ακόμη περισσότερους τρόπους. Με την <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>, μπορείτε:</p></div><div class=ulist><ul><li><p>Να εκκινείτε και να σταματάτε τους εκτυπωτές</p></li><li><p>Να ενεργοποιείτε και να απενεργοποιείτε τις ουρές αναμονής</p></li><li><p>Να ανακατατάσσετε την σειρά εργασιών σε κάθε ουρά αναμονής.</p></li></ul></div><div class=paragraph><p>Καταρχήν, μία σημείωση σχετικά με την ορολογία: αν ένας εκτυπωτής είναι <em>σταματημένος (stopped)</em>, δεν θα εκτυπώσει τίποτε από την ουρά αναμονής εργασιών. Οι χρήστες μπορούν ακόμη να στέλνουν εργασίες, οι οποίες μπαίνουν στην ουρά αναμονής έως ότου ο εκτυπωτής <em>ξεκινήσει</em> ή καθαριστεί η ουρά αναμονής.</p></div><div class=paragraph><p>Αν έχει <em>απενεργοποιηθεί</em> η ουρά αναμονής, κανείς χρήστης (εκτός του <code>root</code>) δεν μπορεί να αποστείλει εργασίες στον εκτυπωτή. Μια <em>ενεργή</em> ουρά αναμονής επιτρέπει να αποσταλούν εργασίες στον εκτυπωτή. Ένας εκτυπωτής μπορεί να <em>ξεκινήσει</em> με ουρά αναμονής απενεργοποιημένη, και σε αυτή την περίπτωση θα συνεχίσει να εκτυπώνει τις εργασίες της ουράς έως ότου αυτή αδειάσει.</p></div><div class=paragraph><p>Γενικά, πρέπει να έχετε προνόμια <code>root</code> για να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>. Οι κανονικοί χρήστες μπορούν να χρησιμοποιούν την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> μόνο για να βλέπουν την κατάσταση του εκτυπωτή και να επανεκκινούν τον εκτυπωτή σε περίπτωση μπλοκαρίσματος.</p></div><div class=paragraph><p>Παρακάτω θα βρείτε μια λίστα εντολών του <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>. Οι περισσότερες από τις εντολές παίρνουν ως παράμετρο το <em>printer-name</em> για τη ρύθμιση του συγκεκριμένου εκτυπωτή. Μπορείτε να χρησιμοποιείτε <code>all</code> στη θέση του <em>printer-name</em> για να αναφερθείτε σε όλους τους εκτυπωτές που είναι καταχωρισμένοι στο <span class=filename>/etc/printcap</span>.</p></div><div class=dlist><dl><dt class=hdlist1><code>abort printer-name</code></dt><dd><p>Διαγράφει την τρέχουσα εργασία και σταματάει τον εκτυπωτή. Οι χρήστες μπορούν ακόμη να αποστείλουν εργασίες αν η ουρά αναμονής είναι ακόμη ενεργή.</p></dd><dt class=hdlist1><code>clean printer-name</code></dt><dd><p>Διαγράφει τα παλιά αρχεία από τον κατάλογο spool του εκτυπωτή. Σε κάποιες περιπτώσεις, τα αρχεία από τα οποία αποτελείται κάποια εργασία δεν αφαιρούνται κανονικά από το LPD, ειδικά αν υπήρξαν σφάλματα κατά την εκτύπωση ή κάποιες ενέργειες από τον διαχειριστή. Αυτή η εντολή βρίσκει αρχεία που δεν ανήκουν στον κατάλογο spool και τα αφαιρεί.</p></dd><dt class=hdlist1><code>disable printer-name</code></dt><dd><p>Απενεργοποιεί την ουρά αναμονής για νέες εργασίες. Αν ο εκτυπωτής δουλεύει, θα συνεχίσει να εκτυπώνει τις εναπομείναντες εργασίες στην ουρά αναμονής. Ο superuser (<code>root</code>) μπορεί πάντα να στέλνει εργασίες, ακόμη και σε απενεργοποιημένη σειρά αναμονής.</p><div class=paragraph><p>Αυτή η εντολή είναι χρήσιμη, όταν ελέγχετε ένα νέο εκτυπωτή ή όταν εγκαθιστάτε ένα φίλτρο: απενεργοποιήστε την ουρά αναμονής και στείλτε εργασίες σαν <code>root</code>. Οι υπόλοιποι χρήστες δεν θα έχουν δυνατότητα να αποστείλουν εργασίες έως ότου ολοκληρώσετε τους ελέγχους σας και επανενεργοποιήσετε την ουρά αναμονής με την εντολή <code>enable</code>.</p></div></dd><dt class=hdlist1><code>down printer-name message</code></dt><dd><p>Οδηγεί τον εκτυπωτή σε "κατέβασμα" (down). Είναι ισοδύναμο με το <code>disable</code> ακολουθούμενο από ένα <code>stop</code>. Το <em>message</em> (μήνυμα) εμφανίζεται όταν κάποιος χρήστης ελέγχει την σειρά αναμονής με <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> ή την κατάσταση του εκτυπωτή με <code>lpc status</code>.</p></dd><dt class=hdlist1><code>enable printer-name</code></dt><dd><p>Ενεργοποίηση της ουράς αναμονής του εκτυπωτή. Οι χρήστες μπορούν να αποστείλουν εργασίες αλλά ο εκτυπωτής δεν θα τυπώσει έως ότου ξεκινήσει.</p></dd><dt class=hdlist1><code>help command-name</code></dt><dd><p>Τυπώνει σελίδες βοηθείας για την εντολή <em>command-name</em>. Δίχως το <em>command-name</em>, εκτυπώνει μια περίληψη όλων των διαθέσιμων εντολών.</p></dd><dt class=hdlist1><code>restart printer-name</code></dt><dd><p>Ξεκινά τον εκτυπωτή. Οι κανονικοί χρήστες μπορούν να χρησιμοποιήσουν αυτή την εντολή μόνο σε κάποια ειδική περίπτωση που το LPD δεν αποκρίνεται, αλλά δεν μπορούν να ξεκινήσουν ένα εκτυπωτή που έχει σταματήσει εξαιτίας των εντολών <code>stop</code> ή <code>down</code>. Η εντολή <code>restart</code> είναι ισοδύναμη με την <code>abort</code> ακολουθούμενη από τη <code>start</code>.</p></dd><dt class=hdlist1><code>start printer-name</code></dt><dd><p>Ξεκινά τον εκτυπωτή. Ο εκτυπωτής θα τυπώσει εργασίες από την ουρά αναμονής του.</p></dd><dt class=hdlist1><code>stop printer-name</code></dt><dd><p>Σταματάει τον εκτυπωτή. Ο εκτυπωτής θα ολοκληρώσει την τρέχουσα εργασία του και δεν θα τυπώσει καμία άλλη εργασία από την ουρά αναμονής του. Ακόμη και αν ο εκτυπωτής είναι σταματημένος, οι χρήστες μπορούν ακόμη να στέλνουν εργασίες αν είναι ενεργοποιημένη η ουρά αναμονής.</p></dd><dt class=hdlist1><code>topq printer-name job-or-username</code></dt><dd><p>Ανακατάταξη της ουράς αναμονής για τον <em>printer-name</em>. Τοποθετούνται πρώτες οι εργασίες με αριθμό αναφοράς <em>job</em> ή αυτές που ανήκουν στο χρήστη <em>username</em>. Για αυτή την εντολή, δεν μπορείτε να χρησιμοποιήσετε <code>all</code> στην θέση του <em>printer-name</em>.</p></dd><dt class=hdlist1><code>up printer-name</code></dt><dd><p>Οδηγεί τον εκτυπωτή σε "ανέβασμα" (up). Το αντίθετο της εντολής <code>down</code>. Ισοδυναμεί με την <code>start</code> ακολουθούμενη από την εντολή <code>enable</code>.</p></dd></dl></div><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> δέχεται τις παραπάνω εντολές στην γραμμή εντολών. Αν δεν εισάγετε καμία εντολή, το <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> μπαίνει σε κατάσταση αλληλεπίδρασης (interactive), όπου μπορείτε να πληκτρολογείτε εντολές μέχρι να δώσετε <code>exit</code>, <code>quit</code>, ή end-of-file.</p></div></div></div><div class=sect2><h3 id=printing-lpd-alternatives>16.6. Εναλλακτικές Λύσεις για τον Στάνταρ Spooler<a class=anchor href=#printing-lpd-alternatives></a></h3><div class=paragraph><p>Αν έχετε μελετήσει πιστά όλο το κεφάλαιο μέχρι εδώ, θα έχετε μάθει σχεδόν τα πάντα σχετικά με το σύστημα παροχέτευσης LPD που διατίθεται με το FreeBSD. Θα έχετε κατανοήσει και πολλές από τις ελλείψεις του, που φυσικά γεννούν το ερώτημα: "Ποια άλλα συστήματα παροχέτευσης (που να λειτουργούν στο FreeBSD) υπάρχουν διαθέσιμα;"</p></div><div class=dlist><dl><dt class=hdlist1>LPRng</dt><dd><p>Το LPRng, το οποίο σκόπιμα σημαίνει "LPR: the Next Generation (η Επόμενη Γενιά)" είναι μια από την αρχή υλοποίηση του PLP. Ο Patrick Powell και ο Justin Mason (κύριος συντηρητής του PLP) συνεργάστηκαν για να φτιάξουν το LPRng. Η κύρια τοποθεσία του LPRng είναι η <a href=http://www.lprng.org/>http://www.lprng.org/</a>.</p></dd><dt class=hdlist1>CUPS</dt><dd><p>Το CUPS, ή αλλιώς Common UNIX Printing System, παρέχει μια φορητή πλατφόρμα εκτυπώσεων για λειτουργικά συστήματα βασισμένα στο UNIX®. Αναπτύχθηκε από την Easy Software Products για να προωθήσει μια στάνταρ λύση εκτυπώσεων για όλους τους χρήστες και κατασκευαστές UNIX®.</p><div class=paragraph><p>Το CUPS χρησιμοποιεί το πρωτόκολλο Internet Printing Protocol (IPP) ως βάση του για τη διαχείριση εργασιών εκτύπωσης και ουρών αναμονής. Υποστηρίζονται επίσης, αλλά με μειωμένη λειτουργικότητα, τα πρωτόκολλα Line Printer Daemon (LPD), Server Message Block (SMB), και AppSocket (γνωστό ως JetDirect). Το CUPS προσθέτει δυνατότητες ανίχνευσης δικτυακών εκτυπωτών, ενώ μέσω των επιλογών PostScript Printer Description (PPD) γίνεται εφικτή η υποστήριξη σύγχρονων εκτυπωτών στον κόσμο του UNIX®.</p></div><div class=paragraph><p>Η κύρια τοποθεσία του CUPS είναι η <a href=http://www.cups.org/>http://www.cups.org/</a>.</p></div></dd><dt class=hdlist1>HPLIP</dt><dd><p>Το HPLIP, ή Σύστημα Απεικόνισης και Εκτύπωσης της HP για Linux®, είναι μια σουίτα εφαρμογών για συσκευές της HP, που υποστηρίζει λειτουργίες όπως η εκτύπωση, η σάρωση και η αποστολή / λήψη φαξ. Η σουίτα αυτή χρησιμοποιεί το CUPS ως backend για κάποιες από τις λειτουργίες εκτύπωσης που παρέχει.</p><div class=paragraph><p>Η κύρια δικτυακή τοποθεσία της εφαρμογής HPLIP είναι <a href=http://hplipopensource.com/hplip-web/index.html>http://hplipopensource.com/hplip-web/index.html</a>.</p></div></dd></dl></div></div><div class=sect2><h3 id=printing-troubleshooting>16.7. Εντοπισμός Βλαβών<a class=anchor href=#printing-troubleshooting></a></h3><div class=paragraph><p>Μετά την εκτέλεση του απλού τεστ με το <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>, αντί της κανονικής εκτύπωσης, μπορεί να έχετε λάβει ως αποτέλεσμα μία από τις ακόλουθες καταστάσεις:</p></div><div class=dlist><dl><dt class=hdlist1>Ο εκτυπωτής καθυστέρησε να ξεκινήσει ή δεν εκτύπωσε ολόκληρη τη σελίδα.</dt><dd><p>Ο εκτυπωτής τύπωσε το τεστ, αλλά δεν ξεκίνησε αμέσως. Ίσως χρειάστηκε να πιέσετε το πλήκτρο PRINT REMAINING ή το FORM FEED του εκτυπωτή σας για να εμφανιστεί το επιθυμητό αποτέλεσμα.</p><div class=paragraph><p>Εάν είναι όντως αυτή η περίπτωση σας, ο εκτυπωτής πιθανώς να ήταν σε αναμονή για να εξακριβώσει αν υπήρχαν πρόσθετα δεδομένα στην εργασία εκτύπωσης πριν ξεκινήσει να εκτυπώνει οτιδήποτε. Για να διορθώσετε το πρόβλημα, μπορείτε να θέσετε το φίλτρο κειμένου να στέλνει ένα χαρακτήρα FORM FEED (ή άλλο κατάλληλο) στον εκτυπωτή. Αυτό συνήθως είναι αρκετό για να μπορείτε να εκτυπώνετε κατευθείαν οποιοδήποτε κείμενο απομένει σε αναμονή στην εσωτερική μνήμη (buffer) του εκτυπωτή. Είναι επίσης χρήσιμο να ρυθμίζετε τις εκτυπώσεις σας ώστε να τελειώνουν με γεμάτη την τελευταία σελίδα, ώστε η επόμενη εργασία να μην αρχίζει από τα μισά του προηγούμενου φύλλου.</p></div><div class=paragraph><p>Η ακόλουθη τροποποίηση στο shell script <span class=filename>/usr/local/libexec/if-simple</span> εκτυπώνει ένα form feed μετά την αποστολή της εργασίας στον εκτυπωτή:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# if-simple - Simple text input filter for lpd
# Installed in /usr/local/libexec/if-simple
#
# Simply copies stdin to stdout.  Ignores all filter arguments.
# Writes a form feed character (\f) after printing job.

/bin/cat &amp;&amp; printf &#34;\f&#34; &amp;&amp; exit 0
exit 2</pre></div></div></dd><dt class=hdlist1>Η εκτύπωση παρουσιάζει "φαινόμενο σκάλας (staircase effect)."</dt><dd><p>Στην εκτύπωση σας φαίνεται το ακόλουθο:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span><span class=s2>&#34;#</span><span class=nv>$%</span><span class=s2>&amp;&#39;()*+,-./01234
                &#34;</span><span class=c>#$%&amp;&#39;()*+,-./012345</span>
                                 <span class=c>#$%&amp;&#39;()*+,-./0123456</span></code></pre></div></div><div class=paragraph><p>Γίνατε ένα ακόμα θύμα του <em>φαινομένου σκάλας</em>, που προκλήθηκε από αντιφατικές ερμηνείες των χαρακτήρων με τους οποίους δηλώνεται η τροφοδοσία νέας γραμμής. Τα λειτουργικά συστήματα τύπου UNIX® χρησιμοποιούν έναν μόνο χαρακτήρα ASCII με κωδικό 10, τον line feed (τροφοδοσία γραμμής, LF). Το MS-DOS®, το OS/2®, και διάφορα άλλα, χρησιμοποιούν ένα ζεύγος χαρακτήρων ASCII κωδικού 10 <em>και</em> ASCII κωδικού 13 (τον carriage return ή αλλιώς CR). Πολλοί εκτυπωτές χρησιμοποιούν την σύμβαση του MS-DOS® για την αλλαγή γραμμής.</p></div><div class=paragraph><p>Όταν εκτυπώνετε με το FreeBSD, το κείμενο σας απλά χρησιμοποιεί τον χαρακτήρα τροφοδοσίας γραμμής (line feed). Ο εκτυπωτής, μόλις αντιληφθεί τον χαρακτήρα line feed, προωθεί το χαρτί κατά μία γραμμή, αλλά κρατάει την ίδια θέση οριζόντια καθώς καλείται να εκτυπώσει τον επόμενο χαρακτήρα. Σε αυτό το σημείο χρησιμοποιείται το CR (carriage return): μετακινεί δηλαδή την θέση εργασίας για τον επόμενο χαρακτήρα που πρόκειται να εκτυπωθεί στο αριστερό άκρο του χαρτιού.</p></div><div class=paragraph><p>Το FreeBSD επιθυμεί ο εκτυπωτής να μπορεί να ενεργεί ως εξής:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Όταν ο εκτυπωτής λαμβάνει CR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Να εκτυπώνει CR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Όταν ο εκτυπωτής λαμβάνει LF</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Να εκτυπώνει CR + LF</p></td></tr></tbody></table><div class=paragraph><p>Υπάρχουν διάφοροι τρόποι για να επιτευχθεί αυτό:</p></div><div class=ulist><ul><li><p>Χρησιμοποιήστε τα πλήκτρα ρύθμισης του εκτυπωτή ή τον πίνακα ελέγχου για να αλλάξετε τον τρόπο με τον οποίο ερμηνεύει αυτούς τους χαρακτήρες ο εκτυπωτής σας. Συμβουλευτείτε το εγχειρίδιο χρήσης του για να δείτε πως μπορεί να γίνει αυτό.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν έχετε και άλλα λειτουργικά στο σύστημα σας εκτός από το FreeBSD, πιθανόν να χρειαστεί, όταν τα χρησιμοποιείτε, να <em>επαναρυθμίσετε</em> τον εκτυπωτή σας ώστε να ερμηνεύει διαφορετικά τους χαρακτήρες CR και LF. Στην περίπτωση αυτή, ίσως είναι καλύτερο να προτιμήσετε κάποια από τις λύσεις που ακολουθούν.</p></div></td></tr></tbody></table></div></li><li><p>Ο οδηγός (driver) της σειριακής γραμμής του FreeBSD μπορεί να μετατρέπει αυτόματα από LF σε CR+LF. Φυσικά, αυτό δουλεύει <em>μόνο</em> σε σειριακές θύρες. Για να ενεργοποιήσετε αυτή την λειτουργία, χρησιμοποιήστε την ικανότητα <code>ms#</code> και ορίστε την κατάσταση λειτουργίας <code>onlcr</code> στο αρχείο <span class=filename>/etc/printcap</span> για τον εκτυπωτή.</p></li><li><p>Στείλτε ένα <em>κωδικό διαφυγής (escape code)</em> στον εκτυπωτή ώστε να χειρίζεται προσωρινά τους χαρακτήρες LF με διαφορετικό τρόπο. Συμβουλευτείτε το εγχειρίδιο χρήσης του εκτυπωτή σας για τους κώδικες διαφυγής που υποστηρίζονται. Όταν ανακαλύψετε τον κατάλληλο, μετατρέψτε το φίλτρο κειμένου ώστε να στέλνει πρώτα τον κωδικό, και έπειτα την εργασία στον εκτυπωτή.</p><div class=paragraph><p>Εδώ είναι ένα παράδειγμα φίλτρου κειμένου για εκτυπωτές που καταλαβαίνουν τους κωδικούς διαφυγής PCL της Hewlett-Packard. Αυτό το φίλτρο κάνει τον εκτυπωτή να χειρίζεται τους χαρακτήρες LF ως LF και CR. Έπειτα αποστέλλει την εργασία, στέλνοντας στο τέλος της ένα χαρακτήρα αλλαγής σελίδας (form feed) ώστε να γίνει σωστή εξαγωγή της τελευταίας σελίδας. Το φίλτρο αυτό θα πρέπει να δουλεύει με σχεδόν όλους τους εκτυπωτές της Hewlett Packard.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# hpif - Simple text input filter for lpd for HP-PCL based printers
# Installed in /usr/local/libexec/hpif
#
# Simply copies stdin to stdout.  Ignores all filter arguments.
# Tells printer to treat LF as CR+LF.  Ejects the page when done.

printf &#34;\033&amp;k2G&#34; &amp;&amp; cat &amp;&amp; printf &#34;\033&amp;l0H&#34; &amp;&amp; exit 0
exit 2</pre></div></div><div class=paragraph><p>Εδώ είναι ένα παράδειγμα για το <span class=filename>/etc/printcap</span> ενός υπολογιστή με όνομα <code>orchid</code>. Έχει ένα μόνο εκτυπωτή στην πρώτη παράλληλη θύρα του, ένα Hewlett Packard LaserJet 3Si με όνομα <code>teak</code>. Χρησιμοποιεί το παραπάνω script ως φίλτρο κειμένου:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sh:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:</pre></div></div></li></ul></div></dd><dt class=hdlist1>Εκτυπώνεται η μία γραμμή πάνω στην άλλη.</dt><dd><p>Ο εκτυπωτής δεν προωθεί καθόλου το χαρτί και όλες οι γραμμές κειμένου τυπώνονται η μία πάνω από την άλλη, σε μία γραμμή.</p><div class=paragraph><p>Αυτό το πρόβλημα είναι το "αντίστροφο" του φαινόμενου σκάλας, που περιγράψαμε προηγουμένως, και είναι πολύ σπάνιο. Σε κάποιο σημείο, οι χαρακτήρες LF που χρησιμοποιεί το FreeBSD για να τερματίσει την γραμμή, ερμηνεύονται ως χαρακτήρες CR οι οποίοι επιστρέφουν την κεφαλή στο αριστερό άκρο του χαρτιού, αλλά δίχως να προωθήσουν το χαρτί μία γραμμή προς τα κάτω.</p></div><div class=paragraph><p>Χρησιμοποιήστε τους διακόπτες ρυθμίσεων του εκτυπωτή ή τον πίνακα ελέγχου για να θέσετε τις ακόλουθες επιλογές για τα LF και CR characters:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Ο εκτυπωτής λαμβάνει</th><th class="tableblock halign-left valign-top">Ο εκτυπωτής τυπώνει</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LF</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CR + LF</p></td></tr></tbody></table></dd><dt class=hdlist1>Ο εκτυπωτής δεν εκτυπώνει (χάνει) κάποιους χαρακτήρες.</dt><dd><p>Ο εκτυπωτής, ενώ είναι σε λειτουργία εκτύπωσης, δεν εκτυπώνει κάποιους χαρακτήρες σε όλες τις γραμμές. Το πρόβλημα πιθανώς να γίνεται εντονότερο καθώς η εκτύπωση εξελίσσεται, χάνοντας ακόμη περισσότερους χαρακτήρες.</p><div class=paragraph><p>Το πρόβλημα είναι πως ο εκτυπωτής, καθώς εκτυπώνει, δεν προλαβαίνει να ακολουθήσει την ταχύτητα με την οποία ο υπολογιστής στέλνει δεδομένα μέσω της σειριακής διασύνδεσης (αυτό το πρόβλημα δεν πρέπει κανονικά να συμβαίνει σε εκτυπωτές συνδεμένους σε παράλληλες θύρες). Υπάρχουν δύο τρόποι για να ξεπεραστεί αυτό το πρόβλημα:</p></div><div class=ulist><ul><li><p>Εάν ο εκτυπωτής υποστηρίζει έλεγχο ροής XON/XOFF, ρυθμίστε το FreeBSD να τον χρησιμοποιήσει ορίζοντας την κατάσταση λειτουργίας <code>ixon</code> με την ικανότητα <code>ms#</code>.</p></li><li><p>Εάν ο εκτυπωτής υποστηρίζει έλεγχο ροής τύπου Request to Send / Clear to Send (hardware handshake, γνωστό και με την ονομασία <code>RTS/CTS</code>), πρέπει να οριστεί η κατάσταση λειτουργίας <code>crtscts</code> στην ικανότητα <code>ms#</code>. Βεβαιωθείτε πως το καλώδιο που συνδέει τον εκτυπωτή με τον υπολογιστή είναι σωστά φτιαγμένο για χρήση αυτού του ελέγχου ροής.</p></li></ul></div></dd><dt class=hdlist1>Ο εκτυπωτής τυπώνει σκουπίδια.</dt><dd><p>Ο εκτυπωτής τύπωσε κάτι που αποκαλούμε τυχαία σκουπίδια, εννοώντας οτιδήποτε εκτός του επιθυμητού κειμένου.</p><div class=paragraph><p>Αυτό είναι συνήθως ένα ακόμα σύμπτωμα λανθασμένων παραμέτρων σειριακής επικοινωνίας με τον εκτυπωτή. Ελέγξτε ξανά την τιμή bps rate στην ικανότητα <code>br</code>, και την ρύθμιση parity στην ικανότητα <code>ms#</code>. Βεβαιωθείτε πως ο εκτυπωτής χρησιμοποιεί τις ίδιες ρυθμίσεις που έχουν καθοριστεί στο αρχείο <span class=filename>/etc/printcap</span>.</p></div></dd><dt class=hdlist1>Δεν συνέβη τίποτε, ο εκτυπωτής δεν ξεκίνησε καν.</dt><dd><p>Αν δεν συνέβη τίποτε, το πρόβλημα πιθανόν να οφείλεται στο FreeBSD και όχι στο hardware. Προσθέστε την ικανότητα αρχείου καταγραφής (log file, <code>lf</code>) στο αρχείο <span class=filename>/etc/printcap</span>, στην καταχώριση του εκτυπωτή που έχει το πρόβλημα. Για παράδειγμα, εδώ είναι η καταχώριση για τον <code>rattan</code>, με την ικανότητα <code>lf</code>:</p><div class="literalblock programlisting"><div class=content><pre>rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:\
        :lf=/var/log/rattan.log</pre></div></div><div class=paragraph><p>Έπειτα, προσπαθήστε να ξαναεκτυπώσετε. Ελέγξτε το αρχείο καταγραφής (log) (στο παράδειγμα μας, <span class=filename>/var/log/rattan.log</span>) για να βρείτε πιθανές αναφορές σφαλμάτων. Με βάση τα μηνύματα που βλέπετε, προσπαθήστε να διορθώσετε το πρόβλημα.</p></div><div class=paragraph><p>Αν δεν καθορίσετε την ικανότητα <code>lf</code>, το LPD χρησιμοποιεί από προεπιλογή το <span class=filename>/dev/console</span>.</p></div></dd></dl></div></div></div></div><div class=sect1><h2 id=linuxemu>Chapter 17. Συμβατότητα με Εκτελέσιμα του Linux<a class=anchor href=#linuxemu></a></h2><div class=sectionbody><div class=sect2><h3 id=linuxemu-synopsis>17.1. Σύνοψη<a class=anchor href=#linuxemu-synopsis></a></h3><div class=paragraph><p>Το FreeBSD παρέχει binary συμβατότητα (εκτελέσιμων) με αρκετά άλλα λειτουργικά τύπου UNIX®, συμπεριλαμβανομένου και του Linux. Σε αυτό το σημείο, μπορεί να αναρωτιέστε γιατί ακριβώς χρειάζεται το FreeBSD να μπορεί να τρέξει εκτελέσιμα Linux; H απάντηση σε αυτή την ερώτηση είναι αρκετά απλή. Πολλές εταιρίες και προγραμματιστές αναπτύσσουν εφαρμογές μόνο για Linux, μια και είναι πολύ "της μόδας" στο κόσμο των υπολογιστών. Αυτό αναγκάζει εμάς τους υπόλοιπους, που χρησιμοποιούμε το FreeBSD, να πιέζουμε τις ίδιες αυτές εταιρίες και προγραμματιστές να δημιουργήσουν κανονικές εκδόσεις των εφαρμογών τους για FreeBSD. Το πρόβλημα είναι, ότι οι περισσότερες από αυτές τις εταιρίες δεν αντιλαμβάνονται πραγματικά πόσοι περισσότεροι άνθρωποι θα χρησιμοποιούσαν το προϊόν τους αν είχαν εκδόσεις και για FreeBSD, και οι περισσότερες συνεχίζουν να αναπτύσσουν μόνο για Linux. Άρα τι μπορεί να κάνει ένας χρήστης του FreeBSD; Εδώ έρχεται να βοηθήσει η binary συμβατότητα του FreeBSD με το Linux.</p></div><div class=paragraph><p>Εν συντομία, η συμβατότητα επιτρέπει στους χρήστες του FreeBSD να εκτελέσουν περίπου το 90% όλων των Linux εφαρμογών χωρίς μετατροπές. Αυτό περιλαμβάνει εφαρμογές όπως το StarOffice™, την Linux έκδοση του <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>, Adobe® Acrobat®, RealPlayer®, Oracle®, WordPerfect®, Doom, Quake, και περισσότερα. Έχει επίσης αναφερθεί ότι σε κάποιες περιπτώσεις, τα εκτελέσιμα του Linux έχουν καλύτερη απόδοση στο FreeBSD από ότι στο Linux.</p></div><div class=paragraph><p>Υπάρχουν ωστόσο κάποια συγκεκριμένα για το Linux στοιχεία του λειτουργικού που δεν υποστηρίζονται στο FreeBSD. Τα εκτελέσιμα του Linux δεν θα δουλέψουν στο FreeBSD αν χρησιμοποιούν πολλές εξειδικευμένες κλήσεις i386™, όπως για παράδειγμα την ενεργοποίηση της εικονικής κατάστασης 8086.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να ενεργοποιήσετε την συμβατότητα εκτελέσιμων με το Linux στο σύστημα σας.</p></li><li><p>Πως να εγκαταστήσετε πρόσθετες κοινόχρηστες βιβλιοθήκες του Linux.</p></li><li><p>Πως να εγκαταστήσετε εφαρμογές του Linux στο FreeBSD.</p></li><li><p>Τις λεπτομέρειες της υλοποίησης της συμβατότητας με το Linux στο FreeBSD.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να γνωρίζετε πως θα εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=linuxemu-lbc-install>17.2. Εγκατάσταση<a class=anchor href=#linuxemu-lbc-install></a></h3><div class=paragraph><p>Η συμβατότητα με εκτελέσιμα του Linux δεν είναι ενεργή εξ' αρχής. Ο ευκολότερος τρόπος για να ενεργοποιήσετε αυτή τη λειτουργία είναι να φορτώσετε το KLD (άρθρωμα) <code>linux</code> ("Kernel LoaDable object"). Μπορείτε να φορτώσετε αυτό το άρθρωμα στον πυρήνα δίνοντας τη παρακάτω εντολή ως <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux</span></code></pre></div></div><div class=paragraph><p>Αν θέλετε να έχετε πάντα ενεργοποιημένη τη συμβατότητα με Linux, τότε θα χρειαστεί να προσθέσετε τη παρακάτω γραμμή στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>linux_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=kldstat&amp;sektion=8&amp;format=html">kldstat(8)</a> μπορεί να χρησιμοποιηθεί για να ελεγχθεί αν το KLD είναι φορτωμένο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kldstat
Id Refs Address    Size     Name
 1    2 0xc0100000 16bdb8   kernel
 7    1 0xc24db000 d000     linux.ko</code></pre></div></div><div class=paragraph><p>Αν για κάποιο λόγο δεν θέλετε ή δε μπορείτε να φορτώσετε το KLD, τότε μπορείτε να συνδέσετε στατικά την υποστήριξη εκτελέσιμων του Linux στον πυρήνα με το να προσθέσετε την επιλογή <code>options COMPAT_LINUX</code> στο αρχείων ρυθμίσεων του πυρήνα. Στη συνέχεια μπορείτε να εγκαταστήσετε τον νέο πυρήνα όπως περιγράφεται στο <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>.</p></div><div class=sect3><h4 id=_εγκατάσταση_των_linux_runtime_libraries>17.2.1. Εγκατάσταση των Linux Runtime Libraries<a class=anchor href=#_εγκατάσταση_των_linux_runtime_libraries></a></h4><div class=paragraph><p>Αυτό μπορεί να γίνει με δύο τρόπους. Είτε με τη χρήση του <a href=#linuxemu-libs-port>linux_base-fc4</a> port, ή με <a href=#linuxemu-libs-manually>χειροκίνητη</a> εγκατάσταση τους.</p></div><div class=sect4><h5 id=linuxemu-libs-port>17.2.1.1. Εγκατάσταση μέσω του linux_base Port<a class=anchor href=#linuxemu-libs-port></a></h5><div class=paragraph><p>Αυτός είναι κατά γενική ομολογία ο ευκολότερος τρόπος για την εγκατάσταση των runtime libraries. Είναι η ίδια διαδικασία εγκατάστασης που ακολουθείται και για οποιοδήποτε άλλο port από τη <a href=./#ports>Συλλογή των Ports</a>. Απλά κάντε το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/linux_base-f10</span>
<span class=c># make install distclean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν χρησιμοποιείτε κάποια έκδοση του FreeBSD πριν την 8.0, θα πρέπει να εγκαταστήσετε το port <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base-fc4/>emulators/linux_base-fc4</a> αντί για το <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base-f10/>emulators/linux_base-f10</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Θα πρέπει τώρα να έχετε κανονική συμβατότητα με εκτελέσιμα του Linux. Μερικά προγράμματα παραπονιούνται ότι οι βιβλιοθήκες συστήματος (system libraries) δεν είναι στη τελευταία τους έκδοση. Γενικά όμως, αυτό δεν αποτελεί κανένα πρόβλημα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μπορούν να υπάρχουν πολλαπλές εκδόσεις του <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base/>emulators/linux_base</a>, που να αντιστοιχούν στις διαφορετικές εκδόσεις των διανομών Linux. Θα πρέπει να κάνετε εγκατάσταση των ports που προαπαιτούνται από τις εφαρμογές Linux τις οποίες θέλετε να εγκαταστήσετε.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=linuxemu-libs-manually>17.2.1.2. Χειροκίνητη εγκατάσταση των Libraries<a class=anchor href=#linuxemu-libs-manually></a></h5><div class=paragraph><p>Αν δεν έχετε εγκαταστήσει την συλλογή των "ports", μπορείτε να εγκαταστήσετε τις βιβλιοθήκες χειροκίνητα. Θα χρειαστείτε τα Linux shared libraries τα οποία απαιτεί το πρόγραμμα. Επίσης, θα χρειαστεί να δημιουργήσετε και έναν κατάλογο "shadow root", <span class=filename>/compat/linux</span>, για τις βιβλιοθήκες Linux που θα υπάρχουν στο FreeBSD. Οποιαδήποτε κοινές βιβλιοθήκες (shared libraries) οι οποίες χρησιμοποιούνται από εφαρμογές Linux και εκτελούνται στο FreeBSD θα κοιτάξουν πρώτα σε αυτόν τον κατάλογο. Επομένως, αν μια εφαρμογή Linux φορτώσει για παράδειγμα το <span class=filename>/lib/libc.so</span>, το FreeBSD θα προσπαθήσει να φορτώσει πρώτα το <span class=filename>/compat/linux/lib/libc.so</span>, και αν αυτό δεν υπάρχει, τότε θα προσπαθήσει να φορτώσει το <span class=filename>/lib/libc.so</span>. Τα shared libraries θα πρέπει να εγκατασταθούν στο shadow tree <span class=filename>/compat/linux/lib</span> αντί για τις τοποθεσίες που αναφέρει το <code>ld.so</code> στο Linux.</p></div><div class=paragraph><p>Γενικά, τουλάχιστον στις πρώτες σας εγκαταστάσεις εφαρμογών Linux, θα χρειαστεί να ψάξετε για τις κοινές βιβλιοθήκες από τα αντίστοιχα εκτελέσιμα. Μετά από κάποιο διάστημα θα έχετε ένα ικανοποιητικό αριθμό Linux shared libraries στο σύστημά σας και πλέον δε θα χρειάζεται επιπλέον εργασία πέρα από την εγκατάσταση της εφαρμογής.</p></div></div><div class=sect4><h5 id=_εγκατάσταση_πρόσθετων_shared_libraries>17.2.1.3. Εγκατάσταση Πρόσθετων Shared Libraries<a class=anchor href=#_εγκατάσταση_πρόσθετων_shared_libraries></a></h5><div class=paragraph><p>Και τι γίνεται στη περίπτωση που έχετε εγκαταστήσει το <span class=filename>linux_base</span> port και οι εφαρμογές σας ακόμη παραπονιούνται για shared libraries που λείπουν; Πώς μπορείτε να ξέρετε ποια shared libraries χρειάζεται κάποια εφαρμογή, και που μπορείτε να τα βρείτε; Βασικά, υπάρχουν 2 επιλογές (για να ακολουθήσετε τις παρακάτω οδηγίες θα πρέπει να είστε <code>root</code> στο σύστημά σας).</p></div><div class=paragraph><p>Αν έχετε πρόσβαση σε κάποιο μηχάνημα Linux, ρίξτε μια ματιά στα shared libraries που χρειάζεται μια εφαρμογή, και αντιγράψτε τα στο FreeBSD. Δείτε το παρακάτω παράδειγμα:</p></div><div class=paragraph><p>Ας υποθέσουμε ότι κατεβάσατε μέσω FTP το εκτελέσιμο του Doom για το Linux, και το βάλατε στο Linux σύστημα στο οποίο έχετε πρόσβαση. Μπορείτε στη συνέχεια να ελέγξετε ποια shared libraries χρειάζεται η εφαρμογή με την εντολή <code>ldd linuxdoom</code>, όπως:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldd linuxdoom
libXt.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libX11.so.3.1.0
libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> <span class=o>=&gt;</span> /lib/libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Θα χρειαστεί να πάρετε όλα τα αρχεία από τη τελευταία στήλη, και να τα αντιγράψετε στον κατάλογο <span class=filename>/compat/linux</span>, και να δημιουργήσετε προς αυτά τους αντίστοιχους συμβολικούς δεσμούς (symbolic links) με τα ονόματα της πρώτης στήλης. Αυτό σημαίνει ότι πρακτικά, θα έχετε αυτά τα αρχεία στο σύστημα σας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σημειώστε ότι αν έχετε ήδη κάποιο Linux shared library που ο αριθμός έκδοσης είναι ο ίδιος με αυτόν της πρώτης στήλης του <code>ldd</code>, δε θα χρειαστεί να αντιγράψετε το αρχείο όπως αυτό ονομάζεται στη τελευταία στήλη, τα υπάρχοντα αρχεία θα πρέπει να κάνουν τη δουλειά τους. Σας συμβουλεύουμε όμως να αντιγράψετε το shared library αν είναι κάποια νεότερη έκδοση. Μπορείτε να διαγράψετε τα παλιά αρχεία, αρκεί όμως να ανανεώσετε τους συμβολικούς δεσμούς ώστε να οδηγούν στα νέα αρχεία. Επομένως, αν έχετε τις παρακάτω βιβλιοθήκες στο σύστημά σας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</code></pre></div></div><div class=paragraph><p>και βρείτε μια εφαρμογή η οποία ζητάει μια νεότερη έκδοση μέσω του <code>ldd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Αν η διαφορά της έκδοσης στο τελευταία ψηφίο είναι μόνο μίας ή δύο εκδόσεων, τότε μην σας απασχολεί η αντιγραφή του <span class=filename>/lib/libc.so.4.6.29</span>, γιατί το πρόγραμμα θα πρέπει να τρέχει κανονικά και με τη λίγο παλαιότερη έκδοση. Παρ' όλα αυτά, αν θέλετε, μπορείτε να αντικαταστήσετε το <span class=filename>libc.so</span> και έτσι θα έχετε το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ο μηχανισμός των συμβολικών συνδέσμων χρειάζεται <em>μόνο</em> για τις εφαρμογές του Linux. Ο runtime linker του FreeBSD κοιτάει μόνος του για τις πιο πρόσφατες εκδόσεις των βιβλιοθηκών και έτσι δε χρειάζεται να σας απασχολεί.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_εγκατάσταση_των_linux_elf_binaries>17.2.2. Εγκατάσταση των Linux ELF Binaries<a class=anchor href=#_εγκατάσταση_των_linux_elf_binaries></a></h4><div class=paragraph><p>Τα ELF binaries χρειάζονται μερικές φορές ένα ακόμα βήμα, το "branding". Αν προσπαθήσετε να τρέξετε ένα εκτελέσιμο ELF χωρίς branding, τότε θα σας εμφανιστεί το παρακάτω σφάλμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./my-linux-elf-binary
ELF binary <span class=nb>type </span>not known
Abort</code></pre></div></div><div class=paragraph><p>Για να βοηθήσετε τον πυρήνα του FreeBSD να ξεχωρίσει ένα ELF του FreeBSD από ένα του Linux, χρησιμοποιήστε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux my-linux-elf-binary</code></pre></div></div><div class=paragraph><p>To GNU toolchain, ομάδα πρόγραμμα GNU, τοποθετεί πλέον αυτόματα τα κατάλληλα χαρακτηριστικά στα εκτελέσιμα ELF, επομένως το παραπάνω βήμα θα χρειάζεται όλο και λιγότερο στο μέλλον.</p></div></div><div class=sect3><h4 id=_εγκατάσταση_μιας_τυχαίας_linux_rpm_εφαρμογής>17.2.3. Εγκατάσταση μιας Τυχαίας Linux RPM Εφαρμογής<a class=anchor href=#_εγκατάσταση_μιας_τυχαίας_linux_rpm_εφαρμογής></a></h4><div class=paragraph><p>Το FreeBSD διαθέτει την δική του βάση δεδομένων για τα πακέτα, η οποία χρησιμοποιείται για όλα τα ports (και για αυτά που προέρχονται από το Linux®). Για το λόγο αυτό, η βάση δεδομένων Linux® RPM δεν χρησιμοποιείται (δεν υποστηρίζεται).</p></div><div class=paragraph><p>Αν ωστόσο χρειάζεται να εγκαταστήσετε μια οποιαδήποτε εφαρμογή του Linux® που βασίζεται σε πακέτο RPM, μπορείτε να το επιτύχετε με τον παρακάτω τρόπο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /compat/linux</span>
<span class=c># rpm2cpio -q &lt; /path/to/linux.archive.rpm | cpio -id</span></code></pre></div></div><div class=paragraph><p>Χρησιμοποιήστε την <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> για να τυποποιήσετε κατάλληλα τα εκτελέσιμα (όχι τις βιβλιοθήκες!) ως εφαρμογές Linux®. Δεν θα μπορείτε να απεγκαταστήσετε τις εφαρμογές με καθαρό τρόπο, αλλά θα μπορέσετε να κάνετε τις δοκιμές που επιθυμείτε.</p></div></div><div class=sect3><h4 id=_ρύθμιση_του_hostname_resolver>17.2.4. Ρύθμιση του Hostname Resolver<a class=anchor href=#_ρύθμιση_του_hostname_resolver></a></h4><div class=paragraph><p>Αν το DNS δε δουλεύει ή αν σας εμφανίζεται το παρακάτω σφάλμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>resolv+: <span class=s2>&#34;bind&#34;</span> is an invalid keyword resolv+:
<span class=s2>&#34;hosts&#34;</span> is an invalid keyword</code></pre></div></div><div class=paragraph><p>Θα χρειαστεί να ρυθμίσετε το <span class=filename>/compat/linux/etc/host.conf</span> ώστε να περιέχει:</p></div><div class="literalblock programlisting"><div class=content><pre>order hosts, bind
multi on</pre></div></div><div class=paragraph><p>Η σειρά εδώ δηλώνει ότι αρχικά ελέγχεται το αρχείο <span class=filename>/etc/hosts</span> και στη συνέχεια ο DNS server. Όταν το <span class=filename>/compat/linux/etc/host.conf</span> δεν είναι διαθέσιμο, οι εφαρμογές Linux χρησιμοποιούν το <span class=filename>/etc/host.conf</span> του FreeBSD και παραπονιούνται ότι η σύνταξη του αρχείου δεν είναι σωστή. Θα πρέπει να αφαιρέσετε την αναφορά στο <code>bind</code> αν δεν έχετε ρυθμίσει ένα name server μέσω του <span class=filename>/etc/resolv.conf</span>.</p></div></div></div><div class=sect2><h3 id=linuxemu-mathematica>17.3. Εγκαθιστώντας το Mathematica®<a class=anchor href=#linuxemu-mathematica></a></h3><div class=paragraph><p>Το κείμενο αυτό περιγράφει τη διαδικασία εγκατάστασης της έκδοσης Linux του Mathematica® 5.X σε ένα σύστημα FreeBSD.</p></div><div class=paragraph><p>Μπορείτε να αγοράσετε την κανονική ή μαθητική έκδοση του Mathematica® για Linux, απευθείας από τη Wolfram στο <a href=http://www.wolfram.com/>http://www.wolfram.com/</a>.</p></div><div class=sect3><h4 id=_το_πρόγραμμα_εγκατάστασης_του_mathematica>17.3.1. Το Πρόγραμμα Εγκατάστασης του Mathematica®<a class=anchor href=#_το_πρόγραμμα_εγκατάστασης_του_mathematica></a></h4><div class=paragraph><p>Αρχικά, θα πρέπει να πείτε στο FreeBSD ότι τα εκτελέσιμα για Linux του Mathematica® κάνουν χρήση του Linux ABI. Ο ευκολότερος τρόπος για να το κάνετε αυτό είναι να ορίσετε τον τύπο του ELF ως Linux σε όλες τις εφαρμογές που δεν είναι ήδη branded, κάνοντας χρήση της εντολής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.fallback_elf_brand=3</span></code></pre></div></div><div class=paragraph><p>Αυτό θα κάνει το FreeBSD να υποθέσει ότι τα εκτελέσιμα ELF που δεν είναι branded, κάνουν χρήση του Linux ABI και έτσι θα μπορείτε να τρέξετε το πρόγραμμα της εγκατάστασης απευθείας από το CDROM.</p></div><div class=paragraph><p>Τώρα, αντιγράψτε το αρχείο <span class=filename>MathInstaller</span> στον σκληρό σας δίσκο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cp /cdrom/Unix/Installers/Linux/MathInstaller /localdir/</span></code></pre></div></div><div class=paragraph><p>Ανοίξτε το αρχείο και αντικαταστήστε το <code>/bin/sh</code> στη πρώτη γραμμή με το <code>/compat/linux/bin/sh</code>. Αυτό θα σιγουρέψει ότι το πρόγραμμα εγκατάστασης θα τρέχει με την έκδοση <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> για Linux. Στη συνέχεια, αντικαταστήστε όλες τις εγγραφές <code>Linux)</code> με <code>FreeBSD)</code> χρησιμοποιώντας έναν συντάκτη κειμένου ή με το παρακάτω script στην επόμενη ενότητα. Αυτό θα πει στο πρόγραμμα εγκατάστασης του Mathematica®, το οποίο τρέχει την εντολή <code>uname -s</code> για να διαπιστώσει το λειτουργικό σύστημα, να αντιμετωπίσει το FreeBSD σαν ένα λειτουργικό παρεμφερές με το Linux. Η εκτέλεση του <code>MathInstaller</code> θα ξεκινήσει τώρα την εγκατάσταση του Mathematica®.</p></div></div><div class=sect3><h4 id=_τροποποιώντας_τα_εκτελέσιμα_του_mathematica>17.3.2. Τροποποιώντας τα Εκτελέσιμα του Mathematica®<a class=anchor href=#_τροποποιώντας_τα_εκτελέσιμα_του_mathematica></a></h4><div class=paragraph><p>Τα shell scripts τα οποία δημιουργεί το Mathematica® κατά τη διαδικασία της εγκατάστασης πρέπει να τροποποιηθούν πριν χρησιμοποιηθούν. Αν επιλέξετε το <span class=filename>/usr/local/bin</span> ως τον κατάλογο για τα εκτελέσιμα του Mathematica®, θα βρείτε εκεί συμβολικούς δεσμούς (symlinks) προς τα αρχεία <span class=filename>math</span>, <span class=filename>mathematica</span>, <span class=filename>Mathematica</span>, και <span class=filename>MathKernel</span>. Σε κάθε περίπτωση από τις παραπάνω, αντικαταστήστε τις εγγραφές <code>Linux)</code> με <code>FreeBSD)</code> με κάποιον συντάκτη κειμένου ή με το παρακάτω shell script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
cd /usr/local/bin
for i in math mathematica Mathematica MathKernel
  do sed &#39;s/Linux)/FreeBSD)/g&#39; $i &gt; $i.tmp
  sed &#39;s/\/bin\/sh/\/compat\/linux\/bin\/sh/g&#39; $i.tmp &gt; $i
  rm $i.tmp
  chmod a+x $i
done</pre></div></div></div><div class=sect3><h4 id=_αποκτώντας_κωδικό_για_το_mathematica>17.3.3. Αποκτώντας Κωδικό για το Mathematica®<a class=anchor href=#_αποκτώντας_κωδικό_για_το_mathematica></a></h4><div class=paragraph><p>Όταν εκκινήσετε το Mathematica® για πρώτη φορά, θα ερωτηθείτε για έναν κωδικό. Αν δεν έχετε κάποιον κωδικό σε αυτό το στάδιο, τρέξτε το πρόγραμμα <code>mathinfo</code> που βρίσκεται στον κατάλογο εγκατάστασης για να σας δοθεί το "machine ID". Το "machine ID" είναι εξ' ολοκλήρου βασισμένο στη διεύθυνση MAC της κάρτας δικτύου που έχετε. Αυτό σημαίνει ότι δεν μπορείτε να τρέξετε το Mathematica® σε άλλους υπολογιστές.</p></div><div class=paragraph><p>Όταν εγγραφείτε στη Wolfram, με e-mail, τηλέφωνο ή fax, θα χρειαστεί να δώσετε το "machine ID" και θα σας απαντήσουν με έναν αντίστοιχο κωδικό που θα αποτελείται από μια σειρά αριθμών.</p></div></div><div class=sect3><h4 id=_τρέχοντας_το_mathematica_frontend_μέσω_δικτύου>17.3.4. Τρέχοντας το Mathematica® Frontend μέσω Δικτύου<a class=anchor href=#_τρέχοντας_το_mathematica_frontend_μέσω_δικτύου></a></h4><div class=paragraph><p>Το Mathematica® κάνει χρήση κάποιων ειδικών γραμματοσειρών για να εμφανίσει χαρακτήρες οι οποίοι δεν υπάρχουν στα συνηθισμένα σετ (ολοκληρώματα, αθροίσματα, Ελληνικά γράμματα, κλπ). To πρωτόκολλο X απαιτεί αυτές οι γραμματοσειρές να υπάρχουν στο <em>τοπικό</em> σύστημα. Αυτό σημαίνει ότι θα χρειαστεί να αντιγράψετε τις γραμματοσειρές αυτές από το CDROM ή από από κάποιον άλλον υπολογιστή που έχει το Mathematica®. Συνήθως αυτές οι γραμματοσειρές μπορούν να βρεθούν μέσα στο κατάλογο <span class=filename>/cdrom/Unix/Files/SystemFiles/Fonts</span> του CDROM, ή στον κατάλογο <span class=filename>/usr/local/mathematica/SystemFiles/Fonts</span> στον τοπικό σκληρό δίσκο. Οι πραγματικές γραμματοσειρές βρίσκονται σε υποκαταλόγους όπως <span class=filename>Type1</span> και <span class=filename>X</span>. Υπάρχουν αρκετοί τρόποι να τις χρησιμοποιήσετε, οι οποίοι περιγράφονται στη συνέχεια.</p></div><div class=paragraph><p>Ο πρώτος τρόπος είναι να τις αντιγράψετε μέσα σε έναν υπάρχοντα κατάλογο στο <span class=filename>/usr/X11R6/lib/X11/fonts</span>. Θα χρειαστεί όμως να τροποποιήσετε το αρχείο <span class=filename>fonts.dir</span>, ώστε να προσθέσετε τα ονόματα των γραμματοσειρών μέσα σε αυτό, και να αλλάξετε τον αριθμό των γραμματοσειρών στη πρώτη γραμμή. Εναλλακτικά, είναι συνήθως αρκετό να εκτελέσετε απλώς την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=mkfontdir&amp;sektion=1&amp;format=html">mkfontdir(1)</a> μέσα στον κατάλογο που έχετε αντιγράψει τις γραμματοσειρές.</p></div><div class=paragraph><p>Ο δεύτερος τρόπος είναι να αντιγράψετε τους παραπάνω καταλόγους μέσα στο <span class=filename>/usr/X11R6/lib/X11/fonts</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/X11R6/lib/X11/fonts</span>
<span class=c># mkdir X</span>
<span class=c># mkdir MathType1</span>
<span class=c># cd /cdrom/Unix/Files/SystemFiles/Fonts</span>
<span class=c># cp X/* /usr/X11R6/lib/X11/fonts/X</span>
<span class=c># cp Type1/* /usr/X11R6/lib/X11/fonts/MathType1</span>
<span class=c># cd /usr/X11R6/lib/X11/fonts/X</span>
<span class=c># mkfontdir</span>
<span class=c># cd ../MathType1</span>
<span class=c># mkfontdir</span></code></pre></div></div><div class=paragraph><p>Τώρα προσθέστε τους νέους καταλόγους με τις γραμματοσειρές στο font path:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xset fp+ /usr/X11R6/lib/X11/fonts/X</span>
<span class=c># xset fp+ /usr/X11R6/lib/X11/fonts/MathType1</span>
<span class=c># xset fp rehash</span></code></pre></div></div><div class=paragraph><p>Αν χρησιμοποιείτε το Xorg, μπορείτε να φορτώνετε τις γραμματοσειρές αυτές αυτόματα, προσθέτοντας τους νέους καταλόγους στο αρχείο <span class=filename>xorg.conf</span>.</p></div><div class=paragraph><p>Αν <em>δεν</em> έχετε ήδη έναν κατάλογο με το όνομα <span class=filename>/usr/X11R6/lib/X11/fonts/Type1</span>, μπορείτε να αλλάξετε το όνομα του <span class=filename>MathType1</span> από το παραπάνω παράδειγμα σε <span class=filename>Type1</span>.</p></div></div></div><div class=sect2><h3 id=linuxemu-maple>17.4. Εγκαθιστώντας το Maple™<a class=anchor href=#linuxemu-maple></a></h3><div class=paragraph><p>Το Maple™ είναι μία εμπορική εφαρμογή μαθηματικών παρόμοια με το Mathematica®. Θα πρέπει να αγοράσετε το λογισμικό από το <a href=http://www.maplesoft.com/>http://www.maplesoft.com/</a> και στη συνέχεια να κάνετε αίτηση για μια άδεια χρήσης. Για να εγκαταστήσετε το λογισμικό στο FreeBSD, ακολουθήστε τα παρακάτω απλά βήματα.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Εκτελέστε το <span class=filename>INSTALL</span> shell script από το μέσο εγκατάστασης που έχετε. Επιλέξτε "RedHat" όταν ερωτηθείτε από το πρόγραμμα εγκατάστασης. Ο τυπικός κατάλογος είναι ο <span class=filename>/usr/local/maple</span>.</p></li><li><p>Αν δεν έχετε αγοράσει ακόμη κάποια άδεια για το Maple™, αγοράστε μία από το Maple Waterloo Software (<a href=http://register.maplesoft.com/>http://register.maplesoft.com/</a>) και αντιγράψτε το αρχείο που θα σας δοθεί στο <span class=filename>/usr/local/maple/license/license.dat</span>.</p></li><li><p>Εγκαταστήσετε το FLEXlm license manager εκτελώντας το <span class=filename>INSTALL_LIC</span> shell script το οποία παρέχεται μαζί με το Maple™. Δώστε το βασικό όνομα του υπολογιστή σας το οποίο απαιτείται από τον εξυπηρετητή διαχείρισης των αδειών (license server).</p></li><li><p>Χρησιμοποιήστε το παρακάτω patch στο αρχείο <span class=filename>/usr/local/maple/bin/maple.system.type</span>:</p><div class="literalblock programlisting"><div class=content><pre>   ----- snip ------------------
*** maple.system.type.orig      Sun Jul  8 16:35:33 2001
--- maple.system.type   Sun Jul  8 16:35:51 2001
***************
*** 72,77 ****
--- 72,78 ----
          # the IBM RS/6000 AIX case
          MAPLE_BIN=&#34;bin.IBM_RISC_UNIX&#34;
          ;;
+     &#34;FreeBSD&#34;|\
      &#34;Linux&#34;)
          # the Linux/x86 case
        # We have two Linux implementations, one for Red Hat and
   ----- snip end of patch -----</pre></div></div><div class=paragraph><p>Σημειώστε ότι μετά το <code>"FreeBSD"|\</code> δεν πρέπει να εμφανίζεται άλλο κενό διάστημα.</p></div><div class=paragraph><p>Το patch αυτό οδηγεί το Maple™ να αναγνωρίσει το "FreeBSD" σαν ένα σύστημα Linux. Το <span class=filename>bin/maple</span> shell script καλεί το <span class=filename>bin/maple.system.type</span> shell script, το οποίο με τη σειρά του καλεί την εντολή <code>uname -a</code> προκειμένου να εντοπιστεί το όνομα του λειτουργικού συστήματος. Αναλόγως με το ποιο λειτουργικό βρεθεί, θα χρησιμοποιηθούν και τα αντίστοιχα εκτελέσιμα αρχεία.</p></div></li><li><p>Εκκινήστε τον license server.</p><div class=paragraph><p>Ένας βολικός τρόπος για να εκκινήσετε το <code>lmgrd</code> είναι το ακόλουθο script που βρίσκεται στο <span class=filename>/usr/local/etc/rc.d/lmgrd.sh</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>   ----- snip ------------

#! /bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin
PATH=${PATH}:/usr/local/maple/bin:/usr/local/maple/FLEXlm/UNIX/LINUX
export PATH

LICENSE_FILE=/usr/local/maple/license/license.dat
LOG=/var/log/lmgrd.log

case &#34;$1&#34; in
start)
	lmgrd -c ${LICENSE_FILE} 2&gt;&gt; ${LOG} 1&gt;&amp;2
	echo -n &#34; lmgrd&#34;
	;;
stop)
	lmgrd -c ${LICENSE_FILE} -x lmdown 2&gt;&gt; ${LOG} 1&gt;&amp;2
	;;
*)
	echo &#34;Usage: `basename $0` {start|stop}&#34; 1&gt;&amp;2
	exit 64
	;;
esac

exit 0
   ----- snip ------------</pre></div></div></li><li><p>Δοκιμή του Maple™:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/local/maple/bin
% ./xmaple</code></pre></div></div><div class=paragraph><p>Σε αυτό το σημείο θα πρέπει να είναι όλα έτοιμα και να μην έχετε κανένα πρόβλημα. Μην ξεχάσετε όμως να στείλετε ένα e-mail στη Maplesoft και να τους πείτε ότι θέλετε μια έκδοση που να υποστηρίζεται επίσημα στο FreeBSD.</p></div></li></ol></div><div class=sect3><h4 id=_συνηθισμένα_προβλήματα>17.4.1. Συνηθισμένα Προβλήματα<a class=anchor href=#_συνηθισμένα_προβλήματα></a></h4><div class=ulist><ul><li><p>Ίσως δυσκολευτείτε με την λειτουργία του FLEXlm license manager. Επιπλέον τεκμηρίωση μπορείτε να βρείτε στο <a href=http://www.globetrotter.com/>http://www.globetrotter.com/</a>.</p></li><li><p>Το <code>lmgrd</code> είναι γνωστό ότι θέλει το αρχείο της άδειας να έχει συγκεκριμένη μορφή αλλιώς η εκτέλεση του θα αποτύχει. Ένα σωστό αρχείο άδειας χρήσης πρέπει είναι σε γενικές γραμμές όπως το παρακάτω:</p><div class="literalblock programlisting"><div class=content><pre># =======================================================
# License File for UNIX Installations (&#34;Pointer File&#34;)
# =======================================================
SERVER chillig ANY
#USE_SERVER
VENDOR maplelmg

FEATURE Maple maplelmg 2000.0831 permanent 1 XXXXXXXXXXXX \
         PLATFORMS=i86_r ISSUER=&#34;Waterloo Maple Inc.&#34; \
         ISSUED=11-may-2000 NOTICE=&#34; Technische Universitat Wien&#34; \
         SN=XXXXXXXXX</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ο σειριακός αριθμός και το κλειδί φαίνονται εδώ με 'X'. Το <code>chillig</code> είναι το όνομα του συστήματος.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μπορείτε να τροποποιήσετε το αρχείο της άδειας χρήσης, αρκεί να μην αλλάξετε την γραμμή "FEATURE" (η οποία προστατεύεται από το κλειδί της άδειας).</p></div></li></ul></div></div></div><div class=sect2><h3 id=linuxemu-matlab>17.5. Εγκαθιστώντας το MATLAB®<a class=anchor href=#linuxemu-matlab></a></h3><div class=paragraph><p>Το κείμενο αυτό περιγράφει τη διαδικασία εγκατάστασης της Linux έκδοσης του MATLAB® 6.5 σε ένα σύστημα FreeBSD. Δουλεύει αρκετά καλά, με εξαίρεση το Java Virtual Machine™ (δείτε στο <a href=#matlab-jre>Σύνδεση με το Περιβάλλον του Java™ Runtime Environment</a>).</p></div><div class=paragraph><p>Η Linux έκδοση του MATLAB® μπορεί να αγοραστεί απευθείας από την εταιρεία The MathWorks στο <a href=http://www.mathworks.com>http://www.mathworks.com</a>. Σιγουρευτείτε ότι πήρατε και το αρχείο που περιέχει την άδεια χρήσης ή οδηγίες για το πως να το δημιουργήσετε. Μια και θα επικοινωνήσετε με την εταιρεία, πείτε τους ότι θα θέλατε να υπάρχει επίσης υποστήριξη για το FreeBSD.</p></div><div class=sect3><h4 id=_εγκατάσταση_του_matlab>17.5.1. Εγκατάσταση του MATLAB®<a class=anchor href=#_εγκατάσταση_του_matlab></a></h4><div class=paragraph><p>Για να εγκαταστήσετε το MATLAB®, κάντε τα παρακάτω:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Εισάγετε το CD και προσαρτήστε το στο σύστημα σας. Συνδεθείτε ως χρήστης <code>root</code>, όπως συνιστά το script της εγκατάστασης. Για να ξεκινήσετε το script της εγκατάστασης δώστε την εντολή:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /compat/linux/bin/sh /cdrom/install</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Το πρόγραμμα της εγκατάστασης είναι σε γραφικό περιβάλλον. Αν λαμβάνετε σφάλματα σχετικά με την οθόνη, δώστε την εντολή: <code>setenv HOME ~USER</code>, όπου <em>USER</em> είναι ο χρήστης από όπου δώσατε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>.</p></div></td></tr></tbody></table></div></li><li><p>Όταν ερωτηθείτε για τον κατάλογο του MATLAB®, δώστε: <code>/compat/linux/usr/local/matlab</code>.</p><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Για ευκολότερη διαδικασία εγκατάστασης, ορίστε το παρακάτω: <code>set MATLAB=/compat/linux/usr/local/matlab</code> στη γραμμή εντολών του κελύφους σας.</p></div></td></tr></tbody></table></div></li><li><p>Τροποποιήσετε το αρχείο της άδειας (license file) σύμφωνα με τις οδηγίες που λάβατε με την άδεια του MATLAB®.</p><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Μπορείτε να ετοιμάσετε εκ των προτέρων το αρχείο αυτό και να το αντιγράψετε στο <span class=filename>$MATLAB/license.dat</span>, πριν καν σας πει το πρόγραμμα εγκατάστασης να το τροποποιήσετε.</p></div></td></tr></tbody></table></div></li><li><p>Ολοκλήρωση της Εγκατάστασης</p></li></ol></div><div class=paragraph><p>Σε αυτό το σημείο, η εγκατάσταση του MATLAB® έχει ολοκληρωθεί. Τα επόμενα βήματα χρειάζονται για να μπορέσετε να το δουλέψετε σωστά με το FreeBSD.</p></div></div><div class=sect3><h4 id=_εκκίνηση_του_license_manager>17.5.2. Εκκίνηση του License Manager<a class=anchor href=#_εκκίνηση_του_license_manager></a></h4><div class="olist arabic procedure"><ol class=arabic><li><p>Δημιουργία συμβολικών συνδέσμων για τα scripts του license manager:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s $MATLAB/etc/lmboot /usr/local/etc/lmboot_TMW</span>
<span class=c># ln -s $MATLAB/etc/lmdown /usr/local/etc/lmdown_TMW</span></code></pre></div></div></li><li><p>Δημιουργήστε το αρχείο εκκίνησης <span class=filename>/usr/local/etc/rc.d/flexlm.sh</span>. Το παράδειγμα παρακάτω είναι μια τροποποιημένη έκδοση του <span class=filename>$MATLAB/etc/rc.lm.glnx86</span>. Οι αλλαγές είναι στις τοποθεσίες των αρχείων, και στην εκκίνηση του license manager στο περιβάλλον εξομοίωσης Linux του FreeBSD .</p><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
case &#34;$1&#34; in
  start)
        if [ -f /usr/local/etc/lmboot_TMW ]; then
              /compat/linux/bin/sh /usr/local/etc/lmboot_TMW -u username &amp;&amp; echo &#39;MATLAB_lmgrd&#39;
        fi
        ;;
  stop)
	if [ -f /usr/local/etc/lmdown_TMW ]; then
            /compat/linux/bin/sh /usr/local/etc/lmdown_TMW  &gt; /dev/null 2&gt;&amp;1
	fi
        ;;
  *)
	echo &#34;Usage: $0 {start|stop}&#34;
	exit 1
	;;
esac

exit 0</pre></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Το αρχείο πρέπει να είναι εκτελέσιμο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod +x /usr/local/etc/rc.d/flexlm.sh</span></code></pre></div></div><div class=paragraph><p>Πρέπει επίσης να αντικαταστήσετε το παραπάνω <em>username</em> με ένα υπαρκτό όνομα χρήστη του συστήματος σας (και να μην είναι ο <code>root</code>).</p></div></td></tr></tbody></table></div></li><li><p>Εκκινήστε τον license manager με την εντολή:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/flexlm.sh start</span></code></pre></div></div></li></ol></div></div><div class=sect3><h4 id=matlab-jre>17.5.3. Σύνδεση με το Περιβάλλον του Java™ Runtime Environment<a class=anchor href=#matlab-jre></a></h4><div class=paragraph><p>Αλλάξτε τον σύνδεσμο τουJava™ Runtime Environment (JRE) σε έναν ο οποίος θα δουλεύει στο FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd $MATLAB/sys/java/jre/glnx86/</span>
<span class=c># unlink jre; ln -s ./jre1.1.8 ./jre</span></code></pre></div></div></div><div class=sect3><h4 id=_δημιουργήστε_το_script_εκκίνησης_του_matlab>17.5.4. Δημιουργήστε το Script Εκκίνησης του MATLAB®<a class=anchor href=#_δημιουργήστε_το_script_εκκίνησης_του_matlab></a></h4><div class="olist arabic procedure"><ol class=arabic><li><p>Τοποθετήστε το παρακάτω script στο <span class=filename>/usr/local/bin/matlab</span>:</p><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/compat/linux/bin/sh /compat/linux/usr/local/matlab/bin/matlab &#34;$@&#34;</pre></div></div></li><li><p>Στη συνέχεια δώστε την εντολή <code>chmod +x /usr/local/bin/matlab</code>.</p></li></ol></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Ανάλογα με την έκδοση του <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base/>emulators/linux_base</a>, που έχετε, μπορεί να εμφανιστούν μερικά σφάλματα όταν τρέξετε το script. Για να το αποφύγετε αυτό, τροποποιήστε το αρχείο <span class=filename>/compat/linux/usr/local/matlab/bin/matlab</span>, και αλλάξτε τη γραμμή που λέει:</p></div><div class="literalblock programlisting"><div class=content><pre>if [ `expr &#34;$lscmd&#34; : &#39;.*-&gt;.*&#39;` -ne 0 ]; then</pre></div></div><div class=paragraph><p>(στην έκδοση 13.0.1 βρίσκεται στη γραμμή 410) σε αυτή τη γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>if test -L $newbase; then</pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_δημιουργία_script_τερματισμού_του_matlab>17.5.5. Δημιουργία Script Τερματισμού του MATLAB®<a class=anchor href=#_δημιουργία_script_τερματισμού_του_matlab></a></h4><div class=paragraph><p>Τα επόμενα βήματα χρειάζονται για να λύσετε ένα πρόβλημα που υπάρχει με τον τερματισμό του MATLAB®.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Δημιουργήστε το αρχείο <span class=filename>$MATLAB/toolbox/local/finish.m</span>, και μέσα σε αυτό προσθέστε μόνο τη γραμμή:</p><div class="literalblock programlisting"><div class=content><pre>! $MATLAB/bin/finish.sh</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>To <code>$MATLAB</code> γράψτε το ακριβώς όπως το βλέπετε.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Στον ίδιο κατάλογο, θα βρείτε τα αρχεία <span class=filename>finishsav.m</span> και <span class=filename>finishdlg.m</span>, τα οποία θα σας δίνουν τη δυνατότητα να σώζετε την εργασία σας πριν κλείσετε το πρόγραμμα. Αν πρόκειται να χρησιμοποιήσετε κάποιο από αυτά, προσθέστε του την παραπάνω γραμμή αμέσως μετά την εντολή <code>save</code> .</p></div></td></tr></tbody></table></div></li><li><p>Δημιουργήστε το αρχείο <span class=filename>$MATLAB/bin/finish.sh</span>, το οποίο θα περιέχει τα παρακάτω:</p><div class="literalblock programlisting"><div class=content><pre>#!/compat/linux/bin/sh
(sleep 5; killall -1 matlab_helper) &amp;
exit 0</pre></div></div></li><li><p>Κάντε το αρχείο εκτελέσιμο:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod +x $MATLAB/bin/finish.sh</span></code></pre></div></div></li></ol></div></div><div class=sect3><h4 id=matlab-using>17.5.6. Χρησιμοποιώντας το MATLAB®<a class=anchor href=#matlab-using></a></h4><div class=paragraph><p>Σε αυτό το σημείο θα πρέπει να είστε έτοιμοι να δώσετε την εντολή <code>matlab</code> και να αρχίσετε να χρησιμοποιείτε την εφαρμογή.</p></div></div></div><div class=sect2><h3 id=linuxemu-oracle>17.6. Εγκατάσταση της Oracle®<a class=anchor href=#linuxemu-oracle></a></h3><div class=sect3><h4 id=_εισαγωγή_4>17.6.1. Εισαγωγή<a class=anchor href=#_εισαγωγή_4></a></h4><div class=paragraph><p>Το κείμενο αυτό περιγράφει τη διαδικασία εγκατάστασης των Oracle® 8.0.5 και Oracle® 8.0.5.1 Enterprise Edition για Linux σε ένα σύστημα FreeBSD.</p></div></div><div class=sect3><h4 id=_εγκατάσταση_του_περιβάλλοντος_linux>17.6.2. Εγκατάσταση του Περιβάλλοντος Linux<a class=anchor href=#_εγκατάσταση_του_περιβάλλοντος_linux></a></h4><div class=paragraph><p>Σιγουρευτείτε ότι έχετε εγκαταστήσει τα <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base/>emulators/linux_base</a> και <a class=package href=https://cgit.freebsd.org/ports/tree/devel/linux_devtools/>devel/linux_devtools</a> από τη συλλογή των Ports. Αν αντιμετωπίζετε δυσκολίες με τα παραπάνω, ίσως χρειαστεί να τα εγκαταστήσετε από πακέτα ή από παλιότερες εκδόσεις της συλλογής των Ports.</p></div><div class=paragraph><p>Αν θέλετε να τρέξετε τον intelligent agent, θα χρειαστεί να εγκαταστήσετε και το πακέτο Red Hat Tcl: <span class=filename>tcl-8.0.3-20.i386.rpm</span>. Η εντολή για την εγκατάσταση μέσω του επίσημου RPM port (<a class=package href=https://cgit.freebsd.org/ports/tree/archivers/rpm/>archivers/rpm</a>) είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rpm -i --ignoreos --root /compat/linux --dbpath /var/lib/rpm package</span></code></pre></div></div><div class=paragraph><p>Η εγκατάσταση του <em>package</em> θα πρέπει να γίνει ομαλά και χωρίς προβλήματα.</p></div></div><div class=sect3><h4 id=_ρυθμίζοντας_το_περιβάλλον_για_την_oracle>17.6.3. Ρυθμίζοντας το Περιβάλλον για την Oracle®<a class=anchor href=#_ρυθμίζοντας_το_περιβάλλον_για_την_oracle></a></h4><div class=paragraph><p>Πριν την εγκατάσταση της Oracle®, θα πρέπει να ρυθμίσετε σωστά το περιβάλλον του συστήματός σας. Το παρακάτω κείμενο περιγράφει τι <em>ακριβώς</em> πρέπει να κάνετε για να εκτελέσετε την Oracle® για Linux στο FreeBSD, και δεν περιγράφει ότι υπάρχει ήδη στον οδηγό εγκατάστασης της Oracle®.</p></div><div class=sect4><h5 id=linuxemu-kernel-tuning>17.6.3.1. Ρύθμιση του Πυρήνα<a class=anchor href=#linuxemu-kernel-tuning></a></h5><div class=paragraph><p>Όπως περιγράφει ο οδηγός εγκατάστασης της Oracle®, θα πρέπει να ορίσετε τις τιμές της shared memory στο μέγιστο. Μην χρησιμοποιήσετε το <code>SHMMAX</code> στο FreeBSD. Το <code>SHMMAX</code> υπολογίζεται απλώς από το <code>SHMMAXPGS</code> και το <code>PGSIZE</code>. Επομένως καθορίστε το <code>SHMMAXPGS</code>. Όλες οι άλλες επιλογές μπορούν να οριστούν όπως περιγράφεται στον οδηγό. Για παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre>options SHMMAXPGS=10000
options SHMMNI=100
options SHMSEG=10
options SEMMNS=200
options SEMMNI=70
options SEMMSL=61</pre></div></div><div class=paragraph><p>Ορίστε τις τιμές των επιλογών έτσι ώστε να ταιριάζουν στη χρήση της Oracle® που θέλετε να κάνετε.</p></div><div class=paragraph><p>Επίσης, επιβεβαιώστε ότι έχετε ενεργοποιήσει τις παρακάτω επιλογές στις ρυθμίσεις του πυρήνα:</p></div><div class="literalblock programlisting"><div class=content><pre>options SYSVSHM #SysV shared memory
options SYSVSEM #SysV semaphores
options SYSVMSG #SysV interprocess communication</pre></div></div></div><div class=sect4><h5 id=linuxemu-oracle-account>17.6.3.2. Ο Χρήστης Oracle®<a class=anchor href=#linuxemu-oracle-account></a></h5><div class=paragraph><p>Δημιουργήστε ένα χρήστη συστήματος με όνομα <code>oracle</code>, με τον ίδιο τρόπο που θα δημιουργούσατε και οποιονδήποτε άλλον χρήστη. Το μόνο ιδιαίτερο χαρακτηριστικό του χρήστη <code>oracle</code> είναι ότι χρειάζεται να του δώσετε ένα κέλυφος Linux. Προσθέστε το <code>/compat/linux/bin/bash</code> στο <span class=filename>/etc/shells</span> και ορίστε το κέλυφος του χρήστη <code>oracle</code> σε <span class=filename>/compat/linux/bin/bash</span>.</p></div></div><div class=sect4><h5 id=linuxemu-environment>17.6.3.3. Το Περιβάλλον<a class=anchor href=#linuxemu-environment></a></h5><div class=paragraph><p>Εκτός των συνηθισμένων μεταβλητών της Oracle®, όπως οι <code>ORACLE_HOME</code> και <code>ORACLE_SID</code> θα πρέπει να ορίσετε και τις ακόλουθες μεταβλητές περιβάλλοντος:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Μεταβλητή</th><th class="tableblock halign-left valign-top">Τιμή</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>LD_LIBRARY_PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>$ORACLE_HOME/lib</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>CLASSPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>$ORACLE_HOME/jdbc/lib/classes111.zip</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>/compat/linux/bin /compat/linux/sbin /compat/linux/usr/bin /compat/linux/usr/sbin /bin /sbin /usr/bin /usr/sbin /usr/local/bin $ORACLE_HOME/bin</code></p></td></tr></tbody></table><div class=paragraph><p>Σας συνιστούμε να ορίσετε όλες τις μεταβλητές περιβάλλοντος στο αρχείο <span class=filename>.profile</span>. Ένα ολοκληρωμένο παράδειγμα είναι το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ORACLE_BASE=/oracle; export ORACLE_BASE
ORACLE_HOME=/oracle; export ORACLE_HOME
LD_LIBRARY_PATH=$ORACLE_HOME/lib
export LD_LIBRARY_PATH
ORACLE_SID=ORCL; export ORACLE_SID
ORACLE_TERM=386x; export ORACLE_TERM
CLASSPATH=$ORACLE_HOME/jdbc/lib/classes111.zip
export CLASSPATH
PATH=/compat/linux/bin:/compat/linux/sbin:/compat/linux/usr/bin
PATH=$PATH:/compat/linux/usr/sbin:/bin:/sbin:/usr/bin:/usr/sbin
PATH=$PATH:/usr/local/bin:$ORACLE_HOME/bin
export PATH</pre></div></div></div></div><div class=sect3><h4 id=_εγκατάσταση_της_oracle>17.6.4. Εγκατάσταση της Oracle®<a class=anchor href=#_εγκατάσταση_της_oracle></a></h4><div class=paragraph><p>Λόγω μια μικρής έλλειψης στον εξομοιωτή του Linux, θα χρειαστεί να δημιουργήσετε έναν κατάλογο με το όνομα <span class=filename>.oracle</span> μέσα στο <span class=filename>/var/tmp</span>, πριν ξεκινήσετε το πρόγραμμα εγκατάστασης. Ο κατάλογος αυτός θα πρέπει να ανήκει στον χρήστη <code>oracle</code>. Θα πρέπει τώρα να πραγματοποιήσετε την εγκατάσταση της Oracle® δίχως κανένα πρόβλημα. Αν αντιμετωπίζετε όμως ακόμη προβλήματα, ελέγξτε την έκδοση της Oracle® που έχετε ή/και τις ρυθμίσεις σας! Αφότου έχετε πραγματοποιήσει την εγκατάσταση της Oracle®, εφαρμόστε τα patches που περιγράφονται στις δύο παρακάτω ενότητες.</p></div><div class=paragraph><p>Ένα συχνό πρόβλημα είναι ότι δεν γίνεται σωστή εγκατάσταση του προσαρμογέα του πρωτοκόλλου TCP. Αυτό έχει ως αποτέλεσμα να μην μπορείτε να ξεκινήσετε τους TCP listeners. Οι ακόλουθες οδηγίες θα σας βοηθήσουν να λύσετε αυτό το πρόβλημα.:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd $ORACLE_HOME/network/lib</span>
<span class=c># make -f ins_network.mk ntcontab.o</span>
<span class=c># cd $ORACLE_HOME/lib</span>
<span class=c># ar r libnetwork.a ntcontab.o</span>
<span class=c># cd $ORACLE_HOME/network/lib</span>
<span class=c># make -f ins_network.mk install</span></code></pre></div></div><div class=paragraph><p>Μη ξεχάσετε να τρέξετε ξανά το <span class=filename>root.sh</span></p></div><div class=sect4><h5 id=linuxemu-patch-root>17.6.4.1. Διόρθωση του root.sh<a class=anchor href=#linuxemu-patch-root></a></h5><div class=paragraph><p>Όταν εγκαθιστάτε την Oracle®, κάποιες ενέργειες, οι οποίες χρειάζονται να γίνουν ως <code>root</code>, καταγράφονται σε ένα shell script που λέγεται <span class=filename>root.sh</span>. Το script αυτό δημιουργείται στον κατάλογο <span class=filename>orainst</span>. Εφαρμόστε το παρακάτω patch στο <span class=filename>root.sh</span>, για να μπορέσει να βρει και να χρησιμοποιήσει το <code>chown</code>. Εναλλακτικά, τρέξτε το script μέσα από ένα κέλυφος Linux.</p></div><div class="literalblock programlisting"><div class=content><pre>*** orainst/root.sh.orig Tue Oct 6 21:57:33 1998
--- orainst/root.sh Mon Dec 28 15:58:53 1998
***************
*** 31,37 ****
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/bin/chown
#
# Define variables to be used in this script
--- 31,37 ----
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/usr/sbin/chown
#
# Define variables to be used in this script</pre></div></div><div class=paragraph><p>Όταν δεν κάνετε χρήση του CD για την εγκατάσταση, μπορείτε να περάσετε το patch για το <span class=filename>root.sh</span>, στην πηγή εγκατάστασης. To αρχείο ονομάζεται <span class=filename>rthd.sh</span> και βρίσκεται στον κατάλογο <span class=filename>orainst</span>.</p></div></div><div class=sect4><h5 id=linuxemu-patch-tcl>17.6.4.2. Διόρθωση του genclntsh<a class=anchor href=#linuxemu-patch-tcl></a></h5><div class=paragraph><p>To script <code>genclntsh</code> χρησιμοποιείται για να δημιουργήσει μια shared client library. Τρέξτε το παρακάτω patch για να σβήσετε το καθορισμένο <code>PATH</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>*** bin/genclntsh.orig Wed Sep 30 07:37:19 1998
--- bin/genclntsh Tue Dec 22 15:36:49 1998
***************
*** 32,38 ****
#
# Explicit path to ensure that we&#39;re using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst
--- 32,38 ----
#
# Explicit path to ensure that we&#39;re using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! #PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst</pre></div></div></div></div><div class=sect3><h4 id=_εκτέλεση_της_oracle>17.6.5. Εκτέλεση της Oracle®<a class=anchor href=#_εκτέλεση_της_oracle></a></h4><div class=paragraph><p>Αφού έχετε ακολουθήσει αυτές τις οδηγίες, θα πρέπει να μπορείτε να εκτελέσετε την Oracle® σαν να βρισκόσασταν σε ένα σύστημα Linux.</p></div></div></div><div class=sect2><h3 id=linuxemu-advanced>17.7. Προχωρημένα Θέματα<a class=anchor href=#linuxemu-advanced></a></h3><div class=paragraph><p>Αν έχετε την απορία πως λειτουργεί η συμβατότητα με εφαρμογές Linux, τότε θα πρέπει να διαβάσετε τη παρακάτω ενότητα. Τα περισσότερα από όσα έχουν γραφτεί είναι βασισμένα στην <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>ηλεκτρονική λίστα γενικών συζητήσεων του FreeBSD</a> και έχουν γραφτεί από τον Terry Lambert <a href=mailto:tlambert@primenet.com>tlambert@primenet.com</a> (Message ID: <code>&lt;<a href=mailto:199906020108.SAA07001@usr09.primenet.com>199906020108.SAA07001@usr09.primenet.com</a>></code>).</p></div><div class=sect3><h4 id=_πως_λειτουργεί>17.7.1. Πως Λειτουργεί;<a class=anchor href=#_πως_λειτουργεί></a></h4><div class=paragraph><p>Το FreeBSD περιέχει ένα επίπεδο αφαίρεσης (abstraction) που ονομάζεται "execution class loader". Αυτό βασίζεται στο <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a>.</p></div><div class=paragraph><p>Αυτό που συμβαίνει είναι ότι το FreeBSD έχει μια λίστα φορτωτών (loaders), αντί για ένα που να καταφεύγει σε περίπτωση αποτυχίας στο <code>#!</code> για να τρέξει κάποιο shell interpreter ή shell script.</p></div><div class=paragraph><p>Ιστορικά, ο μόνος φορτωτής στη πλατφόρμα του UNIX® έλεγχε τον μαγικό αριθμό (γενικά τα πρώτα 4 ή 8 bytes του αρχείου) για να δει αν είναι κάποιο εκτελέσιμο / εφαρμογή γνωστό στο σύστημα, και στην περίπτωση αυτή να καλέσει τον αντίστοιχο φορτωτή.</p></div><div class=paragraph><p>Αν το αρχείο δεν ήταν εκτελέσιμο με βάση τον τύπο του συστήματος, η κλήση στο <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> επέστρεφε κάποιο σφάλμα, και το shell προσπαθούσε να εκτελέσει το αρχείο σαν shell script.</p></div><div class=paragraph><p>Η γενική ιδέα ήταν "αν δεν είναι εκτελέσιμο, προσπάθησε να το τρέξεις ως shell script με βάση το τρέχον shell ".</p></div><div class=paragraph><p>Αργότερα, βρέθηκε ένας έξυπνος τρόπος ώστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> να ελέγχει τους πρώτους δύο χαρακτήρες, και αν ήταν <code>:\n</code>, τότε καλούσε το shell <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> (πιστεύουμε πως η λύση αυτή βρέθηκε αρχικά από τη SCO).</p></div><div class=paragraph><p>Αυτό που κάνει τώρα το FreeBSD είναι να διατρέχει τη λίστα με όλους τους φορτωτές, με ένα γενικό φορτωτή <code>#!</code> ο οποίος αναγνωρίζει ως διερμηνέα (interpreter) τους χαρακτήρες από το επόμενο κενό μετά το <code>!</code> και μέχρι το τέλος, ενώ αν δεν αναγνωριστεί κάποιος, χρησιμοποιείται ως έσχατη λύση το <span class=filename>/bin/sh</span>.</p></div><div class=paragraph><p>Για την υποστήριξη του Linux ABI, το FreeBSD βλέπει τον μαγικό αριθμό του ELF binary (δε αναγνωρίζει τη διαφορά ανάμεσα σε FreeBSD, Solaris™, Linux, ή κάποιο άλλο λειτουργικό σύστημα το οποίο χρησιμοποιεί αρχεία τύπου ELF).</p></div><div class=paragraph><p>Ο φορτωτής ELF κοιτάει για ένα ειδικό <em>brand</em>, το οποίο είναι μια ενότητα σχολίων μέσα στο ELF image, και το οποίο δεν υπάρχει σε ELF binaries για SVR4/Solaris™</p></div><div class=paragraph><p>Για να λειτουργήσουν τα εκτελέσιμα του Linux, θα πρέπει να γίνουν <em>branded</em> (μαρκαριστούν) ως <code>Linux</code> μέσω της <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brandelf -t Linux file</span></code></pre></div></div><div class=paragraph><p>Όταν γίνει αυτό, ο φορτωτής ELF θα βλέπει το <code>Linux</code> brand πάνω στο αρχείο.</p></div><div class=paragraph><p>Όταν ο φορτωτής ELF δει το <code>Linux</code> brand, θα αντικαταστήσει έναν δείκτη μέσα στη δομή <code>proc</code>. Όλες οι κλήσεις του συστήματος ταξινομούνται μέσα από αυτόν τον δείκτη (σε ένα παραδοσιακό σύστημα UNIX®, ο δείκτης θα ήταν ο πίνακας <code>sysent[]</code>, που περιέχει τις κλήσεις του συστήματος (system calls)). Επιπλέον, η διεργασία σημειώνεται για ειδική μεταχείριση του trap vector και άλλες (μικρές) διορθώσεις, τις οποίες χειρίζεται το άρθρωμα πυρήνα της συμβατότητας Linux.</p></div><div class=paragraph><p>Το system call vector του Linux περιέχει, μεταξύ άλλων, μια λίστα με τα δεδομένα του <code>sysent[]</code> των οποίων οι διευθύνσεις βρίσκονται μέσα στο άρθρωμα του πυρήνα.</p></div><div class=paragraph><p>Όταν γίνεται μια κλήση συστήματος από μια εφαρμογή Linux, ο κώδικας (trap code) τροποποιεί τον δείκτη της μέσω της δομής που έχει εγγραφεί στο <code>proc</code>, και αλλάζει την διεύθυνση ώστε να δείχνει στο σημείο εισόδου της συνάρτησης του Linux, και όχι του FreeBSD.</p></div><div class=paragraph><p>Επίσης, το σύστημα συμβατότητας με Linux μπορεί και προσαρμόζει δυναμικά τις τοποθεσίες αναζήτησης. Ουσιαστικά αυτό κάνει και η επιλογή <code>union</code> κατά την προσάρτηση ενός συστήματος αρχείων (<em>δεν</em> εννοούμε εδώ το σύστημα αρχείων <code>unionfs</code>!). Αρχικά, γίνεται απόπειρα να βρεθεί το αρχείο στον κατάλογο <span class=filename>/compat/linux/original-path</span>, <em>και μόνο</em> αν αυτό αποτύχει, θα γίνει αναζήτηση στον κατάλογο <span class=filename>/original-path</span>. Με τον τρόπο αυτό σιγουρεύουμε ότι τα εκτελέσιμα που χρειάζονται άλλα εκτελέσιμα θα τρέξουν (για παράδειγμα, το σύνολο εργαλείων του Linux μπορεί να εκτελεστεί μέσω της υποστήριξης του Linux ABI). Επίσης σημαίνει ότι τα εκτελέσιμα του Linux μπορούν να φορτώσουν και να εκτελέσουν αρχεία του FreeBSD αν δεν μπορούν να εντοπίσουν τα αντίστοιχα αρχεία στο Linux. Μπορείτε επίσης να τοποθετήσετε μια εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> μέσα στο <span class=filename>/compat/linux</span> προκειμένου τα αρχεία του Linux να μη μπορούν να αναγνωρίσουν ότι δεν χρησιμοποιούνται πραγματικά σε Linux.</p></div><div class=paragraph><p>Ουσιαστικά, υπάρχει ένας πυρήνας Linux μέσα στον πυρήνα του FreeBSD. Οι διάφορες λειτουργίες οι οποίες υλοποιούν όλες τις υπηρεσίες που παρέχονται από τον πυρήνα είναι ίδιες τόσο στον πίνακα κλήσεων συστήματος του FreeBSD όσο και στον αντίστοιχο του Linux: λειτουργίες του συστήματος αρχείων, εικονική μνήμη, διαχείριση σημάτων, System V IPC κλπ. Η μόνη διαφορά είναι ότι το εκτελέσιμα του FreeBSD κάνουν χρήση των συναρτήσεων <em>glue</em> του FreeBSD, ενώ τα εκτελέσιμα του Linux, κάνουν χρήση των συναρτήσεων <em>glue</em> του Linux (πολλά από τα παλιά λειτουργικά είχαν τις δικές τους συναρτήσεις <em>glue</em>: οι διευθύνσεις των συναρτήσεων βρίσκονταν στο στατικό πίνακα <code>sysent[]</code>, αντί να διευκρινίζονται μέσω ενός δυναμικού δείκτη στη δομή <code>proc</code> της διεργασίας που πραγματοποιεί την κλήση).</p></div><div class=paragraph><p>Ποιο είναι όμως το εγγενές FreeBSD ABI; Δεν έχει και πολύ σημασία. Η μόνη βασική διαφορά είναι (κάτι το οποίο μπορεί εύκολα να αλλάξει σε μελλοντικές εκδόσεις, και πολύ πιθανόν να αλλάξει) ότι οι συναρτήσεις <em>glue</em> του FreeBSD είναι στατικά συνδεδεμένες στο πυρήνα, ενώ οι αντίστοιχες του Linux μπορούν είτε να είναι συνδεδεμένες στατικά, είτε να είναι προσβάσιμες μέσω ενός αρθρώματος πυρήνα.</p></div><div class=paragraph><p>Είναι αυτό όμως πραγματική εξομοίωση; Όχι. Είναι μια υλοποίηση του ABI, όχι εξομοίωση. Δεν υπάρχει καμία εξομοίωση (ή προσομοίωση, για να προλάβουμε την επόμενη σας ερώτηση).</p></div><div class=paragraph><p>Τότε γιατί μερικές φορές μιλάμε για "εξομοίωση Linux"; Για να δυσκολευτεί η προώθηση του FreeBSD! Η αρχική υλοποίηση έγινε την εποχή όπου δεν υπήρχε άλλη λέξη που να μπορούσε να περιγράψει το τι ακριβώς γινόταν. Το να λέγαμε ότι το FreeBSD έτρεχε εκτελέσιμα Linux δεν θα ήταν αλήθεια, μια και χρειαζόταν να ενσωματωθεί κάποιος κώδικας στον πυρήνα, ή να φορτωθεί κάποιο άρθρωμα. Χρειαζόταν κάποια λέξη που να περιγράφει τι φορτωνόταν-έτσι προέκυψε ο "εξομοιωτής Linux".</p></div><div class=paragraph><p>path: "/books/handbook/partiii/"
---
:leveloffset: +1</p></div></div></div></div></div><h1 id=config-tuning class=sect0>Part III: Ρύθμιση και Βελτιστοποίηση<a class=anchor href=#config-tuning></a></h1><div class=sect1><h2 id=config-synopsis>Chapter 18. Σύνοψη<a class=anchor href=#config-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Ένα από τα σημαντικά χαρακτηριστικά του FreeBSD είναι η δυνατότητα ρύθμισης του συστήματος. Με τις σωστές ρυθμίσεις συστήματος είναι εύκολο να αποφευχθούν πολλά προβλήματα κατά τη διάρκεια μελλοντικών αναβαθμίσεων. Το κεφάλαιο αυτό θα εξηγήσει μεγάλο μέρος της διαδικασίας ρύθμισης του FreeBSD, συμπεριλαμβανομένων και κάποιων παραμέτρων που μπορούν να ρυθμιστούν για την βελτιστοποίηση της απόδοσης του συστήματος.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να δουλέψετε αποδοτικά με συστήματα αρχείων και κατατμήσεις swap.</p></li><li><p>Τα βασικά των συστημάτων ρύθμισης και εκκίνησης <span class=filename>rc.conf</span> και <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Πως να ρυθμίσετε και να δοκιμάσετε μια κάρτα δικτύου.</p></li><li><p>Πως να ρυθμίσετε virtual hosts στις δικτυακές σας συσκευές.</p></li><li><p>Πως να χρησιμοποιήσετε τα διάφορα αρχεία ρυθμίσεων στον κατάλογο <span class=filename>/etc</span>.</p></li><li><p>Πως να βελτιστοποιήσετε το FreeBSD χρησιμοποιώντας μεταβλητές <code>sysctl</code>.</p></li><li><p>Πως να βελτιστοποιήσετε την απόδοση του δίσκου και να αλλάξετε τους περιορισμούς του πυρήνα.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε βασικές έννοιες του UNIX® και του FreeBSD (<a href=./#basics>Βασικές Έννοιες στο UNIX®</a>).</p></li><li><p>Να είστε εξοικειωμένοι με τα βασικά της ρύθμισης και της μεταγλώττισης του πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=configtuning-initial>Chapter 19. Αρχική Ρύθμιση<a class=anchor href=#configtuning-initial></a></h2><div class=sectionbody><div class=sect2><h3 id=_διάταξη_κατατμήσεων>19.1. Διάταξη Κατατμήσεων<a class=anchor href=#_διάταξη_κατατμήσεων></a></h3><div class=sect3><h4 id=_βασικές_κατατμήσεις>19.1.1. Βασικές Κατατμήσεις<a class=anchor href=#_βασικές_κατατμήσεις></a></h4><div class=paragraph><p>Όταν δημιουργείτε συστήματα αρχείων με το <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a>, θυμηθείτε ότι οι σκληροί δίσκοι μεταφέρουν δεδομένα γρηγορότερα απο τα εξωτερικά μέροι τους στα εσωτερικά. Έτσι μικρότερα και περισσότερο προσβάσιμα συστήματα αρχείων πρέπει να είναι πλησιέστερα στο εξωτερικό του δίσκου, ενώ μεγαλύτερες κατατμήσεις όπως το <span class=filename>/usr</span> πρέπει να τοποθετούνται πιο κοντά στο εσωτερικό του δίσκου. Είναι καλή ιδέα να δημιουργείτε κατατμήσεις με παρόμοια σειρά με αυτήν: root, swap, <span class=filename>/var</span>, <span class=filename>/usr</span>.</p></div><div class=paragraph><p>Το μέγεθος του <span class=filename>/var</span> αντανακλά την επιδιωκούμενη χρήση του μηχανήματος. Το <span class=filename>/var</span> χρησιμοποιείτε για την αποθήκευση των γραμματοκιβωτίων, των αρχείων καταγραφής και του spooler του εκτυπωτή. Τα γραμματοκιβώτια και τα αρχεία καταγραφής μπορούν να μεγαλώσουν σε απροσδόκητα μεγέθη ανάλογα με τον αριθμό των χρηστών του συστήματος και το χρονικό διάστημα που κρατούνται τα αρχεία καταγραφής. Σπάνια χρειάζεται το <span class=filename>/var/tmp</span> να έχει πάνω από ένα gigabyte χώρο, αλλά καλό είναι να έχετε κατά νου ότι πρέπει να είναι αρκετά μεγάλο για να κρατάει τα πακέτα που θέλετε να εγκαταστήσετε.</p></div><div class=paragraph><p>Η κατάτμηση <span class=filename>/usr</span> περιέχει τα περισσότερα αρχεία που απαιτούνται για την υποστήριξη του συστήματος, τη συλλογή των <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a> (προτείνεται) και τον πηγαίο κώδικα (προαιρετικό). Και τα δύο αυτά είναι προαιρετικά κατα την εγκατάσταση. Τουλάχιστον 2 gigabytes προτείνονται για αυτή την κατάτμηση.</p></div><div class=paragraph><p>Όταν επιλέγετε μέγεθος για τις κατατμήσεις, να έχετε υπόψιν σας τις απαιτήσεις σε χώρο. Μπορεί να είναι λίγο πρόβλημα το να μείνετε χωρίς χώρο σε μια κατάτμηση ενώ χρησιμοποιείτε ελάχιστα μια άλλη.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μερικές φορές η επιλογή <code>Auto-defaults</code> του κατατμητή του <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> μπορεί να επιλέξει πολύ μικρό μέγεθος για τις κατατμήσεις <span class=filename>/var</span> και <span class=filename>/</span>. Προσπαθείστε να επιλέξετε έξυπνα και γενναιόδωρα μεγέθη για τις κατατμήσεις σας.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=swap-design>19.1.2. Swap Κατάτμηση<a class=anchor href=#swap-design></a></h4><div class=paragraph><p>Ένας εμπειρικός κανόνας για να επιλέξετε μέγεθος για την κατάτμηση swap είναι: πρέπει να είναι περίπου διπλή απο το μέγεθος της μνήμης (RAM) του συστήματος. Για παράδειγμα, αν το μηχάνημα έχει 128 megabytes μνήμης, η κατάτμηση swap πρέπει να είναι 256 megabytes. Συστήματα με λιγότερη μνήμη μπορούν να αποδίδουν καλύτερα με περισσότερο swap. Λιγότερο απο 256 megabytes swap δεν προτείνεται και πρέπει να εξεταστεί η επέκταση της μνήμης. Οι αλγόριθμοι VM paging του πυρήνα είναι έτσι φτιαγμένοι ώστε να αποδίδουν καλύτερα όταν η κατάτμηση swap είναι τουλάχιστον δύο φορές το μέγεθος της κεντρικής μνήμης. Αν ρυθμίσετε πολύ μικρό swap, μπορεί να έχουν μειωμένη απόδοση οι αλγόριθμοι σάρωσης σελίδων του υποσυστήματος VM και μπορεί αργότερα να δημιουργηθούν προβλήματα αν προστεθεί περισσότερη φυσική μνήμη.</p></div><div class=paragraph><p>Σε μεγαλύτερα συστήματα με πολλαπλούς SCSI δίσκους (ή πολλαπλούς IDE δίσκους σε διαφορετικούς ελεγκτές), είναι προτιμότερο το swap να είναι ρυθμισμένο σε κάθε δίσκο (μέχρι τέσσερις δίσκους). Οι ξεχωριστές κατατμήσεις swap καλό είναι να έχουν περίπου το ίδιο μέγεθος. Ο πυρήνας μπορεί να χειριστεί αυθαίρετα μεγέθη swap, αλλά οι εσωτερικές δομές δεδομένων ρυθμίζονται με βάση το μέγεθος της μεγαλύτερης κατάτμησης swap. Κρατώντας την κατάτμηση swap σχεδόν στο ίδιο μέγεθος θα επιτρέψει στον πυρήνα να βελτιστοποιήσει την χρήση του swap, μοιράζοντας πιο καλά το φόρτο σε κάθε δίσκο. Δεν πειράζει να έχετε μεγάλο μέγεθος swap, ακόμα και αν δε χρησιμοποιείται αρκετά. Μπορεί να είναι ευκολότερη η ανάκαμψη απο ένα εκτός ελέγχου πρόγραμμα προτού χρειαστεί να επανεκκινήσετε το σύστημα.</p></div></div><div class=sect3><h4 id=_γιατί_να_φτιάξετε_κατατμήσεις>19.1.3. Γιατί να φτιάξετε κατατμήσεις;<a class=anchor href=#_γιατί_να_φτιάξετε_κατατμήσεις></a></h4><div class=paragraph><p>Αρκετοί χρήστες νομίζουν ότι μία μεγάλη κατάτμηση θα είναι εντάξει, αλλά υπάρχουν αρκετοί λόγοι γιατί αυτό είναι κακή ιδέα. Καταρχήν, κάθε κατάτμηση έχει διαφορετικά λειτουργικά χαρακτηριστικά, οπότε ξεχωρίζοντας τις κατατμήσεις επιτρέπουμε στο σύστημα αρχείων να εναρμονίζεται ανάλογα. Για παράδειγμα, οι root και <span class=filename>/usr</span> κατατμήσεις είναι κυρίως για ανάγνωση, χωρίς πολλές εγγραφές. Αντίθετα, γίνονται πολλές αναγνώσεις και εγγραφές στις <span class=filename>/var</span> και <span class=filename>/var/tmp</span>.</p></div><div class=paragraph><p>Κάνοντας σωστή κατάτμηση σε ένα σύστημα, ο κατακερματισμός που συμβαίνει σε μικρότερες και περισσότερο εγγράψιμες κατατμήσεις δεν θα διαρρεύσει στις κατατμήσεις που διαβάζονται πιο συχνά από ότι γράφονται. Κρατώντας τις περισσότερο εγγράψιμες κατατμήσεις πιο κοντά στην άκρη του δίσκου, θα αυξηθεί η I/O απόδοση στις κατατμήσεις όπου και χρειάζεται πιο συχνά. Τώρα ενώ η απόδοση I/O χρειάζεται στις μεγαλύτερες κατατμήσεις, αλλάζοντας αυτές πιο κοντά στην άκρη του δίσκου δεν θα οδηγήσει σε σημαντική αύξηση της απόδοσης όσο το να μετακινήσετε την <span class=filename>/var</span> στην άκρη. Τέλος, υπάρχει και θέμα ασφάλειας. Μία μικρή, προσεγμένη root κατάτμηση η οποία είναι διαβάζεται πιο συχνά από ότι γράφεται έχει μεγαλύτερη πιθανότητα να επιζήσει ενός άσχημου χτυπήματος.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-core-configuration>Chapter 20. Κύρια Ρύθμιση<a class=anchor href=#configtuning-core-configuration></a></h2><div class=sectionbody><div class=paragraph><p>Η κύρια τοποθεσία των πληροφοριών για την ρύθμιση του συστήματος βρίσκεται μέσα στο <span class=filename>/etc/rc.conf</span>. Αυτό το αρχείο περιέχει ένα ευρύ φάσμα ρυθμίσεων, κυρίως χρησιμοποιούμενες στην εκκίνηση του συστήματος για την ρύθμιση του συστήματος. Το όνομα του απευθείας συνεπάγεται αυτό; είναι ρυθμίσεις για τα αρχεία <span class=filename>rc*</span>.</p></div><div class=paragraph><p>Ένας διαχειριστής πρέπει να δημιουργήσει εγγραφές μέσα στο αρχείο <span class=filename>rc.conf</span> ώστε να αντικαταστήσει τις προεπιλεγμένες ρυθμίσεις απο το αρχείο <span class=filename>/etc/defaults/rc.conf</span>. Το αρχείο προεπιλογών δεν πρέπει να αντιγραφεί αυτολεξεί στο <span class=filename>/etc</span> - αυτό περιέχει προεπιλεγμένες τιμές, όχι παραδείγματα. Όλες οι αλλαγές που αφορούν το σύστημα πρέπει να γίνουν στο αρχείο <span class=filename>rc.conf</span> αποκλειστικά.</p></div><div class=paragraph><p>Ένας αριθμός στρατηγικών μπορεί να εφαρμοστεί σε ένα σύνολο εφαρμογών για να ξεχωρίσουμε ρυθμίσεις του ευρύ συνόλου απο τις ρυθμίσεις επικεντρωμένες για ένα σύστημα για να κρατήσουμε τον φόρτο διαχείρισης χαμηλά. Η προτεινόμενη προσέγγιση είναι να τοποθετούμε τις ρυθμίσεις ευρύ συνόλου σε ένα διαφορετικό αρχείο, όπως το <span class=filename>/etc/rc.conf.site</span>, και τότε να συμπεριλάβουμε το αρχείο αυτό στο <span class=filename>/etc/rc.conf</span>, το οποίο θα περιέχει πληροφορίες επικεντρωμένες για ένα σύστημα.</p></div><div class=paragraph><p>Μιάς και το <span class=filename>rc.conf</span> διαβάζεται απο το <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> είναι εύκολο να το επιτύχουμε αυτό. Για παράδειγμα:</p></div><div class=ulist><ul><li><p>rc.conf:</p><div class="literalblock programlisting"><div class=content><pre>	. /etc/rc.conf.site
	hostname=&#34;node15.example.com&#34;
	network_interfaces=&#34;fxp0 lo0&#34;
	ifconfig_fxp0=&#34;inet 10.1.1.1&#34;</pre></div></div></li><li><p>rc.conf.site:</p><div class="literalblock programlisting"><div class=content><pre>	defaultrouter=&#34;10.1.1.254&#34;
	saver=&#34;daemon&#34;
	blanktime=&#34;100&#34;</pre></div></div></li></ul></div><div class=paragraph><p>Το αρχείο <span class=filename>rc.conf.site</span> μπορεί έπειτα να διανεμηθεί σε κάθε σύστημα χρησιμοποιώντας το <code>rsync</code> ή κάποιο παρόμοιο πρόγραμμα, ενώ το αρχείο <span class=filename>rc.conf</span> παραμένει μοναδικό.</p></div><div class=paragraph><p>Αναβαθμίζοντας το σύστημα χρησιμοποιώντας <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> ή <code>make world</code> δεν θα αντικαταστήσει το αρχείο <span class=filename>rc.conf</span>, έτσι οι ρυθμίσεις δεν θα χαθούν.</p></div></div></div><div class=sect1><h2 id=configtuning-appconfig>Chapter 21. Ρύθμιση Εφαρμογών<a class=anchor href=#configtuning-appconfig></a></h2><div class=sectionbody><div class=paragraph><p>Τυπικά, οι εγκατεστημένες εφαρμογές έχουν τα δικά τους αρχεία ρυθμίσεων, με το δικό τους τρόπο σύνταξης, κτλπ. Είναι σημαντικό αυτά τα αρχεία να κρατούνται ξεχωριστά απο το βασικό σύστημα, έτσι ώστε να είναι εύκολα εντοπίσιμα και διαχειρίσιμα απο τα εργαλεία διαχείρισης πακέτων.</p></div><div class=paragraph><p>Τυπικά, αυτά τα αρχεία είναι εγκατεστημένα στο <span class=filename>/usr/local/etc</span>. Σε αυτή την περίπτωση όταν μία εφαρμογή έχει μεγάλο αριθμό αρχείων ρυθμίσεων, ένας υποκατάλογος δημιουργείται για να τα αποθηκεύσει.</p></div><div class=paragraph><p>Κανονικά, όταν ένα port ή ένα package εγκαθιστάτε, παραδείγματα αρχείων ρυθμίσεων εγκαθιστάνται επίσης. Αυτά είναι συνήθως αναγνωρίσιμα απο την <span class=filename>.default</span> κατάληξη τους. Αν δεν υπάρχουν αρχεία ρυθμίσεων για την εφαρμογή, τότε θα δημιουργηθούν κάνοντας αντιγραφή τα <span class=filename>.default</span> αρχεία.</p></div><div class=paragraph><p>Για παράδειγμα, έχετε υπόψη σας τα περιεχόμενα του καταλόγου <span class=filename>/usr/local/etc/apache</span>:</p></div><div class=literalblock><div class=content><pre>-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</pre></div></div><div class=paragraph><p>Τα μεγέθοι των αρχείων δείχνουν ότι μόνο το αρχείο <span class=filename>srm.conf</span> έχει αλλάξει. Μία μετέπειτα αναβάθμιση του port της εφαρμογής Apache δεν θα αντικαταστήσει το αλλαγμένο αρχείο.</p></div></div></div><div class=sect1><h2 id=configtuning-starting-services>Chapter 22. Eκκινώντας Υπηρεσίες<a class=anchor href=#configtuning-starting-services></a></h2><div class=sectionbody><div class=paragraph><p>Πολλοί χρήστες επιλέγουν να εγκαταστήσουν λογισμικό απο τρίτους κατασκευαστές στο FreeBSD απο την συλλογή των Ports. Σε πολλές απο αυτές τις περιπτώσεις μπορεί να είναι απαραίτητο να ρυθμίσουν το λογισμικό με τέτοιο τρόπο ώστε να μπορεί να επιτραπεί η εκκίνηση του κατα την εκκίνηση του συστήματος. Υπηρεσίες, όπως το <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> ή το <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13/>www/apache13</a> είναι μόνο δύο απο τα πολλά πακέτα λογισμικού που μπορεί να χρειάζονται να εκκινηθούν κατά την εκκίνηση του συστήματος. Το μέρος αυτό θα εξηγήσει τις διαθέσιμες διαδικασίες για την εκκίνηση λογισμικού προερχόμενο απο τρίτους κατασκευαστές.</p></div><div class=paragraph><p>Στο FreeBSD, οι περισσότερες περιεχόμενες υπηρεσίες, όπως το <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, είναι εκκινήσιμες μέσα από τα σενάρια εκκίνησης του συστήματος. Τα σενάρια αυτά μπορεί να διαφέρουν ανάλογα το FreeBSD ή την έκδοση του κατασκευαστή; ωστόσο, η πιο σημαντική πτυχή που πρέπει να εξεταστεί είναι ότι οι ρυθμίσεις εκκίνησης τους μπορούν να χειριστούν μέσα απο ένα απλό σενάριο εκκίνησης.</p></div><div class=paragraph><p>Πριν την έλευση του <span class=filename>rc.d</span>, οι εφαρμογές μπορούσαν να τοποθετήσουν ένα απλό σενάριο εκκίνησης μέσα στον κατάλογο <span class=filename>/usr/local/etc/rc.d</span> ο οποίος μπορούσε να διαβαστεί απο τα σενάρια εκκίνησης του συστήματος. Αυτά τα σενάρια μπορούσαν να εκτελεστούν κατα τα μετέπειτα στάδια εκκίνησης του συστήματος.</p></div><div class=paragraph><p>Ενώ πολλοί ιδιώτες ξόδευαν χρόνο προσπαθώντας να συνχωνεύσουν το παλιό στυλ ρυθμίσεων με το νέο στυλ, παραμένει γεγονός ότι μερικά προγράμματα ακόμα απαιτούν ένα σενάριο να τοποθετηθεί μέσα στον προαναφερθέντα κατάλογο. Οι λεπτές διαφορές ανάμεσα στα σενάρια εξαρτώνται από το αν ή όχι ο <span class=filename>rc.d</span> χρησιμοποιείτε. Προγενέστερα του FreeBSD 5.1 το παλιό στυλ ρυθμίσεων χρησιμοποιούνταν και σχεδόν σε όλες τις περιπτώσεις ένα νέου στυλ σενάριο θα είναι συμβατό.</p></div><div class=paragraph><p>Ενώ κάθε σενάριο πρέπει να τηρεί ορισμένες ελάχιστες απαιτήσεις, τις περισσότερες φορές αυτές οι απαιτήσεις είναι ανεξάρτητες της έκδοσης του FreeBSD. Κάθε σενάριο πρέπει να έχει μια <span class=filename>.sh</span> επέκταση προσαρτημένη στο τέλος του και κάθε σενάριο πρέπει να είναι εκτελέσιμο απο το σύστημα. Το δεύτερο μπορεί να επιτευχθεί χρησιμοποιώντας την <code>chmod</code> εντολή και ρυθμίζοντας την άδεια <code>755</code>. Εκεί πρέπει να υπάρχει, τουλάχιστον, μια επιλογή <code>start</code> και μία επιλογή <code>stop</code> για την εφαρμογή.</p></div><div class=paragraph><p>Το πιο απλό σενάριο εκκίνησης πιθανότατα να μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
echo -n &#39; utility&#39;

case &#34;$1&#34; in
start)
        /usr/local/bin/utility
        ;;
stop)
        kill -9 `cat /var/run/utility.pid`
        ;;
*)
        echo &#34;Usage: `basename $0` {start|stop}&#34; &gt;&amp;2
        exit 64
        ;;
esac

exit 0</pre></div></div><div class=paragraph><p>Το σενάριο αυτό παρέχει μια <code>stop</code> και μια <code>start</code> επιλογή για την εφαρμογή όπου στο παράδειγμα εδώ αναφέρεται σαν <code>utility</code>.</p></div><div class=paragraph><p>Μπορεί να εκκινηθεί χειρωνακτικά κάνοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/utility.sh start</span></code></pre></div></div><div class=paragraph><p>Παρόλο που δεν απαιτούν όλες οι εφαρμογές να προστεθεί μία εγγραφή στο <span class=filename>rc.conf</span>, σχεδόν καθημερινά και ένα νέο port θα τροποποιήτε για να δέχεται αυτή την ρύθμιση. Ελέγξετε την τελική έξοδο της εγκατάστασης για περισσότερες πληροφορίες πάνω στην συγκεκριμένη εφαρμογή. Μερικές εφαρμογές απο τρίτους κατασκευαστές παρέχουν σενάρια εκκίνησης τα οποία επιτρέπουν στην εφαρμογή να χρησιμοποιηθεί με το <span class=filename>rc.d</span>, παρόλα αυτα, αυτό θα συζητηθεί στο επόμενο μέρος.</p></div><div class=sect2><h3 id=_εκτεταμένη_ρύθμιση_εφαρμογών>22.1. Εκτεταμένη Ρύθμιση Εφαρμογών<a class=anchor href=#_εκτεταμένη_ρύθμιση_εφαρμογών></a></h3><div class=paragraph><p>Πλέον το FreeBSD περιέχει το <span class=filename>rc.d</span>, η ρύθμιση της εκκίνησης των εφαρμογών έχει γίνει ευκολότερη, και πιο πλούσια σε χαρακτηρικά. Χρησιμοποιώντας λέξεις κλειδία μέσα στον κατάλογο <a href=#configtuning-rcd>rc.d</a>, οι εφαρμογές μπορούν πλέον να εκκινούν έπειτα απο συγκεκριμένες υπηρεσίες για παράδειγμα την DNS, μπορεί να επιτραπεί η εισαγωγή επιπλέον παραμέτρων μέσα απο το <span class=filename>rc.conf</span> στην θέση των ήδη υπάρχoντον παραμέτρων απο τα σενάρια εκκινήσης, κτλπ. Ένα βασικό σενάριο μπορεί να μοιάζει με το ακόλουθο:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Το σενάριο αυτό θα εξασφαλίσει ότι το πρόγραμμα utility θα εκκινηθεί μετά απο την <code>daemon</code> υπηρεσία. Θα εξασφαλίσει επιπλέον έναν τρόπο για την ρύθμιση και τον εντοπισμό του PID, ή του αρχείου του ID της διεργασίας.</p></div><div class=paragraph><p>Η εφαρμογή μπορεί πλέον να έχει την παρακάτω γραμμή τοποθετημένη στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ο νέος αυτός τρόπος επιτρέπει επιπλέον τον ευκολότερο χειρισμό των παραμέτρων της γραμμής εντολών, σε συνδυασμό με τις προυπάρχουσες λειτουργίες παρεχόμενες απο το <span class=filename>/etc/rc.subr</span>, τη συμβατότητα με το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> και επιπλέον την ευκολότερη ρύθμιση μέσω του <span class=filename>rc.conf</span> αρχείου.</p></div></div><div class=sect2><h3 id=_χρησιμοποιώντας_υπηρεσίες_για_την_εκκίνηση_υπηρεσιών>22.2. Χρησιμοποιώντας Υπηρεσίες Για Την Εκκίνηση Υπηρεσιών<a class=anchor href=#_χρησιμοποιώντας_υπηρεσίες_για_την_εκκίνηση_υπηρεσιών></a></h3><div class=paragraph><p>Άλλες υπηρεσίες, όπως ο δαίμονας του εξυπηρετή POP3, IMAP, κτλπ. μπορούν να εκκινηθούν χρησιμοποιώντας το <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. Αυτό απαιτεί την εγκατάσταση του βοηθητικού προγράμματος υπηρεσιών απο την Ports συλλογή και μια γραμμή ρυθμίσεων προσαρτημένη στο αρχείο <span class=filename>/etc/inetd.conf</span>, ή αποχαρακτηρίζοντας μια απο τις ήδη υπάρχουσες γραμμές ρυθμίσεων. Δουλεύοντας με το inetd και τις ρυθμίσεις του περιγράφεται αναλυτικά στο μέρος <a href=./#network-inetd>inetd</a>.</p></div><div class=paragraph><p>Σε πολλές περιπτώσεις, είναι εύλογο να χρησιμοποιείτε ο δαίμονας <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> για την εκκίνηση των υπηρεσιών του συστήματος. Η προσέγγιση αυτή έχει έναν αριθμό πλεονεκτημάτων γιατί το <code>cron</code> τρέχει τις διεργασίες σαν ιδιοκτήτης του <span class=filename>crontab</span> αρχείου. Αυτό επιτρέπει στους κανονικούς χρήστες να εκκινούν και να διαχειρίζονται μερικές εφαρμογές.</p></div><div class=paragraph><p>Το βοηθητικό πρόγραμμα <code>cron</code> παρέχει ένα μοναδικό χαρακτηριστικό, το <code>@reboot</code>, το οποίο μπορεί να χρησιμοποιηθεί στην θέση του χρονικού ορισμού. Αυτό θα κάνει την εργασία να τρέξει όταν το <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> εκκινηθεί, συνήθως κατά την εκκίνηση του συστήματος.</p></div></div></div></div><div class=sect1><h2 id=configtuning-cron>Chapter 23. Ρυθμίζοντας Το Πρόγραμμα <code>cron</code><a class=anchor href=#configtuning-cron></a></h2><div class=sectionbody><div class=paragraph><p>Ένα απο τα πιο χρήσιμα βοηθητικά προγράμματα στο FreeBSD είναι το <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. Το πρόγραμμα <code>cron</code> τρέχει στο παρασκήνιο και συνεχώς ελέγχει το αρχείο <span class=filename>/etc/crontab</span>. Το <code>cron</code> ελέγχει επίσης τον κατάλογο <span class=filename>/var/cron/tabs</span>, αναζητώντας καινούργια αρχεία <span class=filename>crontab</span>. Τα αρχεία <span class=filename>crontab</span> έχουν αποθηκευμένες πληροφορίες για συγκεκριμένες διαδικασίες τις οποίες το <code>cron</code> πρέπει να εκτελέσει σε συγκεκριμένο χρόνο.</p></div><div class=paragraph><p>Το <code>cron</code> χρησιμοποιεί δύο διαφορετικούς τύπους αρχείων ρυθμίσεων, το crontab του συστήματος και το crontab των χρηστών. Η μόνη διαφορά ανάμεσα στους δύο αυτούς τύπους είναι το έκτο πεδίο. Στο crontab του συστήματος, το έκτο πεδίο είναι το όνομα του χρήστη με του οποίου θα εκτελεστεί η εντολή. Αυτό δίνει την δυνατότητα στο crontab του συστήματος να εκτελεί εντολές σαν οποιοδήποτε χρήστης. Στο crontab των χρηστών, το έκτο πεδίο είναι η εντολή που πρέπει να εκτελεστεί, και όλες οι εντολές εκτελούνται στο όνομα του χρήστη που δημιούργησε το crontab; αυτό είναι ένα σημαντικό χαρακτηριστικό ασφαλείας.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Τα crontabs των χρηστών επιτρέπουν σε μεμονωμένους χρήστες να προγραμματίσουν εργρασίες χωρίς την ανάγκη <code>root</code> δικαιωμάτον. Οι εντολές μέσα στο crontab ενός χρήστη τρέχουν με τα δικαιώματα του χρήστη του οποίου ανήκει το crontab.</p></div><div class=paragraph><p>Ο χρήστης <code>root</code> μπορεί να έχει ένα crontab χρήστη ακριβώς όπως κάθε χρήστης. Αυτό είναι διαφορετικό απο το <span class=filename>/etc/crontab</span> (το crontab του συστήματος). Λόγο του crontab του συστήματος, δεν υπάρχει συνήθως καμία ανάγκη για την δημιουργία ενός ξεχωριστού crontab για τον χρήστη <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ας ρίξουμε μια ματία στο αρχείο <span class=filename>/etc/crontab</span> (το crontab του συστήματος):</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
#<i class=conum data-value=1></i><b>(1)</b>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <i class=conum data-value=3></i><b>(3)</b>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Όπως στα περισσότερα αρχεία ρυθμίσεων στο FreeBSD, ο χαρακτήρας <code>#</code> παριστάνει ένα σχόλιο. Ένα σχόλιο μπορεί να τοποθετηθεί μέσα στο αρχείο σαν υπενθύμιση για το τι πραγματοποιεί και γιατί μία ενέργεια. Τα σχόλια δεν μπορούν να είναι στην ίδια γραμμή με μία εντολή γιατί αλλιώς θα ερμηνευτούν σαν κομμάτι της εντολής; πρέπει να είναι σε μία νέα γραμμή. Οι κενές γραμμές αγνοούνται.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Καταρχήν, πρέπει να καθοριστεί το περιβάλλον. Ο χαρακτήρας ίσον (<code>=</code>) χρησιμοποιείτε για να καθορίσει τις ρυθμίσεις του περιβάλλοντος, όπως σε αυτό το παράδειγμα που χρησιμοποιούνται οι μεταβλητές <code>SHELL</code>, <code>PATH</code>, και <code>HOME</code>. Αν η γραμμή του κέλυφους παραμεληθεί, το <code>cron</code> θα χρησιμοποιήσει την προεπιλεγμένη, οι οποία είναι η <code>sh</code>. Αν η μεταβλητή <code>PATH</code> παραμεληθεί, δεν θα χρησιμοποιηθεί προεπιλεγμένη και η τοποθεσίες των αρχείων θα πρέπει να καθοριστούν με ακρίβεια. Αν η <code>HOME</code> παραμεληθεί, το <code>cron</code> θα χρησιμοποιήσει τον κεντρικό κατάλογο των εκάστοτε χρηστών.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Η γραμμή αυτή καθορίζει συνολικά επτά πεδία. Τα πεδία αυτά είναι τα <code>minute</code>, <code>hour</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code>, και <code>command</code>. Αυτά είναι απο μόνα τους επεξηγηματικά. Το πεδίο <code>minute</code> είναι ο χρόνος σε λεπτά τον οποίον η εντολή θα εκτελεστεί. Το πεδίο <code>hour</code> είναι παρόμοιο με το πεδίο <code>minute</code>, απλά είναι σε ώρες. Το πεδίο <code>mday</code> καθορίζει την ημέρα του μήνα. Το πεδίο <code>month</code> είναι παρόμοιο με το πεδίο <code>hour</code> και το πεδίο <code>minute</code>, υποδεικνύοντας τον μήνα. Το πεδίο <code>wday</code> καθορίζει την ημέρα της εβδομάδας. Όλα αυτά τα πεδία πρέπει να έχουν αριθμητικές τιμές, και να ακολουθούν το είκοσι-τετράωρο ρολόι. Το πεδίο <code>who</code> είναι ιδιαίτερο, και υπάρχει μόνο μέσα στο αρχείο <span class=filename>/etc/crontab</span>. Το πεδίο αυτό καθορίζει σαν ποιός χρήστης θα τρέξει την εντολή. Όταν ένας χρήστης εγκαθιστά το <span class=filename>crontab</span> αρχείο του, δεν θα έχει το πεδίο αυτό διαθέσιμο. Τέλος, θα ακολουθήσει η επιλογή <code>command</code>. Αυτό είναι το τελευταίο πεδίο, έτσι και λογικά υποδεικνύει την εντολή που θα εκτελεστεί.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Η τελευταία αυτή γραμμή θα καθορίσει τα μεγέθοι που συζητήθηκαν παραπάνω. Προσέξτε εδώ ότι έχουμε έναν ορισμό <code>*/5</code>, ακολουθούμενο απο αρκετούς χαρακτήρες <code>*</code>. Οι χαρακτήρες <code>*</code> σημαίνουν "πρώτο-τελευταίο", και μπορούν να ερμηνευθούν σαν <em>κάθε</em> φορά. Έτσι, κρίνοντας απο αυτή την γραμμή, είναι προφανές ότι η εντολή <code>atrun</code> επικαλείται απο τον χρήστη <code>root</code> κάθε πέντε λεπτά ανεξάρτητα απο την ημέρα και τον μήνα. Για περισσότερες πληροφορίες σχετικά με την εντολή <code>atrun</code>, κοιτάξτε την σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=atrun&amp;sektion=8&amp;format=html">atrun(8)</a>.Οι εντολές μπορούν να έχουν απεριόριστο αριθμό παραμέτρων, ωστόσο, οι εντολές με εκτεταμένο αριθμό γραμμών πρέπει να διασπαστούν με τον χαρακτήρα συνέχειας αντίθετης καθέτου "\".</td></tr></tbody></table></div><div class=paragraph><p>Αυτές είναι οι βασικές ρυθμίσεις για κάθε αρχείο <span class=filename>crontab</span>, ωστόσο υπάρχει και κάτι διαφορετικό. Το πεδίο έξι, όπου και καθορίζουμε το όνομα χρήστη, υπάρχει μόνο στο αρχείο του συστήματος <span class=filename>/etc/crontab</span>. Το πεδίο αυτό πρέπει να παραλειφθεί για κάθε <span class=filename>crontab</span> αρχείο χρήστη.</p></div><div class=sect2><h3 id=configtuning-installcrontab>23.1. Εγκαθιστώντας Ένα Crontab<a class=anchor href=#configtuning-installcrontab></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Δεν θα πρέπει να χρησιμοποιήσετε την διαδικασία που περιγράφεται εδώ για την διόρθωση/εγκατάσταση του crontab του συστήματος. Απλά χρησιμοποιήστε τον αγαπημένο σας κειμενογράφο: το <code>cron</code> θα εντοπίσει ότι το αρχείο έχει τροποποιηθεί και θα αρχίσει άμεσα να χρησιμοποιεί την ανανεωμένη έκδοση του. Δείτε <a href=https://docs.freebsd.org/el/books/faq/#ROOT-NOT-FOUND-CRON-ERRORS>αυτή την εγγραφή του FAQ</a> για περισσότερες πληροφορίες.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να εγκαταστήσετε ένα νέο <span class=filename>crontab</span> χρήστη, πρώτα χρησιμοποιήστε τον αγαπημένο σας κειμενογράφο για να δημιουργήσετε ένα αρχείο με το απαιτούμενο τύπο, και τότε χρησιμοποιήστε το <code>crontab</code>. Η πιο κοινή χρήση του είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab crontab-file</code></pre></div></div><div class=paragraph><p>Στο παράδειγμα αυτό, το αρχείο <span class=filename>crontab-file</span> είναι το όνομα του αρχείου <span class=filename>crontab</span> που είχε δημιουργηθεί προηγουμένως.</p></div><div class=paragraph><p>Υπάρχει επίσης μία επιλογή για να απαριθμήσετε τα εγκατεστημένα αρχεία <span class=filename>crontab</span>: απλά εισάγετε την επιλογή <code>-l</code> στην εντολή <code>crontab</code> και ελέγξτε το αποτέλεσμα.</p></div><div class=paragraph><p>Για τους χρήστες που θέλουν να αρχίσουν το crontab αρχείο τους απο την αρχή, χωρίς την χρήση προτύπου, μπορούν να χρησιμοποιήσουν την εντολή <code>crontab -e</code>. Αυτή η εντολή θα ξεκινήσει τον κειμενογράφο με ένα κενό αρχείο. Όταν το αρχείο αποθηκευθεί, θα εγκατασταθεί αυτόματα απο την εντολή <code>crontab</code>.</p></div><div class=paragraph><p>Αν αργότερα θέλετε να διαγράψετε το <span class=filename>crontab</span> αρχείο χρήστη τελείως, χρησιμοποιήστε την εντολή <code>crontab</code> μαζί με την επιλογή <code>-r</code>.</p></div></div></div></div><div class=sect1><h2 id=configtuning-rcd>Chapter 24. Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD<a class=anchor href=#configtuning-rcd></a></h2><div class=sectionbody><div class=paragraph><p>Το 2002 το FreeBSD ενσωμάτωσε το σύστημα <span class=filename>rc.d</span> του NetBSD για την εκκίνηση του συστήματος. Οι χρήστες θα πρέπει να έχουν αντιληφθεί τα αρχεία που βρίσκονται στον κατάλογο <span class=filename>/etc/rc.d</span>. Πολλά απο αυτά τα αρχεία είναι για τις βασικές υπηρεσίες και μπορούν να ελεγθούν με τις επιλογές <code>start</code>, <code>stop</code>, και <code>restart</code>. Για παράδειγμα, το <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> μπορεί να ελεγθεί χρησιμοποιώντας την εξής εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd restart</span></code></pre></div></div><div class=paragraph><p>Η διαδικασία αυτή είναι παρόμοια και για τις υπόλοιπες υπηρεσίες. Φυσικά, οι υπηρεσίες αυτές είναι συνήθως αυτόματα εκκινήσιμες κατα την εκκίνηση του συστήματος όπως και καθορίζεται στο <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Για παράδειγμα, ενεργοποιώντας τον δαίμονα Network Address Translation στην εκκίνηση είναι τόσο απλό όσο κάνοντας προσθήκη της ακόλουθης γραμμής στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Αν η επιλογή <code>natd_enable="NO"</code> είναι ήδη παρούσα, τότε απλά αλλάζετε την επιλογή <code>NO</code> σε <code>YES</code>. Τα σενάρια rc θα φορτώσουν αυτόματα οποιαδήποτε εξαρτώμενη υπηρεσία κατά την διάρκεια της επόμενης εκκίνησης, όπως και περιγράφεται παρακάτω.</p></div><div class=paragraph><p>Μιας και το σύστημα <span class=filename>rc.d</span> είναι κυρίως για την εκκίνηση και τον τερματισμό υπηρεσιών κατα την εκκίνηση και τον τερματισμό του συστήματος αντίστοιχα, οι προκαθορισμένες επιλογές <code>start</code>, <code>stop</code> και <code>restart</code> θα πραγματοποιήσουν τις αντίστοιχες ενέργειες αν η κατάλληλες μεταβλητές είναι καθορισμένες στο <span class=filename>/etc/rc.conf</span>. Για παράδειγμα η παραπάνω εντολή <code>sshd restart</code> θα δουλέψει μόνο αν η μεταβλητή <code>sshd_enable</code> έχει τεθεί σε <code>YES</code> μέσα στο <span class=filename>/etc/rc.conf</span>. Για να εκτελέσετε τις επιλογές <code>start</code>, <code>stop</code> ή <code>restart</code> μιας υπηρεσίας ανεξάρτητα απο τις ρυθμίσεις της στο <span class=filename>/etc/rc.conf</span>, η εντολή πρέπει να έχει χαρακτηριστεί με "one". Για παράδειγμα για την επανεκκίνηση του <code>sshd</code> ανεξάρτητα απο τις τρέχουσες ρυθμίσεις στο <span class=filename>/etc/rc.conf</span>, εκτελείτε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd onerestart</span></code></pre></div></div><div class=paragraph><p>Είναι εύκολο να ελέγξετε αν η υπηρεσία είναι ενεργοποιημένη στο <span class=filename>/etc/rc.conf</span> τρέχοντας το κατάλληλο σενάριο <span class=filename>rc.d</span> με την παράμετρο <code>rcvar</code>. Κατά συνέπεια, ένας διαχειριστής μπορεί να ελέγξει αν το <code>sshd</code> είναι όντως ενεργοποιημένο στο <span class=filename>/etc/rc.conf</span> εκτελώντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd rcvar</span>
<span class=c># sshd</span>
<span class=nv>$sshd_enable</span><span class=o>=</span>YES</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η δεύτερη γραμμή (<code># sshd</code>) είναι η έξοδος της εντολής <code>sshd</code>, και όχι η κονσολά του χρήστη <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να ελέγξετε αν μια υπηρεσία τρέχει, η επιλογή <code>status</code> είναι διαθέσιμη. Για παράδειγμα για να επιβεβαιώστε ότι η υπηρεσία <code>sshd</code> τρέχει:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd status sshd is</span>
      running as pid 433.</code></pre></div></div><div class=paragraph><p>Σε πολλές περιπτώσεις είναι δυνατόν το <code>reload</code> μίας υπηρεσίας. Αυτό θα στείλει ένα σήμα στην υπηρεσία, επιβάλλοντας της να ξαναφορτώσει τα αρχεία ρυθμίσεων της. Στην πραγματικότητα αυτό σημαίνει ότι θα στείλει ένα σήμα <code>SIGHUP</code> στην υπηρεσία. Η υποστήριξη για αυτό το χαρακτηριστικό δεν παρέχεται σε κάθε υπηρεσία.</p></div><div class=paragraph><p>Το σύστημα <span class=filename>rc.d</span> δεν χρησιμοποιείτε μόνο για τις υπηρεσίες δικτύου, αλλά επίσης συμβάλει και κατα την εκκίνηση του συστήματος. Για παράδειγμα, σκεφτείτε το αρχείο <span class=filename>bgfsck</span>. Όταν ένα σενάριο εκτελείτε, θα εκτυπώνει το ακόλουθο μήνυμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Επομένος το αρχείο αυτό χρησιμοποιείτε στο παρασκήνιο για τον έλεγχο του συστήματος αρχείων, ο οποίος και συμβαίνει κατα στην εκκίνηση του συστήματος.</p></div><div class=paragraph><p>Πολλές υπηρεσίες εξαρτώνται από άλλες υπηρεσίες για να τα καταφέρουν να λειτουργήσουν σωστά. Για παράδειγμα, η υπηρεσία NIS και άλλες βασισμένες στο RPC υπηρεσίες θα αποτύχουν να εκκινηθούν αν η υπηρεσία <code>rpcbind</code> (portmapper) δεν έχει ήδη εκκινηθεί. Για να λύθει το πρόβλημα αυτό, υπάρχουν πληροφορίες για τις εξαρτήσεις και άλλα μετα-δεδομένα μέσα στα σχόλια στην αρχή κάθε σεναρίου. Το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> χρησιμοποιείτε για την ανάλυση των σχολίων αυτών κατά την εκκίνηση του συστήματος για να καθορίστει με ποιά σειρά θα πρέπει να εκκινηθούν οι υπηρεσίες ώστε να εκπληρωθούν οι εξαρτήσεις. Οι επόμενες προτάσεις μπορούν να περιληφθούν μέσα σε κάθε αρχείο εκκίνησης:</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: Καθόριζει την υπηρεσία που παρέχει το αρχείο αυτό.</p></li><li><p><code>REQUIRE</code>: Απαριθμεί τις υπηρεσίες που απαιτούνται για την την υπηρεσία αυτή. Το αρχείο αυτό θα εκτελεστεί <em>μετά</em> απο την καθορισμένη υπηρεσία.</p></li><li><p><code>BEFORE</code>: Απαριθμεί τις υπηρεσίες οι οποίες εξαρτώνται απο την υπηρεσία αυτή. Το αρχείο αυτό θα εκτελεστεί <em>πρίν</em> τις καθορισμένες υπηρεσίες.</p></li></ul></div><div class=paragraph><p>Χρησιμοποιώντας την μέθοδο αυτή, οι διαχειριστές μπορούν εύκολα να ελέγξουν τις υπηρεσίες του συστήματος χωρίς τα δυσνόητα "runlevels" όπως σε μερικά άλλα λειτουργικά συστήματα UNIX®.</p></div><div class=paragraph><p>Επιπλέον πληροφορίες για το σύστημα <span class=filename>rc.d</span> μπορούν να βρεθούν στις σελίδες βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Αν ενδιαφέρεστε για την εγγραφή δικών σας σεναρίων <span class=filename>rc.d</span> ή για την βελτίωση των ήδη υπάρχοντων, θα βρείτε <a href=https://docs.freebsd.org/en/articles/rc-scripting/>τον σύνδεσμο αυτόν</a> αρκετά χρήσιμο.</p></div></div></div><div class=sect1><h2 id=config-network-setup>Chapter 25. Ρυθμίζοντας Τις Κάρτες Δικτύου<a class=anchor href=#config-network-setup></a></h2><div class=sectionbody><div class=paragraph><p>Την σήμερον εποχή δεν μπορούμε να σκεφτούμε έναν υπολογιστή χωρίς να σκεφτούμε και μία σύνδεση δικτύου. Προσθέτοντας και ρυθμίζοντας μια κάρτα δικτύου είναι μία συνηθισμένη εργασία για έναν οποιοδήποτε διαχειριστή του FreeBSD.</p></div><div class=sect2><h3 id=_εντοπίζοντας_τον_σωστό_οδηγό>25.1. Εντοπίζοντας Τον Σωστό Οδηγό<a class=anchor href=#_εντοπίζοντας_τον_σωστό_οδηγό></a></h3><div class=paragraph><p>Πριν αρχίσετε, θα πρέπει να γνωρίζετε το μοντέλο της κάρτας που έχετε, ποιό chip χρησιμοποιεί, και αν είναι PCI ή ISA κάρτα. Το FreeBSD υποστηρίζει ένα μεγάλο εύρος καρτών PCI και ISA. Ελέγξτε την Λίστα Συμβατότητας Υλικού για την έκδοση σας για να δείτε αν η κάρτα σας υποστηρίζεται.</p></div><div class=paragraph><p>Εφόσον είστε πλέον σίγουρος ότι η κάρτα σας υποστηρίζεται, θα χρειαστεί να καθορίσετε τον κατάλληλο οδηγό για την κάρτα σας. Το αρχείο <span class=filename>/usr/src/sys/conf/NOTES</span> και το αρχείο <span class=filename>/usr/src/sys/arch/conf/NOTES</span> θα σας δώσουν μια λίστα με κάρτες δικτύου και μερικές πληροφορίες για τα υποστηριζόμενα chipsets και τις υποστηριζόμενες κάρτες. Αν έχετε αμφιβολίες για το ποιός οδηγός είναι ο σωστός, διαβάστε την σελίδα βοηθείας του οδηγού. Η σελίδα βοηθείας θα σας δώσει περισσότερες πληροφορίες σχετικά με το υποστηριζόμενο υλικό και ακόμα και για τα πιθανά προβλήματα που μπορεί να προκύψουν.</p></div><div class=paragraph><p>Αν έχετε μια συνηθισμένη κάρτα, κατα πάσα πιθανότητα δεν θα χρειαστεί να ψάξετε πολύ για τον οδηγό. Οι οδηγοί για τις συνηθισμένες κάρτες δικτύου υπάρχουν στον πυρήνα <span class=filename>GENERIC</span>, έτσι ώστε και θα εμφανιστεί κατα την διάρκεια της εκκίνησης, για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</code></pre></div></div><div class=paragraph><p>Στο παράδειγμα αυτό, βλέπουμε ότι δύο κάρτες που χρησιμοποιούν τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a> έχουν εντοπιστεί στο σύστημα.</p></div><div class=paragraph><p>Αν ο οδηγός της NIC σας δεν είναι παρόν στον <span class=filename>GENERIC</span>, θα πρέπει να φορτώσετε τον κατάλληλο οδηγό για να χρησιμοποιήσετε την NIC σας. Αυτό μπορεί να επιτευχθεί με έναν απο τους δύο αυτούς τρόπους:</p></div><div class=ulist><ul><li><p>Ο ποιό εύκολο τρόπος είναι απλά να φορτώσετε ένα άρθρωμα του πυρήνα για την κάρτα δικτύου σας με το <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>, ή αυτόματα κατα την εκκίνηση προσθέτοντας την κατάλληλη γραμμή στο αρχείο <span class=filename>/boot/loader.conf</span>. Δεν είναι όλοι οι οδηγοί NIC διαθέσιμοι σαν αρθρώματα, χαρακτηριστικά παραδείγματα είναι τα αρθρώματα για συσκευές ISA.</p></li><li><p>Εναλλακτικά, μπορείτε να μεταγλώττισετε στατικά την υποστήριξη για την κάρτα σας στον πυρήνα. Ελέγξετε το αρχείο <span class=filename>/usr/src/sys/conf/NOTES</span>, το <span class=filename>/usr/src/sys/arch/conf/NOTES</span> και την σελίδα βοηθείας του οδηγού για να μάθετε τι πρέπει να προσθέσετε στο αρχείο ρυθμίσεων του πυρήνα. Για περισσότερες πληροφορίες για το πως να μεταγλωττίσετε τον πυρήνα, παρακαλώ διαβάστε το <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>. Αν η κάρτα σας εντοπιστεί κατα την εκκίνηση απο τον πυρήνα (<span class=filename>GENERIC</span>) δεν χρειάζετε να μεταγλώττισετε έναν νέο πυρήνα.</p></li></ul></div><div class=sect3><h4 id=config-network-ndis>25.1.1. Χρησιμοποιώντας Οδηγούς Windows® Με Το NDIS<a class=anchor href=#config-network-ndis></a></h4><div class=paragraph><p>Δυστυχώς, υπάρχουν ακόμα πολλοί κατασκευαστές που δεν παρέχουν τεχνικές προδιαγραφές για τους οδηγούς τους στην κοινότητα του ανοικτού λογισμικού γιατί αντιμετωπίζουν τέτοιες πληροφορίες σαν μυστικά του εμπορίου. Συνεπώς, οι υπεύθυνοι για την ανάπτυξη του FreeBSD και άλλων λειτουργικών συστημάτων μένουν με δύο επιλογές: να αναπτύξουν οδηγούς με την μακρά και επίπονη διαδικασία της αντίστροφης μηχανικής ή να χρησιμοποιήσουν ήδη υπάρχοντες οδηγούς σε δυαδική μορφή διαθέσιμους για την πλατφόρμα Microsoft® Windows®. Οι περισσότεροι υπεύθυνοι για την ανάπτυξη, μεταξύ τους και αυτοί που εμπλέκονται με το FreeBSD, έχουν επιλέξει την δεύτερη προσέγγιση.</p></div><div class=paragraph><p>Χάρη την προσφορά του Bill Paul (wpaul), μιάς και απο το FreeBSD 5.3-RELEASE υπάρχει "γηγενής" υποστήριξη για το Network Driver Interface Specification (NDIS). Το έργο FreeBSD NDISulator (διαφορετικά γνωστό σας Project Evil) παίρνει έναν οδηγό Windows® σε δυαδική μορφή και στην ουσία τον εξαπατά ώστε να νομίζει ότι τρέχει σε Windows®. Λόγο του ότι ο οδηγός <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> χρησιμοποιεί μία Windows® δυαδική μορφή, μπορεί να χρησιμοποιηθεί μόνο σε i386™ και amd64 συστήματα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ο οδηγός <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> είναι σχεδιασμένος ώστε να υποστηρίζει κυρίως συσκευές PCI, CardBus και PCMCIA, οι συσκευές USB δεν υποστηρίζονται ακόμα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να χρησιμοποιήσετε τον NDISulator, θα χρειαστείτε τρία πράγματα:</p></div><div class="olist arabic"><ol class=arabic><li><p>Τον πηγαίο κώδικα του πυρήνα</p></li><li><p>Την Windows® XP δυαδική μορφή του οδηγού (<span class=filename>.SYS</span> επέκταση)</p></li><li><p>Το Windows® XP αρχείο ρυθμίσεων του οδηγού (<span class=filename>.INF</span> επέκταση)</p></li></ol></div><div class=paragraph><p>Εντοπίστε τα αρχεία αυτά για την κάρτα σας. Γενικά, αυτά μπορούν να βρεθούν στα παρεχόμενα CDs ή στους ιστότοπους των κατασκευαστών. Στα ακόλουθα παραδείγματα, θα χρησιμοποιήσουμε τα αρχεία <span class=filename>W32DRIVER.SYS</span> και <span class=filename>W32DRIVER.INF</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Δεν μπορείτε να χρησιμοποιήσετε οδηγούς Windows®/i386 σε συστήματα FreeBSD/amd64, θα πρέπει να βρείτε οδηγούς Windows®/amd64 για να δουλέψουν σωστά.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το επόμενο βήμα είναι να μεταγλωττίσετε τον δυαδικό οδηγό μέσα σε ένα φορτώσιμο άρθρωμα του πυρήνα. Για να το επιτύχετε αυτό, θα πρέπει σαν <code>root</code>, να χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>Το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> είναι διαδραστικό και θα σας ενημερώσει για οποιαδήποτε επιπλέον πληροφορία μπορεί να χρειαστεί; θα παράγει ένα άρθρωμα του πυρήνα στον τρέχωντα κατάλογο και μπορεί να φορτωθεί ως εξής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER.ko</span></code></pre></div></div><div class=paragraph><p>Επιπλέον του παραχθέντος αρθρώματος, θα πρέπει να φορτώσετε τα αρθρώματα <span class=filename>ndis.ko</span> και <span class=filename>if_ndis.ko</span>. Αυτό θα πρέπει να γίνει αυτόματα όταν φορτώνετε οποιαδήποτε εξαρτάται απο το <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>. Αν θέλετε να το κάνετε χειρωνακτικά, θα πρέπει να χρησιμοποιήσετε τις ακόλουθες εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>Η πρώτη εντολή φορτώνει τον οδηγό NDIS miniport wrapper, ενώ η δεύτερη φορτώνει την πραγματική κάρτα δικτύου.</p></div><div class=paragraph><p>Τώρα, ελέγξτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> για να δείτε αν υπάρχουν σφάλματα κατα την φόρτωση. Αν όλα πήγαν καλά, θα πρέπει να δείτε μια παρόμοια έξοδο με την επόμενη:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>Απο εδώ και πέρα μπορείτε να χειριστείτε την συσκευή <span class=filename>ndis0</span> σαν μια οποιαδήποτε κάρτα δικτύου (π.χ., <span class=filename>dc0</span>).</p></div><div class=paragraph><p>Μπορείτε να ρυθμίσετε το σύστημα να φορτώνει τα NDIS αρθρώματα κατα την εκκίνηση με τον ίδιο τρόπο με τα όπως με οποιαδήποτε άλλα αρθρώματα. Πρώτα, αντιγράψτε το παραχθείσα άρθρωμα, <span class=filename>W32DRIVER.ko</span>, στον κατάλογο <span class=filename>/boot/modules</span>. Τότε, προσθέστε την ακόλουθη γραμμή στο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_ρυθμίζοντας_την_κάρτα_δικτύου>25.2. Ρυθμίζοντας Την Κάρτα Δικτύου<a class=anchor href=#_ρυθμίζοντας_την_κάρτα_δικτύου></a></h3><div class=paragraph><p>Μόλις ο κατάλληλος οδηγός φορτωθεί για την κάρτα δικτύου, χρειάζεται να ρυθμιστεί. Όπως πολλά άλλα πράγματα, η κάρτα δικτύου είχε ρυθμιστεί κατα την στιγμή της εγκατάστασης με το sysinstall.</p></div><div class=paragraph><p>Για να εμφανίσετε τις κάρτες δικτύου που έχετε στο σύστημα σας, πληκτρολογήστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Παλαιότερες εκδόσεις του FreeBSD μπορεί να χρειάζονται την παράμετρο <code>-a</code> ακολουθούμενη στην <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, για περισσότερες λεπτομέρειες σχετικά με την σωστή σύνταξη του <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, παρακαλώ ανατρέξτε στην σελίδα βοηθείας. Σημειώστε επίσης ότι οι εγγραφές που αφορούν το IPv6 (<code>inet6</code> κτλπ.) έχουν παραμεληθεί σε αυτό το παράδειγμα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Σε αυτό το παράδειγμα, οι ακόλουθες συσκευές έχουν εμφανιστεί:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: Η πρώτη Ethernet κάρτα δικτύου</p></li><li><p><span class=filename>dc1</span>: Η δεύτερη Ethernet κάρτα δικτύου</p></li><li><p><span class=filename>lp0</span>: Η παράλληλη πόρτα</p></li><li><p><span class=filename>lo0</span>: Η συσκευή loopback</p></li><li><p><span class=filename>tun0</span>: Η συσκευή tunnel χρησιμοποιούμενη απο το πρόγραμμα ppp</p></li></ul></div><div class=paragraph><p>Το FreeBSD χρησιμοποιεί τα ονόματα των οδηγών με την σειρά κατα την οποία εντοπίστηκαν οι αντίστοιχες κάρτες κατα την εκκίνηση. Για παράδειγμα η συσκευή <span class=filename>sis2</span> θα είναι η τρίτη κάρτα δικτύου που χρησιμοποιεί τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a>.</p></div><div class=paragraph><p>Στο παράδειγμα αυτό, η συσκευή <span class=filename>dc0</span> είναι πάνω και τρέχει. Οι λέξεις κλειδία είναι:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> σημαίνει ότι η κάρτα είναι ρυθμισμένη και έτοιμη.</p></li><li><p>Η κάρτα έχει μία Internet διεύθυνση (<code>inet</code>) ρυθμισμένη (σε αυτή την περίπτωση <code>192.168.1.3</code>).</p></li><li><p>Έχει μία έγκυρη μάσκα υποδικτύου (<code>netmask</code>; <code>0xffffff00</code> είναι το ίδιο με το <code>255.255.255.0</code>).</p></li><li><p>Έχει μία έγκυρη broadcast διεύθυνση (σε αυτή την περίπτωση, <code>192.168.1.255</code>).</p></li><li><p>Η διεύθυνση MAC της κάρτας (<code>ether</code>) είναι <code>00:a0:cc:da:da:da</code></p></li><li><p>Η επιλογή του φυσικού μέσου είναι σε κατάσταση autoselection (<code>media: Ethernet autoselect (100baseTX &lt;full-duplex>)</code>). Παρατηρούμε ότι η <span class=filename>dc1</span> έχει ρυθμιστεί να τρέχει σαν <code>10baseT/UTP</code> μέσο. Για περισσότερες πληροφορίες για τους τύπους των μέσων ενός οδηγού, παρακαλώ ανατρέξτε στην σελίδα βοηθείας.</p></li><li><p>Η κατάσταση της σύνδεσης (<code>status</code>) είναι <code>active</code>, δηλ. έχει εντοπιστεί σήμα μεταφοράς. Στην <span class=filename>dc1</span>, παρατηρούμε <code>status: no carrier</code>. Αυτό είναι λογικό αφού το καλώδιο Ethernet δεν έχει συνδεθεί με την κάρτα.</p></li></ol></div><div class=paragraph><p>Αν το <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> εμφανίζει κάτι παρόμοιο με αυτό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
	        ether 00:a0:cc:da:da:da</code></pre></div></div><div class=paragraph><p>σημαίνει ότι η κάρτα δεν έχει ρυθμιστεί.</p></div><div class=paragraph><p>Για να ρυθμίσετε την κάρτα σας, θα χρειαστείτε προνόμια <code>root</code>. Η ρύθμιση της κάρτας δικτύου μπορεί να γίνει απο την γραμμή εντολών με το <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> αλλά θα πρέπει να το επαναλάβετε σε κάθε επανεκκίνηση του συστήματος. Το αρχείο <span class=filename>/etc/rc.conf</span> είναι εκεί όπου πρέπει να προσθέσετε τις ρύθμισεις της κάρτας δικτύου.</p></div><div class=paragraph><p>Ανοίξτε το αρχείο <span class=filename>/etc/rc.conf</span> με τον αγαπημένο σας κειμενογράφο. Θα χρειαστεί να προσθέσετε μία γραμμή για κάθε κάρτα δικτύου που υπάρχει στο σύστημα σας, για παράδειγμα στην περίπτωση μας, θα πρέπει να προσθέσετε τι εξής γραμμές:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Θα πρέπει να αντικαταστήσετε το <span class=filename>dc0</span>, <span class=filename>dc1</span>, και ούτω κάθε εξής, με τις σωστές συσκευές των καρτών σας, και τις σωστές διευθύνσεις. Θα πρέπει να διαβάσετε την σελίδα βοηθείας του οδηγού και του <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> για περισσότερες λεπτομέριες σχετικά με τις επιτρεπόμενες παραμέτρους και επίσης την σελίδα βοηθείας του <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> για περισσότερες λεπτομέριες σχετικά με την σύνταξη του <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Αν ρυθμίσατε το δίκτυο σας κατα την εγκατάσταση, μερικές γραμμές σχετικές με την/τις κάρτα/κάρτες δικτύου θα υπάρχουν ήδη. Ελέγξτε διπλά το <span class=filename>/etc/rc.conf</span> προτού προσθέστε επιπλέον γραμμές.</p></div><div class=paragraph><p>Θα πρέπει επίσης να διορθώσετε το αρχείο <span class=filename>/etc/hosts</span> ώστε να προσθέσετε τα ονόματα και τις IP διεύθυνσεις απο τα διάφορα μηχανήματα στο LAN σας, αν δεν είναι ήδη ρυθμισμένα. Για περισσότερες πληροφορίες ανατρέξτε στην σελίδα βοηθείας του <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> και του <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div></div><div class=sect2><h3 id=_δοκιμές_και_επίλυση_προβλημάτων>25.3. Δοκιμές Και Επίλυση Προβλημάτων<a class=anchor href=#_δοκιμές_και_επίλυση_προβλημάτων></a></h3><div class=paragraph><p>Μόλις κάνετε τις βασικές αλλαγές στο <span class=filename>/etc/rc.conf</span>, θα πρέπει να επανεκκινήσετε το σύστημα σας. Αυτό θα επιτρέψει σε πιθανές αλλαγές στις κάρτες να εφαρμοστούν, και να επιβεβαιώσετε ότι το σύστημα επανεκκινεί χωρίς κανένα λάθος στις ρυθμίσεις.</p></div><div class=paragraph><p>Μόλις το σύστημα επανεκκινηθεί, θα πρέπει να δοκιμάσετε τις κάρτες δικτύου.</p></div><div class=sect3><h4 id=_δοκιμάζοντας_μια_ethernet_κάρτα>25.3.1. Δοκιμάζοντας Μια Ethernet Κάρτα<a class=anchor href=#_δοκιμάζοντας_μια_ethernet_κάρτα></a></h4><div class=paragraph><p>Για να επιβεβαιώσετε ότι η Ethernet κάρτα λειτουργεί σωστά, θα πρέπει να κάνετε δύο πράγματα. Πρώτα, κάντε ping την κάρτα την ίδια, και μετά κάντε ping ένα άλλο μηχάνημα στο LAN.</p></div><div class=paragraph><p>Πρώτα δοκιμάστε στην τοπική κάρτα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=paragraph><p>Τώρα δοκιμάστε σε ένα άλλο μηχάνημα στο LAN:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε και το όνομα το μηχανήματος αντί της διεύθυνσης <code>192.168.1.2</code> αν έχετε ρυθμίσει το αρχείο <span class=filename>/etc/hosts</span>.</p></div></div><div class=sect3><h4 id=_επίλυση_προβλημάτων>25.3.2. Επίλυση Προβλημάτων<a class=anchor href=#_επίλυση_προβλημάτων></a></h4><div class=paragraph><p>Η επίλυση προβλημάτων υλικού και λογισμικού είναι πάντοτε επίπονη, ένας πόνος ο οποιός μπορεί να ανακουφιστεί ελέγχοντας μερικά απλά πράγματα πρώτα. Είναι το καλώδιο του δικτύου συνδεδεμένο; Έχετε ρυθμίσει σωστά τις υπηρεσίες δικτύου; Έχετε ρυθμίσει σωστά το πύρινο τείχος; Έχει πράγματι το FreeBSD υποστήριξη για αυτή την κάρτα δικτύου; Πρέπει πάντα να ελέγχετε τις σημειώσεις του υλικού πριν στείλε μία αναφορά για ένα πρόβλημα. Αναβαθμίστε την έκδοση του FreeBSD στην τελευταία ΣΤΑΘΕΡΗ έκδοση. Ελέγξτε τα αρχεία των λιστών μηνυμάτων, ή ψάξτε στο Internet.</p></div><div class=paragraph><p>Αν η κάρτα δουλεύει, αλλά με χαμηλή απόδοση, θα άξιζε να διαβάσετε την σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>. Μπορείτε επίσης να ελέγξετε οι αν λανθασμένες ρυθμίσεις του δικτύου προκαλούν τις αργές συνδέσεις.</p></div><div class=paragraph><p>Μερικοί χρήστες αντιμετωπίζουν ένα ή δύο μηνύματα <code>device timeout</code>, τα οποία είναι φυσιολογικά για μερικές κάρτες. Αν συνεχιστούν, ή γίνουν ενοχλητικά, θα πρέπει να ελέγξετε μήπως και κάποιες συσκευές παρεμποδίζουν η μία την άλλη. Ελέγξτε διπλά τις συνδέσεις των καλωδίων. Ίσως θα πρέπει να αποκτήσετε μία άλλη κάρτα.</p></div><div class=paragraph><p>Μερικές φορές, οι χρήστες παρατηρούν μερικά μηνύματα λάθους <code>watchdog timeout</code>. Το πρώτο πράγμα που πρέπει να κάνετε είναι να ελέγξετε το καλώδιο του δικτύου. Αρκέτες κάρτες χρειάζονται μία θέση PCI που να υποστηρίζει Bus Mastering. Σε μερικές παλιές μητρικές κάρτες. μόνο μία θέση PCI το υποστήριζε (συνήθως η θέση 0). Ελέγξτε την κάρτα δικτύου και την τεκμηρίωση της μητρικής κάρτας για να διαπιστώσετε αν εκεί είναι το πρόβλημα.</p></div><div class=paragraph><p>Το μήνυμα <code>No route to host</code> εμφανίζεται αν το σύστημα αδυνατεί να δρομολογήσει τα πακέτα στον προορισμό τους. Αυτό συμβαίνει αν δεν έχει καθοριστεί προεπιλεγμένη διεύθυνση δρομολόγησης, ή αν ένα καλώδιο έχει ξεσυνδεθεί. Ελέγξτε την έξοδο τις εντολής <code>netstat -rn</code> και σιγουρευτείτε ότι η διεύθυνση δρομολόγησης είναι έγκυρη. Αν δεν έχει καθοριστεί, διαβάστε το <a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a> για περισσότερες πληροφορίες.</p></div><div class=paragraph><p>Το μήνυμα λάθους <code>ping: sendto: Permission denied</code> συμβαίνει κυρίως λόγο κάποιας λάθος ρύθμισης στο πύρινο τείχος. Αν το <code>ipfw</code> είναι ενεργοποιημένο στον πυρήνα αλλά δεν έχουν καθοριστεί κανόνες, τότε η προεπιλεγμένη πολιτική είναι η απαγόρευση όλης της κίνησης, ακόμα και των αιτημάτων ping! Διαβάστε το <a href=./#firewalls>Firewalls</a> για περισσότερες πληροφορίες.</p></div><div class=paragraph><p>Μερικές φορές η απόδοση της κάρτας μπορεί να είναι φτωχή, ή κάτω του μέσου όρου. Σε αυτές τις περιπτώσεις το καλύτερο είναι να ρυθμίσετε την κατάσταση του μέσου απο <code>autoselect</code> στην κατάλληλη κατάσταση. Ενώ συνήθως αυτό φαίνετε να δουλεύει στα περισσότερα υλικά, μπορεί να μην λύσει το πρόβλημα στον καθέναν. Και πάλι, ελέγξτε όλες τις ρυθμίσεις του δικτύου, και ξαναδιαβάστε πάλι την σελίδα βοηθείας <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>Chapter 26. Εικονικά Hosts<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>Μία αρκετά συνηθισμένη χρήση του FreeBSD είναι η εικονική φιλοξενία ιστοχώρων, όπου και ένας εξυπηρετητής εμφανίζεται στο δίκτυο σαν περισσότερο απο ένας. Αυτό επιτυγχάνεται αναθέτοντας πολλαπλές δικτυακές διευθύνσεις σε μία και μόνο συσκευή.</p></div><div class=paragraph><p>Μία κάρτα δικτύου έχει μία "πραγματική" διεύθυνση, και απεριόριστο αριθμό "εικονικών" διευθύνσεων. Οι εικονικές αυτές διεύθυνσεις προσθέτονται με την μορφή εγγραφών στο αρχείο <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Μία εγγραφή εικονικής διεύθυνσης για την κάρτα δικτύου <span class=filename>fxp0</span> μοιάζει ως εξής:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>Σημειώστε ότι οι εγγραφές αυτές πρέπει να ξεκινούν με <code>alias0</code> και να συνεχίζουν πρός τα πάνω σε σειρά, (για παράδειγμα, <code>_alias1</code>, <code>_alias2</code>, και ούτω κάθε εξής). Η διαδικασία ρύθμισης θα σταματήσει στον πρώτο αριθμό που λείπει.</p></div><div class=paragraph><p>Ο υπολογισμός της μάσκας δικτύου είναι σημαντικός, αλλά ευτυχώς και εύκολος. Για κάθε κάρτα, πρέπει να υπάρχει μία διεύθυνση η οποία αντιπροσωπεύει σωστά την μάσκα του δικτύου. Οποιαδήποτε άλλη διεύθυνση που συμπίπτει στο ίδιο δίκτυο πρέπει να έχει μάσκα δικτύου <code>1</code>s (εκφρασμένη είτε σαν <code>255.255.255.255</code> είτε σαν <code>0xffffffff</code>).</p></div><div class=paragraph><p>Για παράδειγμα, εξετάστε την περίπτωση όπου η κάρτα δικτύου <span class=filename>fxp0</span> είναι συνδεδεμένη σε δύο δίκτυα, το δίκτυο <code>10.1.1.0</code> με μάσκα δικτύου <code>255.255.255.0</code> και το δίκτυο <code>202.0.75.16</code> με μάσκα δικτύου <code>255.255.255.240</code>. Θέλουμε το σύστημα να πάρει τις διευθύνσεις από <code>10.1.1.1</code> μέχρι <code>10.1.1.5</code> και τις <code>202.0.75.17</code> μέχρι <code>202.0.75.20</code>. Όπως σημειώθηκε παραπάνω, μόνο η πρώτες διευθύνσεις (στην περίπτωση αυτή, η <code>10.0.1.1</code> και η <code>202.0.75.17</code>) πρέπει να έχουν πραγματικές μάσκες δικτύου. Όλες οι υπόλοιπες, από (<code>10.1.1.2</code> μέχρι <code>10.1.1.5</code> και <code>202.0.75.18</code> μέχρι <code>202.0.75.20</code>) πρέπει να ρυθμιστούν με μάσκα δικτύου <code>255.255.255.255</code>.</p></div><div class=paragraph><p>Η ακόλουθες εγγραφές στο αρχείο <span class=filename>/etc/rc.conf</span> θα ρυθμίσουν την κάρτα όπως πρέπει για το παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div></div></div><div class=sect1><h2 id=configtuning-configfiles>Chapter 27. Αρχεία Ρυθμίσεων<a class=anchor href=#configtuning-configfiles></a></h2><div class=sectionbody><div class=sect2><h3 id=_ο_κατάλογος_etc>27.1. Ο κατάλογος <span class=filename>/etc</span><a class=anchor href=#_ο_κατάλογος_etc></a></h3><div class=paragraph><p>Τα αρχεία ρυθμίσεων αποθηκεύονται σε καταλόγους. Μερικοί απο αυτούς είναι:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Γενικές ρυθμίσεις του συστήματος, data here is system-specific.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Default versions of system configuration files.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extra <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> configuration, other MTA configuration files.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration for both user- and kernel-ppp programs.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Default location for <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> data. Normally <span class=filename>named.conf</span> and zone files are stored here.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration files for installed applications. May contain per-application subdirectories.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Start/stop scripts for installed applications.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Automatically generated system-specific database files, such as the package database, the locate database, and so on</p></td></tr></tbody></table></div><div class=sect2><h3 id=_hostnames>27.2. Hostnames<a class=anchor href=#_hostnames></a></h3><div class=sect3><h4 id=_etcresolv_conf>27.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h4><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> dictates how FreeBSD’s resolver accesses the Internet Domain Name System (DNS).</p></div><div class=paragraph><p>The most common entries to <span class=filename>resolv.conf</span> are:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The IP address of a name server the resolver should query. The servers are queried in the order listed with a maximum of three.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Search list for hostname lookup. This is normally determined by the domain of the local hostname.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The local domain name.</p></td></tr></tbody></table><div class=paragraph><p>A typical <span class=filename>resolv.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Only one of the <code>search</code> and <code>domain</code> options should be used.</p></div></td></tr></tbody></table></div><div class=paragraph><p>If you are using DHCP, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> usually rewrites <span class=filename>resolv.conf</span> with information received from the DHCP server.</p></div></div><div class=sect3><h4 id=_etchosts>27.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h4><div class=paragraph><p><span class=filename>/etc/hosts</span> is a simple text database reminiscent of the old Internet. It works in conjunction with DNS and NIS providing name to IP address mappings. Local computers connected via a LAN can be placed in here for simplistic naming purposes instead of setting up a <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> server. Additionally, <span class=filename>/etc/hosts</span> can be used to provide a local record of Internet names, reducing the need to query externally for commonly accessed names.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates&#39;).
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> takes on the simple format of:</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet address] [official hostname] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>For example:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> for more information.</p></div></div></div><div class=sect2><h3 id=_log_file_configuration>27.3. Log File Configuration<a class=anchor href=#_log_file_configuration></a></h3><div class=sect3><h4 id=_syslog_conf>27.3.1. <span class=filename>syslog.conf</span><a class=anchor href=#_syslog_conf></a></h4><div class=paragraph><p><span class=filename>syslog.conf</span> is the configuration file for the <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> program. It indicates which types of <code>syslog</code> messages are logged to particular log files.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</pre></div></div><div class=paragraph><p>Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> manual page for more information.</p></div></div><div class=sect3><h4 id=_newsyslog_conf>27.3.2. <span class=filename>newsyslog.conf</span><a class=anchor href=#_newsyslog_conf></a></h4><div class=paragraph><p><span class=filename>newsyslog.conf</span> is the configuration file for <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a>, a program that is normally scheduled to run by <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> determines when log files require archiving or rearranging. <span class=filename>logfile</span> is moved to <span class=filename>logfile.0</span>, <span class=filename>logfile.0</span> is moved to <span class=filename>logfile.1</span>, and so on. Alternatively, the log files may be archived in <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> format causing them to be named: <span class=filename>logfile.0.gz</span>, <span class=filename>logfile.1.gz</span>, and so on.</p></div><div class=paragraph><p><span class=filename>newsyslog.conf</span> indicates which log files are to be managed, how many are to be kept, and when they are to be touched. Log files can be rearranged and/or archived when they have either reached a certain size, or at a certain periodic time/date.</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</pre></div></div><div class=paragraph><p>Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> manual page for more information.</p></div></div></div><div class=sect2><h3 id=configtuning-sysctlconf>27.4. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h3><div class=paragraph><p><span class=filename>sysctl.conf</span> looks much like <span class=filename>rc.conf</span>. Values are set in a <code>variable=value</code> form. The specified values are set after the system goes into multi-user mode. Not all variables are settable in this mode.</p></div><div class=paragraph><p>To turn off logging of fatal signal exits and prevent users from seeing processes started from other users, the following tunables can be set in <span class=filename>sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div></div></div><div class=sect1><h2 id=configtuning-sysctl>Chapter 28. Tuning with sysctl<a class=anchor href=#configtuning-sysctl></a></h2><div class=sectionbody><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> is an interface that allows you to make changes to a running FreeBSD system. This includes many advanced options of the TCP/IP stack and virtual memory system that can dramatically improve performance for an experienced system administrator. Over five hundred system variables can be read and set using <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=paragraph><p>At its core, <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> serves two functions: to read and to modify system settings.</p></div><div class=paragraph><p>To view all readable variables:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>To read a particular variable, for example, <code>kern.maxproc</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>To set a particular variable, use the intuitive <em>variable</em>=<em>value</em> syntax:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>Settings of sysctl variables are usually either strings, numbers, or booleans (a boolean being <code>1</code> for yes or a <code>0</code> for no).</p></div><div class=paragraph><p>If you want to set automatically some variables each time the machine boots, add them to the <span class=filename>/etc/sysctl.conf</span> file. For more information see the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> manual page and the <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect2><h3 id=sysctl-readonly>28.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> Read-only<a class=anchor href=#sysctl-readonly></a></h3><div class=paragraph><p>In some cases it may be desirable to modify read-only <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> values. While this is sometimes unavoidable, it can only be done on (re)boot.</p></div><div class=paragraph><p>For instance on some laptop models the <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> device will not probe memory ranges, and fail with errors which look similar to:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>Cases like the one above usually require the modification of some default <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> settings which are set read only. To overcome these situations a user can put <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> "OIDs" in their local <span class=filename>/boot/loader.conf</span>. Default settings are located in the <span class=filename>/boot/defaults/loader.conf</span> file.</p></div><div class=paragraph><p>Fixing the problem mentioned above would require a user to set <code>hw.pci.allow_unsupported_io_range=1</code> in the aforementioned file. Now <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> will work properly.</p></div></div></div></div><div class=sect1><h2 id=configtuning-disk>Chapter 29. Tuning Disks<a class=anchor href=#configtuning-disk></a></h2><div class=sectionbody><div class=sect2><h3 id=_sysctl_variables>29.1. Sysctl Variables<a class=anchor href=#_sysctl_variables></a></h3><div class=sect3><h4 id=_vfs_vmiodirenable>29.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h4><div class=paragraph><p>The <code>vfs.vmiodirenable</code> sysctl variable may be set to either 0 (off) or 1 (on); it is 1 by default. This variable controls how directories are cached by the system. Most directories are small, using just a single fragment (typically 1 K) in the file system and less (typically 512 bytes) in the buffer cache. With this variable turned off (to 0), the buffer cache will only cache a fixed number of directories even if you have a huge amount of memory. When turned on (to 1), this sysctl allows the buffer cache to use the VM Page Cache to cache the directories, making all the memory available for caching directories. However, the minimum in-core memory used to cache a directory is the physical page size (typically 4 K) rather than 512 bytes. We recommend keeping this option on if you are running any services which manipulate large numbers of files. Such services can include web caches, large mail systems, and news systems. Keeping this option on will generally not reduce performance even with the wasted memory but you should experiment to find out.</p></div></div><div class=sect3><h4 id=_vfs_write_behind>29.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h4><div class=paragraph><p>The <code>vfs.write_behind</code> sysctl variable defaults to <code>1</code> (on). This tells the file system to issue media writes as full clusters are collected, which typically occurs when writing large sequential files. The idea is to avoid saturating the buffer cache with dirty buffers when it would not benefit I/O performance. However, this may stall processes and under certain circumstances you may wish to turn it off.</p></div></div><div class=sect3><h4 id=_vfs_hirunningspace>29.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h4><div class=paragraph><p>The <code>vfs.hirunningspace</code> sysctl variable determines how much outstanding write I/O may be queued to disk controllers system-wide at any given instance. The default is usually sufficient but on machines with lots of disks you may want to bump it up to four or five <em>megabytes</em>. Note that setting too high a value (exceeding the buffer cache’s write threshold) can lead to extremely bad clustering performance. Do not set this value arbitrarily high! Higher write values may add latency to reads occurring at the same time.</p></div><div class=paragraph><p>There are various other buffer-cache and VM page cache related sysctls. We do not recommend modifying these values, the VM system does an extremely good job of automatically tuning itself.</p></div></div><div class=sect3><h4 id=_vm_swap_idle_enabled>29.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h4><div class=paragraph><p>The <code>vm.swap_idle_enabled</code> sysctl variable is useful in large multi-user systems where you have lots of users entering and leaving the system and lots of idle processes. Such systems tend to generate a great deal of continuous pressure on free memory reserves. Turning this feature on and tweaking the swapout hysteresis (in idle seconds) via <code>vm.swap_idle_threshold1</code> and <code>vm.swap_idle_threshold2</code> allows you to depress the priority of memory pages associated with idle processes more quickly then the normal pageout algorithm. This gives a helping hand to the pageout daemon. Do not turn this option on unless you need it, because the tradeoff you are making is essentially pre-page memory sooner rather than later; thus eating more swap and disk bandwidth. In a small system this option will have a determinable effect but in a large system that is already doing moderate paging this option allows the VM system to stage whole processes into and out of memory easily.</p></div></div><div class=sect3><h4 id=_hw_ata_wc>29.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h4><div class=paragraph><p>FreeBSD 4.3 flirted with turning off IDE write caching. This reduced write bandwidth to IDE disks but was considered necessary due to serious data consistency issues introduced by hard drive vendors. The problem is that IDE drives lie about when a write completes. With IDE write caching turned on, IDE hard drives not only write data to disk out of order, but will sometimes delay writing some blocks indefinitely when under heavy disk loads. A crash or power failure may cause serious file system corruption. FreeBSD’s default was changed to be safe. Unfortunately, the result was such a huge performance loss that we changed write caching back to on by default after the release. You should check the default on your system by observing the <code>hw.ata.wc</code> sysctl variable. If IDE write caching is turned off, you can turn it back on by setting the kernel variable back to 1. This must be done from the boot loader at boot time. Attempting to do it after the kernel boots will have no effect.</p></div><div class=paragraph><p>For more information, please see <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect3><h4 id=_scsi_delay_kern_cam_scsi_delay>29.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h4><div class=paragraph><p>The <code>SCSI_DELAY</code> kernel config may be used to reduce system boot times. The defaults are fairly high and can be responsible for <code>15</code> seconds of delay in the boot process. Reducing it to <code>5</code> seconds usually works (especially with modern drives). Newer versions of FreeBSD (5.0 and higher) should use the <code>kern.cam.scsi_delay</code> boot time tunable. The tunable, and kernel config option accept values in terms of <em>milliseconds</em> and <em>not seconds</em>.</p></div></div></div><div class=sect2><h3 id=soft-updates>29.2. Soft Updates<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> program can be used to fine-tune a file system. This program has many different options, but for now we are only concerned with toggling Soft Updates on and off, which is done by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>A filesystem cannot be modified with <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> while it is mounted. A good time to enable Soft Updates is before any partitions have been mounted, in single-user mode.</p></div><div class=paragraph><p>Soft Updates drastically improves meta-data performance, mainly file creation and deletion, through the use of a memory cache. We recommend to use Soft Updates on all of your file systems. There are two downsides to Soft Updates that you should be aware of: First, Soft Updates guarantees filesystem consistency in the case of a crash but could very easily be several seconds (even a minute!) behind updating the physical disk. If your system crashes you may lose more work than otherwise. Secondly, Soft Updates delays the freeing of filesystem blocks. If you have a filesystem (such as the root filesystem) which is almost full, performing a major update, such as <code>make installworld</code>, can cause the filesystem to run out of space and the update to fail.</p></div><div class=sect3><h4 id=_more_details_about_soft_updates>29.2.1. More Details about Soft Updates<a class=anchor href=#_more_details_about_soft_updates></a></h4><div class=paragraph><p>There are two traditional approaches to writing a file systems meta-data back to disk. (Meta-data updates are updates to non-content data like inodes or directories.)</p></div><div class=paragraph><p>Historically, the default behavior was to write out meta-data updates synchronously. If a directory had been changed, the system waited until the change was actually written to disk. The file data buffers (file contents) were passed through the buffer cache and backed up to disk later on asynchronously. The advantage of this implementation is that it operates safely. If there is a failure during an update, the meta-data are always in a consistent state. A file is either created completely or not at all. If the data blocks of a file did not find their way out of the buffer cache onto the disk by the time of the crash, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> is able to recognize this and repair the filesystem by setting the file length to 0. Additionally, the implementation is clear and simple. The disadvantage is that meta-data changes are slow. An <code>rm -r</code>, for instance, touches all the files in a directory sequentially, but each directory change (deletion of a file) will be written synchronously to the disk. This includes updates to the directory itself, to the inode table, and possibly to indirect blocks allocated by the file. Similar considerations apply for unrolling large hierarchies (<code>tar -x</code>).</p></div><div class=paragraph><p>The second case is asynchronous meta-data updates. This is the default for Linux/ext2fs and <code>mount -o async</code> for *BSD ufs. All meta-data updates are simply being passed through the buffer cache too, that is, they will be intermixed with the updates of the file content data. The advantage of this implementation is there is no need to wait until each meta-data update has been written to disk, so all operations which cause huge amounts of meta-data updates work much faster than in the synchronous case. Also, the implementation is still clear and simple, so there is a low risk for bugs creeping into the code. The disadvantage is that there is no guarantee at all for a consistent state of the filesystem. If there is a failure during an operation that updated large amounts of meta-data (like a power failure, or someone pressing the reset button), the filesystem will be left in an unpredictable state. There is no opportunity to examine the state of the filesystem when the system comes up again; the data blocks of a file could already have been written to the disk while the updates of the inode table or the associated directory were not. It is actually impossible to implement a <code>fsck</code> which is able to clean up the resulting chaos (because the necessary information is not available on the disk). If the filesystem has been damaged beyond repair, the only choice is to use <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> on it and restore it from backup.</p></div><div class=paragraph><p>The usual solution for this problem was to implement <em>dirty region logging</em>, which is also referred to as <em>journaling</em>, although that term is not used consistently and is occasionally applied to other forms of transaction logging as well. Meta-data updates are still written synchronously, but only into a small region of the disk. Later on they will be moved to their proper location. Because the logging area is a small, contiguous region on the disk, there are no long distances for the disk heads to move, even during heavy operations, so these operations are quicker than synchronous updates. Additionally the complexity of the implementation is fairly limited, so the risk of bugs being present is low. A disadvantage is that all meta-data are written twice (once into the logging region and once to the proper location) so for normal work, a performance "pessimization" might result. On the other hand, in case of a crash, all pending meta-data operations can be quickly either rolled-back or completed from the logging area after the system comes up again, resulting in a fast filesystem startup.</p></div><div class=paragraph><p>Kirk McKusick, the developer of Berkeley FFS, solved this problem with Soft Updates: all pending meta-data updates are kept in memory and written out to disk in a sorted sequence ("ordered meta-data updates"). This has the effect that, in case of heavy meta-data operations, later updates to an item "catch" the earlier ones if the earlier ones are still in memory and have not already been written to disk. So all operations on, say, a directory are generally performed in memory before the update is written to disk (the data blocks are sorted according to their position so that they will not be on the disk ahead of their meta-data). If the system crashes, this causes an implicit "log rewind": all operations which did not find their way to the disk appear as if they had never happened. A consistent filesystem state is maintained that appears to be the one of 30 to 60 seconds earlier. The algorithm used guarantees that all resources in use are marked as such in their appropriate bitmaps: blocks and inodes. After a crash, the only resource allocation error that occurs is that resources are marked as "used" which are actually "free". <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> recognizes this situation, and frees the resources that are no longer used. It is safe to ignore the dirty state of the filesystem after a crash by forcibly mounting it with <code>mount -f</code>. In order to free resources that may be unused, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> needs to be run at a later time. This is the idea behind the <em>background fsck</em>: at system startup time, only a <em>snapshot</em> of the filesystem is recorded. The <code>fsck</code> can be run later on. All file systems can then be mounted "dirty", so the system startup proceeds in multiuser mode. Then, background <code>fsck</code>s will be scheduled for all file systems where this is required, to free resources that may be unused. (File systems that do not use Soft Updates still need the usual foreground <code>fsck</code> though.)</p></div><div class=paragraph><p>The advantage is that meta-data operations are nearly as fast as asynchronous updates (i.e. faster than with <em>logging</em>, which has to write the meta-data twice). The disadvantages are the complexity of the code (implying a higher risk for bugs in an area that is highly sensitive regarding loss of user data), and a higher memory consumption. Additionally there are some idiosyncrasies one has to get used to. After a crash, the state of the filesystem appears to be somewhat "older". In situations where the standard synchronous approach would have caused some zero-length files to remain after the <code>fsck</code>, these files do not exist at all with a Soft Updates filesystem because neither the meta-data nor the file contents have ever been written to disk. Disk space is not released until the updates have been written to disk, which may take place some time after running <code>rm</code>. This may cause problems when installing large amounts of data on a filesystem that does not have enough free space to hold all the files twice.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-kernel-limits>Chapter 30. Tuning Kernel Limits<a class=anchor href=#configtuning-kernel-limits></a></h2><div class=sectionbody><div class=sect2><h3 id=file-process-limits>30.1. File/Process Limits<a class=anchor href=#file-process-limits></a></h3><div class=sect3><h4 id=kern-maxfiles>30.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h4><div class=paragraph><p><code>kern.maxfiles</code> can be raised or lowered based upon your system requirements. This variable indicates the maximum number of file descriptors on your system. When the file descriptor table is full, <code>file: table is full</code> will show up repeatedly in the system message buffer, which can be viewed with the <code>dmesg</code> command.</p></div><div class=paragraph><p>Each open file, socket, or fifo uses one file descriptor. A large-scale production server may easily require many thousands of file descriptors, depending on the kind and number of services running concurrently.</p></div><div class=paragraph><p>In older FreeBSD releases, the default value of <code>kern.maxfiles</code> is derived from the <code>maxusers</code> option in your kernel configuration file. <code>kern.maxfiles</code> grows proportionally to the value of <code>maxusers</code>. When compiling a custom kernel, it is a good idea to set this kernel configuration option according to the uses of your system. From this number, the kernel is given most of its pre-defined limits. Even though a production machine may not actually have 256 users connected at once, the resources needed may be similar to a high-scale web server.</p></div><div class=paragraph><p>As of FreeBSD 4.5, <code>kern.maxusers</code> is automatically sized at boot based on the amount of memory available in the system, and may be determined at run-time by inspecting the value of the read-only <code>kern.maxusers</code> sysctl. Some sites will require larger or smaller values of <code>kern.maxusers</code> and may set it as a loader tunable; values of 64, 128, and 256 are not uncommon. We do not recommend going above 256 unless you need a huge number of file descriptors; many of the tunable values set to their defaults by <code>kern.maxusers</code> may be individually overridden at boot-time or run-time in <span class=filename>/boot/loader.conf</span> (see the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> man page or the <span class=filename>/boot/defaults/loader.conf</span> file for some hints) or as described elsewhere in this document. Systems older than FreeBSD 4.4 must set this value via the kernel <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> option <code>maxusers</code> instead.</p></div><div class=paragraph><p>In older releases, the system will auto-tune <code>maxusers</code> for you if you explicitly set it to <code>0</code>. When setting this option, you will want to set <code>maxusers</code> to at least 4, especially if you are using the X Window System or compiling software. The reason is that the most important table set by <code>maxusers</code> is the maximum number of processes, which is set to <code>20 + 16 * maxusers</code>, so if you set <code>maxusers</code> to 1, then you can only have 36 simultaneous processes, including the 18 or so that the system starts up at boot time and the 15 or so you will probably create when you start the X Window System. Even a simple task like reading a manual page will start up nine processes to filter, decompress, and view it. Setting <code>maxusers</code> to 64 will allow you to have up to 1044 simultaneous processes, which should be enough for nearly all uses. If, however, you see the dreaded error when trying to start another program, or are running a server with a large number of simultaneous users (like <code>ftp.FreeBSD.org</code>), you can always increase the number and rebuild.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>maxusers</code> does <em>not</em> limit the number of users which can log into your machine. It simply sets various table sizes to reasonable values considering the maximum number of users you will likely have on your system and how many processes each of them will be running. One keyword which <em>does</em> limit the number of simultaneous remote logins and X terminal windows is <a href=./#kernelconfig-ptys><code>pseudo-device pty 16</code></a>. With FreeBSD 5.X, you do not have to worry about this number since the <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> driver is "auto-cloning"; you simply use the line <code>device pty</code> in your configuration file.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_kern_ipc_somaxconn>30.1.2. <code>kern.ipc.somaxconn</code><a class=anchor href=#_kern_ipc_somaxconn></a></h4><div class=paragraph><p>The <code>kern.ipc.somaxconn</code> sysctl variable limits the size of the listen queue for accepting new TCP connections. The default value of <code>128</code> is typically too low for robust handling of new connections in a heavily loaded web server environment. For such environments, it is recommended to increase this value to <code>1024</code> or higher. The service daemon may itself limit the listen queue size (e.g. <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, or Apache) but will often have a directive in its configuration file to adjust the queue size. Large listen queues also do a better job of avoiding Denial of Service () attacks.</p></div></div></div><div class=sect2><h3 id=nmbclusters>30.2. Network Limits<a class=anchor href=#nmbclusters></a></h3><div class=paragraph><p>The <code>NMBCLUSTERS</code> kernel configuration option dictates the amount of network Mbufs available to the system. A heavily-trafficked server with a low number of Mbufs will hinder FreeBSD’s ability. Each cluster represents approximately 2 K of memory, so a value of 1024 represents 2 megabytes of kernel memory reserved for network buffers. A simple calculation can be done to figure out how many are needed. If you have a web server which maxes out at 1000 simultaneous connections, and each connection eats a 16 K receive and 16 K send buffer, you need approximately 32 MB worth of network buffers to cover the web server. A good rule of thumb is to multiply by 2, so 2x32 MB / 2 KB = 64 MB / 2 kB = 32768. We recommend values between 4096 and 32768 for machines with greater amounts of memory. Under no circumstances should you specify an arbitrarily high value for this parameter as it could lead to a boot time crash. The <code>-m</code> option to <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> may be used to observe network cluster use.</p></div><div class=paragraph><p><code>kern.ipc.nmbclusters</code> loader tunable should be used to tune this at boot time. Only older versions of FreeBSD will require you to use the <code>NMBCLUSTERS</code> kernel <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> option.</p></div><div class=paragraph><p>For busy servers that make extensive use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> system call, it may be necessary to increase the number of <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> buffers via the <code>NSFBUFS</code> kernel configuration option or by setting its value in <span class=filename>/boot/loader.conf</span> (see <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> for details). A common indicator that this parameter needs to be adjusted is when processes are seen in the <code>sfbufa</code> state. The sysctl variable <code>kern.ipc.nsfbufs</code> is a read-only glimpse at the kernel configured variable. This parameter nominally scales with <code>kern.maxusers</code>, however it may be necessary to tune accordingly.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Even though a socket has been marked as non-blocking, calling <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> on the non-blocking socket may result in the <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> call blocking until enough <code>struct sf_buf</code>'s are made available.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_net_inet_ip_portrange>30.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h4><div class=paragraph><p>The <code>net.inet.ip.portrange.*</code> sysctl variables control the port number ranges automatically bound to TCP and UDP sockets. There are three ranges: a low range, a default range, and a high range. Most network programs use the default range which is controlled by the <code>net.inet.ip.portrange.first</code> and <code>net.inet.ip.portrange.last</code>, which default to 1024 and 5000, respectively. Bound port ranges are used for outgoing connections, and it is possible to run the system out of ports under certain circumstances. This most commonly occurs when you are running a heavily loaded web proxy. The port range is not an issue when running servers which handle mainly incoming connections, such as a normal web server, or has a limited number of outgoing connections, such as a mail relay. For situations where you may run yourself out of ports, it is recommended to increase <code>net.inet.ip.portrange.last</code> modestly. A value of <code>10000</code>, <code>20000</code> or <code>30000</code> may be reasonable. You should also consider firewall effects when changing the port range. Some firewalls may block large ranges of ports (usually low-numbered ports) and expect systems to use higher ranges of ports for outgoing connections - for this reason it is not recommended that <code>net.inet.ip.portrange.first</code> be lowered.</p></div></div><div class=sect3><h4 id=_tcp_bandwidth_delay_product>30.2.2. TCP Bandwidth Delay Product<a class=anchor href=#_tcp_bandwidth_delay_product></a></h4><div class=paragraph><p>The TCP Bandwidth Delay Product Limiting is similar to TCP/Vegas in NetBSD. It can be enabled by setting <code>net.inet.tcp.inflight.enable</code> sysctl variable to <code>1</code>. The system will attempt to calculate the bandwidth delay product for each connection and limit the amount of data queued to the network to just the amount required to maintain optimum throughput.</p></div><div class=paragraph><p>This feature is useful if you are serving data over modems, Gigabit Ethernet, or even high speed WAN links (or any other link with a high bandwidth delay product), especially if you are also using window scaling or have configured a large send window. If you enable this option, you should also be sure to set <code>net.inet.tcp.inflight.debug</code> to <code>0</code> (disable debugging), and for production use setting <code>net.inet.tcp.inflight.min</code> to at least <code>6144</code> may be beneficial. However, note that setting high minimums may effectively disable bandwidth limiting depending on the link. The limiting feature reduces the amount of data built up in intermediate route and switch packet queues as well as reduces the amount of data built up in the local host’s interface queue. With fewer packets queued up, interactive connections, especially over slow modems, will also be able to operate with lower <em>Round Trip Times</em>. However, note that this feature only effects data transmission (uploading / server side). It has no effect on data reception (downloading).</p></div><div class=paragraph><p>Adjusting <code>net.inet.tcp.inflight.stab</code> is <em>not</em> recommended. This parameter defaults to 20, representing 2 maximal packets added to the bandwidth delay product window calculation. The additional window is required to stabilize the algorithm and improve responsiveness to changing conditions, but it can also result in higher ping times over slow links (though still much lower than you would get without the inflight algorithm). In such cases, you may wish to try reducing this parameter to 15, 10, or 5; and may also have to reduce <code>net.inet.tcp.inflight.min</code> (for example, to 3500) to get the desired effect. Reducing these parameters should be done as a last resort only.</p></div></div></div><div class=sect2><h3 id=_virtual_memory>30.3. Virtual Memory<a class=anchor href=#_virtual_memory></a></h3><div class=sect3><h4 id=_kern_maxvnodes>30.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h4><div class=paragraph><p>A vnode is the internal representation of a file or directory. So increasing the number of vnodes available to the operating system cuts down on disk I/O. Normally this is handled by the operating system and does not need to be changed. In some cases where disk I/O is a bottleneck and the system is running out of vnodes, this setting will need to be increased. The amount of inactive and free RAM will need to be taken into account.</p></div><div class=paragraph><p>To see the current number of vnodes in use:</p></div><div class="literalblock programlisting"><div class=content><pre>#  sysctl vfs.numvnodes
vfs.numvnodes: 91349</pre></div></div><div class=paragraph><p>To see the maximum vnodes:</p></div><div class="literalblock programlisting"><div class=content><pre>#  sysctl kern.maxvnodes
kern.maxvnodes: 100000</pre></div></div><div class=paragraph><p>If the current vnode usage is near the maximum, increasing <code>kern.maxvnodes</code> by a value of 1,000 is probably a good idea. Keep an eye on the number of <code>vfs.numvnodes</code>. If it climbs up to the maximum again, <code>kern.maxvnodes</code> will need to be increased further. A shift in your memory usage as reported by <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> should be visible. More memory should be active.</p></div></div></div></div></div><div class=sect1><h2 id=adding-swap-space>Chapter 31. Adding Swap Space<a class=anchor href=#adding-swap-space></a></h2><div class=sectionbody><div class=paragraph><p>No matter how well you plan, sometimes a system does not run as you expect. If you find you need more swap space, it is simple enough to add. You have three ways to increase swap space: adding a new hard drive, enabling swap over NFS, and creating a swap file on an existing partition.</p></div><div class=paragraph><p>For information on how to encrypt swap space, what options for this task exist and why it should be done, please refer to <a href=./#swap-encrypting>Encrypting Swap Space</a> of the Handbook.</p></div><div class=sect2><h3 id=new-drive-swap>31.1. Swap on a New Hard Drive<a class=anchor href=#new-drive-swap></a></h3><div class=paragraph><p>The best way to add swap, of course, is to use this as an excuse to add another hard drive. You can always use another hard drive, after all. If you can do this, go reread the discussion of swap space in <a href=#configtuning-initial>Αρχική Ρύθμιση</a> of the Handbook for some suggestions on how to best arrange your swap.</p></div></div><div class=sect2><h3 id=nfs-swap>31.2. Swapping over NFS<a class=anchor href=#nfs-swap></a></h3><div class=paragraph><p>Swapping over NFS is only recommended if you do not have a local hard disk to swap to; NFS swapping will be limited by the available network bandwidth and puts an additional burden on the NFS server.</p></div></div><div class=sect2><h3 id=create-swapfile>31.3. Swapfiles<a class=anchor href=#create-swapfile></a></h3><div class=paragraph><p>You can create a file of a specified size to use as a swap file. In our example here we will use a 64MB file called <span class=filename>/usr/swap0</span>. You can use any name you want, of course.</p></div><div class=exampleblock><div class=title>Παράδειγμα 7. Creating a Swapfile on FreeBSD</div><div class=content><div class="olist arabic"><ol class=arabic><li><p>Be certain that your kernel configuration includes the memory disk driver (<a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>). It is default in <span class=filename>GENERIC</span> kernel.</p><div class="literalblock programlisting"><div class=content><pre>device   md   # Memory &#34;disks&#34;</pre></div></div></li><li><p>Create a swapfile (<span class=filename>/usr/swap0</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</span></code></pre></div></div></li><li><p>Set proper permissions on (<span class=filename>/usr/swap0</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Enable the swap file in <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>swapfile=&#34;/usr/swap0&#34;   # Set to name of swapfile if aux swapfile desired.</pre></div></div></li><li><p>Reboot the machine or to enable the swap file immediately, type:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=acpi-overview>Chapter 32. Power and Resource Management<a class=anchor href=#acpi-overview></a></h2><div class=sectionbody><div class=paragraph><p>It is important to utilize hardware resources in an efficient manner. Before ACPI was introduced, it was difficult and inflexible for operating systems to manage the power usage and thermal properties of a system. The hardware was managed by the BIOS and thus the user had less control and visibility into the power management settings. Some limited configurability was available via <em>Advanced Power Management (APM)</em>. Power and resource management is one of the key components of a modern operating system. For example, you may want an operating system to monitor system limits (and possibly alert you) in case your system temperature increased unexpectedly.</p></div><div class=paragraph><p>In this section of the FreeBSD Handbook, we will provide comprehensive information about ACPI. References will be provided for further reading at the end.</p></div><div class=sect2><h3 id=acpi-intro>32.1. What Is ACPI?<a class=anchor href=#acpi-intro></a></h3><div class=paragraph><p>Advanced Configuration and Power Interface (ACPI) is a standard written by an alliance of vendors to provide a standard interface for hardware resources and power management (hence the name). It is a key element in <em>Operating System-directed configuration and Power Management</em>, i.e.: it provides more control and flexibility to the operating system (OS). Modern systems "stretched" the limits of the current Plug and Play interfaces prior to the introduction of ACPI. ACPI is the direct successor to APM (Advanced Power Management).</p></div></div><div class=sect2><h3 id=acpi-old-spec>32.2. Shortcomings of Advanced Power Management (APM)<a class=anchor href=#acpi-old-spec></a></h3><div class=paragraph><p>The <em>Advanced Power Management (APM)</em> facility controls the power usage of a system based on its activity. The APM BIOS is supplied by the (system) vendor and it is specific to the hardware platform. An APM driver in the OS mediates access to the <em>APM Software Interface</em>, which allows management of power levels. APM should still be used for systems manufactured at or before the year 2000.</p></div><div class=paragraph><p>There are four major problems in APM. Firstly, power management is done by the (vendor-specific) BIOS, and the OS does not have any knowledge of it. One example of this, is when the user sets idle-time values for a hard drive in the APM BIOS, that when exceeded, it (BIOS) would spin down the hard drive, without the consent of the OS. Secondly, the APM logic is embedded in the BIOS, and it operates outside the scope of the OS. This means users can only fix problems in their APM BIOS by flashing a new one into the ROM; which is a very dangerous procedure with the potential to leave the system in an unrecoverable state if it fails. Thirdly, APM is a vendor-specific technology, which means that there is a lot of parity (duplication of efforts) and bugs found in one vendor’s BIOS, may not be solved in others. Last but not the least, the APM BIOS did not have enough room to implement a sophisticated power policy, or one that can adapt very well to the purpose of the machine.</p></div><div class=paragraph><p><em>Plug and Play BIOS (PNPBIOS)</em> was unreliable in many situations. PNPBIOS is 16-bit technology, so the OS has to use 16-bit emulation in order to "interface" with PNPBIOS methods.</p></div><div class=paragraph><p>The FreeBSD APM driver is documented in the <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a> manual page.</p></div></div><div class=sect2><h3 id=acpi-config>32.3. Configuring ACPI<a class=anchor href=#acpi-config></a></h3><div class=paragraph><p>The <span class=filename>acpi.ko</span> driver is loaded by default at start up by the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> and should <em>not</em> be compiled into the kernel. The reasoning behind this is that modules are easier to work with, say if switching to another <span class=filename>acpi.ko</span> without doing a kernel rebuild. This has the advantage of making testing easier. Another reason is that starting ACPI after a system has been brought up often doesn’t work well. If you are experiencing problems, you can disable ACPI altogether. This driver should not and can not be unloaded because the system bus uses it for various hardware interactions. ACPI can be disabled by setting <code>hint.acpi.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span> or at the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> prompt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ACPI and APM cannot coexist and should be used separately. The last one to load will terminate if the driver notices the other running.</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACPI can be used to put the system into a sleep mode with <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a>, the <code>-s</code> flag, and a <code>1-5</code> option. Most users will only need <code>1</code> or <code>3</code> (suspend to RAM). Option <code>5</code> will do a soft-off which is the same action as:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># halt -p</span></code></pre></div></div><div class=paragraph><p>Other options are available via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Check out the <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> manual pages for more information.</p></div></div></div></div><div class=sect1><h2 id=ACPI-debug>Chapter 33. Using and Debugging FreeBSD ACPI<a class=anchor href=#ACPI-debug></a></h2><div class=sectionbody><div class=paragraph><p>ACPI is a fundamentally new way of discovering devices, managing power usage, and providing standardized access to various hardware previously managed by the BIOS. Progress is being made toward ACPI working on all systems, but bugs in some motherboards' <em>ACPI Machine Language</em> (AML) bytecode, incompleteness in FreeBSD’s kernel subsystems, and bugs in the Intel® ACPI-CA interpreter continue to appear.</p></div><div class=paragraph><p>This document is intended to help you assist the FreeBSD ACPI maintainers in identifying the root cause of problems you observe and debugging and developing a solution. Thanks for reading this and we hope we can solve your system’s problems.</p></div><div class=sect2><h3 id=ACPI-submitdebug>33.1. Submitting Debugging Information<a class=anchor href=#ACPI-submitdebug></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Before submitting a problem, be sure you are running the latest BIOS version and, if available, embedded controller firmware version.</p></div></td></tr></tbody></table></div><div class=paragraph><p>For those of you that want to submit a problem right away, please send the following information to <a href=mailto:freebsd-acpi@FreeBSD.org></a><a href=mailto:freebsd-acpi@FreeBSD.org>freebsd-acpi@FreeBSD.org</a>:</p></div><div class=ulist><ul><li><p>Description of the buggy behavior, including system type and model and anything that causes the bug to appear. Also, please note as accurately as possible when the bug began occurring if it is new for you.</p></li><li><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> output after <code>boot -v</code>, including any error messages generated by you exercising the bug.</p></li><li><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> output from <code>boot -v</code> with ACPI disabled, if disabling it helps fix the problem.</p></li><li><p>Output from <code>sysctl hw.acpi</code>. This is also a good way of figuring out what features your system offers.</p></li><li><p>URL where your <em>ACPI Source Language</em> (ASL) can be found. Do <em>not</em> send the ASL directly to the list as it can be very large. Generate a copy of your ASL by running this command:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>(Substitute your login name for <em>name</em> and manufacturer/model for <em>system</em>. Example: <span class=filename>njl-FooCo6000.asl</span>)</p></div></li></ul></div><div class=paragraph><p>Most of the developers watch the <a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a> but please submit problems to <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>ηλεκτρονική λίστα για ACPI του FreeBSD</a> to be sure it is seen. Please be patient, all of us have full-time jobs elsewhere. If your bug is not immediately apparent, we will probably ask you to submit a PR via <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. When entering a PR, please include the same information as requested above. This will help us track the problem and resolve it. Do not send a PR without emailing <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>ηλεκτρονική λίστα για ACPI του FreeBSD</a> first as we use PRs as reminders of existing problems, not a reporting mechanism. It is likely that your problem has been reported by someone before.</p></div></div><div class=sect2><h3 id=ACPI-background>33.2. Background<a class=anchor href=#ACPI-background></a></h3><div class=paragraph><p>ACPI is present in all modern computers that conform to the ia32 (x86), ia64 (Itanium), and amd64 (AMD) architectures. The full standard has many features including CPU performance management, power planes control, thermal zones, various battery systems, embedded controllers, and bus enumeration. Most systems implement less than the full standard. For instance, a desktop system usually only implements the bus enumeration parts while a laptop might have cooling and battery management support as well. Laptops also have suspend and resume, with their own associated complexity.</p></div><div class=paragraph><p>An ACPI-compliant system has various components. The BIOS and chipset vendors provide various fixed tables (e.g., FADT) in memory that specify things like the APIC map (used for SMP), config registers, and simple configuration values. Additionally, a table of bytecode (the <em>Differentiated System Description Table</em> DSDT) is provided that specifies a tree-like name space of devices and methods.</p></div><div class=paragraph><p>The ACPI driver must parse the fixed tables, implement an interpreter for the bytecode, and modify device drivers and the kernel to accept information from the ACPI subsystem. For FreeBSD, Intel® has provided an interpreter (ACPI-CA) that is shared with Linux and NetBSD. The path to the ACPI-CA source code is <span class=filename>src/sys/contrib/dev/acpica</span>. The glue code that allows ACPI-CA to work on FreeBSD is in <span class=filename>src/sys/dev/acpica/Osd</span>. Finally, drivers that implement various ACPI devices are found in <span class=filename>src/sys/dev/acpica</span>.</p></div></div><div class=sect2><h3 id=ACPI-comprob>33.3. Common Problems<a class=anchor href=#ACPI-comprob></a></h3><div class=paragraph><p>For ACPI to work correctly, all the parts have to work correctly. Here are some common problems, in order of frequency of appearance, and some possible workarounds or fixes.</p></div><div class=sect3><h4 id=_mouse_issues>33.3.1. Mouse Issues<a class=anchor href=#_mouse_issues></a></h4><div class=paragraph><p>In some cases, resuming from a suspend operation will cause the mouse to fail. A known work around is to add <code>hint.psm.0.flags="0x3000"</code> to the <span class=filename>/boot/loader.conf</span> file. If this does not work then please consider sending a bug report as described above.</p></div></div><div class=sect3><h4 id=_suspendresume>33.3.2. Suspend/Resume<a class=anchor href=#_suspendresume></a></h4><div class=paragraph><p>ACPI has three suspend to RAM (STR) states, <code>S1</code>-<code>S3</code>, and one suspend to disk state (<code>STD</code>), called <code>S4</code>. <code>S5</code> is "soft off" and is the normal state your system is in when plugged in but not powered up. <code>S4</code> can actually be implemented two separate ways. <code>S4</code>BIOS is a BIOS-assisted suspend to disk. <code>S4</code>OS is implemented entirely by the operating system.</p></div><div class=paragraph><p>Start by checking <code>sysctl hw.acpi</code> for the suspend-related items. Here are the results for a Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>This means that we can use <code>acpiconf -s</code> to test <code>S3</code>, <code>S4</code>OS, and <code>S5</code>. If <code>s4bios</code> was one (<code>1</code>), we would have <code>S4</code>BIOS support instead of <code>S4</code>OS.</p></div><div class=paragraph><p>When testing suspend/resume, start with <code>S1</code>, if supported. This state is most likely to work since it does not require much driver support. No one has implemented <code>S2</code> but if you have it, it is similar to <code>S1</code>. The next thing to try is <code>S3</code>. This is the deepest STR state and requires a lot of driver support to properly reinitialize your hardware. If you have problems resuming, feel free to email the <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>ηλεκτρονική λίστα για ACPI του FreeBSD</a> list but do not expect the problem to be resolved since there are a lot of drivers/hardware that need more testing and work.</p></div><div class=paragraph><p>To help isolate the problem, remove as many drivers from your kernel as possible. If it works, you can narrow down which driver is the problem by loading drivers until it fails again. Typically binary drivers like <span class=filename>nvidia.ko</span>, X11 display drivers, and USB will have the most problems while Ethernet interfaces usually work fine. If you can properly load/unload the drivers, you can automate this by putting the appropriate commands in <span class=filename>/etc/rc.suspend</span> and <span class=filename>/etc/rc.resume</span>. There is a commented-out example for unloading and loading a driver. Try setting <code>hw.acpi.reset_video</code> to zero (<code>0</code>) if your display is messed up after resume. Try setting longer or shorter values for <code>hw.acpi.sleep_delay</code> to see if that helps.</p></div><div class=paragraph><p>Another thing to try is load a recent Linux distribution with ACPI support and test their suspend/resume support on the same hardware. If it works on Linux, it is likely a FreeBSD driver problem and narrowing down which driver causes the problems will help us fix the problem. Note that the ACPI maintainers do not usually maintain other drivers (e.g sound, ATA, etc.) so any work done on tracking down a driver problem should probably eventually be posted to the <a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a> list and mailed to the driver maintainer. If you are feeling adventurous, go ahead and start putting some debugging <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>s in a problematic driver to track down where in its resume function it hangs.</p></div><div class=paragraph><p>Finally, try disabling ACPI and enabling APM instead. If suspend/resume works with APM, you may be better off sticking with APM, especially on older hardware (pre-2000). It took vendors a while to get ACPI support correct and older hardware is more likely to have BIOS problems with ACPI.</p></div></div><div class=sect3><h4 id=_system_hangs_temporary_or_permanent>33.3.3. System Hangs (temporary or permanent)<a class=anchor href=#_system_hangs_temporary_or_permanent></a></h4><div class=paragraph><p>Most system hangs are a result of lost interrupts or an interrupt storm. Chipsets have a lot of problems based on how the BIOS configures interrupts before boot, correctness of the APIC (MADT) table, and routing of the <em>System Control Interrupt</em> (SCI).</p></div><div class=paragraph><p>Interrupt storms can be distinguished from lost interrupts by checking the output of <code>vmstat -i</code> and looking at the line that has <code>acpi0</code>. If the counter is increasing at more than a couple per second, you have an interrupt storm. If the system appears hung, try breaking to DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> on console) and type <code>show interrupts</code>.</p></div><div class=paragraph><p>Your best hope when dealing with interrupt problems is to try disabling APIC support with <code>hint.apic.0.disabled="1"</code> in <span class=filename>loader.conf</span>.</p></div></div><div class=sect3><h4 id=_panics>33.3.4. Panics<a class=anchor href=#_panics></a></h4><div class=paragraph><p>Panics are relatively rare for ACPI and are the top priority to be fixed. The first step is to isolate the steps to reproduce the panic (if possible) and get a backtrace. Follow the advice for enabling <code>options DDB</code> and setting up a serial console (see <a href=./#serialconsole-ddb>Είσοδος στον DDB Debugger Μέσω της Σειριακής Γραμμής</a>) or setting up a <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> partition. You can get a backtrace in DDB with <code>tr</code>. If you have to handwrite the backtrace, be sure to at least get the lowest five (5) and top five (5) lines in the trace.</p></div><div class=paragraph><p>Then, try to isolate the problem by booting with ACPI disabled. If that works, you can isolate the ACPI subsystem by using various values of <code>debug.acpi.disable</code>. See the <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> manual page for some examples.</p></div></div><div class=sect3><h4 id=_system_powers_up_after_suspend_or_shutdown>33.3.5. System Powers Up After Suspend or Shutdown<a class=anchor href=#_system_powers_up_after_suspend_or_shutdown></a></h4><div class=paragraph><p>First, try setting <code>hw.acpi.disable_on_poweroff="0"</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>. This keeps ACPI from disabling various events during the shutdown process. Some systems need this value set to <code>1</code> (the default) for the same reason. This usually fixes the problem of a system powering up spontaneously after a suspend or poweroff.</p></div></div><div class=sect3><h4 id=_other_problems>33.3.6. Other Problems<a class=anchor href=#_other_problems></a></h4><div class=paragraph><p>If you have other problems with ACPI (working with a docking station, devices not detected, etc.), please email a description to the mailing list as well; however, some of these issues may be related to unfinished parts of the ACPI subsystem so they might take a while to be implemented. Please be patient and prepared to test patches we may send you.</p></div></div></div><div class=sect2><h3 id=ACPI-aslanddump>33.4. ASL, <code>acpidump</code>, and IASL<a class=anchor href=#ACPI-aslanddump></a></h3><div class=paragraph><p>The most common problem is the BIOS vendors providing incorrect (or outright buggy!) bytecode. This is usually manifested by kernel console messages like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Often, you can resolve these problems by updating your BIOS to the latest revision. Most console messages are harmless but if you have other problems like battery status not working, they are a good place to start looking for problems in the AML. The bytecode, known as AML, is compiled from a source language called ASL. The AML is found in the table known as the DSDT. To get a copy of your ASL, use <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>. You should use both the <code>-t</code> (show contents of the fixed tables) and <code>-d</code> (disassemble AML to ASL) options. See the <a href=#ACPI-submitdebug>Submitting Debugging Information</a> section for an example syntax.</p></div><div class=paragraph><p>The simplest first check you can do is to recompile your ASL to check for errors. Warnings can usually be ignored but errors are bugs that will usually prevent ACPI from working correctly. To recompile your ASL, issue the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div></div><div class=sect2><h3 id=ACPI-fixasl>33.5. Fixing Your ASL<a class=anchor href=#ACPI-fixasl></a></h3><div class=paragraph><p>In the long run, our goal is for almost everyone to have ACPI work without any user intervention. At this point, however, we are still developing workarounds for common mistakes made by the BIOS vendors. The Microsoft® interpreter (<span class=filename>acpi.sys</span> and <span class=filename>acpiec.sys</span>) does not strictly check for adherence to the standard, and thus many BIOS vendors who only test ACPI under Windows® never fix their ASL. We hope to continue to identify and document exactly what non-standard behavior is allowed by Microsoft®'s interpreter and replicate it so FreeBSD can work without forcing users to fix the ASL. As a workaround and to help us identify behavior, you can fix the ASL manually. If this works for you, please send a <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> of the old and new ASL so we can possibly work around the buggy behavior in ACPI-CA and thus make your fix unnecessary.</p></div><div class=paragraph><p>Here is a list of common error messages, their cause, and how to fix them:</p></div><div class=sect3><h4 id=_os_dependencies>33.5.1. _OS dependencies<a class=anchor href=#_os_dependencies></a></h4><div class=paragraph><p>Some AML assumes the world consists of various Windows® versions. You can tell FreeBSD to claim it is any OS to see if this fixes problems you may have. An easy way to override this is to set <code>hw.acpi.osname="Windows 2001"</code> in <span class=filename>/boot/loader.conf</span> or other similar strings you find in the ASL.</p></div></div><div class=sect3><h4 id=_missing_return_statements>33.5.2. Missing Return statements<a class=anchor href=#_missing_return_statements></a></h4><div class=paragraph><p>Some methods do not explicitly return a value as the standard requires. While ACPI-CA does not handle this, FreeBSD has a workaround that allows it to return the value implicitly. You can also add explicit Return statements where required if you know what value should be returned. To force <code>iasl</code> to compile the ASL, use the <code>-f</code> flag.</p></div></div><div class=sect3><h4 id=_overriding_the_default_aml>33.5.3. Overriding the Default AML<a class=anchor href=#_overriding_the_default_aml></a></h4><div class=paragraph><p>After you customize <span class=filename>your.asl</span>, you will want to compile it, run:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div><div class=paragraph><p>You can add the <code>-f</code> flag to force creation of the AML, even if there are errors during compilation. Remember that some errors (e.g., missing Return statements) are automatically worked around by the interpreter.</p></div><div class=paragraph><p><span class=filename>DSDT.aml</span> is the default output filename for <code>iasl</code>. You can load this instead of your BIOS’s buggy copy (which is still present in flash memory) by editing <span class=filename>/boot/loader.conf</span> as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Be sure to copy your <span class=filename>DSDT.aml</span> to the <span class=filename>/boot</span> directory.</p></div></div></div><div class=sect2><h3 id=ACPI-debugoutput>33.6. Getting Debugging Output From ACPI<a class=anchor href=#ACPI-debugoutput></a></h3><div class=paragraph><p>The ACPI driver has a very flexible debugging facility. It allows you to specify a set of subsystems as well as the level of verbosity. The subsystems you wish to debug are specified as "layers" and are broken down into ACPI-CA components (ACPI_ALL_COMPONENTS) and ACPI hardware support (ACPI_ALL_DRIVERS). The verbosity of debugging output is specified as the "level" and ranges from ACPI_LV_ERROR (just report errors) to ACPI_LV_VERBOSE (everything). The "level" is a bitmask so multiple options can be set at once, separated by spaces. In practice, you will want to use a serial console to log the output if it is so long it flushes the console message buffer. A full list of the individual layers and levels is found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> manual page.</p></div><div class=paragraph><p>Debugging output is not enabled by default. To enable it, add <code>options ACPI_DEBUG</code> to your kernel configuration file if ACPI is compiled into the kernel. You can add <code>ACPI_DEBUG=1</code> to your <span class=filename>/etc/make.conf</span> to enable it globally. If it is a module, you can recompile just your <span class=filename>acpi.ko</span> module as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi</span>
<span class=o>&amp;&amp;</span> make clean <span class=o>&amp;&amp;</span>
make <span class=nv>ACPI_DEBUG</span><span class=o>=</span>1</code></pre></div></div><div class=paragraph><p>Install <span class=filename>acpi.ko</span> in <span class=filename>/boot/kernel</span> and add your desired level and layer to <span class=filename>loader.conf</span>. This example enables debug messages for all ACPI-CA components and all ACPI hardware drivers (CPU, LID, etc.). It will only output error messages, the least verbose level.</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>If the information you want is triggered by a specific event (say, a suspend and then resume), you can leave out changes to <span class=filename>loader.conf</span> and instead use <code>sysctl</code> to specify the layer and level after booting and preparing your system for the specific event. The <code>sysctl</code>s are named the same as the tunables in <span class=filename>loader.conf</span>.</p></div></div><div class=sect2><h3 id=ACPI-References>33.7. References<a class=anchor href=#ACPI-References></a></h3><div class=paragraph><p>More information about ACPI may be found in the following locations:</p></div><div class=ulist><ul><li><p>The <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>ηλεκτρονική λίστα για ACPI του FreeBSD</a></p></li><li><p>The ACPI Mailing List Archives <a href=http://lists.freebsd.org/pipermail/freebsd-acpi/>http://lists.freebsd.org/pipermail/freebsd-acpi/</a></p></li><li><p>The old ACPI Mailing List Archives <a href=http://home.jp.FreeBSD.org/mail-list/acpi-jp/>http://home.jp.FreeBSD.org/mail-list/acpi-jp/</a></p></li><li><p>The <a href=https://uefi.org/specifications#ACPI>ACPI Specification</a></p></li><li><p>FreeBSD Manual pages: <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li><li><p><a href=http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt>DSDT debugging resource</a>. (Uses Compaq as an example but generally useful.)</p></li></ul></div></div></div></div><div class=sect1><h2 id=boot>Chapter 34. Η Διαδικασία Εκκίνησης του FreeBSD<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>34.1. Σύνοψη<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>Η διαδικασία της εκκίνησης ενός υπολογιστή και φόρτωσης του λειτουργικού συστήματος αναφέρεται ως "διαδικασία bootstrap", ή απλώς "booting". Η διαδικασία εκκίνησης του FreeBSD μπορεί να προσαρμοστεί πολύ εύκολα στις απαιτήσεις σας, επιτρέποντας σάς να επιλέξετε είτε διαφορετικά λειτουργικά συστήματα που είναι εγκατεστημένα στον ίδιο υπολογιστή, ή ακόμα και διαφορετικές εκδόσεις του ίδιου λειτουργικού συστήματός ή του εγκατεστημένου πυρήνα.</p></div><div class=paragraph><p>Το κεφάλαιο αυτό περιγράφει λεπτομερώς τις επιλογές ρυθμίσεων που μπορείτε να κάνετε και πως να φέρετε στα μέτρα σας τη διαδικασία εκκίνησης του FreeBSD. Η διαδικασία εκκίνησης περιλαμβάνει οτιδήποτε συμβαίνει από την εκκίνηση του πυρήνα του FreeBSD, την ανίχνευση των συσκευών, μέχρι και την εκκίνηση της <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. Η εκκίνηση της <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> σηματοδοτείται από την αλλαγή χρώματος του κειμένου από φωτεινό λευκό σε γκρι.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Ποια είναι τα τμήματα του συστήματος εκκίνησης του FreeBSD, και πως αλληλεπιδρούν μεταξύ τους.</p></li><li><p>Τις επιλογές που μπορείτε να δώσετε στα τμήματα της εκκίνησης του FreeBSD για να ελέγξετε τη διαδικασία εκκίνησης.</p></li><li><p>Τα βασικά του <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Μόνο για υπολογιστές αρχιτεκτονικής x86</div><div class=paragraph><p>Το κεφάλαιο αυτό περιγράφει τη διαδικασία εκκίνησης του FreeBSD μόνο σε συστήματα αρχιτεκτονικής Intel x86.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=boot-introduction>34.2. Το Πρόβλημα της Εκκίνησης<a class=anchor href=#boot-introduction></a></h3><div class=paragraph><p>Η ενεργοποίηση ενός υπολογιστή και η εκκίνηση του λειτουργικού συστήματος, μας φέρνει αντιμέτωπους με ένα ενδιαφέρον δίλημμα. Εξ' ορισμού, ο υπολογιστής δεν ξέρει να κάνει τίποτα μέχρι την εκκίνηση του λειτουργικού συστήματος. Αυτό περιλαμβάνει και την εκτέλεση προγραμμάτων από το δίσκο. Έτσι, αν ο υπολογιστής δεν μπορεί να εκτελέσει προγράμματα από το δίσκο χωρίς το λειτουργικό σύστημα, αλλά και τα προγράμματα του λειτουργικού συστήματος είναι επίσης στο δίσκο, πως είναι δυνατή η εκκίνηση του λειτουργικού;</p></div><div class=paragraph><p>Το πρόβλημα μοιάζει με αυτό στο βιβλίο Οι Περιπέτειες του Βαρώνου Μινχάουζεν. Ένας χαρακτήρας έχει πέσει σε ένα πηγάδι, και βγαίνει πιάνοντας και τραβώντας τα κορδόνια του (bootstraps). Στις πρώτες μέρες των υπολογιστών, χρησιμοποιούνταν ο όρος <em>bootstrap</em> για το μηχανισμό φόρτωσης του λειτουργικού συστήματος, το οποίο συντομεύτηκε σε "booting".</p></div><div class=paragraph><p>Στην αρχιτεκτονική x86, το Βασικό Σύστημα Εισόδου Εξόδου (BIOS) είναι υπεύθυνο για τη φόρτωση του λειτουργικού συστήματος. Για να το επιτύχει αυτό, το BIOS ανιχνεύει το σκληρό δίσκο για την Κεντρική Εγγραφή Εκκίνησης (Master Boot Record, MBR), η οποία πρέπει να βρίσκεται σε συγκεκριμένο σημείο στο δίσκο. Το BIOS γνωρίζει αρκετά για να φορτώσει και να εκτελέσει το MBR, και υποθέτει ότι το MBR μπορεί κατόπιν να εκτελέσει την υπόλοιπη διαδικασία φόρτωσης του λειτουργικού συστήματος, ενδεχομένως και με τη βοήθεια του BIOS.</p></div><div class=paragraph><p>Ο κώδικας μέσα στο MBR συνήθως αναφέρεται ως <em>διαχειριστής εκκίνησης (boot manager)</em>, ειδικά όταν αλληλεπιδρά με το χρήστη. Στην περίπτωση αυτή, ο διαχειριστής εκκίνησης έχει συνήθως περισσότερο κώδικα στην πρώτη <em>τροχιά (track)</em> του δίσκου ή μέσα σε κάποιο σύστημα αρχείων του λειτουργικού. (Μερικές φορές ο διαχειριστής εκκίνησης αποκαλείται και <em>φορτωτής εκκίνησης (boot loader)</em>, αλλά στο FreeBSD ο όρος αυτός χρησιμοποιείται σε μεταγενέστερο στάδιο της εκκίνησης.) Στους δημοφιλείς διαχειριστές εκκίνησης περιλαμβάνονται το boot0 (γνωστό και ως Boot Easy, ο στάνταρ διαχειριστής εκκίνησης του FreeBSD), το Grub, το GAG, και το LILO. (Μόνο το boot0 χωράει μέσα στο MBR.)</p></div><div class=paragraph><p>Αν έχετε εγκατεστημένο ένα μόνο λειτουργικό σύστημα στους δίσκους σας, το τυποποιημένο MBR για PC είναι επαρκές. Αυτό το MBR ψάχνει για το πρώτο εκκινήσιμο (ή ενεργό) διαμέρισμα (slice) στο δίσκο, και εκτελεί τον κώδικα που υπάρχει σε αυτό για να φορτώσει το υπόλοιπο του λειτουργικού συστήματος. Ένα MBR αυτού του τύπου, είναι αυτό που εγκαθίσταται από προεπιλογή με την <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>. Βασίζεται στο <span class=filename>/boot/mbr</span>.</p></div><div class=paragraph><p>Αν έχετε εγκαταστήσει πολλαπλά λειτουργικά συστήματα στους δίσκους σας, μπορείτε να εγκαταστήσετε διαφορετικό διαχειριστή εκκίνησης, κάποιον που να μπορεί να δείξει μια λίστα των διαφορετικών συστημάτων και να σας επιτρέψει να διαλέξετε ποιο να ξεκινήσει. Στο επόμενο τμήμα θα συζητήσουμε για δύο από αυτούς τους διαχειριστές εκκίνησης.</p></div><div class=paragraph><p>Το υπόλοιπο του συστήματος εκκίνησης του FreeBSD είναι χωρισμένο σε τρία στάδια. Το πρώτο στάδιο εκτελείται από το MBR, το οποίο γνωρίζει απλώς ότι απαιτείται για να φέρει τον υπολογιστή σε μια συγκεκριμένη κατάσταση και να εκτελέσει το δεύτερο στάδιο. Το δεύτερο στάδιο μπορεί να κάνει λίγα περισσότερα πράγματα πριν την εκτέλεση του τρίτου σταδίου. Το τρίτο στάδιο ολοκληρώνει τη διαδικασία φόρτωσης του λειτουργικού συστήματος. Η εργασία γίνεται σε τρία στάδια, γιατί το πρότυπο του PC επιβάλλει περιορισμούς στο μέγεθος των προγραμμάτων που μπορούν να εκτελεστούν στα στάδια ένα και δύο. Η συνένωση αυτή των εργασιών επιτρέπει στο FreeBSD να παρέχει ένα πιο ευέλικτο σύστημα φόρτωσης.</p></div><div class=paragraph><p>Έπειτα ξεκινάει ο πυρήνας και αρχίζει την ανίχνευση και αρχικοποίηση των συσκευών ώστε να μπορούν να χρησιμοποιηθούν. Μέτα την ολοκλήρωση της διαδικασίας εκκίνησης του πυρήνα, ο έλεγχος περνάει στη διαδικασία χρήστη <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, η οποία και επιβεβαιώνει ότι οι δίσκοι είναι σε λειτουργική (χωρίς λάθη) κατάσταση. Η <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> ξεκινάει έπειτα την ρύθμιση πόρων (επίπεδο χρήστη), με την οποία προσαρτώνται τα συστήματα αρχείων, ρυθμίζονται οι κάρτες δικτύου για επικοινωνία με το δίκτυο, και γενικά εκκινούν όλες οι διαδικασίες που εκτελούνται τυπικά κατά την εκκίνηση ενός FreeBSD συστήματος.</p></div></div><div class=sect2><h3 id=boot-blocks>34.3. Ο Διαχειριστής Εκκίνησης και τα Στάδια Εκκίνησης<a class=anchor href=#boot-blocks></a></h3><div class=sect3><h4 id=boot-boot0>34.3.1. Ο Διαχειριστής Εκκίνησης (boot manager)<a class=anchor href=#boot-boot0></a></h4><div class=paragraph><p>Ο κώδικας στο MBR ή διαχειριστής εκκίνησης αναφέρεται μερικές φορές και ως <em>στάδιο μηδέν (stage zero)</em> της διαδικασίας εκκίνησης. Το τμήμα αυτό περιγράφει δύο από τους διαχειριστές εκκίνησης που αναφέραμε προηγουμένως: Το boot0 και το LILO.</p></div><div class=paragraph><p><strong>Ο Διαχειριστής Εκκίνησης boot0:</strong> Το MBR που εγκαθίσταται από το πρόγραμμα εγκατάστασης του FreeBSD ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>, βασίζεται από προεπιλογή στο <span class=filename>/boot/boot0</span>. (Το πρόγραμμα boot0 είναι πολύ απλό, καθώς ο κώδικας στο μπορεί να έχει μέγεθος ως 446 bytes, εξαιτίας του πίνακα κατατμήσεων (slice table) και του αναγνωριστικού <code>0x55AA</code> που βρίσκεται στο τέλος του MBR.) Αν έχετε εγκαταστήσει το boot0 και πολλαπλά λειτουργικά συστήματα στους σκληρούς δίσκους σας, θα δείτε κατά την εκκίνηση, μια οθόνη παρόμοια με την παρακάτω:</p></div><div id=boot-boot0-example class=exampleblock><div class=title>Παράδειγμα 8. <span class=filename>boot0</span> Screenshot</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</code></pre></div></div></div></div><div class=paragraph><p>Άλλα λειτουργικά συστήματα, και ειδικότερα τα Windows®, είναι γνωστό ότι γράφουν το δικό τους MBR πάνω σε κάποιο ήδη υπάρχον. Αν σας συμβεί αυτό, ή αν θέλετε να αντικαταστήσετε το υπάρχον MBR σας με αυτό του FreeBSD, χρησιμοποιήστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -B -b /boot/boot0 device</span></code></pre></div></div><div class=paragraph><p>όπου <em>device</em> είναι η συσκευή από την οποία γίνεται εκκίνηση, όπως π.χ. το <span class=filename>ad0</span> για τον πρώτο δίσκο IDE, το <span class=filename>ad2</span> για τον πρώτο IDE δίσκο στο δευτερεύοντα ελεγκτή, το <span class=filename>da0</span> για τον πρώτο SCSI δίσκο κ.ο.κ. Αν πάλι θέλετε προσαρμοσμένη ρύθμιση του MBR, χρησιμοποιήστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>.</p></div><div class=paragraph><p><strong>Ο Διαχειριστής Εκκίνησης LILO</strong> Για να εγκαταστήσετε αυτό το διαχειριστή εκκίνησης ώστε να μπορεί να εκκινεί το FreeBSD, εγκαταστήστε πρώτα το Linux και προσθέστε την ακόλουθη καταχώρηση στο υπάρχον αρχείο ρυθμίσεων <span class=filename>/etc/lilo.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>other=/dev/hdXY
table=/dev/hdX
loader=/boot/chain.b
label=FreeBSD</pre></div></div><div class=paragraph><p>Στο παραπάνω, καθορίστε το πρωτεύον διαμέρισμα και το δίσκο του FreeBSD αντικαθιστώντας το <em>X</em> με το γράμμα δίσκου και το <em>Y</em> με τον αριθμό του πρωτεύοντος διαμερίσματος, χρησιμοποιώντας όμως την ονοματολογία του Linux. Αν χρησιμοποιείτε οδηγό SCSI θα χρειαστεί να αλλάξετε το <em>/dev/hd</em> σε κάτι αντίστοιχο με <em>/dev/sd</em>. Η γραμμή <code>loader=/boot/chain.b</code> μπορεί να παραλειφθεί αν έχετε και τα δύο λειτουργικά συστήματα στον ίδιο δίσκο. Εκτελέστε τώρα την εντολή <code>/sbin/lilo -v</code> για να καταχωρήσετε τις νέες αλλαγές σας στο σύστημα. Μπορείτε να τις επιβεβαιώσετε ελέγχοντας τα μηνύματα που θα εμφανιστούν στην οθόνη σας.</p></div></div><div class=sect3><h4 id=boot-boot1>34.3.2. Το Στάδιο Ένα, <span class=filename>/boot/boot1</span>, και το Στάδιο Δύο, <span class=filename>/boot/boot2</span><a class=anchor href=#boot-boot1></a></h4><div class=paragraph><p>Ουσιαστικά, το πρώτο και δεύτερο στάδιο είναι τμήματα του ίδιου προγράμματος, στην ίδια περιοχή του δίσκου. Λόγω περιορισμών χώρου έχουν χωριστεί σε δύο, αλλά εγκαθίστανται πάντα μαζί. Αντιγράφονται από το συνδυασμένο αρχείο <span class=filename>/boot/boot</span> από το πρόγραμμα εγκατάστασης ή το bsdlabel (δείτε παρακάτω).</p></div><div class=paragraph><p>Βρίσκονται έξω από συστήματα αρχείων, στην πρώτη τροχιά (track) του slice εκκίνησης, ξεκινώντας από τον πρώτο τομέα. Είναι το σημείο όπου το <a href=#boot-boot0>boot0</a>, ή οποιοσδήποτε άλλος διαχειριστής εκκίνησης, αναμένει να βρει πρόγραμμα προς εκτέλεση με το οποίο θα συνεχιστεί η διαδικασία εκκίνησης. Ο αριθμός των τομέων που χρησιμοποιούνται μπορεί να βρεθεί εύκολα από το μέγεθος του αρχείου <span class=filename>/boot/boot</span>.</p></div><div class=paragraph><p>Το <span class=filename>boot1</span> είναι πολύ απλό, μια και μπορεί να είναι μόνο 512 bytes σε μέγεθος, και γνωρίζει όσα χρειάζεται για το <em>bsdlabel</em> του FreeBSD, το οποίο αποθηκεύει πληροφορίες σχετικά με το slice, ώστε να βρει και να εκτελέσει το <span class=filename>boot2</span>.</p></div><div class=paragraph><p>Το <span class=filename>boot2</span> είναι ελαφρά πιο πολύπλοκο και κατανοεί επαρκώς το σύστημα αρχείων του FreeBSD ώστε να μπορεί να βρει αρχεία σε αυτό, και μπορεί επίσης να παρέχει μια απλή διεπαφή με το χρήστη ώστε να μπορεί να γίνει η επιλογή του πυρήνα ή του προγράμματος φόρτωσης που θα εκτελεστεί.</p></div><div class=paragraph><p>Το <span class=filename>boot2</span> συνήθως εκτελεί τον <a href=#boot-loader>loader (φορτωτής εκκίνησης)</a> ο οποίος είναι εξαιρετικά πιο πολύπλοκος, αλλά παρέχει ένα ωραίο και εύκολο τρόπο ρύθμισης της εκκίνησης. Παλιότερα το <span class=filename>boot2</span> αναλάμβανε να φορτώσει απευθείας τον πυρήνα.</p></div><div id=boot-boot2-example class=exampleblock><div class=title>Παράδειγμα 9. Εικόνα από το <span class=filename>boot2</span></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></div><div class=paragraph><p>Αν χρειαστεί ποτέ να αντικαταστήσετε τα εγκατεστημένα <span class=filename>boot1</span> και <span class=filename>boot2</span> χρησιμοποιήστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -B diskslice</span></code></pre></div></div><div class=paragraph><p>όπου το <em>diskslice</em> είναι ο δίσκος και το slice από το οποίο γίνεται η εκκίνηση, όπως π.χ. <span class=filename>ad0s1</span> για το πρώτο slice στον πρώτο IDE δίσκο.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Επικίνδυνα Αφοσιωμένη Κατάσταση (Dangerously Dedicated Mode)</div><div class=paragraph><p>Αν χρησιμοποιήσετε μόνο το όνομα του δίσκου, όπως π.χ. <span class=filename>ad0</span>, στην εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> θα δημιουργήσετε ένα επικίνδυνα αφοσιωμένο δίσκο, χωρίς slices. Είναι σχεδόν σίγουρο ότι δεν θέλετε να το κάνετε αυτό, γι' αυτό σιγουρευτείτε ότι ελέγξατε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> πριν πιέσετε <kbd>Return</kbd>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-loader>34.3.3. Στάδιο Τρία, <span class=filename>/boot/loader</span><a class=anchor href=#boot-loader></a></h4><div class=paragraph><p>Ο loader, ή φορτωτής εκκίνησης, είναι το τελικό στάδιο του συστήματος εκκίνησης τριών σταδίων, και βρίσκεται στο σύστημα αρχείων, συνήθως ως <span class=filename>/boot/loader</span>.</p></div><div class=paragraph><p>Προορισμός του loader είναι να παρέχει μια μέθοδο ρύθμισης φιλική προς το χρήστη, και χρησιμοποιεί ένα εύκολο σύνολο εντολών, το οποίο υποστηρίζεται από ένα ισχυρό μεταφραστή εντολών με ένα πολυπλοκότερο σύνολο εντολών.</p></div><div class=sect4><h5 id=boot-loader-flow>34.3.3.1. Ροή του Προγράμματος Loader<a class=anchor href=#boot-loader-flow></a></h5><div class=paragraph><p>Κατά την αρχικοποίηση, ο loader θα ανιχνεύσει την κονσόλα και τους δίσκους και θα καθορίσει από ποιο δίσκο γίνεται η εκκίνηση. Θα ρυθμίσει κατάλληλα τις αντίστοιχες μεταβλητές και θα ξεκινήσει ένα πρόγραμμα μετάφρασης εντολών (interpreter) στο οποίο μπορεί ο χρήστης να δίνει εντολές, είτε απευθείας, είτε μέσω κάποιου script.</p></div><div class=paragraph><p>Ο loader κατόπιν θα διαβάσει το αρχείο <span class=filename>/boot/loader.rc</span>, το οποίο με τη σειρά του διαβάζει, από προεπιλογή, το <span class=filename>/boot/defaults/loader.conf</span>. Μέσα από το αρχείο αυτό τίθενται λογικές προεπιλεγμένες τιμές για κάποιες μεταβλητές. Έπειτα, διαβάζεται το αρχείο <span class=filename>/boot/loader.conf</span> για τυχόν τοπικές αλλαγές στις μεταβλητές αυτές. Κατόπιν το <span class=filename>loader.rc</span> χρησιμοποιεί αυτές τις μεταβλητές, φορτώνοντας τα αρθρώματα (modules) και τον πυρήνα που έχει επιλεγεί.</p></div><div class=paragraph><p>Τελικά, ο loader, περιμένει 10 δευτερόλεπτα (προεπιλεγμένο χρονικό διάστημα) για την πίεση κάποιου πλήκτρου, και αν δεν υπάρξει παρέμβαση από τον χρήστη, ξεκινάει τον πυρήνα. Αν γίνει παρέμβαση, εμφανίζεται στον χρήστη μια προτροπή η οποίο κατανοεί το εύκολο σύνολο εντολών που αναφέραμε προηγουμένως, και όπου ο χρήστης μπορεί να ρυθμίσει μεταβλητές, να αποφορτώσει όλα τα αρθρώματα, να φορτώσει αρθρώματα και τελικά να προβεί σε εκκίνηση ή επανεκκίνηση.</p></div></div><div class=sect4><h5 id=boot-loader-commands>34.3.3.2. Εντολές Ενσωματωμένες στο Loader<a class=anchor href=#boot-loader-commands></a></h5><div class=paragraph><p>Παρακάτω θα δείτε τις πιο συχνά χρησιμοποιούμενες εντολές του loader. Για περισσότερες λεπτομέρειες σχετικά με όλες τις διαθέσιμες εντολές, παρακαλούμε να δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>autoboot <em>seconds</em></dt><dd><p>Προχωρά στην εκκίνηση του πυρήνα, αν δεν υπάρξει παρέμβαση από το χρήστη μέσα στο καθορισμένο χρονικό διάστημα που δίνεται σε δευτερόλεπτα. Απεικονίζει αντίστροφη μέτρηση, και ο προεπιλεγμένος χρόνος είναι τα 10 δευτερόλεπτα.</p></dd><dt class=hdlist1>boot <code>[-options] [kernelname]</code></dt><dd><p>Προχωράει άμεσα στην εκκίνηση του πυρήνα, χρησιμοποιώντας όποιες τυχόν επιλογές έχουν δοθεί και το όνομα του πυρήνα που θα εκτελεστεί αν έχει επίσης δοθεί. Για να δώσετε διαφορετικό όνομα πυρήνα στην γραμμή εντολής, θα πρέπει πρώτα να χρησιμοποιήσετε την εντολή <em>unload</em>. Διαφορετικά, θα χρησιμοποιηθεί ο πυρήνας που έχει φορτωθεί ήδη.</p></dd><dt class=hdlist1>boot-conf</dt><dd><p>Διατρέχει την αυτόματη ρύθμιση των αρθρωμάτων (module) που βασίζεται σε μεταβλητές, με τον ίδιο τρόπο που γίνεται και σε κανονική εκκίνηση. Αυτό έχει νόημα μόνο αν χρησιμοποιήσετε πρώτα το <code>unload</code> και αλλάξετε κάποιες μεταβλητές, συνήθως το <code>kernel</code>.</p></dd><dt class=hdlist1>help <code>[topic]</code></dt><dd><p>Δείχνει μηνύματα βοήθειας, τα οποία διαβάζονται από το <span class=filename>/boot/loader.help</span>. Αν το topic (θέμα) που δόθηκε είναι η λέξη <code>index</code>, θα δείτε μια λίστα με τα διαθέσιμα θέματα βοήθειας.</p></dd><dt class=hdlist1>include <em>filename</em> …​</dt><dd><p>Επεξεργάζεται το αρχείο με το όνομα αρχείου που δόθηκε (filename). Γίνεται ανάγνωση και γραμμή προς γραμμή μετάφραση του αρχείου. Η εντολή include σταματάει άμεσα αν εντοπιστεί κάποιο λάθος.</p></dd><dt class=hdlist1>load <code>[-t type]</code> <em>filename</em></dt><dd><p>Φορτώνει τον πυρήνα, το άρθρωμα πυρήνα ή ένα αρχείο του τύπου που καθορίστηκε, με βάση το όνομα αρχείου που δόθηκε. Αν μετά το όνομα αρχείου υπάρχουν παράμετροι, περνιούνται ως παράμετροι στο αρχείο που φορτώνεται.</p></dd><dt class=hdlist1>ls <code>[-l] [path]</code></dt><dd><p>Δείχνει ένα κατάλογο των αρχείων της διαδρομής που δόθηκε, ή αν δεν καθορίστηκε διαδρομή, του ριζικού καταλόγου. Αν δοθεί και η επιλογή <code>-l</code> θα εμφανίζονται επίσης και τα μεγέθη των αρχείων.</p></dd><dt class=hdlist1>lsdev <code>[-v]</code></dt><dd><p>Εμφανίζει όλες τις συσκευές από τις οποίες είναι δυνατή η φόρτωση αρθρωμάτων. Αν δοθεί με την επιλογή <code>-v</code>, εμφανίζονται περισσότερες λεπτομέρειες.</p></dd><dt class=hdlist1>lsmod <code>[-v]</code></dt><dd><p>Εμφανίζει τα αρθρώματα που έχουν φορτωθεί. Αν δοθεί η επιλογή <code>-v</code>, εμφανίζονται περισσότερες λεπτομέρειες.</p></dd><dt class=hdlist1>more <em>filename</em></dt><dd><p>Εμφανίζει το αρχείο που καθορίζεται, με παύσεις κάθε <code>LINES</code> αριθμό γραμμών.</p></dd><dt class=hdlist1>reboot</dt><dd><p>Επανεκκινεί άμεσα το σύστημα.</p></dd><dt class=hdlist1>set <em>variable</em></dt><dd><p>Καθορίζει μεταβλητές περιβάλλοντος για τον loader.</p></dd><dt class=hdlist1>unload</dt><dd><p>Αποφορτώνει όλα τα αρθρώματα.</p></dd></dl></div></div><div class=sect4><h5 id=boot-loader-examples>34.3.3.3. Παραδείγματα για τον Loader<a class=anchor href=#boot-loader-examples></a></h5><div class=paragraph><p>Εδώ θα βρείτε μερικά πρακτικά παραδείγματα σχετικά με την χρήση του loader:</p></div><div class=ulist><ul><li><p>Για να ξεκινήσετε το συνηθισμένο πυρήνα σας, αλλά σε κατάσταση ενός χρήστη:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nt>-s</span></code></pre></div></div></li><li><p>Για να αποφορτώσετε το συνηθισμένο πυρήνα σας και να φορτώσετε τον παλιό σας (ή κάποιο άλλο):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> unload
 load kernel.old</code></pre></div></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε το όνομα <span class=filename>kernel.GENERIC</span> για να αναφερθείτε στον αρχικό (generic) πυρήνα ο οποίος υπάρχει στο CD της εγκατάστασης, ή το <span class=filename>kernel.old</span> για να αναφερθείτε στον πυρήνα που είχατε εγκατεστημένο πριν (για παράδειγμα, τον παλιό σας πυρήνα αν κάνατε πρόσφατα ρύθμιση και εγκατάσταση νέου δικού σας προσαρμοσμένου πυρήνα).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Χρησιμοποιήστε το παρακάτω για να φορτώσετε τα συνηθισμένα σας αρθρώματα σε κάποιο άλλο πυρήνα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
<span class=nb>set </span><span class=nv>kernel</span><span class=o>=</span><span class=s2>&#34;kernel.old&#34;</span>
boot-conf</code></pre></div></div></td></tr></tbody></table></div></li><li><p>Για να φορτώσετε ένα script ρύθμισης πυρήνα (ένα αυτοματοποιημένο πρόγραμμα το οποίο εκτελεί τις λειτουργίες που κανονικά θα κάνατε μέσω κάποιου προγράμματος ρύθμισης πυρήνα κατά την εκκίνηση):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> load <span class=nt>-t</span> userconfig_script /boot/kernel.conf</code></pre></div></div></li></ul></div></div><div class=sect4><h5 id=boot-splash>34.3.3.4. Γραφική Οθόνη Εκκίνησης<a class=anchor href=#boot-splash></a></h5><div class=paragraph><p>Η γραφική οθόνη εκκίνησης (splash screen) δημιουργεί ένα πιο ευχάριστο περιβάλλον σε σχέση με την απλή απεικόνιση των μηνυμάτων εκκίνησης σε μορφή κειμένου. Η γραφική οθόνη εκκίνησης εμφανίζεται ως ότου το σύστημα φτάσει στην προτροπή εισόδου (login), είτε στην κονσόλα, είτε στο γραφικό περιβάλλον.</p></div><div class=paragraph><p>Το FreeBSD διαθέτει δύο βασικά περιβάλλοντα. Το πρώτο είναι το προεπιλεγμένο περιβάλλον κειμένου γραμμής εντολών (κονσόλα). Μετά το τέλος της εκκίνησης, εμφανίζεται στην κονσόλα μια προτροπή εισόδου. Το δεύτερο, είναι το γραφικό περιβάλλον που παρέχεται από το σύστημα Χ11. Μετά την εγκατάσταση του <a href=./#x-install>X11</a> και ενός από τους γραφικούς <a href=./#x11-wm>διαχειριστές παραθύρων ή desktop</a>, όπως είναι τα GNOME, KDE ή XFce, μπορείτε να ξεκινήσετε το γραφικό περιβάλλον με την εντολή <code>startx</code>.</p></div><div class=paragraph><p>Μερικοί χρήστες προτιμούν να συνδέονται στο σύστημα μέσω γραφικής οθόνη εισόδου, αντί να χρησιμοποιούν την προτροπή εισόδου της κονσόλας. Η δυνατότητα αυτή παρέχεται απο διαχειριστές οθόνης, όπως ο XDM για το Xorg, o gdm για το GNOME και ο kdm για το KDE (καθώς και άλλους που διατίθενται στη Συλλογή των Ports). Μετά από μια επιτυχημένη είσοδο, παρουσιάζεται άμεσα στο χρήστη το γραφικό περιβάλλον της επιλογής του.</p></div><div class=paragraph><p>Στο περιβάλλον της γραμμής εντολών, η γραφική οθόνη εκκίνησης θα αποκρύψει όλα τα μηνύματα ανίχνευσης των συσκευών και υπηρεσιών, μέχρι την εμφάνιση της προτροπής εισόδου. Με απευθείας εκκίνηση σε περιβάλλον X11, η εμπειρία εκκίνησης θα είναι ακόμα πιο καθαρή, και θα μοιάζει περισσότερο με την αντίστοιχη σε ένα περιβάλλον Microsoft® Windows® ή άλλου μη-UNIX συστήματος.</p></div><div class=sect5><h6 id=boot-splash-function>34.3.3.4.1. Λειτουργία της Γραφικής Οθόνης Εκκίνησης<a class=anchor href=#boot-splash-function></a></h6><div class=paragraph><p>Η γραφική οθόνη εκκίνησης υποστηρίζει εικόνες bitmap (<span class=filename>.bmp</span>), ZSoft PCX (<span class=filename>.pcx</span>) ή TheDraw (<span class=filename>.bin</span>) 256 χρωμάτων. Επιπρόσθετα, οι εικόνες που χρησιμοποιούνται πρέπει να έχουν ανάλυση 320x200 ή μικρότερη για να λειτουργήσουν σε τυπικούς προσαρμογείς οθόνης VGA.</p></div><div class=paragraph><p>Για να χρησιμοποιήσετε μεγαλύτερες εικόνες, μέχρι την μέγιστη ανάλυση των 1024x768 pixels, ενεργοποιήστε την υποστήριξη VESA που περιλαμβάνεται στο FreeBSD. Μπορείτε να την ενεργοποιήσετε φορτώνοντας το άρθρωμα VESA κατά την εκκίνηση του συστήματος, η προσθέτοντας την επιλογή <code>VESA</code> στο αρχείο ρυθμίσεων του πυρήνα, και δημιουργώντας ένα νέο προσαρμοσμένο πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>). Η υποστήριξη VESA δίνει στους χρήστες την δυνατότητα να χρησιμοποιήσουν μια εικόνα που να καλύπτει όλη την οθόνη.</p></div><div class=paragraph><p>Μπορείτε να δείτε τα κανονικά μηνύματα εκκίνησης όσο εμφανίζεται η γραφική οθόνη εκκίνησης, πιέζοντας απλώς οποιοδήποτε πλήκτρο.</p></div><div class=paragraph><p>Η οθόνη εκκίνησης γίνεται επίσης η προεπιλεγμένη προφύλαξη οθόνης, όσο το σύστημα λειτουργεί σε περιβάλλον κονσόλας. Μετά από κάποιο χρονικό διάστημα αδράνειας, η οθόνη αλλάζει, απεικονίζοντας την εικόνα που χρησιμοποιήθηκε στην εκκίνηση, με κυκλική εναλλαγή της φωτεινότητας από πολύ φωτεινή ως πολύ σκοτεινή. Μπορείτε να αλλάξετε αυτή την προεπιλεγμένη προφύλαξη οθόνης, προσθέτοντας μια γραμμή <code>saver=</code> στο αρχείο <span class=filename>/etc/rc.conf</span>. Για την επιλογή <code>saver=</code>, υπάρχουν αρκετές ενσωματωμένες προφυλάξεις οθόνης για να επιλέξετε. Μπορείτε να δείτε την πλήρη λίστα στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a>. Η προεπιλεγμένη προφύλαξη οθόνης ονομάζεται "warp". Σημειώστε ότι η προφύλαξη οθόνης που καθορίζεται στο αρχείο <span class=filename>/etc/rc.conf</span> μέσω της επιλογής <code>saver=</code> έχει επίδραση μόνο στις εικονικές κονσόλες. Δεν επηρεάζει καθόλου το γραφικό περιβάλλον X11.</p></div><div class=paragraph><p>Κάποια μηνύματα εκκίνησης εξακολουθούν να εμφανίζονται, ακόμα και μετά την εφαρμογή της γραφικής οθόνης εκκίνησης. Τα μηνύματα αυτά περιλαμβάνουν το μενού επιλογών εκκίνησης και την αντίστροφη μέτρηση χρόνου που το συνοδεύει.</p></div><div class=paragraph><p>Μπορείτε να κατεβάσετε υποδείγματα εικόνων για χρήση στην εκκίνηση, από τη συλλογή εικόνων στην τοποθεσία <a href=http://artwork.freebsdgr.org/node/3>http://artwork.freebsdgr.org</a>. Αν εγκαταστήσετε το Port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bsd-splash-changer/>sysutils/bsd-splash-changer</a>, θα έχετε τυχαία εναλλαγή εικόνων (που θα επιλέγονται από μια έτοιμη συλλογή) σε κάθε εκκίνηση του συστήματος.</p></div></div><div class=sect5><h6 id=boot-splash-enable>34.3.3.4.2. Ενεργοποίηση της Γραφικής Οθόνης Εκκίνησης<a class=anchor href=#boot-splash-enable></a></h6><div class=paragraph><p>Το αρχείο που θα χρησιμοποιηθεί για την γραφική οθόνη εκκίνησης (τύπου <span class=filename>.bmp</span>, <span class=filename>.pcx</span> ή <span class=filename>.bin</span>) θα πρέπει να τοποθετηθεί στην ριζική (root) κατάτμηση, για παράδειγμα στον κατάλογο <span class=filename>/boot/</span>.</p></div><div class=paragraph><p>Για την προεπιλεγμένη ανάλυση οθόνης (320x200 ή μικρότερη, 256 χρώματα), επεξεργαστείτε το αρχείο <span class=filename>/boot/loader.conf</span> ώστε να περιέχει τα παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_bmp_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bmp&#34;</pre></div></div><div class=paragraph><p>Για μεγαλύτερες αναλύσεις, μέχρι την μέγιστη 1024x768, επεξεργαστείτε το αρχείο <span class=filename>/boot/loader.conf</span> ώστε να περιέχει το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>vesa_load=&#34;YES&#34;
splash_bmp_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bmp&#34;</pre></div></div><div class=paragraph><p>Το παραπάνω υποθέτει ότι θα χρησιμοποιήσετε το αρχείο <span class=filename>/boot/splash.bmp</span> για την γραφική οθόνη εκκίνησης. Αν θέλετε να χρησιμοποιήσετε εικόνα τύπου PCX, χρησιμοποιήστε τις παρακάτω επιλογές, καθώς και την επιλογή <code>vesa_load="YES"</code>, ανάλογα με την ανάλυση:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_pcx_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.pcx&#34;</pre></div></div><div class=paragraph><p>Στην έκδοση 8.3, μια ακόμα επιλογή είναι η χρήση ascii art σε μορφή <a href=https://en.wikipedia.org/wiki/TheDraw>The Draw</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>splash_txt=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bin&#34;</pre></div></div><div class=paragraph><p>Το όνομα αρχείου δεν είναι απαραίτητο να είναι "splash" όπως φαίνεται στο παραπάνω παράδειγμα. Μπορεί να είναι οτιδήποτε, αρκεί να πρόκειται για αρχείο των τύπων που αναφέραμε παραπάνω, για παράδειγμα <span class=filename>splash_640x400.bmp</span> ή <span class=filename>blue_wave.pcx</span>.</p></div><div class=paragraph><p>Παρακάτω φαίνονται μερικές ακόμα ενδιαφέρουσες επιλογές που μπορείτε να χρησιμοποιήσετε στο <span class=filename>/boot/loader.conf</span>:</p></div><div class=dlist><dl><dt class=hdlist1><code>beastie_disable="YES"</code></dt><dd><p>Η επιλογή αυτή καταργεί την εμφάνιση του μενού επιλογών εκκίνησης. Παραμένει ωστόσο η αντίστροφη μέτρηση με την προτροπή εισαγωγής επιλογών εκκίνησης. Ακόμα και όταν δεν εμφανίζεται το μενού επιλογών, αν ο χρήστης κάνει μια επιλογή στη διάρκεια του προεπιλεγμένου χρόνου αναμονής, η επιλογή αυτή θα ισχύσει για την εκκίνηση.</p></dd><dt class=hdlist1><code>loader_logo="beastie"</code></dt><dd><p>Η επιλογή αυτή αλλάζει το κείμενο "FreeBSD" που εμφανίζεται στο δεξιό μέρος του μενού επιλογών εκκίνησης, με ένα έγχρωμο λογότυπο του beastie, όπως εμφανιζόταν στις παλαιότερες εκδόσεις.</p></dd></dl></div><div class=paragraph><p>Για περισσότερες πληροφορίες, παρακαλούμε ανατρέξτε στις σελίδες manual <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=vga&amp;sektion=4&amp;format=html">vga(4)</a>.</p></div></div></div></div></div><div class=sect2><h3 id=boot-kernel>34.4. Αλληλεπίδραση με τον Πυρήνα κατά την Εκκίνηση<a class=anchor href=#boot-kernel></a></h3><div class=paragraph><p>Από τη στιγμή που ο πυρήνας φορτωθεί, είτε μέσω του <a href=#boot-loader>loader</a> (όπως συνήθως) είτε μέσω του <a href=#boot-boot1>boot2</a> (παρακάμπτοντας τον loader), εξετάζει τις παραμέτρους εκκίνησης (boot flags), αν υπάρχουν, και προσαρμόζει ανάλογα τη συμπεριφορά του.</p></div><div class=sect3><h4 id=boot-kernel-bootflags>34.4.1. Παράμετροι Εκκίνησης Πυρήνα (Boot Flags)<a class=anchor href=#boot-kernel-bootflags></a></h4><div class=paragraph><p>Παρακάτω θα βρείτε τις πιο συνηθισμένες παραμέτρους εκκίνησης:</p></div><div class=dlist><dl><dt class=hdlist1><code>-a</code></dt><dd><p>κατά τη διάρκεια της εκκίνησης, θα γίνει ερώτηση για την συσκευή από την οποία θα γίνει η προσάρτηση του ριζικού (root) συστήματος αρχείων.</p></dd><dt class=hdlist1><code>-C</code></dt><dd><p>εκκίνηση από το CDROM.</p></dd><dt class=hdlist1><code>-c</code></dt><dd><p>εκτέλεση του UserConfig, του προγράμματος ρύθμισης πυρήνα κατά την εκκίνηση.</p></dd><dt class=hdlist1><code>-s</code></dt><dd><p>εκκίνηση σε κατάσταση λειτουργίας ενός χρήστη (single user).</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>εμφάνιση περισσότερων πληροφοριών κατά τη διάρκεια εκκίνησης του πυρήνα.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Υπάρχουν και άλλες παράμετροι εκκίνησης, διαβάστε τη σελίδα <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> για περισσότερες πληροφορίες σχετικά με αυτές.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=device-hints>34.5. Device Hints<a class=anchor href=#device-hints></a></h3><div class=paragraph><p>Κατά τη διάρκεια της αρχικής εκκίνησης του συστήματος, το πρόγραμμα του boot <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> διαβάζει το αρχείο <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>. Το αρχείο αυτό περιέχει πληροφορίες εκκίνησης για τον πυρήνα, γνωστές ως μεταβλητές, οι οποίες μερικές φορές αναφέρονται επίσης και ως "device hints". Αυτά τα "device hints" χρησιμοποιούνται από προγράμματα οδήγησης συσκευών για ρύθμιση των αντίστοιχων συσκευών.</p></div><div class=paragraph><p>Μπορούμε επίσης να ορίσουμε Device hints στην προτροπή του <a href=#boot-loader>Σταδίου 3 του boot loader</a>. Οι μεταβλητές μπορούν να οριστούν με χρήση της εντολής <code>set</code>, και να αφαιρεθούν με την <code>unset</code>. Μπορούμε επίσης να τις εμφανίσουμε με την εντολή <code>show</code>. Ακόμα, μπορούμε εδώ να παρακάμψουμε και να αλλάξουμε την τιμή μεταβλητών που έχουν οριστεί στο αρχείο <span class=filename>/boot/device.hints</span>. Τα Device hints που ορίζουμε στο boot loader δεν παραμένουν μόνιμα και δεν θα ισχύσουν στην επόμενη εκκίνηση.</p></div><div class=paragraph><p>Μετά την εκκίνηση του συστήματος, μπορεί να χρησιμοποιηθεί η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a> για να εμφανιστούν οι τιμές όλων των μεταβλητών.</p></div><div class=paragraph><p>Το συντακτικό του αρχείου <span class=filename>/boot/device.hints</span> είναι μια μεταβλητή ανά γραμμή, και χρησιμοποιείται το τυποποιημένο "#" για γραμμές που δηλώνονται ως σχόλια. Οι γραμμές δημιουργούνται όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> hint.driver.unit.keyword<span class=o>=</span><span class=s2>&#34;value&#34;</span></code></pre></div></div><div class=paragraph><p>Η σύνταξη για το Στάδιο 3 του boot loader είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.driver.unit.keyword<span class=o>=</span>value</code></pre></div></div><div class=paragraph><p>όπου <code>driver</code> είναι το όνομα του οδηγού συσκευής, <code>unit</code> είναι ο αριθμός μονάδας της συσκευής, και <code>keyword</code> είναι η λέξη-κλειδί για το συγκεκριμένο hint. Η λέξη-κλειδί μπορεί να αποτελείται από τις ακόλουθες επιλογές:</p></div><div class=ulist><ul><li><p><code>at</code>: καθορίζει το δίαυλο (bus) στον οποίο προσαρτάται η συσκευή.</p></li><li><p><code>port</code>: καθορίζει την αρχική διεύθυνση της θύρας I/O που θα χρησιμοποιηθεί.</p></li><li><p><code>irq</code>: καθορίζει τον αριθμό της αίτησης διακοπής (interrupt request) που θα χρησιμοποιηθεί.</p></li><li><p><code>drq</code>: καθορίζει τον αριθμό του καναλιού DMA.</p></li><li><p><code>maddr</code>: καθορίζει τη φυσική διεύθυνση μνήμης που καταλαμβάνεται από τη συσκευή.</p></li><li><p><code>flags</code>: ορίζει διάφορα bits παραμέτρων για την συσκευή.</p></li><li><p><code>disabled</code>: Αν οριστεί σε τιμή <code>1</code>, η συσκευή απενεργοποιείται.</p></li></ul></div><div class=paragraph><p>Οι οδηγοί συσκευών μπορεί να δέχονται (ή να απαιτούν) περισσότερα hints τα οποία δεν φαίνονται εδώ, και σας συνιστούμε να δείτε την αντίστοιχη σελίδα manual του κάθε οδηγού. Για περισσότερες πληροφορίες συμβουλευθείτε επίσης τις σελίδες manual των <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>, και <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div></div><div class=sect2><h3 id=boot-init>34.6. Init: Αρχικοποίηση Ελέγχου Διαδικασιών<a class=anchor href=#boot-init></a></h3><div class=paragraph><p>Μόλις ολοκληρωθεί η εκκίνηση του πυρήνα, ο έλεγχος μεταφέρεται στην διαδικασία χρήστη <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, η οποία βρίσκεται στο αρχείο <span class=filename>/sbin/init</span>, ή στη διαδρομή που καθορίζεται στην μεταβλητή <code>init_path</code> του <code>loader</code>.</p></div><div class=sect3><h4 id=boot-autoreboot>34.6.1. Ακολουθία Αυτόματης Επανεκκίνησης<a class=anchor href=#boot-autoreboot></a></h4><div class=paragraph><p>Η ακολουθία αυτόματης επανεκκίνησης εξασφαλίζει ότι τα συστήματα αρχείων είναι σε κανονική, σταθερή κατάσταση. Αν δεν είναι, και η <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> δεν μπορεί να διορθώσει τα προβλήματα, τότε η <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> θα μεταφέρει το σύστημα σε <a href=#boot-singleuser>κατάσταση λειτουργίας ενός χρήστη</a> ώστε να μπορέσει άμεσα ο διαχειριστής συστήματος να επιληφθεί των προβλημάτων αυτών.</p></div></div><div class=sect3><h4 id=boot-singleuser>34.6.2. Κατάσταση Λειτουργίας Ενός Χρήστη<a class=anchor href=#boot-singleuser></a></h4><div class=paragraph><p>Μπορείτε να εισέλθετε στην κατάσταση αυτή μέσω της <a href=#boot-autoreboot>ακολουθίας αυτόματης επανεκκίνησης</a>, ή μέσω της επιλογής <code>-s</code> κατά την εκκίνηση ή ακόμα και θέτοντας τη μεταβλητή <code>boot_single</code> στον <code>loader</code>.</p></div><div class=paragraph><p>Μπορείτε επίσης να εισέλθετε σε αυτή εκτελώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> χωρίς την επιλογή επανεκκίνησης (<code>-r</code>) ή τερματισμού (<code>-h</code>), ενώ είστε σε κατάσταση λειτουργίας <a href=#boot-multiuser>πολλών χρηστών (multi-user)</a>.</p></div><div class=paragraph><p>Αν η <code>κονσόλα</code> του συστήματος έχει τεθεί ως <code>insecure</code> (ανασφαλής) στο <span class=filename>/etc/ttys</span>, το σύστημα θα ζητήσει τον κωδικό του <code>root</code> πριν εισέλθει σε κατάσταση λειτουργίας ενός χρήστη.</p></div><div id=boot-insecure-console class=exampleblock><div class=title>Παράδειγμα 10. Ανασφαλής Κονσόλα στο <span class=filename>/etc/ttys</span></div><div class=content><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μια <code>insecure</code> (ανασφαλής) κονσόλα σημαίνει ότι δεν θεωρείτε ασφαλή την κονσόλα όσο αφορά τη φυσική της πρόσβαση και θέλετε να είστε βέβαιος ότι μόνο όποιος γνωρίζει τον κωδικό του <code>root</code> θα μπορεί να χρησιμοποιήσει τη λειτουργία ενός χρήστη. Η επιλογή αυτή δεν σημαίνει ότι θέλετε η κονσόλα σας να λειτουργεί χωρίς ασφάλεια. Αν θέλετε ασφάλεια, θα πρέπει να επιλέξετε <code>insecure</code>, όχι <code>secure</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-multiuser>34.6.3. Κατάσταση Λειτουργία Πολλαπλών Χρηστών (multi-user)<a class=anchor href=#boot-multiuser></a></h4><div class=paragraph><p>Αν η <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> δεν βρει προβλήματα στα συστήματα αρχείων σας, ή μόλις ο χρήστης τερματίσει την <a href=#boot-singleuser>κατάσταση λειτουργίας ενός χρήστη</a>, το σύστημα εισέρχεται σε λειτουργία πολλαπλών χρηστών, όπου και ξεκινά πλέον η ρύθμιση πόρων (resources) του συστήματος.</p></div><div class=sect4><h5 id=boot-rc>34.6.3.1. Ρύθμιση Πόρων (rc)<a class=anchor href=#boot-rc></a></h5><div class=paragraph><p>Το σύστημα ρύθμισης πόρων, διαβάζει τις προεπιλεγμένες επιλογές από το <span class=filename>/etc/defaults/rc.conf</span>, και επιλογές για το συγκεκριμένο μηχάνημα από το <span class=filename>/etc/rc.conf</span>, και προχωρεί στην προσάρτηση των συστημάτων αρχείων που αναγράφονται στο <span class=filename>/etc/fstab</span>, ξεκινά τις υπηρεσίες δικτύου, εκκινεί διάφορους δαίμονες, και τέλος εκτελεί τα scripts εκκίνησης των τοπικά εγκατεστημένων πακέτων (εφαρμογών).</p></div><div class=paragraph><p>Η σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> παρέχει μια καλή αναφορά στο σύστημα ρύθμισης πόρων, καθώς εξετάζει τα ίδια τα scripts εκκίνησης.</p></div></div></div></div><div class=sect2><h3 id=boot-shutdown>34.7. Ακολουθία Τερματισμού<a class=anchor href=#boot-shutdown></a></h3><div class=paragraph><p>Κατά τον ελεγχόμενο τερματισμό, μέσω της <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>, η <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> θα αποπειραθεί να εκτελέσει το script <span class=filename>/etc/rc.shutdown</span>, και ακολούθως θα στείλει σε όλες τις διεργασίες το σήμα <code>TERM</code>, και τέλος το σήμα <code>KILL</code> σε όποια διεργασία δεν τερματίσει σε εύλογο χρονικό διάστημα.</p></div><div class=paragraph><p>Για να γίνει και διακοπή της τροφοδοσίας σε ένα σύστημα FreeBSD με αρχιτεκτονική που υποστηρίζει διαχείριση ενέργειας, απλώς χρησιμοποιήστε την εντολή <code>shutdown -p now</code> για απενεργοποίηση μετά τον τερματισμό. Για να κάνετε απλώς επανεκκίνηση σε ένα σύστημα FreeBSD χρησιμοποιήστε την εντολή <code>shutdown -r now</code>. Θα πρέπει να είστε <code>root</code> ή μέλος της ομάδας <code>operator</code> για να εκτελέσετε την <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>. Μπορείτε επίσης να χρησιμοποιήσετε τις εντολές <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=8&amp;format=html">reboot(8)</a>, κοιτάξτε τις αντίστοιχες σελίδες manual καθώς και τη σελίδα manual της <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> για περισσότερες πληροφορίες.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η διαχείριση ενέργειας απαιτεί την υποστήριξη του <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, είτε στον πυρήνα, είτε φορτωμένη ως άρθρωμα (module).</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security>Chapter 35. Ασφάλεια<a class=anchor href=#security></a></h2><div class=sectionbody><div class=sect2><h3 id=security-synopsis>35.1. Σύνοψη<a class=anchor href=#security-synopsis></a></h3><div class=paragraph><p>Το κεφάλαιο αυτό παρέχει μια βασική εισαγωγή στις έννοιες της ασφάλειας συστήματος, κάποιους γενικά καλούς κανόνες, και ορισμένα προχωρημένα θέματα σχετικά με το FreeBSD. Αρκετά από τα θέματα που καλύπτονται εδώ, μπορούν να εφαρμοστούν το ίδιο καλά τόσο στο ίδιο το σύστημα, όσο και για ασφάλεια μέσω Internet. Το Internet δεν είναι πλέον ένα "φιλικό" μέρος στο οποίο καθένας θέλει να είναι ο ευγενικός σας γείτονας. Η ανάγκη ασφάλισης του συστήματος σας είναι επιτακτική για να προστατέψετε τα δεδομένα σας,την πνευματική σας ιδιοκτησία, το χρόνο σας, και πολλά περισσότερα από τα χέρια των χάκερς και των ομοίων τους.</p></div><div class=paragraph><p>Το FreeBSD παρέχει μια σειρά από βοηθητικά προγράμματα και μηχανισμούς για να εξασφαλίσει την ακεραιότητα και την ασφάλεια του συστήματος σας και του δικτύου.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Βασικές έννοιες για την ασφάλεια, σε σχέση με το FreeBSD.</p></li><li><p>Στοιχεία σχετικά με τους διάφορους μηχανισμούς κρυπτογράφησης που είναι διαθέσιμοι στο FreeBSD, όπως το DES και το MD5.</p></li><li><p>Πως να ρυθμίσετε το σύστημα σας για κωδικούς μιας χρήσης.</p></li><li><p>Πως να ρυθμίσετε TCP Wrappers για χρήση με την <code>inetd</code>.</p></li><li><p>Πως να ρυθμίσετε τον KerberosIV σε FreeBSD εκδόσεις πριν τη 5.0.</p></li><li><p>Πως να ρυθμίσετε τον Kerberos5 στο FreeBSD.</p></li><li><p>Πως να ρυθμίσετε το IPsec και να δημιουργήσετε ένα VPN μεταξύ μηχανημάτων FreeBSD/Windows®.</p></li><li><p>Πως να ρυθμίσετε και να χρησιμοποιήσετε την κατά FreeBSD υλοποίηση SSH του OpenSSH</p></li><li><p>Τι είναι τα ACLs στο σύστημα αρχείων και πως να τα χρησιμοποιήσετε.</p></li><li><p>Πως να χρησιμοποιήσετε το βοηθητικό πρόγραμμα Portaudit για να ελέγξετε λογισμικό τρίτου κατασκευαστή που έχει εγκατασταθεί μέσω της συλλογής Ports.</p></li><li><p>Πως να χρησιμοποιήσετε τις δημοσιεύσεις security advisories του FreeBSD.</p></li><li><p>Θα έχετε μια ιδέα για το τι είναι το Process Accounting και πως να το ενεργοποιήσετε στο FreeBSD.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε βασικές έννοιες του FreeBSD και του Internet.</p></li></ul></div><div class=paragraph><p>Πρόσθετα θέματα σχετικά με την ασφάλεια καλύπτονται σε ολόκληρο το βιβλίο. Για παράδειγμα, ο Υποχρεωτικός Έλεγχος Πρόσβασης συζητείται στο <a href=./#mac>Υποχρεωτικός Έλεγχος Πρόσβασης</a> και τα Internet Firewalls συζητούνται στο <a href=./#firewalls>Firewalls</a>.</p></div></div><div class=sect2><h3 id=security-intro>35.2. Introduction<a class=anchor href=#security-intro></a></h3><div class=paragraph><p>Security is a function that begins and ends with the system administrator. While all BSD UNIX® multi-user systems have some inherent security, the job of building and maintaining additional security mechanisms to keep those users "honest" is probably one of the single largest undertakings of the sysadmin. Machines are only as secure as you make them, and security concerns are ever competing with the human necessity for convenience. UNIX® systems, in general, are capable of running a huge number of simultaneous processes and many of these processes operate as servers - meaning that external entities can connect and talk to them. As yesterday’s mini-computers and mainframes become today’s desktops, and as computers become networked and inter-networked, security becomes an even bigger issue.</p></div><div class=paragraph><p>System security also pertains to dealing with various forms of attack, including attacks that attempt to crash, or otherwise make a system unusable, but do not attempt to compromise the <code>root</code> account ("break root"). Security concerns can be split up into several categories:</p></div><div class="olist arabic"><ol class=arabic><li><p>Denial of service attacks.</p></li><li><p>User account compromises.</p></li><li><p>Root compromise through accessible servers.</p></li><li><p>Root compromise via user accounts.</p></li><li><p>Backdoor creation.</p></li></ol></div><div class=paragraph><p>A denial of service attack is an action that deprives the machine of needed resources. Typically, DoS attacks are brute-force mechanisms that attempt to crash or otherwise make a machine unusable by overwhelming its servers or network stack. Some DoS attacks try to take advantage of bugs in the networking stack to crash a machine with a single packet. The latter can only be fixed by applying a bug fix to the kernel. Attacks on servers can often be fixed by properly specifying options to limit the load the servers incur on the system under adverse conditions. Brute-force network attacks are harder to deal with. A spoofed-packet attack, for example, is nearly impossible to stop, short of cutting your system off from the Internet. It may not be able to take your machine down, but it can saturate your Internet connection.</p></div><div class=paragraph><p>A user account compromise is even more common than a DoS attack. Many sysadmins still run standard telnetd, rlogind, rshd, and ftpd servers on their machines. These servers, by default, do not operate over encrypted connections. The result is that if you have any moderate-sized user base, one or more of your users logging into your system from a remote location (which is the most common and convenient way to login to a system) will have his or her password sniffed. The attentive system admin will analyze his remote access logs looking for suspicious source addresses even for successful logins.</p></div><div class=paragraph><p>One must always assume that once an attacker has access to a user account, the attacker can break <code>root</code>. However, the reality is that in a well secured and maintained system, access to a user account does not necessarily give the attacker access to <code>root</code>. The distinction is important because without access to <code>root</code> the attacker cannot generally hide his tracks and may, at best, be able to do nothing more than mess with the user’s files, or crash the machine. User account compromises are very common because users tend not to take the precautions that sysadmins take.</p></div><div class=paragraph><p>System administrators must keep in mind that there are potentially many ways to break <code>root</code> on a machine. The attacker may know the <code>root</code> password, the attacker may find a bug in a root-run server and be able to break <code>root</code> over a network connection to that server, or the attacker may know of a bug in a suid-root program that allows the attacker to break <code>root</code> once he has broken into a user’s account. If an attacker has found a way to break <code>root</code> on a machine, the attacker may not have a need to install a backdoor. Many of the <code>root</code> holes found and closed to date involve a considerable amount of work by the attacker to cleanup after himself, so most attackers install backdoors. A backdoor provides the attacker with a way to easily regain <code>root</code> access to the system, but it also gives the smart system administrator a convenient way to detect the intrusion. Making it impossible for an attacker to install a backdoor may actually be detrimental to your security, because it will not close off the hole the attacker found to break in the first place.</p></div><div class=paragraph><p>Security remedies should always be implemented with a multi-layered "onion peel" approach and can be categorized as follows:</p></div><div class="olist arabic"><ol class=arabic><li><p>Securing <code>root</code> and staff accounts.</p></li><li><p>Securing <code>root</code>-run servers and suid/sgid binaries.</p></li><li><p>Securing user accounts.</p></li><li><p>Securing the password file.</p></li><li><p>Securing the kernel core, raw devices, and file systems.</p></li><li><p>Quick detection of inappropriate changes made to the system.</p></li><li><p>Paranoia.</p></li></ol></div><div class=paragraph><p>The next section of this chapter will cover the above bullet items in greater depth.</p></div></div><div class=sect2><h3 id=securing-freebsd>35.3. Securing FreeBSD<a class=anchor href=#securing-freebsd></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Command vs. Protocol</div><div class=paragraph><p>Throughout this document, we will use bold text to refer to an application, and a <code>monospaced</code> font to refer to specific commands. Protocols will use a normal font. This typographical distinction is useful for instances such as ssh, since it is a protocol as well as command.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The sections that follow will cover the methods of securing your FreeBSD system that were mentioned in the <a href=./#security-intro>last section</a> of this chapter.</p></div><div class=sect3><h4 id=securing-root-and-staff>35.3.1. Securing the <code>root</code> Account and Staff Accounts<a class=anchor href=#securing-root-and-staff></a></h4><div class=paragraph><p>First off, do not bother securing staff accounts if you have not secured the <code>root</code> account. Most systems have a password assigned to the <code>root</code> account. The first thing you do is assume that the password is <em>always</em> compromised. This does not mean that you should remove the password. The password is almost always necessary for console access to the machine. What it does mean is that you should not make it possible to use the password outside of the console or possibly even with the <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> command. For example, make sure that your ptys are specified as being insecure in the <span class=filename>/etc/ttys</span> file so that direct <code>root</code> logins via <code>telnet</code> or <code>rlogin</code> are disallowed. If using other login services such as sshd, make sure that direct <code>root</code> logins are disabled there as well. You can do this by editing your <span class=filename>/etc/ssh/sshd_config</span> file, and making sure that <code>PermitRootLogin</code> is set to <code>NO</code>. Consider every access method - services such as FTP often fall through the cracks. Direct <code>root</code> logins should only be allowed via the system console.</p></div><div class=paragraph><p>Of course, as a sysadmin you have to be able to get to <code>root</code>, so we open up a few holes. But we make sure these holes require additional password verification to operate. One way to make <code>root</code> accessible is to add appropriate staff accounts to the <code>wheel</code> group (in <span class=filename>/etc/group</span>). The staff members placed in the <code>wheel</code> group are allowed to <code>su</code> to <code>root</code>. You should never give staff members native <code>wheel</code> access by putting them in the <code>wheel</code> group in their password entry. Staff accounts should be placed in a <code>staff</code> group, and then added to the <code>wheel</code> group via the <span class=filename>/etc/group</span> file. Only those staff members who actually need to have <code>root</code> access should be placed in the <code>wheel</code> group. It is also possible, when using an authentication method such as Kerberos, to use Kerberos' <span class=filename>.k5login</span> file in the <code>root</code> account to allow a <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> to <code>root</code> without having to place anyone at all in the <code>wheel</code> group. This may be the better solution since the <code>wheel</code> mechanism still allows an intruder to break <code>root</code> if the intruder has gotten hold of your password file and can break into a staff account. While having the <code>wheel</code> mechanism is better than having nothing at all, it is not necessarily the safest option.</p></div><div class=paragraph><p>An indirect way to secure staff accounts, and ultimately <code>root</code> access is to use an alternative login access method and do what is known as "starring" out the encrypted password for the staff accounts. Using the <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> command, one can replace each instance of an encrypted password with a single “*” character. This command will update the <span class=filename>/etc/master.passwd</span> file and user/password database to disable password-authenticated logins.</p></div><div class=paragraph><p>A staff account entry such as:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>Should be changed to this:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>This change will prevent normal logins from occurring, since the encrypted password will never match “*”. With this done, staff members must use another mechanism to authenticate themselves such as <a href="https://man.freebsd.org/cgi/man.cgi?query=kerberos&amp;sektion=1&amp;format=html">kerberos(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> using a public/private key pair. When using something like Kerberos, one generally must secure the machines which run the Kerberos servers and your desktop workstation. When using a public/private key pair with ssh, one must generally secure the machine used to login <em>from</em> (typically one’s workstation). An additional layer of protection can be added to the key pair by password protecting the key pair when creating it with <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>. Being able to "star" out the passwords for staff accounts also guarantees that staff members can only login through secure access methods that you have set up. This forces all staff members to use secure, encrypted connections for all of their sessions, which closes an important hole used by many intruders: sniffing the network from an unrelated, less secure machine.</p></div><div class=paragraph><p>The more indirect security mechanisms also assume that you are logging in from a more restrictive server to a less restrictive server. For example, if your main box is running all sorts of servers, your workstation should not be running any. In order for your workstation to be reasonably secure you should run as few servers as possible, up to and including no servers at all, and you should run a password-protected screen blanker. Of course, given physical access to a workstation an attacker can break any sort of security you put on it. This is definitely a problem that you should consider, but you should also consider the fact that the vast majority of break-ins occur remotely, over a network, from people who do not have physical access to your workstation or servers.</p></div><div class=paragraph><p>Using something like Kerberos also gives you the ability to disable or change the password for a staff account in one place, and have it immediately affect all the machines on which the staff member may have an account. If a staff member’s account gets compromised, the ability to instantly change his password on all machines should not be underrated. With discrete passwords, changing a password on N machines can be a mess. You can also impose re-passwording restrictions with Kerberos: not only can a Kerberos ticket be made to timeout after a while, but the Kerberos system can require that the user choose a new password after a certain period of time (say, once a month).</p></div></div><div class=sect3><h4 id=_securing_root_run_servers_and_suidsgid_binaries>35.3.2. Securing Root-run Servers and SUID/SGID Binaries<a class=anchor href=#_securing_root_run_servers_and_suidsgid_binaries></a></h4><div class=paragraph><p>The prudent sysadmin only runs the servers he needs to, no more, no less. Be aware that third party servers are often the most bug-prone. For example, running an old version of imapd or popper is like giving a universal <code>root</code> ticket out to the entire world. Never run a server that you have not checked out carefully. Many servers do not need to be run as <code>root</code>. For example, the ntalk, comsat, and finger daemons can be run in special user <em>sandboxes</em>. A sandbox is not perfect, unless you go through a large amount of trouble, but the onion approach to security still stands: If someone is able to break in through a server running in a sandbox, they still have to break out of the sandbox. The more layers the attacker must break through, the lower the likelihood of his success. Root holes have historically been found in virtually every server ever run as <code>root</code>, including basic system servers. If you are running a machine through which people only login via sshd and never login via telnetd or rshd or rlogind, then turn off those services!</p></div><div class=paragraph><p>FreeBSD now defaults to running ntalkd, comsat, and finger in a sandbox. Another program which may be a candidate for running in a sandbox is <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. <span class=filename>/etc/defaults/rc.conf</span> includes the arguments necessary to run named in a sandbox in a commented-out form. Depending on whether you are installing a new system or upgrading an existing system, the special user accounts used by these sandboxes may not be installed. The prudent sysadmin would research and implement sandboxes for servers whenever possible.</p></div><div class=paragraph><p>There are a number of other servers that typically do not run in sandboxes: sendmail, popper, imapd, ftpd, and others. There are alternatives to some of these, but installing them may require more work than you are willing to perform (the convenience factor strikes again). You may have to run these servers as <code>root</code> and rely on other mechanisms to detect break-ins that might occur through them.</p></div><div class=paragraph><p>The other big potential <code>root</code> holes in a system are the suid-root and sgid binaries installed on the system. Most of these binaries, such as rlogin, reside in <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span>, or <span class=filename>/usr/sbin</span>. While nothing is 100% safe, the system-default suid and sgid binaries can be considered reasonably safe. Still, <code>root</code> holes are occasionally found in these binaries. A <code>root</code> hole was found in <code>Xlib</code> in 1998 that made xterm (which is typically suid) vulnerable. It is better to be safe than sorry and the prudent sysadmin will restrict suid binaries, that only staff should run, to a special group that only staff can access, and get rid of (<code>chmod 000</code>) any suid binaries that nobody uses. A server with no display generally does not need an xterm binary. Sgid binaries can be almost as dangerous. If an intruder can break an sgid-kmem binary, the intruder might be able to read <span class=filename>/dev/kmem</span> and thus read the encrypted password file, potentially compromising any passworded account. Alternatively an intruder who breaks group <code>kmem</code> can monitor keystrokes sent through ptys, including ptys used by users who login through secure methods. An intruder that breaks the <code>tty</code> group can write to almost any user’s tty. If a user is running a terminal program or emulator with a keyboard-simulation feature, the intruder can potentially generate a data stream that causes the user’s terminal to echo a command, which is then run as that user.</p></div></div><div class=sect3><h4 id=secure-users>35.3.3. Securing User Accounts<a class=anchor href=#secure-users></a></h4><div class=paragraph><p>User accounts are usually the most difficult to secure. While you can impose draconian access restrictions on your staff and "star" out their passwords, you may not be able to do so with any general user accounts you might have. If you do have sufficient control, then you may win out and be able to secure the user accounts properly. If not, you simply have to be more vigilant in your monitoring of those accounts. Use of ssh and Kerberos for user accounts is more problematic, due to the extra administration and technical support required, but still a very good solution compared to a encrypted password file.</p></div></div><div class=sect3><h4 id=_securing_the_password_file>35.3.4. Securing the Password File<a class=anchor href=#_securing_the_password_file></a></h4><div class=paragraph><p>The only sure fire way is to star out as many passwords as you can and use ssh or Kerberos for access to those accounts. Even though the encrypted password file (<span class=filename>/etc/spwd.db</span>) can only be read by <code>root</code>, it may be possible for an intruder to obtain read access to that file even if the attacker cannot obtain root-write access.</p></div><div class=paragraph><p>Your security scripts should always check for and report changes to the password file (see the <a href=#security-integrity>Checking file integrity</a> section below).</p></div></div><div class=sect3><h4 id=_securing_the_kernel_core_raw_devices_and_file_systems>35.3.5. Securing the Kernel Core, Raw Devices, and File systems<a class=anchor href=#_securing_the_kernel_core_raw_devices_and_file_systems></a></h4><div class=paragraph><p>If an attacker breaks <code>root</code> he can do just about anything, but there are certain conveniences. For example, most modern kernels have a packet sniffing device driver built in. Under FreeBSD it is called the <span class=filename>bpf</span> device. An intruder will commonly attempt to run a packet sniffer on a compromised machine. You do not need to give the intruder the capability and most systems do not have the need for the <span class=filename>bpf</span> device compiled in.</p></div><div class=paragraph><p>But even if you turn off the <span class=filename>bpf</span> device, you still have <span class=filename>/dev/mem</span> and <span class=filename>/dev/kmem</span> to worry about. For that matter, the intruder can still write to raw disk devices. Also, there is another kernel feature called the module loader, <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. An enterprising intruder can use a KLD module to install his own <span class=filename>bpf</span> device, or other sniffing device, on a running kernel. To avoid these problems you have to run the kernel at a higher secure level, at least securelevel 1. The securelevel can be set with a <code>sysctl</code> on the <code>kern.securelevel</code> variable. Once you have set the securelevel to 1, write access to raw devices will be denied and special <code>chflags</code> flags, such as <code>schg</code>, will be enforced. You must also ensure that the <code>schg</code> flag is set on critical startup binaries, directories, and script files - everything that gets run up to the point where the securelevel is set. This might be overdoing it, and upgrading the system is much more difficult when you operate at a higher secure level. You may compromise and run the system at a higher secure level but not set the <code>schg</code> flag for every system file and directory under the sun. Another possibility is to simply mount <span class=filename>/</span> and <span class=filename>/usr</span> read-only. It should be noted that being too draconian in what you attempt to protect may prevent the all-important detection of an intrusion.</p></div></div><div class=sect3><h4 id=security-integrity>35.3.6. Checking File Integrity: Binaries, Configuration Files, Etc.<a class=anchor href=#security-integrity></a></h4><div class=paragraph><p>When it comes right down to it, you can only protect your core system configuration and control files so much before the convenience factor rears its ugly head. For example, using <code>chflags</code> to set the <code>schg</code> bit on most of the files in <span class=filename>/</span> and <span class=filename>/usr</span> is probably counterproductive, because while it may protect the files, it also closes a detection window. The last layer of your security onion is perhaps the most important - detection. The rest of your security is pretty much useless (or, worse, presents you with a false sense of security) if you cannot detect potential intrusions. Half the job of the onion is to slow down the attacker, rather than stop him, in order to be able to catch him in the act.</p></div><div class=paragraph><p>The best way to detect an intrusion is to look for modified, missing, or unexpected files. The best way to look for modified files is from another (often centralized) limited-access system. Writing your security scripts on the extra-secure limited-access system makes them mostly invisible to potential attackers, and this is important. In order to take maximum advantage you generally have to give the limited-access box significant access to the other machines in the business, usually either by doing a read-only NFS export of the other machines to the limited-access box, or by setting up ssh key-pairs to allow the limited-access box to ssh to the other machines. Except for its network traffic, NFS is the least visible method - allowing you to monitor the file systems on each client box virtually undetected. If your limited-access server is connected to the client boxes through a switch, the NFS method is often the better choice. If your limited-access server is connected to the client boxes through a hub, or through several layers of routing, the NFS method may be too insecure (network-wise) and using ssh may be the better choice even with the audit-trail tracks that ssh lays.</p></div><div class=paragraph><p>Once you have given a limited-access box at least read access to the client systems it is supposed to monitor, you must write scripts to do the actual monitoring. Given an NFS mount, you can write scripts out of simple system utilities such as <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=md5&amp;sektion=1&amp;format=html">md5(1)</a>. It is best to physically md5 the client-box files at least once a day, and to test control files such as those found in <span class=filename>/etc</span> and <span class=filename>/usr/local/etc</span> even more often. When mismatches are found, relative to the base md5 information the limited-access machine knows is valid, it should scream at a sysadmin to go check it out. A good security script will also check for inappropriate suid binaries and for new or deleted files on system partitions such as <span class=filename>/</span> and <span class=filename>/usr</span>.</p></div><div class=paragraph><p>When using ssh rather than NFS, writing the security script is much more difficult. You essentially have to <code>scp</code> the scripts to the client box in order to run them, making them visible, and for safety you also need to <code>scp</code> the binaries (such as find) that those scripts use. The ssh client on the client box may already be compromised. All in all, using ssh may be necessary when running over insecure links, but it is also a lot harder to deal with.</p></div><div class=paragraph><p>A good security script will also check for changes to user and staff members access configuration files: <span class=filename>.rhosts</span>, <span class=filename>.shosts</span>, <span class=filename>.ssh/authorized_keys</span> and so forth, files that might fall outside the purview of the <code>MD5</code> check.</p></div><div class=paragraph><p>If you have a huge amount of user disk space, it may take too long to run through every file on those partitions. In this case, setting mount flags to disallow suid binaries and devices on those partitions is a good idea. The <code>nodev</code> and <code>nosuid</code> options (see <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>) are what you want to look into. You should probably scan them anyway, at least once a week, since the object of this layer is to detect a break-in attempt, whether or not the attempt succeeds.</p></div><div class=paragraph><p>Process accounting (see <a href="https://man.freebsd.org/cgi/man.cgi?query=accton&amp;sektion=8&amp;format=html">accton(8)</a>) is a relatively low-overhead feature of the operating system which might help as a post-break-in evaluation mechanism. It is especially useful in tracking down how an intruder has actually broken into a system, assuming the file is still intact after the break-in has occurred.</p></div><div class=paragraph><p>Finally, security scripts should process the log files, and the logs themselves should be generated in as secure a manner as possible - remote syslog can be very useful. An intruder will try to cover his tracks, and log files are critical to the sysadmin trying to track down the time and method of the initial break-in. One way to keep a permanent record of the log files is to run the system console to a serial port and collect the information to a secure machine monitoring the consoles.</p></div></div><div class=sect3><h4 id=_paranoia>35.3.7. Paranoia<a class=anchor href=#_paranoia></a></h4><div class=paragraph><p>A little paranoia never hurts. As a rule, a sysadmin can add any number of security features, as long as they do not affect convenience, and can add security features that <em>do</em> affect convenience with some added thought. Even more importantly, a security administrator should mix it up a bit - if you use recommendations such as those given by this document verbatim, you give away your methodologies to the prospective attacker who also has access to this document.</p></div></div><div class=sect3><h4 id=_denial_of_service_attacks>35.3.8. Denial of Service Attacks<a class=anchor href=#_denial_of_service_attacks></a></h4><div class=paragraph><p>This section covers Denial of Service attacks. A DoS attack is typically a packet attack. While there is not much you can do about modern spoofed packet attacks that saturate your network, you can generally limit the damage by ensuring that the attacks cannot take down your servers by:</p></div><div class="olist arabic"><ol class=arabic><li><p>Limiting server forks.</p></li><li><p>Limiting springboard attacks (ICMP response attacks, ping broadcast, etc.).</p></li><li><p>Overloading the Kernel Route Cache.</p></li></ol></div><div class=paragraph><p>A common DoS attack scenario is attacking a forking server and making it spawning so many child processes that the host system eventually runs out of memory, file descriptors, etc. and then grinds to a halt. inetd (see <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>) has several options to limit this sort of attack. It should be noted that while it is possible to prevent a machine from going down, it is not generally possible to prevent a service from being disrupted by the attack. Read the inetd manual page carefully and pay specific attention to the <code>-c</code>, <code>-C</code>, and <code>-R</code> options. Note that spoofed-IP attacks will circumvent the <code>-C</code> option to inetd, so typically a combination of options must be used. Some standalone servers have self-fork-limitation parameters.</p></div><div class=paragraph><p>Sendmail has its <code>-OMaxDaemonChildren</code> option, which tends to work much better than trying to use Sendmail’s load limiting options due to the load lag. You should specify a <code>MaxDaemonChildren</code> parameter, when you start sendmail; high enough to handle your expected load, but not so high that the computer cannot handle that number of Sendmail instances without falling on its face. It is also prudent to run Sendmail in queued mode (<code>-ODeliveryMode=queued</code>) and to run the daemon (<code>sendmail -bd</code>) separate from the queue-runs (<code>sendmail -q15m</code>). If you still want real-time delivery you can run the queue at a much lower interval, such as <code>-q1m</code>, but be sure to specify a reasonable <code>MaxDaemonChildren</code> option for <em>that</em> Sendmail to prevent cascade failures.</p></div><div class=paragraph><p>Syslogd can be attacked directly and it is strongly recommended that you use the <code>-s</code> option whenever possible, and the <code>-a</code> option otherwise.</p></div><div class=paragraph><p>You should also be fairly careful with connect-back services such as TCP Wrapper’s reverse-identd, which can be attacked directly. You generally do not want to use the reverse-ident feature of TCP Wrapper for this reason.</p></div><div class=paragraph><p>It is a very good idea to protect internal services from external access by firewalling them off at your border routers. The idea here is to prevent saturation attacks from outside your LAN, not so much to protect internal services from network-based <code>root</code> compromise. Always configure an exclusive firewall, i.e., "firewall everything <em>except</em> ports A, B, C, D, and M-Z". This way you can firewall off all of your low ports except for certain specific services such as named (if you are primary for a zone), ntalkd, sendmail, and other Internet-accessible services. If you try to configure the firewall the other way - as an inclusive or permissive firewall, there is a good chance that you will forget to "close" a couple of services, or that you will add a new internal service and forget to update the firewall. You can still open up the high-numbered port range on the firewall, to allow permissive-like operation, without compromising your low ports. Also take note that FreeBSD allows you to control the range of port numbers used for dynamic binding, via the various <code>net.inet.ip.portrange sysctl</code>'s (<code>sysctl -a | fgrep portrange</code>), which can also ease the complexity of your firewall’s configuration. For example, you might use a normal first/last range of 4000 to 5000, and a hiport range of 49152 to 65535, then block off everything under 4000 in your firewall (except for certain specific Internet-accessible ports, of course).</p></div><div class=paragraph><p>Another common DoS attack is called a springboard attack - to attack a server in a manner that causes the server to generate responses which overloads the server, the local network, or some other machine. The most common attack of this nature is the <em>ICMP ping broadcast attack</em>. The attacker spoofs ping packets sent to your LAN’s broadcast address with the source IP address set to the actual machine they wish to attack. If your border routers are not configured to stomp on ping packets to broadcast addresses, your LAN winds up generating sufficient responses to the spoofed source address to saturate the victim, especially when the attacker uses the same trick on several dozen broadcast addresses over several dozen different networks at once. Broadcast attacks of over a hundred and twenty megabits have been measured. A second common springboard attack is against the ICMP error reporting system. By constructing packets that generate ICMP error responses, an attacker can saturate a server’s incoming network and cause the server to saturate its outgoing network with ICMP responses. This type of attack can also crash the server by running it out of memory, especially if the server cannot drain the ICMP responses it generates fast enough. Use the sysctl variable <code>net.inet.icmp.icmplim</code> to limit these attacks. The last major class of springboard attacks is related to certain internal inetd services such as the udp echo service. An attacker simply spoofs a UDP packet with the source address being server A’s echo port, and the destination address being server B’s echo port, where server A and B are both on your LAN. The two servers then bounce this one packet back and forth between each other. The attacker can overload both servers and their LANs simply by injecting a few packets in this manner. Similar problems exist with the internal chargen port. A competent sysadmin will turn off all of these inetd-internal test services.</p></div><div class=paragraph><p>Spoofed packet attacks may also be used to overload the kernel route cache. Refer to the <code>net.inet.ip.rtexpire</code>, <code>rtminexpire</code>, and <code>rtmaxcache sysctl</code> parameters. A spoofed packet attack that uses a random source IP will cause the kernel to generate a temporary cached route in the route table, viewable with <code>netstat -rna | fgrep W3</code>. These routes typically timeout in 1600 seconds or so. If the kernel detects that the cached route table has gotten too big it will dynamically reduce the <code>rtexpire</code> but will never decrease it to less than <code>rtminexpire</code>. There are two problems:</p></div><div class="olist arabic"><ol class=arabic><li><p>The kernel does not react quickly enough when a lightly loaded server is suddenly attacked.</p></li><li><p>The <code>rtminexpire</code> is not low enough for the kernel to survive a sustained attack.</p></li></ol></div><div class=paragraph><p>If your servers are connected to the Internet via a T3 or better, it may be prudent to manually override both <code>rtexpire</code> and <code>rtminexpire</code> via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Never set either parameter to zero (unless you want to crash the machine). Setting both parameters to 2 seconds should be sufficient to protect the route table from attack.</p></div></div><div class=sect3><h4 id=_access_issues_with_kerberos_and_ssh>35.3.9. Access Issues with Kerberos and SSH<a class=anchor href=#_access_issues_with_kerberos_and_ssh></a></h4><div class=paragraph><p>There are a few issues with both Kerberos and ssh that need to be addressed if you intend to use them. Kerberos 5 is an excellent authentication protocol, but there are bugs in the kerberized telnet and rlogin applications that make them unsuitable for dealing with binary streams. Also, by default Kerberos does not encrypt a session unless you use the <code>-x</code> option. ssh encrypts everything by default.</p></div><div class=paragraph><p>Ssh works quite well in every respect except that it forwards encryption keys by default. What this means is that if you have a secure workstation holding keys that give you access to the rest of the system, and you ssh to an insecure machine, your keys are usable. The actual keys themselves are not exposed, but ssh installs a forwarding port for the duration of your login, and if an attacker has broken <code>root</code> on the insecure machine he can utilize that port to use your keys to gain access to any other machine that your keys unlock.</p></div><div class=paragraph><p>We recommend that you use ssh in combination with Kerberos whenever possible for staff logins. Ssh can be compiled with Kerberos support. This reduces your reliance on potentially exposed ssh keys while at the same time protecting passwords via Kerberos. Ssh keys should only be used for automated tasks from secure machines (something that Kerberos is unsuited to do). We also recommend that you either turn off key-forwarding in the ssh configuration, or that you make use of the <code>from=IP/DOMAIN</code> option that ssh allows in its <span class=filename>authorized_keys</span> file to make the key only usable to entities logging in from specific machines.</p></div></div></div><div class=sect2><h3 id=crypt>35.4. DES, MD5, and Crypt<a class=anchor href=#crypt></a></h3><div class=paragraph><p>Every user on a UNIX® system has a password associated with their account. It seems obvious that these passwords need to be known only to the user and the actual operating system. In order to keep these passwords secret, they are encrypted with what is known as a "one-way hash", that is, they can only be easily encrypted but not decrypted. In other words, what we told you a moment ago was obvious is not even true: the operating system itself does not <em>really</em> know the password. It only knows the <em>encrypted</em> form of the password. The only way to get the "plain-text" password is by a brute force search of the space of possible passwords.</p></div><div class=paragraph><p>Unfortunately the only secure way to encrypt passwords when UNIX® came into being was based on DES, the Data Encryption Standard. This was not such a problem for users resident in the US, but since the source code for DES could not be exported outside the US, FreeBSD had to find a way to both comply with US law and retain compatibility with all the other UNIX® variants that still used DES.</p></div><div class=paragraph><p>The solution was to divide up the encryption libraries so that US users could install the DES libraries and use DES but international users still had an encryption method that could be exported abroad. This is how FreeBSD came to use MD5 as its default encryption method. MD5 is believed to be more secure than DES, so installing DES is offered primarily for compatibility reasons.</p></div><div class=sect3><h4 id=_recognizing_your_crypt_mechanism>35.4.1. Recognizing Your Crypt Mechanism<a class=anchor href=#_recognizing_your_crypt_mechanism></a></h4><div class=paragraph><p>Currently the library supports DES, MD5 and Blowfish hash functions. By default FreeBSD uses MD5 to encrypt passwords.</p></div><div class=paragraph><p>It is pretty easy to identify which encryption method FreeBSD is set up to use. Examining the encrypted passwords in the <span class=filename>/etc/master.passwd</span> file is one way. Passwords encrypted with the MD5 hash are longer than those encrypted with the DES hash and also begin with the characters <code>$1$</code>. Passwords starting with <code>$2a$</code> are encrypted with the Blowfish hash function. DES password strings do not have any particular identifying characteristics, but they are shorter than MD5 passwords, and are coded in a 64-character alphabet which does not include the <code>$</code> character, so a relatively short string which does not begin with a dollar sign is very likely a DES password.</p></div><div class=paragraph><p>The password format used for new passwords is controlled by the <code>passwd_format</code> login capability in <span class=filename>/etc/login.conf</span>, which takes values of <code>des</code>, <code>md5</code> or <code>blf</code>. See the <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> manual page for more information about login capabilities.</p></div></div></div><div class=sect2><h3 id=one-time-passwords>35.5. One-time Passwords<a class=anchor href=#one-time-passwords></a></h3><div class=paragraph><p>By default, FreeBSD includes support for OPIE (One-time Passwords In Everything), which uses the MD5 hash by default.</p></div><div class=paragraph><p>There are three different sorts of passwords which we will discuss below. The first is your usual UNIX® style or Kerberos password; we will call this a "UNIX® password". The second sort is the one-time password which is generated by the OPIE <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> program and accepted by the <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> program and the login prompt; we will call this a "one-time password". The final sort of password is the secret password which you give to the <code>opiekey</code> program (and sometimes the <code>opiepasswd</code> programs) which it uses to generate one-time passwords; we will call it a "secret password" or just unqualified "password".</p></div><div class=paragraph><p>The secret password does not have anything to do with your UNIX® password; they can be the same but this is not recommended. OPIE secret passwords are not limited to 8 characters like old UNIX® passwords, they can be as long as you like. Passwords of six or seven word long phrases are fairly common. For the most part, the OPIE system operates completely independently of the UNIX® password system.</p></div><div class=paragraph><p>Besides the password, there are two other pieces of data that are important to OPIE. One is what is known as the "seed" or "key", consisting of two letters and five digits. The other is what is called the "iteration count", a number between 1 and 100. OPIE creates the one-time password by concatenating the seed and the secret password, then applying the MD5 hash as many times as specified by the iteration count and turning the result into six short English words. These six English words are your one-time password. The authentication system (primarily PAM) keeps track of the last one-time password used, and the user is authenticated if the hash of the user-provided password is equal to the previous password. Because a one-way hash is used it is impossible to generate future one-time passwords if a successfully used password is captured; the iteration count is decremented after each successful login to keep the user and the login program in sync. When the iteration count gets down to 1, OPIE must be reinitialized.</p></div><div class=paragraph><p>There are a few programs involved in each system which we will discuss below. The <code>opiekey</code> program accepts an iteration count, a seed, and a secret password, and generates a one-time password or a consecutive list of one-time passwords. The <code>opiepasswd</code> program is used to initialize OPIE, and to change passwords, iteration counts, or seeds; it takes either a secret passphrase, or an iteration count, seed, and a one-time password. The <code>opieinfo</code> program will examine the relevant credentials files (<span class=filename>/etc/opiekeys</span>) and print out the invoking user’s current iteration count and seed.</p></div><div class=paragraph><p>There are four different sorts of operations we will cover. The first is using <code>opiepasswd</code> over a secure connection to set up one-time-passwords for the first time, or to change your password or seed. The second operation is using <code>opiepasswd</code> over an insecure connection, in conjunction with <code>opiekey</code> over a secure connection, to do the same. The third is using <code>opiekey</code> to log in over an insecure connection. The fourth is using <code>opiekey</code> to generate a number of keys which can be written down or printed out to carry with you when going to some location without secure connections to anywhere.</p></div><div class=sect3><h4 id=_secure_connection_initialization>35.5.1. Secure Connection Initialization<a class=anchor href=#_secure_connection_initialization></a></h4><div class=paragraph><p>To initialize OPIE for the first time, execute the <code>opiepasswd</code> command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>At the <code>Enter new secret pass phrase:</code> or <code>Enter secret password:</code> prompts, you should enter a password or phrase. Remember, this is not the password that you will use to login with, this is used to generate your one-time login keys. The "ID" line gives the parameters of your particular instance: your login name, the iteration count, and seed. When logging in the system will remember these parameters and present them back to you so you do not have to remember them. The last line gives the particular one-time password which corresponds to those parameters and your secret password; if you were to re-login immediately, this one-time password is the one you would use.</p></div></div><div class=sect3><h4 id=_insecure_connection_initialization>35.5.2. Insecure Connection Initialization<a class=anchor href=#_insecure_connection_initialization></a></h4><div class=paragraph><p>To initialize or change your secret password over an insecure connection, you will need to already have a secure connection to some place where you can run <code>opiekey</code>; this might be in the form of a shell prompt on a machine you trust. You will also need to make up an iteration count (100 is probably a good value), and you may make up your own seed or use a randomly-generated one. Over on the insecure connection (to the machine you are initializing), use <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>To accept the default seed press <kbd>Return</kbd>. Then before entering an access password, move over to your secure connection and give it the same parameters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</span></code></pre></div></div><div class=paragraph><p>Now switch back over to the insecure connection, and copy the one-time password generated over to the relevant program.</p></div></div><div class=sect3><h4 id=_generating_a_single_one_time_password>35.5.3. Generating a Single One-time Password<a class=anchor href=#_generating_a_single_one_time_password></a></h4><div class=paragraph><p>Once you have initialized OPIE and login, you will be presented with a prompt like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>As a side note, the OPIE prompts have a useful feature (not shown here): if you press <kbd>Return</kbd> at the password prompt, the prompter will turn echo on, so you can see what you are typing. This can be extremely useful if you are attempting to type in a password by hand, such as from a printout.</p></div><div class=paragraph><p>At this point you need to generate your one-time password to answer this login prompt. This must be done on a trusted system that you can run <code>opiekey</code> on. (There are versions of these for DOS, Windows® and Mac OS® as well.) They need the iteration count and the seed as command line options. You can cut-and-paste these right from the login prompt on the machine that you are logging in to.</p></div><div class=paragraph><p>On the trusted system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Now that you have your one-time password you can continue logging in.</p></div></div><div class=sect3><h4 id=_generating_multiple_one_time_passwords>35.5.4. Generating Multiple One-time Passwords<a class=anchor href=#_generating_multiple_one_time_passwords></a></h4><div class=paragraph><p>Sometimes you have to go places where you do not have access to a trusted machine or secure connection. In this case, it is possible to use the <code>opiekey</code> command to generate a number of one-time passwords beforehand to be printed out and taken with you. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</span></code></pre></div></div><div class=paragraph><p>The <code>-n 5</code> requests five keys in sequence, the <code>30</code> specifies what the last iteration number should be. Note that these are printed out in <em>reverse</em> order of eventual use. If you are really paranoid, you might want to write the results down by hand; otherwise you can cut-and-paste into <code>lpr</code>. Note that each line shows both the iteration count and the one-time password; you may still find it handy to scratch off passwords as you use them.</p></div></div><div class=sect3><h4 id=_restricting_use_of_unix_passwords>35.5.5. Restricting Use of UNIX® Passwords<a class=anchor href=#_restricting_use_of_unix_passwords></a></h4><div class=paragraph><p>OPIE can restrict the use of UNIX® passwords based on the IP address of a login session. The relevant file is <span class=filename>/etc/opieaccess</span>, which is present by default. Please check <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> for more information on this file and which security considerations you should be aware of when using it.</p></div><div class=paragraph><p>Here is a sample <span class=filename>opieaccess</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>This line allows users whose IP source address (which is vulnerable to spoofing) matches the specified value and mask, to use UNIX® passwords at any time.</p></div><div class=paragraph><p>If no rules in <span class=filename>opieaccess</span> are matched, the default is to deny non-OPIE logins.</p></div></div></div><div class=sect2><h3 id=tcpwrappers>35.6. TCP Wrappers<a class=anchor href=#tcpwrappers></a></h3><div class=paragraph><p>Anyone familiar with <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> has probably heard of TCP Wrappers at some point. But few individuals seem to fully comprehend its usefulness in a network environment. It seems that everyone wants to install a firewall to handle network connections. While a firewall has a wide variety of uses, there are some things that a firewall not handle such as sending text back to the connection originator. The TCP software does this and much more. In the next few sections many of the TCP Wrappers features will be discussed, and, when applicable, example configuration lines will be provided.</p></div><div class=paragraph><p>The TCP Wrappers software extends the abilities of <code>inetd</code> to provide support for every server daemon under its control. Using this method it is possible to provide logging support, return messages to connections, permit a daemon to only accept internal connections, etc. While some of these features can be provided by implementing a firewall, this will add not only an extra layer of protection but go beyond the amount of control a firewall can provide.</p></div><div class=paragraph><p>The added functionality of TCP Wrappers should not be considered a replacement for a good firewall. TCP Wrappers can be used in conjunction with a firewall or other security enhancements though and it can serve nicely as an extra layer of protection for the system.</p></div><div class=paragraph><p>Since this is an extension to the configuration of <code>inetd</code>, the reader is expected have read the <a href=./#network-inetd>inetd configuration</a> section.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While programs run by <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> are not exactly "daemons", they have traditionally been called daemons. This is the term we will use in this section too.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_initial_configuration>35.6.1. Initial Configuration<a class=anchor href=#_initial_configuration></a></h4><div class=paragraph><p>The only requirement of using TCP Wrappers in FreeBSD is to ensure the <code>inetd</code> server is started from <span class=filename>rc.conf</span> with the <code>-Ww</code> option; this is the default setting. Of course, proper configuration of <span class=filename>/etc/hosts.allow</span> is also expected, but <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> will throw messages in the system logs in these cases.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Unlike other implementations of TCP Wrappers, the use of <span class=filename>hosts.deny</span> has been deprecated. All configuration options should be placed in <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In the simplest configuration, daemon connection policies are set to either be permitted or blocked depending on the options in <span class=filename>/etc/hosts.allow</span>. The default configuration in FreeBSD is to allow a connection to every daemon started with <code>inetd</code>. Changing this will be discussed only after the basic configuration is covered.</p></div><div class=paragraph><p>Basic configuration usually takes the form of <code>daemon : address : action</code>. Where <code>daemon</code> is the daemon name which <code>inetd</code> started. The <code>address</code> can be a valid hostname, an IP address or an IPv6 address enclosed in brackets ([ ]). The action field can be either allow or deny to grant or deny access appropriately. Keep in mind that configuration works off a first rule match semantic, meaning that the configuration file is scanned in ascending order for a matching rule. When a match is found the rule is applied and the search process will halt.</p></div><div class=paragraph><p>Several other options exist but they will be explained in a later section. A simple configuration line may easily be constructed from that information alone. For example, to allow POP3 connections via the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a> daemon, the following lines should be appended to <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>After adding this line, <code>inetd</code> will need restarted. This can be accomplished by use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> command, or with the <span class=parameter>restart</span> parameter with <span class=filename>/etc/rc.d/inetd</span>.</p></div></div><div class=sect3><h4 id=_advanced_configuration>35.6.2. Advanced Configuration<a class=anchor href=#_advanced_configuration></a></h4><div class=paragraph><p>TCP Wrappers has advanced options too; they will allow for more control over the way connections are handled. In some cases it may be a good idea to return a comment to certain hosts or daemon connections. In other cases, perhaps a log file should be recorded or an email sent to the administrator. Other situations may require the use of a service for local connections only. This is all possible through the use of configuration options known as <code>wildcards</code>, expansion characters and external command execution. The next two sections are written to cover these situations.</p></div><div class=sect4><h5 id=_external_commands>35.6.2.1. External Commands<a class=anchor href=#_external_commands></a></h5><div class=paragraph><p>Suppose that a situation occurs where a connection should be denied yet a reason should be sent to the individual who attempted to establish that connection. How could it be done? That action can be made possible by using the <code>twist</code> option. When a connection attempt is made, <code>twist</code> will be called to execute a shell command or script. An example already exists in the <span class=filename>hosts.allow</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>This example shows that the message, "You are not allowed to use <code>daemon</code> from <code>hostname</code>." will be returned for any daemon not previously configured in the access file. This is extremely useful for sending a reply back to the connection initiator right after the established connection is dropped. Note that any message returned <em>must</em> be wrapped in quote <code>"</code> characters; there are no exceptions to this rule.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>It may be possible to launch a denial of service attack on the server if an attacker, or group of attackers could flood these daemons with connection requests.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Another possibility is to use the <code>spawn</code> option in these cases. Like <code>twist</code>, the <code>spawn</code> implicitly denies the connection and may be used to run external shell commands or scripts. Unlike <code>twist</code>, <code>spawn</code> will not send a reply back to the individual who established the connection. For an example, consider the following configuration line:</p></div><div class="literalblock programlisting"><div class=content><pre># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>This will deny all connection attempts from the <code>*.example.com</code> domain; simultaneously logging the hostname, IP address and the daemon which they attempted to access in the <span class=filename>/var/log/connections.log</span> file.</p></div><div class=paragraph><p>Aside from the already explained substitution characters above, e.g. %a, a few others exist. See the <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> manual page for the complete list.</p></div></div><div class=sect4><h5 id=_wildcard_options>35.6.2.2. Wildcard Options<a class=anchor href=#_wildcard_options></a></h5><div class=paragraph><p>Thus far the <code>ALL</code> example has been used continuously throughout the examples. Other options exist which could extend the functionality a bit further. For instance, <code>ALL</code> may be used to match every instance of either a daemon, domain or an IP address. Another wildcard available is <code>PARANOID</code> which may be used to match any host which provides an IP address that may be forged. In other words, <code>paranoid</code> may be used to define an action to be taken whenever a connection is made from an IP address that differs from its hostname. The following example may shed some more light on this discussion:</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class=paragraph><p>In that example all connection requests to <code>sendmail</code> which have an IP address that varies from its hostname will be denied.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Using the <code>PARANOID</code> may severely cripple servers if the client or server has a broken DNS setup. Administrator discretion is advised.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To learn more about wildcards and their associated functionality, see the <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> manual page.</p></div><div class=paragraph><p>Before any of the specific configuration lines above will work, the first configuration line should be commented out in <span class=filename>hosts.allow</span>. This was noted at the beginning of this section.</p></div></div></div></div><div class=sect2><h3 id=kerberosIV>35.7. KerberosIV<a class=anchor href=#kerberosIV></a></h3><div class=paragraph><p>Kerberos is a network add-on system/protocol that allows users to authenticate themselves through the services of a secure server. Services such as remote login, remote copy, secure inter-system file copying and other high-risk tasks are made considerably safer and more controllable.</p></div><div class=paragraph><p>The following instructions can be used as a guide on how to set up Kerberos as distributed for FreeBSD. However, you should refer to the relevant manual pages for a complete description.</p></div><div class=sect3><h4 id=_installing_kerberosiv>35.7.1. Installing KerberosIV<a class=anchor href=#_installing_kerberosiv></a></h4><div class=paragraph><p>Kerberos is an optional component of FreeBSD. The easiest way to install this software is by selecting the <code>krb4</code> or <code>krb5</code> distribution in sysinstall during the initial installation of FreeBSD. This will install the "eBones" (KerberosIV) or "Heimdal" (Kerberos5) implementation of Kerberos. These implementations are included because they are developed outside the USA/Canada and were thus available to system owners outside those countries during the era of restrictive export controls on cryptographic code from the USA.</p></div><div class=paragraph><p>Alternatively, the MIT implementation of Kerberos is available from the Ports Collection as <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>.</p></div></div><div class=sect3><h4 id=_creating_the_initial_database>35.7.2. Creating the Initial Database<a class=anchor href=#_creating_the_initial_database></a></h4><div class=paragraph><p>This is done on the Kerberos server only. First make sure that you do not have any old Kerberos databases around. You should change to the directory <span class=filename>/etc/kerberosIV</span> and check that only the following files are present:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>d /etc/kerberosIV
<span class=c># ls</span>
README		krb.conf        krb.realms</code></pre></div></div><div class=paragraph><p>If any additional files (such as <span class=filename>principal.*</span> or <span class=filename>master_key</span>) exist, then use the <code>kdb_destroy</code> command to destroy the old Kerberos database, or if Kerberos is not running, simply delete the extra files.</p></div><div class=paragraph><p>You should now edit the <span class=filename>krb.conf</span> and <span class=filename>krb.realms</span> files to define your Kerberos realm. In this case the realm will be <code>EXAMPLE.COM</code> and the server is <code>grunt.example.com</code>. We edit or create the <span class=filename>krb.conf</span> file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.conf</span>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</code></pre></div></div><div class=paragraph><p>In this case, the other realms do not need to be there. They are here as an example of how a machine may be made aware of multiple realms. You may wish to not include them for simplicity.</p></div><div class=paragraph><p>The first line names the realm in which this system works. The other lines contain realm/host entries. The first item on a line is a realm, and the second is a host in that realm that is acting as a "key distribution center". The words <code>admin server</code> following a host’s name means that host also provides an administrative database server. For further explanation of these terms, please consult the Kerberos manual pages.</p></div><div class=paragraph><p>Now we have to add <code>grunt.example.com</code> to the <code>EXAMPLE.COM</code> realm and also add an entry to put all hosts in the <code>.example.com</code> domain in the <code>EXAMPLE.COM</code> realm. The <span class=filename>krb.realms</span> file would be updated as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.realms</span>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</code></pre></div></div><div class=paragraph><p>Again, the other realms do not need to be there. They are here as an example of how a machine may be made aware of multiple realms. You may wish to remove them to simplify things.</p></div><div class=paragraph><p>The first line puts the <em>specific</em> system into the named realm. The rest of the lines show how to default systems of a particular subdomain to a named realm.</p></div><div class=paragraph><p>Now we are ready to create the database. This only needs to run on the Kerberos server (or Key Distribution Center). Issue the <code>kdb_init</code> command to do this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_init</span>
Realm name <span class=o>[</span>default  ATHENA.MIT.EDU <span class=o>]</span>: EXAMPLE.COM
You will be prompted <span class=k>for </span>the database Master Password.
It is important that you NOT FORGET this password.

Enter Kerberos master key:</code></pre></div></div><div class=paragraph><p>Now we have to save the key so that servers on the local machine can pick it up. Use the <code>kstash</code> command to do this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!</code></pre></div></div><div class=paragraph><p>This saves the encrypted master password in <span class=filename>/etc/kerberosIV/master_key</span>.</p></div></div><div class=sect3><h4 id=_making_it_all_run>35.7.3. Making It All Run<a class=anchor href=#_making_it_all_run></a></h4><div class=paragraph><p>Two principals need to be added to the database for <em>each</em> system that will be secured with Kerberos. Their names are <code>kpasswd</code> and <code>rcmd</code>. These two principals are made for each system, with the instance being the name of the individual system.</p></div><div class=paragraph><p>These daemons, kpasswd and rcmd allow other systems to change Kerberos passwords and run commands like <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>.</p></div><div class=paragraph><p>Now let us add these entries:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: passwd
Instance: grunt

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: passwd, Instance: grunt, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> enter RANDOM here
Verifying password

New Password: &lt;<span class=nt>----</span> enter RANDOM here

Random password <span class=o>[</span>y] ? y

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name: rcmd
Instance: grunt

&lt;Not found&gt;, Create [y] ?

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
New Password:		&lt;---- enter RANDOM here
Verifying password

New Password:           &lt;---- enter RANDOM here

Random password [y] ?

Principal&#39;</span>s new key version <span class=o>=</span> 1
Expiration <span class=nb>date</span> <span class=o>(</span>enter yyyy-mm-dd<span class=o>)</span> <span class=o>[</span> 2000-01-01 <span class=o>]</span> ?
Max ticket lifetime <span class=o>(</span><span class=k>*</span>5 minutes<span class=o>)</span> <span class=o>[</span> 255 <span class=o>]</span> ?
Attributes <span class=o>[</span> 0 <span class=o>]</span> ?
Edit O.K.
Principal name:         &lt;<span class=nt>----</span> null entry here will cause an <span class=nb>exit</span></code></pre></div></div></div><div class=sect3><h4 id=_creating_the_server_file>35.7.4. Creating the Server File<a class=anchor href=#_creating_the_server_file></a></h4><div class=paragraph><p>We now have to extract all the instances which define the services on each machine. For this we use the <code>ext_srvtab</code> command. This will create a file which must be copied or moved <em>by secure means</em> to each Kerberos client’s <span class=filename>/etc</span> directory. This file must be present on each server and client, and is crucial to the operation of Kerberos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ext_srvtab grunt</span>
Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating <span class=s1>&#39;grunt-new-srvtab&#39;</span>....</code></pre></div></div><div class=paragraph><p>Now, this command only generates a temporary file which must be renamed to <span class=filename>srvtab</span> so that all the servers can pick it up. Use the <a href="https://man.freebsd.org/cgi/man.cgi?query=mv&amp;sektion=1&amp;format=html">mv(1)</a> command to move it into place on the original system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grunt-new-srvtab srvtab</span></code></pre></div></div><div class=paragraph><p>If the file is for a client system, and the network is not deemed safe, then copy the <span class=filename>client-new-srvtab</span> to removable media and transport it by secure physical means. Be sure to rename it to <span class=filename>srvtab</span> in the client’s <span class=filename>/etc</span> directory, and make sure it is mode 600:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grumble-new-srvtab srvtab</span>
<span class=c># chmod 600 srvtab</span></code></pre></div></div></div><div class=sect3><h4 id=_populating_the_database>35.7.5. Populating the Database<a class=anchor href=#_populating_the_database></a></h4><div class=paragraph><p>We now have to add some user entries into the database. First let us create an entry for the user <code>jane</code>. Use the <code>kdb_edit</code> command to do this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance:

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: , kdc_key_ver: 1
New Password:                &lt;<span class=nt>----</span> enter a secure password here
Verifying password

New Password:                &lt;<span class=nt>----</span> re-enter the password here
Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:		   &lt;---- null entry here will cause an exit</span></code></pre></div></div></div><div class=sect3><h4 id=_testing_it_all_out>35.7.6. Testing It All Out<a class=anchor href=#_testing_it_all_out></a></h4><div class=paragraph><p>First we have to start the Kerberos daemons. Note that if you have correctly edited your <span class=filename>/etc/rc.conf</span> then this will happen automatically when you reboot. This is only necessary on the Kerberos server. Kerberos clients will automatically get what they need from the <span class=filename>/etc/kerberosIV</span> directory.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kerberos &amp;</span>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
<span class=c># kadmind -n &amp;</span>
KADM Server KADM0.0A initializing
Please <span class=k>do </span>not use <span class=s1>&#39;kill -9&#39;</span> to <span class=nb>kill </span>this job, use a
regular <span class=nb>kill </span>instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</code></pre></div></div><div class=paragraph><p>Now we can try using the <code>kinit</code> command to get a ticket for the ID <code>jane</code> that we created above:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Try listing the tokens using <code>klist</code> to see if we really have them:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Now try changing the password using <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> to check if the kpasswd daemon can get authorization to the Kerberos database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
realm EXAMPLE.COM
Old password <span class=k>for </span>jane:
New Password <span class=k>for </span>jane:
Verifying password
New Password <span class=k>for </span>jane:
Password changed.</code></pre></div></div></div><div class=sect3><h4 id=_adding_su_privileges>35.7.7. Adding <code>su</code> Privileges<a class=anchor href=#_adding_su_privileges></a></h4><div class=paragraph><p>Kerberos allows us to give <em>each</em> user who needs <code>root</code> privileges their own <em>separate</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> password. We could now add an ID which is authorized to <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> to <code>root</code>. This is controlled by having an instance of <code>root</code> associated with a principal. Using <code>kdb_edit</code> we can create the entry <code>jane.root</code> in the Kerberos database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance: root

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> enter a SECURE password here
Verifying password

New Password:    	 	 &lt;<span class=nt>----</span> re-enter the password here

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ? 12 &lt;--- Keep this short!
Attributes [ 0 ] ?
Edit O.K.
Principal name:		         &lt;---- null entry here will cause an exit</span></code></pre></div></div><div class=paragraph><p>Now try getting tokens for it to make sure it works:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kinit jane.root</span>
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane.root&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Now we need to add the user to <code>root</code>'s <span class=filename>.klogin</span> file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Now try doing the <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:</code></pre></div></div><div class=paragraph><p>and take a look at what tokens we have:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># klist</span>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div></div><div class=sect3><h4 id=_using_other_commands>35.7.8. Using Other Commands<a class=anchor href=#_using_other_commands></a></h4><div class=paragraph><p>In an earlier example, we created a principal called <code>jane</code> with an instance <code>root</code>. This was based on a user with the same name as the principal, and this is a Kerberos default; that a <code>&lt;principal>.&lt;instance></code> of the form <code>&lt;username>. root</code> will allow that <code>&lt;username></code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> to <code>root</code> if the necessary entries are in the <span class=filename>.klogin</span> file in <code>root</code>'s home directory:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Likewise, if a user has in their own home directory lines of the form:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat</span> ~/.klogin
jane@EXAMPLE.COM
jack@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>This allows anyone in the <code>EXAMPLE.COM</code> realm who has authenticated themselves as <code>jane</code> or <code>jack</code> (via <code>kinit</code>, see above) to access to <code>jane</code>'s account or files on this system (<code>grunt</code>) via <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>.</p></div><div class=paragraph><p>For example, <code>jane</code> now logs into another system using Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
% rlogin grunt
Last login: Mon May  1 21:14:47 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div><div class=paragraph><p>Or <code>jack</code> logs into <code>jane</code>'s account on the same machine (<code>jane</code> having set up the <span class=filename>.klogin</span> file as above, and the person in charge of Kerberos having set up principal <em>jack</em> with a null instance):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
% rlogin grunt <span class=nt>-l</span> jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
Last login: Mon May  1 21:16:55 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div></div></div><div class=sect2><h3 id=kerberos5>35.8. Kerberos5<a class=anchor href=#kerberos5></a></h3><div class=paragraph><p>Every FreeBSD release beyond FreeBSD-5.1 includes support only for Kerberos5. Hence Kerberos5 is the only version included, and its configuration is similar in many aspects to that of KerberosIV. The following information only applies to Kerberos5 in post FreeBSD-5.0 releases. Users who wish to use the KerberosIV package may install the <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb4/>security/krb4</a> port.</p></div><div class=paragraph><p>Kerberos is a network add-on system/protocol that allows users to authenticate themselves through the services of a secure server. Services such as remote login, remote copy, secure inter-system file copying and other high-risk tasks are made considerably safer and more controllable.</p></div><div class=paragraph><p>Kerberos can be described as an identity-verifying proxy system. It can also be described as a trusted third-party authentication system. Kerberos provides only one function - the secure authentication of users on the network. It does not provide authorization functions (what users are allowed to do) or auditing functions (what those users did). After a client and server have used Kerberos to prove their identity, they can also encrypt all of their communications to assure privacy and data integrity as they go about their business.</p></div><div class=paragraph><p>Therefore it is highly recommended that Kerberos be used with other security methods which provide authorization and audit services.</p></div><div class=paragraph><p>The following instructions can be used as a guide on how to set up Kerberos as distributed for FreeBSD. However, you should refer to the relevant manual pages for a complete description.</p></div><div class=paragraph><p>For purposes of demonstrating a Kerberos installation, the various name spaces will be handled as follows:</p></div><div class=ulist><ul><li><p>The DNS domain ("zone") will be example.org.</p></li><li><p>The Kerberos realm will be EXAMPLE.ORG.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Please use real domain names when setting up Kerberos even if you intend to run it internally. This avoids DNS problems and assures inter-operation with other Kerberos realms.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_history>35.8.1. History<a class=anchor href=#_history></a></h4><div class=paragraph><p>Kerberos was created by MIT as a solution to network security problems. The Kerberos protocol uses strong cryptography so that a client can prove its identity to a server (and vice versa) across an insecure network connection.</p></div><div class=paragraph><p>Kerberos is both the name of a network authentication protocol and an adjective to describe programs that implement the program (Kerberos telnet, for example). The current version of the protocol is version 5, described in RFC 1510.</p></div><div class=paragraph><p>Several free implementations of this protocol are available, covering a wide range of operating systems. The Massachusetts Institute of Technology (MIT), where Kerberos was originally developed, continues to develop their Kerberos package. It is commonly used in the US as a cryptography product, as such it has historically been affected by US export regulations. The MITKerberos is available as a port (<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>). Heimdal Kerberos is another version 5 implementation, and was explicitly developed outside of the US to avoid export regulations (and is thus often included in non-commercial UNIX® variants). The Heimdal Kerberos distribution is available as a port (<a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a>), and a minimal installation of it is included in the base FreeBSD install.</p></div><div class=paragraph><p>In order to reach the widest audience, these instructions assume the use of the Heimdal distribution included in FreeBSD.</p></div></div><div class=sect3><h4 id=_setting_up_a_heimdal_kdc>35.8.2. Setting up a Heimdal KDC<a class=anchor href=#_setting_up_a_heimdal_kdc></a></h4><div class=paragraph><p>The Key Distribution Center (KDC) is the centralized authentication service that Kerberos provides - it is the computer that issues Kerberos tickets. The KDC is considered "trusted" by all other computers in the Kerberos realm, and thus has heightened security concerns.</p></div><div class=paragraph><p>Note that while running the Kerberos server requires very few computing resources, a dedicated machine acting only as a KDC is recommended for security reasons.</p></div><div class=paragraph><p>To begin setting up a KDC, ensure that your <span class=filename>/etc/rc.conf</span> file contains the correct settings to act as a KDC (you may need to adjust paths to reflect your own system):</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Next we will set up your Kerberos config file, <span class=filename>/etc/krb5.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Note that this <span class=filename>/etc/krb5.conf</span> file implies that your KDC will have the fully-qualified hostname of <code>kerberos.example.org</code>. You will need to add a CNAME (alias) entry to your zone file to accomplish this if your KDC has a different hostname.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For large networks with a properly configured BINDDNS server, the above example could be trimmed to:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>With the following lines being appended to the <code>example.org</code> zonefile:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For clients to be able to find the Kerberos services, you <em>must</em> have either a fully configured <span class=filename>/etc/krb5.conf</span> or a minimally configured <span class=filename>/etc/krb5.conf</span><em>and</em> a properly configured DNS server.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next we will create the Kerberos database. This database contains the keys of all principals encrypted with a master password. You are not required to remember this password, it will be stored in a file (<span class=filename>/var/heimdal/m-key</span>). To create the master key, run <code>kstash</code> and enter a password.</p></div><div class=paragraph><p>Once the master key has been created, you can initialize the database using the <code>kadmin</code> program with the <code>-l</code> option (standing for "local"). This option instructs <code>kadmin</code> to modify the database files directly rather than going through the <code>kadmind</code> network service. This handles the chicken-and-egg problem of trying to connect to the database before it is created. Once you have the <code>kadmin</code> prompt, use the <code>init</code> command to create your realms initial database.</p></div><div class=paragraph><p>Lastly, while still in <code>kadmin</code>, create your first principal using the <code>add</code> command. Stick to the defaults options for the principal for now, you can always change them later with the <code>modify</code> command. Note that you can use the <code>?</code> command at any prompt to see the available options.</p></div><div class=paragraph><p>A sample database creation session is shown below:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

<span class=c># kadmin -l</span>
kadmin&gt; init EXAMPLE.ORG
Realm max ticket life <span class=o>[</span>unlimited]:
kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Now it is time to start up the KDC services. Run <code>/etc/rc.d/kerberos start</code> and <code>/etc/rc.d/kadmind start</code> to bring up the services. Note that you will not have any kerberized daemons running at this point but you should be able to confirm the that the KDC is functioning by obtaining and listing a ticket for the principal (user) that you just created from the command-line of the KDC itself:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit tillman
tillman@EXAMPLE.ORG<span class=s1>&#39;s Password:

% klist
Credentials cache: FILE:/tmp/krb5cc_500
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</span></code></pre></div></div><div class=paragraph><p>The ticket can then be revoked when you have finished:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% k5destroy</code></pre></div></div></div><div class=sect3><h4 id=_kerberos_enabling_a_server_with_heimdal_services>35.8.3. Kerberos enabling a server with Heimdal services<a class=anchor href=#_kerberos_enabling_a_server_with_heimdal_services></a></h4><div class=paragraph><p>First, we need a copy of the Kerberos configuration file, <span class=filename>/etc/krb5.conf</span>. To do so, simply copy it over to the client computer from the KDC in a secure fashion (using network utilities, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, or physically via a floppy disk).</p></div><div class=paragraph><p>Next you need a <span class=filename>/etc/krb5.keytab</span> file. This is the major difference between a server providing Kerberos enabled daemons and a workstation - the server must have a <span class=filename>keytab</span> file. This file contains the server’s host key, which allows it and the KDC to verify each others identity. It must be transmitted to the server in a secure fashion, as the security of the server can be broken if the key is made public. This explicitly means that transferring it via a clear text channel, such as FTP, is a very bad idea.</p></div><div class=paragraph><p>Typically, you transfer to the <span class=filename>keytab</span> to the server using the <code>kadmin</code> program. This is handy because you also need to create the host principal (the KDC end of the <span class=filename>krb5.keytab</span>) using <code>kadmin</code>.</p></div><div class=paragraph><p>Note that you must have already obtained a ticket and that this ticket must be allowed to use the <code>kadmin</code> interface in the <span class=filename>kadmind.acl</span>. See the section titled "Remote administration" in the Heimdal info pages (<code>info heimdal</code>) for details on designing access control lists. If you do not want to enable remote <code>kadmin</code> access, you can simply securely connect to the KDC (via local console, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> or Kerberos <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>) and perform administration locally using <code>kadmin -l</code>.</p></div><div class=paragraph><p>After installing the <span class=filename>/etc/krb5.conf</span> file, you can use <code>kadmin</code> from the Kerberos server. The <code>add --random-key</code> command will let you add the server’s host principal, and the <code>ext</code> command will allow you to extract the server’s host principal to its own keytab. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.example.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Note that the <code>ext</code> command (short for "extract") stores the extracted key in <span class=filename>/etc/krb5.keytab</span> by default.</p></div><div class=paragraph><p>If you do not have <code>kadmind</code> running on the KDC (possibly for security reasons) and thus do not have access to <code>kadmin</code> remotely, you can add the host principal (<code>host/myserver.EXAMPLE.ORG</code>) directly on the KDC and then extract it to a temporary file (to avoid over-writing the <span class=filename>/etc/krb5.keytab</span> on the KDC) using something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext <span class=nt>--keytab</span><span class=o>=</span>/tmp/example.keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>You can then securely copy the keytab to the server computer (using <code>scp</code> or a floppy, for example). Be sure to specify a non-default keytab name to avoid over-writing the keytab on the KDC.</p></div><div class=paragraph><p>At this point your server can communicate with the KDC (due to its <span class=filename>krb5.conf</span> file) and it can prove its own identity (due to the <span class=filename>krb5.keytab</span> file). It is now ready for you to enable some Kerberos services. For this example we will enable the <code>telnet</code> service by putting a line like this into your <span class=filename>/etc/inetd.conf</span> and then restarting the <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> service with <code>/etc/rc.d/inetd restart</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</pre></div></div><div class=paragraph><p>The critical bit is that the <code>-a</code> (for authentication) type is set to user. Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> manual page for more details.</p></div></div><div class=sect3><h4 id=_kerberos_enabling_a_client_with_heimdal>35.8.4. Kerberos enabling a client with Heimdal<a class=anchor href=#_kerberos_enabling_a_client_with_heimdal></a></h4><div class=paragraph><p>Setting up a client computer is almost trivially easy. As far as Kerberos configuration goes, you only need the Kerberos configuration file, located at <span class=filename>/etc/krb5.conf</span>. Simply securely copy it over to the client computer from the KDC.</p></div><div class=paragraph><p>Test your client computer by attempting to use <code>kinit</code>, <code>klist</code>, and <code>kdestroy</code> from the client to obtain, show, and then delete a ticket for the principal you created above. You should also be able to use Kerberos applications to connect to Kerberos enabled servers, though if that does not work and obtaining a ticket does the problem is likely with the server and not with the client or the KDC.</p></div><div class=paragraph><p>When testing an application like <code>telnet</code>, try using a packet sniffer (such as <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>) to confirm that your password is not sent in the clear. Try using <code>telnet</code> with the <code>-x</code> option, which encrypts the entire data stream (similar to <code>ssh</code>).</p></div><div class=paragraph><p>Various non-core Kerberos client applications are also installed by default. This is where the "minimal" nature of the base Heimdal installation is felt: <code>telnet</code> is the only Kerberos enabled service.</p></div><div class=paragraph><p>The Heimdal port adds some of the missing client applications: Kerberos enabled versions of <code>ftp</code>, <code>rsh</code>, <code>rcp</code>, <code>rlogin</code>, and a few other less common programs. The MIT port also contains a full suite of Kerberos client applications.</p></div></div><div class=sect3><h4 id=_user_configuration_files_k5login_and_k5users>35.8.5. User configuration files: <span class=filename>.k5login</span> and <span class=filename>.k5users</span><a class=anchor href=#_user_configuration_files_k5login_and_k5users></a></h4><div class=paragraph><p>Users within a realm typically have their Kerberos principal (such as <code>tillman@EXAMPLE.ORG</code>) mapped to a local user account (such as a local account named <code>tillman</code>). Client applications such as <code>telnet</code> usually do not require a user name or a principal.</p></div><div class=paragraph><p>Occasionally, however, you want to grant access to a local user account to someone who does not have a matching Kerberos principal. For example, <code>tillman@EXAMPLE.ORG</code> may need access to the local user account <code>webdevelopers</code>. Other principals may also need access to that local account.</p></div><div class=paragraph><p>The <span class=filename>.k5login</span> and <span class=filename>.k5users</span> files, placed in a users home directory, can be used similar to a powerful combination of <span class=filename>.hosts</span> and <span class=filename>.rhosts</span>, solving this problem. For example, if a <span class=filename>.k5login</span> with the following contents:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>tillman@example.org
jdoe@example.org</code></pre></div></div><div class=paragraph><p>Were to be placed into the home directory of the local user <code>webdevelopers</code> then both principals listed would have access to that account without requiring a shared password.</p></div><div class=paragraph><p>Reading the manual pages for these commands is recommended. Note that the <code>ksu</code> manual page covers <span class=filename>.k5users</span>.</p></div></div><div class=sect3><h4 id=_kerberos_tips_tricks_and_troubleshooting>35.8.6. Kerberos Tips, Tricks, and Troubleshooting<a class=anchor href=#_kerberos_tips_tricks_and_troubleshooting></a></h4><div class=ulist><ul><li><p>When using either the Heimdal or MITKerberos ports ensure that your <code>PATH</code> environment variable lists the Kerberos versions of the client applications before the system versions.</p></li><li><p>Do all the computers in your realm have synchronized time settings? If not, authentication may fail. <a href=./#network-ntp>Συγχρονισμός Ρολογιού Συστήματος με NTP</a> describes how to synchronize clocks using NTP.</p></li><li><p>MIT and Heimdal inter-operate nicely. Except for <code>kadmin</code>, the protocol for which is not standardized.</p></li><li><p>If you change your hostname, you also need to change your <code>host/</code> principal and update your keytab. This also applies to special keytab entries like the <code>www/</code> principal used for Apache’s <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a>.</p></li><li><p>All hosts in your realm must be resolvable (both forwards and reverse) in DNS (or <span class=filename>/etc/hosts</span> as a minimum). CNAMEs will work, but the A and PTR records must be correct and in place. The error message is not very intuitive: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Some operating systems that may being acting as clients to your KDC do not set the permissions for <code>ksu</code> to be setuid <code>root</code>. This means that <code>ksu</code> does not work, which is a good security idea but annoying. This is not a KDC error.</p></li><li><p>With MITKerberos, if you want to allow a principal to have a ticket life longer than the default ten hours, you must use <code>modify_principal</code> in <code>kadmin</code> to change the maxlife of both the principal in question and the <code>krbtgt</code> principal. Then the principal can use the <code>-l</code> option with <code>kinit</code> to request a ticket with a longer lifetime.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you run a packet sniffer on your KDC to add in troubleshooting and then run <code>kinit</code> from a workstation, you will notice that your TGT is sent immediately upon running <code>kinit</code> - even before you type your password! The explanation is that the Kerberos server freely transmits a TGT (Ticket Granting Ticket) to any unauthorized request; however, every TGT is encrypted in a key derived from the user’s password. Therefore, when a user types their password it is not being sent to the KDC, it is being used to decrypt the TGT that <code>kinit</code> already obtained. If the decryption process results in a valid ticket with a valid time stamp, the user has valid Kerberos credentials. These credentials include a session key for establishing secure communications with the Kerberos server in the future, as well as the actual ticket-granting ticket, which is actually encrypted with the Kerberos server’s own key. This second layer of encryption is unknown to the user, but it is what allows the Kerberos server to verify the authenticity of each TGT.</p></div></td></tr></tbody></table></div><div class=ulist><ul><li><p>If you want to use long ticket lifetimes (a week, for example) and you are using OpenSSH to connect to the machine where your ticket is stored, make sure that Kerberos <code>TicketCleanup</code> is set to <code>no</code> in your <span class=filename>sshd_config</span> or else your tickets will be deleted when you log out.</p></li><li><p>Remember that host principals can have a longer ticket lifetime as well. If your user principal has a lifetime of a week but the host you are connecting to has a lifetime of nine hours, you will have an expired host principal in your cache and the ticket cache will not work as expected.</p></li><li><p>When setting up a <span class=filename>krb5.dict</span> file to prevent specific bad passwords from being used (the manual page for <code>kadmind</code> covers this briefly), remember that it only applies to principals that have a password policy assigned to them. The <span class=filename>krb5.dict</span> files format is simple: one string per line. Creating a symbolic link to <span class=filename>/usr/shared/dict/words</span> might be useful.</p></li></ul></div></div><div class=sect3><h4 id=_differences_with_the_mit_port>35.8.7. Differences with the MIT port<a class=anchor href=#_differences_with_the_mit_port></a></h4><div class=paragraph><p>The major difference between the MIT and Heimdal installs relates to the <code>kadmin</code> program which has a different (but equivalent) set of commands and uses a different protocol. This has a large implications if your KDC is MIT as you will not be able to use the Heimdal <code>kadmin</code> program to administer your KDC remotely (or vice versa, for that matter).</p></div><div class=paragraph><p>The client applications may also take slightly different command line options to accomplish the same tasks. Following the instructions on the MITKerberos web site (<a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a>) is recommended. Be careful of path issues: the MIT port installs into <span class=filename>/usr/local/</span> by default, and the "normal" system applications may be run instead of MIT if your <code>PATH</code> environment variable lists the system directories first.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>With the MIT<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> port that is provided by FreeBSD, be sure to read the <span class=filename>/usr/local/shared/doc/krb5/README.FreeBSD</span> file installed by the port if you want to understand why logins via <code>telnetd</code> and <code>klogind</code> behave somewhat oddly. Most importantly, correcting the "incorrect permissions on cache file" behavior requires that the <code>login.krb5</code> binary be used for authentication so that it can properly change ownership for the forwarded credentials.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The <span class=filename>rc.conf</span> must also be modified to contain the following configuration:</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server=&#34;/usr/local/sbin/krb5kdc&#34;
kadmind5_server=&#34;/usr/local/sbin/kadmind&#34;
kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>This is done because the applications for MIT kerberos installs binaries in the <span class=filename>/usr/local</span> hierarchy.</p></div></div><div class=sect3><h4 id=_mitigating_limitations_found_in_kerberos>35.8.8. Mitigating limitations found in Kerberos<a class=anchor href=#_mitigating_limitations_found_in_kerberos></a></h4><div class=sect4><h5 id=_kerberos_is_an_all_or_nothing_approach>35.8.8.1. Kerberos is an all-or-nothing approach<a class=anchor href=#_kerberos_is_an_all_or_nothing_approach></a></h5><div class=paragraph><p>Every service enabled on the network must be modified to work with Kerberos (or be otherwise secured against network attacks) or else the users credentials could be stolen and re-used. An example of this would be Kerberos enabling all remote shells (via <code>rsh</code> and <code>telnet</code>, for example) but not converting the POP3 mail server which sends passwords in plain text.</p></div></div><div class=sect4><h5 id=_kerberos_is_intended_for_single_user_workstations>35.8.8.2. Kerberos is intended for single-user workstations<a class=anchor href=#_kerberos_is_intended_for_single_user_workstations></a></h5><div class=paragraph><p>In a multi-user environment, Kerberos is less secure. This is because it stores the tickets in the <span class=filename>/tmp</span> directory, which is readable by all users. If a user is sharing a computer with several other people simultaneously (i.e. multi-user), it is possible that the user’s tickets can be stolen (copied) by another user.</p></div><div class=paragraph><p>This can be overcome with the <code>-c</code> filename command-line option or (preferably) the <code>KRB5CCNAME</code> environment variable, but this is rarely done. In principal, storing the ticket in the users home directory and using simple file permissions can mitigate this problem.</p></div></div><div class=sect4><h5 id=_the_kdc_is_a_single_point_of_failure>35.8.8.3. The KDC is a single point of failure<a class=anchor href=#_the_kdc_is_a_single_point_of_failure></a></h5><div class=paragraph><p>By design, the KDC must be as secure as the master password database is contained on it. The KDC should have absolutely no other services running on it and should be physically secured. The danger is high because Kerberos stores all passwords encrypted with the same key (the "master" key), which in turn is stored as a file on the KDC.</p></div><div class=paragraph><p>As a side note, a compromised master key is not quite as bad as one might normally fear. The master key is only used to encrypt the Kerberos database and as a seed for the random number generator. As long as access to your KDC is secure, an attacker cannot do much with the master key.</p></div><div class=paragraph><p>Additionally, if the KDC is unavailable (perhaps due to a denial of service attack or network problems) the network services are unusable as authentication can not be performed, a recipe for a denial-of-service attack. This can alleviated with multiple KDCs (a single master and one or more slaves) and with careful implementation of secondary or fall-back authentication (PAM is excellent for this).</p></div></div><div class=sect4><h5 id=_kerberos_shortcomings>35.8.8.4. Kerberos Shortcomings<a class=anchor href=#_kerberos_shortcomings></a></h5><div class=paragraph><p>Kerberos allows users, hosts and services to authenticate between themselves. It does not have a mechanism to authenticate the KDC to the users, hosts or services. This means that a trojanned <code>kinit</code> (for example) could record all user names and passwords. Something like <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> or other file system integrity checking tools can alleviate this.</p></div></div></div><div class=sect3><h4 id=_resources_and_further_information>35.8.9. Resources and further information<a class=anchor href=#_resources_and_further_information></a></h4><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>The Kerberos FAQ</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Designing an Authentication System: a Dialog in Four Scenes</a></p></li><li><p><a href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510, The Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>MIT Kerberos home page</a></p></li><li><p><a href=http://www.pdc.kth.se/heimdal/>Heimdal Kerberos home page</a></p></li></ul></div></div></div><div class=sect2><h3 id=openssl>35.9. OpenSSL<a class=anchor href=#openssl></a></h3><div class=paragraph><p>One feature that many users overlook is the OpenSSL toolkit included in FreeBSD. OpenSSL provides an encryption transport layer on top of the normal communications layer; thus allowing it to be intertwined with many network applications and services.</p></div><div class=paragraph><p>Some uses of OpenSSL may include encrypted authentication of mail clients, web based transactions such as credit card payments and more. Many ports such as <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-ssl/>www/apache13-ssl</a>, and <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a> will offer compilation support for building with OpenSSL.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In most cases the Ports Collection will attempt to build the <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> port unless the <code>WITH_OPENSSL_BASE</code> make variable is explicitly set to "yes".</p></div></td></tr></tbody></table></div><div class=paragraph><p>The version of OpenSSL included in FreeBSD supports Secure Sockets Layer v2/v3 (SSLv2/SSLv3), Transport Layer Security v1 (TLSv1) network security protocols and can be used as a general cryptographic library.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While OpenSSL supports the IDEA algorithm, it is disabled by default due to United States patents. To use it, the license should be reviewed and, if the restrictions are acceptable, the <code>MAKE_IDEA</code> variable must be set in <span class=filename>make.conf</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>One of the most common uses of OpenSSL is to provide certificates for use with software applications. These certificates ensure that the credentials of the company or individual are valid and not fraudulent. If the certificate in question has not been verified by one of the several "Certificate Authorities", or CAs, a warning is usually produced. A Certificate Authority is a company, such as <a href=http://www.verisign.com>VeriSign</a>, which will sign certificates in order to validate credentials of individuals or companies. This process has a cost associated with it and is definitely not a requirement for using certificates; however, it can put some of the more paranoid users at ease.</p></div><div class=sect3><h4 id=_generating_certificates>35.9.1. Generating Certificates<a class=anchor href=#_generating_certificates></a></h4><div class=paragraph><p>To generate a certificate, the following command is available:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.pem</span>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to <span class=s1>&#39;cert.pem&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:SOME PASSWORD
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>Notice the response directly after the "Common Name" prompt shows a domain name. This prompt requires a server name to be entered for verification purposes; placing anything but a domain name would yield a useless certificate. Other options, for instance expire time, alternate encryption algorithms, etc. are available. A complete list may be obtained by viewing the <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a> manual page.</p></div><div class=paragraph><p>Two files should now exist in the directory in which the aforementioned command was issued. The certificate request, <span class=filename>req.pem</span>, may be sent to a certificate authority who will validate the credentials that you entered, sign the request and return the certificate to you. The second file created will be named <span class=filename>cert.pem</span> and is the private key for the certificate and should be protected at all costs; if this falls in the hands of others it can be used to impersonate you (or your server).</p></div><div class=paragraph><p>In cases where a signature from a CA is not required, a self signed certificate can be created. First, generate the RSA key:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl dsaparam -rand -genkey -out myRSA.key 1024</span></code></pre></div></div><div class=paragraph><p>Next, generate the CA key:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl gendsa -des3 -out myca.key myRSA.key</span></code></pre></div></div><div class=paragraph><p>Use this key to create the certificate:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key myca.key -out new.crt</span></code></pre></div></div><div class=paragraph><p>Two new files should appear in the directory: a certificate authority signature file, <span class=filename>myca.key</span> and the certificate itself, <span class=filename>new.crt</span>. These should be placed in a directory, preferably under <span class=filename>/etc</span>, which is readable only by <code>root</code>. Permissions of 0700 should be fine for this and they can be set with the <code>chmod</code> utility.</p></div></div><div class=sect3><h4 id=_using_certificates_an_example>35.9.2. Using Certificates, an Example<a class=anchor href=#_using_certificates_an_example></a></h4><div class=paragraph><p>So what can these files do? A good use would be to encrypt connections to the SendmailMTA. This would dissolve the use of clear text authentication for users who send mail via the local MTA.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This is not the best use in the world as some MUAs will present the user with an error if they have not installed the certificate locally. Refer to the documentation included with the software for more information on certificate installation.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The following lines should be placed inside the local <span class=filename>.mc</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>dnl SSL Options
define(`confCACERT_PATH&#39;,`/etc/certs&#39;)dnl
define(`confCACERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_CERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_KEY&#39;,`/etc/certs/myca.key&#39;)dnl
define(`confTLS_SRV_OPTIONS&#39;, `V&#39;)dnl</pre></div></div><div class=paragraph><p>Where <span class=filename>/etc/certs/</span> is the directory to be used for storing the certificate and key files locally. The last few requirements are a rebuild of the local <span class=filename>.cf</span> file. This is easily achieved by typing <code>make</code><span class=parameter>install</span> within the <span class=filename>/etc/mail</span> directory. Follow that up with <code>make</code><span class=parameter>restart</span> which should start the Sendmail daemon.</p></div><div class=paragraph><p>If all went well there will be no error messages in the <span class=filename>/var/log/maillog</span> file and Sendmail will show up in the process list.</p></div><div class=paragraph><p>For a simple test, simply connect to the mail server using the <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> utility:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to example.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.12.10/8.12.10<span class=p>;</span> Tue, 31 Aug 2004 03:41:22 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>If the "STARTTLS" line appears in the output then everything is working correctly.</p></div></div></div><div class=sect2><h3 id=ipsec>35.10. VPN over IPsec<a class=anchor href=#ipsec></a></h3><div class=paragraph><p>Creating a VPN between two networks, separated by the Internet, using FreeBSD gateways.</p></div><div class=sect3><h4 id=_understanding_ipsec>35.10.1. Understanding IPsec<a class=anchor href=#_understanding_ipsec></a></h4><div class=paragraph><p>This section will guide you through the process of setting up IPsec, and to use it in an environment which consists of FreeBSD and Microsoft® Windows® 2000/XP machines, to make them communicate securely. In order to set up IPsec, it is necessary that you are familiar with the concepts of building a custom kernel (see <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></div><div class=paragraph><p><em>IPsec</em> is a protocol which sits on top of the Internet Protocol (IP) layer. It allows two or more hosts to communicate in a secure manner (hence the name). The FreeBSD IPsec "network stack" is based on the <a href=http://www.kame.net/>KAME</a> implementation, which has support for both protocol families, IPv4 and IPv6.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD contains a "hardware accelerated" IPsec stack, known as "Fast IPsec", that was obtained from OpenBSD. It employs cryptographic hardware (whenever possible) via the <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=4&amp;format=html">crypto(4)</a> subsystem to optimize the performance of IPsec. This subsystem is new, and does not support all the features that are available in the KAME version of IPsec. However, in order to enable hardware-accelerated IPsec, the following kernel option has to be added to your kernel configuration file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options	  FAST_IPSEC  <span class=c># new IPsec (cannot define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Note, that it is not currently possible to use the "Fast IPsec" subsystem in lieu of the KAME implementation of IPsec. Consult the manual page for more information.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>To let firewalls properly track state for <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> tunnels too, you have to enable the <code>IPSEC_FILTERGIF</code> in your kernel configuration:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_FILTERGIF  <span class=c>#filter ipsec packets from a tunnel</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>IPsec consists of two sub-protocols:</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>, protects the IP packet data from third party interference, by encrypting the contents using symmetric cryptography algorithms (like Blowfish, 3DES).</p></li><li><p><em>Authentication Header (AH)</em>, protects the IP packet header from third party interference and spoofing, by computing a cryptographic checksum and hashing the IP packet header fields with a secure hashing function. This is then followed by an additional header that contains the hash, to allow the information in the packet to be authenticated.</p></li></ul></div><div class=paragraph><p>ESP and AH can either be used together or separately, depending on the environment.</p></div><div class=paragraph><p>IPsec can either be used to directly encrypt the traffic between two hosts (known as <em>Transport Mode</em>); or to build "virtual tunnels" between two subnets, which could be used for secure communication between two corporate networks (known as <em>Tunnel Mode</em>). The latter is more commonly known as a <em>Virtual Private Network (VPN)</em>. The <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> manual page should be consulted for detailed information on the IPsec subsystem in FreeBSD.</p></div><div class=paragraph><p>To add IPsec support to your kernel, add the following options to your kernel configuration file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        <span class=c>#IP security</span>
options   IPSEC_ESP    <span class=c>#IP security (crypto; define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>If IPsec debugging support is desired, the following kernel option should also be added:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  <span class=c>#debug for IP security</span></code></pre></div></div></div><div class=sect3><h4 id=_the_problem>35.10.2. The Problem<a class=anchor href=#_the_problem></a></h4><div class=paragraph><p>There is no standard for what constitutes a VPN. VPNs can be implemented using a number of different technologies, each of which have their own strengths and weaknesses. This section presents a scenario, and the strategies used for implementing a VPN for this scenario.</p></div></div><div class=sect3><h4 id=_the_scenario_two_networks_connected_to_the_internet_to_behave_as_one>35.10.3. The Scenario: Two networks, connected to the Internet, to behave as one<a class=anchor href=#_the_scenario_two_networks_connected_to_the_internet_to_behave_as_one></a></h4><div class=paragraph><p>The premise is as follows:</p></div><div class=ulist><ul><li><p>You have at least two sites</p></li><li><p>Both sites are using IP internally</p></li><li><p>Both sites are connected to the Internet, through a gateway that is running FreeBSD.</p></li><li><p>The gateway on each network has at least one public IP address.</p></li><li><p>The internal addresses of the two networks can be public or private IP addresses, it does not matter. You can be running NAT on the gateway machine if necessary.</p></li><li><p>The internal IP addresses of the two networks <em>do not collide</em>. While I expect it is theoretically possible to use a combination of VPN technology and NAT to get this to work, I expect it to be a configuration nightmare.</p></li></ul></div><div class=paragraph><p>If you find that you are trying to connect two networks, both of which, internally, use the same private IP address range (e.g. both of them use <code>192.168.1.x</code>), then one of the networks will have to be renumbered.</p></div><div class=paragraph><p>The network topology might look something like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-network.png alt="ipsec network"></div></div><div class=paragraph><p>Notice the two public IP addresses. I will use the letters to refer to them in the rest of this article. Anywhere you see those letters in this article, replace them with your own public IP addresses. Note also that internally, the two gateway machines have .1 IP addresses, and that the two networks have different private IP addresses (<code>192.168.1.x</code> and <code>192.168.2.x</code> respectively). All the machines on the private networks have been configured to use the <code>.1</code> machine as their default gateway.</p></div><div class=paragraph><p>The intention is that, from a network point of view, each network should view the machines on the other network as though they were directly attached the same router — albeit a slightly slow router with an occasional tendency to drop packets.</p></div><div class=paragraph><p>This means that (for example), machine <code>192.168.1.20</code> should be able to run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.34</pre></div></div><div class=paragraph><p>and have it work, transparently. Windows® machines should be able to see the machines on the other network, browse file shares, and so on, in exactly the same way that they can browse machines on the local network.</p></div><div class=paragraph><p>And the whole thing has to be secure. This means that traffic between the two networks has to be encrypted.</p></div><div class=paragraph><p>Creating a VPN between these two networks is a multi-step process. The stages are as follows:</p></div><div class="olist arabic"><ol class=arabic><li><p>Create a "virtual" network link between the two networks, across the Internet. Test it, using tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, to make sure it works.</p></li><li><p>Apply security policies to ensure that traffic between the two networks is transparently encrypted and decrypted as necessary. Test this, using tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>, to ensure that traffic is encrypted.</p></li><li><p>Configure additional software on the FreeBSD gateways, to allow Windows® machines to see one another across the VPN.</p></li></ol></div><div class=sect4><h5 id=_step_1_creating_and_testing_a_virtual_network_link>35.10.3.1. Step 1: Creating and testing a "virtual" network link<a class=anchor href=#_step_1_creating_and_testing_a_virtual_network_link></a></h5><div class=paragraph><p>Suppose that you were logged in to the gateway machine on network #1 (with public IP address <code>A.B.C.D</code>, private IP address <code>192.168.1.1</code>), and you ran <code>ping 192.168.2.1</code>, which is the private address of the machine with IP address <code>W.X.Y.Z</code>. What needs to happen in order for this to work?</p></div><div class="olist arabic"><ol class=arabic><li><p>The gateway machine needs to know how to reach <code>192.168.2.1</code>. In other words, it needs to have a route to <code>192.168.2.1</code>.</p></li><li><p>Private IP addresses, such as those in the <code>192.168.x</code> range are not supposed to appear on the Internet at large. Instead, each packet you send to <code>192.168.2.1</code> will need to be wrapped up inside another packet. This packet will need to appear to be from <code>A.B.C.D</code>, and it will have to be sent to <code>W.X.Y.Z</code>. This process is called <em>encapsulation</em>.</p></li><li><p>Once this packet arrives at <code>W.X.Y.Z</code> it will need to "unencapsulated", and delivered to <code>192.168.2.1</code>.</p></li></ol></div><div class=paragraph><p>You can think of this as requiring a "tunnel" between the two networks. The two "tunnel mouths" are the IP addresses <code>A.B.C.D</code> and <code>W.X.Y.Z</code>, and the tunnel must be told the addresses of the private IP addresses that will be allowed to pass through it. The tunnel is used to transfer traffic with private IP addresses across the public Internet.</p></div><div class=paragraph><p>This tunnel is created by using the generic interface, or <span class=filename>gif</span> devices on FreeBSD. As you can imagine, the <span class=filename>gif</span> interface on each gateway host must be configured with four IP addresses; two for the public IP addresses, and two for the private IP addresses.</p></div><div class=paragraph><p>Support for the gif device must be compiled in to the FreeBSD kernel on both machines. You can do this by adding the line:</p></div><div class="literalblock programlisting"><div class=content><pre>device gif</pre></div></div><div class=paragraph><p>to the kernel configuration files on both machines, and then compile, install, and reboot as normal.</p></div><div class=paragraph><p>Configuring the tunnel is a two step process. First the tunnel must be told what the outside (or public) IP addresses are, using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Then the private IP addresses must be configured using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=paragraph><p>On the gateway machine on network #1 you would run the following commands to configure the tunnel.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0 tunnel A.B.C.D W.X.Y.Z</span>
<span class=c># ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff</span></code></pre></div></div><div class=paragraph><p>On the other gateway machine you run the same commands, but with the order of the IP addresses reversed.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0 tunnel W.X.Y.Z A.B.C.D</span>
<span class=c># ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff</span></code></pre></div></div><div class=paragraph><p>You can then run:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig gif0</pre></div></div><div class=paragraph><p>to see the configuration. For example, on the network #1 gateway, you would see this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1280
        tunnel inet A.B.C.D <span class=nt>--</span><span class=o>&gt;</span> W.X.Y.Z
        inet 192.168.1.1 <span class=nt>--</span><span class=o>&gt;</span> 192.168.2.1 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>As you can see, a tunnel has been created between the physical addresses <code>A.B.C.D</code> and <code>W.X.Y.Z</code>, and the traffic allowed through the tunnel is that between <code>192.168.1.1</code> and <code>192.168.2.1</code>.</p></div><div class=paragraph><p>This will also have added an entry to the routing table on both machines, which you can examine with the command <code>netstat -rn</code>. This output is from the gateway host on network #1.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -rn</span>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...</code></pre></div></div><div class=paragraph><p>As the "Flags" value indicates, this is a host route, which means that each gateway knows how to reach the other gateway, but they do not know how to reach the rest of their respective networks. That problem will be fixed shortly.</p></div><div class=paragraph><p>It is likely that you are running a firewall on both machines. This will need to be circumvented for your VPN traffic. You might want to allow all traffic between both networks, or you might want to include firewall rules that protect both ends of the VPN from one another.</p></div><div class=paragraph><p>It greatly simplifies testing if you configure the firewall to allow all traffic through the VPN. You can always tighten things up later. If you are using <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> on the gateway machines then a command like</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div><div class=paragraph><p>will allow all traffic between the two end points of the VPN, without affecting your other firewall rules. Obviously you will need to run this command on both gateway hosts.</p></div><div class=paragraph><p>This is sufficient to allow each gateway machine to ping the other. On <code>192.168.1.1</code>, you should be able to run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>and get a response, and you should be able to do the same thing on the other gateway machine.</p></div><div class=paragraph><p>However, you will not be able to reach internal machines on either network yet. This is because of the routing — although the gateway machines know how to reach one another, they do not know how to reach the network behind each one.</p></div><div class=paragraph><p>To solve this problem you must add a static route on each gateway machine. The command to do this on the first gateway would be:</p></div><div class="literalblock programlisting"><div class=content><pre>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00</pre></div></div><div class=paragraph><p>This says "In order to reach the hosts on the network <code>192.168.2.0</code>, send the packets to the host <code>192.168.2.1</code>". You will need to run a similar command on the other gateway, but with the <code>192.168.1.x</code> addresses instead.</p></div><div class=paragraph><p>IP traffic from hosts on one network will now be able to reach hosts on the other network.</p></div><div class=paragraph><p>That has now created two thirds of a VPN between the two networks, in as much as it is "virtual" and it is a "network". It is not private yet. You can test this using <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. Log in to the gateway host and run</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>In another log in session on the same host run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>You will see output that looks something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>16:10:24.018080 192.168.1.1  192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1  192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1  192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1  192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1  192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1  192.168.2.1: icmp: echo reply</pre></div></div><div class=paragraph><p>As you can see, the ICMP messages are going back and forth unencrypted. If you had used the <code>-s</code> parameter to <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> to grab more bytes of data from the packets you would see more information.</p></div><div class=paragraph><p>Obviously this is unacceptable. The next section will discuss securing the link between the two networks so that all traffic is automatically encrypted.</p></div><div class=ulist><div class=title>Summary:</div><ul><li><p>Configure both kernels with "device gif".</p></li><li><p>Edit <span class=filename>/etc/rc.conf</span> on gateway host #1 and add the following lines (replacing IP addresses as necessary).</p><div class="literalblock programlisting"><div class=content><pre>gif_interfaces=&#34;gif0&#34;
gifconfig_gif0=&#34;A.B.C.D W.X.Y.Z&#34;
ifconfig_gif0=&#34;inet 192.168.1.1 192.168.2.1 netmask 0xffffffff&#34;
static_routes=&#34;vpn&#34;
route_vpn=&#34;192.168.2.0 192.168.2.1 netmask 0xffffff00&#34;</pre></div></div></li><li><p>Edit your firewall script (<span class=filename>/etc/rc.firewall</span>, or similar) on both hosts, and add</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div></li><li><p>Make similar changes to <span class=filename>/etc/rc.conf</span> on gateway host #2, reversing the order of IP addresses.</p></li></ul></div></div><div class=sect4><h5 id=_step_2_securing_the_link>35.10.3.2. Step 2: Securing the link<a class=anchor href=#_step_2_securing_the_link></a></h5><div class=paragraph><p>To secure the link we will be using IPsec. IPsec provides a mechanism for two hosts to agree on an encryption key, and to then use this key in order to encrypt data between the two hosts.</p></div><div class=paragraph><p>The are two areas of configuration to be considered here.</p></div><div class="olist arabic"><ol class=arabic><li><p>There must be a mechanism for two hosts to agree on the encryption mechanism to use. Once two hosts have agreed on this mechanism there is said to be a "security association" between them.</p></li><li><p>There must be a mechanism for specifying which traffic should be encrypted. Obviously, you do not want to encrypt all your outgoing traffic — you only want to encrypt the traffic that is part of the VPN. The rules that you put in place to determine what traffic will be encrypted are called "security policies".</p></li></ol></div><div class=paragraph><p>Security associations and security policies are both maintained by the kernel, and can be modified by userland programs. However, before you can do this you must configure the kernel to support IPsec and the Encapsulated Security Payload (ESP) protocol. This is done by configuring a kernel with:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div><div class=paragraph><p>and recompiling, reinstalling, and rebooting. As before you will need to do this to the kernels on both of the gateway hosts.</p></div><div class=paragraph><p>You have two choices when it comes to setting up security associations. You can configure them by hand between two hosts, which entails choosing the encryption algorithm, encryption keys, and so forth, or you can use daemons that implement the Internet Key Exchange protocol (IKE) to do this for you.</p></div><div class=paragraph><p>I recommend the latter. Apart from anything else, it is easier to set up.</p></div><div class=paragraph><p>Editing and displaying security policies is carried out using <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. By analogy, <code>setkey</code> is to the kernel’s security policy tables as <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> is to the kernel’s routing tables. <code>setkey</code> can also display the current security associations, and to continue the analogy further, is akin to <code>netstat -r</code> in that respect.</p></div><div class=paragraph><p>There are a number of choices for daemons to manage security associations with FreeBSD. This article will describe how to use one of these, racoon - which is available from <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a> in the FreeBSD Ports collection.</p></div><div class=paragraph><p>The racoon software must be run on both gateway hosts. On each host it is configured with the IP address of the other end of the VPN, and a secret key (which you choose, and must be the same on both gateways).</p></div><div class=paragraph><p>The two daemons then contact one another, confirm that they are who they say they are (by using the secret key that you configured). The daemons then generate a new secret key, and use this to encrypt the traffic over the VPN. They periodically change this secret, so that even if an attacker were to crack one of the keys (which is as theoretically close to unfeasible as it gets) it will not do them much good — by the time they have cracked the key the two daemons have chosen another one.</p></div><div class=paragraph><p>The configuration file for racoon is stored in <span class=filename>${PREFIX}/etc/racoon</span>. You should find a configuration file there, which should not need to be changed too much. The other component of racoon’s configuration, which you will need to change, is the "pre-shared key".</p></div><div class=paragraph><p>The default racoon configuration expects to find this in the file <span class=filename>${PREFIX}/etc/racoon/psk.txt</span>. It is important to note that the pre-shared key is <em>not</em> the key that will be used to encrypt your traffic across the VPN link, it is simply a token that allows the key management daemons to trust one another.</p></div><div class=paragraph><p><span class=filename>psk.txt</span> contains a line for each remote site you are dealing with. In this example, where there are two sites, each <span class=filename>psk.txt</span> file will contain one line (because each end of the VPN is only dealing with one other end).</p></div><div class=paragraph><p>On gateway host #1 this line should look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>W.X.Y.Z            secret</pre></div></div><div class=paragraph><p>That is, the <em>public</em> IP address of the remote end, whitespace, and a text string that provides the secret. Obviously, you should not use "secret" as your key — the normal rules for choosing a password apply.</p></div><div class=paragraph><p>On gateway host #2 the line would look like this</p></div><div class="literalblock programlisting"><div class=content><pre>A.B.C.D            secret</pre></div></div><div class=paragraph><p>That is, the public IP address of the remote end, and the same secret key. <span class=filename>psk.txt</span> must be mode <code>0600</code> (i.e., only read/write to <code>root</code>) before racoon will run.</p></div><div class=paragraph><p>You must run racoon on both gateway machines. You will also need to add some firewall rules to allow the IKE traffic, which is carried over UDP to the ISAKMP (Internet Security Association Key Management Protocol) port. Again, this should be fairly early in your firewall ruleset.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp</pre></div></div><div class=paragraph><p>Once racoon is running you can try pinging one gateway host from the other. The connection is still not encrypted, but racoon will then set up the security associations between the two hosts — this might take a moment, and you may see this as a short delay before the ping commands start responding.</p></div><div class=paragraph><p>Once the security association has been set up you can view it using <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Run</p></div><div class="literalblock programlisting"><div class=content><pre>setkey -D</pre></div></div><div class=paragraph><p>on either host to view the security association information.</p></div><div class=paragraph><p>That’s one half of the problem. The other half is setting your security policies.</p></div><div class=paragraph><p>To create a sensible security policy, let’s review what’s been set up so far. This discussions hold for both ends of the link.</p></div><div class=paragraph><p>Each IP packet that you send out has a header that contains data about the packet. The header includes the IP addresses of both the source and destination. As we already know, private IP addresses, such as the <code>192.168.x.y</code> range are not supposed to appear on the public Internet. Instead, they must first be encapsulated inside another packet. This packet must have the public source and destination IP addresses substituted for the private addresses.</p></div><div class=paragraph><p>So if your outgoing packet started looking like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-out-pkt.png alt="ipsec out pkt"></div></div><div class=paragraph><p>Then it will be encapsulated inside another packet, looking something like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-encap-pkt.png alt="ipsec encap pkt"></div></div><div class=paragraph><p>This encapsulation is carried out by the <span class=filename>gif</span> device. As you can see, the packet now has real IP addresses on the outside, and our original packet has been wrapped up as data inside the packet that will be put out on the Internet.</p></div><div class=paragraph><p>Obviously, we want all traffic between the VPNs to be encrypted. You might try putting this in to words, as:</p></div><div class=paragraph><p>"If a packet leaves from <code>A.B.C.D</code>, and it is destined for <code>W.X.Y.Z</code>, then encrypt it, using the necessary security associations."</p></div><div class=paragraph><p>"If a packet arrives from <code>W.X.Y.Z</code>, and it is destined for <code>A.B.C.D</code>, then decrypt it, using the necessary security associations."</p></div><div class=paragraph><p>That’s close, but not quite right. If you did this, all traffic to and from <code>W.X.Y.Z</code>, even traffic that was not part of the VPN, would be encrypted. That’s not quite what you want. The correct policy is as follows</p></div><div class=paragraph><p>"If a packet leaves from <code>A.B.C.D</code>, and that packet is encapsulating another packet, and it is destined for <code>W.X.Y.Z</code>, then encrypt it, using the necessary security associations."</p></div><div class=paragraph><p>"If a packet arrives from <code>W.X.Y.Z</code>, and that packet is encapsulating another packet, and it is destined for <code>A.B.C.D</code>, then decrypt it, using the necessary security associations."</p></div><div class=paragraph><p>A subtle change, but a necessary one.</p></div><div class=paragraph><p>Security policies are also set using <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> features a configuration language for defining the policy. You can either enter configuration instructions via stdin, or you can use the <code>-f</code> option to specify a filename that contains configuration instructions.</p></div><div class=paragraph><p>The configuration on gateway host #1 (which has the public IP address <code>A.B.C.D</code>) to force all outbound traffic to <code>W.X.Y.Z</code> to be encrypted is:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Put these commands in a file (e.g. <span class=filename>/etc/ipsec.conf</span>) and then run</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -f /etc/ipsec.conf</span></code></pre></div></div><div class=paragraph><p><code>spdadd</code> tells <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> that we want to add a rule to the secure policy database. The rest of this line specifies which packets will match this policy. <code>A.B.C.D/32</code> and <code>W.X.Y.Z/32</code> are the IP addresses and netmasks that identify the network or hosts that this policy will apply to. In this case, we want it to apply to traffic between these two hosts. <code>ipencap</code> tells the kernel that this policy should only apply to packets that encapsulate other packets. <code>-P out</code> says that this policy applies to outgoing packets, and <code>ipsec</code> says that the packet will be secured.</p></div><div class=paragraph><p>The second line specifies how this packet will be encrypted. <code>esp</code> is the protocol that will be used, while <code>tunnel</code> indicates that the packet will be further encapsulated in an IPsec packet. The repeated use of <code>A.B.C.D</code> and <code>W.X.Y.Z</code> is used to select the security association to use, and the final <code>require</code> mandates that packets must be encrypted if they match this rule.</p></div><div class=paragraph><p>This rule only matches outgoing packets. You will need a similar rule to match incoming packets.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>Note the <code>in</code> instead of <code>out</code> in this case, and the necessary reversal of the IP addresses.</p></div><div class=paragraph><p>The other gateway host (which has the public IP address <code>W.X.Y.Z</code>) will need similar rules.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Finally, you need to add firewall rules to allow ESP and IPENCAP packets back and forth. These rules will need to be added to both hosts.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div><div class=paragraph><p>Because the rules are symmetric you can use the same rules on each gateway host.</p></div><div class=paragraph><p>Outgoing packets will now look something like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-crypt-pkt.png alt="ipsec crypt pkt"></div></div><div class=paragraph><p>When they are received by the far end of the VPN they will first be decrypted (using the security associations that have been negotiated by racoon). Then they will enter the <span class=filename>gif</span> interface, which will unwrap the second layer, until you are left with the innermost packet, which can then travel in to the inner network.</p></div><div class=paragraph><p>You can check the security using the same <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> test from earlier. First, log in to the <code>A.B.C.D</code> gateway machine, and run:</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>In another log in session on the same host run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>This time you should see output like the following:</p></div><div class="literalblock programlisting"><div class=content><pre>XXX tcpdump output</pre></div></div><div class=paragraph><p>Now, as you can see, <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> shows the ESP packets. If you try to examine them with the <code>-s</code> option you will see (apparently) gibberish, because of the encryption.</p></div><div class=paragraph><p>Congratulations. You have just set up a VPN between two remote sites.</p></div><div class=ulist><div class=title>Summary</div><ul><li><p>Configure both kernels with:</p><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div></li><li><p>Install <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a>. Edit <span class=filename>${PREFIX}/etc/racoon/psk.txt</span> on both gateway hosts, adding an entry for the remote host’s IP address and a secret key that they both know. Make sure this file is mode 0600.</p></li><li><p>Add the following lines to <span class=filename>/etc/rc.conf</span> on each host:</p><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_file=&#34;/etc/ipsec.conf&#34;</pre></div></div></li><li><p>Create an <span class=filename>/etc/ipsec.conf</span> on each host that contains the necessary spdadd lines. On gateway host #1 this would be:</p><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>On gateway host #2 this would be:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div></li><li><p>Add firewall rules to allow IKE, ESP, and IPENCAP traffic to both hosts:</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div></li></ul></div><div class=paragraph><p>The previous two steps should suffice to get the VPN up and running. Machines on each network will be able to refer to one another using IP addresses, and all traffic across the link will be automatically and securely encrypted.</p></div></div></div></div><div class=sect2><h3 id=openssh>35.11. OpenSSH<a class=anchor href=#openssh></a></h3><div class=paragraph><p>OpenSSH is a set of network connectivity tools used to access remote machines securely. It can be used as a direct replacement for <code>rlogin</code>, <code>rsh</code>, <code>rcp</code>, and <code>telnet</code>. Additionally, TCP/IP connections can be tunneled/forwarded securely through SSH. OpenSSH encrypts all traffic to effectively eliminate eavesdropping, connection hijacking, and other network-level attacks.</p></div><div class=paragraph><p>OpenSSH is maintained by the OpenBSD project, and is based upon SSH v1.2.12 with all the recent bug fixes and updates. It is compatible with both SSH protocols 1 and 2.</p></div><div class=sect3><h4 id=_advantages_of_using_openssh>35.11.1. Advantages of Using OpenSSH<a class=anchor href=#_advantages_of_using_openssh></a></h4><div class=paragraph><p>Normally, when using <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, data is sent over the network in an clear, un-encrypted form. Network sniffers anywhere in between the client and server can steal your user/password information or data transferred in your session. OpenSSH offers a variety of authentication and encryption methods to prevent this from happening.</p></div></div><div class=sect3><h4 id=_enabling_sshd>35.11.2. Enabling sshd<a class=anchor href=#_enabling_sshd></a></h4><div class=paragraph><p>The sshd is an option presented during a <code>Standard</code> install of FreeBSD. To see if sshd is enabled, check the <span class=filename>rc.conf</span> file for:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>This will load <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, the daemon program for OpenSSH, the next time your system initializes. Alternatively, it is possible to use <span class=filename>/etc/rc.d/sshd</span> <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> script to start OpenSSH:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/rc.d/sshd start</pre></div></div></div><div class=sect3><h4 id=_ssh_client>35.11.3. SSH Client<a class=anchor href=#_ssh_client></a></h4><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> utility works similarly to <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
Host key not found from the list of known hosts.
Are you sure you want to <span class=k>continue </span>connecting <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>? <span class=nb>yes
</span>Host <span class=s1>&#39;example.com&#39;</span> added to the list of known hosts.
user@example.com<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>The login will continue just as it would have if a session was created using <code>rlogin</code> or <code>telnet</code>. SSH utilizes a key fingerprint system for verifying the authenticity of the server when the client connects. The user is prompted to enter <code>yes</code> only when connecting for the first time. Future attempts to login are all verified against the saved fingerprint key. The SSH client will alert you if the saved fingerprint differs from the received fingerprint on future login attempts. The fingerprints are saved in <span class=filename>~/.ssh/known_hosts</span>, or <span class=filename>~/.ssh/known_hosts2</span> for SSH v2 fingerprints.</p></div><div class=paragraph><p>By default, recent versions of the OpenSSH servers only accept SSH v2 connections. The client will use version 2 if possible and will fall back to version 1. The client can also be forced to use one or the other by passing it the <code>-1</code> or <code>-2</code> for version 1 or version 2, respectively. The version 1 compatibility is maintained in the client for backwards compatibility with older versions.</p></div></div><div class=sect3><h4 id=_secure_copy>35.11.4. Secure Copy<a class=anchor href=#_secure_copy></a></h4><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> command works similarly to <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>; it copies a file to or from a remote machine, except in a secure fashion.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp user@example.com:/COPYRIGHT COPYRIGHT</span>
user@example.com<span class=s1>&#39;s password: *******
COPYRIGHT            100% |*****************************|  4735
00:00
#</span></code></pre></div></div><div class=paragraph><p>Since the fingerprint was already saved for this host in the previous example, it is verified when using <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> here.</p></div><div class=paragraph><p>The arguments passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> are similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a>, with the file or files in the first argument, and the destination in the second. Since the file is fetched over the network, through SSH, one or more of the file arguments takes on the form <code>user@host:path_to_remote_file</code>.</p></div></div><div class=sect3><h4 id=_configuration>35.11.5. Configuration<a class=anchor href=#_configuration></a></h4><div class=paragraph><p>The system-wide configuration files for both the OpenSSH daemon and client reside within the <span class=filename>/etc/ssh</span> directory.</p></div><div class=paragraph><p><span class=filename>ssh_config</span> configures the client settings, while <span class=filename>sshd_config</span> configures the daemon.</p></div><div class=paragraph><p>Additionally, the <code>sshd_program</code> (<span class=filename>/usr/sbin/sshd</span> by default), and <code>sshd_flags</code><span class=filename>rc.conf</span> options can provide more levels of configuration.</p></div></div><div class=sect3><h4 id=security-ssh-keygen>35.11.6. ssh-keygen<a class=anchor href=#security-ssh-keygen></a></h4><div class=paragraph><p>Instead of using passwords, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> can be used to generate DSA or RSA keys to authenticate a user:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> dsa
Generating public/private dsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>:
Created directory <span class=s1>&#39;/home/user/.ssh&#39;</span><span class=nb>.</span>
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:
Enter same passphrase again:
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> will create a public and private key pair for use in authentication. The private key is stored in <span class=filename>~/.ssh/id_dsa</span> or <span class=filename>~/.ssh/id_rsa</span>, whereas the public key is stored in <span class=filename>~/.ssh/id_dsa.pub</span> or <span class=filename>~/.ssh/id_rsa.pub</span>, respectively for DSA and RSA key types. The public key must be placed in <span class=filename>~/.ssh/authorized_keys</span> of the remote machine in order for the setup to work. Similarly, RSA version 1 public keys should be placed in <span class=filename>~/.ssh/authorized_keys</span>.</p></div><div class=paragraph><p>This will allow connection to the remote machine based upon SSH keys instead of passwords.</p></div><div class=paragraph><p>If a passphrase is used in <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>, the user will be prompted for a password each time in order to use the private key. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> can alleviate the strain of repeatedly entering long passphrases, and is explored in the <a href=#security-ssh-agent>ssh-agent and ssh-add</a> section below.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>The various options and files can be different according to the OpenSSH version you have on your system; to avoid problems you should consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> manual page.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=security-ssh-agent>35.11.7. ssh-agent and ssh-add<a class=anchor href=#security-ssh-agent></a></h4><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> utilities provide methods for SSH keys to be loaded into memory for use, without needing to type the passphrase each time.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> utility will handle the authentication using the private key(s) that are loaded into it. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> should be used to launch another application. At the most basic level, it could spawn a shell or at a more advanced level, a window manager.</p></div><div class=paragraph><p>To use <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> in a shell, first it will need to be spawned with a shell as an argument. Secondly, the identity needs to be added by running <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> and providing it the passphrase for the private key. Once these steps have been completed the user will be able to <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> to any host that has the corresponding public key installed. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for</span> /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>
%</code></pre></div></div><div class=paragraph><p>To use <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> in X11, a call to <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> will need to be placed in <span class=filename>~/.xinitrc</span>. This will provide the <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> services to all programs launched in X11. An example <span class=filename>~/.xinitrc</span> file might look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>This would launch <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, which would in turn launch XFCE, every time X11 starts. Then once that is done and X11 has been restarted so that the changes can take effect, simply run <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> to load all of your SSH keys.</p></div></div><div class=sect3><h4 id=security-ssh-tunneling>35.11.8. SSH Tunneling<a class=anchor href=#security-ssh-tunneling></a></h4><div class=paragraph><p>OpenSSH has the ability to create a tunnel to encapsulate another protocol in an encrypted session.</p></div><div class=paragraph><p>The following command tells <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> to create a tunnel for telnet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>The <code>ssh</code> command is used with the following options:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Forces <code>ssh</code> to use version 2 of the protocol. (Do not use if you are working with older SSH servers)</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>Indicates no command, or tunnel only. If omitted, <code>ssh</code> would initiate a normal session.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Forces <code>ssh</code> to run in the background.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Indicates a local tunnel in <em>localport:remotehost:remoteport</em> fashion.</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>The remote SSH server.</p></dd></dl></div><div class=paragraph><p>An SSH tunnel works by creating a listen socket on <code>localhost</code> on the specified port. It then forwards any connection received on the local host/port via the SSH connection to the specified remote host and port.</p></div><div class=paragraph><p>In the example, port <em>5023</em> on <code>localhost</code> is being forwarded to port <em>23</em> on <code>localhost</code> of the remote machine. Since <em>23</em> is telnet, this would create a secure telnet session through an SSH tunnel.</p></div><div class=paragraph><p>This can be used to wrap any number of insecure TCP protocols such as SMTP, POP3, FTP, etc.</p></div><div class=exampleblock><div class=title>Παράδειγμα 11. Using SSH to Create a Secure Tunnel for SMTP</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p>This can be used in conjunction with an <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> and additional user accounts to create a more seamless/hassle-free SSH tunneling environment. Keys can be used in place of typing a password, and the tunnels can be run as a separate user.</p></div></div></div><div class=sect4><h5 id=_practical_ssh_tunneling_examples>35.11.8.1. Practical SSH Tunneling Examples<a class=anchor href=#_practical_ssh_tunneling_examples></a></h5><div class=sect5><h6 id=_secure_access_of_a_pop3_server>35.11.8.1.1. Secure Access of a POP3 Server<a class=anchor href=#_secure_access_of_a_pop3_server></a></h6><div class=paragraph><p>At work, there is an SSH server that accepts connections from the outside. On the same office network resides a mail server running a POP3 server. The network, or network path between your home and office may or may not be completely trustable. Because of this, you need to check your e-mail in a secure manner. The solution is to create an SSH connection to your office’s SSH server, and tunnel through to the mail server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>When the tunnel is up and running, you can point your mail client to send POP3 requests to <code>localhost</code> port 2110. A connection here will be forwarded securely across the tunnel to <code>mail.example.com</code>.</p></div></div><div class=sect5><h6 id=_bypassing_a_draconian_firewall>35.11.8.1.2. Bypassing a Draconian Firewall<a class=anchor href=#_bypassing_a_draconian_firewall></a></h6><div class=paragraph><p>Some network administrators impose extremely draconian firewall rules, filtering not only incoming connections, but outgoing connections. You may be only given access to contact remote machines on ports 22 and 80 for SSH and web surfing.</p></div><div class=paragraph><p>You may wish to access another (perhaps non-work related) service, such as an Ogg Vorbis server to stream music. If this Ogg Vorbis server is streaming on some other port than 22 or 80, you will not be able to access it.</p></div><div class=paragraph><p>The solution is to create an SSH connection to a machine outside of your network’s firewall, and use it to tunnel to the Ogg Vorbis server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Your streaming client can now be pointed to <code>localhost</code> port 8888, which will be forwarded over to <code>music.example.com</code> port 8000, successfully evading the firewall.</p></div></div></div></div><div class=sect3><h4 id=_the_allowusers_users_option>35.11.9. The <code>AllowUsers</code> Users Option<a class=anchor href=#_the_allowusers_users_option></a></h4><div class=paragraph><p>It is often a good idea to limit which users can log in and from where. The <code>AllowUsers</code> option is a good way to accomplish this. For example, to only allow the <code>root</code> user to log in from <code>192.168.1.32</code>, something like this would be appropriate in the <span class=filename>/etc/ssh/sshd_config</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>To allow the user <code>admin</code> to log in from anywhere, just list the username by itself:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>Multiple users should be listed on the same line, like so:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is important that you list each user that needs to log in to this machine; otherwise they will be locked out.</p></div></td></tr></tbody></table></div><div class=paragraph><p>After making changes to <span class=filename>/etc/ssh/sshd_config</span> you must tell <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> to reload its config files, by running:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd reload</span></code></pre></div></div></div><div class=sect3><h4 id=_further_reading>35.11.10. Further Reading<a class=anchor href=#_further_reading></a></h4><div class=paragraph><p><a href=http://www.openssh.com/>OpenSSH</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp-server&amp;sektion=8&amp;format=html">sftp-server(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a></p></div></div></div><div class=sect2><h3 id=fs-acl>35.12. File System Access Control Lists<a class=anchor href=#fs-acl></a></h3><div class=paragraph><p>In conjunction with file system enhancements like snapshots, FreeBSD 5.0 and later offers the security of File System Access Control Lists (ACLs).</p></div><div class=paragraph><p>Access Control Lists extend the standard UNIX® permission model in a highly compatible (POSIX®.1e) way. This feature permits an administrator to make use of and take advantage of a more sophisticated security model.</p></div><div class=paragraph><p>To enable ACL support for UFS file systems, the following:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>must be compiled into the kernel. If this option has not been compiled in, a warning message will be displayed when attempting to mount a file system supporting ACLs. This option is included in the <span class=filename>GENERIC</span> kernel. ACLs rely on extended attributes being enabled on the file system. Extended attributes are natively supported in the next generation UNIX® file system, UFS2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A higher level of administrative overhead is required to configure extended attributes on UFS1 than on UFS2. The performance of extended attributes on UFS2 is also substantially higher. As a result, UFS2 is generally recommended in preference to UFS1 for use with access control lists.</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACLs are enabled by the mount-time administrative flag, <code>acls</code>, which may be added to <span class=filename>/etc/fstab</span>. The mount-time flag can also be automatically set in a persistent manner using <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> to modify a superblock ACLs flag in the file system header. In general, it is preferred to use the superblock flag for several reasons:</p></div><div class=ulist><ul><li><p>The mount-time ACLs flag cannot be changed by a remount (<a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <code>-u</code>), only by means of a complete <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> and fresh <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. This means that ACLs cannot be enabled on the root file system after boot. It also means that you cannot change the disposition of a file system once it is in use.</p></li><li><p>Setting the superblock flag will cause the file system to always be mounted with ACLs enabled even if there is not an <span class=filename>fstab</span> entry or if the devices re-order. This prevents accidental mounting of the file system without ACLs enabled, which can result in ACLs being improperly enforced, and hence security problems.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>We may change the ACLs behavior to allow the flag to be enabled without a complete fresh <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, but we consider it desirable to discourage accidental mounting without ACLs enabled, because you can shoot your feet quite nastily if you enable ACLs, then disable them, then re-enable them without flushing the extended attributes. In general, once you have enabled ACLs on a file system, they should not be disabled, as the resulting file protections may not be compatible with those intended by the users of the system, and re-enabling ACLs may re-attach the previous ACLs to files that have since had their permissions changed, resulting in other unpredictable behavior.</p></div></td></tr></tbody></table></div><div class=paragraph><p>File systems with ACLs enabled will show a <code>+</code> (plus) sign in their permission settings when viewed. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>Here we see that the <span class=filename>directory1</span>, <span class=filename>directory2</span>, and <span class=filename>directory3</span> directories are all taking advantage of ACLs. The <span class=filename>public_html</span> directory is not.</p></div><div class=sect3><h4 id=_making_use_of_acls>35.12.1. Making Use of ACLs<a class=anchor href=#_making_use_of_acls></a></h4><div class=paragraph><p>The file system ACLs can be viewed by the <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> utility. For instance, to view the ACL settings on the <span class=filename>test</span> file, one would use the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>To change the ACL settings on this file, invoke the <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> utility. Observe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>The <code>-k</code> flag will remove all of the currently defined ACLs from a file or file system. The more preferable method would be to use <code>-b</code> as it leaves the basic fields required for ACLs to work.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>In the aforementioned command, the <code>-m</code> option was used to modify the default ACL entries. Since there were no pre-defined entries, as they were removed by the previous command, this will restore the default options and assign the options listed. Take care to notice that if you add a user or group which does not exist on the system, an <code>Invalid argument</code> error will be printed to <span class=filename>stdout</span>.</p></div></div></div><div class=sect2><h3 id=security-portaudit>35.13. Monitoring Third Party Security Issues<a class=anchor href=#security-portaudit></a></h3><div class=paragraph><p>In recent years, the security world has made many improvements to how vulnerability assessment is handled. The threat of system intrusion increases as third party utilities are installed and configured for virtually any operating system available today.</p></div><div class=paragraph><p>Vulnerability assessment is a key factor in security, and while FreeBSD releases advisories for the base system, doing so for every third party utility is beyond the FreeBSD Project’s capability. There is a way to mitigate third party vulnerabilities and warn administrators of known security issues. A FreeBSD add on utility known as Portaudit exists solely for this purpose.</p></div><div class=paragraph><p>The <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portaudit/>ports-mgmt/portaudit</a> port polls a database, updated and maintained by the FreeBSD Security Team and ports developers, for known security issues.</p></div><div class=paragraph><p>To begin using Portaudit, one must install it from the Ports Collection:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portaudit  make install clean</span></code></pre></div></div><div class=paragraph><p>During the install process, the configuration files for <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> will be updated, permitting Portaudit output in the daily security runs. Ensure the daily security run emails, which are sent to <code>root</code>'s email account, are being read. No more configuration will be required here.</p></div><div class=paragraph><p>After installation, an administrator can update the database and view known vulnerabilities in installed packages by invoking the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -Fda</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The database will automatically be updated during the <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> run; thus, the previous command is completely optional. It is only required for the following examples.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To audit the third party utilities installed as part of the Ports Collection at anytime, an administrator need only run the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -a</span></code></pre></div></div><div class=paragraph><p>Portaudit will produce something like this for vulnerable packages:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>By pointing a web browser to the URL shown, an administrator may obtain more information about the vulnerability in question. This will include versions affected, by FreeBSD Port version, along with other web sites which may contain security advisories.</p></div><div class=paragraph><p>In short, Portaudit is a powerful utility and extremely useful when coupled with the Portupgrade port.</p></div></div><div class=sect2><h3 id=security-advisories>35.14. FreeBSD Security Advisories<a class=anchor href=#security-advisories></a></h3><div class=paragraph><p>Like many production quality operating systems, FreeBSD publishes "Security Advisories". These advisories are usually mailed to the security lists and noted in the Errata only after the appropriate releases have been patched. This section will work to explain what an advisory is, how to understand it, and what measures to take in order to patch a system.</p></div><div class=sect3><h4 id=_what_does_an_advisory_look_like>35.14.1. What does an advisory look like?<a class=anchor href=#_what_does_an_advisory_look_like></a></h4><div class=paragraph><p>The FreeBSD security advisories look similar to the one below, taken from the <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>ηλεκτρονική λίστα Ανακοινώσεων για Θέματα Ασφάλειας του FreeBSD</a> mailing list.</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem <i class=conum data-value=1></i><b>(1)</b>

Category:       core <i class=conum data-value=2></i><b>(2)</b>
Module:         sys <i class=conum data-value=3></i><b>(3)</b>
Announced:      2003-09-23 <i class=conum data-value=4></i><b>(4)</b>
Credits:        Person@EMAIL-ADDRESS <i class=conum data-value=5></i><b>(5)</b>
Affects:        All releases of FreeBSD <i class=conum data-value=6></i><b>(6)</b>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39) <i class=conum data-value=7></i><b>(7)</b>
CVE Name:	CVE-XXXX-XXXX <i class=conum data-value=8></i><b>(8)</b>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background <i class=conum data-value=9></i><b>(9)</b>

II.  Problem Description <i class=conum data-value=10></i><b>(10)</b>

III. Impact <i class=conum data-value=11></i><b>(11)</b>

IV.  Workaround <i class=conum data-value=12></i><b>(12)</b>

V.   Solution <i class=conum data-value=13></i><b>(13)</b>

VI.  Correction details <i class=conum data-value=14></i><b>(14)</b>

VII. References <i class=conum data-value=15></i><b>(15)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The <code>Topic</code> field indicates exactly what the problem is. It is basically an introduction to the current security advisory and notes the utility with the vulnerability.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>Category</code> refers to the affected part of the system which may be one of <code>core</code>, <code>contrib</code>, or <code>ports</code>. The <code>core</code> category means that the vulnerability affects a core component of the FreeBSD operating system. The <code>contrib</code> category means that the vulnerability affects software contributed to the FreeBSD Project, such as sendmail. Finally the <code>ports</code> category indicates that the vulnerability affects add on software available as part of the Ports Collection.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>Module</code> field refers to the component location, for instance <code>sys</code>. In this example, we see that the module, <code>sys</code>, is affected; therefore, this vulnerability affects a component used within the kernel.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>Announced</code> field reflects the date said security advisory was published, or announced to the world. This means that the security team has verified that the problem does exist and that a patch has been committed to the FreeBSD source code repository.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The <code>Credits</code> field gives credit to the individual or organization who noticed the vulnerability and reported it.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>The <code>Affects</code> field explains which releases of FreeBSD are affected by this vulnerability. For the kernel, a quick look over the output from <code>ident</code> on the affected files will help in determining the revision. For ports, the version number is listed after the port name in <span class=filename>/var/db/pkg</span>. If the system does not sync with the FreeBSD CVS repository and rebuild daily, chances are that it is affected.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>The <code>Corrected</code> field indicates the date, time, time offset, and release that was corrected.
Reserved for the identification information used to look up vulnerabilities in the Common Vulnerabilities Database system.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The <code>Background</code> field gives information on exactly what the affected utility is. Most of the time this is why the utility exists in FreeBSD, what it is used for, and a bit of information on how the utility came to be.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>The <code>Problem Description</code> field explains the security hole in depth. This can include information on flawed code, or even how the utility could be maliciously used to open a security hole.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>The <code>Impact</code> field describes what type of impact the problem could have on a system. For example, this could be anything from a denial of service attack, to extra privileges available to users, or even giving the attacker superuser access.</td></tr><tr><td><i class=conum data-value=11></i><b>11</b></td><td>The <code>Workaround</code> field offers a feasible workaround to system administrators who may be incapable of upgrading the system. This may be due to time constraints, network availability, or a slew of other reasons. Regardless, security should not be taken lightly, and an affected system should either be patched or the security hole workaround should be implemented.</td></tr><tr><td><i class=conum data-value=12></i><b>12</b></td><td>The <code>Solution</code> field offers instructions on patching the affected system. This is a step by step tested and verified method for getting a system patched and working securely.</td></tr><tr><td><i class=conum data-value=13></i><b>13</b></td><td>The <code>Correction Details</code> field displays the CVS branch or release name with the periods changed to underscore characters. It also shows the revision number of the affected files within each branch.</td></tr><tr><td><i class=conum data-value=14></i><b>14</b></td><td>The <code>References</code> field usually offers sources of other information. This can include web URLs, books, mailing lists, and newsgroups.</td></tr></tbody></table></div></div></div><div class=sect2><h3 id=security-accounting>35.15. Process Accounting<a class=anchor href=#security-accounting></a></h3><div class=paragraph><p>Process accounting is a security method in which an administrator may keep track of system resources used, their allocation among users, provide for system monitoring, and minimally track a user’s commands.</p></div><div class=paragraph><p>This indeed has its own positive and negative points. One of the positives is that an intrusion may be narrowed down to the point of entry. A negative is the amount of logs generated by process accounting, and the disk space they may require. This section will walk an administrator through the basics of process accounting.</p></div><div class=sect3><h4 id=_enable_and_utilizing_process_accounting>35.15.1. Enable and Utilizing Process Accounting<a class=anchor href=#_enable_and_utilizing_process_accounting></a></h4><div class=paragraph><p>Before making use of process accounting, it must be enabled. To do this, execute the following commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/account/acct</span>

<span class=c># accton /var/account/acct</span>

<span class=c># echo &#39;accounting_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Once enabled, accounting will begin to track CPU stats, commands, etc. All accounting logs are in a non-human readable format and may be viewed using the <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> utility. If issued without any options, <code>sa</code> will print information relating to the number of per user calls, the total elapsed time in minutes, total CPU and user time in minutes, average number of I/O operations, etc.</p></div><div class=paragraph><p>To view information about commands being issued, one would use the <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a> utility. The <code>lastcomm</code> may be used to print out commands issued by users on specific <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>, for example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls</span>
	trhodes ttyp1</code></pre></div></div><div class=paragraph><p>Would print out all known usage of the <code>ls</code> by <code>trhodes</code> on the ttyp1 terminal.</p></div><div class=paragraph><p>Many other useful options exist and are explained in the <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> manual pages.</p></div></div></div></div></div><div class=sect1><h2 id=jails>Chapter 36. Jails<a class=anchor href=#jails></a></h2><div class=sectionbody><div class=sect2><h3 id=jails-synopsis>36.1. Σύνοψη<a class=anchor href=#jails-synopsis></a></h3><div class=paragraph><p>Το κεφάλαιο αυτό εξηγεί τι είναι τα jails (φυλακές) του FreeBSD και πως χρησιμοποιούνται. Τα jails, που αναφέρονται ορισμένες φορές σαν μια ενισχυμένη εναλλακτική λύση για <em>περιβάλλοντα chroot</em>, είναι ένα ισχυρό εργαλείο για διαχειριστές συστημάτων, αλλά η βασική τους χρήση μπορεί επίσης να είναι χρήσιμη σε προχωρημένους χρήστες.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Τι είναι ένα jail και τι σκοπό μπορεί να εξυπηρετήσει σε εγκαταστάσεις FreeBSD.</p></li><li><p>Πως να φτιάξετε, να εκκινήσετε, και να σταματήσετε ένα jail.</p></li><li><p>Τα βασικά της διαχείρισης ενός jail, τόσο μέσα, όσο και έξω από αυτό.</p></li></ul></div><div class=paragraph><p>Άλλες πηγές χρήσιμων πληροφοριών σχετικά με τα jails είναι:</p></div><div class=ulist><ul><li><p>Η σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Περιέχει πλήρη αναφορά του βοηθητικού προγράμματος <code>jail</code> - του διαχειριστικού εργαλείου που μπορεί να χρησιμοποιηθεί στο FreeBSD για την εκκίνηση, διακοπή, και έλεγχο των jails.</p></li><li><p>Οι λίστες ταχυδρομείου και τα αρχεία τους. Τα αρχεία από την <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>ηλεκτρονική λίστα γενικών ερωτήσεων του FreeBSD</a> και άλλες λίστες που εξυπηρετούνται από τον <a href=https://lists.freebsd.org>εξυπηρετητής για ηλεκτρονικές λίστες του FreeBSD</a> περιέχουν πλήρη οδηγό για τα jails. Είναι πάντοτε ενδιαφέρον να ψάχνετε τα αρχεία ή να δημοσιεύετε νέες ερωτήσεις στη λίστα <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a>.</p></li></ul></div></div><div class=sect2><h3 id=jails-terms>36.2. Όροι των Jails<a class=anchor href=#jails-terms></a></h3><div class=paragraph><p>Για να κατανοήσετε καλύτερα το πως οι εσωτερικές λειτουργίες του FreeBSD σχετίζονται με τα jails και πως αυτές αλληλεπιδρούν με τα υπόλοιπα μέρη του FreeBSD, θα χρησιμοποιήσουμε εκτενώς τους παρακάτω όρους:</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> (εντολή)</dt><dd><p>Ένα βοηθητικό πρόγραμμα, το οποίο χρησιμοποιεί την κλήση συστήματος <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> του FreeBSD για να αλλάξει τον γονικό κατάλογο (root directory) μιας διεργασίας και όλων των άλλων διεργασιών που εξαρτώνται από αυτή.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (περιβάλλον)</dt><dd><p>Το περιβάλλον μια διεργασίας που τρέχει μέσα σε ένα "chroot". Αυτό περιλαμβάνει πόρους όπως το τμήμα του συστήματος αρχείων που είναι ορατό, τα ID του χρήστη και της ομάδας που είναι διαθέσιμα, καθώς και τις διεπαφές δικτύου (network interfaces), τους μηχανισμούς IPC κλπ.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> (εντολή)</dt><dd><p>Το πρόγραμμα που σας επιτρέπει να διαχειρίζεστε το σύστημα σας και να ξεκινάτε διεργασίες σε περιβάλλον jail.</p></dd><dt class=hdlist1>host (σύστημα (system), διεργασία (process), χρήστης (user), κλπ.)</dt><dd><p>Το φυσικό σύστημα που φιλοξενεί και ελέγχει ένα περιβάλλον jail. Το host system έχει πρόσβαση σε όλο το διαθέσιμο υλικό, και μπορεί να ελέγξει διεργασίες τόσο μέσα όσο και έξω από το περιβάλλον του jail. Μία από τις σημαντικότερες διαφορές μεταξύ του host system και του jail είναι ότι οι περιορισμοί που εφαρμόζονται στις διεργασίες του χρήστη root μέσα στο περιβάλλον jail, δεν ισχύουν για τις διεργασίες στο host system.</p></dd><dt class=hdlist1>hosted (σύστημα (system), διεργασία (process), χρήστης (user), κλπ.)</dt><dd><p>Μια διεργασία, ένας χρήστης ή κάποια άλλη οντότητα, του οποίου η πρόσβαση στους πόρους του συστήματος περιορίζεται μέσα από ένα jail.</p></dd></dl></div></div><div class=sect2><h3 id=jails-intro>36.3. Εισαγωγή<a class=anchor href=#jails-intro></a></h3><div class=paragraph><p>Μια και η διαχείριση ενός συστήματος μπορεί να είναι δύσκολη και περίπλοκη, αναπτύχθηκαν αρκετά εργαλεία τα οποία μπορούν να κάνουν τη ζωή ενός διαχειριστή πολύ πιο εύκολη. Τα εργαλεία αυτά προσφέρουν κάποιες πρόσθετες δυνατότητες όσο αφορά τον τρόπο εγκατάστασης, ρύθμισης και συντήρησης ενός συστήματος. Μια από τις εργασίες που αναμένεται να εκτελέσει κάθε διαχειριστής συστήματος, είναι να ρυθμίσει σωστά την ασφάλεια του συστήματος, προκειμένου να προσφέρει τις υπηρεσίες για τις οποίες έχει προγραμματιστεί, χωρίς να επιτρέπει συμβιβασμούς στην ασφάλεια.</p></div><div class=paragraph><p>Ένα από τα εργαλεία που μπορούν να ενισχύσουν την ασφάλεια ενός συστήματος FreeBSD είναι τα <em>jails</em>. Τα Jails πρωτοεμφανίστηκαν στο FreeBSD 4.X από τον Poul-Henning Kamp &lt;<a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>>, αλλά βελτιώθηκαν πολύ περισσότερο στην έκδοση FreeBSD 5.X, προκειμένου να προσφέρουν περισσότερες δυνατότητες και να είναι περισσότερο ευέλικτα. Η ανάπτυξή τους συνεχίζεται ακόμη, με βελτιώσεις στους τομείς της ευχρηστίας, της απόδοσης, της αξιοπιστίας και της ασφάλειας που πρέπει να παρέχουν.</p></div><div class=sect3><h4 id=jails-what>36.3.1. Τι Είναι Ένα Jail<a class=anchor href=#jails-what></a></h4><div class=paragraph><p>Τα λειτουργικά συστήματα τύπου BSD, παρείχαν το <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> από την εποχή του 4.2BSD. Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> μπορεί να χρησιμοποιηθεί για να αλλάξει τον γονικό κατάλογο μιας ομάδας διεργασιών, δημιουργώντας ένα ασφαλές περιβάλλον, ξεχωριστό από το υπόλοιπο σύστημα. Όσες διεργασίες δημιουργούνται σε έναν τέτοιο περιβάλλον, δεν έχουν πρόσβαση σε αρχεία και πόρους έξω από αυτό. Για αυτό το λόγο, αν μια υπηρεσία τρέχει μέσα σε ένα τέτοιο περιβάλλον, και κάποιος εισβολέας καταφέρει να διεισδύσει σε αυτή, δε θα του επιτραπεί η πρόσβαση στο υπόλοιπο σύστημα. Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> είναι πολύ καλή για απλές εργασίες οι οποίες δε χρειάζονται να είναι πολύ ευέλικτες ή να διαθέτουν πολύπλοκα και προηγμένα χαρακτηριστικά. Ωστόσο, από την αρχή της ιδέας του chroot, βρέθηκαν αρκετοί τρόποι για να μπορέσει κάποιος να ξεφύγει από το περιβάλλον αυτό. Παρ' όλο που έχουν διορθωθεί πολλά σφάλματα στις πρόσφατες εκδόσεις του πυρήνα του FreeBSD, ήταν ξεκάθαρο ότι η <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> δεν ήταν η ιδανική λύση για την ασφάλιση υπηρεσιών. Έπρεπε να υλοποιηθεί ένα νέο υποσύστημα.</p></div><div class=paragraph><p>Αυτός είναι ένας από τους κύριους λόγους για την ανάπτυξη των <em>jails</em>.</p></div><div class=paragraph><p>Τα jails βελτίωσαν με διάφορους τρόπους την ιδέα του παραδοσιακού περιβάλλοντος του <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a>. Στο τυπικό περιβάλλον του <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a>, οι διεργασίες περιορίζονται μόνος ως προς το μέρος του συστήματος αρχείων όπου μπορούν να έχουν πρόσβαση. Οι υπόλοιποι πόροι του συστήματος (όπως οι χρήστες, οι τρέχοντες διεργασίες, το υποσύστημα δικτύωσης) είναι κοινόχρηστοι μεταξύ των διεργασιών του περιβάλλοντος chroot και των διεργασιών του host system. Τα jails επεκτείνουν αυτό το μοντέλο, με την εικονικοποίηση όχι μόνο της πρόσβασης στο σύστημα αρχείων, αλλά επίσης των χρηστών, του υποσυστήματος δικτύωσης του πυρήνα του FreeBSD και μερικών ακόμη πραγμάτων. Περισσότερα για τις διαθέσιμες εντολές που μπορούν να χρησιμοποιηθούν για τη ρύθμιση και τον έλεγχο ενός περιβάλλοντος jail μπορείτε να βρείτε στο <a href=#jails-tuning>Λεπτομερής Ρύθμιση και Διαχείριση</a>.</p></div><div class=paragraph><p>Το Jail έχει τέσσερα κύρια στοιχεία:</p></div><div class=ulist><ul><li><p>Έναν κατάλογο με δική του δομή - το αρχικό σημείο στο οποίο εισέρχεται ένα jail. Από τη στιγμή που μια διεργασία βρίσκεται μέσα σε ένα jail, δεν επιτρέπεται να βγει έξω από τον κατάλογο αυτό. Τα προβλήματα που ταλαιπωρούσαν τον σχεδιασμό του <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> δεν επηρεάζουν τα jails του FreeBSD.</p></li><li><p>Ένα hostname (όνομα συστήματος) - το hostname το οποίο θα χρησιμοποιηθεί μέσα στο jail. Τα jails χρησιμοποιούνται κυρίως για την εξυπηρέτηση δικτυακών υπηρεσιών, επομένως η ύπαρξη ενός χαρακτηριστικού hostname που να περιγράφει ταυτόχρονα και τη χρήση του, μπορεί να βοηθήσει αρκετά τον διαχειριστή συστήματος.</p></li><li><p>Μια διεύθυνση IP - αυτή η διεύθυνση αντιστοιχεί σε ένα jail και δεν μπορεί να αλλάξει κατά τη διάρκεια της ζωής του. Η διεύθυνση IP ενός jail είναι συνήθως μία διεύθυνση τύπου alias για μια ήδη υπάρχουσα διεπαφή δικτύου (network interface), αλλά κάτι τέτοιο δεν είναι απαραίτητο.</p></li><li><p>Μία εντολή - η διαδρομή προς ένα εκτελέσιμο το οποίο θα εκτελείται μέσα στο jail. Η διαδρομή αυτή είναι σχετική ως προς τον γονικό κατάλογο του περιβάλλοντος του jail, και μπορεί να διαφέρει πολύ από jail σε jail ανάλογα με το συγκεκριμένο περιβάλλον.</p></li></ul></div><div class=paragraph><p>Εκτός αυτών, τα jails μπορούν να έχουν τις δικές τους ομάδες χρηστών και τον δικό τους χρήστη <code>root</code>. Φυσικά, ο έλεγχος που έχει ο χρήστης <code>root</code> του jail, περιορίζεται μέσα στο περιβάλλον του jail, και από την οπτική γωνία του host system, ο χρήστης αυτός δεν είναι παντοδύναμος. Επιπλέον, ο χρήστης <code>root</code> του jail, δεν μπορεί να εκτελέσει κρίσιμες εργασίες στο σύστημα έξω από το περιβάλλον του <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Περισσότερες πληροφορίες σχετικά με τις δυνατότητες και τους περιορισμούς του <code>root</code> θα βρείτε στο <a href=#jails-tuning>Λεπτομερής Ρύθμιση και Διαχείριση</a>.</p></div></div></div><div class=sect2><h3 id=jails-build>36.4. Δημιουργώντας και Ελέγχοντας Jails<a class=anchor href=#jails-build></a></h3><div class=paragraph><p>Μερικοί διαχειριστές συστημάτων κατηγοριοποιούν τα jails σε δύο ενότητες: τα "complete (πλήρη)" jails, τα οποία μιμούνται ένα πραγματικό σύστημα FreeBSD, και τα "service" jails, τα οποία χρησιμοποιούνται για μια εφαρμογή ή υπηρεσία, που πιθανόν εκτελείται με ειδικά προνόμια. Αυτός είναι ένας νοητικός διαχωρισμός και δεν επιδρά στη διαδικασία δημιουργίας ενός jail. Η σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> περιέχει κατατοπιστικές πληροφορίες για τη διαδικασία δημιουργίας ενός jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setenv D /here/is/the/jail</span>
<span class=c># mkdir -p $D </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># cd /usr/src</span>
<span class=c># make buildworld </span><i class=conum data-value=2></i><b>(2)</b>
<span class=c># make installworld DESTDIR=$D </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make distribution DESTDIR=$D </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># mount -t devfs devfs $D/dev </span><i class=conum data-value=5></i><b>(5)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Ο καλύτερος τρόπος για να ξεκινήσετε είναι με την επιλογή μιας θέσης (διαδρομής) για το jail σας. Εκεί θα βρίσκονται αποθηκευμένα τα αρχεία του jail όσο αφορά το σύστημα σας. Μια καλή ιδέα είναι το <span class=filename>/usr/jail/jailname</span>, όπου <em>jailname</em> το hostname με το οποίο θα αναγνωρίζεται το jail. Το σύστημα αρχείων <span class=filename>/usr/</span> έχει συνήθως αρκετό χώρο για το σύστημα αρχείων του jail, το οποίο, για ένα "complete" jail είναι ουσιαστικά ένας κλώνος κάθε αρχείου του βασικού συστήματος μια προεπιλεγμένης εγκατάστασης του FreeBSD.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Το βήμα αυτό δεν απαιτείται αν έχετε μεταγλωττίσει στο παρελθόν το βασικό σύστημα χρησιμοποιώντας την εντολή <code>make world</code> ή <code>make buildworld</code>. Μπορείτε απλώς να εγκαταστήσετε το υπάρχον σύστημα σας στο νέο jail.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Η εντολή αυτή θα εμπλουτίσει τον κατάλογο που επιλέξατε για το jail με όλα τα απαραίτητα αρχεία, βιβλιοθήκες, σελίδες βοήθειας κλπ.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Το <code>distribution</code> target του make εγκαθιστά όλα τα αρχεία ρυθμίσεων που απαιτούνται. Με απλά λόγια, εγκαθιστά κάθε αρχείο από το <span class=filename>/usr/src/etc/</span> στον κατάλογο <span class=filename>/etc</span> του περιβάλλοντος jail: <span class=filename>$D/etc/</span>.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Δε χρειάζεται να προσαρτήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> στο περιβάλλον του jail. Από την άλλη όμως, όλες, ή σχεδόν όλες οι εφαρμογές χρειάζονται πρόσβαση σε τουλάχιστον μία συσκευή, αναλόγως με τον σκοπό της εφαρμογής. Είναι πολύ σημαντικό να ελέγχεται η πρόσβαση στις συσκευές μέσα σε ένα jail, καθώς λανθασμένες ρυθμίσεις μπορεί να επιτρέψουν σε κάποιον εισβολέα να κάνει "άσχημα παιχνίδια" μέσα στο jail. Ο έλεγχος του <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> γίνεται μέσω ενός συνόλου κανόνων οι οποίοι περιγράφονται στις σελίδες manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> και του <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a>.</td></tr></tbody></table></div><div class=paragraph><p>Από την στιγμή που έχει εγκατασταθεί ένα jail, μπορεί να εκκινηθεί με τη χρήση της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Η <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> δέχεται τέσσερις υποχρεωτικές παραμέτρους οι οποίες περιγράφονται στο <a href=#jails-what>Τι Είναι Ένα Jail</a>. Μπορείτε να δώσετε και άλλες παραμέτρους, π.χ., για να εκτελέσετε μια διεργασία στο περιβάλλον του jail με τις άδειες ενός συγκεκριμένου χρήστη. Η παράμετρος <code><em>command</em></code> εξαρτάται από τον τύπο του jail. Για ένα <em>εικονικό σύστημα</em>, το <span class=filename>/etc/rc</span> είναι μια καλή επιλογή, μια και στην ουσία θα κλωνοποιήσει την διαδικασία εκκίνησης ενός πραγματικού συστήματος FreeBSD. Για ένα <em>service</em> jail, η παράμετρος εξαρτάται από την υπηρεσία ή την εφαρμογή που θα τρέχει μέσα στο jail.</p></div><div class=paragraph><p>Τα jails συνήθως ξεκινούν κατά την εκκίνηση και ο μηχανισμός <span class=filename>rc</span> του FreeBSD παρέχει έναν εύκολο τρόπο για να γίνει κάτι τέτοιο.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Η λίστα με τα jails που θέλετε να ξεκινάνε κατά την εκκίνηση θα πρέπει να προστεθούν στο αρχείο <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;   # Set to NO to disable starting of any jails
jail_list=&#34;www&#34;     # Space separated list of names of jails</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το όνομα που έχει κάθε jail στη λίστα <code>jail_list</code> επιτρέπεται να περιέχει μόνο αλφαριθμητικούς χαρακτήρες.</p></div></td></tr></tbody></table></div></li><li><p>Για κάθε jail που υπάρχει στο <code>jail_list</code>, θα πρέπει να προστεθεί μια ομάδα από ρυθμίσεις στο <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, οι οποίες θα το περιγράφουν:</p><div class="literalblock programlisting"><div class=content><pre>jail_www_rootdir=&#34;/usr/jail/www&#34;     # jail&#39;s root directory
jail_www_hostname=&#34;www.example.org&#34;  # jail&#39;s hostname
jail_www_ip=&#34;192.168.0.10&#34;           # jail&#39;s IP address
jail_www_devfs_enable=&#34;YES&#34;          # mount devfs in the jail
jail_www_devfs_ruleset=&#34;www_ruleset&#34; # devfs ruleset to apply to jail</pre></div></div><div class=paragraph><p>Η προεπιλεγμένη εκκίνηση του jail μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, θα ξεκινήσει το script του jail <span class=filename>/etc/rc</span>, το οποίο υποθέτει ότι το jail είναι ένα ολοκληρωμένο εικονικό σύστημα. Για service jails, η προεπιλεγμένη εκκίνηση πρέπει να αλλάξει, ορίζοντας κατάλληλα την επιλογή <code>jail<em>jailname</em>exec_start</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Για πλήρη λίστα των διαθέσιμων επιλογών, δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div></td></tr></tbody></table></div></li></ol></div><div class=paragraph><p>Το script <span class=filename>/etc/rc.d/jail</span> μπορεί να χρησιμοποιηθεί για να ξεκινήσει ή να σταματήσει κάποιο jail χειροκίνητα. Πρέπει όμως να υπάρχει η αντίστοιχη καταχώρηση στο <span class=filename>rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/jail start www</span>
<span class=c># /etc/rc.d/jail stop www</span></code></pre></div></div><div class=paragraph><p>Για την ώρα δεν υπάρχει κάποιος απόλυτα σωστός τρόπος για να τερματίσετε κάποιο <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Αυτό συμβαίνει, διότι οι εντολές που χρησιμοποιούνται συνήθως για να τερματίσουν με ασφάλεια ένα σύστημα, δεν μπορούν να χρησιμοποιηθούν μέσα στο περιβάλλον ενός jail. Ο καλύτερος τρόπος για να τερματίσετε ένα jail είναι με την εκτέλεση της ακόλουθης εντολής μέσα από το ίδιο το jail ή με χρήση του βοηθητικού προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> έξω από αυτό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/rc.shutdown</span></code></pre></div></div><div class=paragraph><p>Περισσότερες πληροφορίες σχετικά με αυτή τη διαδικασία μπορείτε να βρείτε στη σελίδα βοηθείας του <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a></p></div></div><div class=sect2><h3 id=jails-tuning>36.5. Λεπτομερής Ρύθμιση και Διαχείριση<a class=anchor href=#jails-tuning></a></h3><div class=paragraph><p>Υπάρχουν αρκετές επιλογές που μπορούν να εφαρμοστούν σε ένα jail, καθώς και διάφοροι τρόποι για να συνδυαστεί ένα σύστημα FreeBSD με jails προκειμένου να παράγουν εφαρμογές υψηλότερου επιπέδου. Η ενότητα αυτή παρουσιάζει:</p></div><div class=ulist><ul><li><p>Μερικές από τις διαθέσιμες επιλογές για την ρύθμιση της συμπεριφοράς και των περιορισμών ασφαλείας που υλοποιούνται από την εγκατάσταση ενός jail.</p></li><li><p>Μερικές εφαρμογές υψηλού επιπέδου για τη διαχείριση jails, οι οποίες είναι διαθέσιμες μέσω της συλλογής των Ports του FreeBSD και μπορούν να χρησιμοποιηθούν στην υλοποίηση ολοκληρωμένων λύσεων με τη χρήση jails.</p></li></ul></div><div class=sect3><h4 id=jails-tuning-utilities>36.5.1. Εργαλεία Συστήματος του FreeBSD για τη Ρύθμιση Jails<a class=anchor href=#jails-tuning-utilities></a></h4><div class=paragraph><p>Λεπτομερής ρύθμιση ενός jail γίνεται κατά κύριο λόγο μέσω των μεταβλητών του <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Υπάρχει ένα ειδικό subtree του sysctl το οποίο αποτελεί τη βάση για την οργάνωση όλων των σχετικών επιλογών: πρόκειται για την ιεραρχία επιλογών πυρήνα <code>security.jail.*</code>. Παρακάτω θα βρείτε μια λίστα με τα κύρια sysctl που σχετίζονται με κάποιο jail καθώς και τις προεπιλεγμένες τιμές τους. Τα ονόματα μάλλον εξηγούν από μόνα τους την αντίστοιχη λειτουργία, αλλά για περισσότερες πληροφορίες μπορείτε να δείτε τις σελίδες βοήθειας των <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=ulist><ul><li><p><code>security.jail.set_hostname_allowed: 1</code></p></li><li><p><code>security.jail.socket_unixiproute_only: 1</code></p></li><li><p><code>security.jail.sysvipc_allowed: 0</code></p></li><li><p><code>security.jail.enforce_statfs: 2</code></p></li><li><p><code>security.jail.allow_raw_sockets: 0</code></p></li><li><p><code>security.jail.chflags_allowed: 0</code></p></li><li><p><code>security.jail.jailed: 0</code></p></li></ul></div><div class=paragraph><p>Οι μεταβλητές αυτές μπορούν να χρησιμοποιηθούν από τον διαχειριστή του <em>host system</em> προκειμένου να προσθέσει ή να αφαιρέσει περιορισμούς οι οποίοι υπάρχουν αρχικά στον χρήστη <code>root</code>. Υπάρχουν όμως και κάποιοι περιορισμοί οι οποίοι δεν μπορούν να αφαιρεθούν. Ο χρήστης <code>root</code> δεν επιτρέπεται να προσαρτά ή να απο-προσαρτά συστήματα αρχείων μέσα από ένα <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Ο <code>root</code> μέσα σε ένα jail δεν επιτρέπεται να φορτώσει ή να αποφορτώσει τους κανόνες (rulesets) του <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>, το firewall, και διάφορες άλλες εργασίες διαχείρισης οι οποίες χρειάζονται τροποποίηση των δεδομένων του πυρήνα, όπως για παράδειγμα ο ορισμός του <code>securelevel</code> του πυρήνα.</p></div><div class=paragraph><p>Το βασικό σύστημα του FreeBSD περιέχει τα βασικά εργαλεία για τη προβολή πληροφοριών σχετικά με τα ενεργά jails, και επίσης για την ανάθεση συγκεκριμένων εντολών διαχείρισης σε κάποιο jail. Οι εντολές <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> αποτελούν μέρος του βασικού συστήματος του FreeBSD, και μπορούν να χρησιμοποιηθούν για να τις παρακάτω απλές εργασίες:</p></div><div class=ulist><ul><li><p>Προβολή λίστας των ενεργών jails και τον αντίστοιχων χαρακτηριστικών τους - jail identifier (JID), διεύθυνση IP, hostname και path.</p></li><li><p>Προσκόλληση σε κάποιο ενεργό jail, από το host system, και εκτέλεση κάποιας εντολής μέσα στο jail ή εκτέλεση εργασιών διαχείρισης μέσα στο jail. Κάτι τέτοιο είναι ιδιαίτερα χρήσιμο όταν ο χρήστης <code>root</code> επιθυμεί να τερματίσει με ασφάλεια κάποιο jail. Μπορεί επίσης να χρησιμοποιηθεί η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> για την εκτέλεση κάποιου shell μέσα στο jail προκειμένου να εκτελεστούν εργασίες διαχείρισης, για παράδειγμα:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 1 tcsh</span></code></pre></div></div></li></ul></div></div><div class=sect3><h4 id=jails-tuning-admintools>36.5.2. Εργαλεία Διαχείρισης Υψηλού Επιπέδου στη Συλλογή Ports του FreeBSD<a class=anchor href=#jails-tuning-admintools></a></h4><div class=paragraph><p>Ανάμεσα στις διάφορες εφαρμογές τρίτων κατασκευαστών για τη διαχείριση των jails, ένα από τα ποιο ολοκληρωμένα και χρήσιμα πακέτα είναι το <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/jailutils/>sysutils/jailutils</a>. Αποτελεί ένα σύνολο μικρών εφαρμογών οι οποίες συνεισφέρουν στη διαχείριση του <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Για περισσότερες πληροφορίες, δείτε στον δικτυακό του τόπο.</p></div></div></div><div class=sect2><h3 id=jails-application>36.6. Εφαρμογή των Jails<a class=anchor href=#jails-application></a></h3><div class=sect3><h4 id=jails-service-jails>36.6.1. Service Jails<a class=anchor href=#jails-service-jails></a></h4><div class=paragraph><p>Η ενότητα αυτή είναι βασισμένη στην ιδέα που παρουσιάστηκε αρχικά από τον Simon L. B. Nielsen &lt;<a href=mailto:simon@FreeBSD.org>simon@FreeBSD.org</a>> στο <a href=http://simon.nitro.dk/service-jails.html>http://simon.nitro.dk/service-jails.html</a>, καθώς και σε ένα ανανεωμένο άρθρο του Ken Tom <a href=mailto:locals@gmail.com>locals@gmail.com</a>. Στην ενότητα αυτή θα σας δείξουμε πως να στήσετε ένα σύστημα FreeBSD το οποίο να διαθέτει ένα επιπλέον επίπεδο ασφάλειας, με τη χρήση του <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Υποθέτουμε ότι το σύστημα τρέχει τουλάχιστον RELENG_6_0 και ότι έχετε κατανοήσει όλες τις προηγούμενες πληροφορίες του κεφαλαίου.</p></div><div class=sect4><h5 id=jails-service-jails-design>36.6.1.1. Σχεδιασμός<a class=anchor href=#jails-service-jails-design></a></h5><div class=paragraph><p>Ένα από τα σημαντικότερα προβλήματα με τα jails είναι η διαχείριση της διαδικασίας αναβαθμίσεων. Αυτό τείνει να είναι πρόβλημα διότι το κάθε jail πρέπει να δημιουργηθεί από την αρχή σε κάθε αναβάθμιση. Συνήθως δεν είναι πρόβλημα αν έχετε ένα μόνο jail, μια και πρόκειται για σχετικά απλή διαδικασία, αλλά γίνεται κουραστική και χρονοβόρα αν έχετε πολλά jails.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Οι παρακάτω ρυθμίσεις προϋποθέτουν εμπειρία με το FreeBSD και τη χρήση των διάφορων χαρακτηριστικών του. Εάν τα παρακάτω βήματα σας φαίνονται πολύ περίπλοκα, είναι καλύτερα να ρίξετε μια ματιά σε κάτι ποιο απλό όπως το <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>, το οποίο παρέχει έναν ευκολότερο τρόπο διαχείρισης των jails του FreeBSD και δεν είναι τόσο εξειδικευμένο όσο οι παρακάτω ρυθμίσεις.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η ιδέα αυτή έχει παρουσιαστεί για να λύσει τέτοιου είδους προβλήματα, με την βοήθεια της κοινής χρήσης όσο το δυνατόν περισσότερων αρχείων μεταξύ των jails, με έναν ασφαλή όμως τρόπο - χρησιμοποιώντας προσαρτήσεις τύπου <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a> και μόνο για ανάγνωση (read only) έτσι ώστε η αναβάθμιση να είναι ευκολότερη, και η χρήση μεμονωμένων jails για κάθε υπηρεσία να καθίσταται επιθυμητή. Επιπλέον, παρέχει έναν απλό τρόπο για να προσθέσετε και να αφαιρέσετε jails όπως επίσης και να τα αναβαθμίσετε.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Παραδείγματα υπηρεσιών τέτοιου τύπου: ένας HTTP server, ένας DNS server, ένας SMTP server, κλπ.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Οι στόχοι των παρακάτω ρυθμίσεων είναι:</p></div><div class=ulist><ul><li><p>Δημιουργία απλών και κατανοητών jails. Αυτό σημαίνει ότι <em>δεν</em> θα τρέξουμε ένα πλήρες installworld σε κάθε jail.</p></li><li><p>Εύκολη προσθήκη και διαγραφή jails.</p></li><li><p>Εύκολη αναβάθμιση υπαρχόντων jails.</p></li><li><p>Δυνατότητα δημιουργίας προσαρμοσμένου τμήματος του FreeBSD.</p></li><li><p>Όσο περισσότερη ασφάλεια είναι δυνατόν, με ελαχιστοποίηση της πιθανότητας κακόβουλης χρήσης.</p></li><li><p>Εξοικονόμηση χώρου και inodes.</p></li></ul></div><div class=paragraph><p>Όπως έχουμε ήδη πει, ο σχεδιασμός αυτός εξαρτάται ιδιαίτερα από την ύπαρξη ενός αρχικού template στο οποίο δεν επιτρέπεται η εγγραφή δεδομένων (γνωστό ως nullfs) και το οποίο πρέπει να έχει προσαρτηθεί σε κάθε jail, όπως επίσης και στην ύπαρξη για κάθε jail μιας συσκευής που να επιτρέπει τόσο την ανάγνωση όσο και την εγγραφή. Μια τέτοια συσκευή μπορεί να είναι κάποιος ξεχωριστός φυσικός δίσκος, μια κατάτμηση, ή κάποια συσκευή vnode <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>. Στο παρακάτω παράδειγμα, θα χρησιμοποιήσουμε προσαρτήσεις τύπου nullfs στις οποίες θα επιτρέπεται εγγραφή και ανάγνωση.</p></div><div class=paragraph><p>Η δομή του συστήματος αρχείων περιγράφεται στην παρακάτω λίστα:</p></div><div class=ulist><ul><li><p>Κάθε jail θα προσαρτάται κάτω από τον κατάλογο <span class=filename>/home/j</span>.</p></li><li><p>Το <span class=filename>/home/j/mroot</span> είναι το template για το κάθε jail και η κατάτμηση μόνο ανάγνωσης για όλα τα jails.</p></li><li><p>Θα δημιουργηθεί ένας κενός κατάλογος για κάθε jail κάτω από τον κατάλογο <span class=filename>/home/j</span>.</p></li><li><p>Κάθε jail θα έχει έναν κατάλογο <span class=filename>/s</span>, ο οποίος θα είναι σύνδεσμος προς το εγγράψιμο μέρος του συστήματος.</p></li><li><p>Κάθε jail θα έχει το δικό εγγράψιμο μέρος το οποίο θα βασίζεται στο <span class=filename>/home/j/skel</span>.</p></li><li><p>Κάθε jailspace (το εγγράψιμο μέρος κάθε jail) θα πρέπει να δημιουργηθεί στον κατάλογο <span class=filename>/home/js</span>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όλα αυτά προϋποθέτουν ότι τα jails βρίσκονται κάτω από τον κατάλογο <span class=filename>/home</span>. Αυτό βέβαια μπορεί να αλλάξει σε οτιδήποτε εσείς θέλετε, αλλά θα επηρεάσει όλα τα παρακάτω παραδείγματα.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=jails-service-jails-template>36.6.1.2. Δημιουργώντας το Template<a class=anchor href=#jails-service-jails-template></a></h5><div class=paragraph><p>Η ενότητα αυτή θα περιγράψει τα βήματα που χρειάζονται προκειμένου να δημιουργήσετε το πρωταρχικό template το οποίο θα περιέχει το τμήμα των jails που είναι μόνο για ανάγνωση.</p></div><div class=paragraph><p>Είναι πάντοτε καλή ιδέα να αναβαθμίζετε το FreeBSD στη τελευταία έκδοση -RELEASE. Για το σκοπό αυτό, διαβάστε το αντίστοιχο <a href=./#makeworld>κεφάλαιο</a> στο Εγχειρίδιο. Στη περίπτωση που η αναβάθμιση δεν είναι εφικτή, θα χρειαστείτε buildworld για να μπορέσετε να συνεχίσετε. Επιπλέον θα χρειαστείτε το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a>. Θα χρησιμοποιήσουμε το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> για να κατεβάσουμε τη συλλογή των Ports. Για τους νεο-εισερχόμενους, συνίσταται η ανάγνωση του <a href=./#portsnap>κεφαλαίου για το Portsnap</a> στο Εγχειρίδιο του FreeBSD.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Αρχικά, δημιουργήστε μια δομή καταλόγων για το σύστημα αρχείων το οποίο θα είναι μόνο για ανάγνωση, και το οποίο θα περιέχει τα εκτελέσιμα (binaries) του FreeBSD για τα jails. Στη συνέχεια πηγαίνετε στον κατάλογο όπου βρίσκονται τα αρχεία πηγαίου κώδικα (source tree) του FreeBSD και εγκαταστήστε τα αντίστοιχα αρχεία στο jail template:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j /home/j/mroot</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot</span></code></pre></div></div></li><li><p>Επόμενο βήμα είναι να προετοιμάσετε τη συλλογή των Ports του FreeBSD για τα jails όπως επίσης και ένα FreeBSD source tree, το οποίο θα χρειαστεί για το mergemaster:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir usr/ports</span>
<span class=c># portsnap -p /home/j/mroot/usr/ports fetch extract</span>
<span class=c># cpdup /usr/src /home/j/mroot/usr/src</span></code></pre></div></div></li><li><p>Δημιουργήστε το σκελετό για το τμήμα του συστήματος όπου προορίζεται για ανάγνωση και εγγραφή:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/skel /home/j/skel/home /home/j/skel/usr-X11R6 /home/j/skel/distfiles</span>
<span class=c># mv etc /home/j/skel</span>
<span class=c># mv usr/local /home/j/skel/usr-local</span>
<span class=c># mv tmp /home/j/skel</span>
<span class=c># mv var /home/j/skel</span>
<span class=c># mv root /home/j/skel</span></code></pre></div></div></li><li><p>Χρησιμοποιήστε το mergemaster για να εγκαταστήσετε τα αρχεία ρυθμίσεων που λείπουν. Στη συνέχεια διαγράψτε όλους τους έξτρα καταλόγους που δημιουργεί το mergemaster:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -t /home/j/skel/var/tmp/temproot -D /home/j/skel -i</span>
<span class=c># cd /home/j/skel</span>
<span class=c># rm -R bin boot lib libexec mnt proc rescue sbin sys usr dev</span></code></pre></div></div></li><li><p>Τώρα, δημιουργήστε συνδέσμους από το σύστημα αρχείων στο οποίο επιτρέπεται η εγγραφή, προς το σύστημα αρχείων που είναι μόνο για ανάγνωση. Βεβαιωθείτε ότι οι σύνδεσμοι έχουν δημιουργηθεί στις σωστές θέσεις <span class=filename>s/</span>. Η ύπαρξη πραγματικών καταλόγων ή η δημιουργία καταλόγων σε λάθος θέσεις θα οδηγήσουν την εγκατάσταση σε αποτυχία.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir s</span>
<span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s ../../s/distfiles usr/ports/distfiles</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Σαν τελευταίο βήμα, δημιουργήστε ένα γενικό αρχείο <span class=filename>/home/j/skel/etc/make.conf</span> με τα παρακάτω δεδομένα:</p><div class="literalblock programlisting"><div class=content><pre>WRKDIRPREFIX?=  /s/portbuild</pre></div></div><div class=paragraph><p>Έχοντας ορίσει το <code>WRKDIRPREFIX</code> με αυτόν τον τρόπο, θα μπορείτε να μεταγλωττίσετε ports του FreeBSD μέσα σε κάθε jail. Θυμηθείτε ότι ο κατάλογος των ports είναι μέρος του συστήματος αρχείων που έχει προσαρτηθεί μόνο για ανάγνωση. Η προσαρμοσμένη διαδρομή για το <code>WRKDIRPREFIX</code> επιτρέπει την μεταγλώττιση των ports στο εγγράψιμο μέρος του κάθε jail.</p></div></li></ol></div></div><div class=sect4><h5 id=jails-service-jails-creating>36.6.1.3. Δημιουργώντας Jails<a class=anchor href=#jails-service-jails-creating></a></h5><div class=paragraph><p>Τώρα που έχουμε ένα ολοκληρωμένο FreeBSD jail template, μπορούμε να εγκαταστήσουμε και να ρυθμίσουμε τα jails στο <span class=filename>/etc/rc.conf</span>. Το παράδειγμα αυτό δείχνει τη δημιουργία τριών jails: "NS", "MAIL" και "WWW".</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Εισάγετε τις παρακάτω γραμμές στο αρχείο <span class=filename>/etc/fstab</span>, ώστε το μόνο για ανάγνωση template για τα jails και ο εγγράψιμος χώρος να είναι διαθέσιμα στα αντίστοιχα jails:</p><div class="literalblock programlisting"><div class=content><pre>/home/j/mroot   /home/j/ns     nullfs  ro  0   0
/home/j/mroot   /home/j/mail   nullfs  ro  0   0
/home/j/mroot   /home/j/www    nullfs  ro  0   0
/home/js/ns     /home/j/ns/s   nullfs  rw  0   0
/home/js/mail   /home/j/mail/s nullfs  rw  0   0
/home/js/www    /home/j/www/s  nullfs  rw  0   0</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι κατατμήσεις που είναι σημειωμένες με 0 pass number δεν ελέγχονται κατά την εκκίνηση από το <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, ενώ για τις κατατμήσεις με 0 dump number, η <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> δεν θα δημιουργεί αντίγραφα ασφαλείας. Προφανώς, δεν θέλουμε το fsck να ελέγχει τις προσαρτήσεις τύπου nullfs, ούτε και το dump να κρατά αντίγραφα από τα μόνο για ανάγνωση nullfs συστήματα αρχείων των jails. Αυτός είναι και ο λόγος που βάλαμε "0 0" στις δύο τελευταίες στήλες κάθε εγγραφής του <span class=filename>fstab</span>.</p></div></td></tr></tbody></table></div></li><li><p>Ρυθμίστε τα jails στο <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;
jail_set_hostname_allow=&#34;NO&#34;
jail_list=&#34;ns mail www&#34;
jail_ns_hostname=&#34;ns.example.org&#34;
jail_ns_ip=&#34;192.168.3.17&#34;
jail_ns_rootdir=&#34;/home/j/ns&#34;
jail_ns_devfs_enable=&#34;YES&#34;
jail_mail_hostname=&#34;mail.example.org&#34;
jail_mail_ip=&#34;192.168.3.18&#34;
jail_mail_rootdir=&#34;/home/j/mail&#34;
jail_mail_devfs_enable=&#34;YES&#34;
jail_www_hostname=&#34;www.example.org&#34;
jail_www_ip=&#34;62.123.43.14&#34;
jail_www_rootdir=&#34;/home/j/www&#34;
jail_www_devfs_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ο λόγος για τον οποίο θέτουμε τη μεταβλητή <code>jail<em>name</em>rootdir</code> να δείχνει στο <span class=filename>/usr/home</span> αντί για το <span class=filename>/home</span> είναι ότι η φυσική διαδρομή για τον κατάλογο <span class=filename>/home</span> σε μια τυπική εγκατάσταση του FreeBSD είναι το <span class=filename>/usr/home</span>. Η μεταβλητή <code>jail<em>name</em>rootdir</code> <em>δεν</em> δεν πρέπει να δείχνει προς διαδρομή που περιλαμβάνει συμβολικό δεσμό, διαφορετικά τα jails θα αρνηθούν να ξεκινήσουν. Χρησιμοποιήστε το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=realpath&amp;sektion=1&amp;format=html">realpath(1)</a> για να προσδιορίσετε την τιμή που θα πρέπει να λάβει αυτή η μεταβλητή. Δείτε το FreeBSD-SA-07:01.jail Security Advisory για περισσότερες πληροφορίες.</p></div></td></tr></tbody></table></div></li><li><p>Δημιουργήστε τα απαραίτητα σημεία προσαρτήσεων για το σύστημα αρχείων μόνο ανάγνωσης του κάθε jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/ns /home/j/mail /home/j/www</span></code></pre></div></div></li><li><p>Εγκαταστήστε το εγγράψιμο template μέσα στο κάθε jail. Προσέξτε εδώ τη χρήση του <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a>, το οποίο επιβεβαιώνει ότι δημιουργείται το σωστό αντίγραφο του κάθε καταλόγου:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/js</span>
<span class=c># cpdup /home/j/skel /home/js/ns</span>
<span class=c># cpdup /home/j/skel /home/js/mail</span>
<span class=c># cpdup /home/j/skel /home/js/www</span></code></pre></div></div></li><li><p>Σε αυτή τη φάση, τα jails έχουν δημιουργηθεί και είναι έτοιμα να ξεκινήσουν. Προσαρτήστε το σωστό σύστημα αρχείων για το κάθε jail, και στη συνέχεια εκκινήστε τα, χρησιμοποιώντας το script <span class=filename>/etc/rc.d/jail</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># /etc/rc.d/jail start</span></code></pre></div></div></li></ol></div><div class=paragraph><p>Τα jails θα πρέπει τώρα να εκτελούνται κανονικά. Γα να ελέγξετε αν έχουν ξεκινήσει σωστά, χρησιμοποιείστε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a>. Θα πρέπει να δείτε κάτι αντίστοιχο με το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.3.17    ns.example.org                /home/j/ns
     2  192.168.3.18    mail.example.org              /home/j/mail
     1  62.123.43.14    www.example.org               /home/j/www</code></pre></div></div><div class=paragraph><p>Σε αυτό το σημείο, θα πρέπει να μπορείτε να συνδεθείτε σε κάθε jail, να προσθέσετε νέους χρήστες ή να ρυθμίσετε υπηρεσίες. Η στήλη <code>JID</code> δηλώνει το χαρακτηριστικό αναγνωριστικό αριθμό κάθε ενεργού jail. Χρησιμοποιήστε την παρακάτω εντολή προκειμένου να εκτελέσετε εργασίες διαχείρισης του jail, με <code>JID</code> 3:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 3 tcsh</span></code></pre></div></div></div><div class=sect4><h5 id=jails-service-jails-upgrading>36.6.1.4. Αναβάθμιση<a class=anchor href=#jails-service-jails-upgrading></a></h5><div class=paragraph><p>Κάποια στιγμή, θα χρειαστεί να αναβαθμίσετε το σύστημά σας σε μια νέα έκδοση του FreeBSD, είτε για λόγους ασφάλειας, είτε γιατί υπάρχουν νέες δυνατότητες στην νεώτερη έκδοση οι οποίες είναι χρήσιμες για τα jails που ήδη έχετε. Ο τρόπος που χρησιμοποιήσαμε για την δημιουργία των jails, επιτρέπει την εύκολη αναβάθμιση τους. Επιπλέον, ελαχιστοποιεί το χρόνο διακοπής της λειτουργίας τους, μια και θα χρειαστεί να τα σταματήσετε μόνο κατά τα λίγα τελευταία λεπτά. Επίσης, παρέχει έναν τρόπο να επιστρέψετε σε παλαιότερες εκδόσεις εάν προκύψουν οποιαδήποτε σφάλματα.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Το πρώτο βήμα είναι να αναβαθμίσετε το σύστημα στο οποίο φιλοξενούνται τα jails, με το συνήθη τρόπο. Στη συνέχεια δημιουργήστε ένα νέο προσωρινό template κατάλογο, μόνο για ανάγνωση, στο <span class=filename>/home/j/mroot2</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/mroot2</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot2</span>
<span class=c># cd /home/j/mroot2</span>
<span class=c># cpdup /usr/src usr/src</span>
<span class=c># mkdir s</span></code></pre></div></div><div class=paragraph><p>Το <code>installworld</code> δημιουργεί μερικούς καταλόγους που δε χρειάζονται, και θα πρέπει να διαγραφούν:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags -R 0 var</span>
<span class=c># rm -R etc var root usr/local tmp</span></code></pre></div></div></li><li><p>Δημιουργήστε ξανά τους συνδέσμους για το σύστημα αρχείων ανάγνωσης - εγγραφής:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Τώρα είναι η σωστή στιγμή για να σταματήσετε τα jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/jail stop</span></code></pre></div></div></li><li><p>Αποπροσαρτήστε τα αρχικά συστήματα αρχείων:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /home/j/ns/s</span>
<span class=c># umount /home/j/ns</span>
<span class=c># umount /home/j/mail/s</span>
<span class=c># umount /home/j/mail</span>
<span class=c># umount /home/j/www/s</span>
<span class=c># umount /home/j/www</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Τα συστήματα αρχείων ανάγνωσης - εγγραφής είναι προσαρτημένα στο σύστημα αρχείων μόνο ανάγνωσης (<span class=filename>/s</span>) και πρέπει να είναι τα πρώτα που θα αποπροσαρτηθούν.</p></div></td></tr></tbody></table></div></li><li><p>Μετακινήστε τον παλιό μόνο για ανάγνωση κατάλογο, και αντικαταστήστε τον με τον καινούργιο. Ο παλιός θα παραμείνει ως αντίγραφο ασφαλείας του παλιού συστήματος σε περίπτωση προβλήματος. Ο τρόπος ονομασίας που ακολουθήσαμε εδώ αντιστοιχεί στη χρονική στιγμή δημιουργίας του νέου συστήματος αρχείων μόνο ανάγνωσης. Μετακινήστε την αρχική συλλογή των Ports του FreeBSD στο νέο σύστημα, αρχείων προκειμένου να εξοικονομήσετε χώρο και inodes:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j</span>
<span class=c># mv mroot mroot.20060601</span>
<span class=c># mv mroot2 mroot</span>
<span class=c># mv mroot.20060601/usr/ports mroot/usr</span></code></pre></div></div></li><li><p>Σε αυτό το σημείο το μόνο για ανάγνωση template είναι έτοιμο, οπότε το μόνο που απομένει είναι να προσαρτήσετε ξανά τα συστήματα αρχείων και να ξεκινήσετε τα jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># /etc/rc.d/jail start</span></code></pre></div></div></li></ol></div><div class=paragraph><p>Χρησιμοποιείτε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> για να ελέγξετε εάν τα jails ξεκίνησαν σωστά. Μην ξεχάσετε να εκτελέσετε το mergemaster για το κάθε jail. Θα χρειαστεί να αναβαθμίσετε τόσο τα αρχεία ρυθμίσεων, όσο και τα rc.d scripts.</p></div></div></div></div></div></div><div class=sect1><h2 id=mac>Chapter 37. Υποχρεωτικός Έλεγχος Πρόσβασης<a class=anchor href=#mac></a></h2><div class=sectionbody><div class=sect2><h3 id=mac-synopsis>37.1. Σύνοψη<a class=anchor href=#mac-synopsis></a></h3><div class=paragraph><p>Το FreeBSD 5.X εισήγαγε νέες επεκτάσεις ασφαλείας από το TrustedBSD project, που βασίζονται στο προσχέδιο POSIX®.1e. Δύο από τους πιο σημαντικούς νέους μηχανισμούς ασφαλείας, είναι οι Λίστες Ελέγχου Πρόσβασης (Access Control Lists, ACLs) στο σύστημα αρχείων και ο Υποχρεωτικός Έλεγχος Πρόσβασης (Mandatory Access Control, MAC). Ο Υποχρεωτικός Έλεγχος Πρόσβασης δίνει την δυνατότητας φόρτωσης αρθρωμάτων (modules) ελέγχου τα οποία υλοποιούν νέες πολιτικές ασφαλείας. Μερικά παρέχουν προστασία σε ένα στενό υποσύνολο του συστήματος, ενδυναμώνοντας την ασφάλεια μιας συγκεκριμένης υπηρεσίας. Άλλα παρέχουν συνοπτική ασφάλεια προς όλες τις υπηρεσίες και το σύστημα. Ο έλεγχος ονομάζεται υποχρεωτικός από το γεγονός ότι η επιβολή γίνεται από τους διαχειριστές και το σύστημα, και δεν αφήνεται στη διακριτική ευχέρεια των χρηστών όπως γίνεται με το διακριτικό έλεγχο πρόσβασης (Discretionary Access Control, DAC, τις τυποποιημένες άδειες αρχείων και IPC του System V στο FreeBSD).</p></div><div class=paragraph><p>Το κεφάλαιο αυτό εστιάζει στο πλαίσιο του Υποχρεωτικού Ελέγχου Πρόσβασης (MAC Framework), και σε ένα σύνολο πρόσθετων αρθρωμάτων για πολιτικές ασφάλειας, που ενεργοποιούν διάφορους μηχανισμούς ασφάλειας.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Τι MAC αρθρώματα πολιτικών ασφαλείας περιλαμβάνονται αυτή τη στιγμή στο FreeBSD και τους σχετικούς μηχανισμούς τους.</p></li><li><p>Τι υλοποιούν τα MAC αρθρώματα πολιτικών ασφαλείας καθώς και τη διαφορά μεταξύ μια χαρακτηρισμένης (labeled) και μη χαρακτηρισμένης (non-labeled) πολιτικής.</p></li><li><p>Πως να ρυθμίσετε αποδοτικά ένα σύστημα για χρήση του πλαισίου λειτουργιών MAC.</p></li><li><p>Πως να ρυθμίσετε τα διαφορετικά αρθρώματα πολιτικών ασφάλειας τα οποία περιλαμβάνονται στο πλαίσιο λειτουργιών MAC .</p></li><li><p>Πως να υλοποιήσετε ένα πιο ασφαλές περιβάλλον, χρησιμοποιώντας το πλαίσιο λειτουργιών MAC και τα παραδείγματα που φαίνονται.</p></li><li><p>Πως να ελέγξετε τη ρύθμιση του MAC για να εξασφαλίσετε ότι έχει γίνει σωστή υλοποίηση του πλαισίου λειτουργιών.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε τις βασικές έννοιες του UNIX® και του FreeBSD. (<a href=./#basics>Βασικές Έννοιες στο UNIX®</a>).</p></li><li><p>Να είστε εξοικειωμένος με τις βασικές έννοιες της ρύθμισης και μεταγλώττισης του πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li><li><p>Να έχετε κάποια εξοικείωση με την ασφάλεια και πως αυτή σχετίζεται με το FreeBSD (<a href=./#security>Ασφάλεια</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Η κακή χρήση των πληροφοριών που παρέχονται εδώ μπορεί να προκαλέσει απώλεια πρόσβασης στο σύστημα, εκνευρισμό στους χρήστες ή αδυναμία πρόσβασης στις υπηρεσίες που παρέχονται από το Χ11. Ακόμα πιο σημαντικό είναι ότι δεν πρέπει να βασίζεστε στο MAC για την πλήρη ασφάλιση ενός συστήματος. Το πλαίσιο λειτουργιών MAC παρέχει απλώς επιπλέον υποστήριξη σε μια υπάρχουσα πολιτική ασφαλείας. Χωρίς σωστές πρακτικές και τακτικούς ελέγχους ασφαλείας, το σύστημα δεν θα είναι ποτέ απόλυτα ασφαλές.</p></div><div class=paragraph><p>Θα πρέπει επίσης να σημειωθεί ότι τα παραδείγματα που περιέχονται σε αυτό το κεφάλαιο είναι ακριβώς και μόνο αυτό: παραδείγματα. Δεν συνίσταται να χρησιμοποιηθούν ακριβώς αυτές οι ρυθμίσεις σε ένα σύστημα παραγωγής. Η υλοποίηση των διάφορων αρθρωμάτων πολιτικών ασφαλείας απαιτεί αρκετή σκέψη και δοκιμές. Αν δεν κατανοείτε την ακριβή λειτουργία τους, μπορεί να βρεθείτε στη θέση να ελέγχετε ξανά ολόκληρο το σύστημα και να αλλάζετε ρυθμίσεις σε πολλά αρχεία και καταλόγους.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_τι_δεν_περιλαμβάνεται_στο_κεφάλαιο>37.1.1. Τι δεν Περιλαμβάνεται στο Κεφάλαιο<a class=anchor href=#_τι_δεν_περιλαμβάνεται_στο_κεφάλαιο></a></h4><div class=paragraph><p>Το κεφάλαιο αυτό καλύπτει μια ευρεία περιοχή προβλημάτων ασφαλείας που σχετίζονται με το πλαίσιο λειτουργιών MAC. Δεν θα καλυφθεί η ανάπτυξη νέων αρθρωμάτων πολιτικών ασφαλείας MAC. Ένας αριθμός από αρθρώματα που περιλαμβάνονται στο πλαίσιο MAC, έχουν ειδικά χαρακτηριστικά που παρέχονται τόσο για δοκιμές όσο και για ανάπτυξη νέων αρθρωμάτων. Αυτά περιλαμβάνουν τα <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_test&amp;sektion=4&amp;format=html">mac_test(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_stub&amp;sektion=4&amp;format=html">mac_stub(4)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_none&amp;sektion=4&amp;format=html">mac_none(4)</a>. Για περισσότερες πληροφορίες σχετικά με αυτά τα αρθρώματα και τους διάφορους μηχανισμούς που παρέχουν, παρακαλούμε ανατρέξτε στις αντίστοιχες σελίδες manual.</p></div></div></div><div class=sect2><h3 id=mac-inline-glossary>37.2. Key Terms in this Chapter<a class=anchor href=#mac-inline-glossary></a></h3><div class=paragraph><p>Before reading this chapter, a few key terms must be explained. This will hopefully clear up any confusion that may occur and avoid the abrupt introduction of new terms and information.</p></div><div class=ulist><ul><li><p><em>compartment</em>: A compartment is a set of programs and data to be partitioned or separated, where users are given explicit access to specific components of a system. Also, a compartment represents a grouping, such as a work group, department, project, or topic. Using compartments, it is possible to implement a need-to-know security policy.</p></li><li><p><em>high water mark</em>: A high water mark policy is one which permits the raising of security levels for the purpose of accessing higher level information. In most cases, the original level is restored after the process is complete. Currently, the FreeBSD MAC framework does not have a policy for this, but the definition is included for completeness.</p></li><li><p><em>integrity</em>: Integrity, as a key concept, is the level of trust which can be placed on data. As the integrity of the data is elevated, so does the ability to trust that data.</p></li><li><p><em>label</em>: A label is a security attribute which can be applied to files, directories, or other items in the system. It could be considered a confidentiality stamp; when a label is placed on a file it describes the security properties for that specific file and will only permit access by files, users, resources, etc. with a similar security setting. The meaning and interpretation of label values depends on the policy configuration: while some policies might treat a label as representing the integrity or secrecy of an object, other policies might use labels to hold rules for access.</p></li><li><p><em>level</em>: The increased or decreased setting of a security attribute. As the level increases, its security is considered to elevate as well.</p></li><li><p><em>low water mark</em>: A low water mark policy is one which permits lowering of the security levels for the purpose of accessing information which is less secure. In most cases, the original security level of the user is restored after the process is complete. The only security policy module in FreeBSD to use this is <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a>.</p></li><li><p><em>multilabel</em>: The <code>multilabel</code> property is a file system option which can be set in single user mode using the <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> utility, during the boot operation using the <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> file, or during the creation of a new file system. This option will permit an administrator to apply different MAC labels on different objects. This option only applies to security policy modules which support labeling.</p></li><li><p><em>object</em>: An object or system object is an entity through which information flows under the direction of a <em>subject</em>. This includes directories, files, fields, screens, keyboards, memory, magnetic storage, printers or any other data storage/moving device. Basically, an object is a data container or a system resource; access to an <em>object</em> effectively means access to the data.</p></li><li><p><em>policy</em>: A collection of rules which defines how objectives are to be achieved. A <em>policy</em> usually documents how certain items are to be handled. This chapter will consider the term <em>policy</em> in this context as a <em>security policy</em>; i.e. a collection of rules which will control the flow of data and information and define whom will have access to that data and information.</p></li><li><p><em>sensitivity</em>: Usually used when discussing MLS. A sensitivity level is a term used to describe how important or secret the data should be. As the sensitivity level increases, so does the importance of the secrecy, or confidentiality of the data.</p></li><li><p><em>single label</em>: A single label is when the entire file system uses one label to enforce access control over the flow of data. When a file system has this set, which is any time when the <code>multilabel</code> option is not set, all files will conform to the same label setting.</p></li><li><p><em>subject</em>: a subject is any active entity that causes information to flow between <em>objects</em>; e.g. a user, user processor, system process, etc. On FreeBSD, this is almost always a thread acting in a process on behalf of a user.</p></li></ul></div></div><div class=sect2><h3 id=mac-initial>37.3. Explanation of MAC<a class=anchor href=#mac-initial></a></h3><div class=paragraph><p>With all of these new terms in mind, consider how the MAC framework augments the security of the system as a whole. The various security policy modules provided by the MAC framework could be used to protect the network and file systems, block users from accessing certain ports and sockets, and more. Perhaps the best use of the policy modules is to blend them together, by loading several security policy modules at a time for a multi-layered security environment. In a multi-layered security environment, multiple policy modules are in effect to keep security in check. This is different to a hardening policy, which typically hardens elements of a system that is used only for specific purposes. The only downside is administrative overhead in cases of multiple file system labels, setting network access control user by user, etc.</p></div><div class=paragraph><p>These downsides are minimal when compared to the lasting effect of the framework; for instance, the ability to pick and choose which policies are required for a specific configuration keeps performance overhead down. The reduction of support for unneeded policies can increase the overall performance of the system as well as offer flexibility of choice. A good implementation would consider the overall security requirements and effectively implement the various security policy modules offered by the framework.</p></div><div class=paragraph><p>Thus a system utilizing MAC features should at least guarantee that a user will not be permitted to change security attributes at will; all user utilities, programs and scripts must work within the constraints of the access rules provided by the selected security policy modules; and that total control of the MAC access rules are in the hands of the system administrator.</p></div><div class=paragraph><p>It is the sole duty of the system administrator to carefully select the correct security policy modules. Some environments may need to limit access control over the network; in these cases, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> and even <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> policy modules might make good starting points. In other cases, strict confidentiality of file system objects might be required. Policy modules such as <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> exist for this purpose.</p></div><div class=paragraph><p>Policy decisions could be made based on network configuration. Perhaps only certain users should be permitted access to facilities provided by <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> to access the network or the Internet. The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> would be the policy module of choice for these situations. But what should be done in the case of file systems? Should all access to certain directories be severed from other groups or specific users? Or should we limit user or utility access to specific files by setting certain objects as classified?</p></div><div class=paragraph><p>In the file system case, access to objects might be considered confidential to some users, but not to others. For an example, a large development team might be broken off into smaller groups of individuals. Developers in project A might not be permitted to access objects written by developers in project B. Yet they might need to access objects created by developers in project C; that is quite a situation indeed. Using the different security policy modules provided by the MAC framework; users could be divided into these groups and then given access to the appropriate areas without fear of information leakage.</p></div><div class=paragraph><p>Thus, each security policy module has a unique way of dealing with the overall security of a system. Module selection should be based on a well thought out security policy. In many cases, the overall policy may need to be revised and reimplemented on the system. Understanding the different security policy modules offered by the MAC framework will help administrators choose the best policies for their situations.</p></div><div class=paragraph><p>The default FreeBSD kernel does not include the option for the MAC framework; thus the following kernel option must be added before trying any of the examples or information in this chapter:</p></div><div class="literalblock programlisting"><div class=content><pre>options	MAC</pre></div></div><div class=paragraph><p>And the kernel will require a rebuild and a reinstall.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>While the various manual pages for MAC policy modules state that they may be built into the kernel, it is possible to lock the system out of the network and more. Implementing MAC is much like implementing a firewall, care must be taken to prevent being completely locked out of the system. The ability to revert back to a previous configuration should be considered while the implementation of MAC remotely should be done with extreme caution.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-understandlabel>37.4. Understanding MAC Labels<a class=anchor href=#mac-understandlabel></a></h3><div class=paragraph><p>A MAC label is a security attribute which may be applied to subjects and objects throughout the system.</p></div><div class=paragraph><p>When setting a label, the user must be able to comprehend what it is, exactly, that is being done. The attributes available on an object depend on the policy module loaded, and that policy modules interpret their attributes in different ways. If improperly configured due to lack of comprehension, or the inability to understand the implications, the result will be the unexpected and perhaps, undesired, behavior of the system.</p></div><div class=paragraph><p>The security label on an object is used as a part of a security access control decision by a policy. With some policies, the label by itself contains all information necessary to make a decision; in other models, the labels may be processed as part of a larger rule set, etc.</p></div><div class=paragraph><p>For instance, setting the label of <code>biba/low</code> on a file will represent a label maintained by the Biba security policy module, with a value of "low".</p></div><div class=paragraph><p>A few policy modules which support the labeling feature in FreeBSD offer three specific predefined labels. These are the low, high, and equal labels. Although they enforce access control in a different manner with each policy module, you can be sure that the low label will be the lowest setting, the equal label will set the subject or object to be disabled or unaffected, and the high label will enforce the highest setting available in the Biba and MLS policy modules.</p></div><div class=paragraph><p>Within single label file system environments, only one label may be used on objects. This will enforce one set of access permissions across the entire system and in many environments may be all that is required. There are a few cases where multiple labels may be set on objects or subjects in the file system. For those cases, the <code>multilabel</code> option may be passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>.</p></div><div class=paragraph><p>In the case of Biba and MLS, a numeric label may be set to indicate the precise level of hierarchical control. This numeric level is used to partition or sort information into different groups of say, classification only permitting access to that group or a higher group level.</p></div><div class=paragraph><p>In most cases the administrator will only be setting up a single label to use throughout the file system.</p></div><div class=paragraph><p><em>Hey wait, this is similar to DAC! I thought MAC gave control strictly to the administrator.</em> That statement still holds true, to some extent as <code>root</code> is the one in control and who configures the policies so that users are placed in the appropriate categories/access levels. Alas, many policy modules can restrict the <code>root</code> user as well. Basic control over objects will then be released to the group, but <code>root</code> may revoke or modify the settings at any time. This is the hierarchal/clearance model covered by policies such as Biba and MLS.</p></div><div class=sect3><h4 id=_label_configuration>37.4.1. Label Configuration<a class=anchor href=#_label_configuration></a></h4><div class=paragraph><p>Virtually all aspects of label policy module configuration will be performed using the base system utilities. These commands provide a simple interface for object or subject configuration or the manipulation and verification of the configuration.</p></div><div class=paragraph><p>All configuration may be done by use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> utilities. The <code>setfmac</code> command is used to set MAC labels on system objects while the <code>setpmac</code> command is used to set the labels on system subjects. Observe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span></code></pre></div></div><div class=paragraph><p>If no errors occurred with the command above, a prompt will be returned. The only time these commands are not quiescent is when an error occurred; similarly to the <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a> commands. In some cases this error may be a <code>Permission denied</code> and is usually obtained when the label is being set or modified on an object which is restricted. The system administrator may use the following commands to overcome this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span>
Permission denied
<span class=c># setpmac biba/low setfmac biba/high test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/high</code></pre></div></div><div class=paragraph><p>As we see above, <code>setpmac</code> can be used to override the policy module’s settings by assigning a different label to the invoked process. The <code>getpmac</code> utility is usually used with currently running processes, such as sendmail: although it takes a process ID in place of a command the logic is extremely similar. If users attempt to manipulate a file not in their access, subject to the rules of the loaded policy modules, the <code>Operation not permitted</code> error will be displayed by the <code>mac_set_link</code> function.</p></div><div class=sect4><h5 id=_common_label_types>37.4.1.1. Common Label Types<a class=anchor href=#_common_label_types></a></h5><div class=paragraph><p>For the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> policy modules, the ability to assign simple labels is provided. These take the form of high, equal and low, what follows is a brief description of what these labels provide:</p></div><div class=ulist><ul><li><p>The <code>low</code> label is considered the lowest label setting an object or subject may have. Setting this on objects or subjects will block their access to objects or subjects marked high.</p></li><li><p>The <code>equal</code> label should only be placed on objects considered to be exempt from the policy.</p></li><li><p>The <code>high</code> label grants an object or subject the highest possible setting.</p></li></ul></div><div class=paragraph><p>With respect to each policy module, each of those settings will instate a different information flow directive. Reading the proper manual pages will further explain the traits of these generic label configurations.</p></div><div class=sect5><h6 id=_advanced_label_configuration>37.4.1.1.1. Advanced Label Configuration<a class=anchor href=#_advanced_label_configuration></a></h6><div class=paragraph><p>Numeric grade labels are used for <code>comparison:compartment+compartment</code>; thus the following:</p></div><div class="literalblock programlisting"><div class=content><pre>biba/10:2+3+6(5:2+3-20:2+3+4+5+6)</pre></div></div><div class=paragraph><p>May be interpreted as:</p></div><div class=paragraph><p>"Biba Policy Label"/"Grade 10" :"Compartments 2, 3 and 6": ("grade 5 …​")</p></div><div class=paragraph><p>In this example, the first grade would be considered the "effective grade" with "effective compartments", the second grade is the low grade and the last one is the high grade. In most configurations these settings will not be used; indeed, they offered for more advanced configurations.</p></div><div class=paragraph><p>When applied to system objects, they will only have a current grade/compartments as opposed to system subjects as they reflect the range of available rights in the system, and network interfaces, where they are used for access control.</p></div><div class=paragraph><p>The grade and compartments in a subject and object pair are used to construct a relationship referred to as "dominance", in which a subject dominates an object, the object dominates the subject, neither dominates the other, or both dominate each other. The "both dominate" case occurs when the two labels are equal. Due to the information flow nature of Biba, you have rights to a set of compartments, "need to know", that might correspond to projects, but objects also have a set of compartments. Users may have to subset their rights using <code>su</code> or <code>setpmac</code> in order to access objects in a compartment from which they are not restricted.</p></div></div></div><div class=sect4><h5 id=_users_and_label_settings>37.4.1.2. Users and Label Settings<a class=anchor href=#_users_and_label_settings></a></h5><div class=paragraph><p>Users themselves are required to have labels so that their files and processes may properly interact with the security policy defined on the system. This is configured through the <span class=filename>login.conf</span> file by use of login classes. Every policy module that uses labels will implement the user class setting.</p></div><div class=paragraph><p>An example entry containing every policy module setting is displayed below:</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/shared/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:</pre></div></div><div class=paragraph><p>The <code>label</code> option is used to set the user class default label which will be enforced by MAC. Users will never be permitted to modify this value, thus it can be considered not optional in the user case. In a real configuration, however, the administrator will never wish to enable every policy module. It is recommended that the rest of this chapter be reviewed before any of this configuration is implemented.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Users may change their label after the initial login; however, this change is subject constraints of the policy. The example above tells the Biba policy that a process’s minimum integrity is 5, its maximum is 15, but the default effective label is 10. The process will run at 10 until it chooses to change label, perhaps due to the user using the setpmac command, which will be constrained by Biba to the range set at login.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In all cases, after a change to <span class=filename>login.conf</span>, the login class capability database must be rebuilt using <code>cap_mkdb</code> and this will be reflected throughout every forthcoming example or discussion.</p></div><div class=paragraph><p>It is useful to note that many sites may have a particularly large number of users requiring several different user classes. In depth planning is required as this may get extremely difficult to manage.</p></div><div class=paragraph><p>Future versions of FreeBSD will include a new way to deal with mapping users to labels; however, this will not be available until some time after FreeBSD 5.3.</p></div></div><div class=sect4><h5 id=_network_interfaces_and_label_settings>37.4.1.3. Network Interfaces and Label Settings<a class=anchor href=#_network_interfaces_and_label_settings></a></h5><div class=paragraph><p>Labels may also be set on network interfaces to help control the flow of data across the network. In all cases they function in the same way the policies function with respect to objects. Users at high settings in <code>biba</code>, for example, will not be permitted to access network interfaces with a label of low.</p></div><div class=paragraph><p>The <code>maclabel</code> may be passed to <code>ifconfig</code> when setting the MAC label on network interfaces. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0 maclabel biba/equal</span></code></pre></div></div><div class=paragraph><p>will set the MAC label of <code>biba/equal</code> on the <a href="https://man.freebsd.org/cgi/man.cgi?query=bge&amp;sektion=4&amp;format=html">bge(4)</a> interface. When using a setting similar to <code>biba/high(low-high)</code> the entire label should be quoted; otherwise an error will be returned.</p></div><div class=paragraph><p>Each policy module which supports labeling has a tunable which may be used to disable the MAC label on network interfaces. Setting the label to <code>equal</code> will have a similar effect. Review the output from <code>sysctl</code>, the policy manual pages, or even the information found later in this chapter for those tunables.</p></div></div></div><div class=sect3><h4 id=_singlelabel_or_multilabel>37.4.2. Singlelabel or Multilabel?<a class=anchor href=#_singlelabel_or_multilabel></a></h4><div class=paragraph><p>By default the system will use the <code>singlelabel</code> option. But what does this mean to the administrator? There are several differences which, in their own right, offer pros and cons to the flexibility in the systems security model.</p></div><div class=paragraph><p>The <code>singlelabel</code> only permits for one label, for instance <code>biba/high</code> to be used for each subject or object. It provides for lower administration overhead but decreases the flexibility of policies which support labeling. Many administrators may want to use the <code>multilabel</code> option in their security policy.</p></div><div class=paragraph><p>The <code>multilabel</code> option will permit each subject or object to have its own independent MAC label in place of the standard <code>singlelabel</code> option which will allow only one label throughout the partition. The <code>multilabel</code> and <code>single</code> label options are only required for the policies which implement the labeling feature, including the Biba, Lomac, MLS and SEBSD policies.</p></div><div class=paragraph><p>In many cases, the <code>multilabel</code> may not need to be set at all. Consider the following situation and security model:</p></div><div class=ulist><ul><li><p>FreeBSD web-server using the MAC framework and a mix of the various policies.</p></li><li><p>This machine only requires one label, <code>biba/high</code>, for everything in the system. Here the file system would not require the <code>multilabel</code> option as a single label will always be in effect.</p></li><li><p>But, this machine will be a web server and should have the web server run at <code>biba/low</code> to prevent write up capabilities. The Biba policy and how it works will be discussed later, so if the previous comment was difficult to interpret just continue reading and return. The server could use a separate partition set at <code>biba/low</code> for most if not all of its runtime state. Much is lacking from this example, for instance the restrictions on data, configuration and user settings; however, this is just a quick example to prove the aforementioned point.</p></li></ul></div><div class=paragraph><p>If any of the non-labeling policies are to be used, then the <code>multilabel</code> option would never be required. These include the <code>seeotheruids</code>, <code>portacl</code> and <code>partition</code> policies.</p></div><div class=paragraph><p>It should also be noted that using <code>multilabel</code> with a partition and establishing a security model based on <code>multilabel</code> functionality could open the doors for higher administrative overhead as everything in the file system would have a label. This includes directories, files, and even device nodes.</p></div><div class=paragraph><p>The following command will set <code>multilabel</code> on the file systems to have multiple labels. This may only be done in single user mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -l enable /</span></code></pre></div></div><div class=paragraph><p>This is not a requirement for the swap file system.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some users have experienced problems with setting the <code>multilabel</code> flag on the root partition. If this is the case, please review the <a href=#mac-troubleshoot>Troubleshooting the MAC Framework</a> of this chapter.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-planning>37.5. Planning the Security Configuration<a class=anchor href=#mac-planning></a></h3><div class=paragraph><p>Whenever a new technology is implemented, a planning phase is always a good idea. During the planning stages, an administrator should in general look at the "big picture", trying to keep in view at least the following:</p></div><div class=ulist><ul><li><p>The implementation requirements;</p></li><li><p>The implementation goals;</p></li></ul></div><div class=paragraph><p>For MAC installations, these include:</p></div><div class=ulist><ul><li><p>How to classify information and resources available on the target systems.</p></li><li><p>What sorts of information or resources to restrict access to along with the type of restrictions that should be applied.</p></li><li><p>Which MAC module or modules will be required to achieve this goal.</p></li></ul></div><div class=paragraph><p>It is always possible to reconfigure and change the system resources and security settings, it is quite often very inconvenient to search through the system and fix existing files and user accounts. Planning helps to ensure a trouble-free and efficient trusted system implementation. A trial run of the trusted system, including the configuration, is often vital and definitely beneficial <em>before</em> a MAC implementation is used on production systems. The idea of just letting loose on a system with MAC is like setting up for failure.</p></div><div class=paragraph><p>Different environments may have explicit needs and requirements. Establishing an in depth and complete security profile will decrease the need of changes once the system goes live. As such, the future sections will cover the different modules available to administrators; describe their use and configuration; and in some cases provide insight on what situations they would be most suitable for. For instance, a web server might roll out the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> policies. In other cases, a machine with very few local users, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_partition&amp;sektion=4&amp;format=html">mac_partition(4)</a> might be a good choice.</p></div></div><div class=sect2><h3 id=mac-modules>37.6. Module Configuration<a class=anchor href=#mac-modules></a></h3><div class=paragraph><p>Every module included with the MAC framework may be either compiled into the kernel as noted above or loaded as a run-time kernel module. The recommended method is to add the module name to the <span class=filename>/boot/loader.conf</span> file so that it will load during the initial boot operation.</p></div><div class=paragraph><p>The following sections will discuss the various MAC modules and cover their features. Implementing them into a specific environment will also be a consideration of this chapter. Some modules support the use of labeling, which is controlling access by enforcing a label such as "this is allowed and this is not". A label configuration file may control how files may be accessed, network communication can be exchanged, and more. The previous section showed how the <code>multilabel</code> flag could be set on file systems to enable per-file or per-partition access control.</p></div><div class=paragraph><p>A single label configuration would enforce only one label across the system, that is why the <code>tunefs</code> option is called <code>multilabel</code>.</p></div><div class=sect3><h4 id=mac-seeotheruids>37.6.1. The MAC seeotheruids Module<a class=anchor href=#mac-seeotheruids></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_seeotheruids.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_SEEOTHERUIDS</code></p></div><div class=paragraph><p>Boot option: <code>mac_seeotheruids_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> module mimics and extends the <code>security.bsd.see_other_uids</code> and <code>security.bsd.see_other_gids sysctl</code> tunables. This option does not require any labels to be set before configuration and can operate transparently with the other modules.</p></div><div class=paragraph><p>After loading the module, the following <code>sysctl</code> tunables may be used to control the features:</p></div><div class=ulist><ul><li><p><code>security.mac.seeotheruids.enabled</code> will enable the module’s features and use the default settings. These default settings will deny users the ability to view processes and sockets owned by other users.</p></li><li><p><code>security.mac.seeotheruids.specificgid_enabled</code> will allow a certain group to be exempt from this policy. To exempt specific groups from this policy, use the <code>security.mac.seeotheruids.specificgid=XXX sysctl</code> tunable. In the above example, the <em>XXX</em> should be replaced with the numeric group ID to be exempted.</p></li><li><p><code>security.mac.seeotheruids.primarygroup_enabled</code> is used to exempt specific primary groups from this policy. When using this tunable, the <code>security.mac.seeotheruids.specificgid_enabled</code> may not be set.</p></li></ul></div></div></div><div class=sect2><h3 id=mac-bsdextended>37.7. The MAC bsdextended Module<a class=anchor href=#mac-bsdextended></a></h3><div class=paragraph><p>Module name: <span class=filename>mac_bsdextended.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_BSDEXTENDED</code></p></div><div class=paragraph><p>Boot option: <code>mac_bsdextended_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> module enforces the file system firewall. This module’s policy provides an extension to the standard file system permissions model, permitting an administrator to create a firewall-like ruleset to protect files, utilities, and directories in the file system hierarchy. When access to a file system object is attempted, the list of rules is iterated until either a matching rule is located or the end is reached. This behavior may be changed by the use of a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> parameter, security.mac.bsdextended.firstmatch_enabled. Similar to other firewall modules in FreeBSD, a file containing access control rules can be created and read by the system at boot time using an <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> variable.</p></div><div class=paragraph><p>The rule list may be entered using a utility, <a href="https://man.freebsd.org/cgi/man.cgi?query=ugidfw&amp;sektion=8&amp;format=html">ugidfw(8)</a>, that has a syntax similar to that of <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. More tools can be written by using the functions in the <a href="https://man.freebsd.org/cgi/man.cgi?query=libugidfw&amp;sektion=3&amp;format=html">libugidfw(3)</a> library.</p></div><div class=paragraph><p>Extreme caution should be taken when working with this module; incorrect use could block access to certain parts of the file system.</p></div><div class=sect3><h4 id=_examples>37.7.1. Examples<a class=anchor href=#_examples></a></h4><div class=paragraph><p>After the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> module has been loaded, the following command may be used to list the current rule configuration:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw list</span>
0 slots, 0 rules</code></pre></div></div><div class=paragraph><p>As expected, there are no rules defined. This means that everything is still completely accessible. To create a rule which will block all access by users but leave <code>root</code> unaffected, simply run the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw add subject not uid root new object not uid root mode n</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In releases prior to FreeBSD 5.3, the <span class=parameter>add</span> parameter did not exist. In those cases the <span class=parameter>set</span> should be used instead. See below for a command example.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This is a very bad idea as it will block all users from issuing even the most simple commands, such as <code>ls</code>. A more patriotic list of rules might be:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw set 2 subject uid user1 object uid user2 mode n</span>
<span class=c># ugidfw set 3 subject uid user1 object gid user2 mode n</span></code></pre></div></div><div class=paragraph><p>This will block any and all access, including directory listings, to <code><em>user2</em></code>'s home directory from the username <code>user1</code>.</p></div><div class=paragraph><p>In place of <code>user1</code>, the <code>not uid <em>user2</em></code> could be passed. This will enforce the same access restrictions above for all users in place of just one user.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>root</code> user will be unaffected by these changes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This should provide a general idea of how the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> module may be used to help fortify a file system. For more information, see the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> and the <a href="https://man.freebsd.org/cgi/man.cgi?query=ugidfw&amp;sektion=8&amp;format=html">ugidfw(8)</a> manual pages.</p></div></div></div><div class=sect2><h3 id=mac-ifoff>37.8. The MAC ifoff Module<a class=anchor href=#mac-ifoff></a></h3><div class=paragraph><p>Module name: <span class=filename>mac_ifoff.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_IFOFF</code></p></div><div class=paragraph><p>Boot option: <code>mac_ifoff_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> module exists solely to disable network interfaces on the fly and keep network interfaces from being brought up during the initial system boot. It does not require any labels to be set up on the system, nor does it have a dependency on other MAC modules.</p></div><div class=paragraph><p>Most of the control is done through the <code>sysctl</code> tunables listed below.</p></div><div class=ulist><ul><li><p><code>security.mac.ifoff.lo_enabled</code> will enable/disable all traffic on the loopback (<a href="https://man.freebsd.org/cgi/man.cgi?query=lo&amp;sektion=4&amp;format=html">lo(4)</a>) interface.</p></li><li><p><code>security.mac.ifoff.bpfrecv_enabled</code> will enable/disable all traffic on the Berkeley Packet Filter interface (<a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>)</p></li><li><p><code>security.mac.ifoff.other_enabled</code> will enable/disable traffic on all other interfaces.</p></li></ul></div><div class=paragraph><p>One of the most common uses of <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> is network monitoring in an environment where network traffic should not be permitted during the boot sequence. Another suggested use would be to write a script which uses <a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a> to automatically block network traffic if it finds new or altered files in protected directories.</p></div></div><div class=sect2><h3 id=mac-portacl>37.9. The MAC portacl Module<a class=anchor href=#mac-portacl></a></h3><div class=paragraph><p>Module name: <span class=filename>mac_portacl.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>MAC_PORTACL</code></p></div><div class=paragraph><p>Boot option: <code>mac_portacl_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> module is used to limit binding to local TCP and UDP ports using a variety of <code>sysctl</code> variables. In essence <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> makes it possible to allow non-<code>root</code> users to bind to specified privileged ports, i.e. ports fewer than 1024.</p></div><div class=paragraph><p>Once loaded, this module will enable the MAC policy on all sockets. The following tunables are available:</p></div><div class=ulist><ul><li><p><code>security.mac.portacl.enabled</code> will enable/disable the policy completely.</p></li><li><p><code>security.mac.portacl.port_high</code> will set the highest port number that <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> will enable protection for.</p></li><li><p><code>security.mac.portacl.suser_exempt</code> will, when set to a non-zero value, exempt the <code>root</code> user from this policy.</p></li><li><p><code>security.mac.portacl.rules</code> will specify the actual mac_portacl policy; see below.</p></li></ul></div><div class=paragraph><p>The actual <code>mac_portacl</code> policy, as specified in the <code>security.mac.portacl.rules</code> sysctl, is a text string of the form: <code>rule[,rule,…​]</code> with as many rules as needed. Each rule is of the form: <code>idtype:id:protocol:port</code>. The <span class=parameter>idtype</span> parameter can be <code>uid</code> or <code>gid</code> and used to interpret the <span class=parameter>id</span> parameter as either a user id or group id, respectively. The <span class=parameter>protocol</span> parameter is used to determine if the rule should apply to TCP or UDP by setting the parameter to <code>tcp</code> or <code>udp</code>. The final <span class=parameter>port</span> parameter is the port number to allow the specified user or group to bind to.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Since the ruleset is interpreted directly by the kernel only numeric values can be used for the user ID, group ID, and port parameters. I.e. user, group, and port service names cannot be used.</p></div></td></tr></tbody></table></div><div class=paragraph><p>By default, on UNIX®-like systems, ports fewer than 1024 can only be used by/bound to privileged processes, i.e. those run as <code>root</code>. For <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> to allow non-privileged processes to bind to ports below 1024 this standard UNIX® restriction has to be disabled. This can be accomplished by setting the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variables <code>net.inet.ip.portrange.reservedlow</code> and <code>net.inet.ip.portrange.reservedhigh</code> to zero.</p></div><div class=paragraph><p>See the examples below or review the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> manual page for further information.</p></div><div class=sect3><h4 id=_examples_2>37.9.1. Examples<a class=anchor href=#_examples_2></a></h4><div class=paragraph><p>The following examples should illuminate the above discussion a little better:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.port_high=1023</span>
<span class=c># sysctl net.inet.ip.portrange.reservedlow=0 net.inet.ip.portrange.reservedhigh=0</span></code></pre></div></div><div class=paragraph><p>First we set <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> to cover the standard privileged ports and disable the normal UNIX® bind restrictions.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.suser_exempt=1</span></code></pre></div></div><div class=paragraph><p>The <code>root</code> user should not be crippled by this policy, thus set the <code>security.mac.portacl.suser_exempt</code> to a non-zero value. The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> module has now been set up to behave the same way UNIX®-like systems behave by default.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:80:tcp:80</span></code></pre></div></div><div class=paragraph><p>Allow the user with UID 80 (normally the <code>www</code> user) to bind to port 80. This can be used to allow the <code>www</code> user to run a web server without ever having <code>root</code> privilege.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995</span></code></pre></div></div><div class=paragraph><p>Permit the user with the UID of 1001 to bind to the TCP ports 110 ("pop3") and 995 ("pop3s"). This will permit this user to start a server that accepts connections on ports 110 and 995.</p></div></div></div><div class=sect2><h3 id=mac-partition>37.10. The MAC partition Module<a class=anchor href=#mac-partition></a></h3><div class=paragraph><p>Module name: <span class=filename>mac_partition.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_PARTITION</code></p></div><div class=paragraph><p>Boot option: <code>mac_partition_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_partition&amp;sektion=4&amp;format=html">mac_partition(4)</a> policy will drop processes into specific "partitions" based on their MAC label. Think of it as a special type of <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>, though that is hardly a worthy comparison.</p></div><div class=paragraph><p>This is one module that should be added to the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> file so that it loads and enables the policy during the boot process.</p></div><div class=paragraph><p>Most configuration for this policy is done using the <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> utility which will be explained below. The following <code>sysctl</code> tunable is available for this policy:</p></div><div class=ulist><ul><li><p><code>security.mac.partition.enabled</code> will enable the enforcement of MAC process partitions.</p></li></ul></div><div class=paragraph><p>When this policy is enabled, users will only be permitted to see their processes, and any others within their partition, but will not be permitted to work with utilities outside the scope of this partition. For instance, a user in the <code>insecure</code> class above will not be permitted to access the <code>top</code> command as well as many other commands that must spawn a process.</p></div><div class=paragraph><p>To set or drop utilities into a partition label, use the <code>setpmac</code> utility:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac partition/13 top</span></code></pre></div></div><div class=paragraph><p>This will add the <code>top</code> command to the label set on users in the <code>insecure</code> class. Note that all processes spawned by users in the <code>insecure</code> class will stay in the <code>partition/13</code> label.</p></div><div class=sect3><h4 id=_examples_3>37.10.1. Examples<a class=anchor href=#_examples_3></a></h4><div class=paragraph><p>The following command will show you the partition label and the process list:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps Zax</span></code></pre></div></div><div class=paragraph><p>This next command will allow the viewing of another user’s process partition label and that user’s currently running processes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -ZU trhodes</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Users can see processes in <code>root</code>'s label unless the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> policy is loaded.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A really crafty implementation could have all of the services disabled in <span class=filename>/etc/rc.conf</span> and started by a script that starts them with the proper labeling set.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The following policies support integer settings in place of the three default labels offered. These options, including their limitations, are further explained in the module manual pages.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-mls>37.11. The MAC Multi-Level Security Module<a class=anchor href=#mac-mls></a></h3><div class=paragraph><p>Module name: <span class=filename>mac_mls.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_MLS</code></p></div><div class=paragraph><p>Boot option: <code>mac_mls_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> policy controls access between subjects and objects in the system by enforcing a strict information flow policy.</p></div><div class=paragraph><p>In MLS environments, a "clearance" level is set in each subject or objects label, along with compartments. Since these clearance or sensibility levels can reach numbers greater than six thousand; it would be a daunting task for any system administrator to thoroughly configure each subject or object. Thankfully, three "instant" labels are already included in this policy.</p></div><div class=paragraph><p>These labels are <code>mls/low</code>, <code>mls/equal</code> and <code>mls/high</code>. Since these labels are described in depth in the manual page, they will only get a brief description here:</p></div><div class=ulist><ul><li><p>The <code>mls/low</code> label contains a low configuration which permits it to be dominated by all other objects. Anything labeled with <code>mls/low</code> will have a low clearance level and not be permitted to access information of a higher level. In addition, this label will prevent objects of a higher clearance level from writing or passing information on to them.</p></li><li><p>The <code>mls/equal</code> label should be placed on objects considered to be exempt from the policy.</p></li><li><p>The <code>mls/high</code> label is the highest level of clearance possible. Objects assigned this label will hold dominance over all other objects in the system; however, they will not permit the leaking of information to objects of a lower class.</p></li></ul></div><div class=paragraph><p>MLS provides for:</p></div><div class=ulist><ul><li><p>A hierarchical security level with a set of non hierarchical categories;</p></li><li><p>Fixed rules: no read up, no write down (a subject can have read access to objects on its own level or below, but not above. Similarly, a subject can have write access to objects on its own level or above but not beneath.);</p></li><li><p>Secrecy (preventing inappropriate disclosure of data);</p></li><li><p>Basis for the design of systems that concurrently handle data at multiple sensitivity levels (without leaking information between secret and confidential).</p></li></ul></div><div class=paragraph><p>The following <code>sysctl</code> tunables are available for the configuration of special services and interfaces:</p></div><div class=ulist><ul><li><p><code>security.mac.mls.enabled</code> is used to enable/disable the MLS policy.</p></li><li><p><code>security.mac.mls.ptys_equal</code> will label all <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> devices as <code>mls/equal</code> during creation.</p></li><li><p><code>security.mac.mls.revocation_enabled</code> is used to revoke access to objects after their label changes to a label of a lower grade.</p></li><li><p><code>security.mac.mls.max_compartments</code> is used to set the maximum number of compartment levels with objects; basically the maximum compartment number allowed on a system.</p></li></ul></div><div class=paragraph><p>To manipulate the MLS labels, the <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a> command has been provided. To assign a label to an object, issue the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac mls/5 test</span></code></pre></div></div><div class=paragraph><p>To get the MLS label for the file <span class=filename>test</span> issue the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># getfmac test</span></code></pre></div></div><div class=paragraph><p>This is a summary of the MLS policy’s features. Another approach is to create a master policy file in <span class=filename>/etc</span> which specifies the MLS policy information and to feed that file into the <code>setfmac</code> command. This method will be explained after all policies are covered.</p></div><div class=sect3><h4 id=_planning_mandatory_sensitivity>37.11.1. Planning Mandatory Sensitivity<a class=anchor href=#_planning_mandatory_sensitivity></a></h4><div class=paragraph><p>With the Multi-Level Security Policy Module, an administrator plans for controlling the flow of sensitive information. By default, with its block read up block write down nature, the system defaults everything to a low state. Everything is accessible and an administrator slowly changes this during the configuration stage; augmenting the confidentiality of the information.</p></div><div class=paragraph><p>Beyond the three basic label options above, an administrator may group users and groups as required to block the information flow between them. It might be easier to look at the information in clearance levels familiarized with words, for instance classifications such as <code>Confidential</code>, <code>Secret</code>, and <code>Top Secret</code>. Some administrators might just create different groups based on project levels. Regardless of classification method, a well thought out plan must exist before implementing such a restrictive policy.</p></div><div class=paragraph><p>Some example situations for this security policy module could be an e-commerce web server, a file server holding critical company information, and financial institution environments. The most unlikely place would be a personal workstation with only two or three users.</p></div></div></div><div class=sect2><h3 id=mac-biba>37.12. The MAC Biba Module<a class=anchor href=#mac-biba></a></h3><div class=paragraph><p>Module name: <span class=filename>mac_biba.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_BIBA</code></p></div><div class=paragraph><p>Boot option: <code>mac_biba_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> module loads the MAC Biba policy. This policy works much like that of the MLS policy with the exception that the rules for information flow are slightly reversed. This is said to prevent the downward flow of sensitive information whereas the MLS policy prevents the upward flow of sensitive information; thus, much of this section can apply to both policies.</p></div><div class=paragraph><p>In Biba environments, an "integrity" label is set on each subject or object. These labels are made up of hierarchal grades, and non-hierarchal components. As an object’s or subject’s grade ascends, so does its integrity.</p></div><div class=paragraph><p>Supported labels are <code>biba/low</code>, <code>biba/equal</code>, and <code>biba/high</code>; as explained below:</p></div><div class=ulist><ul><li><p>The <code>biba/low</code> label is considered the lowest integrity an object or subject may have. Setting this on objects or subjects will block their write access to objects or subjects marked high. They still have read access though.</p></li><li><p>The <code>biba/equal</code> label should only be placed on objects considered to be exempt from the policy.</p></li><li><p>The <code>biba/high</code> label will permit writing to objects set at a lower label, but not permit reading that object. It is recommended that this label be placed on objects that affect the integrity of the entire system.</p></li></ul></div><div class=paragraph><p>Biba provides for:</p></div><div class=ulist><ul><li><p>Hierarchical integrity level with a set of non hierarchical integrity categories;</p></li><li><p>Fixed rules: no write up, no read down (opposite of MLS). A subject can have write access to objects on its own level or below, but not above. Similarly, a subject can have read access to objects on its own level or above, but not below;</p></li><li><p>Integrity (preventing inappropriate modification of data);</p></li><li><p>Integrity levels (instead of MLS sensitivity levels).</p></li></ul></div><div class=paragraph><p>The following <code>sysctl</code> tunables can be used to manipulate the Biba policy.</p></div><div class=ulist><ul><li><p><code>security.mac.biba.enabled</code> may be used to enable/disable enforcement of the Biba policy on the target machine.</p></li><li><p><code>security.mac.biba.ptys_equal</code> may be used to disable the Biba policy on <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> devices.</p></li><li><p><code>security.mac.biba.revocation_enabled</code> will force the revocation of access to objects if the label is changed to dominate the subject.</p></li></ul></div><div class=paragraph><p>To access the Biba policy setting on system objects, use the <code>setfmac</code> and <code>getfmac</code> commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/low test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/low</code></pre></div></div><div class=sect3><h4 id=_planning_mandatory_integrity>37.12.1. Planning Mandatory Integrity<a class=anchor href=#_planning_mandatory_integrity></a></h4><div class=paragraph><p>Integrity, different from sensitivity, guarantees that the information will never be manipulated by untrusted parties. This includes information passed between subjects, objects, and both. It ensures that users will only be able to modify and in some cases even access information they explicitly need to.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> security policy module permits an administrator to address which files and programs a user or users may see and invoke while assuring that the programs and files are free from threats and trusted by the system for that user, or group of users.</p></div><div class=paragraph><p>During the initial planning phase, an administrator must be prepared to partition users into grades, levels, and areas. Users will be blocked access not only to data but programs and utilities both before and after they start. The system will default to a high label once this policy module is enabled, and it is up to the administrator to configure the different grades and levels for users. Instead of using clearance levels as described above, a good planning method could include topics. For instance, only allow developers modification access to the source code repository, source code compiler, and other development utilities. While other users would be grouped into other categories such as testers, designers, or just ordinary users and would only be permitted read access.</p></div><div class=paragraph><p>With its natural security control, a lower integrity subject is unable to write to a higher integrity subject; a higher integrity subject cannot observe or read a lower integrity object. Setting a label at the lowest possible grade could make it inaccessible to subjects. Some prospective environments for this security policy module would include a constrained web server, development and test machine, and source code repository. A less useful implementation would be a personal workstation, a machine used as a router, or a network firewall.</p></div></div></div><div class=sect2><h3 id=mac-lomac>37.13. The MAC LOMAC Module<a class=anchor href=#mac-lomac></a></h3><div class=paragraph><p>Module name: <span class=filename>mac_lomac.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_LOMAC</code></p></div><div class=paragraph><p>Boot option: <code>mac_lomac_load="YES"</code></p></div><div class=paragraph><p>Unlike the MAC Biba policy, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> policy permits access to lower integrity objects only after decreasing the integrity level to not disrupt any integrity rules.</p></div><div class=paragraph><p>The MAC version of the Low-watermark integrity policy, not to be confused with the older <a href="https://man.freebsd.org/cgi/man.cgi?query=lomac&amp;sektion=4&amp;format=html">lomac(4)</a> implementation, works almost identically to Biba, but with the exception of using floating labels to support subject demotion via an auxiliary grade compartment. This secondary compartment takes the form of <code>[auxgrade]</code>. When assigning a lomac policy with an auxiliary grade, it should look a little bit like: <code>lomac/10[2]</code> where the number two (2) is the auxiliary grade.</p></div><div class=paragraph><p>The MAC LOMAC policy relies on the ubiquitous labeling of all system objects with integrity labels, permitting subjects to read from low integrity objects and then downgrading the label on the subject to prevent future writes to high integrity objects. This is the <code>[auxgrade]</code> option discussed above, thus the policy may provide for greater compatibility and require less initial configuration than Biba.</p></div><div class=sect3><h4 id=_examples_4>37.13.1. Examples<a class=anchor href=#_examples_4></a></h4><div class=paragraph><p>Like the Biba and MLS policies; the <code>setfmac</code> and <code>setpmac</code> utilities may be used to place labels on system objects:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac /usr/home/trhodes lomac/high[low]</span>
<span class=c># getfmac /usr/home/trhodes</span>
lomac/high[low]</code></pre></div></div><div class=paragraph><p>Notice the auxiliary grade here is <code>low</code>, this is a feature provided only by the MAC LOMAC policy.</p></div></div></div><div class=sect2><h3 id=mac-implementing>37.14. Nagios in a MAC Jail<a class=anchor href=#mac-implementing></a></h3><div class=paragraph><p>The following demonstration will implement a secure environment using various MAC modules with properly configured policies. This is only a test and should not be considered the complete answer to everyone’s security woes. Just implementing a policy and ignoring it never works and could be disastrous in a production environment.</p></div><div class=paragraph><p>Before beginning this process, the <code>multilabel</code> option must be set on each file system as stated at the beginning of this chapter. Not doing so will result in errors. While at it, ensure that the <a class=package href=https://cgit.freebsd.org/ports/tree/net-mngt/nagios-plugins/>net-mngt/nagios-plugins</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/net-mngt/nagios/>net-mngt/nagios</a>, and <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13/>www/apache13</a> ports are all installed, configured, and working correctly.</p></div><div class=sect3><h4 id=_create_an_insecure_user_class>37.14.1. Create an insecure User Class<a class=anchor href=#_create_an_insecure_user_class></a></h4><div class=paragraph><p>Begin the procedure by adding the following user class to the <span class=filename>/etc/login.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/shared/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=biba/10(10-10):</pre></div></div><div class=paragraph><p>And adding the following line to the default user class:</p></div><div class="literalblock programlisting"><div class=content><pre>:label=biba/high:</pre></div></div><div class=paragraph><p>Once this is completed, the following command must be issued to rebuild the database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></div><div class=sect3><h4 id=_boot_configuration>37.14.2. Boot Configuration<a class=anchor href=#_boot_configuration></a></h4><div class=paragraph><p>Do not reboot yet, just add the following lines to <span class=filename>/boot/loader.conf</span> so the required modules will load during system initialization:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_biba_load=&#34;YES&#34;
mac_seeotheruids_load=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_configure_users>37.14.3. Configure Users<a class=anchor href=#_configure_users></a></h4><div class=paragraph><p>Set the <code>root</code> user to the default class using:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod root -L default</span></code></pre></div></div><div class=paragraph><p>All user accounts that are not <code>root</code> or system users will now require a login class. The login class is required otherwise users will be refused access to common commands such as <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>. The following <code>sh</code> script should do the trick:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for x in `awk -F: &#39;($3 &gt;= 1001) &amp;&amp; ($3 != 65534) { print $1 }&#39; \</span>

<span class=c># /etc/passwd`; do pw usermod $x -L default; done;</span></code></pre></div></div><div class=paragraph><p>Drop the <code>nagios</code> and <code>www</code> users into the insecure class:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod nagios -L insecure</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod www -L insecure</span></code></pre></div></div></div><div class=sect3><h4 id=_create_the_contexts_file>37.14.4. Create the Contexts File<a class=anchor href=#_create_the_contexts_file></a></h4><div class=paragraph><p>A contexts file should now be created; the following example file should be placed in <span class=filename>/etc/policy.contexts</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># This is the default BIBA policy for this system.

# System:
/var/run                        biba/equal
/var/run/*                      biba/equal

/dev                            biba/equal
/dev/*                          biba/equal

/var				biba/equal
/var/spool                      biba/equal
/var/spool/*                    biba/equal

/var/log                        biba/equal
/var/log/*                      biba/equal

/tmp				biba/equal
/tmp/*				biba/equal
/var/tmp			biba/equal
/var/tmp/*			biba/equal

/var/spool/mqueue		biba/equal
/var/spool/clientmqueue		biba/equal

# For Nagios:
/usr/local/etc/nagios
/usr/local/etc/nagios/*         biba/10

/var/spool/nagios               biba/10
/var/spool/nagios/*             biba/10

# For apache
/usr/local/etc/apache           biba/10
/usr/local/etc/apache/*         biba/10</pre></div></div><div class=paragraph><p>This policy will enforce security by setting restrictions on the flow of information. In this specific configuration, users, <code>root</code> and others, should never be allowed to access Nagios. Configuration files and processes that are a part of Nagios will be completely self contained or jailed.</p></div><div class=paragraph><p>This file may now be read into our system by issuing the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfsmac -ef /etc/policy.contexts /</span>
<span class=c># setfsmac -ef /etc/policy.contexts /</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The above file system layout may be different depending on environment; however, it must be run on every single file system.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The <span class=filename>/etc/mac.conf</span> file requires the following modifications in the main section:</p></div><div class="literalblock programlisting"><div class=content><pre>default_labels file ?biba
default_labels ifnet ?biba
default_labels process ?biba
default_labels socket ?biba</pre></div></div></div><div class=sect3><h4 id=_enable_networking>37.14.5. Enable Networking<a class=anchor href=#_enable_networking></a></h4><div class=paragraph><p>Add the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>security.mac.biba.trust_all_interfaces=1</pre></div></div><div class=paragraph><p>And the following to the network card configuration stored in <span class=filename>rc.conf</span>. If the primary Internet configuration is done via DHCP, this may need to be configured manually after every system boot:</p></div><div class="literalblock programlisting"><div class=content><pre>maclabel biba/equal</pre></div></div></div><div class=sect3><h4 id=_testing_the_configuration>37.14.6. Testing the Configuration<a class=anchor href=#_testing_the_configuration></a></h4><div class=paragraph><p>Ensure that the web server and Nagios will not be started on system initialization, and reboot. Ensure the <code>root</code> user cannot access any of the files in the Nagios configuration directory. If <code>root</code> can issue an <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> command on <span class=filename>/var/spool/nagios</span>, then something is wrong. Otherwise a "permission denied" error should be returned.</p></div><div class=paragraph><p>If all seems well, Nagios, Apache, and Sendmail can now be started in a way fitting of the security policy. The following commands will make this happen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/mail &amp;&amp; make stop &amp;&amp; \</span>
setpmac biba/equal make start <span class=o>&amp;&amp;</span> setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> apachectl start <span class=o>&amp;&amp;</span> <span class=se>\</span>
setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> /usr/local/etc/rc.d/nagios.sh forcestart</code></pre></div></div><div class=paragraph><p>Double check to ensure that everything is working properly. If not, check the log files or error messages. Use the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> utility to disable the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> security policy module enforcement and try starting everything again, like normal.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>root</code> user can change the security enforcement and edit the configuration files without fear. The following command will permit the degradation of the security policy to a lower grade for a newly spawned shell:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac biba/10 csh</span></code></pre></div></div><div class=paragraph><p>To block this from happening, force the user into a range via <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>. If <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> attempts to run a command outside of the compartment’s range, an error will be returned and the command will not be executed. In this case, setting root to <code>biba/high(high-high)</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-userlocked>37.15. User Lock Down<a class=anchor href=#mac-userlocked></a></h3><div class=paragraph><p>This example considers a relatively small, fewer than fifty users, storage system. Users would have login capabilities, and be permitted to not only store data but access resources as well.</p></div><div class=paragraph><p>For this scenario, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> mixed with <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> could co-exist and block access not only to system objects but to hide user processes as well.</p></div><div class=paragraph><p>Begin by adding the following lines to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_seeotheruids_enabled=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> security policy module may be activated through the use of the following rc.conf variable:</p></div><div class="literalblock programlisting"><div class=content><pre>ugidfw_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Default rules stored in <span class=filename>/etc/rc.bsdextended</span> will be loaded at system initialization; however, the default entries may need modification. Since this machine is expected only to service users, everything may be left commented out except the last two. These will force the loading of user owned system objects by default.</p></div><div class=paragraph><p>Add the required users to this machine and reboot. For testing purposes, try logging in as a different user across two consoles. Run the <code>ps aux</code> command to see if processes of other users are visible. Try to run <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> on another users home directory, it should fail.</p></div><div class=paragraph><p>Do not try to test with the <code>root</code> user unless the specific <code>sysctl</code>s have been modified to block super user access.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When a new user is added, their <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> rule will not be in the ruleset list. To update the ruleset quickly, simply unload the security policy module and reload it again using the <a href="https://man.freebsd.org/cgi/man.cgi?query=kldunload&amp;sektion=8&amp;format=html">kldunload(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> utilities.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-troubleshoot>37.16. Troubleshooting the MAC Framework<a class=anchor href=#mac-troubleshoot></a></h3><div class=paragraph><p>During the development stage, a few users reported problems with normal configuration. Some of these problems are listed below:</p></div><div class=sect3><h4 id=_the_multilabel_option_cannot_be_enabled_on>37.16.1. The <code>multilabel</code> option cannot be enabled on <span class=filename>/</span><a class=anchor href=#_the_multilabel_option_cannot_be_enabled_on></a></h4><div class=paragraph><p>The <code>multilabel</code> flag does not stay enabled on my root (<span class=filename>/</span>) partition!</p></div><div class=paragraph><p>It seems that one out of every fifty users has this problem, indeed, we had this problem during our initial configuration. Further observation of this so called "bug" has lead me to believe that it is a result of either incorrect documentation or misinterpretation of the documentation. Regardless of why it happened, the following steps may be taken to resolve it:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Edit <span class=filename>/etc/fstab</span> and set the root partition at <code>ro</code> for read-only.</p></li><li><p>Reboot into single user mode.</p></li><li><p>Run <code>tunefs -l enable</code> on <span class=filename>/</span>.</p></li><li><p>Reboot the system into normal mode.</p></li><li><p>Run <code>mount -urw</code> <span class=filename>/</span> and change the <code>ro</code> back to <code>rw</code> in <span class=filename>/etc/fstab</span> and reboot the system again.</p></li><li><p>Double-check the output from the <code>mount</code> to ensure that <code>multilabel</code> has been properly set on the root file system.</p></li></ol></div></div><div class=sect3><h4 id=_cannot_start_a_x11_server_after_mac>37.16.2. Cannot start a X11 server after MAC<a class=anchor href=#_cannot_start_a_x11_server_after_mac></a></h4><div class=paragraph><p>After establishing a secure environment with MAC, I am no longer able to start X!</p></div><div class=paragraph><p>This could be caused by the MAC <code>partition</code> policy or by a mislabeling in one of the MAC labeling policies. To debug, try the following:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Check the error message; if the user is in the <code>insecure</code> class, the <code>partition</code> policy may be the culprit. Try setting the user’s class back to the <code>default</code> class and rebuild the database with the <code>cap_mkdb</code> command. If this does not alleviate the problem, go to step two.</p></li><li><p>Double-check the label policies. Ensure that the policies are set correctly for the user in question, the X11 application, and the <span class=filename>/dev</span> entries.</p></li><li><p>If neither of these resolve the problem, send the error message and a description of your environment to the TrustedBSD discussion lists located at the <a href=http://www.TrustedBSD.org>TrustedBSD</a> website or to the <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>ηλεκτρονική λίστα γενικών ερωτήσεων του FreeBSD</a> mailing list.</p></li></ol></div></div><div class=sect3><h4 id=_error_secure_path3_cannot_stat_login_conf>37.16.3. Error: <a href="https://man.freebsd.org/cgi/man.cgi?query=_secure_path&amp;sektion=3&amp;format=html">_secure_path(3)</a> cannot stat <span class=filename>.login_conf</span><a class=anchor href=#_error_secure_path3_cannot_stat_login_conf></a></h4><div class=paragraph><p>When I attempt to switch from the <code>root</code> to another user in the system, the error message <code>_secure_path: unable to state .login_conf</code>.</p></div><div class=paragraph><p>This message is usually shown when the user has a higher label setting then that of the user whom they are attempting to become. For instance a user on the system, <code>joe</code>, has a default label of <code>biba/low</code>. The <code>root</code> user, who has a label of <code>biba/high</code>, cannot view <code>joe</code>'s home directory. This will happen regardless if <code>root</code> has used the <code>su</code> command to become <code>joe</code>, or not. In this scenario, the Biba integrity model will not permit <code>root</code> to view objects set at a lower integrity level.</p></div></div><div class=sect3><h4 id=_the_root_username_is_broken>37.16.4. The <code>root</code> username is broken!<a class=anchor href=#_the_root_username_is_broken></a></h4><div class=paragraph><p>In normal or even single user mode, the <code>root</code> is not recognized. The <code>whoami</code> command returns 0 (zero) and <code>su</code> returns <code>who are you?</code>. What could be going on?</p></div><div class=paragraph><p>This can happen if a labeling policy has been disabled, either by a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> or the policy module was unloaded. If the policy is being disabled or has been temporarily disabled, then the login capabilities database needs to be reconfigured with the <code>label</code> option being removed. Double check the <span class=filename>login.conf</span> file to ensure that all <code>label</code> options have been removed and rebuild the database with the <code>cap_mkdb</code> command.</p></div><div class=paragraph><p>This may also happen if a policy restricts access to the <span class=filename>master.passwd</span> file or database. Usually caused by an administrator altering the file under a label which conflicts with the general policy being used by the system. In these cases, the user information would be read by the system and access would be blocked as the file has inherited the new label. Disable the policy via a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> and everything should return to normal.</p></div></div></div></div></div><div class=sect1><h2 id=audit>Chapter 38. Έλεγχος Συμβάντων Ασφαλείας<a class=anchor href=#audit></a></h2><div class=sectionbody><div class=sect2><h3 id=audit-synopsis>38.1. Σύνοψη<a class=anchor href=#audit-synopsis></a></h3><div class=paragraph><p>Οι εκδόσεις του FreeBSD από την 6.2-RELEASE και μετά περιλαμβάνουν υποστήριξη για λεπτομερή έλεγχο συμβάντων ασφαλείας. Ο έλεγχος συμβάντων επιτρέπει αξιόπιστη, λεπτομερή και παραμετροποιήσιμη καταγραφή πλήθους συμβάντων σχετικών με την ασφάλεια, συμπεριλαμβανομένων των logins, των αλλαγών ρυθμίσεων, καθώς και της πρόσβασης σε αρχεία και στο δίκτυο. Οι καταγραφές αυτές είναι πολύτιμες για απευθείας παρακολούθηση του συστήματος, ανίχνευση εισβολέων, καθώς και για ανάλυση μετά από κάποια επίθεση. Το FreeBSD υλοποιεί τη μορφή αρχείων και το BSM API όπως έχουν δημοσιευτεί από την Sun™, και επιτρέπει διαλειτουργικότητα με τις υλοποιήσεις ελέγχου τόσο του Solaris™ της Sun™ όσο του Mac OS® της Apple®.</p></div><div class=paragraph><p>Το κεφάλαιο αυτό εστιάζει στην εγκατάσταση και ρύθμιση του Ελέγχου Συμβάντων. Εξηγεί τις πολιτικές ελέγχου, και παρέχει ένα παράδειγμα ρυθμίσεων ελέγχου.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Τι είναι ο έλεγχος συμβάντων και πως λειτουργεί.</p></li><li><p>Πως να ρυθμίσετε τον έλεγχο συμβάντων στο FreeBSD για χρήστες και προγράμματα (processes).</p></li><li><p>Πως να αναλύσετε τα ίχνη του ελέγχου χρησιμοποιώντας τα εργαλεία μείωσης όγκου δεδομένων και ανάλυσης.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε τις βασικές έννοιες του UNIX® και του FreeBSD (<a href=./#basics>Βασικές Έννοιες στο UNIX®</a>).</p></li><li><p>Να είστε εξοικειωμένος με τις βασικές έννοιες της ρύθμισης και μεταγλώττισης του πυρήνα. (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li><li><p>Να έχετε κάποια εξοικείωση με την ασφάλεια και πως αυτή σχετίζεται με το FreeBSD (<a href=./#security>Ασφάλεια</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Οι λειτουργίες ελέγχου στο FreeBSD 6.2 είναι σε πειραματικό στάδιο και η εγκατάσταση τους σε μηχανήματα παραγωγής θα πρέπει να γίνεται μόνο αφού ληφθούν σοβαρά υπόψιν οι κίνδυνοι από την εγκατάσταση πειραματικού λογισμικού. Οι γνωστοί αυτή τη στιγμή τρέχοντες περιορισμοί περιλαμβάνουν την αδυναμία ελέγχου όλων των συμβάντων που σχετίζονται με την ασφάλεια. Επίσης κάποιοι μηχανισμοί εισόδου (logins), όπως οι γραφικοί (X11-βασισμένοι) display managers, καθώς και ορισμένες υπηρεσίες τρίτων κατασκευαστών δεν είναι σωστά ρυθμισμένες για τον έλεγχο εισόδου χρηστών.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ο έλεγχος συμβάντων ασφαλείας μπορεί να δημιουργήσει πολύ λεπτομερείς καταγραφές της δραστηριότητας του συστήματος: σε ένα σύστημα με υψηλό φόρτο, τα αρχεία καταγραφής μπορεί να γίνουν πολύ μεγάλα, αν έχουν ρυθμιστεί για λεπτομερή καταγραφή, και να ξεπεράσουν τα αρκετά gigabytes την εβδομάδα σε κάποιες περιπτώσεις. Οι διαχειριστές θα πρέπει να λαμβάνουν υπόψιν τους τις πιθανές απαιτήσεις σε χώρο δίσκου σε περίπτωση ρυθμίσεων λεπτομερούς καταγραφής. Για παράδειγμα, ίσως είναι θεμιτό να αφιερωθεί ένα σύστημα αρχείων στο <span class=filename>/var/audit</span> ώστε τα υπόλοιπα συστήματα αρχείων να μην επηρεαστούν αν ο χώρος αυτός εξαντληθεί.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=audit-inline-glossary>38.2. Key Terms in this Chapter<a class=anchor href=#audit-inline-glossary></a></h3><div class=paragraph><p>Before reading this chapter, a few key audit-related terms must be explained:</p></div><div class=ulist><ul><li><p><em>event</em>: An auditable event is any event that can be logged using the audit subsystem. Examples of security-relevant events include the creation of a file, the building of a network connection, or a user logging in. Events are either "attributable", meaning that they can be traced to an authenticated user, or "non-attributable" if they cannot be. Examples of non-attributable events are any events that occur before authentication in the login process, such as bad password attempts.</p></li><li><p><em>class</em>: Event classes are named sets of related events, and are used in selection expressions. Commonly used classes of events include "file creation" (fc), "exec" (ex) and "login_logout" (lo).</p></li><li><p><em>record</em>: A record is an audit log entry describing a security event. Records contain a record event type, information on the subject (user) performing the action, date and time information, information on any objects or arguments, and a success or failure condition.</p></li><li><p><em>trail</em>: An audit trail, or log file, consists of a series of audit records describing security events. Typically, trails are in roughly chronological order with respect to the time events completed. Only authorized processes are allowed to commit records to the audit trail.</p></li><li><p><em>selection expression</em>: A selection expression is a string containing a list of prefixes and audit event class names used to match events.</p></li><li><p><em>preselection</em>: The process by which the system identifies which events are of interest to the administrator in order to avoid generating audit records describing events that are not of interest. The preselection configuration uses a series of selection expressions to identify which classes of events to audit for which users, as well as global settings that apply to both authenticated and unauthenticated processes.</p></li><li><p><em>reduction</em>: The process by which records from existing audit trails are selected for preservation, printing, or analysis. Likewise, the process by which undesired audit records are removed from the audit trail. Using reduction, administrators can implement policies for the preservation of audit data. For example, detailed audit trails might be kept for one month, but after that, trails might be reduced in order to preserve only login information for archival purposes.</p></li></ul></div></div><div class=sect2><h3 id=audit-install>38.3. Installing Audit Support<a class=anchor href=#audit-install></a></h3><div class=paragraph><p>User space support for Event Auditing is installed as part of the base FreeBSD operating system as of 6.2-RELEASE. However, Event Auditing support must be explicitly compiled into the kernel by adding the following lines to the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options	AUDIT</pre></div></div><div class=paragraph><p>Rebuild and reinstall the kernel via the normal process explained in <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>.</p></div><div class=paragraph><p>Once the kernel is built, installed, and the system has been rebooted, enable the audit daemon by adding the following line to <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>auditd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Audit support must then be started by a reboot, or by manually starting the audit daemon:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/rc.d/auditd start</pre></div></div></div><div class=sect2><h3 id=audit-config>38.4. Audit Configuration<a class=anchor href=#audit-config></a></h3><div class=paragraph><p>All configuration files for security audit are found in <span class=filename>/etc/security</span>. The following files must be present before the audit daemon is started:</p></div><div class=ulist><ul><li><p><span class=filename>audit_class</span> - Contains the definitions of the audit classes.</p></li><li><p><span class=filename>audit_control</span> - Controls aspects of the audit subsystem, such as default audit classes, minimum disk space to leave on the audit log volume, maximum audit trail size, etc.</p></li><li><p><span class=filename>audit_event</span> - Textual names and descriptions of system audit events, as well as a list of which classes each event in in.</p></li><li><p><span class=filename>audit_user</span> - User-specific audit requirements, which are combined with the global defaults at login.</p></li><li><p><span class=filename>audit_warn</span> - A customizable shell script used by auditd to generate warning messages in exceptional situations, such as when space for audit records is running low or when the audit trail file has been rotated.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Audit configuration files should be edited and maintained carefully, as errors in configuration may result in improper logging of events.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_event_selection_expressions>38.4.1. Event Selection Expressions<a class=anchor href=#_event_selection_expressions></a></h4><div class=paragraph><p>Selection expressions are used in a number of places in the audit configuration to determine which events should be audited. Expressions contain a list of event classes to match, each with a prefix indicating whether matching records should be accepted or ignored, and optionally to indicate if the entry is intended to match successful or failed operations. Selection expressions are evaluated from left to right, and two expressions are combined by appending one onto the other.</p></div><div class=paragraph><p>The following list contains the default audit event classes present in <span class=filename>audit_class</span>:</p></div><div class=ulist><ul><li><p><code>all</code> - <code>all</code> - Match all event classes.</p></li><li><p><code>ad</code> - <code>administrative</code> - Administrative actions performed on the system as a whole.</p></li><li><p><code>ap</code> - <code>application</code> - Application defined action.</p></li><li><p><code>cl</code> - <code>file_close</code> - Audit calls to the <code>close</code> system call.</p></li><li><p><code>ex</code> - <code>exec</code> - Audit program execution. Auditing of command line arguments and environmental variables is controlled via <a href="https://man.freebsd.org/cgi/man.cgi?query=audit_control&amp;sektion=5&amp;format=html">audit_control(5)</a> using the <code>argv</code> and <code>envv</code> parameters to the <code>policy</code> setting.</p></li><li><p><code>fa</code> - <code>file_attr_acc</code> - Audit the access of object attributes such as <a href="https://man.freebsd.org/cgi/man.cgi?query=stat&amp;sektion=1&amp;format=html">stat(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pathconf&amp;sektion=2&amp;format=html">pathconf(2)</a> and similar events.</p></li><li><p><code>fc</code> - <code>file_creation</code> - Audit events where a file is created as a result.</p></li><li><p><code>fd</code> - <code>file_deletion</code> - Audit events where file deletion occurs.</p></li><li><p><code>fm</code> - <code>file_attr_mod</code> - Audit events where file attribute modification occurs, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=flock&amp;sektion=2&amp;format=html">flock(2)</a>, etc.</p></li><li><p><code>fr</code> - <code>file_read</code> - Audit events in which data is read, files are opened for reading, etc.</p></li><li><p><code>fw</code> - <code>file_write</code> - Audit events in which data is written, files are written or modified, etc.</p></li><li><p><code>io</code> - <code>ioctl</code> - Audit use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;format=html">ioctl(2)</a> system call.</p></li><li><p><code>ip</code> - <code>ipc</code> - Audit various forms of Inter-Process Communication, including POSIX pipes and System V IPC operations.</p></li><li><p><code>lo</code> - <code>login_logout</code> - Audit <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=logout&amp;sektion=1&amp;format=html">logout(1)</a> events occurring on the system.</p></li><li><p><code>na</code> - <code>non_attrib</code> - Audit non-attributable events.</p></li><li><p><code>no</code> - <code>no_class</code> - Match no audit events.</p></li><li><p><code>nt</code> - <code>network</code> - Audit events related to network actions, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a>.</p></li><li><p><code>ot</code> - <code>other</code> - Audit miscellaneous events.</p></li><li><p><code>pc</code> - <code>process</code> - Audit process operations, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>.</p></li></ul></div><div class=paragraph><p>These audit event classes may be customized by modifying the <span class=filename>audit_class</span> and <span class=filename>audit_event</span> configuration files.</p></div><div class=paragraph><p>Each audit class in the list is combined with a prefix indicating whether successful/failed operations are matched, and whether the entry is adding or removing matching for the class and type.</p></div><div class=ulist><ul><li><p>(none) Audit both successful and failed instances of the event.</p></li><li><p><code>+</code> Audit successful events in this class.</p></li><li><p><code>-</code> Audit failed events in this class.</p></li><li><p><code>^</code> Audit neither successful nor failed events in this class.</p></li><li><p><code>^+</code> Don’t audit successful events in this class.</p></li><li><p><code>^-</code> Don’t audit failed events in this class.</p></li></ul></div><div class=paragraph><p>The following example selection string selects both successful and failed login/logout events, but only successful execution events:</p></div><div class="literalblock programlisting"><div class=content><pre>lo,+ex</pre></div></div></div><div class=sect3><h4 id=_configuration_files>38.4.2. Configuration Files<a class=anchor href=#_configuration_files></a></h4><div class=paragraph><p>In most cases, administrators will need to modify only two files when configuring the audit system: <span class=filename>audit_control</span> and <span class=filename>audit_user</span>. The first controls system-wide audit properties and policies; the second may be used to fine-tune auditing by user.</p></div><div class=sect4><h5 id=audit-auditcontrol>38.4.2.1. The <span class=filename>audit_control</span> File<a class=anchor href=#audit-auditcontrol></a></h5><div class=paragraph><p>The <span class=filename>audit_control</span> file specifies a number of defaults for the audit subsystem. Viewing the contents of this file, we see the following:</p></div><div class="literalblock programlisting"><div class=content><pre>dir:/var/audit
flags:lo
minfree:20
naflags:lo
policy:cnt
filesz:0</pre></div></div><div class=paragraph><p>The <code>dir</code> option is used to set one or more directories where audit logs will be stored. If more than one directory entry appears, they will be used in order as they fill. It is common to configure audit so that audit logs are stored on a dedicated file system, in order to prevent interference between the audit subsystem and other subsystems if the file system fills.</p></div><div class=paragraph><p>The <code>flags</code> field sets the system-wide default preselection mask for attributable events. In the example above, successful and failed login and logout events are audited for all users.</p></div><div class=paragraph><p>The <code>minfree</code> option defines the minimum percentage of free space for the file system where the audit trail is stored. When this threshold is exceeded, a warning will be generated. The above example sets the minimum free space to twenty percent.</p></div><div class=paragraph><p>The <code>naflags</code> option specifies audit classes to be audited for non-attributed events, such as the login process and system daemons.</p></div><div class=paragraph><p>The <code>policy</code> option specifies a comma-separated list of policy flags controlling various aspects of audit behavior. The default <code>cnt</code> flag indicates that the system should continue running despite an auditing failure (this flag is highly recommended). Another commonly used flag is <code>argv</code>, which causes command line arguments to the <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> system call to audited as part of command execution.</p></div><div class=paragraph><p>The <code>filesz</code> option specifies the maximum size in bytes to allow an audit trail file to grow to before automatically terminating and rotating the trail file. The default, 0, disables automatic log rotation. If the requested file size is non-zero and below the minimum 512k, it will be ignored and a log message will be generated.</p></div></div><div class=sect4><h5 id=audit-audituser>38.4.2.2. The <span class=filename>audit_user</span> File<a class=anchor href=#audit-audituser></a></h5><div class=paragraph><p>The <span class=filename>audit_user</span> file permits the administrator to specify further audit requirements for specific users. Each line configures auditing for a user via two fields: the first is the <code>alwaysaudit</code> field, which specifies a set of events that should always be audited for the user, and the second is the <code>neveraudit</code> field, which specifies a set of events that should never be audited for the user.</p></div><div class=paragraph><p>The following example <span class=filename>audit_user</span> file audits login/logout events and successful command execution for the root user, and audits file creation and successful command execution for the www user. If used with the example <span class=filename>audit_control</span> file above, the <code>lo</code> entry for <code>root</code> is redundant, and login/logout events will also be audited for the <code>www</code> user.</p></div><div class="literalblock programlisting"><div class=content><pre>root:lo,+ex:no
www:fc,+ex:no</pre></div></div></div></div></div><div class=sect2><h3 id=audit-administration>38.5. Administering the Audit Subsystem<a class=anchor href=#audit-administration></a></h3><div class=sect3><h4 id=_viewing_audit_trails>38.5.1. Viewing Audit Trails<a class=anchor href=#_viewing_audit_trails></a></h4><div class=paragraph><p>Audit trails are stored in the BSM binary format, so tools must be used to modify or convert to text. The <code>praudit</code> command convert trail files to a simple text format; the <code>auditreduce</code> command may be used to reduce the audit trail file for analysis, archiving, or printing purposes. <code>auditreduce</code> supports a variety of selection parameters, including event type, event class, user, date or time of the event, and the file path or object acted on.</p></div><div class=paragraph><p>For example, the <code>praudit</code> utility will dump the entire contents of a specified audit log in plain text:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /var/audit/AUDITFILE</span></code></pre></div></div><div class=paragraph><p>Where <em>AUDITFILE</em> is the audit log to dump.</p></div><div class=paragraph><p>Audit trails consist of a series of audit records made up of tokens, which <code>praudit</code> prints sequentially one per line. Each token is of a specific type, such as <code>header</code> holding an audit record header, or <code>path</code> holding a file path from a name lookup. The following is an example of an <code>execve</code> event:</p></div><div class="literalblock programlisting"><div class=content><pre>header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec
exec arg,finger,doug
path,/usr/bin/finger
attribute,555,root,wheel,90,24918,104944
subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
return,success,0
trailer,133</pre></div></div><div class=paragraph><p>This audit represents a successful <code>execve</code> call, in which the command <code>finger doug</code> has been run. The arguments token contains both the processed command line presented by the shell to the kernel. The path token holds the path to the executable as looked up by the kernel. The attribute token describes the binary, and in particular, includes the file mode which can be used to determine if the application was setuid. The subject token describes the subject process, and stores in sequence the audit user ID, effective user ID and group ID, real user ID and group ID, process ID, session ID, port ID, and login address. Notice that the audit user ID and real user ID differ: the user <code>robert</code> has switched to the <code>root</code> account before running this command, but it is audited using the original authenticated user. Finally, the return token indicates the successful execution, and the trailer concludes the record.</p></div></div><div class=sect3><h4 id=_reducing_audit_trails>38.5.2. Reducing Audit Trails<a class=anchor href=#_reducing_audit_trails></a></h4><div class=paragraph><p>Since audit logs may be very large, an administrator will likely want to select a subset of records for using, such as records associated with a specific user:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># auditreduce -u trhodes /var/audit/AUDITFILE | praudit</span></code></pre></div></div><div class=paragraph><p>This will select all audit records produced for the user <code>trhodes</code> stored in the <span class=filename>AUDITFILE</span> file.</p></div></div><div class=sect3><h4 id=_delegating_audit_review_rights>38.5.3. Delegating Audit Review Rights<a class=anchor href=#_delegating_audit_review_rights></a></h4><div class=paragraph><p>Members of the <code>audit</code> group are given permission to read audit trails in <span class=filename>/var/audit</span>; by default, this group is empty, so only the <code>root</code> user may read audit trails. Users may be added to the <code>audit</code> group in order to delegate audit review rights to the user. As the ability to track audit log contents provides significant insight into the behavior of users and processes, it is recommended that the delegation of audit review rights be performed with caution.</p></div></div><div class=sect3><h4 id=_live_monitoring_using_audit_pipes>38.5.4. Live Monitoring Using Audit Pipes<a class=anchor href=#_live_monitoring_using_audit_pipes></a></h4><div class=paragraph><p>Audit pipes are cloning pseudo-devices in the device file system which allow applications to tap the live audit record stream. This is primarily of interest to authors of intrusion detection and system monitoring applications. However, for the administrator the audit pipe device is a convenient way to allow live monitoring without running into problems with audit trail file ownership or log rotation interrupting the event stream. To track the live audit event stream, use the following command line</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /dev/auditpipe</span></code></pre></div></div><div class=paragraph><p>By default, audit pipe device nodes are accessible only to the <code>root</code> user. To make them accessible to the members of the <code>audit</code> group, add a <code>devfs</code> rule to <span class=filename>devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;auditpipe*&#39; mode 0440 group audit</pre></div></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> for more information on configuring the devfs file system.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>It is easy to produce audit event feedback cycles, in which the viewing of each audit event results in the generation of more audit events. For example, if all network I/O is audited, and praudit is run from an SSH session, then a continuous stream of audit events will be generated at a high rate, as each event being printed will generate another event. It is advisable to run praudit on an audit pipe device from sessions without fine-grained I/O auditing in order to avoid this happening.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_rotating_audit_trail_files>38.5.5. Rotating Audit Trail Files<a class=anchor href=#_rotating_audit_trail_files></a></h4><div class=paragraph><p>Audit trails are written to only by the kernel, and managed only by the audit daemon, auditd. Administrators should not attempt to use <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> or other tools to directly rotate audit logs. Instead, the <code>audit</code> management tool may be used to shut down auditing, reconfigure the audit system, and perform log rotation. The following command causes the audit daemon to create a new audit log and signal the kernel to switch to using the new log. The old log will be terminated and renamed, at which point it may then be manipulated by the administrator.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># audit -n</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>If the auditd daemon is not currently running, this command will fail and an error message will be produced.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Adding the following line to <span class=filename>/etc/crontab</span> will force the rotation every twelve hours from <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>0     */12       *       *       *       root    /usr/sbin/audit -n</pre></div></div><div class=paragraph><p>The change will take effect once you have saved the new <span class=filename>/etc/crontab</span>.</p></div><div class=paragraph><p>Automatic rotation of the audit trail file based on file size is possible via the <code>filesz</code> option in <a href="https://man.freebsd.org/cgi/man.cgi?query=audit_control&amp;sektion=5&amp;format=html">audit_control(5)</a>, and is described in the configuration files section of this chapter.</p></div></div><div class=sect3><h4 id=_compressing_audit_trails>38.5.6. Compressing Audit Trails<a class=anchor href=#_compressing_audit_trails></a></h4><div class=paragraph><p>As audit trail files can become very large, it is often desirable to compress or otherwise archive trails once they have been closed by the audit daemon. The <span class=filename>audit_warn</span> script can be used to perform customized operations for a variety of audit-related events, including the clean termination of audit trails when they are rotated. For example, the following may be added to the <span class=filename>audit_warn</span> script to compress audit trails on close:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Compress audit trail files on close.
#
if [ &#34;$1&#34; = closefile ]; then
        gzip -9 $2
fi</pre></div></div><div class=paragraph><p>Other archiving activities might include copying trail files to a centralized server, deleting old trail files, or reducing the audit trail to remove unneeded records. The script will be run only when audit trail files are cleanly terminated, so will not be run on trails left unterminated following an improper shutdown.</p></div></div></div></div></div><div class=sect1><h2 id=disks>Chapter 39. Αποθηκευτικά Μέσα<a class=anchor href=#disks></a></h2><div class=sectionbody><div class=sect2><h3 id=disks-synopsis>39.1. Σύνοψη<a class=anchor href=#disks-synopsis></a></h3><div class=paragraph><p>Το κεφάλαιο αυτό καλύπτει την χρήση των δίσκων στο FreeBSD. Περιλαμβάνει δίσκους που υποστηρίζονται από μνήμη, δίσκους συνδεδεμένους απευθείας στο δίκτυο, τις τυπικές συσκευές αποθήκευσης SCSI/IDE, καθώς και συσκευές που χρησιμοποιούν διεπαφή USB.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Την ορολογία που χρησιμοποιεί το FreeBSD για να περιγράψει την οργάνωση των δεδομένων στο φυσικό μέσο του δίσκου (partitions - κατατμήσεις - και slices).</p></li><li><p>Πως να προσθέσετε νέους σκληρούς δίσκους στο σύστημα σας.</p></li><li><p>Πως να ρυθμίσετε το FreeBSD να χρησιμοποιεί συσκευές αποθήκευσης USB.</p></li><li><p>Πως να ρυθμίσετε εικονικά συστήματα αρχείων, όπως δίσκους που αποθηκεύονται σε μνήμη RAM.</p></li><li><p>Πως να χρησιμοποιήσετε quotas για να περιορίσετε τη χρήση χώρου στο δίσκο.</p></li><li><p>Πως να κρυπτογραφήσετε δίσκους για να τους ασφαλίσετε από επιθέσεις.</p></li><li><p>Πως να δημιουργήσετε και να γράψετε CD και DVD στο FreeBSD.</p></li><li><p>Πως να χρησιμοποιήσετε προγράμματα λήψης αντιγράφων ασφαλείας στο FreeBSD.</p></li><li><p>Τι είναι οι εικόνες (snapshots) σε ένα σύστημα αρχείων και πως να τις χρησιμοποιήσετε αποδοτικά.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να ξέρετε πως να <a href=./#kernelconfig>ρυθμίσετε και να εγκαταστήσετε ένα νέο πυρήνα του FreeBSD</a>.</p></li></ul></div></div><div class=sect2><h3 id=disks-naming>39.2. Device Names<a class=anchor href=#disks-naming></a></h3><div class=paragraph><p>The following is a list of physical storage devices supported in FreeBSD and their associated device names.</p></div><table id=disk-naming-physical-table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 3. Physical Disk Naming Conventions</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Drive type</th><th class="tableblock halign-left valign-top">Drive device name</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE hard drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad</code> or <code>ada</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE CD-ROM drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acd</code> or <code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA hard drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad</code> or <code>ada</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA CD-ROM drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acd</code> or <code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI hard drives and USB Mass storage devices</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI CD-ROM drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Assorted non-standard CD-ROM drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>mcd</code> for Mitsumi CD-ROM and <code>scd</code> for Sony CD-ROM devices</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Floppy drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI tape drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE tape drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ast</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Flash drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fla</code> for DiskOnChip® Flash device</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RAID drives</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>aacd</code> for Adaptec® AdvancedRAID, <code>mlxd</code> and <code>mlyd</code> for Mylex®, <code>amrd</code> for AMI MegaRAID®, <code>idad</code> for Compaq Smart RAID, <code>twed</code> for 3ware® RAID.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disks-adding>39.3. Adding Disks<a class=anchor href=#disks-adding></a></h3><div class=paragraph><p>This section describes how to add a new SATA disk to a machine that currently only has a single drive. First, turn off the computer and install the drive in the computer following the instructions of the computer, controller, and drive manufacturers. Reboot the system and become <code>root</code>.</p></div><div class=paragraph><p>Inspect <span class=filename>/var/run/dmesg.boot</span> to ensure the new disk was found. In this example, the newly added SATA drive will appear as <span class=filename>ada1</span>.</p></div><div class=paragraph><p>For this example, a single large partition will be created on the new disk. The <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a> partitioning scheme will be used in preference to the older and less versatile MBR scheme.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the disk to be added is not blank, old partition information can be removed with <code>gpart delete</code>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> for details.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The partition scheme is created, and then a single partition is added:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT ada1</span>
<span class=c># gpart add -t freebsd-ufs ada1</span></code></pre></div></div><div class=paragraph><p>Depending on use, several smaller partitions may be desired. See <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> for options to create partitions smaller than a whole disk.</p></div><div class=paragraph><p>A file system is created on the new blank disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ada1p1</span></code></pre></div></div><div class=paragraph><p>An empty directory is created as a <em>mountpoint</em>, a location for mounting the new disk in the original disk’s file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /newdisk</span></code></pre></div></div><div class=paragraph><p>Finally, an entry is added to <span class=filename>/etc/fstab</span> so the new disk will be mounted automatically at startup:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1p1	/newdisk	ufs	rw	2	2</pre></div></div><div class=paragraph><p>The new disk can be mounted manually, without restarting the system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /newdisk</span></code></pre></div></div></div><div class=sect2><h3 id=usb-disks>39.4. USB Storage Devices<a class=anchor href=#usb-disks></a></h3><div class=paragraph><p>Many external storage solutions, such as hard drives, USB thumbdrives, and CD/DVD burners, use the Universal Serial Bus (USB). FreeBSD provides support for these devices.</p></div><div class=sect3><h4 id=_configuration_2>39.4.1. Configuration<a class=anchor href=#_configuration_2></a></h4><div class=paragraph><p>The USB mass storage devices driver, <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>, is built into the <span class=filename>GENERIC</span> kernel and provides support for USB storage devices. For a custom kernel, be sure that the following lines are present in the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass</pre></div></div><div class=paragraph><p>Since the <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> driver uses the SCSI subsystem to access the USB storage devices, any USB device will be seen as a SCSI device by the system. Depending on the USB chipset on the motherboard, <code>device uhci</code> or <code>device ohci</code> is used to provide USB 1.X support. Support for USB 2.0 controllers is provided by <code>device ehci</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the USB device is a CD or DVD burner, <a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=4&amp;format=html">cd(4)</a>, must be added to the kernel via the line:</p></div><div class="literalblock programlisting"><div class=content><pre>device cd</pre></div></div><div class=paragraph><p>Since the burner is seen as a SCSI drive, the driver <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> should not be used in the kernel configuration.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_testing_the_configuration_2>39.4.2. Testing the Configuration<a class=anchor href=#_testing_the_configuration_2></a></h4><div class=paragraph><p>To test the USB configuration, plug in the USB device. In the system message buffer, <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>, the drive should appear as something like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 <span class=nv>dp</span><span class=o>=</span>0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB <span class=o>(</span>258048 512 byte sectors: 64H 32S/T 126C<span class=o>)</span></code></pre></div></div><div class=paragraph><p>The brand, device node (<span class=filename>da0</span>), and other details will differ according to the device.</p></div><div class=paragraph><p>Since the USB device is seen as a SCSI one, <code>camcontrol</code> can be used to list the USB storage devices attached to the system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 <span class=o>(</span>da0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>If the drive comes with a file system, it can be mounted. Refer to <a href=#disks-adding>Adding Disks</a> for instructions on how to format and create partitions on the USB drive.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Allowing untrusted users to mount arbitrary media, by enabling <code>vfs.usermount</code> as described below, should not be considered safe from a security point of view. Most file systems in FreeBSD were not built to safeguard against malicious devices.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To make the device mountable as a normal user, one solution is to make all users of the device a member of the <code>operator</code> group using <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>. Next, ensure that the <code>operator</code> group is able to read and write the device by adding these lines to <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[localrules=5]
add path &#39;da*&#39; mode 0660 group operator</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If SCSI disks are installed in the system, change the second line as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>This will exclude the first three SCSI disks (<span class=filename>da0</span> to <span class=filename>da2</span>)from belonging to the <code>operator</code> group.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next, enable the <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> ruleset in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;localrules&#34;</pre></div></div><div class=paragraph><p>Next, instruct the running kernel to allow regular users to mount file systems. The easiest way is to add the following line to <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.usermount=1</pre></div></div><div class=paragraph><p>Since this only takes effect after the next reboot use <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> to set this variable now.</p></div><div class=paragraph><p>The final step is to create a directory where the file system is to be mounted. This directory needs to be owned by the user that is to mount the file system. One way to do that is for <code>root</code> to create a subdirectory owned by that user as <span class=filename>/mnt/username</span>. In the following example, replace <em>username</em> with the login name of the user and <em>usergroup</em> with the user’s primary group:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt/username</span>
<span class=c># chown username:usergroup /mnt/username</span></code></pre></div></div><div class=paragraph><p>Suppose a USB thumbdrive is plugged in, and a device <span class=filename>/dev/da0s1</span> appears. If the device is preformatted with a FAT file system, it can be mounted using:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mount <span class=nt>-t</span> msdosfs <span class=nt>-o</span> <span class=nt>-m</span><span class=o>=</span>644,-M<span class=o>=</span>755 /dev/da0s1 /mnt/username</code></pre></div></div><div class=paragraph><p>Before the device can be unplugged, it <em>must</em> be unmounted first. After device removal, the system message buffer will show messages similar to the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub0 port 1 <span class=o>(</span>addr 2<span class=o>)</span> disconnected
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: lost device
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: removing device entry
GEOM: destroy disk da0 <span class=nv>dp</span><span class=o>=</span>0xc2d74850
umass0: detached</code></pre></div></div></div><div class=sect3><h4 id=_further_reading_2>39.4.3. Further Reading<a class=anchor href=#_further_reading_2></a></h4><div class=paragraph><p>Beside the <a href=#disks-adding>Adding Disks</a> and <a href=./#mount-unmount>Mounting and Unmounting File Systems</a> sections, reading various manual pages may also be useful: <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a> under FreeBSD 8.X or <a href="https://man.freebsd.org/cgi/man.cgi?query=usbdevs&amp;sektion=8&amp;format=html">usbdevs(8)</a> under earlier versions of FreeBSD.</p></div></div></div><div class=sect2><h3 id=creating-cds>39.5. Creating and Using CD Media<a class=anchor href=#creating-cds></a></h3><div class=sect3><h4 id=_introduction>39.5.1. Introduction<a class=anchor href=#_introduction></a></h4><div class=paragraph><p>CD media provide a number of features that differentiate them from conventional disks. Initially, they were not writable by the user. They are designed so that they can be read continuously without delays to move the head between tracks. They are also much easier to transport between systems.</p></div><div class=paragraph><p>CD media do have tracks, but this refers to a section of data to be read continuously and not a physical property of the disk. For example, to produce a CD on FreeBSD, prepare the data files that are going to make up the tracks on the CD, then write the tracks to the CD.</p></div><div class=paragraph><p>The ISO 9660 file system was designed to deal with these differences. To overcome the original file system limits, it provides an extension mechanism that allows properly written CDs to exceed those limits while still working with systems that do not support those extensions.</p></div><div class=paragraph><p>The <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> port includes <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, a program that can be used to produce a data file containing an ISO 9660 file system. It has options that support various extensions, and is described below.</p></div><div class=paragraph><p>Which tool to use to burn the CD depends on whether the CD burner is ATAPI or something else. ATAPI CD burners use <code>burncd</code> which is part of the base system. SCSI and USB CD burners should use <code>cdrecord</code> from the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> port. It is also possible to use <code>cdrecord</code> and other tools for SCSI drives on ATAPI hardware with the <a href=#atapicam>ATAPI/CAM module</a>.</p></div><div class=paragraph><p>For CD burning software with a graphical user interface, consider X-CD-Roast or K3b. These tools are available as packages or from the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> and <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> ports. X-CD-Roast and K3b require the <a href=#atapicam>ATAPI/CAM module</a> with ATAPI hardware.</p></div></div><div class=sect3><h4 id=mkisofs>39.5.2. mkisofs<a class=anchor href=#mkisofs></a></h4><div class=paragraph><p>The <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> port also installs <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, which produces an ISO 9660 file system that is an image of a directory tree in the UNIX® file system name space. The simplest usage is:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o imagefile.iso /path/to/tree</span></code></pre></div></div><div class=paragraph><p>This command creates an <em>imagefile.iso</em> containing an ISO 9660 file system that is a copy of the tree at <em>/path/to/tree</em>. In the process, it maps the file names to names that fit the limitations of the standard ISO 9660 file system, and will exclude files that have names uncharacteristic of ISO file systems.</p></div><div class=paragraph><p>A number of options are available to overcome these restrictions. In particular, <code>-R</code> enables the Rock Ridge extensions common to UNIX® systems, <code>-J</code> enables Joliet extensions used by Microsoft systems, and <code>-hfs</code> can be used to create HFS file systems used by Mac OS®.</p></div><div class=paragraph><p>For CDs that are going to be used only on FreeBSD systems, <code>-U</code> can be used to disable all filename restrictions. When used with <code>-R</code>, it produces a file system image that is identical to the specified FreeBSD tree, though it may violate the ISO 9660 standard in a number of ways.</p></div><div class=paragraph><p>The last option of general use is <code>-b</code>. This is used to specify the location of the boot image for use in producing an "El Torito" bootable CD. This option takes an argument which is the path to a boot image from the top of the tree being written to the CD. By default, <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> creates an ISO image in "floppy disk emulation" mode, and thus expects the boot image to be exactly 1200, 1440 or 2880 KB in size. Some boot loaders, like the one used by the FreeBSD distribution disks, do not use emulation mode. In this case, <code>-no-emul-boot</code> should be used. So, if <span class=filename>/tmp/myboot</span> holds a bootable FreeBSD system with the boot image in <span class=filename>/tmp/myboot/boot/cdboot</span>, this command would produce the image of an ISO 9660 file system as <span class=filename>/tmp/bootable.iso</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre></div></div><div class=paragraph><p>If <span class=filename>md</span> is configured in the kernel, the file system can be mounted as a memory disk with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>One can then verify that <span class=filename>/mnt</span> and <span class=filename>/tmp/myboot</span> are identical.</p></div><div class=paragraph><p>There are many other options available for <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> to fine-tune its behavior. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> for details.</p></div></div><div class=sect3><h4 id=burncd>39.5.3. burncd<a class=anchor href=#burncd></a></h4><div class=paragraph><p>For an ATAPI CD burner, <code>burncd</code> can be used to burn an ISO image onto a CD. <code>burncd</code> is part of the base system, installed as <span class=filename>/usr/sbin/burncd</span>. Usage is very simple, as it has few options:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f cddevice data imagefile.iso fixate</span></code></pre></div></div><div class=paragraph><p>This command will burn a copy of <em>imagefile.iso</em> on <em>cddevice</em>. The default device is <span class=filename>/dev/acd0</span>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> for options to set the write speed, eject the CD after burning, and write audio data.</p></div></div><div class=sect3><h4 id=cdrecord>39.5.4. cdrecord<a class=anchor href=#cdrecord></a></h4><div class=paragraph><p>For systems without an ATAPI CD burner, <code>cdrecord</code> can be used to burn CDs. <code>cdrecord</code> is not part of the base system and must be installed from either the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> package or port. Changes to the base system can cause binary versions of this program to fail, possibly resulting in a "coaster". It is recommended to either upgrade the port when the system is upgraded, or for users <a href=./#stable>tracking -STABLE</a>, to upgrade the port when a new version becomes available.</p></div><div class=paragraph><p>While <code>cdrecord</code> has many options, basic usage is simple. Burning an ISO 9660 image is done with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device imagefile.iso</span></code></pre></div></div><div class=paragraph><p>The tricky part of using <code>cdrecord</code> is finding the <code>dev</code> to use. To find the proper setting, use <code>-scanbus</code> which might produce results like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
Cdrecord-Clone 2.01 <span class=o>(</span>i386-unknown-freebsd7.0<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2004 J<span class=s2>&#34;org Schilling
Using libscg version &#39;schily-0.1&#39;
scsibus0:
        0,0,0     0) &#39;SEAGATE &#39; &#39;ST39236LW       &#39; &#39;0004&#39; Disk
        0,1,0     1) &#39;SEAGATE &#39; &#39;ST39173W        &#39; &#39;5958&#39; Disk
        0,2,0     2) *
        0,3,0     3) &#39;iomega  &#39; &#39;jaz 1GB         &#39; &#39;J.86&#39; Removable Disk
        0,4,0     4) &#39;NEC     &#39; &#39;CD-ROM DRIVE:466&#39; &#39;1.26&#39; Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) &#39;YAMAHA  &#39; &#39;CRW4260         &#39; &#39;1.0q&#39; Removable CD-ROM
        1,6,0   106) &#39;ARTEC   &#39; &#39;AM12S           &#39; &#39;1.06&#39; Scanner
        1,7,0   107) *</span></code></pre></div></div><div class=paragraph><p>This lists the appropriate <code>dev</code> value for the devices on the list. Locate the CD burner, and use the three numbers separated by commas as the value for <code>dev</code>. In this case, the CRW device is 1,5,0, so the appropriate input is <code>dev=1,5,0</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> for easier ways to specify this value and for information on writing audio tracks and controlling the write speed.</p></div></div><div class=sect3><h4 id=duplicating-audiocds>39.5.5. Duplicating Audio CDs<a class=anchor href=#duplicating-audiocds></a></h4><div class=paragraph><p>To duplicate an audio CD, extract the audio data from the CD to a series of files, then write these files to a blank CD. The process is slightly different for ATAPI and SCSI drives.</p></div><div class="olist arabic procedure"><div class=title>Procedure: SCSI Drives</div><ol class=arabic><li><p>Use <code>cdda2wav</code> to extract the audio:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-vall</span> <span class=nt>-D2</span>,0 <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div></li><li><p>Use <code>cdrecord</code> to write the <span class=filename>.wav</span> files:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span>  <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Make sure that <em>2,0</em> is set appropriately, as described in <a href=#cdrecord>cdrecord</a>.</p></div></li></ol></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: ATAPI Drives</strong></p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>With the help of the <a href=#atapicam>ATAPI/CAM module</a>, <code>cdda2wav</code> can also be used on ATAPI drives. This tool is usually a better choice for most of users, as it supports jitter correction and endianness, than the method proposed below.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>The ATAPI CD driver makes each track available as <span class=filename>/dev/acddtnn</span>, where <em>d</em> is the drive number, and <em>nn</em> is the track number written with two decimal digits, prefixed with zero as needed. So the first track on the first disk is <span class=filename>/dev/acd0t01</span>, the second is <span class=filename>/dev/acd0t02</span>, the third is <span class=filename>/dev/acd0t03</span>, and so on.</p><div class=paragraph><p>Make sure the appropriate files exist in <span class=filename>/dev</span>. If the entries are missing, force the system to retaste the media:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0 of=/dev/null count=1</span></code></pre></div></div></li><li><p>Extract each track using <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a>, making sure to specify a block size when extracting the files:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0t01 of=track1.cdr bs=2352</span>
<span class=c># dd if=/dev/acd0t02 of=track2.cdr bs=2352</span>
...</code></pre></div></div></li><li><p>Burn the extracted files to disk using <code>burncd</code>. Specify that these are audio files, and that <code>burncd</code> should fixate the disk when finished:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=imaging-cd>39.5.6. Duplicating Data CDs<a class=anchor href=#imaging-cd></a></h4><div class=paragraph><p>It is possible to copy a data CD to an image file that is functionally equivalent to the image file created with <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, and then use it to duplicate any data CD. The example given here assumes that the CD-ROM device is <span class=filename>acd0</span>. Substitute the correct CD-ROM device.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0 of=file.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>Now that there is an image, it can be burned to CD as described above.</p></div></div><div class=sect3><h4 id=mounting-cd>39.5.7. Using Data CDs<a class=anchor href=#mounting-cd></a></h4><div class=paragraph><p>It is possible to mount and read the data on a standard data CD. By default, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> assumes that a file system is of type <code>ufs</code>. Running this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>will generate an error about <code>Incorrect super block</code>, and will fail to mount the CD. The CD does not use the <code>UFS</code> file system, so attempts to mount it as such will fail. Instead, tell <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> that the file system is of type <code>ISO9660</code> by specifying <code>-t cd9660</code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. For example, to mount the CD-ROM device, <span class=filename>/dev/cd0</span>, under <span class=filename>/mnt</span>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Replace <span class=filename>/dev/cd0</span> with the device name for the CD device. Also, <code>-t cd9660</code> executes <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>, meaning the above command is equivalent to:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>While data CD-ROMs from any vendor can be mounted this way, disks with certain ISO 9660 extensions might behave oddly. For example, Joliet disks store all filenames in two-byte Unicode characters. The FreeBSD kernel does not speak Unicode, but the FreeBSD CD9660 driver is able to convert Unicode characters on the fly. If some non-English characters show up as question marks, specify the local charset with <code>-C</code>. For more information, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to do this character conversion with the help of <code>-C</code>, the kernel requires the <span class=filename>cd9660_iconv.ko</span> module to be loaded. This can be done either by adding this line to <span class=filename>loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cd9660_iconv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>and then rebooting the machine, or by directly loading the module with <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Occasionally, <code>Device not configured</code> will be displayed when trying to mount a CD-ROM. This usually means that the CD-ROM drive thinks that there is no disk in the tray, or that the drive is not visible on the bus. It can take a couple of seconds for a CD-ROM drive to realize that a media is present, so be patient.</p></div><div class=paragraph><p>Sometimes, a SCSI CD-ROM may be missed because it did not have enough time to answer the bus reset. To resolve this, add the following option to the kernel configuration and <a href=./#kernelconfig-building>rebuild the kernel</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>This tells the SCSI bus to pause 15 seconds during boot, to give the CD-ROM drive every possible chance to answer the bus reset.</p></div></div><div class=sect3><h4 id=rawdata-cd>39.5.8. Burning Raw Data CDs<a class=anchor href=#rawdata-cd></a></h4><div class=paragraph><p>It is possible to burn a file directly to CD, without creating an ISO 9660 file system. Some people do this for backup purposes. This command runs more quickly than burning a standard CD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</span></code></pre></div></div><div class=paragraph><p>In order to retrieve the data burned to such a CD, the data must be read from the raw device node:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/acd1</span></code></pre></div></div><div class=paragraph><p>This type of disk can not be mounted as a normal CD-ROM and the data cannot be read under any operating system except FreeBSD. In order to mount the CD, or to share the data with another operating system, <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> must be used as described above.</p></div></div><div class=sect3><h4 id=atapicam>39.5.9. Using the ATAPI/CAM Driver<a class=anchor href=#atapicam></a></h4><div class=paragraph><p>This driver allows ATAPI devices, such as CD/DVD drives, to be accessed through the SCSI subsystem, and so allows the use of applications like <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a>.</p></div><div class=paragraph><p>To use this driver, add the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>then, reboot the system.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Users who prefer to statically compile <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> support into the kernel, should add this line to the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Ensure the following lines are still in the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata
device scbus
device cd
device pass</pre></div></div><div class=paragraph><p>Then rebuild, install the new kernel, and reboot the machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>During the boot process, the burner should show up, like so:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div><div class=paragraph><p>The drive can now be accessed via the <span class=filename>/dev/cd0</span> device name. For example, to mount a CD-ROM on <span class=filename>/mnt</span>, type the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>As <code>root</code>, run the following command to get the SCSI address of the burner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>pass0,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In this example, <code>1,0,0</code> is the SCSI address to use with <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> and other SCSI applications.</p></div><div class=paragraph><p>For more information about ATAPI/CAM and SCSI system, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=cam&amp;sektion=4&amp;format=html">cam(4)</a>.</p></div></div></div><div class=sect2><h3 id=creating-dvds>39.6. Creating and Using DVD Media<a class=anchor href=#creating-dvds></a></h3><div class=sect3><h4 id=_introduction_2>39.6.1. Introduction<a class=anchor href=#_introduction_2></a></h4><div class=paragraph><p>Compared to the CD, the DVD is the next generation of optical media storage technology. The DVD can hold more data than any CD and is the standard for video publishing.</p></div><div class=paragraph><p>Five physical recordable formats can be defined for a recordable DVD:</p></div><div class=ulist><ul><li><p>DVD-R: This was the first DVD recordable format available. The DVD-R standard is defined by the <a href=http://www.dvdforum.com/forum.shtml>DVD Forum</a>. This format is write once.</p></li><li><p>DVD-RW: This is the rewritable version of the DVD-R standard. A DVD-RW can be rewritten about 1000 times.</p></li><li><p>DVD-RAM: This is a rewritable format which can be seen as a removable hard drive. However, this media is not compatible with most DVD-ROM drives and DVD-Video players as only a few DVD writers support the DVD-RAM format. Refer to <a href=#creating-dvd-ram>Using a DVD-RAM</a> for more information on DVD-RAM use.</p></li><li><p>DVD+RW: This is a rewritable format defined by the <a href=http://www.dvdrw.com/>DVD+RW Alliance</a>. A DVD+RW can be rewritten about 1000 times.</p></li><li><p>DVD+R: This format is the write once variation of the DVD+RW format.</p></li></ul></div><div class=paragraph><p>A single layer recordable DVD can hold up to 4,700,000,000 bytes which is actually 4.38 GB or 4485 MB as 1 kilobyte is 1024 bytes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A distinction must be made between the physical media and the application. For example, a DVD-Video is a specific file layout that can be written on any recordable DVD physical media such as DVD-R, DVD+R, or DVD-RW. Before choosing the type of media, ensure that both the burner and the DVD-Video player are compatible with the media under consideration.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_configuration_3>39.6.2. Configuration<a class=anchor href=#_configuration_3></a></h4><div class=paragraph><p>To perform DVD recording, use <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. This command is part of the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a> utilities which support all DVD media types.</p></div><div class=paragraph><p>These tools use the SCSI subsystem to access the devices, therefore <a href=#atapicam>ATAPI/CAM support</a> must be loaded or statically compiled into the kernel. This support is not needed if the burner uses the USB interface. Refer to <a href=#usb-disks>USB Storage Devices</a> for more details on USB device configuration.</p></div><div class=paragraph><p>DMA access must also be enabled for ATAPI devices, by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Before attempting to use dvd+rw-tools, consult the <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>Hardware Compatibility Notes</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For a graphical user interface, consider using <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> which provides a user friendly interface to <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> and many other burning tools.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_burning_data_dvds>39.6.3. Burning Data DVDs<a class=anchor href=#_burning_data_dvds></a></h4><div class=paragraph><p>Since <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> is a front-end to <a href=#mkisofs>mkisofs</a>, it will invoke <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> to create the file system layout and perform the write on the DVD. This means that an image of the data does not need to be created before the burning process.</p></div><div class=paragraph><p>To burn to a DVD+R or a DVD-R the data in <span class=filename>/path/to/data</span>, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>In this example, <code>-J -R</code> is passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> to create an ISO 9660 file system with Joliet and Rock Ridge extensions. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> for more details.</p></div><div class=paragraph><p>For the initial session recording, <code>-Z</code> is used for both single and multiple sessions. Replace <em>/dev/cd0</em>, with the name of the DVD device. Using <code>-dvd-compat</code> indicates that the disk will be closed and that the recording will be unappendable. This should also provide better media compatibility with DVD-ROM drives.</p></div><div class=paragraph><p>To burn a pre-mastered image, such as <em>imagefile.iso</em>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>The write speed should be detected and automatically set according to the media and the drive being used. To force the write speed, use <code>-speed=</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> for example usage.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to support working files larger than 4.38GB, an UDF/ISO-9660 hybrid filesystem must be created by passing <code>-udf -iso-level 3</code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> and all related programs, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. This is required only when creating an ISO image file or when writing files directly to a disk. Since a disk created this way must be mounted as an UDF filesystem with <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_udf&amp;sektion=8&amp;format=html">mount_udf(8)</a>, it will be usable only on an UDF aware operating system. Otherwise it will look as if it contains corrupted files.</p></div><div class=paragraph><p>To create this type of ISO file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mkisofs <span class=nt>-R</span> <span class=nt>-J</span> <span class=nt>-udf</span> <span class=nt>-iso-level</span> 3 <span class=nt>-o</span> imagefile.iso /path/to/data</code></pre></div></div><div class=paragraph><p>To burn files directly to a disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>When an ISO image already contains large files, no additional options are required for <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> to burn that image on a disk.</p></div><div class=paragraph><p>Be sure to use an up-to-date version of <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, which contains <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, as an older version may not contain large files support. If the latest version does not work, install <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools-devel/>sysutils/cdrtools-devel</a> and read its <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_burning_a_dvd_video>39.6.4. Burning a DVD-Video<a class=anchor href=#_burning_a_dvd_video></a></h4><div class=paragraph><p>A DVD-Video is a specific file layout based on the ISO 9660 and micro-UDF (M-UDF) specifications. Since DVD-Video presents a specific data structure hierarchy, a particular program such as <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a> is needed to author the DVD.</p></div><div class=paragraph><p>If an image of the DVD-Video file system already exists, it can be burned in the same way as any other image. If <code>dvdauthor</code> was used to make the DVD and the result is in <span class=filename>/path/to/video</span>, the following command should be used to burn the DVD-Video:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre></div></div><div class=paragraph><p><code>-dvd-video</code> is passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> to instruct it to create a DVD-Video file system layout. This option implies the <code>-dvd-compat</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> option.</p></div></div><div class=sect3><h4 id=_using_a_dvdrw>39.6.5. Using a DVD+RW<a class=anchor href=#_using_a_dvdrw></a></h4><div class=paragraph><p>Unlike CD-RW, a virgin DVD+RW needs to be formatted before first use. It is <em>recommended</em> to let <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> take care of this automatically whenever appropriate. However, it is possible to use <code>dvd+rw-format</code> to format the DVD+RW:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Only perform this operation once and keep in mind that only virgin DVD+RW medias need to be formatted. Once formatted, the DVD+RW can be burned as usual.</p></div><div class=paragraph><p>To burn a totally new file system and not just append some data onto a DVD+RW, the media does not need to be blanked first. Instead, write over the previous recording like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre></div></div><div class=paragraph><p>The DVD+RW format supports appending data to a previous recording. This operation consists of merging a new session to the existing one as it is not considered to be multi-session writing. <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> will <em>grow</em> the ISO 9660 file system present on the media.</p></div><div class=paragraph><p>For example, to append data to a DVD+RW, use the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>The same <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> options used to burn the initial session should be used during next writes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Use <code>-dvd-compat</code> for better media compatibility with DVD-ROM drives. When using DVD+RW, this option will not prevent the addition of data.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To blank the media, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect3><h4 id=_using_a_dvd_rw>39.6.6. Using a DVD-RW<a class=anchor href=#_using_a_dvd_rw></a></h4><div class=paragraph><p>A DVD-RW accepts two disc formats: incremental sequential and restricted overwrite. By default, DVD-RW discs are in sequential format.</p></div><div class=paragraph><p>A virgin DVD-RW can be directly written without being formatted. However, a non-virgin DVD-RW in sequential format needs to be blanked before writing a new initial session.</p></div><div class=paragraph><p>To blank a DVD-RW in sequential mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A full blanking using <code>-blank=full</code> will take about one hour on a 1x media. A fast blanking can be performed using <code>-blank</code>, if the DVD-RW will be recorded in Disk-At-Once (DAO) mode. To burn the DVD-RW in DAO mode, use the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Since <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> automatically attempts to detect fast blanked media and engage DAO write, <code>-use-the-force-luke=dao</code> should not be required.</p></div><div class=paragraph><p>One should instead use restricted overwrite mode with any DVD-RW as this format is more flexible than the default of incremental sequential.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To write data on a sequential DVD-RW, use the same instructions as for the other DVD formats:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>To append some data to a previous recording, use <code>-M</code> with <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. However, if data is appended on a DVD-RW in incremental sequential mode, a new session will be created on the disc and the result will be a multi-session disc.</p></div><div class=paragraph><p>A DVD-RW in restricted overwrite format does not need to be blanked before a new initial session. Instead, overwrite the disc with <code>-Z</code>. It is also possible to grow an existing ISO 9660 file system written on the disc with <code>-M</code>. The result will be a one-session DVD.</p></div><div class=paragraph><p>To put a DVD-RW in restricted overwrite format, the following command must be used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>To change back to sequential format, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect3><h4 id=_multi_session>39.6.7. Multi-Session<a class=anchor href=#_multi_session></a></h4><div class=paragraph><p>Few DVD-ROM drives support multi-session DVDs and most of the time only read the first session. DVD+R, DVD-R and DVD-RW in sequential format can accept multiple sessions. The notion of multiple sessions does not exist for the DVD+RW and the DVD-RW restricted overwrite formats.</p></div><div class=paragraph><p>Using the following command after an initial non-closed session on a DVD+R, DVD-R, or DVD-RW in sequential format, will add a new session to the disc:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Using this command with a DVD+RW or a DVD-RW in restricted overwrite mode will append data while merging the new session to the existing one. The result will be a single-session disc. Use this method to add data after an initial write on these types of media.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Since some space on the media is used between each session to mark the end and start of sessions, one should add sessions with a large amount of data to optimize media space. The number of sessions is limited to 154 for a DVD+R, about 2000 for a DVD-R, and 127 for a DVD+R Double Layer.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_for_more_information>39.6.8. For More Information<a class=anchor href=#_for_more_information></a></h4><div class=paragraph><p>To obtain more information about a DVD, use <code>dvd+rw-mediainfo /dev/cd0</code> while the disc in the specified drive.</p></div><div class=paragraph><p>More information about dvd+rw-tools can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, on the <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>dvd+rw-tools web site</a>, and in the <a href=http://lists.debian.org/cdwrite/>cdwrite mailing list</a> archives.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When creating a problem report related to the use of dvd+rw-tools, always include the output of <code>dvd+rw-mediainfo</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=creating-dvd-ram>39.6.9. Using a DVD-RAM<a class=anchor href=#creating-dvd-ram></a></h4><div class=sect4><h5 id=_configuration_4>39.6.9.1. Configuration<a class=anchor href=#_configuration_4></a></h5><div class=paragraph><p>DVD-RAM writers can use either a SCSI or ATAPI interface. For ATAPI devices, DMA access has to be enabled by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div></div><div class=sect4><h5 id=_preparing_the_media>39.6.9.2. Preparing the Media<a class=anchor href=#_preparing_the_media></a></h5><div class=paragraph><p>A DVD-RAM can be seen as a removable hard drive. Like any other hard drive, the DVD-RAM must be formatted before it can be used. In this example, the whole disk space will be formatted with a standard UFS2 file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/acd0 bs=2k count=1</span>
<span class=c># bsdlabel -Bw acd0</span>
<span class=c># newfs /dev/acd0</span></code></pre></div></div><div class=paragraph><p>The DVD device, <span class=filename>acd0</span>, must be changed according to the configuration.</p></div></div><div class=sect4><h5 id=_using_the_media>39.6.9.3. Using the Media<a class=anchor href=#_using_the_media></a></h5><div class=paragraph><p>Once the DVD-RAM has been formatted, it can be mounted as a normal hard drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/acd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Once mounted, the DVD-RAM will be both readable and writeable.</p></div></div></div></div><div class=sect2><h3 id=floppies>39.7. Creating and Using Floppy Disks<a class=anchor href=#floppies></a></h3><div class=paragraph><p>Storing data on floppy disks is sometimes useful, for example when one does not have any other removable storage media or when one needs to transfer small amounts of data to another computer.</p></div><div class=paragraph><p>This section explains how to use floppy disks in FreeBSD. It covers formatting and usage of 3.5inch DOS floppies, but the concepts are similar for other floppy disk formats.</p></div><div class=sect3><h4 id=_formatting_floppies>39.7.1. Formatting Floppies<a class=anchor href=#_formatting_floppies></a></h4><div class=sect4><h5 id=_the_device>39.7.1.1. The Device<a class=anchor href=#_the_device></a></h5><div class=paragraph><p>Floppy disks are accessed through entries in <span class=filename>/dev</span>, just like other devices. To access the raw floppy disk, simply use <span class=filename>/dev/fdN</span>.</p></div></div><div class=sect4><h5 id=_formatting>39.7.1.2. Formatting<a class=anchor href=#_formatting></a></h5><div class=paragraph><p>A floppy disk needs to be low-level formatted before it can be used. This is usually done by the vendor, but formatting is a good way to check media integrity. Although it is possible to force other disk sizes, 1440kB is what most floppy disks are designed for.</p></div><div class=paragraph><p>To low-level format the floppy disk, use <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>. This utility expects the device name as an argument.</p></div><div class=paragraph><p>Make note of any error messages, as these can help determine if the disk is good or bad.</p></div><div class=sect5><h6 id=_formatting_floppy_disks>39.7.1.2.1. Formatting Floppy Disks<a class=anchor href=#_formatting_floppy_disks></a></h6><div class=paragraph><p>To format the floppy, insert a new 3.5inch floppy disk into the first floppy drive and issue:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_the_disk_label>39.7.2. The Disk Label<a class=anchor href=#_the_disk_label></a></h4><div class=paragraph><p>After low-level formatting the disk, a disk label needs to placed on it. This disk label will be destroyed later, but it is needed by the system to determine the size of the disk and its geometry.</p></div><div class=paragraph><p>The new disk label will take over the whole disk and will contain all the proper information about the geometry of the floppy. The geometry values for the disk label are listed in <span class=filename>/etc/disktab</span>.</p></div><div class=paragraph><p>To write the disk label, use <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre></div></div></div><div class=sect3><h4 id=_the_file_system>39.7.3. The File System<a class=anchor href=#_the_file_system></a></h4><div class=paragraph><p>The floppy is now ready to be high-level formatted. This will place a new file system on it so that FreeBSD can read and write to the disk. Since creating the new file system destroys the disk label, the disk label needs to be recreated whenever the disk is reformatted.</p></div><div class=paragraph><p>The floppy’s file system can be either UFS or FAT. FAT is generally a better choice for floppies.</p></div><div class=paragraph><p>To put a new file system on the floppy, issue:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div><div class=paragraph><p>The disk is now ready for use.</p></div></div><div class=sect3><h4 id=_using_the_floppy>39.7.4. Using the Floppy<a class=anchor href=#_using_the_floppy></a></h4><div class=paragraph><p>To use the floppy, mount it with <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>. One can also use <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> from the Ports Collection.</p></div></div></div><div class=sect2><h3 id=backups-tapebackups>39.8. Creating and Using Data Tapes<a class=anchor href=#backups-tapebackups></a></h3><div class=paragraph><p>Tape technology has continued to evolve but is less likely to be used in a modern system. Modern backup systems tend to use off site combined with local removable disk drive technologies. Still, FreeBSD will support any tape drive that uses SCSI, such as LTO and older devices such as DAT. There is limited support for SATA and USB tape drives.</p></div><div class=sect3><h4 id=tapes-sa0>39.8.1. Serial Access with <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a><a class=anchor href=#tapes-sa0></a></h4><div class=paragraph><p>FreeBSD uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a> driver, providing <span class=filename>/dev/sa0</span>, <span class=filename>/dev/nsa0</span>, and <span class=filename>/dev/esa0</span>. In normal use, only <span class=filename>/dev/sa0</span> is needed. <span class=filename>/dev/nsa0</span> is the same physical drive as <span class=filename>/dev/sa0</span> but does not rewind the tape after writing a file. This allows writing more than one file to a tape. Using <span class=filename>/dev/esa0</span> ejects the tape after the device is closed, if applicable.</p></div></div><div class=sect3><h4 id=_controlling_the_tape_drive_with_mt1>39.8.2. Controlling the Tape Drive with <a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a><a class=anchor href=#_controlling_the_tape_drive_with_mt1></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a> is the FreeBSD utility for controlling other operations of the tape drive, such as seeking through files on a tape or writing tape control marks to the tape.</p></div><div class=paragraph><p>For example, the first three files on a tape can be preserved by skipping past them before writing a new file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mt -f /dev/nsa0 fsf 3</span></code></pre></div></div></div><div class=sect3><h4 id=_using_tar1_to_read_and_write_tape_backups>39.8.3. Using <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> to Read and Write Tape Backups<a class=anchor href=#_using_tar1_to_read_and_write_tape_backups></a></h4><div class=paragraph><p>An example of writing a single file to tape using <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cvf /dev/sa0 file</span></code></pre></div></div><div class=paragraph><p>Recovering files from a <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> archive on tape into the current directory:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xvf /dev/sa0</span></code></pre></div></div></div><div class=sect3><h4 id=_using_dump8_and_restore8_to_create_and_restore_backups>39.8.4. Using <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> to Create and Restore Backups<a class=anchor href=#_using_dump8_and_restore8_to_create_and_restore_backups></a></h4><div class=paragraph><p>A simple backup of <span class=filename>/usr</span> with <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -0aL -b64 -f /dev/nsa0 /usr</span></code></pre></div></div><div class=paragraph><p>Interactively restoring files from a <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> file on tape into the current directory:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># restore -i -f /dev/nsa0</span></code></pre></div></div></div><div class=sect3><h4 id=_other_tape_software>39.8.5. Other Tape Software<a class=anchor href=#_other_tape_software></a></h4><div class=paragraph><p>Higher-level programs are available to simplify tape backup. The most popular are Amanda and Bacula. These programs aim to make backups easier and more convenient, or to automate complex backups of multiple machines. The Ports Collection contains both these and other tape utility applications.</p></div></div></div><div class=sect2><h3 id=backup-strategies>39.9. Backup Strategies<a class=anchor href=#backup-strategies></a></h3><div class=paragraph><p>The first requirement in devising a backup plan is to make sure that all of the following problems are covered:</p></div><div class=ulist><ul><li><p>Disk failure.</p></li><li><p>Accidental file deletion.</p></li><li><p>Random file corruption.</p></li><li><p>Complete machine destruction, say by fire, including destruction of any on-site backups.</p></li></ul></div><div class=paragraph><p>Some systems will be best served by having each of these problems covered by a completely different technique. Except for strictly personal systems with low-value data, it is unlikely that one technique will cover all of them.</p></div><div class=paragraph><p>Some possible techniques include:</p></div><div class=ulist><ul><li><p>Archives of the whole system, backed up onto permanent, off-site media. This provides protection against all of the problems listed above, but is slow and inconvenient to restore from. Copies of the backups can be stored on site or online, but there will still be inconveniences in restoring files, especially for non-privileged users.</p></li><li><p>Filesystem snapshots, which are really only helpful in the accidental file deletion scenario, but can be <em>very</em> helpful in that case, as well as quick and easy to deal with.</p></li><li><p>Copies of whole file systems or disks which can be created with a periodic <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> of the whole machine. This is generally most useful in networks with unique requirements. For general protection against disk failure, this is usually inferior to RAID. For restoring accidentally deleted files, it can be comparable to UFS snapshots.</p></li><li><p>RAID, which minimizes or avoids downtime when a disk fails at the expense of having to deal with disk failures more often, because there are more disks, albeit at a much lower urgency.</p></li><li><p>Checking fingerprints of files using <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a>. Although this is not a backup, this technique indicates when one needs to resort to backups. This is particularly important for offline backups, and should be checked periodically.</p></li></ul></div><div class=paragraph><p>It is quite easy to come up with more techniques, many of them variations on the ones listed above. Specialized requirements usually lead to specialized techniques. For example, backing up a live database usually requires a method particular to the database software as an intermediate step. The important thing is to know which dangers should be protected against, and how each will be handled.</p></div></div><div class=sect2><h3 id=backup-basics>39.10. Backup Basics<a class=anchor href=#backup-basics></a></h3><div class=paragraph><p>The major backup programs built into FreeBSD are <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a>.</p></div><div class=sect3><h4 id=_dump_and_restore>39.10.1. Dump and Restore<a class=anchor href=#_dump_and_restore></a></h4><div class=paragraph><p>The traditional UNIX® backup programs are <code>dump</code> and <code>restore</code>. They operate on the drive as a collection of disk blocks, below the abstractions of files, links and directories that are created by the file systems. Unlike other backup software, <code>dump</code> backs up an entire file system on a device. It is unable to backup only part of a file system or a directory tree that spans more than one file system. <code>dump</code> does not write files and directories, but rather writes the raw data blocks that comprise files and directories. When used to extract data, <code>restore</code> stores temporary files in <span class=filename>/tmp/</span> by default. When using a recovery disk with a small <span class=filename>/tmp</span>, set <code>TMPDIR</code> to a directory with more free space in order for the restore to succeed.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If <code>dump</code> is used on the root directory, it will not back up <span class=filename>/home</span>, <span class=filename>/usr</span> or many other directories since these are typically mount points for other file systems or symbolic links into those file systems.</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>dump</code> has quirks that remain from its early days in Version 6 of AT&amp;T UNIX®,circa 1975. The default parameters are suitable for 9-track tapes (6250 bpi), not the high-density media available today (up to 62,182 ftpi). These defaults must be overridden on the command line to utilize the capacity of current tape drives.</p></div><div class=paragraph><p>It is also possible to backup data across the network to a tape drive attached to another computer with <code>rdump</code> and <code>rrestore</code>. Both programs rely upon <a href="https://man.freebsd.org/cgi/man.cgi?query=rcmd&amp;sektion=3&amp;format=html">rcmd(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ruserok&amp;sektion=3&amp;format=html">ruserok(3)</a> to access the remote tape drive. Therefore, the user performing the backup must be listed in <span class=filename>.rhosts</span> on the remote computer. The arguments to <code>rdump</code> and <code>rrestore</code> must be suitable to use on the remote computer. For example, to <code>rdump</code> from a FreeBSD computer to an Exabyte tape drive connected to a host called <code>komodo</code>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</span></code></pre></div></div><div class=paragraph><p>There are security implications to allowing <span class=filename>.rhosts</span> authentication, so use with caution.</p></div><div class=paragraph><p>It is also possible to use <code>dump</code> and <code>restore</code> in a more secure fashion over <code>ssh</code>.</p></div><div class=exampleblock><div class=title>Παράδειγμα 12. Using <code>dump</code> over ssh</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
          targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>Or, use the built-in <code>RSH</code>:</p></div><div class=exampleblock><div class=title>Παράδειγμα 13. Using <code>dump</code> over ssh with <code>RSH</code> Set</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_tar>39.10.2. <code>tar</code><a class=anchor href=#_tar></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> also dates back to Version 6 of AT&amp;T UNIX®, circa 1975. <code>tar</code> operates in cooperation with the file system and writes files and directories to tape. <code>tar</code> does not support the full range of options that are available from <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>, but it does not require the unusual command pipeline that <code>cpio</code> uses.</p></div><div class=paragraph><p>To <code>tar</code> to an Exabyte tape drive connected to a host called <code>komodo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cf - . | rsh komodo dd of=tape-device obs=20b</span></code></pre></div></div><div class=paragraph><p>When backing up over an insecure network, instead use <code>ssh</code>.</p></div></div><div class=sect3><h4 id=_cpio>39.10.3. <code>cpio</code><a class=anchor href=#_cpio></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> is the original UNIX® file interchange tape program for magnetic media. <code>cpio</code> includes options to perform byte-swapping, write a number of different archive formats, and pipe the data to other programs. This last feature makes <code>cpio</code> an excellent choice for installation media. <code>cpio</code> does not know how to walk the directory tree and a list of files must be provided through <span class=filename>stdin</span>.</p></div><div class=paragraph><p>Since <code>cpio</code> does not support backups across the network, use a pipeline and <code>ssh</code> to send the data to a remote tape drive.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for f in directory_list; do</span>

<span class=c># find $f &gt;&gt; backup.list</span>

<span class=c># done</span>
<span class=c># cpio -v -o --format=newc &lt; backup.list | ssh user@host &#34;cat &gt; backup_device&#34;</span></code></pre></div></div><div class=paragraph><p>Where <em>directory_list</em> is the list of directories to back up, <em>user</em>@<em>host</em> is the user/hostname combination that will be performing the backups, and <em>backup_device</em> is where the backups should be written to, such as <span class=filename>/dev/nsa0</span>).</p></div></div><div class=sect3><h4 id=_pax>39.10.4. <code>pax</code><a class=anchor href=#_pax></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> is the IEEE/POSIX® answer to <code>tar</code> and <code>cpio</code>. Over the years the various versions of <code>tar</code> and <code>cpio</code> have become slightly incompatible. So rather than fight it out to fully standardize them, POSIX® created a new archive utility. <code>pax</code> attempts to read and write many of the various <code>cpio</code> and <code>tar</code> formats, plus new formats of its own. Its command set more resembles <code>cpio</code> than <code>tar</code>.</p></div></div><div class=sect3><h4 id=backups-programs-amanda>39.10.5. Amanda<a class=anchor href=#backups-programs-amanda></a></h4><div class=paragraph><p>Amanda (Advanced Maryland Network Disk Archiver) is a client/server backup system, rather than a single program. An Amanda server will backup to a single tape drive any number of computers that have Amanda clients and a network connection to the Amanda server. A common problem at sites with a number of large disks is that the length of time required to backup to data directly to tape exceeds the amount of time available for the task. Amanda solves this problem by using a "holding disk" to backup several file systems at the same time. Amanda creates "archive sets": a group of tapes used over a period of time to create full backups of all the file systems listed in Amanda’s configuration file. The "archive set" also contains nightly incremental, or differential, backups of all the file systems. Restoring a damaged file system requires the most recent full backup and the incremental backups.</p></div><div class=paragraph><p>The configuration file provides fine grained control of backups and the network traffic that Amanda generates. Amanda will use any of the above backup programs to write the data to tape. Amanda is not installed by but is available as either a port or package.</p></div></div><div class=sect3><h4 id=_do_nothing>39.10.6. Do Nothing<a class=anchor href=#_do_nothing></a></h4><div class=paragraph><p>"Do nothing" is not a computer program, but it is the most widely used backup strategy. There are no initial costs. There is no backup schedule to follow. Just say no. If something happens to your data, grin and bear it!</p></div><div class=paragraph><p>If your time and data is worth little to nothing, then "Do nothing" is the most suitable backup program for the computer. But beware, FreeBSD is a useful tool and over time it can be used to create a valuable collection of files.</p></div><div class=paragraph><p>"Do nothing" is the correct backup method for <span class=filename>/usr/obj</span> and other directory trees that can be exactly recreated by the computer. An example is the files that comprise the HTML or PostScript® version of this Handbook. These document formats have been created from XML input files. Creating backups of the HTML or PostScript® files is not necessary if the XML files are backed up regularly.</p></div></div><div class=sect3><h4 id=_which_backup_program_is_best>39.10.7. Which Backup Program Is Best?<a class=anchor href=#_which_backup_program_is_best></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> <em>Period.</em> Elizabeth D. Zwicky torture tested all the backup programs discussed here. The clear choice for preserving all your data and all the peculiarities of UNIX® file systems is <code>dump</code>. Elizabeth created file systems containing a large variety of unusual conditions (and some not so unusual ones) and tested each program by doing a backup and restore of those file systems. The peculiarities included: files with holes, files with holes and a block of nulls, files with funny characters in their names, unreadable and unwritable files, devices, files that change size during the backup, files that are created/deleted during the backup and more. She presented the results at LISA V in Oct. 1991. See <a href=http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html>torture-testing Backup and Archive Programs</a>.</p></div></div><div class=sect3><h4 id=_emergency_restore_procedure>39.10.8. Emergency Restore Procedure<a class=anchor href=#_emergency_restore_procedure></a></h4><div class=sect4><h5 id=_before_the_disaster>39.10.8.1. Before the Disaster<a class=anchor href=#_before_the_disaster></a></h5><div class=paragraph><p>There are four steps which should be performed in preparation for any disaster that may occur.</p></div><div class=paragraph><p>First, print the bsdlabel of each disk using a command such as <code>bsdlabel da0 | lpr</code>. Also print a copy of <span class=filename>/etc/fstab</span> and all boot messages.</p></div><div class=paragraph><p>Second, burn a "livefs" CD. This CD contains support for booting into a FreeBSD "livefs" rescue mode, allowing the user to perform many tasks like running <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, and more. The livefs CD image for FreeBSD/i386 11.2-RELEASE is available from <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Livefs CD images are not available for FreeBSD 12.0-RELEASE and later. In addition to the CD-ROM installation images, flash drive installation images may be used to recover a system. The "memstick" image for FreeBSD/i386 12.0-RELEASE is available from <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/12.0/FreeBSD-12.0-RELEASE-i386-memstick.img>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/12.0/FreeBSD-12.0-RELEASE-i386-memstick.img</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Third, create backup tapes regularly. Any changes that made after the last backup may be irretrievably lost. Write-protect the backup media.</p></div><div class=paragraph><p>Fourth, test the "livefs" CD and the backups. Make notes of the procedure. Store these notes with the CD, the printouts, and the backups. These notes may prevent the inadvertent destruction of the backups while under the stress of performing an emergency recovery.</p></div><div class=paragraph><p>For an added measure of security, store an extra "livefs" CD and the latest backup at a remote location, where a remote location is <em>not</em> the basement of the same building. A remote location should be physically separated from the computers and disk drives by a significant distance.</p></div></div><div class=sect4><h5 id=_after_the_disaster>39.10.8.2. After the Disaster<a class=anchor href=#_after_the_disaster></a></h5><div class=paragraph><p>First, determine if the hardware survived. Thanks to regular, off-site backups, there is no need to worry about the software.</p></div><div class=paragraph><p>If the hardware has been damaged, the parts should be replaced before attempting to use the computer.</p></div><div class=paragraph><p>If the hardware is okay, insert the "livefs" CD and boot the computer. The original install menu will be displayed on the screen. Select the correct country, then choose <span class=guimenuitem>Fixit — Repair mode with CD-ROM/DVD/floppy or start a shell.</span> then select <span class=guimenuitem>CD-ROM/DVD — Use the live filesystem CD-ROM/DVD</span>. <code>restore</code> and the other needed programs are located in <span class=filename>/mnt2/rescue</span>.</p></div><div class=paragraph><p>Recover each file system separately.</p></div><div class=paragraph><p>Try to <code>mount</code> the root partition of the first disk using <code>mount /dev/da0a /mnt</code>. If the bsdlabel was damaged, use <code>bsdlabel</code> to re-partition and label the disk to match the label that was printed and saved. Use <code>newfs</code> to re-create the file systems. Re-mount the root partition of the disk read-write using <code>mount -u -o rw /mnt</code>. Use the backups to recover the data for this file system. Unmount the file system with <code>umount /mnt</code>. Repeat for each file system that was damaged.</p></div><div class=paragraph><p>Once the system is running, backup the data onto new media as whatever caused the crash or data loss may strike again. Another hour spent now may save further distress later.</p></div></div></div></div><div class=sect2><h3 id=disks-virtual>39.11. Network, Memory, and File-Backed File Systems<a class=anchor href=#disks-virtual></a></h3><div class=paragraph><p>In addition to physical disks such as floppies, CDs, and hard drives, FreeBSD also supports <em>virtual disks</em>.</p></div><div class=paragraph><p>These include network file systems such as the <a href=./#network-nfs>Network File System</a> and Coda, memory-based file systems, and file-backed file systems.</p></div><div class=paragraph><p>According to the FreeBSD version, the tools used for the creation and use of file-backed and memory-based file systems differ.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> to allocate device nodes transparently for the user.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=disks-mdconfig>39.11.1. File-Backed File System<a class=anchor href=#disks-mdconfig></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> is used to configure and enable memory disks, <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>, under FreeBSD. To use <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> must be first loaded. When using a custom kernel configuration file, ensure it includes this line:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> supports several types of memory backed virtual disks: memory disks allocated with <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> and memory disks using a file or swap space as backing. One possible use is the mounting of CD images.</p></div><div class=paragraph><p>To mount an existing file system image:</p></div><div class=exampleblock><div class=title>Παράδειγμα 14. Using <code>mdconfig</code> to Mount an Existing File System Image</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f diskimage -u 0</span>
<span class=c># mount /dev/md0 /mnt</span></code></pre></div></div></div></div><div class=paragraph><p>To create a new file system image with <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>:</p></div><div class=exampleblock><div class=title>Παράδειγμα 15. Creating a New File-Backed Disk with <code>mdconfig</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdconfig -a -t vnode -f newimage -u 0</span>
<span class=c># bsdlabel -w md0 auto</span>
<span class=c># newfs md0a</span>
/dev/md0a: 5.0MB <span class=o>(</span>10224 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2720, 5280, 7840
<span class=c># mount /dev/md0a /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>If unit number is not specified with <code>-u</code>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> automatic allocation to select an unused device. The name of the allocated unit will be output to stdout, such as <span class=filename>md4</span>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> for more details about.</p></div><div class=paragraph><p>While <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> is useful, it takes several command lines to create a file-backed file system. FreeBSD also comes with <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> which automatically configures a <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> disk using <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>, puts a UFS file system on it using <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>, and mounts it using <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. For example, to create and mount the same file system image as above, type the following:</p></div><div class=exampleblock><div class=title>Παράδειγμα 16. Configure and Mount a File-Backed Disk with <code>mdmfs</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdmfs -F newimage -s 5m md0 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>When <code>md</code> is used without a unit number, <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> auto-unit feature to automatically select an unused device. For more details about <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>, refer to its manual page.</p></div></div><div class=sect3><h4 id=disks-md-freebsd5>39.11.2. Memory-Based File System<a class=anchor href=#disks-md-freebsd5></a></h4><div class=paragraph><p>For a memory-based file system, "swap backing" should normally be used. This does not mean that the memory disk will be swapped out to disk by default, but rather that the memory disk will be allocated from a memory pool which can be swapped out to disk if needed. It is also possible to create memory-based disks which are <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> backed, but using large malloc backed memory disks can result in a system panic if the kernel runs out of memory.</p></div><div class=exampleblock><div class=title>Παράδειγμα 17. Creating a New Memory-Based Disk with <code>mdconfig</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t swap -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2752, 5344, 7936
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre></div></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 18. Creating a New Memory-Based Disk with <code>mdmfs</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -s 5m md2 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</code></pre></div></div></div></div></div><div class=sect3><h4 id=_detaching_a_memory_disk_from_the_system>39.11.3. Detaching a Memory Disk from the System<a class=anchor href=#_detaching_a_memory_disk_from_the_system></a></h4><div class=paragraph><p>When a memory-based or file-based file system is no longer in use, its resources should be released back to the system. First, unmount the file system, then use <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> to detach the disk from the system and release the resources.</p></div><div class=paragraph><p>For example, to detach and free all resources used by <span class=filename>/dev/md4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>It is possible to list information about configured <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> devices by running <code>mdconfig -l</code>.</p></div></div></div><div class=sect2><h3 id=snapshots>39.12. File System Snapshots<a class=anchor href=#snapshots></a></h3><div class=paragraph><p>FreeBSD offers a feature in conjunction with <a href=./#soft-updates>Soft Updates</a>: file system snapshots.</p></div><div class=paragraph><p>UFS snapshots allow a user to create images of specified file systems, and treat them as a file. Snapshot files must be created in the file system that the action is performed on, and a user may create no more than 20 snapshots per file system. Active snapshots are recorded in the superblock so they are persistent across unmount and remount operations along with system reboots. When a snapshot is no longer required, it can be removed using <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. While snapshots may be removed in any order, all the used space may not be acquired because another snapshot will possibly claim some of the released blocks.</p></div><div class=paragraph><p>The un-alterable <code>snapshot</code> file flag is set by <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> after initial creation of a snapshot file. <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> makes an exception for snapshot files since it allows them to be removed.</p></div><div class=paragraph><p>Snapshots are created using <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. To place a snapshot of <span class=filename>/var</span> in the file <span class=filename>/var/snapshot/snap</span>, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>Alternatively, use <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> to create the snapshot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>One can find snapshot files on a file system, such as <span class=filename>/var</span>, using <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Once a snapshot has been created, it has several uses:</p></div><div class=ulist><ul><li><p>Some administrators will use a snapshot file for backup purposes, because the snapshot can be transferred to CDs or tape.</p></li><li><p>The file system integrity checker, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, may be run on the snapshot. Assuming that the file system was clean when it was mounted, this should always provide a clean and unchanging result.</p></li><li><p>Running <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> on the snapshot will produce a dump file that is consistent with the file system and the timestamp of the snapshot. <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> can also take a snapshot, create a dump image, and then remove the snapshot in one command by using <code>-L</code>.</p></li><li><p>The snapshot can be mounted as a frozen image of the file system. To <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> the snapshot <span class=filename>/var/snapshot/snap</span> run:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>The frozen <span class=filename>/var</span> is now available through <span class=filename>/mnt</span>. Everything will initially be in the same state it was during the snapshot creation time. The only exception is that any earlier snapshots will appear as zero length files. To unmount the snapshot, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>For more information about <code>softupdates</code> and file system snapshots, including technical papers, visit Marshall Kirk McKusick’s website at <a href=http://www.mckusick.com/>http://www.mckusick.com/</a>.</p></div></div><div class=sect2><h3 id=quotas>39.13. File System Quotas<a class=anchor href=#quotas></a></h3><div class=paragraph><p>Quotas are an optional feature of the operating system that can be used to limit the amount of disk space or the number of files a user or members of a group may allocate on a per-file system basis. This is used most often on timesharing systems where it is desirable to limit the amount of resources any one user or group of users may allocate. This prevents one user or group of users from consuming all of the available disk space.</p></div><div class=sect3><h4 id=_configuring_the_system_to_enable_disk_quotas>39.13.1. Configuring the System to Enable Disk Quotas<a class=anchor href=#_configuring_the_system_to_enable_disk_quotas></a></h4><div class=paragraph><p>Before using disk quotas, quota support must be added to the kernel by adding the following line to the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Before FreeBSD 9.2, the <span class=filename>GENERIC</span> kernel usually did not include this option. <code>sysctl kern.features.ufs_quota</code> can be used to test whether the current kernel supports quotas. If the option is not present, a custom kernel must be compiled. Refer to <a href=./#kernelconfig>Configuring the FreeBSD Kernel</a> for more information on kernel configuration.</p></div><div class=paragraph><p>Next, enable disk quotas in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>quota_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>For finer control over quota startup, an additional configuration variable is available. Normally on bootup, the quota integrity of each file system is checked by <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>. This program insures that the data in the quota database properly reflects the data on the file system. This is a time consuming process that will significantly affect the time the system takes to boot. To skip this step, add this variable to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Finally, edit <span class=filename>/etc/fstab</span> to enable disk quotas on a per-file system basis. This is when user or group quotas can be enabled on the file systems.</p></div><div class=paragraph><p>To enable per-user quotas on a file system, add <code>userquota</code> to the options field in the <span class=filename>/etc/fstab</span> entry for the file system to enable quotas on. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>To enable group quotas, instead use <code>groupquota</code>. To enable both user and group quotas, change the entry as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>By default, the quota files are stored in the root directory of the file system as <span class=filename>quota.user</span> and <span class=filename>quota.group</span>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> for more information. Even though an alternate location for the quota files can be specified, this is not recommended because the various quota utilities do not seem to handle this properly.</p></div><div class=paragraph><p>Once the configuration is complete, reboot the system with the new kernel. <span class=filename>/etc/rc</span> will automatically run the appropriate commands to create the initial quota files for all of the quotas enabled in <span class=filename>/etc/fstab</span>. There is no need to manually create any zero length quota files.</p></div><div class=paragraph><p>In the normal course of operations, there should be no need to manually run <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a>, or <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a>. However, one should read their manual pages to be familiar with their operation.</p></div></div><div class=sect3><h4 id=_setting_quota_limits>39.13.2. Setting Quota Limits<a class=anchor href=#_setting_quota_limits></a></h4><div class=paragraph><p>Once the system has been configured to enable quotas, verify they really are enabled by running:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>There should be a one line summary of disk usage and current quota limits for each file system that quotas are enabled on.</p></div><div class=paragraph><p>The system is now ready to be assigned quota limits with <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div><div class=paragraph><p>Several options are available to enforce limits on the amount of disk space a user or group may allocate, and how many files they may create. Allocations can be limited based on disk space (block quotas), number of files (inode quotas), or a combination of both. Each limits is further broken down into two categories: hard and soft limits.</p></div><div class=paragraph><p>A hard limit may not be exceeded. Once a user reaches a hard limit, no further allocations can be made on that file system by that user. For example, if the user has a hard limit of 500 kbytes on a file system and is currently using 490 kbytes, the user can only allocate an additional 10 kbytes. Attempting to allocate an additional 11 kbytes will fail.</p></div><div class=paragraph><p>Soft limits can be exceeded for a limited amount of time, known as the grace period, which is one week by default. If a user stays over their limit longer than the grace period, the soft limit turns into a hard limit and no further allocations are allowed. When the user drops back below the soft limit, the grace period is reset.</p></div><div class=paragraph><p>The following is an example output from <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>. When <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> is invoked, the editor specified by <code>EDITOR</code> is opened in order to edit the quota limits. The default editor is set to vi.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</pre></div></div><div class=paragraph><p>There are normally two lines for each file system that has quotas enabled. One line represents the block limits and the other represents the inode limits. Change the value to modify the quota limit. For example, to raise this user’s block limit from a soft limit of 50 and a hard limit of 75 to a soft limit of 500 and a hard limit of 600, change:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</pre></div></div><div class=paragraph><p>to:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>The new quota limits take affect upon exiting the editor.</p></div><div class=paragraph><p>Sometimes it is desirable to set quota limits on a range of UIDs. This can be done by passing <code>-p</code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>. First, assign the desired quota limit to a user, then run <code>edquota -p protouser startuid-enduid</code>. For example, if <code>test</code> has the desired quota limits, the following command will duplicate those quota limits for UIDs 10,000 through 19,999:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>For more information, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div></div><div class=sect3><h4 id=_checking_quota_limits_and_disk_usage>39.13.3. Checking Quota Limits and Disk Usage<a class=anchor href=#_checking_quota_limits_and_disk_usage></a></h4><div class=paragraph><p>Either <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> can be used to check quota limits and disk usage. To check individual user or group quotas and disk usage, use <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a>. A user may only examine their own quota and the quota of a group they are a member of. Only the superuser may view all user and group quotas. To get a summary of all quotas and disk usage for file systems with quotas enabled, use <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a>.</p></div><div class=paragraph><p>The following is sample output from <code>quota -v</code> for a user that has quota limits on two file systems.</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>In this example, the user is currently 15 kbytes over the soft limit of 50 kbytes on <span class=filename>/usr</span> and has 5 days of grace period left. The asterisk <code>*</code> indicates that the user is currently over the quota limit.</p></div><div class=paragraph><p>Normally, file systems that the user is not using any disk space on will not show in the output of <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a>, even if the user has a quota limit assigned for that file system. Use <code>-v</code> to display those file systems, such as <span class=filename>/usr/var</span> in the above example.</p></div></div><div class=sect3><h4 id=_quotas_over_nfs>39.13.4. Quotas over NFS<a class=anchor href=#_quotas_over_nfs></a></h4><div class=paragraph><p>Quotas are enforced by the quota subsystem on the NFS server. The <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> daemon makes quota information available to <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> on NFS clients, allowing users on those machines to see their quota statistics.</p></div><div class=paragraph><p>Enable <code>rpc.rquotad</code> in <span class=filename>/etc/inetd.conf</span> like so:</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>Now restart <code>inetd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div></div><div class=sect2><h3 id=disks-encrypting>39.14. Encrypting Disk Partitions<a class=anchor href=#disks-encrypting></a></h3><div class=paragraph><p>FreeBSD offers excellent online protections against unauthorized data access. File permissions and <a href=./#mac>Mandatory Access Control</a> (MAC) help prevent unauthorized users from accessing data while the operating system is active and the computer is powered up. However, the permissions enforced by the operating system are irrelevant if an attacker has physical access to a computer and can move the computer’s hard drive to another system to copy and analyze the data.</p></div><div class=paragraph><p>Regardless of how an attacker may have come into possession of a hard drive or powered-down computer, both the GEOM Based Disk Encryption (<code>gbde</code>) and <code>geli</code> cryptographic subsystems in FreeBSD are able to protect the data on the computer’s file systems against even highly-motivated attackers with significant resources. Unlike cumbersome encryption methods that encrypt only individual files, <code>gbde</code> and <code>geli</code> transparently encrypt entire file systems. No cleartext ever touches the hard drive’s platter.</p></div><div class=sect3><h4 id=_disk_encryption_with_gbde>39.14.1. Disk Encryption with gbde<a class=anchor href=#_disk_encryption_with_gbde></a></h4><div class="olist arabic procedure"><ol class=arabic><li><p>Configuring gbde requires superuser privileges.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su -
Password:</code></pre></div></div></li><li><p>If using a custom kernel configuration file, ensure it contains this line:</p><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>If the kernel already contains this support, use <code>kldload</code> to load <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_bde</span></code></pre></div></div></li></ol></div><div class=sect4><h5 id=_preparing_the_encrypted_hard_drive>39.14.1.1. Preparing the Encrypted Hard Drive<a class=anchor href=#_preparing_the_encrypted_hard_drive></a></h5><div class=paragraph><p>The following example demonstrates adding a new hard drive to a system that will hold a single encrypted partition. This partition will be mounted as <span class=filename>/private</span>. gbde can also be used to encrypt <span class=filename>/home</span> and <span class=filename>/var/mail</span>, but this requires more complex instructions which exceed the scope of this introduction.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Add the New Hard Drive</p><div class=paragraph><p>Install the new drive to the system as explained in <a href=#disks-adding>Adding Disks</a>. For the purposes of this example, a new hard drive partition has been added as <span class=filename>/dev/ad4s1c</span> and <span class=filename>/dev/ad0s1*</span> represents the existing standard FreeBSD partitions.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Create a Directory to Hold <code>gbde</code> Lock Files</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>The gbde lock file contains information that gbde requires to access encrypted partitions. Without access to the lock file, gbde will not be able to decrypt the data contained in the encrypted partition without significant manual intervention which is not supported by the software. Each encrypted partition uses a separate lock file.</p></div></li><li><p>Initialize the <code>gbde</code> Partition</p><div class=paragraph><p>A gbde partition must be initialized before it can be used. This initialization needs to be performed only once:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> will open the default editor, in order to set various configuration options in a template. For use with UFS1 or UFS2, set the sector_size to 2048:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size	=	2048
[...]</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> will ask the user twice to type the passphrase used to secure the data. The passphrase must be the same both times. The ability of gbde to protect data depends entirely on the quality of the passphrase. For tips on how to select a secure passphrase that is easy to remember, see the <a href=http://world.std.com/~reinhold/diceware.html>Diceware Passphrase</a> website.</p></div><div class=paragraph><p><code>gbde init</code> creates a lock file for the gbde partition. In this example, it is stored as <span class=filename>/etc/gbde/ad4s1c.lock</span>. gbde lock files must end in ".lock" in order to be correctly detected by the <span class=filename>/etc/rc.d/gbde</span> start up script.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>gbde lock files <em>must</em> be backed up together with the contents of any encrypted partitions. While deleting a lock file alone cannot prevent a determined attacker from decrypting a gbde partition, without the lock file, the legitimate owner will be unable to access the data on the encrypted partition without a significant amount of work that is totally unsupported by <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>.</p></div></td></tr></tbody></table></div></li><li><p>Attach the Encrypted Partition to the Kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p>This command will prompt to input the passphrase that was selected during the initialization of the encrypted partition. The new encrypted device will appear in <span class=filename>/dev</span> as <span class=filename>/dev/device_name.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Create a File System on the Encrypted Device</p><div class=paragraph><p>Once the encrypted device has been attached to the kernel, a file system can be created on the device using <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. This example creates a UFS2 file system with soft updates enabled.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ad4s1c.bde</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> must be performed on an attached gbde partition which is identified by a <span class=filename>*.bde</span> extension to the device name.</p></div></td></tr></tbody></table></div></li><li><p>Mount the Encrypted Partition</p><div class=paragraph><p>Create a mount point for the encrypted file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span></code></pre></div></div><div class=paragraph><p>Mount the encrypted file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Verify That the Encrypted File System is Available</p><div class=paragraph><p>The encrypted file system should now be visible to <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> and be available for use.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div><div class=sect4><h5 id=_mounting_existing_encrypted_file_systems>39.14.1.2. Mounting Existing Encrypted File Systems<a class=anchor href=#_mounting_existing_encrypted_file_systems></a></h5><div class=paragraph><p>After each boot, any encrypted file systems must be re-attached to the kernel, checked for errors, and mounted, before the file systems can be used. The required commands must be executed as <code>root</code>.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Attach the <code>gbde</code> Partition to the Kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p>This command will prompt for the passphrase that was selected during initialization of the encrypted gbde partition.</p></div></li><li><p>Check the File System for Errors</p><div class=paragraph><p>Since encrypted file systems cannot yet be listed in <span class=filename>/etc/fstab</span> for automatic mounting, the file systems must be checked for errors by running <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> manually before mounting:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p -t ffs /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Mount the Encrypted File System</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div><div class=paragraph><p>The encrypted file system is now available for use.</p></div></li></ol></div><div class=sect5><h6 id=_automatically_mounting_encrypted_partitions>39.14.1.2.1. Automatically Mounting Encrypted Partitions<a class=anchor href=#_automatically_mounting_encrypted_partitions></a></h6><div class=paragraph><p>It is possible to create a script to automatically attach, check, and mount an encrypted partition, but for security reasons the script should not contain the <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> password. Instead, it is recommended that such scripts be run manually while providing the password via the console or <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>.</p></div><div class=paragraph><p>As an alternative, an <span class=filename>rc.d</span> script is provided. Arguments for this script can be passed via <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;
gbde_lockdir=&#34;/etc/gbde&#34;</pre></div></div><div class=paragraph><p>This requires that the gbde passphrase be entered at boot time. After typing the correct passphrase, the gbde encrypted partition will be mounted automatically. This can be useful when using gbde on laptops.</p></div></div></div><div class=sect4><h5 id=_cryptographic_protections_employed_by_gbde>39.14.1.3. Cryptographic Protections Employed by <code>gbde</code><a class=anchor href=#_cryptographic_protections_employed_by_gbde></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> encrypts the sector payload using 128-bit AES in CBC mode. Each sector on the disk is encrypted with a different AES key. For more information on the cryptographic design, including how the sector keys are derived from the user-supplied passphrase, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div></div><div class=sect4><h5 id=_compatibility_issues>39.14.1.4. Compatibility Issues<a class=anchor href=#_compatibility_issues></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> is incompatible with gbde-encrypted devices. All <span class=filename>*.bde</span> devices must be detached from the kernel before starting <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> or it will crash during its initial probing for devices. To detach the encrypted device used in the example, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div></div></div><div class=sect3><h4 id=_disk_encryption_with_geli>39.14.2. Disk Encryption with <code>geli</code><a class=anchor href=#_disk_encryption_with_geli></a></h4><div class=paragraph><p>An alternative cryptographic GEOM class is available through <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>. <code>geli</code> differs from <code>gbde</code>; offers different features, and uses a different scheme for doing cryptographic work.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> provides the following features:</p></div><div class=ulist><ul><li><p>Utilizes the <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a> framework and, when cryptographic hardware is available, <code>geli</code> uses it automatically.</p></li><li><p>Supports multiple cryptographic algorithms such as AES, Blowfish, and 3DES.</p></li><li><p>Allows the root partition to be encrypted. The passphrase used to access the encrypted root partition will be requested during system boot.</p></li><li><p>Allows the use of two independent keys such as a "key" and a "company key".</p></li><li><p><code>geli</code> is fast as it performs simple sector-to-sector encryption.</p></li><li><p>Allows backup and restore of master keys. If a user destroys their keys, it is still possible to get access to the data by restoring keys from the backup.</p></li><li><p>Allows a disk to attach with a random, one-time key which is useful for swap partitions and temporary file systems.</p></li></ul></div><div class=paragraph><p>More <code>geli</code> features can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></div><div class=paragraph><p>This section describes how to enable support for <code>geli</code> in the FreeBSD kernel and explains how to create and use a <code>geli</code> encryption provider.</p></div><div class=paragraph><p>Superuser privileges are required since modifications to the kernel are necessary.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Adding <code>geli</code> Support to the Kernel</p><div class=paragraph><p>For a custom kernel, ensure the kernel configuration file contains these lines:</p></div><div class="literalblock programlisting"><div class=content><pre>options GEOM_ELI
device crypto</pre></div></div><div class=paragraph><p>Alternatively, the <code>geli</code> module can be loaded at boot time by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_eli_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> should now be supported by the kernel.</p></div></li><li><p>Generating the Master Key</p><div class=paragraph><p>The following example describes how to generate a key file which will be used as part of the master key for the encrypted provider mounted under <span class=filename>/private</span>. The key file will provide some random data used to encrypt the master key. The master key will also be protected by a passphrase. The provider’s sector size will be 4kB. The example will describe how to attach to the <code>geli</code> provider, create a file system on it, mount it, work with it, and finally, how to detach it.</p></div><div class=paragraph><p>It is recommended to use a bigger sector size, such as 4kB, for better performance.</p></div><div class=paragraph><p>The master key will be protected with a passphrase and the data source for the key file will be <span class=filename>/dev/random</span>. The sector size of the provider <span class=filename>/dev/da2.eli</span> will be 4kB.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class=c># geli init -s 4096 -K /root/da2.key /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre></div></div><div class=paragraph><p>It is not mandatory to use both a passphrase and a key file as either method of securing the master key can be used in isolation.</p></div><div class=paragraph><p>If the key file is given as "-", standard input will be used. This example shows how more than one key file can be used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre></div></div></li><li><p>Attaching the Provider with the Generated Key</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre></div></div><div class=paragraph><p>The new plaintext device will be named <span class=filename>/dev/da2.eli</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre></div></div></li><li><p>Creating the New File System</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class=c># newfs /dev/da2.eli</span>
<span class=c># mount /dev/da2.eli /private</span></code></pre></div></div><div class=paragraph><p>The encrypted file system should now be visible to <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> and be available for use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre></div></div></li><li><p>Unmounting and Detaching the Provider</p><div class=paragraph><p>Once the work on the encrypted partition is done, and the <span class=filename>/private</span> partition is no longer needed, it is prudent to consider unmounting and detaching the <code>geli</code> encrypted partition from the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /private</span>
<span class=c># geli detach da2.eli</span></code></pre></div></div></li></ol></div><div class=paragraph><p>More information about the use of <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> can be found in its manual page.</p></div><div class=sect4><h5 id=_using_the_geli_rc_d_script>39.14.2.1. Using the <span class=filename>geli</span> <span class=filename>rc.d</span> Script<a class=anchor href=#_using_the_geli_rc_d_script></a></h5><div class=paragraph><p><code>geli</code> comes with a <span class=filename>rc.d</span> script which can be used to simplify the usage of <code>geli</code>. An example of configuring <code>geli</code> through <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> follows:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-p -k /root/da2.key&#34;</pre></div></div><div class=paragraph><p>This configures <span class=filename>/dev/da2</span> as a <code>geli</code> provider of which the master key file is located in <span class=filename>/root/da2.key</span>. <code>geli</code> will not use a passphrase when attaching to the provider if <code>-P</code> was given during the <code>geli init</code> phase. The system will detach the <code>geli</code> provider from the kernel before the system shuts down.</p></div><div class=paragraph><p>More information about configuring <span class=filename>rc.d</span> is provided in the <a href=./#configtuning-rcd>rc.d</a> section of the Handbook.</p></div></div></div></div><div class=sect2><h3 id=swap-encrypting>39.15. Encrypting Swap Space<a class=anchor href=#swap-encrypting></a></h3><div class=paragraph><p>Like the encryption of disk partitions, encryption of swap space is used to protect sensitive information. Consider an application that deals with passwords. As long as these passwords stay in physical memory, these passwords will not be written to disk and be cleared after a reboot. If FreeBSD starts swapping out memory pages to free space for other applications, the passwords may be written to the disk platters unencrypted. Encrypting swap space can be a solution for this scenario.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> encryption systems may be used for swap encryption. Both systems use the <span class=filename>encswap</span> <a href=./#configtuning-rcd>rc.d</a> script.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For the remainder of this section, <span class=filename>ad0s1b</span> will be the swap partition.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Swap partitions are not encrypted by default and should be cleared of any sensitive data before continuing. To overwrite the current swap parition with random garbage, execute the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/ad0s1b bs=1m</span></code></pre></div></div><div class=sect3><h4 id=_swap_encryption_with_gbde8>39.15.1. Swap Encryption with <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a><a class=anchor href=#_swap_encryption_with_gbde8></a></h4><div class=paragraph><p>The <code>.bde</code> suffix should be added to the device in the respective <span class=filename>/etc/fstab</span> swap line:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ad0s1b.bde		none		swap	sw		0	0</pre></div></div></div><div class=sect3><h4 id=_swap_encryption_with_geli8>39.15.2. Swap Encryption with <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a><a class=anchor href=#_swap_encryption_with_geli8></a></h4><div class=paragraph><p>The procedure for instead using <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> for swap encryption is similar to that of using <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>. The <code>.eli</code> suffix should be added to the device in the respective <span class=filename>/etc/fstab</span> swap line:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ad0s1b.eli		none		swap	sw		0	0</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> uses the AES algorithm with a key length of 128 bit by default. These defaults can be altered by using <code>geli_swap_flags</code> in <span class=filename>/etc/rc.conf</span>. The following line tells the <span class=filename>encswap</span> rc.d script to create <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> swap partitions using the Blowfish algorithm with a key length of 128 bits and a sectorsize of 4 kilobytes, and sets "detach on last close":</p></div><div class="literalblock programlisting"><div class=content><pre>geli_swap_flags=&#34;-e blowfish -l 128 -s 4096 -d&#34;</pre></div></div><div class=paragraph><p>Refer to the description of <code>onetime</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> for a list of possible options.</p></div></div><div class=sect3><h4 id=_encrypted_swap_verification>39.15.3. Encrypted Swap Verification<a class=anchor href=#_encrypted_swap_verification></a></h4><div class=paragraph><p>Once the system has rebooted, proper operation of the encrypted swap can be verified using <code>swapinfo</code>.</p></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> is being used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%</code></pre></div></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> is being used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%</code></pre></div></div></div></div><div class=sect2><h3 id=disks-hast>39.16. Highly Available Storage (HAST)<a class=anchor href=#disks-hast></a></h3><div class=sect3><h4 id=_synopsis>39.16.1. Synopsis<a class=anchor href=#_synopsis></a></h4><div class=paragraph><p>High availability is one of the main requirements in serious business applications and highly-available storage is a key component in such environments. Highly Available STorage, or HAST, was developed by Paweł Jakub Dawidek &lt;<a href=mailto:pjd@FreeBSD.org>pjd@FreeBSD.org</a>> as a framework which allows transparent storage of the same data across several physically separated machines connected by a TCP/IP network. HAST can be understood as a network-based RAID1 (mirror), and is similar to the DRBD® storage system known from the GNU/Linux® platform. In combination with other high-availability features of FreeBSD like CARP, HAST makes it possible to build a highly-available storage cluster that is resistant to hardware failures.</p></div><div class=paragraph><p>After reading this section, you will know:</p></div><div class=ulist><ul><li><p>What HAST is, how it works and which features it provides.</p></li><li><p>How to set up and use HAST on FreeBSD.</p></li><li><p>How to integrate CARP and <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> to build a robust storage system.</p></li></ul></div><div class=paragraph><p>Before reading this section, you should:</p></div><div class=ulist><ul><li><p>Understand UNIX® and <a href=./#basics>FreeBSD Basics</a>.</p></li><li><p>Know how to <a href=./#config-tuning>configure</a> network interfaces and other core FreeBSD subsystems.</p></li><li><p>Have a good understanding of <a href=./#network-communication>FreeBSD networking</a>.</p></li></ul></div><div class=paragraph><p>The HAST project was sponsored by The FreeBSD Foundation with support from <a href=http://www.omc.net/>OMCnet Internet Service GmbH</a> and <a href=http://www.transip.nl/>TransIP BV</a>.</p></div></div><div class=sect3><h4 id=_hast_features>39.16.2. HAST Features<a class=anchor href=#_hast_features></a></h4><div class=paragraph><p>The main features of the HAST system are:</p></div><div class=ulist><ul><li><p>Can be used to mask I/O errors on local hard drives.</p></li><li><p>File system agnostic as it works with any file system supported by FreeBSD.</p></li><li><p>Efficient and quick resynchronization, synchronizing only blocks that were modified during the downtime of a node.</p></li><li><p>Can be used in an already deployed environment to add additional redundancy.</p></li><li><p>Together with CARP, Heartbeat, or other tools, it can be used to build a robust and durable storage system.</p></li></ul></div></div><div class=sect3><h4 id=_hast_operation>39.16.3. HAST Operation<a class=anchor href=#_hast_operation></a></h4><div class=paragraph><p>As HAST provides a synchronous block-level replication of any storage media to several machines, it requires at least two physical machines: the <code>primary</code>, also known as the <code>master</code> node, and the <code>secondary</code> or <code>slave</code> node. These two machines together are referred to as a cluster.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>HAST is currently limited to two cluster nodes in total.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Since HAST works in a primary-secondary configuration, it allows only one of the cluster nodes to be active at any given time. The <code>primary</code> node, also called <code>active</code>, is the one which will handle all the I/O requests to HAST-managed devices. The <code>secondary</code> node is automatically synchronized from the <code>primary</code> node.</p></div><div class=paragraph><p>The physical components of the HAST system are:</p></div><div class=ulist><ul><li><p>local disk on primary node, and</p></li><li><p>disk on remote, secondary node.</p></li></ul></div><div class=paragraph><p>HAST operates synchronously on a block level, making it transparent to file systems and applications. HAST provides regular GEOM providers in <span class=filename>/dev/hast/</span> for use by other tools or applications, thus there is no difference between using HAST-provided devices and raw disks or partitions.</p></div><div class=paragraph><p>Each write, delete, or flush operation is sent to the local disk and to the remote disk over TCP/IP. Each read operation is served from the local disk, unless the local disk is not up-to-date or an I/O error occurs. In such case, the read operation is sent to the secondary node.</p></div><div class=sect4><h5 id=_synchronization_and_replication_modes>39.16.3.1. Synchronization and Replication Modes<a class=anchor href=#_synchronization_and_replication_modes></a></h5><div class=paragraph><p>HAST tries to provide fast failure recovery. For this reason, it is very important to reduce synchronization time after a node’s outage. To provide fast synchronization, HAST manages an on-disk bitmap of dirty extents and only synchronizes those during a regular synchronization, with an exception of the initial sync.</p></div><div class=paragraph><p>There are many ways to handle synchronization. HAST implements several replication modes to handle different synchronization methods:</p></div><div class=ulist><ul><li><p><em>memsync</em>: report write operation as completed when the local write operation is finished and when the remote node acknowledges data arrival, but before actually storing the data. The data on the remote node will be stored directly after sending the acknowledgement. This mode is intended to reduce latency, but still provides very good reliability.</p></li><li><p><em>fullsync</em>: report write operation as completed when local write completes and when remote write completes. This is the safest and the slowest replication mode. This mode is the default.</p></li><li><p><em>async</em>: report write operation as completed when local write completes. This is the fastest and the most dangerous replication mode. It should be used when replicating to a distant node where latency is too high for other modes.</p></li></ul></div></div></div><div class=sect3><h4 id=_hast_configuration>39.16.4. HAST Configuration<a class=anchor href=#_hast_configuration></a></h4><div class=paragraph><p>HAST requires <code>GEOM_GATE</code> support which is not present in the default <code>GENERIC</code> kernel. However, the <code>geom_gate.ko</code> loadable module is available in the default FreeBSD installation. Alternatively, to build <code>GEOM_GATE</code> support into the kernel statically, add this line to the custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_GATE</pre></div></div><div class=paragraph><p>The HAST framework consists of several parts from the operating system’s point of view:</p></div><div class=ulist><ul><li><p>the <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> daemon responsible for data synchronization,</p></li><li><p>the <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> userland management utility,</p></li><li><p>and the <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a> configuration file.</p></li></ul></div><div class=paragraph><p>The following example describes how to configure two nodes in <code>master</code>-<code>slave</code> / <code>primary</code>-<code>secondary</code> operation using HAST to replicate the data between the two. The nodes will be called <code>hasta</code> with an IP address of <em>172.16.0.1</em> and <code>hastb</code> with an IP of address <em>172.16.0.2</em>. Both nodes will have a dedicated hard drive <span class=filename>/dev/ad6</span> of the same size for HAST operation. The HAST pool, sometimes also referred to as a resource or the GEOM provider in <span class=filename>/dev/hast/</span>, will be called <span class=filename>test</span>.</p></div><div class=paragraph><p>Configuration of HAST is done using <span class=filename>/etc/hast.conf</span>. This file should be the same on both nodes. The simplest configuration possible is:</p></div><div class="literalblock programlisting"><div class=content><pre>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre></div></div><div class=paragraph><p>For more advanced configuration, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>It is also possible to use host names in the <code>remote</code> statements. In such a case, make sure that these hosts are resolvable and are defined in <span class=filename>/etc/hosts</span> or in the local DNS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Now that the configuration exists on both nodes, the HAST pool can be created. Run these commands on both nodes to place the initial metadata onto the local disk and to start <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl create test</span>
<span class=c># service hastd onestart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is <em>not</em> possible to use GEOM providers with an existing file system or to convert an existing storage to a HAST-managed pool. This procedure needs to store some metadata on the provider and there will not be enough required space available on an existing provider.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A HAST node’s <code>primary</code> or <code>secondary</code> role is selected by an administrator, or software like Heartbeat, using <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a>. On the primary node, <code>hasta</code>, issue this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role primary test</span></code></pre></div></div><div class=paragraph><p>Similarly, run this command on the secondary node, <code>hastb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role secondary test</span></code></pre></div></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>When the nodes are unable to communicate with each other, and both are configured as primary nodes, the condition is called <code>split-brain</code>. To troubleshoot this situation, follow the steps described in <a href=#disks-hast-sb>Recovering from the Split-brain Condition</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Verify the result by running <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> on each node:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl status test</span></code></pre></div></div><div class=paragraph><p>The important text is the <code>status</code> line, which should say <code>complete</code> on each of the nodes. If it says <code>degraded</code>, something went wrong. At this point, the synchronization between the nodes has already started. The synchronization completes when <code>hastctl status</code> reports 0 bytes of <code>dirty</code> extents.</p></div><div class=paragraph><p>The next step is to create a filesystem on the <span class=filename>/dev/hast/test</span> GEOM provider and mount it. This must be done on the <code>primary</code> node, as <span class=filename>/dev/hast/test</span> appears only on the <code>primary</code> node. Creating the filesystem can take a few minutes, depending on the size of the hard drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/hast/test</span>
<span class=c># mkdir /hast/test</span>
<span class=c># mount /dev/hast/test /hast/test</span></code></pre></div></div><div class=paragraph><p>Once the HAST framework is configured properly, the final step is to make sure that HAST is started automatically during system boot. Add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hastd_enable=&#34;YES&#34;</pre></div></div><div class=sect4><h5 id=_failover_configuration>39.16.4.1. Failover Configuration<a class=anchor href=#_failover_configuration></a></h5><div class=paragraph><p>The goal of this example is to build a robust storage system which is resistant to the failure of any given node. The scenario is that a <code>primary</code> node of the cluster fails. If this happens, the <code>secondary</code> node is there to take over seamlessly, check and mount the file system, and continue to work without missing a single bit of data.</p></div><div class=paragraph><p>To accomplish this task, another FreeBSD feature, CARP, provides for automatic failover on the IP layer. CARP (Common Address Redundancy Protocol) allows multiple hosts on the same network segment to share an IP address. Set up CARP on both nodes of the cluster according to the documentation available in <a href=./#carp>Common Access Redundancy Protocol (CARP)</a>. After setup, each node will have its own <span class=filename>carp0</span> interface with a shared IP address of <em>172.16.0.254</em>. The primary HAST node of the cluster must be the master CARP node.</p></div><div class=paragraph><p>The HAST pool created in the previous section is now ready to be exported to the other hosts on the network. This can be accomplished by exporting it through NFS or Samba, using the shared IP address <em>172.16.0.254</em>. The only problem which remains unresolved is an automatic failover should the primary node fail.</p></div><div class=paragraph><p>In the event of CARP interfaces going up or down, the FreeBSD operating system generates a <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> event, making it possible to watch for state changes on the CARP interfaces. A state change on the CARP interface is an indication that one of the nodes failed or came back online. These state change events make it possible to run a script which will automatically handle the HAST failover.</p></div><div class=paragraph><p>To be able to catch state changes on the CARP interfaces, add this configuration to <span class=filename>/etc/devd.conf</span> on each node:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_UP&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch master&#34;;
};

notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_DOWN&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch slave&#34;;
};</pre></div></div><div class=paragraph><p>Restart <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> on both nodes to put the new configuration into effect:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>When the <span class=filename>carp0</span> interface state changes by going up or down , the system generates a notification, allowing the <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> subsystem to run an arbitrary script, in this case <span class=filename>/usr/local/sbin/carp-hast-switch</span>. This script handles the automatic failover. For further clarification about the above <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> configuration, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>An example of such a script could be:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources=&#34;test&#34;

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log=&#34;local0.debug&#34;
name=&#34;carp-hast&#34;

# end of user configurable stuff

case &#34;$1&#34; in
	master)
		logger -p $log -t $name &#34;Switching to primary provider for ${resources}.&#34;
		sleep ${delay}

		# Wait for any &#34;hastd secondary&#34; processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf &#34;hastd: ${disk} \(secondary\)&#34; &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to change role to primary for resource ${disk}.&#34;
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c &#34;/dev/hast/${disk}&#34; ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c &#34;/dev/hast/${disk}&#34; ]; then
				logger -p $log -t $name &#34;GEOM provider /dev/hast/${disk} did not appear.&#34;
				exit 1
			fi
		done

		logger -p $log -t $name &#34;Role for HAST resources ${resources} switched to primary.&#34;

		logger -p $log -t $name &#34;Mounting disks.&#34;
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name &#34;Switching to secondary provider for ${resources}.&#34;

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q &#34;^/dev/hast/${disk} on &#34;
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to switch role to secondary for resource ${disk}.&#34;
				exit 1
			fi
			logger -p $log -t $name &#34;Role switched to secondary for resource ${disk}.&#34;
		done
	;;
esac</pre></div></div><div class=paragraph><p>In a nutshell, the script takes these actions when a node becomes <code>master</code> / <code>primary</code>:</p></div><div class=ulist><ul><li><p>Promotes the HAST pools to primary on a given node.</p></li><li><p>Checks the file system under the HAST pool.</p></li><li><p>Mounts the pools at an appropriate place.</p></li></ul></div><div class=paragraph><p>When a node becomes <code>backup</code> / <code>secondary</code>:</p></div><div class=ulist><ul><li><p>Unmounts the HAST pools.</p></li><li><p>Degrades the HAST pools to secondary.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Keep in mind that this is just an example script which serves as a proof of concept. It does not handle all the possible scenarios and can be extended or altered in any way, for example, to start/stop required services.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>For this example, a standard UFS file system was used. To reduce the time needed for recovery, a journal-enabled UFS or ZFS file system can be used instead.</p></div></td></tr></tbody></table></div><div class=paragraph><p>More detailed information with additional examples can be found in the <a href=http://wiki.FreeBSD.org/HAST>HAST Wiki</a> page.</p></div></div></div><div class=sect3><h4 id=_troubleshooting>39.16.5. Troubleshooting<a class=anchor href=#_troubleshooting></a></h4><div class=sect4><h5 id=_general_troubleshooting_tips>39.16.5.1. General Troubleshooting Tips<a class=anchor href=#_general_troubleshooting_tips></a></h5><div class=paragraph><p>HAST should generally work without issues. However, as with any other software product, there may be times when it does not work as supposed. The sources of the problems may be different, but the rule of thumb is to ensure that the time is synchronized between all nodes of the cluster.</p></div><div class=paragraph><p>When troubleshooting HAST problems, the debugging level of <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> should be increased by starting <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> with <code>-d</code>. This argument may be specified multiple times to further increase the debugging level. A lot of useful information may be obtained this way. Consider also using <code>-F</code>, which starts <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> in the foreground.</p></div></div><div class=sect4><h5 id=disks-hast-sb>39.16.5.2. Recovering from the Split-brain Condition<a class=anchor href=#disks-hast-sb></a></h5><div class=paragraph><p><code>Split-brain</code> is when the nodes of the cluster are unable to communicate with each other, and both are configured as primary. This is a dangerous condition because it allows both nodes to make incompatible changes to the data. This problem must be corrected manually by the system administrator.</p></div><div class=paragraph><p>The administrator must decide which node has more important changes (or merge them manually) and let HAST perform full synchronization of the node which has the broken data. To do this, issue these commands on the node which needs to be resynchronized:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role init &lt;resource&gt;</span>
<span class=c># hastctl create &lt;resource&gt;</span>
<span class=c># hastctl role secondary &lt;resource&gt;</span></code></pre></div></div></div></div></div></div></div><div class=sect1><h2 id=geom>Chapter 40. GEOM: Διαχείριση Συστοιχιών Δίσκων<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=GEOM-synopsis>40.1. Σύνοψη<a class=anchor href=#GEOM-synopsis></a></h3><div class=paragraph><p>Το κεφάλαιο αυτό καλύπτει τη χρήση των δίσκων κάτω από το πλαίσιο λειτουργιών GEOM στο FreeBSD. Περιλαμβάνει τα κυριότερα προγράμματα ελέγχου RAID των οποίων οι ρυθμίσεις βασίζονται στο πλαίσιο GEOM. Το κεφάλαιο αυτό δεν αναλύει σε βάθος τον τρόπο με τον οποίο το GEOM χειρίζεται ή ελέγχει λειτουργίες Εισόδου / Εξόδου (IO), το υποσύστημα που βρίσκεται κάτω από αυτό, ή τον κώδικα του. Οι πληροφορίες αυτές παρέχονται από τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a> καθώς και από τις αναφορές που περιέχει σε άλλες σχετικές σελίδες. Επίσης το κεφάλαιο αυτό δεν αποτελεί καθοριστικό οδηγό για όλες τις ρυθμίσεις του RAID. Θα συζητηθούν μόνο οι καταστάσεις λειτουργίας του RAID που υποστηρίζονται από το GEOM.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Το είδος της υποστήριξης RAID που είναι διαθέσιμο μέσω του GEOM.</p></li><li><p>Πως να χρησιμοποιήσετε τα βασικά βοηθητικά προγράμματα για την ρύθμιση, συντήρηση και διαχείριση των διαφόρων επιπέδων RAID.</p></li><li><p>Πως να δημιουργήσετε mirror ή stripe, να κρυπτογραφήσετε, και να συνδέσετε δίσκους με το GEOM, μέσω μιας απομακρυσμένης σύνδεσης.</p></li><li><p>Πως να αντιμετωπίσετε προβλήματα δίσκων που χρησιμοποιούν το πλαίσιο λειτουργιών GEOM.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε πως μεταχειρίζεται το FreeBSD τις συσκευές δίσκων (<a href=./#disks>Αποθηκευτικά Μέσα</a>).</p></li><li><p>Να γνωρίζετε πως θα ρυθμίσετε και θα εγκαταστήσετε ένα νέο πυρήνα στο FreeBSD (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=GEOM-intro>40.2. Εισαγωγή στο GEOM<a class=anchor href=#GEOM-intro></a></h3><div class=paragraph><p>Το GEOM επιτρέπει την πρόσβαση και τον έλεγχο σε κλάσεις - όπως την Κεντρική Εγγραφή Εκκίνησης (Master Boot Record), τα BSD labels, κ.α. - μέσω της χρήσης παροχέων, ή μέσω ειδικών αρχείων στον κατάλογο <span class=filename>/dev</span>. Το GEOM υποστηρίζει διάφορες διατάξεις RAID και παρέχει διάφανη πρόσβαση στο λειτουργικό σύστημα και τα βοηθητικά του προγράμματα.</p></div></div><div class=sect2><h3 id=GEOM-striping>40.3. RAID0 - Striping<a class=anchor href=#GEOM-striping></a></h3><div class=paragraph><p>Το striping είναι μια μέθοδος που συνδυάζει διαφορετικούς φυσικούς δίσκους σε ένα μοναδικό λογικό τόμο. Σε πολλές περιπτώσεις, αυτό γίνεται με την βοήθεια εξειδικευμένου υλικού (ελεγκτών). Το υποσύστημα δίσκων GEOM παρέχει υποστήριξη μέσω λογισμικού για τη διάταξη RAID0, η οποία είναι γνωστή και ως striping.</p></div><div class=paragraph><p>Σε ένα σύστημα RAID0, τα δεδομένα χωρίζονται σε blocks τα οποία γράφονται τμηματικά σε όλους τους δίσκους που αποτελούν τη συστοιχία. Αντί να χρειάζεται να περιμένετε το σύστημα να γράψει 256k δεδομένων σε ένα δίσκο, ένα σύστημα RAID0 μπορεί να γράψει ταυτόχρονα 64k σε καθένα από τους τέσσερις δίσκους μιας συστοιχίας, προσφέροντας έτσι εξαιρετική απόδοση εισόδου/εξόδου (I/O). Η απόδοση αυτή μπορεί να αυξηθεί περισσότερο, με τη χρήση πολλαπλών ελεγκτών δίσκων.</p></div><div class=paragraph><p>Κάθε δίσκος σε ένα stripe RAID0 πρέπει να είναι του ίδιου μεγέθους, καθώς οι αιτήσεις I/O μοιράζονται όσο αφορά την ανάγνωση και εγγραφή, σε πολλούς παράλληλους δίσκους.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Διάγραμμα Disk Striping"></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Δημιουργία Stripe από μη-Διαμορφωμένους ATA Δίσκους</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Φορτώστε το άρθρωμα <span class=filename>geom_stripe.ko</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Εξασφαλίστε ότι υπάρχει κατάλληλο σημείο προσάρτησης. Αν ο τόμος πρόκειται να γίνει κατάτμηση root, προσαρτήστε τον προσωρινά σε κάποιο άλλο σημείο προσάρτησης, όπως το <span class=filename>/mnt</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt</span></code></pre></div></div></li><li><p>Καθορίστε τα ονόματα των συσκευών για τους δίσκους που πρόκειται να γίνουν stripe, και δημιουργήστε τη νέα συσκευή stripe. Για παράδειγμα, για να δημιουργήσετε ένα stripe από δύο αχρησιμοποίητους και χωρίς κατατμήσεις δίσκους ATA, όπως π.χ. τους <span class=filename>/dev/ad2</span> και <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre></div></div></li><li><p>Γράψτε ένα τυποποιημένο label (πίνακα κατατμήσεων) στο νέο τόμο, και εγκαταστήστε τον προεπιλεγμένο κώδικα εκκίνησης (bootstrap):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>Η διαδικασία αυτή θα δημιουργήσει τη συσκευή <span class=filename>st0</span>, καθώς και δύο ακόμα συσκευές στον κατάλογο <span class=filename>/dev/stripe</span>. Οι συσκευές αυτές θα ονομάζονται <span class=filename>st0a</span> και <span class=filename>st0c</span>. Στο σημείο αυτό, μπορείτε πλέον να δημιουργήσετε σύστημα αρχείων στη συσκευή <span class=filename>st0a</span> χρησιμοποιώντας το βοηθητικό πρόγραμμα <code>newfs</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Θα δείτε μια μεγάλη σειρά αριθμών να περνά γρήγορα από την οθόνη σας, και μετά από λίγα δευτερόλεπτα η διαδικασία θα έχει ολοκληρωθεί. Ο τόμος θα έχει δημιουργηθεί και θα είναι έτοιμος για προσάρτηση.</p></div></li></ol></div></div></div><div class=paragraph><p>Για να προσαρτήσετε χειροκίνητα το stripe που δημιουργήσατε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div><div class=paragraph><p>Για να γίνεται αυτόματα η προσάρτηση αυτού του συστήματος αρχείων κατά την διαδικασία εκκίνησης, τοποθετήστε τις πληροφορίες του τόμου στο αρχείο <span class=filename>/etc/fstab</span>. Για το σκοπό αυτό, δημιουργούμε ένα μόνιμο σημείο προσάρτησης, το <span class=filename>stripe</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /stripe</span>
<span class=c># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
    <span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div><div class=paragraph><p>Το άρθρωμα <span class=filename>geom_stripe.ko</span> θα πρέπει να φορτώνεται αυτόματα κατά την εκκίνηση του συστήματος. Εκτελέστε την παρακάτω εντολή, για να προσθέσετε την κατάλληλη ρύθμιση στο <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_stripe_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></div><div class=sect2><h3 id=GEOM-mirror>40.4. RAID1 - Mirroring<a class=anchor href=#GEOM-mirror></a></h3><div class=paragraph><p>Το mirroring (καθρεφτισμός) είναι μια τεχνολογία που χρησιμοποιείται από πολλές εταιρίες και οικιακούς χρήστες για να ασφαλίσουν τα δεδομένα τους χωρίς διακοπές. Σε μια διάταξη mirror, ο δίσκος Β είναι απλώς ένα πλήρες αντίγραφο του δίσκου Α. Ή μπορεί οι δίσκοι Γ+Δ να είναι αντίγραφα των δίσκων A+B. Άσχετα με την ακριβή διάταξη των δίσκων, το σημαντικό είναι ότι οι πληροφορίες ενός δίσκου ή μιας κατάτμησης αντιγράφονται σε άλλους. Οι πληροφορίες αυτές μπορεί αργότερα να αποκατασταθούν με εύκολο τρόπο, ή να αντιγραφούν χωρίς να προκληθεί διακοπή στις υπηρεσίες του μηχανήματος ή στην πρόσβαση των δεδομένων. Μπορούν ακόμα και να μεταφερθούν και να φυλαχθούν σε άλλο, ασφαλές μέρος.</p></div><div class=paragraph><p>Για να ξεκινήσετε, βεβαιωθείτε ότι το σύστημα σας έχει δύο σκληρούς δίσκους ίδιου μεγέθους. Στα παραδείγματα μας θεωρούμε ότι οι δίσκοι είναι τύπου SCSI (απευθείας πρόσβασης, <a href="https://man.freebsd.org/cgi/man.cgi?query=da&amp;sektion=4&amp;format=html">da(4)</a>).</p></div><div class=sect3><h4 id=_mirroring_στους_βασικούς_δίσκους>40.4.1. Mirroring στους Βασικούς Δίσκους<a class=anchor href=#_mirroring_στους_βασικούς_δίσκους></a></h4><div class=paragraph><p>Υποθέτοντας ότι το FreeBSD έχει εγκατασταθεί στον πρώτο δίσκο <span class=filename>da0</span>, θα πρέπει να ρυθμίσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> να αποθηκεύσει εκεί τα βασικά δεδομένα του.</p></div><div class=paragraph><p>Πριν δημιουργήσετε το mirror, ενεργοποιήστε την δυνατότητα εμφάνισης περισσότερων λεπτομερειών (που μπορεί να σας βοηθήσουν σε περίπτωση προβλήματος) και επιτρέψτε την απευθείας πρόσβαση στη συσκευή δίσκου. Για το σκοπό αυτό θέστε τη μεταβλητή <code>kern.geom.debugflags</code> του <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> στην παρακάτω τιμή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.debugflags=17</span></code></pre></div></div><div class=paragraph><p>Μπορείτε τώρα να δημιουργήσετε το mirror. Ξεκινήστε τη διαδικασία αποθηκεύοντας τα μετα-δεδομένα (meta-data) στον βασικό δίσκο, δημιουργώντας ουσιαστικά τη συσκευή <span class=filename>/dev/mirror/gm</span>. Χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Η δημιουργία mirror στο δίσκο εκκίνησης μπορεί να έχει ως αποτέλεσμα την απώλεια δεδομένων, αν ο τελευταίος τομέας του δίσκου έχει ήδη χρησιμοποιηθεί. Η πιθανότητα αυτή είναι πολύ μικρότερη αν το mirror δημιουργηθεί αμέσως μετά από μια νέα εγκατάσταση του FreeBSD. Η παρακάτω διαδικασία είναι επίσης ασύμβατη με τις προεπιλεγμένες ρυθμίσεις εγκατάστασης του FreeBSD 9.<em>X</em> στις οποίες χρησιμοποιείται το σύστημα κατατμήσεων GPT. To GEOM καταστρέφει τα μεταδεδομένα του GPT, και θα προκαλέσει απώλεια δεδομένων και πιθανή αδυναμία εκκίνησης του συστήματος.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -vb round-robin gm0 /dev/da0</span></code></pre></div></div><div class=paragraph><p>Το σύστημα θα ανταποκριθεί με το παρακάτω μήνυμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Metadata value stored on /dev/da0.
Done.</code></pre></div></div><div class=paragraph><p>Αρχικοποιήστε το GEOM. Η παρακάτω εντολή θα φορτώσει το άρθρωμα <span class=filename>/boot/kernel/geom_mirror.ko</span> στον πυρήνα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Με την επιτυχή εκτέλεση αυτής της εντολής, δημιουργείται η συσκευή <span class=filename>gm0</span> μέσα στον κατάλογο <span class=filename>/dev/mirror</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ενεργοποιήστε το φόρτωμα του αρθρώματος <span class=filename>geom_mirror.ko</span> κατά την εκκίνηση του συστήματος:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_mirror_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div><div class=paragraph><p>Επεξεργαστείτε το αρχείο <span class=filename>/etc/fstab</span>, αντικαθιστώντας τις αναφορές στις παλιές συσκευές <span class=filename>da0</span> με τις αντίστοιχες καινούριες <span class=filename>gm0</span> που αντιπροσωπεύουν το mirror.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν χρησιμοποιείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>, μπορείτε να ακολουθήσετε τα παρακάτω βήματα για να ολοκληρώσετε εύκολα αυτή τη διαδικασία:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vi /etc/fstab</span></code></pre></div></div><div class=paragraph><p>Στο <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>, κρατήστε αντίγραφο ασφαλείας του τρέχοντος αρχείου <span class=filename>fstab</span> πληκτρολογώντας <code>:w /etc/fstab.bak</code>. Έπειτα αντικαταστήστε όλες τις αναφορές στις παλιές συσκευές <span class=filename>da0</span> με τις νέες <span class=filename>gm0</span> γράφοντας <code>:%s/da/mirror\/gm/g</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το <span class=filename>fstab</span> που θα προκύψει, θα μοιάζει με το παρακάτω. Δεν έχει σημασία αν οι δίσκοι ήταν αρχικά SCSI ή ATA, η συσκευή RAID θα έχει πάντα το όνομα <span class=filename>gm</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Device                  Mountpoint  FStype      Options   Dump     Pass#
/dev/mirror/gm0s1b        none        swap        sw        0        0
/dev/mirror/gm0s1a        /           ufs         rw        1        1
/dev/mirror/gm0s1d        /usr        ufs         rw        0        0
/dev/mirror/gm0s1f        /home       ufs         rw        2        2
#/dev/mirror/gm0s2d       /store      ufs         rw        2        2
/dev/mirror/gm0s1e        /var        ufs         rw        2        2
/dev/acd0                 /cdrom      cd9660      ro,noauto 0        0</pre></div></div><div class=paragraph><p>Επανεκκινήστε το σύστημα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Κατά την εκκίνηση του συστήματος, θα πρέπει πλέον να χρησιμοποιείται η συσκευή <span class=filename>gm0</span> αντί για την <span class=filename>da0</span>. Μετά το τέλος της εκκίνησης, μπορείτε να ελέγξετε ότι όλα λειτουργούν σωστά, εξετάζοντας την έξοδο της εντολής <code>mount</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/mirror/gm0s1a   1012974  224604   707334    24%    /
devfs                      1       1        0   100%    /dev
/dev/mirror/gm0s1f  45970182   28596 42263972     0%    /home
/dev/mirror/gm0s1d   6090094 1348356  4254532    24%    /usr
/dev/mirror/gm0s1e   3045006 2241420   559986    80%    /var
devfs                      1       1        0   100%    /var/named/dev</code></pre></div></div><div class=paragraph><p>Η έξοδος φαίνεται σωστή, όπως αναμενόταν. Τελικά, για να ξεκινήσει ο συγχρονισμός, εισάγετε και την συσκευή <span class=filename>da1</span> στο mirror, χρησιμοποιώντας την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/da1</span></code></pre></div></div><div class=paragraph><p>Κατά τη διάρκεια του συγχρονισμού του mirror, μπορείτε να δείτε την πρόοδο της διαδικασίας με την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror status</span></code></pre></div></div><div class=paragraph><p>Μετά το τέλος της δόμησης του mirror, και αφού έχουν συγχρονιστεί όλα τα δεδομένα, η έξοδος της παραπάνω εντολής θα μοιάζει με την ακόλουθη:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>      Name    Status  Components
mirror/gm0  COMPLETE  da0
                      da1</code></pre></div></div><div class=paragraph><p>Αν υπάρχουν προβλήματα, ή αν το mirror βρίσκεται ακόμα στη διαδικασία συγχρονισμού, το παράδειγμα θα δείχνει <code>DEGRADED</code> αντί για <code>COMPLETE</code>.</p></div></div><div class=sect3><h4 id=_αντιμετώπιση_προβλημάτων_2>40.4.2. Αντιμετώπιση Προβλημάτων<a class=anchor href=#_αντιμετώπιση_προβλημάτων_2></a></h4><div class=sect4><h5 id=_το_σύστημα_αρνείται_να_ξεκινήσει>40.4.2.1. Το σύστημα αρνείται να ξεκινήσει<a class=anchor href=#_το_σύστημα_αρνείται_να_ξεκινήσει></a></h5><div class=paragraph><p>Αν το σύστημα σας σταματάει σε μια προτροπή που μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ffs_mountroot: can&#39;t find rootvp
Root mount failed: 6
mountroot&gt;</pre></div></div><div class=paragraph><p>Επανεκκινήστε το σύστημα σας μέσω του διακόπτη τροφοδοσίας ή του πλήκτρου reset. Στο μενού εκκίνησης, επιλέξτε το (6). Με τον τρόπο αυτό θα βρεθείτε στην προτροπή του <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>. Φορτώστε χειροκίνητα το άρθρωμα στον πυρήνα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK? load geom_mirror
OK? boot</code></pre></div></div><div class=paragraph><p>Αν το παραπάνω λειτουργήσει, τότε για κάποιο λόγο το άρθρωμα δεν φορτώθηκε σωστά. Ελέγξτε αν είναι σωστή η σχετική καταχώριση στο αρχείο <span class=filename>/boot/loader.conf</span>. Αν το πρόβλημα παραμένει, προσθέστε τη γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_MIRROR</pre></div></div><div class=paragraph><p>στο αρχείο ρυθμίσεων του πυρήνα σας, αναδημιουργήστε και επανεγκαταστήστε τον πυρήνα σας. Το πρόβλημα σας θα πρέπει να διορθωθεί.</p></div></div></div><div class=sect3><h4 id=_επαναφορά_μετά_από_αποτυχία_δίσκου>40.4.3. Επαναφορά Μετά από Αποτυχία Δίσκου<a class=anchor href=#_επαναφορά_μετά_από_αποτυχία_δίσκου></a></h4><div class=paragraph><p>Το εκπληκτικό με το mirroring είναι ότι όταν ένας σκληρός δίσκος χαλάσει, μπορείτε να τον αντικαταστήσετε χωρίς να χάσετε καθόλου δεδομένα.</p></div><div class=paragraph><p>Υποθέτοντας ότι χρησιμοποιούμε τις ρυθμίσεις RAID1 που δείξαμε προηγουμένως, ας θεωρήσουμε ότι χάλασε ο δίσκος <span class=filename>da1</span> και πρέπει να αντικατασταθεί. Για να τον αντικαταστήσετε, βρείτε ποιος δίσκος είναι και απενεργοποιήστε το σύστημα. Στο σημείο αυτό, μπορείτε πλέον να ανταλλάξετε το δίσκο με ένα νέο και να ενεργοποιήσετε ξανά το σύστημα. Μετά την επανενεργοποίηση του συστήματος, μπορείτε να χρησιμοποιήσετε τις παρακάτω εντολές για να θέσετε σε λειτουργία το νέο δίσκο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror forget gm0</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/da1</span></code></pre></div></div><div class=paragraph><p>Χρησιμοποιήστε την εντολή <code>gmirror status</code> για να παρακολουθείτε τη διαδικασία του συγχρονισμού. Είναι στα αλήθεια τόσο απλό.</p></div></div></div><div class=sect2><h3 id=GEOM-raid3>40.5. RAID3 - Striping σε Επίπεδο Byte με Αφοσιωμένο Parity<a class=anchor href=#GEOM-raid3></a></h3><div class=paragraph><p>Το RAID3 είναι μια μέθοδος που συνδυάζει αρκετούς διαφορετικούς σκληρούς δίσκους σε ένα τόμο με ένα δίσκο αφοσιωμένο στην ισοτιμία (parity). Σε ένα σύστημα RAID3, τα δεδομένα χωρίζονται σε ένα αριθμό από bytes που εγγράφονται σε όλους τους δίσκους της συστοιχίας εκτός από ένα που χρησιμοποιείται αποκλειστικά ως δίσκος ισοτιμίας. Αυτό σημαίνει ότι για να διαβάσουμε 1024KB από μια υλοποίηση του RAID3 θα πρέπει να προσπελάσουμε όλους τους δίσκους της συστοιχίας. Η απόδοση αυξάνεται με τη χρήση χωριστών ελεγκτών σκληρών δίσκων. Η συστοιχία RAID3 προσφέρει ανοχή σε βλάβη ενός δίσκου ενός παρέχει χωρητικότητα 1 - 1/n φορές τη χωρητικότητα όλων των δίσκων της συστοιχίας, όπου n είναι το πλήθος των δίσκων που την απαρτίζουν. Αυτού του είδους οι συστοιχίες είναι κατάλληλες για αποθήκευση μεγάλων αρχείων, για παράδειγμα αρχείων πολυμέσων.</p></div><div class=paragraph><p>Χρειάζονται τουλάχιστον 3 φυσικοί σκληροί δίσκοι για τη δημιουργία μια συστοιχίας RAID3. Κάθε δίσκος θα πρέπει να είναι το ίδιο μέγεθος καθώς οι αιτήσεις Ι/Ο (εισόδου/εξόδου) εναλλάσσονται ώστε να γίνεται εγγραφή και ανάγνωση σε πολλαπλούς δίσκους παράλληλα. Επίσης, εξαιτίας της φύσης του RAID3, ο αριθμός των δίσκων πρέπει να είναι 3, 5, 9, 17 κλπ. (2^n+1).</p></div><div class=sect3><h4 id=_δημιουργία_συστοιχίας_raid3>40.5.1. Δημιουργία Συστοιχίας RAID3<a class=anchor href=#_δημιουργία_συστοιχίας_raid3></a></h4><div class=paragraph><p>Στο FreeBSD, η υποστήριξη για RAID3 υλοποιείται μέσω της κλάσης <a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a> του GEOM. Η δημιουργία μιας συστοιχίας RAID3 στο FreeBSD απαιτεί τα παρακάτω βήματα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν και είναι θεωρητικά δυνατό να φτιάξετε μια εκκινήσιμη συστοιχία RAID3 στο FreeBSD, δεν συνίσταται καθώς πρόκειται για ασυνήθιστη λειτουργία.</p></div></td></tr></tbody></table></div><div class="olist arabic procedure"><ol class=arabic><li><p>Αρχικά, φορτώστε το <span class=filename>geom_rai3.ko</span> άρθρωμα του πυρήνα μέσω της ακόλουθης εντολής:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 load</span></code></pre></div></div><div class=paragraph><p>Εναλλακτικά, είναι δυνατόν να φορτώσετε το άρθρωμα χειροκίνητα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_raid3.ko</span></code></pre></div></div></li><li><p>Εξασφαλίστε ότι υπάρχει κατάλληλο σημείο προσάρτησης, ή δημιουργήστε ένα καινούριο:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /multimedia</span></code></pre></div></div></li><li><p>Προσδιορίστε τα ονόματα συσκευών των δίσκων που θα προστεθούν στη συστοιχία και δημιουργήστε τη νέα συσκευή RAID3. Στο παράδειγμα μας χρησιμοποιούμε τρεις οδηγούς ATA οι οποίοι δεν περιέχουν κατατμήσεις: <span class=filename>ada1</span> και <span class=filename>ada2</span> για τα δεδομένα και <span class=filename>ada3</span> για το parity.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1
Metadata value stored on /dev/ada2
Metadata value stored on /dev/ada3
Done.</code></pre></div></div></li><li><p>Δημιουργήστε κατατμήσεις στη νέα συσκευή <span class=filename>gr0</span> και διαμορφώστε την με σύστημα αρχείων UFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT /dev/raid3/gr0</span>
<span class=c># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class=c># newfs -j /dev/raid3/gr0p1</span></code></pre></div></div><div class=paragraph><p>Θα δείτε μεγάλο πλήθος αριθμών να περνάει από την οθόνη σας και μετά από λίγο η διαδικασία θα ολοκληρωθεί. Ο τόμος έχει πλέον δημιουργηθεί και είναι έτοιμος να προσαρτηθεί.</p></div></li><li><p>Το τελευταίο βήμα είναι η προσάρτηση του συστήματος αρχείων:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/raid3/gr0p1 /multimedia</span></code></pre></div></div><div class=paragraph><p>Η συστοιχία RAID3 είναι τώρα έτοιμη προς χρήση.</p></div></li></ol></div><div class=paragraph><p>Θα χρειαστεί να κάνετε επιπλέον ρυθμίσεις ώστε η συστοιχία να είναι άμεσα διαθέσιμη μετά από κάθε εκκίνηση του υπολογιστή σας.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Το άρθρωμα <span class=filename>geom_raid3.ko</span> θα πρέπει να φορτώνεται πριν την προσάρτηση της συστοιχίας. Για να φορτώνεται αυτόματα κατά την εκκίνηση του συστήματος, προσθέστε την παρακάτω γραμμή στο <span class=filename>/boot/loader.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>geom_raid3_load=&#34;YES&#34;</pre></div></div></li><li><p>Θα πρέπει να προσθέσετε τις παρακάτω πληροφορίες σχετικά με τον τόμο στο αρχείο <span class=filename>/etc/fstab</span> ώστε η προσάρτηση του συστήματος αρχείων της συστοιχίας να γίνεται αυτόματα κατά τη διαδικασία εκκίνησης του συστήματος:</p><div class="literalblock programlisting"><div class=content><pre>/dev/raid3/gr0p1    /multimedia    ufs    rw    2    2</pre></div></div></li></ol></div></div></div><div class=sect2><h3 id=geom-ggate>40.6. Δικτυακές Συσκευές μέσω GEOM Gate<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>Το GEOM υποστηρίζει απομακρυσμένη χρήση συσκευών, όπως οι σκληροί δίσκοι, τα CD-ROM, τα αρχεία κ.λ.π. χρησιμοποιώντας τα βοηθητικά προγράμματα πύλης (gate). Η λειτουργία είναι παρόμοια με το NFS.</p></div><div class=paragraph><p>Για να ξεκινήσετε, πρέπει να δημιουργήσετε ένα αρχείο exports. Το αρχείο αυτό καθορίζει ποιος επιτρέπεται να αποκτήσει πρόσβαση στους κοινόχρηστους πόρους και τι επιπέδου θα είναι αυτή η πρόσβαση. Για παράδειγμα, για να διαμοιράσετε την τέταρτη κατάτμηση (slice) του πρώτου δίσκου SCSI, είναι αρκετό να δημιουργήσετε το παρακάτω αρχείο <span class=filename>/etc/gg.exports</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.0/24 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Το παραπάνω θα επιτρέψει σε όλους τους υπολογιστές του ιδιωτικού σας δικτύου, να έχουν πρόσβαση μέσω δικτύου στο σύστημα αρχείων της κατάτμησης <span class=filename>da0s4d</span>.</p></div><div class=paragraph><p>Για να διαμοιράσετε αυτή τη συσκευή, βεβαιωθείτε ότι δεν είναι προσαρτημένη τη δεδομένη στιγμή, και ξεκινήστε το δαίμονα εξυπηρετητή <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Για να προσαρτήσετε την συσκευή στο μηχάνημα πελάτη, χρησιμοποιήστε τις ακόλουθες εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>Από εδώ και στο εξής, μπορείτε να έχετε πρόσβαση στη συσκευή μέσω του σημείου προσάρτησης <span class=filename>/mnt</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Πρέπει να τονιστεί ότι η διαδικασία θα αποτύχει αν η συσκευή είναι τη δεδομένη στιγμή προσαρτημένη, είτε στον εξυπηρετητή, είτε σε οποιοδήποτε άλλο υπολογιστή στο δίκτυο.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Όταν δεν χρειάζεστε πλέον τη συσκευή, μπορείτε να την αποπροσαρτήσετε με ασφάλεια, χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a>, όπως γίνεται και με οποιαδήποτε άλλη συσκευή δίσκου.</p></div></div><div class=sect2><h3 id=geom-glabel>40.7. Δημιουργώντας Ετικέτες (Labels) στις Συσκευές Δίσκων<a class=anchor href=#geom-glabel></a></h3><div class=paragraph><p>Κατά τη διάρκεια της αρχικοποίησης, στην εκκίνηση του συστήματος, ο πυρήνας του FreeBSD θα δημιουργήσει τα απαραίτητα αρχεία για κάθε συσκευή που ανιχνεύει. Αυτή η μέθοδος ανίχνευσης συσκευών, μπορεί να δημιουργήσει προβλήματα. Για παράδειγμα, τι θα γίνει αν προσθέσουμε ένα νέο δίσκο USB; Είναι αρκετά πιθανό μια συσκευή μνήμης flash να πάρει το όνομα <span class=filename>da0</span> και η αρχική <span class=filename>da0</span> να μετακινηθεί στο <span class=filename>da1</span>. Αυτό θα προκαλέσει προβλήματα στην προσάρτηση των συστημάτων αρχείων, αν υπάρχουν οι αντίστοιχες καταχωρίσεις τους στο <span class=filename>/etc/fstab</span>, και μπορεί ακόμα και να παρεμποδίσει την κανονική εκκίνηση του συστήματος.</p></div><div class=paragraph><p>Μια λύση είναι να ρυθμίσετε τις συσκευές SCSI με τέτοιο τρόπο, ώστε η αρίθμηση τους να είναι συνεχόμενη. Έτσι, κάθε φορά που προσθέτετε μια νέα συσκευή στον ελεγκτή SCSI θα είστε σίγουρος ότι θα λάβει αριθμό που δεν έχει χρησιμοποιηθεί. Αλλά τι γίνεται με τις συσκευές USB που μπορεί να αντικαταστήσουν τον κύριο SCSI δίσκο; Αυτό μπορεί πράγματι να συμβεί, καθώς οι συσκευές USB ανιχνεύονται κατά βάση πριν από τον ελεγκτή SCSI. Μια λύση είναι να βάζετε τις συσκευές αυτές μόνο μετά την εκκίνηση του συστήματος. Μια άλλη μέθοδος είναι να χρησιμοποιείτε μόνο μια συσκευή τύπου ATA και να μην καταχωρείτε ποτέ τους δίσκους SCSI στο <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>Υπάρχει ωστόσο καλύτερη λύση. Χρησιμοποιώντας το βοηθητικό πρόγραμμα <code>glabel</code>, ένας διαχειριστής ή χρήστης, μπορεί να αποδώσει ετικέτες στις συσκευές δίσκων και να τις χρησιμοποιήσει στο <span class=filename>/etc/fstab</span>, αντί για τα συμβατικά ονόματα συσκευών. Επειδή η <code>glabel</code> αποθηκεύει την ετικέτα στον τελευταίο τομέα του κάθε παροχέα (συσκευής δίσκου), η ετικέτα διατηρείται και μετά από την επανεκκίνηση του συστήματος. Χρησιμοποιώντας αυτή την ετικέτα ως όνομα συσκευής, θα μπορείτε να προσαρτήσετε πάντα το σύστημα αρχείων, άσχετα με το πραγματικό όνομα συσκευής που έχει αποδοθεί στο δίσκο.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Δεν χρειάζεται φυσικά να τονίσουμε ότι αυτή η ετικέτα θα πρέπει να είναι μόνιμη. Το βοηθητικό πρόγραμμα <code>glabel</code> μπορεί να δημιουργήσει τόσο μόνιμες όσο και προσωρινές ετικέτες. Μόνο οι μόνιμες ετικέτες διατηρούνται ανέπαφες μετά από μια επανεκκίνηση. Δείτε τη σελίδα manual της <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> για περισσότερες πληροφορίες σχετικά με τα είδη των ετικετών.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_είδη_ετικετών_και_παραδείγματα>40.7.1. Είδη Ετικετών και Παραδείγματα<a class=anchor href=#_είδη_ετικετών_και_παραδείγματα></a></h4><div class=paragraph><p>Υπάρχουν δύο τύποι ετικετών, η γενική ετικέτα και η ετικέτα συστήματος αρχείων. Οι ετικέτες μπορεί να είναι προσωρινές ή μόνιμες. Οι μόνιμες ετικέτες μπορούν να δημιουργηθούν με τις εντολές <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> ή <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. Στην περίπτωση αυτή, θα δημιουργηθούν σε ένα υποκατάλογο του <span class=filename>/dev</span>. Για παράδειγμα, οι ετικέτες συσκευών με σύστημα αρχείων UFS2, θα δημιουργηθούν στον κατάλογο <span class=filename>/dev/ufs</span>. Μόνιμες ετικέτες μπορούν επίσης να δημιουργηθούν με χρήση της εντολής <code>glabel label</code>. Οι ετικέτες αυτές δεν εξαρτώνται από το σύστημα αρχείων, και δημιουργούνται στον κατάλογο <span class=filename>/dev/label</span>.</p></div><div class=paragraph><p>Οι ετικέτες προσωρινού τύπου, χάνονται σε κάθε επανεκκίνηση του συστήματος. Οι ετικέτες αυτές δημιουργούνται στον κατάλογο <span class=filename>/dev/label</span> και είναι τέλειες για πειραματισμούς. Μπορείτε να δημιουργήσετε προσωρινές ετικέτες με την εντολή <code>glabel create</code>. Για περισσότερες πληροφορίες, διαβάστε τη σελίδα manual της <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a>.</p></div><div class=paragraph><p>Για να δημιουργήσετε μια μόνιμη ετικέτα για ένα σύστημα αρχείων UFS2, χωρίς να καταστρέψετε τα δεδομένα που περιέχει, χρησιμοποιήστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Αν το σύστημα αρχείων είναι γεμάτο, η παραπάνω εντολή μπορεί να προκαλέσει καταστροφή δεδομένων. Ωστόσο, αν το σύστημα αρχείων είναι γεμάτο, στόχος σας θα πρέπει να είναι να διαγράψετε τα αρχεία που δεν χρησιμοποιούνται, και όχι να προσθέτετε ετικέτες.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Θα πρέπει τώρα να υπάρχει μια ετικέτα στον κατάλογο <span class=filename>/dev/ufs</span> η οποία μπορεί να προστεθεί στο <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το σύστημα αρχείων δεν πρέπει να είναι προσαρτημένο καθώς εκτελείτε την εντολή <code>tunefs</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μπορείτε τώρα να προσαρτήσετε το σύστημα αρχείων με το συνήθη τρόπο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>Από εδώ και πέρα, και όσο το άρθρωμα <span class=filename>geom_label.ko</span> φορτώνεται στον πυρήνα μέσω του <span class=filename>/boot/loader.conf</span> ή εφόσον έχετε βάλει την επιλογή <code>GEOM_LABEL</code> στον πυρήνα σας, ακόμα και αν το όνομα της συσκευής αλλάξει, δεν θα έχει καμιά δυσμενή επίδραση στο σύστημα σας.</p></div><div class=paragraph><p>Μπορείτε επίσης να δημιουργήσετε συστήματα αρχείων με προεπιλεγμένη ετικέτα, χρησιμοποιώντας την επιλογή <code>-L</code> στην εντολή <code>newfs</code>. Δείτε την σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> για περισσότερες πληροφορίες.</p></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε την παρακάτω εντολή για να καταστρέψετε μια ετικέτα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>Το επόμενο παράδειγμα δείχνει πως μπορούν να δοθούν ετικέτες στις κατατμήσεις του δίσκου εκκίνησης.</p></div><div class=exampleblock><div class=title>Παράδειγμα 19. Δημιουργία Ετικετών στις Κατατμήσεις του Δίσκου Εκκίνησης</div><div class=content><div class=paragraph><p>Δημιουργώντας μόνιμες ετικέτες στις κατατμήσεις του δίσκου εκκίνησης, το σύστημα σας θα συνεχίσει να εκκινεί κανονικά ακόμα και αν μεταφέρετε το δίσκο σε άλλο ελεγκτή ή ακόμα και σε διαφορετικό σύστημα. Στο παράδειγμα μας, θεωρούμε ότι χρησιμοποιείται ένας δίσκος ATA, ο οποίος αναγνωρίζεται από το σύστημα ως <span class=filename>ad0</span>. Θεωρούμε επίσης ότι χρησιμοποιείται η συνηθισμένη διάταξη κατατμήσεων του FreeBSD, που περιλαμβάνει τις κατατμήσεις <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/usr</span> και <span class=filename>/tmp</span> όπως επίσης και μια κατάτμηση swap.</p></div><div class=paragraph><p>Επανεκκινήστε το σύστημα, και όταν εμφανιστεί η προτροπή του <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>, πιέστε το <kbd>4</kbd> για να πραγματοποιηθεί εκκίνηση σε κατάσταση ενός χρήστη. Έπειτα, δώστε τις ακόλουθες εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1a is label/rootfs
<span class=c># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1d is label/var
<span class=c># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1f is label/usr
<span class=c># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1e is label/tmp
<span class=c># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1b is label/swap
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Η εκκίνηση θα συνεχιστεί κανονικά και το σύστημα θα έλθει σε κατάσταση πολλαπλών χρηστών (multi-user). Μετά το τέλος της εκκίνησης, επεξεργαστείτε το αρχείο <span class=filename>/etc/fstab</span> και αλλάξτε τα συμβατικά ονόματα συσκευών με τις αντίστοιχες ετικέτες. Το τελικό αρχείο <span class=filename>/etc/fstab</span> θα μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre></div></div><div class=paragraph><p>Μπορείτε τώρα να επανεκκινήσετε το σύστημα. Αν όλα πήγαν καλά, η εκκίνηση θα είναι κανονική, και η εντολή <code>mount</code> θα δείξει:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/label/rootfs on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/label/tmp on /tmp <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/usr on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/var on /var <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>Ξεκινώντας από το FreeBSD 7.2, το <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> υποστηρίζει ένα νέο είδος ετικέτας για συστήματα αρχείων UFS, που βασίζεται σε ένα μοναδιαίο αναγνωριστικό τους, το <code>ufsid</code>. Οι ετικέτες αυτές βρίσκονται στον κατάλογο <span class=filename>/dev/ufsid</span>, δημιουργούνται αυτόματα κατά την εκκίνηση του συστήματος και είναι δυνατόν να χρησιμοποιηθούν για την προσάρτηση κατατμήσεων μέσω του <span class=filename>/etc/fstab</span>. Μπορείτε να χρησιμοποιήσετε την εντολή <code>glabel status</code> για να λάβετε μια λίστα των συστημάτων αρχείων με τις αντίστοιχες <code>ufsid</code> ετικέτες τους:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre></div></div><div class=paragraph><p>Στο παραπάνω παράδειγμα, το <span class=filename>ad4s1d</span> αντιπροσωπεύει το σύστημα αρχείων <span class=filename>/var</span>, ενώ το <span class=filename>ad4s1f</span> αντιπροσωπεύει το σύστημα αρχείων <span class=filename>/usr</span>. Χρησιμοποιώντας τις τιμές <code>ufsid</code> που φαίνονται, η προσάρτηση αυτών των κατατμήσεων μπορεί να γίνει με τις παρακάτω καταχωρίσεις στο <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre></div></div><div class=paragraph><p>Οποιαδήποτε κατάτμηση διαθέτει αναγνωριστικό <code>ufsid</code> μπορεί να προσαρτηθεί με τον ίδιο τρόπο, χωρίς να υπάρχει πλέον ανάγκη να δημιουργηθεί μόνιμη ετικέτα χειροκίνητα. Η προσάρτηση μέσω ετικέτας <code>ufsid</code>, παρέχει το πλεονέκτημα της ανεξαρτησίας από το όνομα συσκευής, το οποίο παρέχουν και οι μόνιμες ετικέτες.</p></div></div></div><div class=sect2><h3 id=geom-gjournal>40.8. UFS Journaling Μέσω GEOM<a class=anchor href=#geom-gjournal></a></h3><div class=paragraph><p>Στην έκδοση 7.0 του FreeBSD υλοποιείται για πρώτη φορά η νέα (και από πολλούς αναμενόμενη) δυνατότητα για χρήση ημερολογίου (journal) στο σύστημα αρχείων. Η υλοποίηση παρέχεται μέσω του υποσυστήματος GEOM και μπορεί να ρυθμιστεί εύκολα μέσω του βοηθητικού προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a>.</p></div><div class=paragraph><p>Τι είναι το journaling; Το journaling αποθηκεύει σε ένα αρχείο καταγραφής (log, ημερολόγιο, ή απλώς journal) τις συναλλαγές του συστήματος αρχείων. Παράδειγμα συναλλαγής είναι οι αλλαγές που απαιτούνται για μια πλήρη διαδικασία εγγραφής στο δίσκο. Έτσι, στο log αποθηκεύονται οι αλλαγές στα μετα-δεδομένα (meta-data) και στα ίδια τα αρχεία, πριν γίνει η τελική (κανονική) αποθήκευση τους στο δίσκο. Το αρχείο καταγραφής μπορεί αργότερα να ξαναχρησιμοποιηθεί ώστε η συναλλαγή να γίνει από την αρχή, εξασφαλίζοντας με αυτό τον τρόπο ότι το σύστημα αρχείων θα παραμείνει σε σταθερή κατάσταση.</p></div><div class=paragraph><p>Πρόκειται ουσιαστικά για μια ακόμα μέθοδο προφύλαξης από απώλεια δεδομένων και ασυνέπειες στο σύστημα αρχείων. Σε αντίθεση με τα Soft Updates τα οποία εντοπίζουν και υποχρεώνουν την άμεση εγγραφή των μετα-δεδομένων, και των στιγμιοτύπων (Snapshots) τα οποία είναι εικόνες του συστήματος αρχείων σε μια δεδομένη στιγμή, το log αποθηκεύεται σε χώρο που έχει εκχωρηθεί ειδικά για αυτό το σκοπό, και σε μερικές περιπτώσεις μπορεί να αποθηκεύεται σε εντελώς διαφορετικό δίσκο.</p></div><div class=paragraph><p>Σε αντίθεση με υλοποιήσεις journaling σε άλλα συστήματα αρχείων, η μέθοδος <code>gjournal</code> βασίζεται σε blocks, και δεν υλοποιείται ως μέρος του συστήματος αρχείων, αλλά μόνο ως επέκταση του GEOM.</p></div><div class=paragraph><p>Για ενεργοποίηση της υποστήριξης <code>gjournal</code>, θα πρέπει να υπάρχει η παρακάτω επιλογή στον πυρήνα του FreeBSD. Η επιλογή αυτή υπάρχει από προεπιλογή στην έκδοση 7.0 και όλες τις νεότερες εκδόσεις του FreeBSD.</p></div><div class="literalblock programlisting"><div class=content><pre>options	UFS_GJOURNAL</pre></div></div><div class=paragraph><p>Αν χρειάζεται να προσαρτώνται τόμοι με journaling κατά την εκκίνηση, θα πρέπει επίσης να φορτώνεται αυτόματα και το άρθρωμα πυρήνα <span class=filename>geom_journal.ko</span>. Για το σκοπό αυτό, προσθέστε την παρακάτω γραμμή στο αρχείο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_journal_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Εναλλακτικά, η λειτουργία αυτή μπορεί να ενσωματωθεί σε ένα προσαρμοσμένο πυρήνα, με την προσθήκη της παρακάτω γραμμής στο αντίστοιχο αρχείο ρυθμίσεων:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_JOURNAL</pre></div></div><div class=paragraph><p>Η δημιουργία journal σε ένα ελεύθερο σύστημα αρχείων, μπορεί τώρα να γίνει με τα ακόλουθα βήματα, θεωρώντας ότι η συσκευή <span class=filename>da4</span> είναι ένας νέος δίσκος SCSI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gjournal load</span>
<span class=c># gjournal label /dev/da4</span></code></pre></div></div><div class=paragraph><p>Στο σημείο αυτό θα υπάρχει μια συσκευή <span class=filename>/dev/da4</span> καθώς και μια συσκευή <span class=filename>/dev/da4.journal</span>. Στη συσκευή αυτή μπορείτε τώρα να δημιουργήσετε σύστημα αρχείων:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -O 2 -J /dev/da4.journal</span></code></pre></div></div><div class=paragraph><p>Η παραπάνω εντολή θα δημιουργήσει ένα σύστημα αρχείων UFS2 στη συσκευή <span class=filename>/dev/da4.journal</span>, η οποία έχει ήδη υποστήριξη για journaling.</p></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε την εντολή <code>mount</code> για να προσαρτήσετε την συσκευή στο επιθυμητό σημείο προσάρτησης, όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/da4.journal /mnt</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Στην περίπτωση αρκετών slice, θα δημιουργηθεί ένα journal για κάθε επιμέρους slice. Για παράδειγμα, αν υπάρχουν τα slices <span class=filename>ad4s1</span> και <span class=filename>ad4s2</span> τότε το <code>gjournal</code> θα δημιουργήσει τις συσκευές <span class=filename>ad4s1.journal</span> και <span class=filename>ad4s2.journal</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για καλύτερη απόδοση, ίσως είναι επιθυμητή η τήρηση του journal σε διαφορετικό δίσκο. Για τις περιπτώσεις αυτές, ο παροχέας ημερολογίου (η συσκευή δίσκου που θα περιέχει το journal) πρέπει να δίνεται ως παράμετρος στην εντολή, αμέσως μετά τη συσκευή δίσκου στην οποία θα ενεργοποιηθεί το journaling. Μπορείτε επίσης να ενεργοποιήσετε το journaling σε υπάρχοντα συστήματα αρχείων χρησιμοποιώντας την εντολή <code>tunefs</code>. Ωστόσο, θα πρέπει να κρατήσετε αντίγραφο ασφαλείας των αρχείων σας, πριν επιχειρήσετε να κάνετε αλλαγές σε ένα υπάρχον σύστημα αρχείων. Στις περισσότερες περιπτώσεις, η <code>tunefs</code> θα αποτύχει αν δεν μπορέσει να δημιουργήσει το journal, αλλά αυτό δεν σας προστατεύει από απώλεια δεδομένων που μπορεί να προέλθει από κακή χρήση της <code>tunefs</code>.</p></div><div class=paragraph><p>Είναι επίσης δυνατόν να χρησιμοποιηθεί journaling στον δίσκο εκκίνησης ενός συστήματος FreeBSD. Διαβάστε το άρθρο <a href=https://docs.freebsd.org/el/articles/gjournal-desktop/>Υλοποίηση του UFS Journaling σε ένα Desktop Υπολογιστή</a> για λεπτομερείς οδηγίες.</p></div></div></div></div><div class=sect1><h2 id=filesystems>Chapter 41. Υποστήριξη Συστημάτων Αρχείων<a class=anchor href=#filesystems></a></h2><div class=sectionbody><div class=sect2><h3 id=filesystems-synopsis>41.1. Σύνοψη<a class=anchor href=#filesystems-synopsis></a></h3><div class=paragraph><p>Τα συστήματα αρχείων αποτελούν αναπόσπαστο τμήμα κάθε λειτουργικού συστήματος. Επιτρέπουν στους χρήστες να δημιουργούν και να αποθηκεύουν αρχεία, παρέχουν πρόσβαση σε δεδομένα, και φυσικά αξιοποιούν τους σκληρούς δίσκους. Διαφορετικά λειτουργικά συστήματα χρησιμοποιούν συνήθως διαφορετικά εγγενή συστήματα αρχείων. Το σύστημα αρχείων του FreeBSD είναι το Fast File System ή FFS, το οποίο προήλθε από το αρχικό σύστημα αρχείων του Unix™, γνωστό επίσης και ως UFS. Αυτό είναι και το εγγενές σύστημα αρχείων του FreeBSD, το οποίο χρησιμοποιείται στους σκληρούς δίσκους και προσφέρει πρόσβαση στα δεδομένα.</p></div><div class=paragraph><p>Το FreeBSD προσφέρει επίσης πληθώρα διαφορετικών συστημάτων αρχείων, ώστε να παρέχει τοπική πρόσβαση σε δεδομένα που έχουν δημιουργηθεί από άλλα λειτουργικά συστήματα, π.χ. δεδομένα που βρίσκονται σε τοπικά USB αποθηκευτικά μέσα, οδηγούς flash, και σκληρούς δίσκους. Υπάρχει επίσης υποστήριξη για άλλα, μη-εγγενή συστήματα αρχείων, όπως το Extended File System (EXT) του Linux® καθώς και το σύστημα Z File System (ZFS) της Sun™.</p></div><div class=paragraph><p>Το FreeBSD παρέχει διαφορετικό επίπεδο υποστήριξης για κάθε σύστημα αρχείων. Για ορισμένα θα χρειαστεί να φορτωθεί κάποιο άρθρωμα στον πυρήνα, ενώ για άλλα θα πρέπει να εγκατασταθούν κάποια εργαλεία. Το κεφάλαιο αυτό έχει σχεδιαστεί να βοηθήσει τους χρήστες του FreeBSD να αποκτήσουν πρόσβαση σε άλλα συστήματα αρχείων στο σύστημα τους, ξεκινώντας από το Ζ File System της Sun™.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα γνωρίζετε:</p></div><div class=ulist><ul><li><p>Τη διαφορά μεταξύ των εγγενών και των υποστηριζόμενων συστημάτων αρχείων.</p></li><li><p>Ποια συστήματα αρχείων υποστηρίζονται από το FreeBSD.</p></li><li><p>Πως να ενεργοποιήσετε, να ρυθμίσετε, να αποκτήσετε πρόσβαση και να χρησιμοποιήσετε μη-εγγενή συστήματα αρχείων.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε βασικές έννοιες του UNIX® και του FreeBSD (<a href=./#basics>Βασικές Έννοιες στο UNIX®</a>).</p></li><li><p>Να είστε εξοικειωμένος με τις βασικές διαδικασίες ρύθμισης και εγκατάστασης προσαρμοσμένου πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li><li><p>Να αισθάνεστε άνετα με την εγκατάσταση εφαρμογών τρίτου κατασκευαστή στο FreeBSD (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li><li><p>Να είστε εξοικειωμένος με τους δίσκους, τα μέσα αποθήκευσης, και τα αντίστοιχα ονόματα συσκευών στο FreeBSD (<a href=./#disks>Αποθηκευτικά Μέσα</a>).</p></li></ul></div></div><div class=sect2><h3 id=filesystems-zfs>41.2. Το Σύστημα Αρχείων Z (ZFS)<a class=anchor href=#filesystems-zfs></a></h3><div class=paragraph><p>Το σύστημα αρχείων Z, αναπτύχθηκε από την Sun™, και είναι μια νέα τεχνολογία που σχεδιάστηκε για να παρέχει αποθήκευση μέσω της μεθόδου pool. Αυτό σημαίνει ότι όλος ο ελεύθερος χώρος διατίθεται ως απόθεμα, και διανέμεται δυναμικά σε κάθε σύστημα αρχείων ανάλογα με τις ανάγκες αποθήκευσης δεδομένων. Έχει επίσης σχεδιαστεί για τη μέγιστη ακεραιότητα δεδομένων και υποστηρίζει στιγμιότυπα (snapshots) δεδομένων, πολλαπλά αντίγραφα και αθροίσματα ελέγχου δεδομένων (checksums). Έχει ακόμα προστεθεί ένα νέο μοντέλο για τη διατήρηση αντιγράφων των δεδομένων, γνωστό ως RAID-Z. Το μοντέλο RAID-Z είναι παρόμοιο με το RAID5 αλλά είναι σχεδιασμένο να παρέχει προστασία των δεδομένων κατά την εγγραφή τους.</p></div><div class=sect3><h4 id=_βελτιστοποίηση_του_zfs>41.2.1. Βελτιστοποίηση του ZFS<a class=anchor href=#_βελτιστοποίηση_του_zfs></a></h4><div class=paragraph><p>Το υποσύστημα ZFS χρησιμοποιεί αρκετούς πόρους του συστήματος. Βελτιστοποιώντας τις ρυθμίσεις του συστήματος σας, θα επιτύχετε τη μέγιστη απόδοση στην καθημερινή χρήση. Καθώς το ZFS είναι ακόμα σε πειραματικό στάδιο στο FreeBSD, αυτό ίσως αλλάξει μελλοντικά. Ωστόσο, για την ώρα, συνίσταται να ακολουθήσετε τα παρακάτω βήματα:</p></div><div class=sect4><h5 id=_μνήμη>41.2.1.1. Μνήμη<a class=anchor href=#_μνήμη></a></h5><div class=paragraph><p>Το συνολικό μέγεθος μνήμης του συστήματος πρέπει να είναι τουλάχιστον ένα gigabyte, ενώ το συνιστώμενο μέγεθος είναι δύο gigabytes ή και περισσότερο. Σε όλα τα παραδείγματα που φαίνονται εδώ, το σύστημα έχει ένα gigabyte μνήμης και έχουμε επίσης βελτιστοποιήσει τις ρυθμίσεις του.</p></div><div class=paragraph><p>Ορισμένοι χρήστες φαίνεται να τα καταφέρνουν και με λιγότερο από ένα gigabyte μνήμης, αλλά με τέτοιους περιορισμούς φυσικής μνήμης, είναι αρκετά πιθανό να δημιουργηθεί panic κάτω από βαρύ φορτίο εργασίας, εξαιτίας εξάντλησης της.</p></div></div><div class=sect4><h5 id=_ρύθμιση_του_πυρήνα_2>41.2.1.2. Ρύθμιση του Πυρήνα<a class=anchor href=#_ρύθμιση_του_πυρήνα_2></a></h5><div class=paragraph><p>Συνίσταται να αφαιρέσετε τα προγράμματα οδήγησης και τις επιλογές που δεν χρησιμοποιείτε από το αρχείο ρυθμίσεων του πυρήνα. Καθώς οι περισσότεροι οδηγοί συσκευών διατίθενται επίσης και σε μορφή αρθρωμάτων, μπορείτε να τους φορτώσετε χρησιμοποιώντας το αρχείο <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Οι χρήστες της αρχιτεκτονικής i386™ θα πρέπει να προσθέσουν την παρακάτω επιλογή στο αρχείο ρυθμίσεων του πυρήνα τους, να τον επαναμεταγλωττίσουν και να επανεκκινήσουν το σύστημα τους:</p></div><div class="literalblock programlisting"><div class=content><pre>options 	KVA_PAGES=512</pre></div></div><div class=paragraph><p>Η επιλογή αυτή θα διευρύνει την περιοχή διευθύνσεων του πυρήνα, επιτρέποντας έτσι την αύξηση τιμής της ρυθμιστικής μεταβλητής <code>vm.kvm_size</code> πέρα από το τρέχον όριο του 1 GB (2 GB για πυρήνες PAE). Για να βρείτε την καταλληλότερη τιμή για αυτή την επιλογή, διαιρέστε το επιθυμητό μέγεθος της περιοχής διευθύνσεων με το τέσσερα (4). Στην περίπτωση αυτή, έχουμε <code>512</code> για μέγεθος 2 GB.</p></div></div><div class=sect4><h5 id=_ρυθμίσεις_στις_μεταβλητές_του_loader>41.2.1.3. Ρυθμίσεις στις Μεταβλητές του Loader<a class=anchor href=#_ρυθμίσεις_στις_μεταβλητές_του_loader></a></h5><div class=paragraph><p>Θα πρέπει να αυξηθεί η περιοχή διευθύνσεων <span class=filename>kmem</span> σε όλες τις αρχιτεκτονικές του FreeBSD. Στο δοκιμαστικό μας σύστημα, με ένα gigabyte φυσικής μνήμης, είχαμε επιτυχημένο αποτέλεσμα χρησιμοποιώντας τις ακόλουθες επιλογές στο αρχείο <span class=filename>/boot/loader.conf</span> και επανεκκινώντας το σύστημα μας:</p></div><div class="literalblock programlisting"><div class=content><pre>vm.kmem_size=&#34;330M&#34;
vm.kmem_size_max=&#34;330M&#34;
vfs.zfs.arc_max=&#34;40M&#34;
vfs.zfs.vdev.cache.size=&#34;5M&#34;</pre></div></div><div class=paragraph><p>Για αναλυτικότερες ρυθμίσεις σχετικά με την βελτιστοποίηση του ZFS, δείτε το <a href=http://wiki.freebsd.org/ZFSTuningGuide>http://wiki.freebsd.org/ZFSTuningGuide</a>.</p></div></div></div><div class=sect3><h4 id=_χρησιμοποιώντας_το_zfs>41.2.2. Χρησιμοποιώντας το ZFS<a class=anchor href=#_χρησιμοποιώντας_το_zfs></a></h4><div class=paragraph><p>Υπάρχει ένας μηχανισμός εκκίνησης που επιτρέπει στο FreeBSD να προσαρτήσει ZFS pools κατά τη διάρκεια της εκκίνησης του συστήματος. Για να τον ρυθμίσετε, εκτελέστε τις ακόλουθες εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;zfs_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># /etc/rc.d/zfs start</span></code></pre></div></div><div class=paragraph><p>Το υπόλοιπο αυτού του κειμένου υποθέτει ότι έχετε διαθέσιμους τρεις SCSI δίσκους, και ότι τα ονόματα συσκευών τους είναι <span class=filename>da0</span>, <span class=filename>da1</span> και <span class=filename>da2</span>. Όσοι διαθέτουν δίσκους IDE θα πρέπει να χρησιμοποιήσουν συσκευές του τύπου <span class=filename>ad</span> αντί για τις αντίστοιχες SCSI.</p></div><div class=sect4><h5 id=_pool_με_ένα_μόνο_δίσκο>41.2.2.1. Pool με Ένα Μόνο Δίσκο<a class=anchor href=#_pool_με_ένα_μόνο_δίσκο></a></h5><div class=paragraph><p>Για την δημιουργία ενός ZFS pool με ένα μόνο δίσκο (χωρίς δυνατότητα ανοχής σφαλμάτων), χρησιμοποιήστε την εντολή <code>zpool</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create example /dev/da0</span></code></pre></div></div><div class=paragraph><p>Για να δείτε το νέο pool, εξετάστε την έξοδο της εντολής <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example</code></pre></div></div><div class=paragraph><p>Η έξοδος αυτή δείχνει καθαρά ότι το <code>example</code> pool όχι μόνο έχει δημιουργηθεί, αλλά έχει επίσης <em>προσαρτηθεί</em> κιόλας. Είναι επίσης διαθέσιμο ως κανονικό σύστημα αρχείων, μπορείτε να δημιουργήσετε αρχεία σε αυτό, και άλλοι χρήστες μπορούν επίσης να το δουν, όπως φαίνεται στο παρακάτω παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /example</span>
<span class=c># ls</span>
<span class=c># touch testfile</span>
<span class=c># ls -al</span>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 <span class=nb>.</span>
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
<span class=nt>-rw-r--r--</span>   1 root  wheel    0 Aug 29 23:15 testfile</code></pre></div></div><div class=paragraph><p>Δυστυχώς αυτό το pool δεν χρησιμοποιεί κάποιο από τα πλεονεκτήματα του ZFS. Δημιουργήστε ένα σύστημα αρχείων σε αυτό το pool και ενεργοποιήστε σε αυτό τη συμπίεση:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/compressed</span>
<span class=c># zfs set compression=gzip example/compressed</span></code></pre></div></div><div class=paragraph><p>Το σύστημα αρχείων <code>example/compressed</code> είναι πλέον ένα συμπιεσμένο ZFS σύστημα. Δοκιμάστε να αντιγράψετε μερικά μεγάλα αρχεία σε αυτό, απευθείας στον κατάλογο <span class=filename>/example/compressed</span>.</p></div><div class=paragraph><p>Μπορείτε τώρα να απενεργοποιήσετε τη συμπίεση γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set compression=off example/compressed</span></code></pre></div></div><div class=paragraph><p>Για να αποπροσαρτήσετε το σύστημα αρχείων, εκτελέστε την ακόλουθη εντολή και επαληθεύστε το αποτέλεσμα μέσω του βοηθητικού προγράμματος <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs umount example/compressed</span>
<span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example</code></pre></div></div><div class=paragraph><p>Προσαρτήστε ξανά το σύστημα αρχείων, ώστε να είναι και πάλι προσβάσιμο, και επαληθεύστε το χρησιμοποιώντας όπως και πριν, την εντολή <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs mount example/compressed</span>
<span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed</code></pre></div></div><div class=paragraph><p>Μπορείτε επίσης να δείτε το pool και το σύστημα αρχείων εξετάζοντας την έξοδο της εντολής <code>mount</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
example on /example <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
example/data on /example/data <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
example/compressed on /example/compressed <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span></code></pre></div></div><div class=paragraph><p>Όπως παρατηρούμε, το σύστημα αρχείων ZFS μπορεί να χρησιμοποιηθεί ως κοινό σύστημα αρχείων μετά τη δημιουργία του. Ωστόσο, διαθέτει πολλές ακόμα λειτουργίες. Στο παρακάτω παράδειγμα δημιουργούμε ένα νέο σύστημα αρχείων, το <code>data</code>. θα αποθηκεύσουμε σημαντικά δεδομένα σε αυτό, και έτσι το ρυθμίζουμε ώστε να κρατάει δύο αντίγραφα από κάθε μπλοκ δεδομένων:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/data</span>
<span class=c># zfs set copies=2 example/data</span></code></pre></div></div><div class=paragraph><p>Μπορούμε τώρα να δούμε τα δεδομένα και την κατανάλωση χώρου δίνοντας ξανά την εντολή <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data</code></pre></div></div><div class=paragraph><p>Παρατηρήστε ότι κάθε σύστημα αρχείων στο pool δείχνει το ίδιο μέγεθος διαθέσιμου χώρου. Αυτός είναι και ο λόγος που χρησιμοποιούμε την εντολή <code>df</code> σε όλα τα παραδείγματα, για να δείξουμε ότι τα συστήματα αρχείων χρησιμοποιούν μόνο το χώρο που χρειάζονται και ότι όλα μοιράζονται τον ίδιο χώρο (το κοινόχρηστο απόθεμα - pool). Στο σύστημα αρχείων ZFS έννοιες όπως οι τόμοι (volumes) και οι κατατμήσεις (partitions) δεν έχουν νόημα. Αντίθετα, πολλά συστήματα αρχείων μοιράζονται τον ίδιο χώρο, το pool. Μπορείτε να καταργήσετε το σύστημα αρχείων και κατόπιν το ίδιο το pool όταν δεν τα χρειάζεστε πλέον:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy example/compressed</span>
<span class=c># zfs destroy example/data</span>
<span class=c># zpool destroy example</span></code></pre></div></div><div class=paragraph><p>Οι σκληροί δίσκοι με τον καιρό χαλάνε, είναι αναπόφευκτο. Όταν ένας δίσκος χαλάσει, τα δεδομένα του χάνονται. Μια μέθοδος για να αποφύγουμε την απώλεια δεδομένων εξαιτίας ενός χαλασμένου δίσκου είναι να δημιουργήσουμε μια συστοιχία RAID. Τα pools του ZFS έχουν σχεδιασθεί ώστε να υποστηρίζουν αυτό το χαρακτηριστικό. Η λειτουργία αυτή αναλύεται στην επόμενη ενότητα.</p></div></div><div class=sect4><h5 id=_zfs_raid_z>41.2.2.2. ZFS RAID-Z<a class=anchor href=#_zfs_raid_z></a></h5><div class=paragraph><p>Όπως αναφέραμε προηγουμένως, η ενότητα αυτή προϋποθέτει ότι χρησιμοποιούμε τρεις συσκευές SCSI με ονόματα συσκευών <span class=filename>da0</span>, <span class=filename>da1</span> και <span class=filename>da2</span>. Για να δημιουργήσουμε ένα pool τύπου RAID-Z, εκτελούμε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create storage raidz da0 da1 da2</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η Sun™ συνιστά να χρησιμοποιούνται από τρεις ως εννιά συσκευές σε συστοιχίες τύπου RAID-Z. Αν χρειάζεται να δημιουργήσετε ένα pool με περισσότερους από δέκα δίσκους, είναι προτιμότερο να το χωρίσετε σε ομάδες από μικρότερα RAID-Z pools. Αν διαθέτετε μόνο δύο δίσκους αλλά χρειάζεστε την δυνατότητα ανοχής σφαλμάτων, ίσως είναι καλύτερο να χρησιμοποιήσετε ένα ZFS mirror. Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> για περισσότερες λεπτομέρειες.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Θα δημιουργηθεί το <code>storage</code> zpool. Μπορείτε να επαληθεύσετε το αποτέλεσμα χρησιμοποιώντας, όπως και προηγουμένως, τις εντολές <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a>. Θα μπορούσαμε να χρησιμοποιήσουμε περισσότερους δίσκους, προσθέτοντας τα ονόματα συσκευών τους στο τέλος της παραπάνω λίστας. Δημιουργήστε ένα νέο σύστημα αρχείων στο pool, το οποίο θα ονομάζεται <code>home</code> και όπου θα αποθηκεύονται τελικά τα αρχεία των χρηστών:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create storage/home</span></code></pre></div></div><div class=paragraph><p>Μπορούμε τώρα να ενεργοποιήσουμε την συμπίεση και να κρατάμε επιπλέον αντίγραφα των καταλόγων και των δεδομένων των χρηστών. Όπως και προηγουμένως, μπορούμε να το επιτύχουμε χρησιμοποιώντας τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set copies=2 storage/home</span>
<span class=c># zfs set compression=gzip storage/home</span></code></pre></div></div><div class=paragraph><p>Για να γίνει αυτός ο νέος κατάλογος των χρηστών, αντιγράψτε τα δεδομένα τους σε αυτόν και δημιουργήστε τους κατάλληλους συμβολικούς δεσμούς:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp -rp /home/* /storage/home</span>
<span class=c># rm -rf /home /usr/home</span>
<span class=c># ln -s /storage/home /home</span>
<span class=c># ln -s /storage/home /usr/home</span></code></pre></div></div><div class=paragraph><p>Τα δεδομένα των χρηστών θα αποθηκεύονται τώρα στο νέο σύστημα αρχείων <span class=filename>/storage/home</span>. Για να το επαληθεύσετε, δημιουργήστε ένα νέο χρήστη και εισέλθετε στο σύστημα με το νέο λογαριασμό.</p></div><div class=paragraph><p>Δοκιμάστε να δημιουργήσετε ένα στιγμιότυπο (snapshot) στο οποίο θα μπορείτε να επανέλθετε αργότερα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Σημειώστε ότι η επιλογή δημιουργίας στιγμιότυπου λειτουργεί μόνο σε πραγματικό σύστημα αρχείων, και όχι σε κάποιο μεμονωμένο κατάλογο ή αρχείο. Ο χαρακτήρας <code>@</code> χρησιμοποιείται ως διαχωριστικό μεταξύ του συστήματος αρχείων και του ονόματος τόμου. Αν καταστραφεί ο κατάλογος δεδομένων κάποιου χρήστη αποκαταστήστε τον με την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Για να δείτε μια λίστα των διαθέσιμων στιγμιότυπων, εκτελέστε την εντολή <code>ls</code> στον κατάλογο <span class=filename>.zfs/snapshot</span> του συστήματος αρχείων. Για παράδειγμα, για να δείτε το στιγμιότυπο που δημιουργήσαμε προηγουμένως, εκτελέστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /storage/home/.zfs/snapshot</span></code></pre></div></div><div class=paragraph><p>Είναι δυνατόν να γράψετε κάποιο script που να δημιουργεί μηνιαία στιγμιότυπα των δεδομένων των χρηστών. Ωστόσο, με την πάροδο του χρόνου, τα στιγμιότυπα θα καταναλώσουν μεγάλο ποσοστό του χώρου στο δίσκο. Μπορείτε να διαγράψετε το προηγούμενο στιγμιότυπο χρησιμοποιώντας την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Δεν υπάρχει λόγος, μετά από όλες αυτές τις δοκιμές, να κρατήσουμε το <span class=filename>/storage/home</span> στην παρούσα κατάσταση του. Μετατρέψτε το στο πραγματικό σύστημα αρχείων <span class=filename>/home</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set mountpoint=/home storage/home</span></code></pre></div></div><div class=paragraph><p>Χρησιμοποιώντας τις εντολές <code>df</code> και <code>mount</code> θα δούμε ότι το σύστημα χειρίζεται πλέον αυτό το σύστημα αρχείων ως το πραγματικό <span class=filename>/home</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
storage on /storage <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
storage/home on /home <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
<span class=c># df</span>
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home</code></pre></div></div><div class=paragraph><p>Εδώ ολοκληρώνεται η ρύθμιση του RAID-Z. Για να δέχεστε αναφορές κατάστασης σχετικά με τα συστήματα αρχείων κατά τη νυκτερινή εκτέλεση του <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>, δώστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;daily_status_zfs_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/periodic.conf</span></code></pre></div></div></div><div class=sect4><h5 id=_ανάκτηση_του_raid_z>41.2.2.3. Ανάκτηση του RAID-Z<a class=anchor href=#_ανάκτηση_του_raid_z></a></h5><div class=paragraph><p>Κάθε λογισμικό RAID έχει μια μέθοδο για επίβλεψη της κατάστασής του, και το ZFS δεν αποτελεί εξαίρεση. Μπορείτε να δείτε την κατάσταση των συσκευών του RAID-Z χρησιμοποιώντας την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status -x</span></code></pre></div></div><div class=paragraph><p>Αν όλα τα pools είναι σε υγιή κατάσταση, θα πάρετε το ακόλουθο μήνυμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>all pools are healthy</code></pre></div></div><div class=paragraph><p>Αν υπάρχει κάποιο πρόβλημα, π.χ. κάποιος δίσκος έχει βγει εκτός λειτουργίας, θα δείτε την περιγραφή της κατάστασης σε ένα μήνυμα όπως το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist <span class=k>for </span>the pool to <span class=k>continue </span>functioning <span class=k>in </span>a
	degraded state.
action: Online the device using <span class=s1>&#39;zpool online&#39;</span> or replace the device with
	<span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Το παραπάνω δείχνει ότι η συσκευή τέθηκε εκτός λειτουργίας από τον διαχειριστή. Αυτό είναι αλήθεια για το συγκεκριμένο παράδειγμα. Για να τεθεί ο δίσκος εκτός, χρησιμοποιήθηκε η παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool offline storage da1</span></code></pre></div></div><div class=paragraph><p>Μπορούμε τώρα να αντικαταστήσουμε το δίσκο <span class=filename>da1</span> μετά την απενεργοποίηση του συστήματος. Όταν το σύστημα επανέλθει σε λειτουργία, μπορούμε να χρησιμοποιήσουμε την ακόλουθη εντολή για να ενημερώσουμε το σύστημα για την αντικατάσταση του δίσκου:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool replace storage da1</span></code></pre></div></div><div class=paragraph><p>Από εδώ, μπορούμε να ελέγξουμε ξανά την κατάσταση, αυτή τη φορά χωρίς την επιλογή <code>-x</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Όπως φαίνεται στο παράδειγμα, τα πάντα φαίνεται να λειτουργούν φυσιολογικά.</p></div></div><div class=sect4><h5 id=_επαλήθευση_δεδομένων>41.2.2.4. Επαλήθευση Δεδομένων<a class=anchor href=#_επαλήθευση_δεδομένων></a></h5><div class=paragraph><p>Όπως αναφέραμε προηγουμένως, το ZFS χρησιμοποιεί <code>checksums</code> (αθροίσματα ελέγχου) για να επαληθεύσει την ακεραιότητα των αποθηκευμένων δεδομένων. Τα αθροίσματα ελέγχου ενεργοποιούνται αυτόματα κατά την δημιουργία των συστημάτων αρχείων, και μπορούν να απενεργοποιηθούν μέσω της επόμενης εντολής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set checksum=off storage/home</span></code></pre></div></div><div class=paragraph><p>Αυτό δεν είναι γενικά καλή ιδέα, καθώς τα checksums καταλαμβάνουν ελάχιστο αποθηκευτικό χώρο, και είναι πολύ πιο χρήσιμο να τα έχουμε ενεργοποιημένα. Επίσης δεν φαίνεται να προκαλούν κάποια σημαντική καθυστέρηση ή επιβάρυνση. Με τα checksums ενεργοποιημένα, μπορούμε να ζητήσουμε από το ZFS να ελέγξει την ακεραιότητα των δεδομένων χρησιμοποιώντας τα για επαλήθευση. Η διαδικασία αυτή είναι γνωστή ως "scrubbing." Για να ελέγξετε την ακεραιότητα δεδομένων του pool <code>storage</code>, χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub storage</span></code></pre></div></div><div class=paragraph><p>Η διαδικασία αυτή μπορεί να πάρει αρκετή ώρα, ανάλογα με την ποσότητα των αποθηκευμένων δεδομένων. Επίσης χρησιμοποιεί πάρα πολύ το δίσκο (I/O), τόσο ώστε σε κάθε δεδομένη στιγμή μπορεί να εκτελείται μόνο μια τέτοια διαδικασία. Μετά την ολοκλήρωση του scrub, θα ανανεωθεί και η αναφορά κατάστασης, την οποία μπορείτε να δείτε ζητώντας την με την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Aug 30 19:57:37 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Στο παράδειγμα μας εμφανίζεται και η χρονική στιγμή που ολοκληρώθηκε η εντολή scrub. Η δυνατότητα αυτή μας εξασφαλίζει ακεραιότητα δεδομένων σε μεγάλο βάθος χρόνου.</p></div><div class=paragraph><p>Υπάρχουν πολλές ακόμα επιλογές για το σύστημα αρχείων Ζ. Δείτε τις σελίδες manual <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>.</p></div></div><div class=sect4><h5 id=_zfs_quotas>41.2.2.5. ZFS Quotas<a class=anchor href=#_zfs_quotas></a></h5><div class=paragraph><p>Το ZFS υποστηρίζει διαφορετικούς τύπους quota: το refquota, το γενικό quota, το quota χρήστη και το quota ομάδας. Στην ενότητα αυτή θα εξηγήσουμε τις βασικές έννοιες κάθε τύπου και θα δώσουμε κάποιες οδηγίες χρήσης.</p></div><div class=paragraph><p>Τα quotas χρησιμοποιούνται για να περιορίσουν το χώρο στο δίσκο που μπορεί να καταναλωθεί από ένα dataset και τους απογόνους του (descendants) του καθώς και για να θέσουν περιορισμούς στο χώρο που μπορεί να καταλάβει ένα στιγμιότυπο (snapshot). Σε όρους χρήστη, τα quotas είναι χρήσιμα για τον περιορισμό του χώρου δίσκου που μπορεί να έχει στη διάθεση του κάποιος χρήστης.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Δεν μπορείτε να ορίσετε quotas σε τόμους (volumes) καθώς αυτό ουσιαστικά γίνεται ήδη από την ιδιότητα <code>volsize</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το refquota, <code>refquota=size</code>, περιορίζει το χώρο που μπορεί να καταναλώσει ένα dataset θέτοντας ένα απόλυτο όριο χώρου (hard limit). Ωστόσο, αυτό το απόλυτο όριο δεν περιλαμβάνει το χώρο που χρησιμοποιείται από τους απογόνους του dataset όπως τα συστήματα αρχείων ή τα στιγμιότυπα.</p></div><div class=paragraph><p>Για να επιβάλετε γενικό quota 10 GB για το <span class=filename>storage/home/bob</span>, χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set quota=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Τα quotas χρήστη περιορίζουν την ποσότητα χώρου που μπορεί να χρησιμοποιήσει ένας συγκεκριμένος χρήστης. Η γενική μορφή είναι <code>userquota@user=size</code>, και το όνομα του χρήστη πρέπει να δίνεται σε μια από τις παρακάτω μορφές:</p></div><div class=ulist><ul><li><p>Μορφή συμβατή με το POSIX, για παράδειγμα <em>joe</em>.</p></li><li><p>Μορφή συμβατή με το αριθμητικό αναγνωριστικό (ΙD) του POSIX, για παράδειγμα <em>789</em>.</p></li><li><p>Μορφή ονόματος SID, για παράδειγμα <em>joe.bloggs@example.com</em>.</p></li><li><p>Μορφή αριθμητικού αναγνωριστικού (ID) SID, για παράδειγμα <em>S-1-123-456-789</em>.</p></li></ul></div><div class=paragraph><p>Για παράδειγμα, για να επιβάλετε quota 50 GB για ένα χρήστη με όνομα <em>joe</em>, χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=50G</span></code></pre></div></div><div class=paragraph><p>Για να αφαιρέσετε το quota ή να βεβαιωθείτε ότι δεν έχει τεθεί, χρησιμοποιήστε την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=none</span></code></pre></div></div><div class=paragraph><p>Οι ιδιότητες των quota χρηστών δεν απεικονίζονται μέσω της εντολής <code>zfs get all</code>. Οι χρήστες εκτός του <code>root</code> μπορούν να δουν μόνο τα δικά τους quotas εκτός αν τους έχει αποδοθεί το προνόμιο <code>userquota</code>. Οι χρήστες με αυτό το προνόμιο μπορούν να δουν και να ρυθμίσουν τo quota οποιουδήποτε χρήστη.</p></div><div class=paragraph><p>Το quota ομάδας περιορίζει το διαθέσιμο χώρο που μπορεί να χρησιμοποιηθεί από μια συγκεκριμένη ομάδα χρηστών. Η γενική μορφή είναι <code>groupquota@group=size</code>.</p></div><div class=paragraph><p>Για να θέσετε quota για την ομάδα χρηστών <em>firstgroup</em> τα 50 GB, χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=50G</span></code></pre></div></div><div class=paragraph><p>Για να αφαιρέσετε το quota ή να βεβαιωθείτε ότι δεν έχει τεθεί, χρησιμοποιήστε την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=none</span></code></pre></div></div><div class=paragraph><p>Όπως και με την ιδιότητα quota χρηστών, οι χρήστες εκτός του <code>root</code> μπορούν να δουν μόνο τα quota που σχετίζονται με τις ομάδες στις οποίες ανήκουν. Ωστόσο, ο χρήστης <code>root</code> και κάθε χρήστης στον οποίο έχει δοθεί το προνόμιο <code>groupquota</code> μπορεί να δει και να ρυθμίσει τα quota για όλες τις ομάδες.</p></div><div class=paragraph><p>Η υπο-εντολή <code>zfs userspace</code> απεικονίζει την ποσότητα χώρου που καταναλώνει κάθε χρήστης στο συγκεκριμένο σύστημα αρχείων ή στιγμιότυπο καθώς και το καθορισμένο quota. Η υπο-εντολή <code>zfs groupspace</code> εκτελεί ακριβώς το ίδιο για ομάδες χρηστών. Για περισσότερες πληροφορίες σχετικά με τις επιλογές εκτέλεσης ή απεικόνισης αυτών των εντολών, δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=1&amp;format=html">zfs(1)</a>.</p></div><div class=paragraph><p>Για να δειτε το quota για το <span class=filename>storage/home/bob</span>, αν έχετε τα σωστά προνόμια ή είστε ο <code>root</code>, χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get quota storage/home/bob</span></code></pre></div></div></div><div class=sect4><h5 id=_κρατήσεις_χώρου_reservations_στο_zfs>41.2.2.6. Κρατήσεις Χώρου (reservations) στο ZFS<a class=anchor href=#_κρατήσεις_χώρου_reservations_στο_zfs></a></h5><div class=paragraph><p>Το ZFS υποστηρίζει δύο τύπους κρατήσεων χώρου. Σε αυτή την ενότητα θα εξηγήσουμε τις βασικές έννοιες κάθε τύπο και θα δώσουμε κάποιες οδηγίες χρήσης.</p></div><div class=paragraph><p>Η ιδιότητα <code>reservation</code> μας επιτρέπει να διαφυλάξουμε κάποιο εγγυημένο ελάχιστο ποσό χώρου για ένα dataset και τους απογόνους του. Αυτό σημαίνει ότι αν τεθεί κράτηση χώρου 10 GB στο <span class=filename>storage/home/bob</span> και ο διαθέσιμος χώρος του δίσκου καταστεί ελάχιστος, θα διαφυλαχθούν τουλάχιστον 10 GB χώρου για αυτό το dataset. Η ιδιότητα <code>refreservation</code> θέτει ή δείχνει την ελάχιστη ποσότητα χώρου που έχει κρατηθεί για ένα dataset χωρίς τους απογόνους του (π.χ. τα στιγμιότυπα). Για παράδειγμα, για να πάρετε ένα στιγμιότυπο του <span class=filename>storage/home/bob</span> θα πρέπει να έχετε επαρκή χώρο εκτός της ποσότητας <code>refreservation</code> για να εκτελέσετε επιτυχώς τη λειτουργία. Οι απόγονοι του κυρίου dataset δεν προσμετρώνται από την ιδιότητα <code>refreservation</code> και δεν καταπατούν τον ελεύθερο χώρο του.</p></div><div class=paragraph><p>Οι κρατήσεις κάθε τύπου είναι χρήσιμες σε πολλές περιπτώσεις, για παράδειγμα στο σχεδιασμό και δοκιμή καταλληλότητας της κατανομής χώρου σε ένα νέο σύστημα ή την εξασφάλιση διαθεσιμότητας αρκετού ελεύθερου χώρου σε ένα σύστημα για λειτουργίες ανάκτησης δεδομένων (recovery).</p></div><div class=paragraph><p>Η γενική μορφή της ιδιότητας <code>reservation</code> είναι <code>reservation=size</code>. Για να θέσετε κράτηση 10 GB στο <span class=filename>storage/home/bob</span> χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Για να αφαιρέσετε ένα reservation ή να βεβαιωθείτε ότι δεν έχει τεθεί, εκτελέστε την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=none storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Μπορείτε να εφαρμόσετε την ίδια βασική αρχή και για να θέσετε την ιδιότητα <code>refreservation</code>, χρησιμοποιώντας τη γενική μορφή <code>refreservation=size</code>.</p></div><div class=paragraph><p>Για να ελέγξετε αν υπάρχουν reservations ή refreservations στο <span class=filename>storage/home/bob</span>, εκτελέστε μια από τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get reservation storage/home/bob</span>
<span class=c># zfs get refreservation storage/home/bob</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=filesystems-linux>41.3. Συστήματα Αρχείων Linux®<a class=anchor href=#filesystems-linux></a></h3><div class=paragraph><p>Αυτή η ενότητα περιγράφει κάποια από τα συστήματα αρχείων του Linux® που υποστηρίζονται από το FreeBSD.</p></div><div class=sect3><h4 id=_ext2fs>41.3.1. Ext2FS<a class=anchor href=#_ext2fs></a></h4><div class=paragraph><p>Η υλοποίηση του συστήματος αρχείων <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> στον πυρήνα, γράφηκε από τον Godmar Back και το πρόγραμμα οδήγησης εμφανίστηκε για πρώτη φορά στο FreeBSD 2.2. Στο FreeBSD 8 και στις προηγούμενες εκδόσεις, ο κώδικας ήταν υπό την άδεια GNU Public License, ωστόσο στο FreeBSD 9 o κώδικας γράφτηκε ξανά και είναι πλέον υπό την άδεια BSD.</p></div><div class=paragraph><p>Το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> επιτρέπει στον πυρήνα του FreeBSD τόσο να διαβάζει όσο και να γράφει σε συστήματα αρχείων ext2.</p></div><div class=paragraph><p>Αρχικά, φορτώστε το άρθρωμα στον πυρήνα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ext2fs</span></code></pre></div></div><div class=paragraph><p>Για να προσαρτήσετε έπειτα ένα τόμο <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> που βρίσκεται στο <span class=filename>/dev/ad1s1</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t ext2fs /dev/ad1s1 /mnt</span></code></pre></div></div></div><div class=sect3><h4 id=_xfs>41.3.2. XFS<a class=anchor href=#_xfs></a></h4><div class=paragraph><p>Το σύστημα αρχείων Χ, XFS γράφτηκε αρχικά από την SGI για το λειτουργικό IRIX και μεταφέρθηκε στο Linux®. Ο πηγαίος κώδικας είναι διαθέσιμος υπό την άδεια GNU Public License. Δείτε <a href=http://oss.sgi.com/projects/xfs>αυτή τη σελίδα</a> για περισσότερες πληροφορίες. Η μεταφορά στο FreeBSD ξεκίνησε από τους Russel Cattelan, Alexander Kabaev &lt;<a href=mailto:kan@FreeBSD.org>kan@FreeBSD.org</a>> και Craig Rodrigues &lt;<a href=mailto:rodrigc@FreeBSD.org>rodrigc@FreeBSD.org</a>>.</p></div><div class=paragraph><p>Για να φορτώσετε το XFS ως άρθρωμα στον πυρήνα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload xfs</span></code></pre></div></div><div class=paragraph><p>Το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=xfs&amp;sektion=5&amp;format=html">xfs(5)</a> επιτρέπει στον πυρήνα του FreeBSD να έχει πρόσβαση σε συστήματα αρχείων XFS. Ωστόσο, τη δεδομένη στιγμή, επιτρέπει πρόσβαση μόνο για ανάγνωση. Η εγγραφή δεν είναι δυνατή.</p></div><div class=paragraph><p>Για να προσαρτήσετε ένα τόμο <a href="https://man.freebsd.org/cgi/man.cgi?query=xfs&amp;sektion=5&amp;format=html">xfs(5)</a> που βρίσκεται στο <span class=filename>/dev/ad1s1</span>, εκτελέστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t xfs /dev/ad1s1 /mnt</span></code></pre></div></div><div class=paragraph><p>Καλό είναι επίσης να γνωρίζετε ότι το port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xfsprogs/>sysutils/xfsprogs</a> περιέχει το βοηθητικό πρόγραμμα <code>mkfs.xfs</code> το οποίο επιτρέπει τη δημιουργία συστημάτων αρχείων XFS. Το port επίσης παρέχει προγράμματα για έλεγχο και επισκευή αυτών των συστημάτων αρχείων.</p></div><div class=paragraph><p>Μπορείτε να χρησιμοποίησετε την παράμετρο <code>-p</code> στην εντολή <code>mkfs.xfs</code> για να δημιουργήσετε ένα σύστημα αρχείων <a href="https://man.freebsd.org/cgi/man.cgi?query=xfs&amp;sektion=5&amp;format=html">xfs(5)</a> το οποίο να περιέχει αρχεία και άλλα μετα-δεδομένα. Mε αυτό τον τρόπο μπορείτε να δημιουργήσετε ένα σύστημα αρχείων μόνο ανάγνωσης για δοκιμή με το FreeBSD.</p></div></div><div class=sect3><h4 id=_reiserfs>41.3.3. ReiserFS<a class=anchor href=#_reiserfs></a></h4><div class=paragraph><p>To σύστημα αρχείων Reiser, ReiserFS, μεταφέρθηκε στο FreeBSD από τον Jean-Sébastien Pédron &lt;<a href=mailto:dumbbell@FreeBSD.org>dumbbell@FreeBSD.org</a>> και είναι υπό την άδεια GNU Public License.</p></div><div class=paragraph><p>Το πρόγραμμα οδήγησης για το ReiserFS επιτρέπει στον πυρήνα του FreeBSD να έχει πρόσβαση ανάγνωσης στα αντίστοιχα συστήματα αρχείων αλλά τη δεδομένη στιγμή δεν επιτρέπει εγγραφή δεδομένων.</p></div><div class=paragraph><p>Φορτώστε αρχικά το άρθρωμα του πυρήνα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload reiserfs</span></code></pre></div></div><div class=paragraph><p>Για να προσαρτήσετε ένα τόμο ReiserFS από το <span class=filename>/dev/ad1s1</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t reiserfs /dev/ad1s1 /mnt</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=virtualization>Chapter 42. Εικονικοποίηση<a class=anchor href=#virtualization></a></h2><div class=sectionbody><div class=sect2><h3 id=virtualization-synopsis>42.1. Σύνοψη<a class=anchor href=#virtualization-synopsis></a></h3><div class=paragraph><p>Το λογισμικό εικονικοποίησης επιτρέπει σε πολλαπλά λειτουργικά συστήματα να εκτελούνται ταυτόχρονα στον ίδιο υπολογιστή. Σε υπολογιστές PC το λογισμικό αυτό τυπικά χρησιμοποιεί ένα λειτουργικό ως ξενιστή (host) στο οποίο και εκτελείται, και το οποίο υποστηρίζει ένα οποιοδήποτε αριθμό από φιλοξενούμενα (guest) λειτουργικά.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Τη διαφορά μεταξύ ενός ξενιστή (host) και ενός φιλοξενούμενου (guest) λειτουργικού.</p></li><li><p>Πως να εγκαταστήσετε το FreeBSD σε ένα Apple® Macintosh® υπολογιστή που βασίζεται σε Intel® αρχιτεκτονική.</p></li><li><p>Πώς να εγκαταστήσετε το FreeBSD κάτω από Microsoft® Windows® με το Virtual PC.</p></li><li><p>Πως να βελτιστοποιήσετε ένα FreeBSD σύστημα για την καλύτερη απόδοση σε περιβάλλον εικονικού μηχανήματος.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να έχετε κατανοήσει τις βασικές έννοιες του UNIX® και του FreeBSD (<a href=./#basics>Βασικές Έννοιες στο UNIX®</a>).</p></li><li><p>Να γνωρίζετε πως θα εγκαταστήσετε το FreeBSD (<a href=./#install>Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a>).</p></li><li><p>Να γνωρίζετε πως θα ρυθμίσετε τη σύνδεση σας στο δίκτυο (<a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a>).</p></li><li><p>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=virtualization-guest>42.2. Το FreeBSD ως φιλοξενούμενο λειτουργικό<a class=anchor href=#virtualization-guest></a></h3><div class=sect3><h4 id=virtualization-guest-parallels>42.2.1. Το Parallels σε MacOS<a class=anchor href=#virtualization-guest-parallels></a></h4><div class=paragraph><p>Το Parallels Desktop για Mac® είναι ένα εμπορικό λογισμικό το οποίον είναι διαθέσιμο για υπολογιστές Apple® Mac® με επεξεργαστή Intel® και λειτουργικό Mac OS® 10.4.6 ή νεότερο. Το FreeBSD παρέχει πλήρη υποστήριξη ως φιλοξενούμενο λειτουργικό. Όταν το Parallels έχει εγκατασταθεί στο Mac OS® X, ο χρήστης πρέπει να ρυθμίσει ένα εικονικό σύστημα και στη συνέχεια να εγκαταστήσει το φιλοξενούμενο λειτουργικό σύστημα που επιθυμεί.</p></div><div class=sect4><h5 id=virtualization-guest-parallels-install>42.2.1.1. Εγκαθιστώντας το FreeBSD στο Parallels/Mac OS® X<a class=anchor href=#virtualization-guest-parallels-install></a></h5><div class=paragraph><p>Το πρώτο βήμα για την εγκατάσταση του FreeBSD στο Mac OS® X/Parallels είναι να δημιουργήσετε ένα νέο εικονικό σύστημα για το FreeBSD. Όταν ερωτηθείτε, επιλέξτε <span class=guimenuitem>το FreeBSD</span> σαν το <b class=menuref>φιλοξενούμενο λειτουργικό (Guest OS)</b>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd1.png alt="parallels freebsd1"></div></div><div class=paragraph><p>Ορίστε ένα λογικό μέγεθος δίσκου και μνήμης που να ανταποκρίνεται στα σχέδια που έχετε για την εικονικοποίηση του FreeBSD. 4GB δίσκος και 512MB μνήμης δουλεύουν μια χαρά για τους περισσότερους χρήστες του FreeBSDμέσα από το Parallels:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd2.png alt="parallels freebsd2"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd3.png alt="parallels freebsd3"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd4.png alt="parallels freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd5.png alt="parallels freebsd5"></div></div><div class=paragraph><p>Επιλέξτε τον τύπο δικτύωσης και τον προσαρμογέα δικτύου:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd6.png alt="parallels freebsd6"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd7.png alt="parallels freebsd7"></div></div><div class=paragraph><p>Αποθήκευση και τέλος των ρυθμίσεων:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd8.png alt="parallels freebsd8"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd9.png alt="parallels freebsd9"></div></div><div class=paragraph><p>Όταν το εικονικό σύστημα έχει δημιουργηθεί, θα χρειαστεί να εγκαταστήσετε το ίδιο το FreeBSD. Ο καλύτερος τρόπος για να γίνει η εγκατάσταση είναι με το επίσημο FreeBSD CD-ROM ή με κάποιο αρχείο ISO, κατεβασμένο από τον επίσημο FTP τόπο. Όταν έχετε το κατάλληλο ISO στο σκληρό σας, ή το CD-ROM στον οδηγό CD, ενεργοποιήστε με το ποντίκι το εικονίδιο του CD στο κάτω δεξί μέρος της οθόνης του Parallels. Με αυτόν τον τρόπο θα μπορέσετε να ορίσετε την πηγή της εγκατάστασης. Μπορείτε να ορίσετε το CDROM ή κάποιο διαθέσιμο ISO αρχείο.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd11.png alt="parallels freebsd11"></div></div><div class=paragraph><p>Όταν έχετε αντιστοιχήσει τη πηγή εγκατάστασης, επανεκκινήστε το εικονικό σύστημα πατώντας απλά το κουμπί της επανεκκίνησης (reboot) του Parallels. Το Parallels θα ξεκινήσει με ένα ειδικό BIOS το οποίο πρώτα ελέγχει εάν υπάρχει διαθέσιμο κάποιο CD-ROM, όπως κάνει και ένα φυσιολογικό BIOS.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd10.png alt="parallels freebsd10"></div></div><div class=paragraph><p>Σε αυτή τη περίπτωση θα βρει το μέσο εγκατάστασης του FreeBSD και θα ξεκινήσει το sysinstall όπως περιγράφεται στο <a href=./#install>Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a>. Μπορείτε να εγκαταστήσετε το X11, αλλά μη δοκιμάσετε να ρυθμίσετε αυτή τη στιγμή.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd12.png alt="parallels freebsd12"></div></div><div class=paragraph><p>Όταν τελειώσετε με την εγκατάσταση, κάντε μια επανεκκίνηση στο φρέσκο εικονικό FreeBSD.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd13.png alt="parallels freebsd13"></div></div></div><div class=sect4><h5 id=virtualization-guest-parallels-configure>42.2.1.2. Ρυθμίζοντας το FreeBSD στο Mac OS® X/Parallels<a class=anchor href=#virtualization-guest-parallels-configure></a></h5><div class=paragraph><p>Αφού έχει εγκατασταθεί επιτυχώς το FreeBSD στο Mac OS® X με το Parallels, υπάρχουν μερικά βήματα ακόμη που μπορούν να σας βοηθήσουν να ρυθμίσετε το εικονικό σας σύστημα.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Μεταβλητές του Boot Loader</p><div class=paragraph><p>Το ποιο σημαντικό βήμα είναι να μειώσετε το μέγεθος του <code>kern.hz</code> προκειμένου να αξιοποιήσετε τη CPU μέσα από το Parallels. Αυτό μπορεί να γίνει με το να προσθέσετε την ακόλουθη γραμμή στο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Χωρίς αυτή τη ρύθμιση, ένα αδρανές FreeBSD στο Parallels θα καταναλώνει το 15% της CPU ενός μονοπύρηνου iMac®. Μετά από την αλλαγή, η κατανάλωση θα πέσει κοντά στο 5%.</p></div></li><li><p>Δημιουργία Νέου Αρχείου Ρυθμίσεων του Πυρήνα</p><div class=paragraph><p>Μπορείτε να αφαιρέσετε όλες τους οδηγούς για SCSI, FireWire, και USB συσκευές. Το Parallels παρέχει ένα εικονικό προσαρμογέα δικτύου ο οποίος χρησιμοποιείται από τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a>, οπότε όλοι οι οδηγοί για δικτυακές συσκευές εκτός των <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> μπορούν να αφαιρεθούν από τον πυρήνα.</p></div></li><li><p>Ρύθμιση Δικτύου</p><div class=paragraph><p>Η πιο απλή ρύθμιση δικτύου κάνει χρήση του DHCP για να συνδεθεί το εικονικό σας σύστημα στο ίδιο τοπικό δίκτυο με τον Mac®. Αυτό μπορεί εύκολα να γίνει με το να προσθέσετε τη γραμμή <code>ifconfig_ed0="DHCP"</code> στο <span class=filename>/etc/rc.conf</span>. Πολυπλοκότερες ρυθμίσεις δικτύου περιγράφονται στο κεφάλαιο <a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a>.</p></div></li></ol></div></div></div><div class=sect3><h4 id=virtualization-guest-virtualpc>42.2.2. Το Virtual PC στα Windows®<a class=anchor href=#virtualization-guest-virtualpc></a></h4><div class=paragraph><p>Το Virtual PC για Windows® είναι ένα προϊόν της Microsoft® που διατίθεται για δωρεάν κατέβασμα. Δείτε τις <a href=http://www.microsoft.com/windows/downloads/virtualpc/sysreq.mspx>απαιτήσεις συστήματος</a>. Μετά την εγκατάσταση του Virtual PC στα Microsoft® Windows®, ο χρήστης πρέπει να ρυθμίσει ένα εικονικό μηχάνημα και να εγκαταστήσει το φιλοξενούμενο λειτουργικό που επιθυμεί.</p></div><div class=sect4><h5 id=virtualization-guest-virtualpc-install>42.2.2.1. Εγκατάσταση του FreeBSD στο Virtual PC/Microsoft® Windows®<a class=anchor href=#virtualization-guest-virtualpc-install></a></h5><div class=paragraph><p>Το πρώτο βήμα στην εγκατάσταση του FreeBSD στα Microsoft® Windows® με χρήση του Virtual PC, είναι η δημιουργία ενός νέου εικονικού μηχανήματος για την εγκατάσταση του. Επιλέξτε <span class=guimenuitem>Create a virtual machine</span> όταν ερωτηθείτε:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd1.png alt="virtualpc freebsd1"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd2.png alt="virtualpc freebsd2"></div></div><div class=paragraph><p>Στην ερώτηση <span class=guimenuitem>Operating System</span> επιλέξτε <span class=guimenuitem>Other</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd3.png alt="virtualpc freebsd3"></div></div><div class=paragraph><p>Επιλέξτε έπειτα κατάλληλο μέγεθος για το σκληρό δίσκο και τη μνήμη RAM του εικονικού μηχανήματος, ανάλογα με τη χρήση που σκοπεύετε να κάνετε. Στις περισσότερες περιπτώσεις, τα 4GB δίσκου και 512MB RAM είναι αρκετά για χρήση του FreeBSD στο Virtual PC:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd4.png alt="virtualpc freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd5.png alt="virtualpc freebsd5"></div></div><div class=paragraph><p>Ολοκληρώστε αποθηκεύοντας τις ρυθμίσεις:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd6.png alt="virtualpc freebsd6"></div></div><div class=paragraph><p>Επιλέξτε την εικονική μηχανή FreeBSD που δημιουργήσατε και κάντε κλικ στο <span class=guimenuitem>Settings</span>. Ρυθμίστε έπειτα το είδος και την διεπαφή (interface) του δικτύου:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd7.png alt="virtualpc freebsd7"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd8.png alt="virtualpc freebsd8"></div></div><div class=paragraph><p>Αφού δημιουργήσετε την εικονική μηχανή σας για το FreeBSD, θα πρέπει να εγκαταστήσετε το λειτουργικό σε αυτήν. Ο καλύτερος τρόπος είναι να χρησιμοποιήσετε ένα από τα επίσημα CDROM του FreeBSD ή να κατεβάσετε κάποιο αρχείο ISO από την επίσημη τοποθεσία FTP. Έχοντας το κατάλληλο αρχείο ISO στο τοπικό σας σύστημα αρχείων των Windows® (ή το αντίστοιχο CDROM στον οδηγό), κάντε διπλό κλικ στο εικονίδιο της εικονικής μηχανής FreeBSD για να την εκκινήσετε. Έπειτα κάντε κλικ στο <b class=menuref>CD</b> και επιλέξτε <b class=menuref>Capture ISO Image…​</b> στο παράθυρο του Virtual PC. Θα εμφανιστεί ένα παράθυρο που θα σας επιτρέψει να συσχετίσετε τον εικονικό οδηγό CDROM με ένα αρχείο ISO ή και με τον πραγματικό σας οδηγό.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd9.png alt="virtualpc freebsd9"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd10.png alt="virtualpc freebsd10"></div></div><div class=paragraph><p>Μόλις δημιουργήσετε τη συσχέτιση με την πηγή που θα χρησιμοποιήσετε ως CDROM, επανεκκινήστε το εικονικό σας FreeBSD μηχάνημα, επιλέγοντας <b class=menuref>Reset</b> από το μενού <b class=menuref>Action</b>. Το Virtual PC εκκινεί με ένα ειδικό BIOS το οποίο ελέγχει πρώτα αν υπάρχει CDROM στον οδηγό, όπως ακριβώς συμβαίνει και με ένα φυσιολογικό BIOS.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd11.png alt="virtualpc freebsd11"></div></div><div class=paragraph><p>Στη δική μας περίπτωση, θα ανιχνεύσει το μέσο εγκατάστασης του FreeBSD και θα ξεκινήσει η συνηθισμένη διαδικασία εγκατάστασης μέσω του sysinstall, όπως περιγράφεται στο <a href=./#install>Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a>. Μπορείτε να προχωρήσετε με την εγκατάσταση, αλλά μη προσπαθήσετε να ρυθμίσετε το γραφικό σύστημα X11 τη δεδομένη στιγμή.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd12.png alt="virtualpc freebsd12"></div></div><div class=paragraph><p>Όταν τελειώσετε την εγκατάσταση, μη ξεχάσετε να βγάλετε το CDROM από τον οδηγό (ή να καταργήσετε την αντίστοιχη συσχέτιση με το αρχείο ISO). Μπορείτε έπειτα να επανεκκινήσετε στη νέα σας εγκατάσταση του FreeBSD.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd13.png alt="virtualpc freebsd13"></div></div></div><div class=sect4><h5 id=virtualization-guest-virtualpc-configure>42.2.2.2. Ρύθμιση του FreeBSD στο Virtual PC σε Microsoft® Windows®<a class=anchor href=#virtualization-guest-virtualpc-configure></a></h5><div class=paragraph><p>Μετά την επιτυχή εγκατάσταση του FreeBSD στα Microsoft® Windows® μέσω του Virtual PC, θα πρέπει να εκτελέσετε μια σειρά από ρυθμίσεις για να βελτιστοποιήσετε την λειτουργία του συστήματος σε περιβάλλον εικονικής μηχανής.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Θέστε Τιμές στις Μεταβλητές του Φορτωτή Εκκίνησης</p><div class=paragraph><p>Η πιο σημαντική ρύθμιση είναι να μειώσετε την τιμή της μεταβλητής <code>kern.hz</code> για να μειώσετε τη χρήση της CPU στο FreeBSD όταν το χρησιμοποιείτε στο εικονικό περιβάλλον του Virtual PC. Αυτό μπορεί να επιτευχθεί προσθέτοντας την παρακάτω γραμμή στο αρχείο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Χωρίς αυτή τη ρύθμιση, μια εικονική μηχανή FreeBSD στο Virtual PC, όταν εκτελείται χωρίς φορτίο, θα χρησιμοποιεί περίπου το 40% του επεξεργαστή σε ένα μηχάνημα με μία CPU. Μετά από την αλλαγή αυτή, η χρήση θα είναι κοντά στο 3%.</p></div></li><li><p>Δημιουργήστε Ένα Νέο Αρχείο Ρυθμίσεων Πυρήνα</p><div class=paragraph><p>Μπορείτε να αφαιρέσετε όλα τα προγράμματα οδήγησης για συσκευές SCSI, Firewire και USB. Το Virtual PC παρέχει μια εικονική κάρτα δικτύου η οποία υποστηρίζεται από το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a>, άρα μπορείτε να αφαιρέσετε όλες τις άλλες κάρτες δικτύου από τον πυρήνα, εκτός από το <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a> και το <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a>.</p></div></li><li><p>Ρύθμιση Δικτύου</p><div class=paragraph><p>Η πιο απλή ρύθμιση δικτύου περιλαμβάνει τη χρήση του πρωτοκόλλου DHCP για να συνδέσετε το εικονικό μηχάνημα σας στο ίδιο τοπικό δίκτυο με το μηχάνημα ξενιστή. Αυτό επιτυγχάνεται προσθέτοντας τη γραμμή <code>ifconfig_de0="DHCP"</code> στο <span class=filename>/etc/rc.conf</span>. Μπορείτε να βρείτε πιο προχωρημένες ρυθμίσεις δικτύου στο <a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a>.</p></div></li></ol></div></div></div><div class=sect3><h4 id=virtualization-guest-vmware>42.2.3. Το VMware σε MacOS<a class=anchor href=#virtualization-guest-vmware></a></h4><div class=paragraph><p>Το VMware Fusion για Mac® είναι ένα εμπορικό πρόγραμμα. Υπάρχει διαθέσιμο για υπολογιστές Apple® Mac® αρχιτεκτονικής Intel® που τρέχουν Mac OS® 10.4.9 ή κάποια πιο πρόσφατη έκδοση. Το FreeBSD υποστηρίζεται πλήρως ως φιλοξενούμενο (guest) λειτουργικό. Μόλις ολοκληρωθεί η εγκατάσταση του VMware Fusion στο Mac OS® X, πρέπει να ρυθμίσετε μια εικονική μηχανή και να εγκαταστήσετε το φιλοξενούμενο λειτουργικό σύστημα.</p></div><div class=sect4><h5 id=virtualization-guest-vmware-install>42.2.3.1. Εγκατάσταση του FreeBSD στο VMware/Mac OS® X<a class=anchor href=#virtualization-guest-vmware-install></a></h5><div class=paragraph><p>Αρχικά ξεκινήστε το VMware Fusion, και θα φορτώσει η Συλλογή Εικονικών Μηχανών. Επιλέξτε "New" για να δημιουργήσετε μια νέα εικονική μηχανή:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd01.png alt="vmware freebsd01"></div></div><div class=paragraph><p>Θα δείτε να φορτώνει το New Virtual Machine Assistant, το βοηθητικό πρόγραμμα δημιουργίας μιας νέας εικονικής μηχανής. Επιλέξτε Continue για να συνεχίσετε:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd02.png alt="vmware freebsd02"></div></div><div class=paragraph><p>Στην επιλογή λειτουργικού συστήματος διαλέξτε <span class=guimenuitem>Other</span> και ως έκδοση λειτουργικού συστήματος διαλέξτε <span class=guimenuitem>FreeBSD</span> ή <span class=guimenuitem>FreeBSD 64-bit</span> (ανάλογα με το αν θέλετε υποστήριξη για 64-bit εφαρμογές ή όχι):</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd03.png alt="vmware freebsd03"></div></div><div class=paragraph><p>Δώστε ένα όνομα για το VM Image και ρυθμίστε τον κατάλογο στον οποίο θέλετε να αποθηκευθεί:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd04.png alt="vmware freebsd04"></div></div><div class=paragraph><p>Ρυθμίστε το μέγεθος του Εικονικού Δίσκου για την εικονική μηχανή:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd05.png alt="vmware freebsd05"></div></div><div class=paragraph><p>Επιλέξτε μια μέθοδο εγκατάστασης για την εικονική μηχανή: είτε από ένα ISO image είτε από το CD-ROM:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd06.png alt="vmware freebsd06"></div></div><div class=paragraph><p>Μόλις επιλέξετε Finish, η εικονική μηχανή θα ξεκινήσει τη διαδικασία εκκίνησης (boot):</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd07.png alt="vmware freebsd07"></div></div><div class=paragraph><p>Εγκαταστήστε το FreeBSD όπως θα κάνατε και σε οποιοδήποτε άλλο υπολογιστή, ή ακολουθώντας τις οδηγίες από το <a href=./#install>Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd08.png alt="vmware freebsd08"></div></div><div class=paragraph><p>Μόλις ολοκληρωθεί η εγκατάσταση, μπορείτε να αλλάξετε τις ρυθμίσεις της εικονικής μηχανής, όπως π.χ. το μέγεθος μνήμης που θα χρησιμοποιεί:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι ρυθμίσεις υλικού μιας εικονικής μηχανής δε μπορούν να αλλάξουν όσο τρέχει αυτή η εικονική μηχανή.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd09.png alt="vmware freebsd09"></div></div><div class=paragraph><p>Μπορείτε, ακόμη, να ρυθμίσετε τον αριθμό των επεξεργαστών τους οποίους επιτρέπεται να χρησιμοποιήσει αυτή η εικονική μηχανή:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd10.png alt="vmware freebsd10"></div></div><div class=paragraph><p>Ίσως έχει νόημα, επίσης, να αλλάξετε το αρχείο ή τη συσκευή που φαίνεται ως CD-ROM μέσα στην εικονική μηχανή. Συνήθως μπορείτε να αποσυνδέσετε το CD-ROM ή το ISO image από την εικονική μηχανή, αφού δε χρειάζεται πλέον όταν έχει ολοκληρωθεί η εγκατάσταση του FreeBSD:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd11.png alt="vmware freebsd11"></div></div><div class=paragraph><p>Μια από τις τελευταίες ρυθμίσεις είναι η σύνδεση της εικονικής μηχανής με το δίκτυο. Για να μπορείτε να συνδεθείτε στην ΕΜ από άλλα μηχανήματα (εκτός του ξενιστή), ενεργοποιήστε την επιλογή <span class=guimenuitem>Connect directly to the physical network (Bridged)</span>. Αλλιώς, για να μπορεί η ΕΜ να συνδεθεί στο δίκτυο μέσω του ξενιστή, αλλά να μη μπορούν άλλα μηχανήματα να συνδεθούν σε αυτή, ενεργοποιήστε την επιλογή <span class=guimenuitem>Share the host’s internet connection (NAT)</span>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd12.png alt="vmware freebsd12"></div></div><div class=paragraph><p>Μόλις τελειώσετε με αυτές τις ρυθμίσεις, μπορείτε να εκκινήσετε τη νέα εικονική μηχανή με το φρεσκο-εγκατεστημένο FreeBSD σας.</p></div></div><div class=sect4><h5 id=virtualization-guest-vmware-configure>42.2.3.2. Ρυθμίσεις του FreeBSD μέσα στο Mac OS® X/VMware<a class=anchor href=#virtualization-guest-vmware-configure></a></h5><div class=paragraph><p>Αφού τελειώσετε με την εγκατάσταση του FreeBSD σε μια εικονική μηχανή VMware μέσα σε Mac OS® X, πρέπει να κάνετε κάποιες ρυθμίσεις για να βελτιωθεί η απόδοση του FreeBSD ως φιλοξενούμενου συστήματος.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Ρυθμίσεις Μεταβλητών του Boot Loader</p><div class=paragraph><p>Η πιο σημαντική ρύθμιση είναι να μειώσετε την τιμή της μεταβλητής <code>kern.hz</code>, για να μειωθεί κάπως η χρήση του επεξεργαστή από το FreeBSD καθώς τρέχει μέσα στο VMware. Προσθέστε, λοιπόν, την παρακάτω γραμμή στο αρχείο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Χωρίς αυτή τη ρύθμιση ένα φιλοξενούμενο FreeBSD που τρέχει μέσα σε VMware μπορεί να χρησιμοποιεί μέχρι και 15% του επεξεργαστή ενός iMac®. Μετά από αυτή τη ρύθμιση η χρήση του επεξεργαστή μπορεί να είναι μικρότερη από 5%.</p></div></li><li><p>Δημιουργήστε Ένα Νέο Αρχείο Ρυθμίσεων Πυρήνα</p><div class=paragraph><p>Μπορείτε να αφαιρέσετε όλες τις συσκευές FireWire και USB. Το VMware παρέχει μια εικονική κάρτα δικτύου, η οποία είναι συμβατή με τον οδηγό <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a>, οπότε μπορείτε να αφαιρέσετε όλες τις υπόλοιπες κάρτες δικτύου από τον πυρήνα σας.</p></div></li><li><p>Ρυθμίστε το Δίκτυο</p><div class=paragraph><p>Ο πιο εύκολος τρόπος να ρυθμίσετε το δίκτυο της εικονικής μηχανής είναι να συνδεθείτε μέσω DHCP με το τοπικό δίκτυο, χρησιμοποιώντας τη διεύθυνση MAC του ξενιστή. Αυτό μπορεί να γίνει προσθέτοντας τη γραμμή <code>ifconfig_em0="DHCP"</code> στο αρχείο <span class=filename>/etc/rc.conf</span>. Για περισσότερες πληροφορίες και πιο προχωρημένες ρυθμίσεις δικτύου, δείτε το <a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a>.</p></div></li></ol></div></div></div><div class=sect3><h4 id=virtualization-guest-virtualbox-guest-additions>42.2.4. VirtualBox™ Guest Additions σε FreeBSD Guest<a class=anchor href=#virtualization-guest-virtualbox-guest-additions></a></h4><div class=paragraph><p>Τα πρόσθετα προγράμματα για το φιλοξενούμενο λειτουργικό (guest additions) του VirtualBox™ παρέχουν υποστήριξη για τα παρακάτω:</p></div><div class=ulist><ul><li><p>Κοινή χρήση προχείρου (clipboard)</p></li><li><p>Έξυπνη χρήση δείκτη ποντικιού</p></li><li><p>Συγχρονισμός ώρας με τον ξενιστή (host)</p></li><li><p>Αναπροσαρμογή μεγέθους παραθύρου</p></li><li><p>Κατάσταση απρόσκοπτης λειτουργίας (seamless mode)</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι παρακάτω εντολές εκτελούνται στο φιλοξενούμενο FreeBSD λειτουργικό.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αρχικά, εγκαταστήστε το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose-additions/>emulators/virtualbox-ose-additions</a> στο φιλοξενούμενο FreeBSD λειτουργικό.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose-additions &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>Προσθέστε τις παρακάτω γραμμές στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxguest_enable=&#34;YES&#34;
vboxservice_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Αν πρόκειται να χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a>, θα πρέπει να απενεργοποιήσετε το συγχρονισμό ώρας με τον ξενιστή:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxservice_flags=&#34;--disable-timesync&#34;</pre></div></div><div class=paragraph><p>Το πρόγραμμα οδήγησης <code>vboxvideo_drv</code> φυσιολογικά θα αναγνωριστεί αυτόματα όταν εκτελέσετε το <code>Xorg -configure</code>. Αν αυτό δεν συμβεί, τροποποιήστε το <span class=filename>xorg.conf</span> για την κάρτα γραφικών του VirtualBox™:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	### Available Driver options are:-
	### Values: &lt;i&gt;: integer, &lt;f&gt;: float, &lt;bool&gt;: &#34;True&#34;/&#34;False&#34;,
	### &lt;string&gt;: &#34;String&#34;, &lt;freq&gt;: &#34;&lt;f&gt; Hz/kHz/MHz&#34;
	### [arg]: arg optional
	Identifier &#34;Card0&#34;
	Driver &#34;vboxvideo&#34;
	VendorName &#34;InnoTek Systemberatung GmbH&#34;
	BoardName &#34;VirtualBox Graphics Adapter&#34;
	BusID &#34;PCI:0:2:0&#34;
EndSection</pre></div></div><div class=paragraph><p>Για να χρησιμοποιήσετε το <code>vboxmouse_drv</code>, χρησιμοποιήστε την παρακάτω ενότητα για το ποντίκι στο <span class=filename>xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier &#34;Mouse0&#34;
	Driver &#34;vboxmouse&#34;
EndSection</pre></div></div><div class=paragraph><p>Οι χρήστες του HAL θα πρέπει να δημιουργήσουν το αρχείο <span class=filename>/usr/local/etc/hal/fdi/policy/90-vboxguest.fdi</span> ή να το αντιγράψουν από το <span class=filename>/usr/local/shared/hal/fdi/policy/10osvendor/90-vboxguest.fdi</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;!--
# Sun VirtualBox
# Hal driver description for the vboxmouse driver
# $Id: chapter.xml,v 1.16 2011-12-09 19:53:53 manolis Exp $

	Copyright (C) 2008-2009 Sun Microsystems, Inc.

	This file is part of VirtualBox Open Source Edition (OSE, as
	available from http://www.virtualbox.org. This file is free software;
	you can redistribute it and/or modify it under the terms of the GNU
	General Public License (GPL) as published by the Free Software
	Foundation, in version 2 as it comes in the &#34;COPYING&#34; file of the
	VirtualBox OSE distribution. VirtualBox OSE is distributed in the
	hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.

	Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
	Clara, CA 95054 USA or visit http://www.sun.com if you need
	additional information or have any questions.
--&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.subsystem&#34; string=&#34;pci&#34;&gt;
      &lt;match key=&#34;info.product&#34; string=&#34;VirtualBox guest Service&#34;&gt;
        &lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input&lt;/append&gt;
	&lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input.mouse&lt;/append&gt;
        &lt;merge key=&#34;input.x11_driver&#34; type=&#34;string&#34;&gt;vboxmouse&lt;/merge&gt;
	&lt;merge key=&#34;input.device&#34; type=&#34;string&#34;&gt;/dev/vboxguest&lt;/merge&gt;
      &lt;/match&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div></div></div><div class=sect2><h3 id=virtualization-host>42.3. Το FreeBSD ως Ξενιστής (Host)<a class=anchor href=#virtualization-host></a></h3><div class=paragraph><p>Για αρκετά χρόνια, κανένα από τα πακέτα εικονικοποίησης δεν υποστήριζε επίσημα το FreeBSD ως ξενιστή. Κάποιοι χρήστες χρησιμοποιούσαν παλιές και κατά βάση εγκαταλελειμμένες εκδόσεις του VMware (όπως το <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/vmware3/>emulators/vmware3</a>), οι οποίες χρησιμοποιούσαν την συμβατότητα εκτέλεσης προγραμμάτων Linux®. Λίγο μετά την επίσημη κυκλοφορία του FreeBSD 7.2, έγινε διαθέσιμη στη Συλλογή των Ports η εφαρμογή VirtualBox™ της Sun™. Η εφαρμογή αυτή εκτελείται ως εγγενές πρόγραμμα του FreeBSD.</p></div><div class=paragraph><p>Το VirtualBox™ είναι ένα πλήρες πακέτο εικονικοποίησης το οποίο βρίσκεται σε διαρκή ανάπτυξη. Είναι διαθέσιμο για τα περισσότερα λειτουργικά συστήματα, συμπεριλαμβανομένων των Windows®, Mac OS®, Linux® και FreeBSD. Έχει τη δυνατότητα να εκτελεί το ίδιο καλά τόσο λειτουργικά τύπου Windows® όσο και UNIX®. Διανέμεται ως λογισμικό ανοικτού κώδικα αλλά περιέχει κάποια εξαρτήματα κλειστού κώδικα που διατίθενται ως χωριστό πακέτο επέκτασης. Μπορείτε να βρείτε περισσότερες πληροφορίες στη σελίδα "Downloads" στο wiki του VirtualBox™, <a href=http://www.virtualbox.org/wiki/Downloads>http://www.virtualbox.org/wiki/Downloads</a>. Τη δεδομένη στιγμή οι επεκτάσεις αυτές δεν διατίθενται για το FreeBSD.</p></div><div class=sect3><h4 id=virtualization-virtualbox-install>42.3.1. Εγκατάσταση του VirtualBox™<a class=anchor href=#virtualization-virtualbox-install></a></h4><div class=paragraph><p>Το VirtualBox™ είναι διαθέσιμο ως FreeBSD port στο <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose/>emulators/virtualbox-ose</a>. Καθώς το VirtualBox™ βρίσκεται υπό συνεχή και πολύ ενεργή ανάπτυξη, βεβαιωθείτε ότι έχετε ανανεώσει το δέντρο των ports πριν ξεκινήσετε την εγκατάσταση του. Χρησιμοποιήστε τις παρακάτω εντολές για να το εγκαταστήσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Μια χρήσιμη επιλογή που εμφανίζεται στο διάλογο ρυθμίσεων, αφορά την εγκατάσταση των προγραμμάτων <code>GuestAdditions</code>. Τα προγράμματα αυτά παρέχουν μια σειρά από χρήσιμες λειτουργίες στα φιλοξενούμενα λειτουργικά, όπως η διάφανη λειτουργία του δείκτη ποντικιού (επιτρέπει στο ποντίκι να κινείται ελεύθερα μεταξύ του ξενιστή και του φιλοξενούμενου λειτουργικού, χωρίς να απαιτείται η χρήση κάποιου ειδικού πλήκτρου για εναλλαγή) καθώς και ταχύτερη γραφική απεικόνιση, ειδικά σε λειτουργικά Windows®. Μπορείτε να βρείτε τα guest additions στο μενού <b class=menuref>Devices</b>, όταν ολοκληρώσετε την εγκατάσταση του φιλοξενούμενου λειτουργικού.</p></div><div class=paragraph><p>Πριν χρησιμοποιήσετε το VirtualBox™ για πρώτη φορά, θα πρέπει να αλλάξετε κάποιες ρυθμίσεις. Το port εγκαθιστά ένα άρθρωμα πυρήνα στον κατάλογο <span class=filename>/boot/modules</span> το οποίο θα πρέπει να φορτώσετε στον πυρήνα που εκτελείται:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vboxdrv</span></code></pre></div></div><div class=paragraph><p>Για να φορτώνεται το άρθρωμα αυτόματα σε κάθε επανεκκίνηση του συστήματος, προσθέστε την παρακάτω γραμμή στο αρχείο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxdrv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Για να χρησιμοποιήσετε τα αρθρώματα πυρήνα που επιτρέπουν τη λειτουργία του δικτύου σε κατάσταση γέφυρας (bridged) ή host-only, προσθέστε την παρακάτω γραμμή στο <span class=filename>/etc/rc.conf</span> και επανεκκινήστε τον υπολογιστή σας:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxnet_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Κατά τη διάρκεια της εγκατάστασης του VirtualBox™, δημιουργείται αυτόματα η ομάδα χρηστών <code>vboxusers</code>. Όλοι οι χρήστες που χρειάζονται πρόσβαση στο VirtualBox™, θα πρέπει να ανήκουν σε αυτή την ομάδα. Μπορείτε να χρησιμοποιήσετε την εντολή <code>pw</code> για να προσθέσετε νέα μέλη στην ομάδα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod vboxusers -m yourusername</span></code></pre></div></div><div class=paragraph><p>Τα προεπιλεγμένα δικαιώματα για τη συσκευή <span class=filename>/dev/vboxnetctl</span> είναι αρκετά περιοριστικά και πρέπει να αλλάξουν για να λειτουργήσει το δίκτυο σε κατάσταση γέφυρας.</p></div><div class=paragraph><p>Για να δοκιμάσετε τις νέες ρυθμίσεις προσωρινά:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:vboxusers /dev/vboxnetctl</span>
<span class=c># chmod 0660 /dev/vboxnetctl</span></code></pre></div></div><div class=paragraph><p>Για να αλλάξετε τα δικαιώματα μόνιμα, προσθέστε τις παρακάτω γραμμές στο <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>own     vboxnetctl root:vboxusers
perm    vboxnetctl 0660</pre></div></div><div class=paragraph><p>Για να εκτελέσετε το VirtualBox™, μπορείτε απλώς να επιλέξετε την καταχώριση <span class=guimenuitem>Sun VirtualBox</span> από το μενού του γραφικού σας περιβάλλοντος, ή να πληκτρολογήσετε το παρακάτω σε ένα τερματικό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% VirtualBox</code></pre></div></div><div class=paragraph><p>Για περισσότερες πληροφορίες σχετικά με τη ρύθμιση και χρήση του VirtualBox™, παρακαλούμε επισκεφθείτε την επίσημη δικτυακή τοποθεσία στο <a href=http://www.virtualbox.org>http://www.virtualbox.org</a>. Καθώς το FreeBSD port είναι πολύ πρόσφατο, η εξέλιξη του είναι συνεχής. Για τις τελευταίες πληροφορίες καθώς και για οδηγίες αντιμετώπισης τυχόν προβλημάτων, παρακαλούμε δείτε τη σχετική σελίδα στο wiki του FreeBSD, στην τοποθεσία <a href=http://wiki.FreeBSD.org/VirtualBox>http://wiki.FreeBSD.org/VirtualBox</a>.</p></div></div><div class=sect3><h4 id=virtualization-virtualbox-usb-support>42.3.2. Υποστήριξη USB στο VirtualBox™<a class=anchor href=#virtualization-virtualbox-usb-support></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Για τα βήματα αυτά απαιτείται το VirtualBox™ 4.0.0 ή μεταγενέστερο.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να μπορείτε να διαβάσετε και να γράψετε σε συσκευές USB, θα πρέπει ο λογαριασμός σας να ανήκει στην ομάδα operators:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod operator -m jerry</span></code></pre></div></div><div class=paragraph><p>Προσθέστε έπειτα τις παρακάτω γραμμές στο αρχείο <span class=filename>/etc/devfs.rules</span> (δημιουργήστε το αν δεν υπάρχει ήδη):</p></div><div class="literalblock programlisting"><div class=content><pre>[system=10]
add path &#39;usb/*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Για να φορτώσετε τους νέους κανόνες, προσθέστε την παρακάτω γραμμή στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Έπειτα επανεκκινήστε το devfs:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/devfs restart</span></code></pre></div></div><div class=paragraph><p>Μπορείτε τώρα να ενεργοποιήσετε το USB στο φιλοξενούμενο λειτουργικό. Θα πρέπει να μπορείτε να δείτε τις συσκευές USB στις προτιμήσεις του VirtualBox™.</p></div></div><div class=sect3><h4 id=virtualization-virtualbox-host-dvd-cd-access>42.3.3. Πρόσβαση στο DVD/CD του Ξενιστή<a class=anchor href=#virtualization-virtualbox-host-dvd-cd-access></a></h4><div class=paragraph><p>θα πρέπει να φορτώσετε το άρθρωμα πυρήνα <code>atapicam</code> προσθέτοντας την παρακάτω γραμμή στο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Θα πρέπει να εκτελείται το HAL για να λειτουργήσει σωστά το DVD/CD στο VirtualBox™. Ενεργοποιήστε το στο <span class=filename>/etc/rc.conf</span> και ξεκινήστε το (αν δεν εκτελείται ήδη):</p></div><div class="literalblock programlisting"><div class=content><pre>hald_enable=&#34;YES&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/hald start</span></code></pre></div></div><div class=paragraph><p>Για να μπορούν οι χρήστες να έχουν πρόσβαση στις λειτουργίες CD/DVD του VirtualBox™, χρειάζονται πρόσβαση στις συσκευές <span class=filename>/dev/xpt0</span>, <span class=filename>/dev/cdN</span> και <span class=filename>/dev/passN</span>. Προσθέστε τις παρακάτω γραμμές στο <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>perm cd0 0600
perm xpt0 0660
perm pass0 0660</pre></div></div></div></div></div></div><div class=sect1><h2 id=l10n>Chapter 43. Τοπικές Ρυθμίσεις - Χρήση και ρύθμιση I18N/L10N<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-synopsis>43.1. Σύνοψη<a class=anchor href=#l10n-synopsis></a></h3><div class=paragraph><p>Το FreeBSD είναι ένα ιδιαίτερα αποκεντρωμένο έργο με χρήστες και εθελοντές σε ολόκληρο τον κόσμο. Στο κεφάλαιο αυτό συζητούνται οι δυνατότητες τοπικών και διεθνών ρυθμίσεων του FreeBSD, οι οποίες επιτρέπουν σε χρήστες γλωσσών εκτός της Αγγλικής να εκτελέσουν πραγματική εργασία. Υπάρχουν πολλοί παράγοντες στην υλοποίηση του πλαισίου i18n, τόσο σε επίπεδο συστήματος, όσο και εφαρμογών, και για το λόγο αυτό, όπου χρειάζεται, παραπέμπουμε τον αναγνώστη σε πιο συγκεκριμένες πηγές τεκμηρίωσης.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως κωδικοποιούνται οι γλώσσες και οι τοπικές ρυθμίσεις στα σύγχρονα λειτουργικά συστήματα.</p></li><li><p>Πως να βάλετε τοπικές ρυθμίσεις στο κέλυφος σας (login shell).</p></li><li><p>Πως να ρυθμίσετε την κονσόλα για γλώσσες εκτός της Αγγλικής.</p></li><li><p>Πως να χρησιμοποιήσετε αποτελεσματικά το σύστημα X Windows με διαφορετικές γλώσσες.</p></li><li><p>Που να βρείτε περισσότερες πληροφορίες για τη συγγραφή εφαρμογών συμβατών με το πρότυπο i18n.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=l10n-basics>43.2. Βασικές Γνώσεις<a class=anchor href=#l10n-basics></a></h3><div class=sect3><h4 id=_τι_είναι_το_i18nl10n>43.2.1. Τι Είναι το I18N/L10N;<a class=anchor href=#_τι_είναι_το_i18nl10n></a></h4><div class=paragraph><p>Οι ομάδες ανάπτυξης λογισμικού δημιούργησαν τον όρο I18N, ως συντόμευση της λέξης "internationalization" (διεθνοποίηση), μετρώντας απλώς τα γράμματα της λέξης ανάμεσα στο πρώτο και το τελευταίο. Ο όρος L10N έχει προκύψει με τον ίδιο τρόπο, αυτή τη φορά από τη λέξη "localization" (τοπικοποίηση, ή απλώς τοπικές ρυθμίσεις). Συνδυάζοντας μεταξύ τους τις μεθόδους, τα πρωτόκολλα, και τις εφαρμογές που συμβαδίζουν με τα I18N/L10N, οι χρήστες μπορούν να χρησιμοποιήσουν τις γλώσσες της επιλογής τους.</p></div><div class=paragraph><p>Οι εφαρμογές I18N προγραμματίζονται με τη βοήθεια εργαλείων (kits) και βιβλιοθηκών. Επιτρέπεται έτσι στους προγραμματιστές να γράψουν ένα απλό αρχείο και να μεταφράσουν τα μενού και τα κείμενα που απεικονίζει η εφαρμογή, σε κάθε γλώσσα που απαιτείται. Συνιστούμε ένθερμα στους προγραμματιστές να ακολουθούν την παραπάνω σύμβαση.</p></div></div><div class=sect3><h4 id=_γιατί_πρέπει_να_χρησιμοποιήσω_τα_i18nl10n>43.2.2. Γιατί Πρέπει να Χρησιμοποιήσω τα I18N/L10N;<a class=anchor href=#_γιατί_πρέπει_να_χρησιμοποιήσω_τα_i18nl10n></a></h4><div class=paragraph><p>Τα I18N/L10N χρησιμοποιούνται κάθε φορά που επιθυμείτε να δείτε, να εισάγετε, ή να επεξεργαστείτε δεδομένα σε γλώσσες εκτός της Αγγλικής.</p></div></div><div class=sect3><h4 id=_ποιες_γλώσσες_υποστηρίζονται_στο_i18n>43.2.3. Ποιες Γλώσσες Υποστηρίζονται στο I18N;<a class=anchor href=#_ποιες_γλώσσες_υποστηρίζονται_στο_i18n></a></h4><div class=paragraph><p>Το I18N και το L10N δεν είναι ειδικά φτιαγμένα για το FreeBSD. Την δεδομένη στιγμή, υποστηρίζονται οι περισσότερες γνωστές γλώσσες, συμπεριλαμβανομένων των: Κινεζικών, Γερμανικών, Γιαπωνέζικων, Κορεατικών, Γαλλικών, Ρωσικών, Βιετναμέζικων, κ.α.</p></div></div></div><div class=sect2><h3 id=using-localization>43.3. Χρήση των Τοπικών Ρυθμίσεων<a class=anchor href=#using-localization></a></h3><div class=paragraph><p>Το I18N είναι στην πραγματικότητα μια σύμβαση, και δεν έχει δημιουργηθεί αποκλειστικά για το FreeBSD. Επιθυμούμε τη βοήθεια σας ώστε το FreeBSD να ακολουθεί αυτή τη σύμβαση.</p></div><div class=paragraph><p>Οι τοπικές ρυθμίσεις βασίζονται σε τρεις βασικούς όρους: Κωδικό Γλώσσας, Κωδικό Χώρας και Κωδικοποίηση. Τα ονόματα των τοπικών ρυθμίσεων προκύπτουν από τους παραπάνω όρους, με τον τρόπο που περιγράφεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ΚωδικόςΓλώσσας_ΚωδικόςΧώρας.Κωδικοποίηση</pre></div></div><div class=sect3><h4 id=_κωδικοί_γλωσσών_και_χωρών>43.3.1. Κωδικοί Γλωσσών και Χωρών<a class=anchor href=#_κωδικοί_γλωσσών_και_χωρών></a></h4><div class=paragraph><p>Για να χρησιμοποιηθούν οι τοπικές ρυθμίσεις για μια συγκεκριμένη γλώσσα σε ένα σύστημα FreeBSD (ή σε άλλο σύστημα τύπου UNIX® που υποστηρίζει το πρότυπο I18N), ο χρήστης θα πρέπει να βρει τους κωδικούς της συγκεκριμένης χώρας και γλώσσας (οι κωδικοί χωρών καθοδηγούν τις εφαρμογές σχετικά με τη διάλεκτο της γλώσσας που πρέπει να χρησιμοποιηθεί). Προγράμματα όπως φυλλομετρητές, εξυπηρετητές ιστοσελίδων, εξυπηρετητές SMTP/POP κλπ. παίρνουν επίσης κάποιες αποφάσεις που εξαρτώνται από τους κωδικούς αυτούς. Παρακάτω φαίνονται μερικά παραδείγματα γλωσσών/χωρών:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Κωδικός Γλώσσας/Χώρας</th><th class="tableblock halign-left valign-top">Περιγραφή</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>en_US</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αγγλικά - Ηνωμένες Πολιτείες</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ru_RU</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ρώσικα - Ρωσία</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>zh_TW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Παραδοσιακά Κινέζικα - Ταϊβάν</p></td></tr></tbody></table></div><div class=sect3><h4 id=_κωδικοποιήσεις>43.3.2. Κωδικοποιήσεις<a class=anchor href=#_κωδικοποιήσεις></a></h4><div class=paragraph><p>Κάποιες γλώσσες χρησιμοποιούν κωδικοποιήσεις που δεν είναι ASCII, αλλά περιέχουν χαρακτήρες 8-bit, wide, ή multibyte (δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a> για περισσότερες πληροφορίες). Οι πιο καινούριες εφαρμογές συνήθως αναγνωρίζουν τους χαρακτήρες 8-bit. Ανάλογα με την υλοποίηση, οι χρήστες μπορεί να χρειάζεται να μεταγλωττίσουν μια εφαρμογή με υποστήριξη χαρακτήρων wide ή multibyte, ή να προσαρμόσουν τις ρυθμίσεις του προγράμματος. Για να έχετε την ικανότητα να εισάγετε και να επεξεργάζεστε χαρακτήρες multibyte, η <a href=https://www.FreeBSD.org/ports/>Συλλογή των Ports του FreeBSD</a> διαθέτει προγράμματα για κάθε γλώσσα. Δείτε την τεκμηρίωση για το I18N στο αντίστοιχο Port του FreeBSD.</p></div><div class=paragraph><p>Ειδικότερα, ο χρήστης χρειάζεται να διαβάσει την τεκμηρίωση της εφαρμογής, για να αποφασίσει πως πρέπει να τη ρυθμίσει σωστά ή πως να περάσει τις σωστές τιμές στο configure, το Makefile ή τον μεταγλωττιστή.</p></div><div class=paragraph><p>Θα πρέπει να έχετε κατά νου κάποια πράγματα:</p></div><div class=ulist><ul><li><p>Σετ χαρακτήρων που εξαρτώνται από τη γλώσσα (single C chars character set, δείτε την <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a>), π.χ. ISO8859-1, ISO8859-15, KOI8-R, CP437.</p></li><li><p>Κωδικοποιήσεις Wide ή multibyte, π.χ. EUC, Big5.</p></li></ul></div><div class=paragraph><p>Μπορείτε να δείτε την ενεργή λίστα των σετ χαρακτήρων στο <a href=http://www.iana.org/assignments/character-sets>Μητρώο IANA</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το FreeBSD χρησιμοποιεί για τις τοπικές ρυθμίσεις κωδικοποιήσεις συμβατές με το X11.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_εφαρμογές_i18n>43.3.3. Εφαρμογές I18N<a class=anchor href=#_εφαρμογές_i18n></a></h4><div class=paragraph><p>Στο σύστημα πακέτων και ports του FreeBSD, οι εφαρμογές που σχετίζονται με το I18N έχουν στο όνομα τους τη λέξη <code>I18N</code> ώστε να αναγνωρίζονται εύκολα. Ωστόσο, μπορεί να μην υποστηρίζουν πάντοτε τη γλώσσα που χρειάζεστε.</p></div></div><div class=sect3><h4 id=setting-locale>43.3.4. Τοπικές Ρυθμίσεις<a class=anchor href=#setting-locale></a></h4><div class=paragraph><p>Είναι συνήθως αρκετό να γίνει export η τιμή με την ονομασία της επιθυμητής τοπικής ρύθμισης, μέσω της μεταβλητής περιβάλλοντος <code>LANG</code> στο κέλυφος εισόδου. Αυτό μπορεί να γίνει στο αρχείο <span class=filename>~/.login_conf</span> του χρήστη, ή στο αρχείο εκκίνησης του κελύφους του χρήστη (<span class=filename>~/.profile</span>, <span class=filename>~/.bashrc</span>, <span class=filename>~/.cshrc</span>). Δεν είναι ανάγκη να θέσετε και τις υπόλοιπες μεταβλητές των τοπικών ρυθμίσεων, όπως οι <code>LC_CTYPE</code>, <code>LC_CTIME</code>. Για περισσότερες πληροφορίες, διαβάστε την τεκμηρίωση του FreeBSD που σχετίζεται με την υποστήριξη της επιθυμητής γλώσσας.</p></div><div class=paragraph><p>Θα πρέπει να θέσετε τις δύο παρακάτω μεταβλητές περιβάλλοντος, στα αρχεία ρυθμίσεων:</p></div><div class=ulist><ul><li><p>Την <code>LANG</code> για λειτουργίες που ανήκουν στην οικογένεια POSIX® <a href="https://man.freebsd.org/cgi/man.cgi?query=setlocale&amp;sektion=3&amp;format=html">setlocale(3)</a></p></li><li><p>Την <code>MM_CHARSET</code> για το σύνολο χαρακτήρων MIME των εφαρμογών.</p></li></ul></div><div class=paragraph><p>Το παραπάνω περιλαμβάνει την ρύθμιση του κελύφους χρήστη, την ρύθμιση για μια συγκεκριμένη εφαρμογή, και τη ρύθμιση για τα X11.</p></div><div class=sect4><h5 id=_μέθοδοι_αλλαγής_τοπικών_ρυθμίσεων>43.3.4.1. Μέθοδοι Αλλαγής Τοπικών Ρυθμίσεων<a class=anchor href=#_μέθοδοι_αλλαγής_τοπικών_ρυθμίσεων></a></h5><div class=paragraph><p>Υπάρχουν δύο μέθοδοι για την αλλαγή των τοπικών ρυθμίσεων, τις οποίες και περιγράφουμε παρακάτω. Η πρώτη (την οποία και συνιστούμε) υλοποιείται θέτοντας τιμές στις μεταβλητές περιβάλλοντος στο <a href=#login-class>login class</a>, και η δεύτερη αλλάζοντας τις τιμές των μεταβλητών περιβάλλοντος στο <a href=#startup-file>αρχείο εκκίνησης</a> του κελύφους του χρήστη.</p></div><div class=sect5><h6 id=login-class>43.3.4.1.1. Μέθοδος Κλάσεων Εισόδου (Login Class)<a class=anchor href=#login-class></a></h6><div class=paragraph><p>Η μέθοδος αυτή επιτρέπει να γίνει η ρύθμιση των μεταβλητών περιβάλλοντος μια φορά για κάθε κέλυφος, αντί να χρειάζεται να τεθούν συγκεκριμένες τιμές στο αρχείο εκκίνησης του καθενός χωριστά. Οι <a href=#usr-setup>Ρυθμίσεις σε Επίπεδο Χρήστη</a> μπορούν να γίνουν από τον ίδιο το χρήστη, ενώ οι <a href=#adm-setup>Ρυθμίσεις σε Επίπεδο Διαχειριστή</a> απαιτούν προνόμια υπερχρήστη.</p></div><div class=sect6><h7 id=usr-setup>43.3.4.1.1.1. Ρυθμίσεις σε Επίπεδο Χρήστη<a class=anchor href=#usr-setup></a></h7><div class=paragraph><p>Το παρακάτω απλό παράδειγμα, δείχνει ένα αρχείο <span class=filename>.login_conf</span> στον κατάλογο κάποιου χρήστη στο οποίο και οι δύο μεταβλητές έχουν τεθεί για κωδικοποίηση Latin-1:</p></div><div class="literalblock programlisting"><div class=content><pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre></div></div><div class=paragraph><p>Παρακάτω βλέπετε ένα <span class=filename>.login_conf</span> στο οποίο οι μεταβλητές έχουν τεθεί για Παραδοσιακά Κινέζικα σε κωδικοποίηση BIG-5. Παρατηρήστε ότι έχουμε θέσει πολύ περισσότερες μεταβλητές, καθώς κάποιες εφαρμογές δεν σέβονται σωστά τις μεταβλητές για Κινέζικα, Γιαπωνέζικα και Κορεάτικα.</p></div><div class="literalblock programlisting"><div class=content><pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:setenv=LC_ALL=zh_TW.Big5:\
	:setenv=LC_COLLATE=zh_TW.Big5:\
	:setenv=LC_CTYPE=zh_TW.Big5:\
	:setenv=LC_MESSAGES=zh_TW.Big5:\
	:setenv=LC_MONETARY=zh_TW.Big5:\
	:setenv=LC_NUMERIC=zh_TW.Big5:\
	:setenv=LC_TIME=zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=gcin&#34;: #Set gcin as the XIM Input Server</pre></div></div><div class=paragraph><p>Για περισσότερες πληροφορίες, δείτε τις <a href=#adm-setup>Ρυθμίσεις σε Επίπεδο Διαχειριστή</a> και την <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div></div></div><div class=sect5><h6 id=adm-setup>43.3.4.1.2. Ρυθμίσεις σε Επίπεδο Διαχειριστή<a class=anchor href=#adm-setup></a></h6><div class=paragraph><p>Βεβαιωθείτε ότι έχει οριστεί η σωστή γλώσσα στην κλάση του χρήστη, στο αρχείο <span class=filename>/etc/login.conf</span>. Στο αρχείο αυτό θα πρέπει να υπάρχουν οι παρακάτω ρυθμίσεις:</p></div><div class="literalblock programlisting"><div class=content><pre>language_name|Account Type Description:\
	:charset=MIME_charset:\
	:lang=locale_name:\
	:tc=default:</pre></div></div><div class=paragraph><p>Με βάση το προηγούμενο παράδειγμα μας που χρησιμοποιήσαμε Latin-1, το αρχείο θα μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>german|German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre></div></div><div class=paragraph><p>Πριν κάνετε αλλαγές στις Κλάσεις Εισόδου (Login Classes) των χρηστών, εκτελέστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class=paragraph><p>ώστε να ενεργοποιηθούν στο σύστημα οι αλλαγές που κάνατε στο <span class=filename>/etc/login.conf</span>.</p></div></div><div class=sect5><h6 id=_αλλαγή_κλάσεων_εισόδου_μέσω_της_vipw8>43.3.4.1.3. Αλλαγή Κλάσεων Εισόδου μέσω της <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a><a class=anchor href=#_αλλαγή_κλάσεων_εισόδου_μέσω_της_vipw8></a></h6><div class=paragraph><p>Χρησιμοποιήστε την <code>vipw</code> για να προσθέσετε νέους χρήστες, και κάντε την καταχώριση να μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>user:password:1111:11:language:0:0:User Name:/home/user:/bin/sh</pre></div></div></div><div class=sect5><h6 id=_αλλαγή_κλάσεων_εισόδου_μέσω_της_adduser8>43.3.4.1.4. Αλλαγή Κλάσεων Εισόδου μέσω της <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a><a class=anchor href=#_αλλαγή_κλάσεων_εισόδου_μέσω_της_adduser8></a></h6><div class=paragraph><p>Χρησιμοποιήστε την <code>adduser</code> για να προσθέσετε νέους χρήστες, και έπειτα ακολουθήστε τις παρακάτω οδηγίες:</p></div><div class=ulist><ul><li><p>Θέστε το <code>defaultclass = language</code> στο <span class=filename>/etc/adduser.conf</span>. Να έχετε υπόψη σας ότι σε αυτή την περίπτωση, θα πρέπει να ορίσετε μια κλάση <code>default</code> για όλους τους χρήστες άλλων γλωσσών.</p></li><li><p>Μια εναλλακτική λύση, είναι να απαντάτε κάθε φορά στην ερώτηση</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter login class: default <span class=o>[]</span>:</code></pre></div></div><div class=paragraph><p>που εμφανίζεται από την <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>.</p></div></li><li><p>Ακόμα μια εναλλακτική λύση, είναι να χρησιμοποιήσετε το παρακάτω σε κάθε χρήστη που θέλετε να προσθέσετε και ο οποίος χρησιμοποιεί διαφορετική γλώσσα:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -class language</span></code></pre></div></div></li></ul></div></div><div class=sect5><h6 id=_αλλαγή_κλάσεων_εισόδου_μέσω_της_pw8>43.3.4.1.5. Αλλαγή Κλάσεων Εισόδου μέσω της <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a><a class=anchor href=#_αλλαγή_κλάσεων_εισόδου_μέσω_της_pw8></a></h6><div class=paragraph><p>Αν χρησιμοποιείτε την <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> για να προσθέσετε νέους χρήστες, καλέστε την με τον παρακάτω τρόπο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd user_name -L language</span></code></pre></div></div></div><div class=sect5><h6 id=startup-file>43.3.4.1.6. Μέθοδος Αρχείων Εκκίνησης Κελύφους<a class=anchor href=#startup-file></a></h6><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η μέθοδος αυτή δεν συνίσταται, καθώς απαιτεί διαφορετικές ρυθμίσεις για κάθε διαφορετικό πρόγραμμα κελύφους που χρησιμοποιείται. Προτιμήστε καλύτερα την μέθοδο των <a href=#login-class>Κλάσεων Εισόδου</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να προσθέσετε τις τοπικές ρυθμίσεις και το σετ χαρακτήρων MIME, ρυθμίστε απλώς τις δύο μεταβλητές περιβάλλοντος που φαίνονται παρακάτω στο αρχείο <span class=filename>/etc/profile</span> ή/και στο <span class=filename>/etc/csh.login</span>. Θα χρησιμοποιήσουμε τα Γερμανικά ως γλώσσα για το παρακάτω παράδειγμα:</p></div><div class=paragraph><p>Στο <span class=filename>/etc/profile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre></div></div><div class=paragraph><p>Ή στο <span class=filename>/etc/csh.login</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre></div></div><div class=paragraph><p>Εναλλακτικά, μπορείτε να προσθέσετε τις παραπάνω οδηγίες στο <span class=filename>/usr/shared/skel/dot.profile</span> (αντίστοιχα με τις οδηγίες για το <span class=filename>/etc/profile</span> που είδαμε παραπάνω), ή στο <span class=filename>/usr/shared/skel/dot.login</span> (αντίστοιχα με τις οδηγίες για το <span class=filename>/etc/csh.login</span> που είδαμε επίσης παραπάνω).</p></div><div class=paragraph><p>Για το X11:</p></div><div class=paragraph><p>Στο <span class=filename>$HOME/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG</pre></div></div><div class=paragraph><p>Ή:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1</pre></div></div><div class=paragraph><p>Ανάλογα με το κέλυφος που χρησιμοποιείτε (δείτε παραπάνω).</p></div></div></div></div><div class=sect3><h4 id=setting-console>43.3.5. Ρυθμίσεις για την Κονσόλα<a class=anchor href=#setting-console></a></h4><div class=paragraph><p>Για όλα τα single C σετ χαρακτήρων, μπορείτε να θέσετε τις γραμματοσειρές της κονσόλας στο <span class=filename>/etc/rc.conf</span> για την επιθυμητή γλώσσα, γράφοντας:</p></div><div class="literalblock programlisting"><div class=content><pre>font8x16=font_name
font8x14=font_name
font8x8=font_name</pre></div></div><div class=paragraph><p>Το <em>font_name</em> εδώ προκύπτει από το αντίστοιχο αρχείο του καταλόγου <span class=filename>/usr/shared/syscons/fonts</span>, αφαιρώντας την κατάληξη <span class=filename>.fnt</span>.</p></div><div class=paragraph><p>Αν χρειάζεται, χρησιμοποιήστε την κατάλληλη αντιστοίχηση πληκτρολογίου (keymap) και οθόνης για το σετ χαρακτήρων single C που χρησιμοποιείτε, μέσω του <code>sysinstall</code>. Μόλις εκτελέσετε το sysinstall, επιλέξτε το <span class=guimenuitem>Configure</span>, και έπειτα το <span class=guimenuitem>Console</span>. Εναλλακτικά, μπορείτε να προσθέσετε το παρακάτω στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>scrnmap=screenmap_name
keymap=keymap_name
keychange=&#34;fkey_number sequence&#34;</pre></div></div><div class=paragraph><p>Στην περίπτωση αυτή, το <em>screenmap_name</em> προέρχεται από ένα αρχείο του καταλόγου <span class=filename>/usr/shared/syscons/scrnmaps</span>, χωρίς την κατάληξη <span class=filename>.scm</span>. Η αντιστοίχηση οθόνης μαζί με την αντίστοιχη γραμματοσειρά, χρησιμοποιείται συνήθως για την επέκταση του 8ου bit στο 9o, για κάρτες VGA που χρησιμοποιούν μήτρα χαρακτήρων με 8 στήλες.</p></div><div class=paragraph><p>Αν έχετε ενεργοποιημένο τον δαίμονα moused στο αρχείο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>moused_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>καλό θα είναι να εξετάσετε τις πληροφορίες σχετικά με τον δρομέα του ποντικιού που εμφανίζονται στην παρακάτω παράγραφο.</p></div><div class=paragraph><p>Ο προεπιλεγμένος δρομέας του ποντικιού που χρησιμοποιείται από το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a>, καταλαμβάνει τις θέσεις 0xd0-0xd3 του συνόλου χαρακτήρων. Αν αυτή η περιοχή χαρακτήρων δεν είναι διαθέσιμη στη γλώσσα που χρησιμοποιείτε, θα πρέπει να μετακινήσετε την περιοχή του δρομέα έξω από αυτήν. Για να γίνει αυτό στο FreeBSD, προσθέστε την ακόλουθη γραμμή στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div><div class=paragraph><p>Το <em>keymap_name</em> προέρχεται από ένα αρχείο του καταλόγου <span class=filename>/usr/shared/syscons/keymaps</span>, χωρίς την κατάληξη <span class=filename>.kbd</span>. Αν δεν είστε σίγουρος για την αντιστοίχηση πληκτρολογίου που χρειάζεται να χρησιμοποιήσετε, μπορείτε να χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a> για να κάνετε δοκιμές σε διάφορες αντιστοιχίσεις, χωρίς να χρειάζεται να κάνετε επανεκκίνηση.</p></div><div class=paragraph><p>Η λειτουργία <code>keychange</code> χρησιμοποιείται συνήθως για τον προγραμματισμό των πλήκτρων λειτουργιών (function keys), ώστε να ταιριάζουν με τον επιλεγμένο τύπο τερματικού, καθώς οι ακολουθίες των πλήκτρων λειτουργιών δεν μπορούν να καθοριστούν στις αντιστοιχίσεις πληκτρολογίου.</p></div><div class=paragraph><p>Βεβαιωθείτε επίσης ότι έχετε ρυθμίσει το σωστό τύπου τερματικού στο <span class=filename>/etc/ttys</span> για όλες τις καταχωρίσεις <code>ttyv*</code>. Τη δεδομένη στιγμή, οι προκαθορισμένες αντιστοιχίες είναι:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Σετ Χαρακτήρων</th><th class="tableblock halign-left valign-top">Τύπος Τερματικού</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-1 ή ISO8859-15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l7</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25r</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25u</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CP437 (προεπιλεγμένο VGA)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>US-ASCII</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25w</code></p></td></tr></tbody></table><div class=paragraph><p>Για γλώσσες με χαρακτήρες wide ή multibyte, χρησιμοποιήστε το σωστό FreeBSD port στον κατάλογο <span class=filename>/usr/ports/language</span>. Μερικές θύρες εμφανίζονται ως κονσόλα, ενώ το σύστημα τις βλέπει ως σειριακά vtty, και έτσι πρέπει να παρακρατήσετε αρκετά vtty, τόσο για το X11 όσο και για την ψευτό-σειριακή κονσόλα. Παρακάτω θα βρείτε μια μερικώς ενημερωμένη λίστα για χρήση άλλων γλωσσών στην κονσόλα:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Γλώσσα</th><th class="tableblock halign-left valign-top">Τοποθεσία</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Παραδοσιακά Κινέζικα (BIG-5)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/big5con/>chinese/big5con</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Γιαπωνέζικα</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-16dot/>japanese/kon2-16dot</a> ή <a class=package href=https://cgit.freebsd.org/ports/tree/japanese/mule-freewnn/>japanese/mule-freewnn</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Κορεάτικα</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/han/>korean/han</a></p></td></tr></tbody></table></div><div class=sect3><h4 id=_ρύθμιση_του_x11_2>43.3.6. Ρύθμιση του X11<a class=anchor href=#_ρύθμιση_του_x11_2></a></h4><div class=paragraph><p>Αν και το X11 δεν είναι μέρος του FreeBSD Project, θα δώσουμε εδώ κάποιες χρήσιμες πληροφορίες για όσους το χρησιμοποιούν στο FreeBSD. Για περισσότερες πληροφορίες, δείτε την <a href=http://www.x.org/>δικτυακή τοποθεσία του Xorg</a>, ή του εξυπηρετητή X11 που πρόκειται να χρησιμοποιήσετε.</p></div><div class=paragraph><p>Στο αρχείο <span class=filename>~/.Xresources</span>, μπορείτε επιπρόσθετα να αλλάξετε και άλλες ρυθμίσεις που σχετίζονται με το I18N (π.χ. γραμματοσειρές, μενού, κ.λ.π.).</p></div><div class=sect4><h5 id=_απεικόνιση_γραμματοσειρών>43.3.6.1. Απεικόνιση Γραμματοσειρών<a class=anchor href=#_απεικόνιση_γραμματοσειρών></a></h5><div class=paragraph><p>Εγκαταστήστε τον εξυπηρετητή Xorg (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-servers/xorg-server/>x11-servers/xorg-server</a>) και έπειτα εγκαταστήστε τις γραμματοσειρές TrueType® για την επιθυμητή γλώσσα. Με τις σωστές τοπικές ρυθμίσεις, θα μπορείτε να δείτε την επιλεγμένη γλώσσα στα μενού και τα μηνύματα του γραφικού περιβάλλοντος.</p></div></div><div class=sect4><h5 id=_εισαγωγή_μη_αγγλικών_χαρακτήρων>43.3.6.2. Εισαγωγή μη-Αγγλικών Χαρακτήρων<a class=anchor href=#_εισαγωγή_μη_αγγλικών_χαρακτήρων></a></h5><div class=paragraph><p>Η μέθοδος εισόδου X11 (XIM, X11 Input Method), είναι ένα νέο πρότυπο για όλους τους πελάτες X11. Όλες οι εφαρμογές του X11 θα πρέπει να γράφονται ως πελάτες του XIM, και να λαμβάνουν είσοδο από εξυπηρετητές εισόδου XIM. Υπάρχουν διαθέσιμοι διάφοροι εξυπηρετητές XIM, για διαφορετικές γλώσσες.</p></div></div></div><div class=sect3><h4 id=_ρύθμιση_εκτυπωτή>43.3.7. Ρύθμιση Εκτυπωτή<a class=anchor href=#_ρύθμιση_εκτυπωτή></a></h4><div class=paragraph><p>Κάποια σετ χαρακτήρων single C είναι συνήθως ενσωματωμένα στο ίδιο το υλικό των εκτυπωτών. Τα σετ χαρακτήρων τύπου wide ή multibyte απαιτούν ειδικές ρυθμίσεις, και συνιστούμε να χρησιμοποιήσετε το apsfilter. Μπορείτε επίσης να μετατρέψετε το έγγραφο σας σε PostScript® ή PDF, χρησιμοποιώντας εργαλεία ειδικά φτιαγμένα για τη συγκεκριμένη γλώσσα.</p></div></div><div class=sect3><h4 id=_πυρήνας_και_συστήματα_αρχείων>43.3.8. Πυρήνας και Συστήματα Αρχείων<a class=anchor href=#_πυρήνας_και_συστήματα_αρχείων></a></h4><div class=paragraph><p>Το σύστημα αρχείων FFS (fast filesystem) του FreeBSD μπορεί να διαχειριστεί ονόματα αρχείων που ανήκουν σε σετ single C (είναι 8-bit clean, δείτε και το <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a>), αλλά δεν αποθηκεύει το σετ χαρακτήρων που χρησιμοποιείται. Με άλλα λόγια, είναι 8-bit αλλά δεν γνωρίζει τίποτα για την κωδικοποίηση των χαρακτήρων. Επίσημα, το FFS δεν υποστηρίζει ακόμα σετ χαρακτήρων wide ή multibyte. Υπάρχουν ωστόσο κάποια ανεξάρτητα patches για το FFS που υποστηρίζουν αυτές τις δυνατότητες. Πρόκειται μόνο για προσωρινές και μη μεταφέρσιμες λύσεις ή hacks, και έχουμε αποφασίσει να μην τα περιλάβουμε στο κεντρικό δέντρο πηγαίου κώδικα. Δείτε τις ιστοσελίδες των αντίστοιχων γλωσσών για περισσότερες πληροφορίες και για να ανακτήσετε τα απαραίτητα αρχεία.</p></div><div class=paragraph><p>Το σύστημα αρχείων MS-DOS® στο FreeBSD έχει την δυνατότητα να ρυθμιστεί ώστε να μετατρέπει μεταξύ των σετ χαρακτήρων Unicode, του MS-DOS®, και του σετ χαρακτήρων που έχει επιλεγεί για το σύστημα αρχείων του FreeBSD. Για περισσότερες λεπτομέρειες, δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>.</p></div></div></div><div class=sect2><h3 id=l10n-compiling>43.4. Μεταγλώττιση Προγραμμάτων I18N<a class=anchor href=#l10n-compiling></a></h3><div class=paragraph><p>Πολλά ports του FreeBSD διαθέτουν υποστήριξη I18N. Σε μερικά από αυτά, το -I18N είναι μέρος του ονόματος τους. Τα προγράμματα αυτά, και πολλά περισσότερα, έχουν ενσωματωμένη υποστήριξη για I18N και δεν χρειάζονται άλλες ειδικές ρυθμίσεις.</p></div><div class=paragraph><p>Ωστόσο, σε κάποιες εφαρμογές όπως η MySQL, θα πρέπει να ρυθμιστεί το <span class=filename>Makefile</span> με το επιθυμητό σετ χαρακτήρων. Αυτό συνήθως γίνεται περνώντας μια τιμή στο configure στον πηγαίο κώδικα, ή αλλάζοντας το ίδιο το <span class=filename>Makefile</span>.</p></div></div><div class=sect2><h3 id=lang-setup>43.5. Τοπικές Ρυθμίσεις για Συγκεκριμένες Γλώσσες<a class=anchor href=#lang-setup></a></h3><div class=sect3><h4 id=ru-localize>43.5.1. Ρώσικη Γλώσσα (Κωδικοποίηση KOI8-R)<a class=anchor href=#ru-localize></a></h4><div class=paragraph><p>Για περισσότερες πληροφορίες σχετικά με την κωδικοποίηση KOI8-R, δείτε τις <a href=http://koi8.pp.ru/>Αναφορές Σχετικά με το Σετ Χαρακτήρων KOIR-8 (Ρωσικό Σύνολο Χαρακτήρων)</a>.</p></div><div class=sect4><h5 id=_τοπικές_ρυθμίσεις>43.5.1.1. Τοπικές Ρυθμίσεις<a class=anchor href=#_τοπικές_ρυθμίσεις></a></h5><div class=paragraph><p>Τοποθετήστε τις ακόλουθες γραμμές στο αρχείο σας <span class=filename>~/.login_conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>me:My Account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre></div></div><div class=paragraph><p>Για παραδείγματα που σχετίζονται με τις <a href=#setting-locale>Τοπικές Ρυθμίσεις</a>, δείτε προηγούμενες ενότητες σε αυτό το κεφάλαιο.</p></div></div><div class=sect4><h5 id=_ρύθμιση_κονσόλας>43.5.1.2. Ρύθμιση Κονσόλας<a class=anchor href=#_ρύθμιση_κονσόλας></a></h5><div class=ulist><ul><li><p>Προσθέστε την ακόλουθη γραμμή στο αρχείο <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div></li><li><p>Χρησιμοποιήστε επίσης τις παρακάτω ρυθμίσεις στο <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;</pre></div></div></li><li><p>Για κάθε καταχώριση <code>ttyv*</code> στο αρχείο <span class=filename>/etc/ttys</span>, χρησιμοποιήστε το <code>cons25r</code> ως τύπο τερματικού.</p></li></ul></div><div class=paragraph><p>Για παραδείγματα που σχετίζονται με την ρύθμιση της <a href=#setting-console>κονσόλας</a>, δείτε προηγούμενες ενότητες αυτού του κεφαλαίου.</p></div></div><div class=sect4><h5 id=_ρύθμιση_εκτυπωτή_2>43.5.1.3. Ρύθμιση Εκτυπωτή<a class=anchor href=#_ρύθμιση_εκτυπωτή_2></a></h5><div class=paragraph><p>Καθώς οι περισσότεροι εκτυπωτές που διαθέτουν Ρωσικούς χαρακτήρες έχουν ενσωματωμένη την κωδικοσελίδα CP866, θα χρειαστείτε ειδικό φίλτρο εξόδου για να μετατρέψετε από το KOI8-R στο CP866. Το φίλτρο αυτό εγκαθίσταται από προεπιλογή στο <span class=filename>/usr/libexec/lpr/ru/koi2alt</span>. Η καταχώριση για ένα Ρώσικο εκτυπωτή στο <span class=filename>/etc/printcap</span> θα μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> για πιο λεπτομερή περιγραφή.</p></div></div><div class=sect4><h5 id=_σύστημα_αρχείων_ms_dos_και_ρώσικα_ονόματα_αρχείων>43.5.1.4. Σύστημα Αρχείων MS-DOS® και Ρώσικα Ονόματα Αρχείων<a class=anchor href=#_σύστημα_αρχείων_ms_dos_και_ρώσικα_ονόματα_αρχείων></a></h5><div class=paragraph><p>Το παρακάτω υπόδειγμα καταχώρισης στο <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> ενεργοποιεί την υποστήριξη για Ρώσικα ονόματα αρχείων σε προσαρτημένα συστήματα αρχείων τύπου MS-DOS®:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0s2      /dos/c  msdos   rw,-Wkoi2dos,-Lru_RU.KOI8-R 0 0</pre></div></div><div class=paragraph><p>Η επιλογή <code>-L</code> επιλέγει τις τοπικές ρυθμίσεις που θα χρησιμοποιηθούν, και η <code>-W</code> ορίζει τον πίνακα μετατροπής χαρακτήρων. Για να χρησιμοποιήσετε την επιλογή <code>-W</code> βεβαιωθείτε ότι έχετε προσαρτήσει την κατάτμηση <span class=filename>/usr</span> πριν την κατάτμηση MS-DOS®, καθώς οι πίνακες μετατροπής βρίσκονται στο <span class=filename>/usr/libdata/msdosfs</span>. Για περισσότερες πληροφορίες, δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>.</p></div></div><div class=sect4><h5 id=_ρύθμιση_x11>43.5.1.5. Ρύθμιση X11<a class=anchor href=#_ρύθμιση_x11></a></h5><div class="olist arabic"><ol class=arabic><li><p>Εκτελέστε πρώτα <a href=#setting-locale>τις γενικές τοπικές ρυθμίσεις</a> που έχουμε ήδη περιγράψει.</p></li><li><p>Αν χρησιμοποιείτε τον εξυπηρετητή Xorg, εγκαταστήστε το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/xorg-fonts-cyrillic/>x11-fonts/xorg-fonts-cyrillic</a>.</p><div class=paragraph><p>Ελέγξτε την ενότητα <code>"Files"</code> στο αρχείο <span class=filename>/etc/X11/xorg.conf</span>. Θα πρέπει να προσθέσετε την παρακάτω γραμμή <em>πριν</em> από οποιαδήποτε άλλη καταχώριση <code>FontPath</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath   &#34;/usr/local/lib/X11/fonts/cyrillic&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Δείτε στην Συλλογή των Ports για περισσότερες κυριλλικές γραμματοσειρές.</p></div></td></tr></tbody></table></div></li><li><p>Για την ενεργοποίηση του Ρωσικού πληκτρολογίου, προσθέστε τις παρακάτω γραμμές στην ενότητα <code>"Keyboard"</code> του αρχείου <span class=filename>xorg.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre></div></div><div class=paragraph><p>Βεβαιωθείτε επίσης ότι η γραμμή <code>XkbDisable</code> είναι ανενεργή (μαρκαρισμένη ως σχόλιο).</p></div><div class=paragraph><p>Αν χρησιμοποιήσετε το <code>grp:toggle</code> η εναλλαγή RUS/LAT θα γίνεται με το <kbd>Δεξιό Alt</kbd>, ενώ αν θέσετε <code>grp:ctrl_shift_toggle</code>, η εναλλαγή θα γίνεται με το <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Shift</kbd></span>. Για <code>grp:caps_toggle</code>, η εναλλαγή RUS/LAT θα γίνεται με το <kbd>CapsLock</kbd>. Η κανονική λειτουργία του <kbd>CapsLock</kbd> εξακολουθεί να είναι διαθέσιμη μέσω του συνδυασμού πλήκτρων <span class=keyseq><kbd>Shift</kbd>+<kbd>CapsLock</kbd></span> (μόνο σε κατάσταση LAT). Το <code>grp:caps_toggle</code> για κάποιο άγνωστο λόγο, δεν λειτουργεί στο Xorg.</p></div><div class=paragraph><p>Αν το πληκτρολόγιο σας διαθέτει πλήκτρα "Windows®", και έχετε παρατηρήσει ότι κάποια από τα μη-αλφαριθμητικά πλήκτρα έχουν λάθος αντιστοίχηση όταν είστε σε κατάσταση RUS, προσθέστε την παρακάτω γραμμή στο αρχείο <span class=filename>xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το Ρώσικο XKB πληκτρολόγιο ίσως δεν λειτουργεί με εφαρμογές που δεν έχουν φτιαχτεί για τις αντίστοιχες τοπικές ρυθμίσεις.</p></div></td></tr></tbody></table></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι εφαρμογές που τηρούν τις ελάχιστες προδιαγραφές τοπικών ρυθμίσεων, θα πρέπει να καλούν από νωρίς τη συνάρτηση <code>XtSetLanguageProc (NULL, NULL, NULL);</code> μέσα στον κώδικα τους.</p></div><div class=paragraph><p>Δείτε το <a href=http://koi8.pp.ru/xwin.html>KOI8-R για το σύστημα X Window</a> για περισσότερες οδηγίες σχετικά με την δημιουργία εφαρμογών X11 που να χρησιμοποιούν τοπικές ρυθμίσεις.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_τοπικές_ρυθμίσεις_για_παραδοσιακά_κινέζικα_ταϊβάν>43.5.2. Τοπικές Ρυθμίσεις για Παραδοσιακά Κινέζικα Ταϊβάν<a class=anchor href=#_τοπικές_ρυθμίσεις_για_παραδοσιακά_κινέζικα_ταϊβάν></a></h4><div class=paragraph><p>Το FreeBSD-Taiwan Project έχει δημιουργήσει ένα HOWTO για τα Κινέζικα στο FreeBSD, το οποίο μπορείτε να βρείτε στη διεύθυνση <a href=http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/>http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/</a>, χρησιμοποιώντας πολλά Κινέζικα ports. Ο τρέχων συντάκτης του <code>Κινέζικου FreeBSD Howto</code> είναι ο Shen Chuan-Hsing <a href=mailto:statue@freebsd.sinica.edu.tw>statue@freebsd.sinica.edu.tw</a>.</p></div><div class=paragraph><p>Ο Chuan-Hsing Shen <a href=mailto:statue@freebsd.sinica.edu.tw>statue@freebsd.sinica.edu.tw</a> έχει δημιουργήσει την <a href=http://netlab.cse.yzu.edu.tw/\~statue/cfc/>Κινέζικη Συλλογή FreeBSD (CFC)</a> χρησιμοποιώντας την κωδικοποίηση <code>zh-L10N-tut</code> του FreeBSD-Ταΐβάν. Τα πακέτα και τα scripts διατίθενται στη διεύθυνση <a href=ftp://freebsd.csie.nctu.edu.tw/pub/taiwan/CFC/>ftp://freebsd.csie.nctu.edu.tw/pub/taiwan/CFC/</a>.</p></div></div><div class=sect3><h4 id=_τοπικές_ρυθμίσεις_για_την_γερμανική_γλώσσα_για_όλες_τις_γλώσσες_που_βασίζονται_στο_iso_8859_1>43.5.3. Τοπικές Ρυθμίσεις για την Γερμανική Γλώσσα (για Όλες τις Γλώσσες που Βασίζονται στο ISO 8859-1)<a class=anchor href=#_τοπικές_ρυθμίσεις_για_την_γερμανική_γλώσσα_για_όλες_τις_γλώσσες_που_βασίζονται_στο_iso_8859_1></a></h4><div class=paragraph><p>Ο Slaven Rezic <a href=mailto:eserte@cs.tu-berlin.de>eserte@cs.tu-berlin.de</a> έχει γράψει ένα οδηγό για την χρήση των umlauts σε ένα μηχάνημα FreeBSD. Ο οδηγός είναι γραμμένος στα Γερμανικά και διατίθεται στην τοποθεσία <a href=http://user.cs.tu-berlin.de/~eserte/FreeBSD/doc/umlaute/umlaute.html>http://user.cs.tu-berlin.de/~eserte/FreeBSD/doc/umlaute/umlaute.html</a>.</p></div></div><div class=sect3><h4 id=_τοπικές_ρυθμίσεις_για_την_ελληνική_γλώσσα>43.5.4. Τοπικές Ρυθμίσεις για την Ελληνική Γλώσσα<a class=anchor href=#_τοπικές_ρυθμίσεις_για_την_ελληνική_γλώσσα></a></h4><div class=paragraph><p>Ο Nikos Kokkalis &lt;<a href=mailto:nickkokkalis@gmail.com>nickkokkalis@gmail.com</a>> έχει γράψει ένα πλήρες άρθρο για την υποστήριξη της Ελληνικής γλώσσας στο FreeBSD. Το άρθρο αυτό διατίθεται ως μέρος της επίσημης Ελληνικής τεκμηρίωσης του FreeBSD, στην τοποθεσία <a href={greek-language-support}>Υποστήριξη της Ελληνικής Γλώσσας στο FreeBSD</a>.</p></div></div><div class=sect3><h4 id=_τοπικές_ρυθμίσεις_για_γιαπωνέζικα_και_κορεάτικα>43.5.5. Τοπικές Ρυθμίσεις Για Γιαπωνέζικα και Κορεάτικα<a class=anchor href=#_τοπικές_ρυθμίσεις_για_γιαπωνέζικα_και_κορεάτικα></a></h4><div class=paragraph><p>Για Γιαπωνέζικα, δείτε στην τοποθεσία <a href=http://www.jp.FreeBSD.org/>http://www.jp.FreeBSD.org/</a>, ενώ για Κορεάτικα, δείτε στην τοποθεσία <a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a>.</p></div></div><div class=sect3><h4 id=_τεκμηρίωση_του_freebsd_σε_γλώσσες_εκτός_της_αγγλικής>43.5.6. Τεκμηρίωση του FreeBSD σε Γλώσσες Εκτός της Αγγλικής<a class=anchor href=#_τεκμηρίωση_του_freebsd_σε_γλώσσες_εκτός_της_αγγλικής></a></h4><div class=paragraph><p>Κάποιοι εθελοντές του FreeBSD έχουν μεταφράσει τμήματα της τεκμηρίωσης του σε άλλες γλώσσες. Οι μεταφράσεις αυτές διατίθενται μέσω συνδέσμων στην <a href=https://www.FreeBSD.org/>κύρια δικτυακή τοποθεσία του FreeBSD</a> ή στον κατάλογο <span class=filename>/usr/shared/doc</span>.</p></div></div></div></div></div><div class=sect1><h2 id=updating-upgrading>Chapter 44. Ενημέρωση και Αναβάθμιση του FreeBSD<a class=anchor href=#updating-upgrading></a></h2><div class=sectionbody><div class=sect2><h3 id=updating-upgrading-synopsis>44.1. Σύνοψη<a class=anchor href=#updating-upgrading-synopsis></a></h3><div class=paragraph><p>Το FreeBSD βρίσκεται υπό συνεχή εξέλιξη μεταξύ των επίσημων εκδόσεων του. Μερικοί άνθρωποι προτιμούν να χρησιμοποιούν τις επίσημες εκδόσεις, ενώ άλλοι προτιμούν να κρατούν το σύστημα τους ενημερωμένο με τις τελευταίες εξελίξεις. Ωστόσο, ακόμα και οι επίσημες εκδόσεις ενημερώνονται συχνά με διορθώσεις κρίσιμων σφαλμάτων και ασφαλείας. Όποια έκδοση και να χρησιμοποιήσετε, το FreeBSD παρέχει όλα τα απαραίτητα εργαλεία για να κρατήσετε το σύστημα σας ενημερωμένο, και επίσης σας επιτρέπει να αναβαθμιστείτε εύκολα σε κάποια επόμενη έκδοση. Το κεφάλαιο αυτό θα σας βοηθήσει να αποφασίσετε αν θέλετε να παρακολουθείτε το σύστημα ανάπτυξης, ή αν θα προτιμήσετε να παραμείνετε σε μια από τις παγιωμένες εκδόσεις. Θα παρουσιάσουμε επίσης τα βασικά εργαλεία που απαιτούνται για την ενημέρωση και αναβάθμιση του συστήματος.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Ποια βοηθητικά προγράμματα μπορείτε να χρησιμοποιήσετε για να ενημερώσετε το σύστημα και την Συλλογή των Ports.</p></li><li><p>Πως να διατηρείτε το σύστημα σας ενημερωμένο με τα προγράμματα freebsd-updateCVSup, CVS, ή CTM.</p></li><li><p>Πως να συγκρίνετε την κατάσταση ενός εγκατεστημένου συστήματος, με αναφορά ένα γνωστό και εγγυημένα σωστό σύστημα.</p></li><li><p>Πως να διατηρήσετε την τεκμηρίωση σας ενημερωμένη μέσω του CVSup ή των ports της τεκμηρίωσης .</p></li><li><p>Τη διαφορά μεταξύ των δύο κλάδων που βρίσκονται σε εξέλιξη: του FreeBSD-STABLE και του FreeBSD-CURRENT.</p></li><li><p>Πως να ξαναφτιάξετε και να επανεγκαταστήσετε ολόκληρο το βασικό σύστημα με την <code>make buildworld</code> (κλπ).</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να ρυθμίσετε σωστά τη σύνδεση σας στο δίκτυο (<a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a>).</p></li><li><p>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Στο κεφάλαιο αυτό γίνεται συχνά χρήση της εντολής <code>cvsup</code> για την ανάκτηση ή ενημέρωση των αρχείων πηγαίου κώδικα του FreeBSD. Για να την χρησιμοποιήσετε, θα πρέπει να εγκαταστήσετε ένα πακέτο ή port όπως το <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a> (αν δεν θέλετε να εγκαταστήσετε γραφικό πρόγραμμα <code>cvsup</code>, μπορείτε να εγκαταστήσετε το port <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup-without-gui/>net/cvsup-without-gui</a>). Μπορείτε να αντικαταστήσετε αυτή την εντολή με την <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> η οποία ανήκει στο βασικό σύστημα.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=updating-upgrading-freebsdupdate>44.2. Ενημερώνοντας το FreeBSD<a class=anchor href=#updating-upgrading-freebsdupdate></a></h3><div class=paragraph><p>Η εφαρμογή ενημερώσεων ασφαλείας αποτελεί ένα σημαντικό τμήμα της συντήρησης λογισμικού, ειδικά όταν πρόκειται για το λειτουργικό σύστημα. Για μεγάλο διάστημα, η διαδικασία αυτή δεν ήταν εύκολη στο FreeBSD. Έπρεπε να εφαρμοστούν patches στον πηγαίο κώδικα, να γίνει μεταγλώττιση του από την αρχή, και να εγκατασταθούν ξανά τα νέα εκτελέσιμα.</p></div><div class=paragraph><p>Αυτό δεν είναι πλέον αναγκαίο, καθώς το FreeBSD διαθέτει τώρα ένα βοηθητικό πρόγραμμα, το <code>freebsd-update</code>. Το πρόγραμμα παρέχει δύο διαφορετικές λειτουργίες. Η πρώτη είναι η δυνατότητα δυαδικής (binary) ενημέρωσης του βασικού συστήματος με τις τελευταίες διορθώσεις ασφάλειας και λαθών, χωρίς να χρειάζεται ξανά μεταγλώττιση και εγκατάσταση. Η δεύτερη είναι η δυνατότητα αναβάθμισης του συστήματος σε μια νέα μικρή ή μεγάλη επίσημη έκδοση (release).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Δυαδικές διορθώσεις λαθών και ασφάλειας, διατίθενται για όλες τις αρχιτεκτονικές και εκδόσεις που υποστηρίζονται από την ομάδα ασφάλειας. Πριν προχωρήσετε στην αναβάθμιση σε μια νέα έκδοση, θα πρέπει να διαβάσετε τις σχετικές με αυτήν ανακοινώσεις, καθώς μπορεί να περιέχουν σημαντικές πληροφορίες. Μπορείτε να δείτε τις ανακοινώσεις εκδόσεων στην παρακάτω τοποθεσία: <a href=http://www.FreeBSD.org/releases/>http://www.FreeBSD.org/releases/</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν υπάρχει κάποιο <code>crontab</code> που χρησιμοποιεί τις δυνατότητες του <code>freebsd-update</code>, θα πρέπει να απενεργοποιηθεί πριν ξεκινήσει η παρακάτω διαδικασία. Μπορείτε να εγκαταστήσετε την τελευταία έκδοση του <code>freebsd-update</code> κατεβάζοντας το συμπιεσμένο πακέτο από το παραπάνω URL και εκτελώντας τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gunzip -c freebsd-update-upgrade.tgz | tar xvf -</span>
<span class=c># mv freebsd-update.sh /usr/sbin/freebsd-update</span>
<span class=c># mv freebsd-update.conf /etc</span></code></pre></div></div><div class=paragraph><p>Δεν απαιτείται να κατεβάσετε την τελευταία έκδοση, αν χρησιμοποιείτε κάποια από τις τρέχουσες εκδόσεις του FreeBSD.</p></div><div class=sect3><h4 id=freebsdupdate-config-file>44.2.1. Το Αρχείο Ρυθμίσεων<a class=anchor href=#freebsdupdate-config-file></a></h4><div class=paragraph><p>Κάποιοι χρήστες ίσως θέλουν να αλλάξουν το προεπιλεγμένο αρχείο ρυθμίσεων <span class=filename>/etc/freebsd-update.conf</span>, ώστε να έχουν καλύτερο έλεγχο της διαδικασίας. Οι επιλογές είναι γενικά αρκετά καλά τεκμηριωμένες, αλλά οι παρακάτω ίσως να χρειάζονται κάποιες επιπλέον επεξηγήσεις:</p></div><div class="literalblock programlisting"><div class=content><pre># Components of the base system which should be kept updated.
Components src world kernel</pre></div></div><div class=paragraph><p>Αυτή η παράμετρος ελέγχει ποια τμήματα του FreeBSD θα διατηρούνται ενημερωμένα. Η προεπιλογή είναι να ενημερώνεται ο πηγαίος κώδικας, όλο το βασικό σύστημα, και ο πυρήνας. Τα τμήματα είναι τα ίδια που διατίθενται και κατά την εγκατάσταση, για παράδειγμα αν βάλετε την επιλογή <code>world/games</code> θα εγκαθίστανται ενημερώσεις για τα παιχνίδια. Αν βάλετε <code>src/bin</code> θα επιτρέψετε την ενημέρωση του πηγαίου κώδικα του καταλόγου <span class=filename>src/bin</span>.</p></div><div class=paragraph><p>Η καλύτερη επιλογή είναι να αφήσετε εδώ την προεπιλεγμένη τιμή, καθώς αν την αλλάξετε ώστε να περιέχει συγκεκριμένα μόνο τμήματα, θα αναγκαστείτε να αναφέρετε χωριστά μέσα στο αρχείο ρυθμίσεων κάθε τμήμα που θέλετε να ενημερώνεται. Αυτό ίσως έχει καταστροφικά αποτελέσματα, καθώς είναι πιθανό ο πηγαίος κώδικας και τα εκτελέσιμα προγράμματα να μην είναι πλέον σε συγχρονισμό μεταξύ τους.</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</pre></div></div><div class=paragraph><p>Προσθέστε διαδρομές σε καταλόγους, όπως <span class=filename>/bin</span> ή <span class=filename>/sbin</span> για να αφήσετε απείραχτους τους συγκεκριμένους καταλόγους κατά την διαδικασία ενημέρωσης. Η επιλογή αυτή μπορεί να χρησιμοποιηθεί για να αποτρέψει το <code>freebsd-update</code> να γράψει πάνω σε πιθανόν δικές σας τοπικές αλλαγές.</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</pre></div></div><div class=paragraph><p>Η επιλογή αυτή θα ενημερώσει τα αρχεία ρυθμίσεων στους καταλόγους που καθορίζονται, μόνο αν αυτά δεν έχουν μεταβληθεί από το χρήστη. Αν υπάρχουν τοπικές αλλαγές, δεν θα γίνει ενημέρωση. Υπάρχει μια ακόμα επιλογή, η <code>KeepModifiedMetadata</code>, η οποία οδηγεί το <code>freebsd-update</code> να αποθηκεύσει τις αλλαγές μεταξύ των δύο εκδόσεων κατά τη διάρκεια της συγχώνευσης (merge).</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading to a new FreeBSD release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</pre></div></div><div class=paragraph><p>Πρόκειται για τη λίστα των καταλόγων που περιέχουν αρχεία ρυθμίσεων, και στα οποία το <code>freebsd-update</code> θα επιχειρεί την διαδικασία συγχώνευσης αλλαγών. Η διαδικασία συγχώνευσης γίνεται με μια σειρά από patches τύπου <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> παρόμοια με το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> αλλά με λιγότερες επιλογές. Οι συγχωνεύσεις είτε γίνονται δεκτές, είτε προκαλούν το άνοιγμα κάποιου συντάκτη κειμένου, διαφορετικά η εκτέλεση του <code>freebsd-update</code> ακυρώνεται. Αν δεν είστε σίγουρος, κρατήστε αντίγραφο ασφαλείας του καταλόγου <span class=filename>/etc</span> και απλώς δεχθείτε τις αλλαγές. Δείτε το <a href=#mergemaster><code>mergemaster</code></a> για περισσότερες πληροφορίες σχετικά με την εντολή <code>mergemaster</code>.</p></div><div class="literalblock programlisting"><div class=content><pre># Directory in which to store downloaded updates and temporary
# files used by FreeBSD Update.
# WorkDir /var/db/freebsd-update</pre></div></div><div class=paragraph><p>Στον κατάλογο αυτό φυλάσσονται όλα τα patches και τα προσωρινά αρχεία. Σε περιπτώσεις όπου ο χρήστης εκτελεί αναβάθμιση σε μια νεότερη έκδοση του FreeBSD, θα πρέπει να διαθέτει τουλάχιστον ένα gigabyte ελεύθερου χώρου.</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which FreeBSD Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</pre></div></div><div class=paragraph><p>Αν θέσετε την παραπάνω επιλογή στο <code>yes</code>, το <code>freebsd-update</code> θα υποθέσει ότι η λίστα <code>Components</code> είναι πλήρης και δεν θα επιχειρήσει να προχωρήσει σε αλλαγές εκτός λίστας. Ουσιαστικά, το <code>freebsd-update</code> θα προσπαθήσει να ενημερώσει κάθε αρχείο που ανήκει στη λίστα <code>Components</code>.</p></div></div><div class=sect3><h4 id=freebsdupdate-security-patches>44.2.2. Patches Σχετικά με την Ασφάλεια<a class=anchor href=#freebsdupdate-security-patches></a></h4><div class=paragraph><p>Τα patches που σχετίζονται με την ασφάλεια, αποθηκεύονται σε ένα απομακρυσμένο μηχάνημα και μπορούν να μεταφορτωθούν και να εγκατασταθούν με την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update fetch</span>
<span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Αν με την παραπάνω εντολή εγκατασταθούν ενημερώσεις στον πυρήνα, θα χρειαστεί να επανεκκινήσετε το σύστημα. Αν όλα πάνε καλά, το σύστημα θα είναι πλέον ενημερωμένο και μπορείτε να εκτελείτε το <code>freebsd-update</code> αυτόματα με την βοήθεια του <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. Μια απλή καταχώριση στο αρχείο <span class=filename>/etc/crontab</span> είναι επαρκής για αυτό το σκοπό:</p></div><div class="literalblock programlisting"><div class=content><pre>@daily                                  root    freebsd-update cron</pre></div></div><div class=paragraph><p>Η παραπάνω καταχώριση ορίζει ότι το <code>freebsd-update</code> θα εκτελείται μια φορά την ημέρα. Με τον τρόπο αυτό, και όταν η εκτέλεση είναι μέσω της επιλογής <code>cron</code>, το <code>freebsd-update</code> απλώς θα ελέγχει για ενημερώσεις. Αν υπάρχουν, η εφαρμογή θα τις κατεβάζει, αλλά δεν θα τις εγκαθιστά. Θα στέλνει όμως ένα email στο χρήστη <code>root</code> ώστε να τις εγκαταστήσει χειροκίνητα.</p></div><div class=paragraph><p>Αν οτιδήποτε πάει στραβά, το <code>freebsd-update</code> έχει την ικανότητα να επιστρέφει στην προηγούμενη σταθερή κατάσταση, αναιρώντας το τελευταίο σετ αλλαγών με την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update rollback</span></code></pre></div></div><div class=paragraph><p>Με την ολοκλήρωση της εντολής, θα πρέπει να επανεκκινήσετε το σύστημα αν έχουν γίνει αλλαγές στον πυρήνα ή σε κάποιο από τα αρθρώματα του. Αυτό θα επιτρέψει στο FreeBSD να φορτώσει τα νέα εκτελέσιμα στη μνήμη.</p></div><div class=paragraph><p>Το βοηθητικό πρόγραμμα <code>freebsd-update</code> μπορεί να ενημερώσει αυτόματα μόνο τον πυρήνα <span class=filename>GENERIC</span>. Αν χρησιμοποιείται προσαρμοσμένος πυρήνας, θα πρέπει να μεταγλωττιστεί ξανά, όταν το <code>freebsd-update</code> τελειώσει με την εγκατάσταση των υπόλοιπων ενημερώσεων. Ωστόσο, το <code>freebsd-update</code> θα ανιχνεύσει και θα ενημερώσει τον πυρήνα <span class=filename>GENERIC</span> στο <span class=filename>/boot/GENERIC</span> (αν υπάρχει), ακόμα και αν δεν είναι ο ενεργός πυρήνας του συστήματος (αυτός που εκτελείται τη συγκεκριμένη στιγμή).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Είναι γενικά καλή ιδέα να έχετε πάντα ένα αντίγραφο του πυρήνα <span class=filename>GENERIC</span> στον κατάλογο <span class=filename>/boot/GENERIC</span>. Θα σας βοηθήσει στην διάγνωση διάφορων προβλημάτων, καθώς και στην αναβάθμιση σε επόμενες εκδόσεις του FreeBSD, μέσω του <code>freebsd-update</code>. Η διαδικασία αυτή περιγράφεται στο <a href=#freebsdupdate-upgrade>Αναβαθμίσεις σε Μικρές και Μεγάλες Εκδόσεις</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν δεν έχουν γίνει αλλαγές στις προεπιλεγμένες ρυθμίσεις στο αρχείο <span class=filename>/etc/freebsd-update.conf</span>, το <code>freebsd-update</code> θα εγκαταστήσει τα ανανεωμένα αρχεία πηγαίου κώδικα μαζί με τις υπόλοιπες ενημερώσεις. Μπορείτε έπειτα να προχωρήσετε στη μεταγλώττιση και εγκατάσταση νέου προσαρμοσμένου πυρήνα, με το συνήθη τρόπο.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι ενημερώσεις που διανέμονται μέσω του <code>freebsd-update</code> δεν περιλαμβάνουν πάντοτε αλλαγές στον πυρήνα. Δεν είναι απαραίτητο να επαναμεταγλωττίσετε τον προσαρμοσμένο πυρήνα σας, αν η εκτέλεση του <code>freebsd-update install</code> δεν επέφερε αλλαγές στα αρχεία πηγαίου κώδικα του πυρήνα. Ωστόσο, το <code>freebsd-update</code> ενημερώνει πάντοτε το αρχείο <span class=filename>/usr/src/sys/conf/newvers.sh</span>. Το αρχείο αυτό περιέχει το τρέχον επίπεδο ενημερώσεων (patch level) το οποίο και αναφέρεται ως αριθμός <code>-p</code> από εντολές όπως η <code>uname -r</code>. Μεταγλωττίζοντας ξανά τον προσαρμοσμένο πυρήνα σας (ακόμα και αν δεν υπάρχουν άλλες αλλαγές) θα δώσετε τη δυνατότητα στην <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> να αναφέρει με ακρίβεια το επίπεδο ενημερώσεων. Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο όταν συντηρείτε πολλαπλά συστήματα, καθώς σας επιτρέπει να αξιολογήσετε με μια ματιά τι ενημερώσεις έχουν εγκατασταθεί στο καθένα.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=freebsdupdate-upgrade>44.2.3. Αναβαθμίσεις σε Μικρές και Μεγάλες Εκδόσεις<a class=anchor href=#freebsdupdate-upgrade></a></h4><div class=paragraph><p>Η διαδικασία αυτή θα απομακρύνει τα παλιά αρχεία αντικειμενικού κώδικα (object files) καθώς και τις παλιές βιβλιοθήκες, κάνοντας τις περισσότερες εφαρμογές τρίτων κατασκευαστών να μη λειτουργούν. Σας συνιστούμε είτε να απεγκαταστήσετε όλα τα εγκατεστημένα ports και να τα εγκαταστήσετε ξανά, ή να τα αναβαθμίσετε αργότερα, χρησιμοποιώντας το βοηθητικό πρόγραμμα <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a>. Οι περισσότεροι χρήστες θα θέλουν να κάνουν μια δοκιμαστική μεταγλώττιση χρησιμοποιώντας την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -af</span></code></pre></div></div><div class=paragraph><p>Με αυτό τον τρόπο εξασφαλίζεται ότι τα πάντα θα επανεγκατασταθούν σωστά. Σημειώστε ότι αν θέσετε την μεταβλητή περιβάλλοντος <code>BATCH</code> στην τιμή <code>yes</code>, όλες οι πιθανές ερωτήσεις που θα εμφανιστούν κατά τη διαδικασία, θα απαντηθούν αυτόματα με <code>yes</code>. Έτσι δεν υπάρχει πλέον ανάγκη για παρέμβαση του χρήστη κατά τη διάρκεια της διαδικασίας μεταγλώττισης.</p></div><div class=paragraph><p>Αν χρησιμοποιείται προσαρμοσμένος πυρήνας, η διαδικασία αναβάθμισης είναι ελαφρά πιο πολύπλοκη. Θα χρειαστείτε ένα αντίγραφο του πυρήνα <span class=filename>GENERIC</span> στον κατάλογο <span class=filename>/boot/GENERIC</span>. Αν δεν υπάρχει ήδη ο πυρήνας <span class=filename>GENERIC</span> στο σύστημα σας, μπορείτε να τον ανακτήσετε χρησιμοποιώντας μια από τις παρακάτω μεθόδους:</p></div><div class=ulist><ul><li><p>Αν έχετε μεταγλωττίσει προσαρμοσμένο πυρήνα μόνο μια φορά, ο πυρήνας στον κατάλογο <span class=filename>/boot/kernel.old</span> είναι στην πραγματικότητα ο <span class=filename>GENERIC</span>. Απλώς μετονομάστε τον κατάλογο σε <span class=filename>/boot/GENERIC</span>.</p></li><li><p>Αν έχετε φυσική πρόσβαση στο μηχάνημα, μπορείτε να εγκαταστήσετε ένα αντίγραφο του πυρήνα <span class=filename>GENERIC</span> από το CD-ROM της εγκατάστασης. Τοποθετήστε το CD-ROM στον οδηγό και χρησιμοποιήστε τις παρακάτω εντολές:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cd /cdrom/X.Y-RELEASE/kernels</span>
<span class=c># ./install.sh GENERIC</span></code></pre></div></div><div class=paragraph><p>Αντικαταστήστε το <span class=filename>X.Y-RELEASE</span> με τους πραγματικούς αριθμούς της έκδοσης που χρησιμοποιείτε. Ο πυρήνας <span class=filename>GENERIC</span> θα εγκατασταθεί από προεπιλογή στον κατάλογο <span class=filename>/boot/GENERIC</span>.</p></div></li><li><p>Αν δεν έχετε κάποια από τις παραπάνω επιλογές, μπορείτε να μεταγλωττίσετε και να εγκαταστήσετε τον πυρήνα <span class=filename>GENERIC</span> μέσω του πηγαίου κώδικα:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/</span>
<span class=c># env DESTDIR=/boot/GENERIC make kernel</span>
<span class=c># mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</span>
<span class=c># rm -rf /boot/GENERIC/boot</span></code></pre></div></div><div class=paragraph><p>Για να αναγνωριστεί αυτός ο πυρήνας ως <span class=filename>GENERIC</span> από το <code>freebsd-update</code>, δεν θα πρέπει να έχουν γίνει αλλαγές στο αρχείο ρυθμίσεων του <span class=filename>GENERIC</span>. Συνίσταται επίσης η μεταγλώττιση να γίνει χωρίς άλλες εξειδικευμένες ρυθμίσεις (κατά προτίμηση με κενό το <span class=filename>/etc/make.conf</span>).</p></div></li></ul></div><div class=paragraph><p>Δεν χρειάζεται τη δεδομένη στιγμή να επανεκκινήσετε με τον πυρήνα <span class=filename>GENERIC</span>.</p></div><div class=paragraph><p>Είναι δυνατές οι αναβαθμίσεις τόσο σε μικρές όσο και σε μεγάλες εκδόσεις, δίνοντας στην εντολή <code>freebsd-update</code> τον επιθυμητό αριθμό έκδοσης. Για παράδειγμα, η ακόλουθη εντολή θα αναβαθμίσει το σύστημα σε FreeBSD 8.1:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -r 8.1-RELEASE upgrade</span></code></pre></div></div><div class=paragraph><p>Μετά τη λήψη της εντολής, το <code>freebsd-update</code> θα αξιολογήσει την κατάσταση του συστήματος και του αρχείου ρυθμίσεων του, σε μια απόπειρα να μαζέψει τις απαραίτητες πληροφορίες για την αναβάθμιση του συστήματος. Οι πληροφορίες που ανιχνεύθηκαν θα εμφανιστούν στην οθόνη με τη μορφή μιας λίστας εγκατεστημένων προγραμμάτων. Για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature <span class=k>for </span>8.0-RELEASE from update1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD <span class=k>do </span>not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable <span class=o>(</span>y/n<span class=o>)</span>? y</code></pre></div></div><div class=paragraph><p>Στο σημείο αυτό, το <code>freebsd-update</code> θα κατεβάσει όλα τα αρχεία που απαιτούνται για την αναβάθμιση. Σε μερικές περιπτώσεις, ο χρήστης θα κληθεί να απαντήσει σε ερωτήσεις σχετικά με το τι θα εγκατασταθεί ή πως πρέπει να προχωρήσει η διαδικασία.</p></div><div class=paragraph><p>Όταν χρησιμοποιείται προσαρμοσμένος πυρήνας, το παραπάνω βήμα θα προκαλέσει την εμφάνιση της παρακάτω προειδοποίησης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>WARNING: This system is running a <span class=s2>&#34;MYKERNEL&#34;</span> kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running <span class=s2>&#34;/usr/sbin/freebsd-update install&#34;</span></code></pre></div></div><div class=paragraph><p>Μπορείτε να αγνοήσετε αυτή την προειδοποίηση. Θα χρησιμοποιήσουμε τον ενημερωμένο πυρήνα <span class=filename>GENERIC</span> ως ενδιάμεσο βήμα στη διαδικασία αναβάθμισης.</p></div><div class=paragraph><p>Αφού μεταφορτωθούν όλα τα patches στο τοπικό σύστημα, θα γίνει και η εφαρμογή τους. Η διαδικασία αυτή ίσως πάρει λίγο χρόνο, ανάλογα με την ταχύτητα και το φορτίο του μηχανήματος. Έπειτα θα γίνει η συγχώνευση των αρχείων ρυθμίσεων. Αυτό το μέρος της διαδικασίας απαιτεί παρέμβαση του χρήστη, καθώς σε κάποια αρχεία θα χρειαστεί η συγχώνευση να γίνει χειροκίνητα με τη βοήθεια κάποιου συντάκτη κειμένου. Ο χρήστης θα ενημερώνεται για το αποτέλεσμα κάθε επιτυχημένης συγχώνευσης καθώς εξελίσσεται η διαδικασία. Σε περίπτωση αποτυχημένης συγχώνευσης (ή αγνόησης της), η διαδικασία αναβάθμισης θα διακοπεί. Ενδεχομένως να θέλετε να κρατήσετε αντίγραφο ασφαλείας του καταλόγου <span class=filename>/etc</span> και να συγχωνεύσετε αργότερα (χειροκίνητα) κάποια σημαντικά αρχεία, όπως το <span class=filename>master.passwd</span> ή το <span class=filename>group</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Στο σημείο αυτό δεν έχει γίνει ακόμα καμιά αλλαγή στο σύστημα, καθώς όλη η διαδικασία της αναβάθμισης και συγχώνευσης γίνεται σε διαφορετικό κατάλογο. Όταν εφαρμοστούν επιτυχώς όλα τα patches και ολοκληρωθεί με επιτυχία η διαδικασία της συγχώνευσης όλων των αρχείων ρύθμισης, ο χρήστης θα πρέπει να επιβεβαιώσει την τελική εγκατάσταση.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Με το τέλος αυτής τη διαδικασίας, η αναβάθμιση μπορεί να οριστικοποιηθεί στο δίσκο, με τη χρήση της ακόλουθης εντολής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Στην πρώτη φάση, θα αλλαχθεί ο πυρήνας και τα σχετικά αρθρώματα. Στο σημείο αυτό, θα πρέπει να γίνει επανεκκίνηση του μηχανήματος. Σε μηχάνημα με προσαρμοσμένο πυρήνα, χρησιμοποιήστε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=nextboot&amp;sektion=8&amp;format=html">nextboot(8)</a> ώστε να θέσετε τον πυρήνα για την επόμενη εκκίνηση στον <span class=filename>/boot/GENERIC</span> (ο οποίος έχει ήδη αναβαθμιστεί):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nextboot -k GENERIC</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Πριν επανεκκινήσετε με τον πυρήνα <span class=filename>GENERIC</span>, βεβαιωθείτε ότι περιέχει όλα τα προγράμματα οδήγησης που απαιτούνται για την επιτυχή εκκίνηση του συστήματος σας (και τη λειτουργία του δικτύου, αν αναβαθμίζετε κάποιο απομακρυσμένο μηχάνημα). Ειδικότερα, αν ο προηγούμενος προσαρμοσμένος πυρήνας περιείχε λειτουργίες που συνήθως παρέχονται από αρθρώματα (modules), βεβαιωθείτε ότι φροντίσατε να φορτωθούν προσωρινά στον πυρήνα <span class=filename>GENERIC</span> χρησιμοποιώντας τις δυνατότητες του αρχείου <span class=filename>/boot/loader.conf</span>. Ίσως επίσης να θέλετε να απενεργοποιήσετε υπηρεσίες, προσαρτήσεις δίσκων και δικτύου κ.λ.π. που δεν είναι απαραίτητες, μέχρι την ολοκλήρωση της διαδικασίας αναβάθμισης.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε την ακόλουθη εντολή για να επανεκκινήσετε το μηχάνημα με τον νέο πυρήνα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Μόλις το σύστημα επανέλθει σε λειτουργία, θα πρέπει να εκτελέσετε ξανά το <code>freebsd-update</code>. Η προηγούμενη λειτουργία έχει αποθηκευθεί, και έτσι το <code>freebsd-update</code> δεν θα ξεκινήσει από την αρχή, αλλά θα απομακρύνει όλες τις παλιές κοινόχρηστες βιβλιοθήκες και τα αρχεία αντικειμενικού κώδικα. Για να συνεχίσετε σε αυτό το στάδιο, δώστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ανάλογα με το αν υπήρξαν αλλαγές στους αριθμούς εκδόσεων των βιβλιοθηκών, ίσως να υπάρχουν μόνο δύο φάσεις εγκατάστασης αντί για τρεις.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Όλο το λογισμικό τρίτου κατασκευαστή θα πρέπει τώρα να μεταγλωττιστεί και να επανεγκατασταθεί από την αρχή. Αυτό απαιτείται καθώς το εγκατεστημένο λογισμικό ίσως εξαρτάται από βιβλιοθήκες οι οποίες αφαιρέθηκαν κατά τη διαδικασία της αναβάθμισης. Μπορείτε να χρησιμοποιήσετε την εντολή <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> για να αυτοματοποιήσετε αυτή τη διαδικασία. Για να ξεκινήσετε, δώστε τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -f ruby</span>
<span class=c># rm /var/db/pkg/pkgdb.db</span>
<span class=c># portupgrade -f ruby18-bdb</span>
<span class=c># rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</span>
<span class=c># portupgrade -af</span></code></pre></div></div><div class=paragraph><p>Μόλις ολοκληρωθεί το παραπάνω, ολοκληρώστε τη διαδικασία αναβάθμισης με μια τελευταία κλήση της εντολής <code>freebsd-update</code>. Δώστε την παρακάτω εντολή για να ολοκληρώσετε οτιδήποτε έχει απομείνει στη διαδικασία αναβάθμισης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Αν χρησιμοποιούσατε προσωρινά τον πυρήνα <span class=filename>GENERIC</span>, αυτή είναι η κατάλληλη στιγμή για να μεταγλωττίσετε και να εγκαταστήσετε νέο προσαρμοσμένο πυρήνα, με το συνήθη τρόπο.</p></div><div class=paragraph><p>Επανεκκινήστε το μηχάνημα σας στην νέα έκδοση του FreeBSD. Η διαδικασία έχει ολοκληρωθεί.</p></div></div><div class=sect3><h4 id=freebsdupdate-system-comparison>44.2.4. Σύγκριση Κατάστασης του Συστήματος<a class=anchor href=#freebsdupdate-system-comparison></a></h4><div class=paragraph><p>Το βοηθητικό πρόγραμμα <code>freebsd-update</code> μπορεί να χρησιμοποιηθεί για να ελέγξετε την κατάσταση της εγκατεστημένης έκδοσης του FreeBSD σε σχέση με μια γνωστή και σωστή εγκατάσταση. Η επιλογή αυτή συγκρίνει και αξιολογεί την τρέχουσα έκδοση των προγραμμάτων συστήματος, των βιβλιοθηκών και των αρχείων ρύθμισης. Για να ξεκινήσετε τη σύγκριση, δώστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update IDS &gt;&gt; outfile.ids</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Αν και το όνομα της εντολής είναι IDS, δεν θα πρέπει σε καμιά περίπτωση να θεωρηθεί υποκατάστατο ενός συστήματος ανίχνευσης εισβολέα (intrusion detection system) όπως είναι για παράδειγμα το <a class=package href=https://cgit.freebsd.org/ports/tree/security/snort/>security/snort</a>. Καθώς το <code>freebsd-update</code> αποθηκεύει τα δεδομένα του στο δίσκο, υπάρχει πάντα η πιθανότητα να έχει γίνει αλλοίωση τους. Αν και η πιθανότητα αυτή μπορεί να μειωθεί χρησιμοποιώντας τη ρύθμιση <code>kern.securelevel</code> και αποθηκεύοντας τα δεδομένα της εντολής <code>freebsd-update</code> σε ένα σύστημα αρχείων μόνο για ανάγνωση, μια ακόμα καλύτερη λύση θα ήταν να συγκρίνετε το σύστημα με κάποιο δίσκο που θεωρείτε σίγουρα ασφαλή. Μπορείτε να χρησιμοποιήσετε ένα δίσκο DVD ή ένα εξωτερικό δίσκο USB που φυλάσσετε σε ασφαλή τοποθεσία.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Θα γίνει τώρα μια επιθεώρηση του συστήματος και θα εκτυπωθεί μια λίστα από αρχεία και τιμές hash του τύπου <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a>, τόσο για το εγκατεστημένο όσο και για το γνωστό σύστημα. Επειδή πρόκειται για μεγάλη λίστα, την ανακατευθύνουμε στο αρχείο <span class=filename>outfile.ids</span>. Στην οθόνη το κείμενο θα κυλούσε πολύ γρήγορα, και σύντομα θα γέμιζε την προσωρινή μνήμη απεικόνισης της κονσόλας.</p></div><div class=paragraph><p>Οι γραμμές αυτές έχουν γενικά μεγάλο μήκος, αλλά είναι εύκολο να επεξεργαστούμε την έξοδο. Για παράδειγμα, για να δείτε μια λίστα όλων των αρχείων που διαφέρουν από αυτά της επίσημης έκδοσης, δώστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat outfile.ids | awk &#39;{ print $1 }&#39; | more</span>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</code></pre></div></div><div class=paragraph><p>Τα παραπάνω είναι μόνο ένα μέρος της εξόδου, υπάρχουν ακόμα πολλά διαφορετικά αρχεία. Κάποια από αυτά τα αρχεία είναι φυσιολογικό να έχουν τροποποιηθεί. Για παράδειγμα, το <span class=filename>/etc/passwd</span> έχει τροποποιηθεί, καθώς έχουν προστεθεί χρήστες στο σύστημα. Σε μερικές περιπτώσεις, μπορεί να υπάρχουν και άλλα αρχεία, όπως π.χ. αρθρώματα πυρήνα τα οποία διαφέρουν αφού έχουν ενημερωθεί μέσω της <code>freebsd-update</code>. Για να εξαιρέσετε συγκεκριμένα αρχεία ή καταλόγους, προσθέστε τα στην επιλογή <code>IDSIgnorePaths</code> στο αρχείο ρυθμίσεων <span class=filename>/etc/freebsd-update.conf</span>.</p></div><div class=paragraph><p>Εκτός από την χρήση που αναφέραμε προηγουμένως, το σύστημα αυτό μπορεί να χρησιμοποιηθεί και ως τμήμα μιας λεπτομερούς διαδικασίας αναβάθμισης.</p></div></div></div><div class=sect2><h3 id=updating-upgrading-portsnap>44.3. Portsnap: Ένα Εργαλείο Ενημέρωσης της Συλλογής των Ports<a class=anchor href=#updating-upgrading-portsnap></a></h3><div class=paragraph><p>Το βασικό σύστημα του FreeBSD περιλαμβάνει επίσης ένα βοηθητικό πρόγραμμα για την ενημέρωση της Συλλογής των Ports. Πρόκειται για το <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a>. Όταν το εκτελέσετε, θα συνδεθεί σε ένα απομακρυσμένο διακομιστή, θα επαληθεύσει το κλειδί του πηγαίου κώδικα, και θα κατεβάσει ένα νέο αντίγραφο της Συλλογής των Ports. Το κλειδί χρησιμοποιείται για να επαληθεύσει την ακεραιότητα όλων των αρχείων που μεταφορτώνονται, εξασφαλίζοντας ότι δεν έχουν αλλοιωθεί κατά την μεταφορά. Για να κατεβάσετε τα τελευταία αρχεία της Συλλογής των Ports, εκτελέστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span>
Looking up portsnap.FreeBSD.org mirrors... 9 mirrors found.
Fetching snapshot tag from geodns-1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching snapshot metadata... <span class=k>done</span><span class=nb>.</span>
Updating from Tue May 22 02:12:15 CEST 2012 to Wed May 23 16:28:31 CEST 2012.
Fetching 3 metadata patches.. <span class=k>done</span><span class=nb>.</span>
Applying metadata patches... <span class=k>done</span><span class=nb>.</span>
Fetching 3 metadata files... <span class=k>done</span><span class=nb>.</span>
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. <span class=k>done</span><span class=nb>.</span>
Applying patches... <span class=k>done</span><span class=nb>.</span>
Fetching 133 new ports or files... <span class=k>done</span>.</code></pre></div></div><div class=paragraph><p>Το παραπάνω παράδειγμα δείχνει ότι το <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> βρήκε και επαλήθευσε αρκετά patches τα οποία πρέπει να εφαρμοστούν στο υπάρχον δέντρο των ports. Αυτό δείχνει επίσης ότι το πρόγραμμα έχει εκτελεστεί κατά το παρελθόν. Αν αυτή ήταν η πρώτη φορά που εκτελούνταν, θα γίνονταν απλώς κατέβασμα της συλλογής.</p></div><div class=paragraph><p>Όταν το <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> εκτελέσει επιτυχώς τη λειτουργία <code>fetch</code>, η Συλλογή των Ports και τα αντίστοιχα patches έχουν αποθηκευθεί στο τοπικό σύστημα και έχει γίνει η επαλήθευση τους. Την πρώτη φορά που θα εκτελέσετε το <code>portsnap</code>, θα πρέπει να χρησιμοποιήσετε το <code>extract</code> για να εγκαταστήσετε τα ενημερωμένα αρχεία:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
...</code></pre></div></div><div class=paragraph><p>Αν έχετε ήδη εγκατεστημένη την Συλλογή των Ports, χρησιμοποιήστε την εντολή <code>portsnap update</code> για να την ενημέρωσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap update</span></code></pre></div></div><div class=paragraph><p>Η διαδικασία έχει πλέον ολοκληρωθεί, και μπορείτε να εγκαταστήσετε ή να αναβαθμίσετε εφαρμογές χρησιμοποιώντας την ενημερωμένη Συλλογή των Ports.</p></div><div class=paragraph><p>Μπορείτε να εκτελέσετε τις διαδικασίες <code>fetch</code> και <code>extract</code> ή <code>update</code> διαδοχικά, όπως φαίνεται στο παρακάτω παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch update</span></code></pre></div></div><div class=paragraph><p>Η παραπάνω εντολή θα κατεβάσει την τελευταία έκδοση της Συλλογής των Ports και θα ενημερώσει τα τοπικά αρχεία σας στον κατάλογο <span class=filename>/usr/ports</span>.</p></div></div><div class=sect2><h3 id=updating-upgrading-documentation>44.4. Ενημερώνοντας την Τεκμηρίωση<a class=anchor href=#updating-upgrading-documentation></a></h3><div class=paragraph><p>Εκτός από το βασικό σύστημα και την Συλλογή των Ports, η τεκμηρίωση αποτελεί επίσης βασικό τμήμα ενός συστήματος FreeBSD. Αν και πάντα μπορείτε να βρείτε την πιο πρόσφατη τεκμηρίωση στην <a href=http://www.freebsd.org/doc/>δικτυακή τοποθεσία του FreeBSD</a>, ορισμένοι χρήστες ίσως έχουν αργή ή μη σταθερή σύνδεση με το Διαδίκτυο. Ευτυχώς υπάρχουν αρκετοί τρόποι για να ενημερώσετε την τεκμηρίωση η οποία παρέχεται με κάθε επίσημη έκδοση, διατηρώντας το δικό σας τοπικό αντίγραφο της πιο πρόσφατης τεκμηρίωσης του FreeBSD.</p></div><div class=sect3><h4 id=csup-doc>44.4.1. Χρησιμοποιώντας το CVSup για την Ενημέρωση της Τεκμηρίωσης<a class=anchor href=#csup-doc></a></h4><div class=paragraph><p>Ο πηγαίος κώδικας και το εγκατεστημένο αντίγραφο της τεκμηρίωσης του FreeBSD, μπορούν να ενημερωθούν με την βοήθεια του CVSup, χρησιμοποιώντας ένα μηχανισμό παρόμοιο με αυτόν που χρησιμοποιείται στο βασικό σύστημα (δείτε το <a href=#makeworld>Μεταγλωττίζοντας το Βασικό Σύστημα ("world")</a>). Η ενότητα αυτή περιγράφει:</p></div><div class=ulist><ul><li><p>Πως να εγκαταστήσετε τα εργαλεία που απαιτούνται για την τεκμηρίωση, με τα οποία μπορείτε να δημιουργήσετε την τεκμηρίωση του FreeBSD ξεκινώντας από τον πηγαίο της κώδικα.</p></li><li><p>Πως να κατεβάσετε ένα αντίγραφο του πηγαίου κώδικα της τεκμηρίωσης στον κατάλογο <span class=filename>/usr/doc</span> χρησιμοποιώντας το CVSup.</p></li><li><p>Πως να αναδημιουργήσετε την τεκμηρίωση του FreeBSD από τον πηγαίο της κώδικα, και να την εγκαταστήσετε στον κατάλογο <span class=filename>/usr/shared/doc/</span>.</p></li></ul></div></div><div class=sect3><h4 id=installing-documentation-toolchain>44.4.2. Εγκαθιστώντας το CVSup και τη Σειρά Εργαλείων της Τεκμηρίωσης<a class=anchor href=#installing-documentation-toolchain></a></h4><div class=paragraph><p>Η αναδημιουργία της τεκμηρίωσης του FreeBSD από τον πηγαίο κώδικα, απαιτεί μια σχετικά μεγάλη συλλογή εργαλείων. Τα εργαλεία αυτά δεν είναι μέρος του βασικού συστήματος του FreeBSD, καθώς χρειάζονται αρκετό χώρο στο δίσκο και δεν είναι χρήσιμα σε όλους τους χρήστες. Είναι χρήσιμα μόνο στους χρήστες που ασχολούνται με τη συγγραφή νέας τεκμηρίωσης για το FreeBSD, ή που ενημερώνουν συχνά την τοπική τους τεκμηρίωση μέσω του πηγαίου κώδικα.</p></div><div class=paragraph><p>Όλα τα απαιτούμενα εργαλεία διατίθενται μέσω της Συλλογής των Ports. Το <a class=package href=https://cgit.freebsd.org/ports/tree/textproc/docproj/>textproc/docproj</a> είναι το κύριο port το οποίο έχει αναπτυχθεί από την Ομάδα Τεκμηρίωσης του FreeBSD, για να βοηθήσει στην αρχική εγκατάσταση και τις μελλοντικές αναβαθμίσεις αυτών των εργαλείων.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν δεν απαιτείται η δημιουργία τεκμηρίωσης σε μορφές PostScript® ή PDF, μπορείτε να εγκαταστήσετε το port <a class=package href=https://cgit.freebsd.org/ports/tree/textproc/docproj-nojadetex/>textproc/docproj-nojadetex</a>. Αυτή η έκδοση των εργαλείων περιέχει τα πάντα εκτός από την μηχανή στοιχειοθεσίας teTeX. Το teTeX είναι μια αρκετά μεγάλη συλλογή εργαλείων, και δεν έχει νόημα να το εγκαταστήσετε αν δεν σας είναι απαραίτητη η παραγωγή της τεκμηρίωσης σε μορφή PDF.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για περισσότερες πληροφορίες σχετικά με την εγκατάσταση και χρήση του CVSup, δείτε την ενότητα <a href=./#cvsup>Χρησιμοποιώντας το CVSup</a>.</p></div></div><div class=sect3><h4 id=updating-documentation-sources>44.4.3. Ενημερώνοντας τον Πηγαίο Κώδικα της Τεκμηρίωσης<a class=anchor href=#updating-documentation-sources></a></h4><div class=paragraph><p>Το βοηθητικό πρόγραμμα CVSup μπορεί να κατεβάσει ένα καθαρό αντίγραφο του πηγαίου κώδικα της τεκμηρίωσης, χρησιμοποιώντας το <span class=filename>/usr/shared/examples/cvsup/doc-supfile</span> ως πρότυπο αρχείο ρυθμίσεων. Ο προεπιλεγμένος υπολογιστής ενημερώσεων στο παραπάνω αρχείο είναι ρυθμισμένος σε πλασματική τιμή. Ωστόσο, η <a href="https://man.freebsd.org/cgi/man.cgi?query=cvsup&amp;sektion=1&amp;format=html">cvsup(1)</a> δέχεται όνομα υπολογιστή μέσω της γραμμής εντολών, έτσι μπορείτε να ανακτήσετε τον πηγαίο κώδικα της τεκμηρίωσης μέσω κάποιου εξυπηρετητή CVSup γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cvsup -h cvsup.FreeBSD.org -g -L 2 /usr/shared/examples/cvsup/doc-supfile</span></code></pre></div></div><div class=paragraph><p>Αλλάξτε το <em>cvsup.FreeBSD.org</em> με τον κοντινότερο σας εξυπηρετητή CVSup. Δείτε το <a href=./#cvsup-mirrors>Τοποθεσίες CVSup</a> για μια πλήρη λίστα των mirror sites.</p></div><div class=paragraph><p>Το αρχικό κατέβασμα του πηγαίου κώδικα της τεκμηρίωσης μπορεί να διαρκέσει αρκετή ώρα. Αφήστε το να εκτελείται μέχρι να ολοκληρωθεί.</p></div><div class=paragraph><p>Μπορείτε να συνεχίσετε να ενημερώνετε τον πηγαίο κώδικα της τεκμηρίωσης χρησιμοποιώντας την ίδια εντολή. Το βοηθητικό πρόγραμμα CVSup κατεβάζει και αντιγράφει μόνο τις ενημερώσεις σε σχέση με την τελευταία εκτέλεση του, έτσι κάθε εκτέλεση του CVSup μετά την πρώτη θα πρέπει να είναι αρκετά γρήγορη.</p></div><div class=paragraph><p>Μετά την αρχική ανάκτηση του πηγαίου κώδικα, ένας εναλλακτικός τρόπος ενημέρωσης της τεκμηρίωσης είναι μέσω του αρχείου <span class=filename>Makefile</span> στον κατάλογο <span class=filename>/usr/doc</span>. Θέτοντας τις μεταβλητές <code>SUP_UPDATE</code>, <code>SUPHOST</code> και <code>DOCSUPFILE</code> στο αρχείο <span class=filename>/etc/make.conf</span>, μπορείτε να εκτελέσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make update</span></code></pre></div></div><div class=paragraph><p>Τυπικές τιμές για τις παραπάνω επιλογές του <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> στο αρχείο <span class=filename>/etc/make.conf</span> είναι:</p></div><div class="literalblock programlisting"><div class=content><pre>SUP_UPDATE= yes
SUPHOST?= cvsup.freebsd.org
DOCSUPFILE?= /usr/shared/examples/cvsup/doc-supfile</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν θέσετε τις τιμές των <code>SUPHOST</code> και <code>DOCSUPFILE</code> σε <code>?=</code>, θα μπορείτε να ορίσετε άλλες τιμές για αυτές στη γραμμή εντολής του make. Αυτός είναι και ο συνιστώμενος τρόπος να προσθέσετε επιλογές στο <span class=filename>make.conf</span>, ώστε να αποφεύγετε να τροποποιείτε συνέχεια το αρχείο κάθε φορά που θέλετε να δοκιμάσετε μια νέα τιμή σε μια επιλογή.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=updating-documentation-options>44.4.4. Προσαρμογή Επιλογών στον Πηγαίο Κώδικα της Τεκμηρίωσης<a class=anchor href=#updating-documentation-options></a></h4><div class=paragraph><p>Το σύστημα ενημέρωσης και μεταγλώττισης της τεκμηρίωσης του FreeBSD, υποστηρίζει μερικές επιλογές που διευκολύνουν τη διαδικασία ενημέρωσης ενός μόνο μέρους της τεκμηρίωσης, ή την μεταγλώττιση της τεκμηρίωσης κάποιων συγκεκριμένων μεταφράσεων. Αν θέλετε οι επιλογές αυτές να ισχύουν μόνιμα, μπορείτε να τις ορίσετε μέσα στο αρχείο <span class=filename>/etc/make.conf</span>, διαφορετικά μπορείτε να τις ορίζετε κάθε φορά στη γραμμή εντολής της <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>.</p></div><div class=paragraph><p>Κάποιες από τις επιλογές αυτές φαίνονται παρακάτω:</p></div><div class=dlist><dl><dt class=hdlist1><code>DOC_LANG</code></dt><dd><p>Λίστα των γλωσσών και κωδικοποιήσεων που θα μεταγλωττιστούν και θα εγκατασταθούν, π.χ. <code>en_US.ISO8859-1</code> αν είναι επιθυμητή μόνο η Αγγλική τεκμηρίωση.</p></dd><dt class=hdlist1><code>FORMATS</code></dt><dd><p>Η μορφή (ή μια λίστα από μορφές) στην οποία θα παραχθεί η μεταγλωττισμένη τεκμηρίωση. Τη δεδομένη στιγμή υποστηρίζονται οι μορφές <code>html</code>, <code>html-split</code>, <code>txt</code>, <code>ps</code>, <code>pdf</code> και <code>rtf</code>.</p></dd><dt class=hdlist1><code>SUPHOST</code></dt><dd><p>Το όνομα του εξυπηρετητή CVSup που θα χρησιμοποιηθεί κατά την ενημέρωση.</p></dd><dt class=hdlist1><code>DOCDIR</code></dt><dd><p>Ο κατάλογος στον οποίο θα εγκατασταθεί η τεκμηρίωση. Από προεπιλογή είναι ο <span class=filename>/usr/shared/doc</span>.</p></dd></dl></div><div class=paragraph><p>Για περισσότερες πληροφορίες σχετικά με τις μεταβλητές του make που υποστηρίζονται ως επιλογές συστήματος στο FreeBSD, δείτε την σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>.</p></div><div class=paragraph><p>Για περισσότερες πληροφορίες και μεταβλητές make που υποστηρίζονται από το σύστημα μεταγλώττισης της τεκμηρίωσης του FreeBSD, παρακαλούμε δείτε τις <a href=/books/fdp-primer>Οδηγίες της Ομάδας Τεκμηρίωσης του FreeBSD για Νέους Συγγραφείς</a>.</p></div></div><div class=sect3><h4 id=updating-installed-documentation>44.4.5. Εγκατάσταση της Τεκμηρίωσης του FreeBSD από τον Πηγαίο Κώδικα<a class=anchor href=#updating-installed-documentation></a></h4><div class=paragraph><p>Έχοντας ενημερώσει το τοπικό αντίγραφο του πηγαίου κώδικα της τεκμηρίωσης στον κατάλογο <span class=filename>/usr/doc</span>, είμαστε έτοιμοι για την ενημέρωση της εγκατεστημένης τεκμηρίωσης.</p></div><div class=paragraph><p>Μπορείτε να προχωρήσετε σε πλήρη ενημέρωση όλων των γλωσσών που ορίζονται στην επιλογή <code>DOC_LANG</code> του Makefile, γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Αν έχετε ρυθμίσει το <span class=filename>make.conf</span> με τις σωστές τιμές για τις επιλογές <code>DOCSUPFILE</code>, <code>SUPHOST</code> και <code>SUP_UPDATE</code>, μπορείτε να συνδυάσετε τα βήματα ενημέρωσης και εγκατάστασης του πηγαίου κώδικα σε ένα, γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make update install clean</span></code></pre></div></div><div class=paragraph><p>Αν επιθυμείτε την ενημέρωση μιας μόνο συγκεκριμένης γλώσσας, μπορείτε να καλέσετε την <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> σε ένα συγκεκριμένο υποκατάλογο του <span class=filename>/usr/doc</span>, π.χ.:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc/en_US.ISO8859-1</span>
<span class=c># make update install clean</span></code></pre></div></div><div class=paragraph><p>Μπορείτε να καθορίσετε τη μορφή της τεκμηρίωσης που θα εγκατασταθεί, ρυθμίζοντας τη μεταβλητή <code>FORMATS</code> του make, π.χ.:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make FORMATS=&#39;html html-split&#39; install clean</span></code></pre></div></div></div><div class=sect3><h4 id=doc-ports>44.4.6. Χρησιμοποιώντας τα Ports της Τεκμηρίωσης<a class=anchor href=#doc-ports></a></h4><div class=paragraph><p>Στην προηγούμενη ενότητα, παρουσιάσαμε μια μέθοδο για την ενημέρωση της τεκμηρίωσης του FreeBSD μέσω του πηγαίου κώδικα. Ωστόσο, οι ενημερώσεις που βασίζονται στον πηγαίο κώδικα μπορεί να μην είναι δυνατές ή πρακτικές για κάθε σύστημα FreeBSD. Η διαδικασία μεταγλώττισης του πηγαίου κώδικα της τεκμηρίωσης απαιτεί σχετικά μεγάλο αριθμό εργαλείων και βοηθητικών προγραμμάτων, γνωστά ως <em>εργαλεία τεκμηρίωσης</em>. Απαιτεί επίσης και μια σχετική εξοικείωση με το CVS και τη διαδικασία ανάκτησης των αρχείων από αυτό, καθώς και μια σειρά από βήματα για τη μεταγλώττιση του κώδικα. Στην ενότητα αυτή περιγράφουμε ένα εναλλακτικό τρόπο ενημέρωσης της τεκμηρίωσης που εγκαθίσταται μαζί με το FreeBSD. Η μέθοδος αυτή χρησιμοποιεί την Συλλογή των Ports και δίνει τις παρακάτω δυνατότητες:</p></div><div class=ulist><ul><li><p>Κατέβασμα και εγκατάσταση προ-μεταγλωττισμένων στιγμιότυπων της τεκμηρίωσης, χωρίς να απαιτείται καμιά τοπική μεταγλώττιση (εξαλείφοντας έτσι και την ανάγκη εγκατάστασης όλων των εργαλείων τεκμηρίωσης).</p></li><li><p>Κατέβασμα του πηγαίου κώδικα της τεκμηρίωσης και μεταγλώττιση του μέσω των δυνατοτήτων που παρέχουν τα εργαλεία των ports (απλοποιώντας με αυτό τον τρόπο τη χειροκίνητη διαδικασία ανάκτησης και μεταγλώττισης).</p></li></ul></div><div class=paragraph><p>Αυτές οι δύο μέθοδοι ενημέρωσης της τεκμηρίωσης του FreeBSD υποστηρίζονται από μια σειρά από <em>ports τεκμηρίωσης</em> τα οποία ενημερώνονται κάθε μήνα από την Ομάδα Αρχιτεκτονικής της Τεκμηρίωσης &lt;<a href=mailto:doceng@FreeBSD.org>doceng@FreeBSD.org</a>>. Στη Συλλογή των Ports, θα τα βρείτε κάτω από την κατηγορία <a href=http://www.freshports.org/docs/>docs</a>.</p></div><div class=sect4><h5 id=doc-ports-install-make>44.4.6.1. Μεταγλώττιση και Εγκατάσταση των Ports της Τεκμηρίωσης<a class=anchor href=#doc-ports-install-make></a></h5><div class=paragraph><p>Τα ports της τεκμηρίωσης χρησιμοποιούν τις δυνατότητες μεταγλώττισης που παρέχει το σύστημα των ports ώστε να διευκολύνουν τη διαδικασία δημιουργίας της τεκμηρίωσης. Με αυτό τον τρόπο η ανάκτηση του πηγαίου κώδικα της τεκμηρίωσης γίνεται αυτόματα με την εκτέλεση της <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> και τις κατάλληλες ρυθμίσεις στο περιβάλλον. Η εγκατάσταση και απεγκατάσταση της τεκμηρίωσης είναι το ίδιο εύκολη με την εγκατάσταση οποιουδήποτε άλλου port ή πακέτου στο FreeBSD.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σε περίπτωση τοπικής μεταγλώττισης των ports της τεκμηρίωσης, απαιτείται και η εγκατάσταση των <em>εργαλείων τεκμηρίωσης</em>. Τα εργαλεία αυτά ωστόσο θα εγκατασταθούν αυτόματα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η οργάνωση των ports τεκμηρίωσης φαίνεται παρακάτω:</p></div><div class=ulist><ul><li><p>Υπάρχει ένα κεντρικό "master port", το <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-en/>misc/freebsd-doc-en</a> το οποίο διαθέτει τα απαραίτητα αρχεία και αποτελεί την βάση όλων των άλλων ports τεκμηρίωσης. Από προεπιλογή, το port αυτό μεταγλωττίζει μόνο την Αγγλική τεκμηρίωση.</p></li><li><p>Υπάρχει ένα port "όλα σε ένα", το <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-all/>misc/freebsd-doc-all</a> το οποίο μεταγλωττίζει και εγκαθιστά όλη την τεκμηρίωση σε όλες τις διαθέσιμες γλώσσες.</p></li><li><p>Τέλος, υπάρχει ένα "εξαρτώμενο port" για κάθε μετάφραση, π.χ.: <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-el/>misc/freebsd-doc-el</a> για την Ελληνική τεκμηρίωση. Όλα αυτά τα ports εξαρτώνται από το master port και εγκαθιστούν την τεκμηρίωση που έχει μεταφραστεί στην αντίστοιχη γλώσσα.</p></li></ul></div><div class=paragraph><p>Για να εγκαταστήσετε ένα port τεκμηρίωσης από τον πηγαίο κώδικα, εκτελέστε τις παρακάτω εντολές (ως <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-en</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Το παραπάνω θα μεταγλωττίσει και θα εγκαταστήσει την Αγγλική τεκμηρίωση σε μορφή τμηματικών HTML κειμένων (όπως χρησιμοποιούνται και στο <a href=http://www.FreeBSD.org>http://www.FreeBSD.org</a>), στον κατάλογο <span class=filename>/usr/local/shared/doc/freebsd</span>.</p></div><div class=sect5><h6 id=doc-ports-options>44.4.6.1.1. Συνηθισμένες Επιλογές και Παράμετροι Μεταγλώττισης<a class=anchor href=#doc-ports-options></a></h6><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε αρκετές επιλογές για την τροποποίηση της προεπιλεγμένης συμπεριφοράς των ports τεκμηρίωσης. Παρακάτω δείχνουμε μερικές μόνο από αυτές:</p></div><div class=dlist><dl><dt class=hdlist1><code>WITH_HTML</code></dt><dd><p>Επιτρέπει τη δημιουργία της τεκμηρίωσης σε μορφή HTML. Θα δημιουργηθεί ένα αρχείο HTML για κάθε κείμενο. Η μορφοποιημένη τεκμηρίωση θα αποθηκευθεί, ανάλογα με την περίπτωση, σε ένα αρχείο με όνομα <span class=filename>article.html</span> ή <span class=filename>book.html</span>. Θα γίνει επίσης και αποθήκευση των αντίστοιχων εικόνων.</p></dd><dt class=hdlist1><code>WITH_PDF</code></dt><dd><p>Επιτρέπει τη δημιουργία εγγράφου σε μορφή Adobe® Portable Document Format (PDF) για χρήση με τον Adobe® Acrobat Reader®, το Ghostscript, ή άλλα προγράμματα προβολής εγγράφων PDF. Η μορφοποιημένη τεκμηρίωση θα αποθηκευθεί, ανάλογα με την περίπτωση, σε ένα αρχείο <span class=filename>article.pdf</span> ή <span class=filename>book.pdf</span>.</p></dd><dt class=hdlist1><code>DOCBASE</code></dt><dd><p>Πρόκειται για την θέση στην οποία θα εγκατασταθεί η τεκμηρίωση. Από προεπιλογή, είναι ο κατάλογος <span class=filename>/usr/local/shared/doc/freebsd</span>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Παρατηρήστε ότι ο προεπιλεγμένος κατάλογος διαφέρει από αυτόν που χρησιμοποιείται στη μέθοδο CVSup. Αυτό συμβαίνει επειδή γίνεται εγκατάσταση port, τα οποία από προεπιλογή χρησιμοποιούν τον κατάλογο <span class=filename>/usr/local</span>. Μπορείτε να παρακάμψετε αυτή την προεπιλογή, αλλάζοντας την τιμή της μεταβλητής <code>PREFIX</code>.</p></div></td></tr></tbody></table></div></dd></dl></div><div class=paragraph><p>Παρακάτω θα βρείτε ένα σύντομο παράδειγμα σχετικό με τη χρήση των μεταβλητών για την εγκατάσταση της Αγγλικής τεκμηρίωσης σε μορφή PDF:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-en</span>
<span class=c># make -DWITH_PDF DOCBASE=share/doc/freebsd/en install clean</span></code></pre></div></div></div></div><div class=sect4><h5 id=doc-ports-install-package>44.4.6.2. Χρήση Έτοιμων Πακέτων Τεκμηρίωσης<a class=anchor href=#doc-ports-install-package></a></h5><div class=paragraph><p>Η μεταγλώττιση των ports τεκμηρίωσης από τον πηγαίο κώδικα (όπως είδαμε στην προηγούμενη ενότητα), απαιτεί τοπική εγκατάσταση των αντίστοιχων εργαλείων τεκμηρίωσης και επάρκεια χώρου στο δίσκο για την διαδικασία. Όταν δεν διατίθενται οι απαραίτητοι πόροι για την εγκατάσταση των εργαλείων τεκμηρίωσης (ή επειδή η μεταγλώττιση από τα ports θα χρησιμοποιούσε πολύ χώρο), η εγκατάσταση μπορεί να γίνει μέσω έτοιμων πακέτων τεκμηρίωσης.</p></div><div class=paragraph><p>H Ομάδα Αρχιτεκτονικής της Τεκμηρίωσης &lt;<a href=mailto:doceng@FreeBSD.org>doceng@FreeBSD.org</a>> προετοιμάζει μηνιαία στιγμιότυπα πακέτων τεκμηρίωσης του FreeBSD. Τα έτοιμα αυτά πακέτα μπορούν να χρησιμοποιηθούν με την βοήθεια οποιουδήποτε εργαλείου διαχείρισης πακέτων που διατίθεται με το FreeBSD, όπως για παράδειγμα τα <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a> κ.λ.π.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όταν χρησιμοποιείτε έτοιμα πακέτα, η εγκατάσταση της τεκμηρίωσης της επιλεγμένης γλώσσας θα γίνεται σε όλες τις διαθέσιμες μορφές.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για παράδειγμα, η παρακάτω εντολή θα εγκαταστήσει την τελευταία έκδοση του έτοιμου πακέτου της Ελληνικής τεκμηρίωσης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r el-freebsd-doc</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Τα πακέτα χρησιμοποιούν τη μορφή <code>lang-freebsd-doc</code> στο όνομα τους, η οποία διαφέρει από την αντίστοιχη μορφή του port. Το <em>lang</em> είναι η σύντομη μορφή της γλώσσας, π.χ. <code>el</code> για Ελληνικά ή <code>zh_cn</code> για Απλοποιημένα Κινέζικα.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=doc-ports-update>44.4.6.3. Ενημερώνοντας τα Ports της Τεκμηρίωσης<a class=anchor href=#doc-ports-update></a></h5><div class=paragraph><p>Για να ενημερώσετε ένα ήδη εγκατεστημένο port τεκμηρίωσης, μπορείτε να χρησιμοποιήσετε οποιοδήποτε εργαλείο αναβάθμισης ports. Για παράδειγμα, η παρακάτω εντολή ενημερώνει την εγκατεστημένη Ελληνική τεκμηρίωση μέσω του εργαλείου <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> με τη χρήση μόνο έτοιμων πακέτων:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PP el-freebsd-doc</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=current-stable>44.5. Παρακολούθηση Ενός Κλάδου Ανάπτυξης<a class=anchor href=#current-stable></a></h3><div class=paragraph><p>Υπάρχουν δύο κλάδοι ανάπτυξης στο FreeBSD, το FreeBSD-CURRENT και το FreeBSD-STABLE. Στην ενότητα αυτή, θα εξηγήσουμε κάποια πράγματα σχετικά με αυτούς τους κλάδους, και θα περιγράψουμε πως μπορείτε να διατηρήσετε το σύστημα σας ενημερωμένο σε κάποιον από αυτούς. Θα μιλήσουμε αρχικά για το FreeBSD-CURRENT και έπειτα για το FreeBSD-STABLE.</p></div><div class=sect3><h4 id=current>44.5.1. Παρακολουθώντας το FreeBSD-CURRENT<a class=anchor href=#current></a></h4><div class=paragraph><p>Καθώς διαβάζετε αυτό το κείμενο, να έχετε υπόψιν σας ότι το FreeBSD-CURRENT είναι πράγματι η "κόψη του ξυραφιού" στην ανάπτυξη του FreeBSD. Οι χρήστες του FreeBSD-CURRENT αναμένεται να έχουν αυξημένες τεχνικές γνώσεις, και να είναι ικανοί να επιλύουν δύσκολα προβλήματα του συστήματος τους, χωρίς βοήθεια. Αν είστε καινούριος στο FreeBSD, μάλλον θα πρέπει να το ξανασκεφτείτε πριν το εγκαταστήσετε.</p></div><div class=sect4><h5 id=_τι_είναι_το_freebsd_current>44.5.1.1. Τι Είναι το FreeBSD-CURRENT;<a class=anchor href=#_τι_είναι_το_freebsd_current></a></h5><div class=paragraph><p>Το FreeBSD-CURRENT αποτελείται από τον πλέον πρόσφατο λειτουργικό πηγαίο κώδικα του FreeBSD. Περιλαμβάνει αλλαγές που βρίσκονται σε εξέλιξη, πειραματικές αλλαγές, και μηχανισμούς μετάβασης οι οποίοι δεν είναι σίγουρο ότι θα περιλαμβάνονται στην επόμενη επίσημη έκδοση του λογισμικού. Αν και πολλά μέλη της ομάδας ανάπτυξης του FreeBSD μεταγλωττίζουν καθημερινά τον πηγαίο κώδικα του FreeBSD-CURRENT, υπάρχουν χρονικές περίοδοι που η μεταγλώττιση του είναι αδύνατη. Τα προβλήματα αυτά γενικά επιλύονται όσο πιο γρήγορα γίνεται, αλλά το αν το FreeBSD-CURRENT θα σας φέρει την καταστροφή ή κάποιο πολυπόθητο χαρακτηριστικό, είναι περισσότερο θέμα της χρονικής στιγμής που θα επιλέξετε να ανακτήσετε τον πηγαίο κώδικα!</p></div></div><div class=sect4><h5 id=_ποιος_χρειάζεται_το_freebsd_current>44.5.1.2. Ποιος Χρειάζεται το FreeBSD-CURRENT;<a class=anchor href=#_ποιος_χρειάζεται_το_freebsd_current></a></h5><div class=paragraph><p>Το FreeBSD-CURRENT διατίθεται και ενδιαφέρει κυρίως τις παρακάτω τρεις ομάδες:</p></div><div class="olist arabic"><ol class=arabic><li><p>Μέλη της κοινότητας του FreeBSD που δουλεύουν ενεργά σε κάποιο τμήμα του πηγαίου κώδικα, και για τους οποίους η παρακολούθηση του FreeBSD-CURRENT είναι απόλυτα απαραίτητη.</p></li><li><p>Μέλη της κοινότητας του FreeBSD που είναι ενεργοί testers και είναι πρόθυμοι να αναλώσουν το χρόνο τους για να λύσουν προβλήματα, ώστε να εξασφαλίσουν ότι το FreeBSD-CURRENT θα παραμείνει όσο το δυνατόν πιο σωστό. Συνήθως, τα μέλη αυτά κάνουν προτάσεις για τοπικές αλλαγές και για την γενική κατεύθυνση του FreeBSD, και στέλνουν patches για την πραγματοποίηση τους.</p></li><li><p>Αυτοί που απλώς θέλουν να βλέπουν τις τελευταίες ενημερώσεις, ή να χρησιμοποιούν τον τελευταίο πηγαίο κώδικα ως αναφορά (π.χ. για <em>μελέτη</em> και όχι για εκτέλεση). Μέλη αυτής της ομάδας μπορεί επίσης περιστασιακά να συνεισφέρουν σχόλια ή κώδικα.</p></li></ol></div></div><div class=sect4><h5 id=_τι_δεν_είναι_το_freebsd_current>44.5.1.3. Τι <em>Δεν</em> Είναι το FreeBSD-CURRENT;<a class=anchor href=#_τι_δεν_είναι_το_freebsd_current></a></h5><div class="olist arabic"><ol class=arabic><li><p>Δεν είναι ένας γρήγορος τρόπος να πάρετε κώδικα ο οποίος δεν έχει κυκλοφορήσει ακόμα σε κάποια έκδοση, με την ελπίδα ότι περιέχει κάποια νέα εκπληκτική δυνατότητα και θέλετε να είστε ο πρώτος που τη χρησιμοποιεί. Αν είστε πράγματι ο πρώτος που την χρησιμοποιεί, θα είστε επίσης και ο πρώτος που θα συναντήσετε τα νέα προβλήματα και bugs.</p></li><li><p>Δεν είναι ένας γρήγορος τρόπος για να ανακτήσετε διορθώσεις προβλημάτων. Κάθε νέα έκδοση του FreeBSD-CURRENT μπορεί να εισάγει τόσα νέα bugs όσα και αυτά που διορθώνει.</p></li><li><p>Το FreeBSD-CURRENT δεν αποτελεί "επίσημα υποστηριζόμενο" κώδικα. Αν και καταβάλλουμε κάθε δυνατή προσπάθεια να βοηθήσουμε όσους ανήκουν "πραγματικά" σε κάποια από τις τρεις ομάδες που αναφέραμε, ωστόσο <em>δεν έχουμε το χρόνο</em> να παρέχουμε τεχνική υποστήριξη. Αυτό δεν συμβαίνει επειδή είμαστε κακοήθεις και δύσκολοι και δεν θέλουμε να βοηθάμε τους ανθρώπους (δεν θα είχαμε καν δημιουργήσει το FreeBSD αν σκεφτόμασταν έτσι). Πολύ απλά, δεν μπορούμε να απαντάμε εκατοντάδες μηνύματα την ημέρα και <em>ταυτόχρονα</em> να δουλεύουμε στο FreeBSD! Αν δώσετε σε οποιοδήποτε μέλος της ομάδας ανάπτυξης την επιλογή να απαντάει σε πολλές ερωτήσεις σχετικά με πειραματικό κώδικα ή να δουλεύει για τη βελτίωση του FreeBSD, θα επιλέξει σίγουρα το δεύτερο.</p></li></ol></div></div><div class=sect4><h5 id=_χρησιμοποιώντας_το_freebsd_current>44.5.1.4. Χρησιμοποιώντας το FreeBSD-CURRENT<a class=anchor href=#_χρησιμοποιώντας_το_freebsd_current></a></h5><div class="olist arabic"><ol class=arabic><li><p>Γραφτείτε στις λίστες <a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a> και <a href=https://lists.FreeBSD.org/subscription/svn-src-head>ηλεκτρονική λίστα μηνυμάτων SVN commit πηγαίου κώδικα για τον κλάδο head/-current</a>. Δεν είναι απλώς καλή ιδέα, είναι <em>βασικό</em> να το κάνετε. Αν δεν είστε γραμμένος στη λίστα <em><a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a></em>, δεν θα βλέπετε τα σχόλια σχετικά με την τρέχουσα κατάσταση του συστήματος από όσους το χρησιμοποιούν, και έτσι πιθανώς θα καταλήξετε να αντιμετωπίζετε πολλά προβλήματα που άλλοι έχουν ήδη ανακαλύψει και λύσει. Ακόμα πιο σημαντικό είναι ότι θα χάνετε σημαντικές ανακοινώσεις, οι οποίες μπορεί να είναι κρίσιμες για την διατήρηση του συστήματος σας σε υγιή κατάσταση.</p><div class=paragraph><p>Η λίστα <a href=https://lists.FreeBSD.org/subscription/svn-src-head>ηλεκτρονική λίστα μηνυμάτων SVN commit πηγαίου κώδικα για τον κλάδο head/-current</a> θα σας επιτρέψει να βλέπετε τις καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται, καθώς και πληροφορίες για πιθανές παρενέργειες που μπορεί να έχει.</p></div><div class=paragraph><p>Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> και επιλέξτε τη λίστα στην οποία θέλετε να γίνετε συνδρομητής. Οδηγίες για την υπόλοιπη διαδικασία θα βρείτε επιτόπου. Αν σας ενδιαφέρει να παρακολουθείτε τις αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να εγγραφείτε στη λίστα <a href=https://lists.FreeBSD.org/subscription/svn-src-all>ηλεκτρονική λίστα μηνυμάτων SVN commit πηγαίου κώδικα του FreeBSD (εξαιρούνται τα δέντρα "user" και "projects")</a>.</p></div></li><li><p>Ανακτήστε τον πηγαίο κώδικα από ένα <a href=./#mirrors>mirror site</a> του FreeBSD. Αυτό μπορεί να γίνει με δύο τρόπους:</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Χρησιμοποιήστε το πρόγραμμα <a href=./#cvsup>cvsup</a> σε συνδυασμό με το <span class=filename>supfile</span> με την ονομασία <span class=filename>standard-supfile</span> το οποίο θα βρείτε στον κατάλογο <span class=filename>/usr/shared/examples/cvsup</span>. Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές. Πολλοί χρήστες εκτελούν το <code>cvsup</code> μέσω του <code>cron</code> ώστε να κρατάνε τον πηγαίο κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα. Θα πρέπει να προσαρμόσετε το υπόδειγμα του <span class=filename>supfile</span> που δίνουμε παραπάνω, και να ρυθμίσετε το <a href=./#cvsup>cvsup</a> για το περιβάλλον σας.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το υπόδειγμα του αρχείου <span class=filename>standard-supfile</span> προορίζεται για χρήση με κάποιο συγκεκριμένο κλάδο ασφάλειας (security branch) του FreeBSD, και όχι με το FreeBSD-CURRENT. Θα πρέπει να επεξεργαστείτε το αρχείο και να αντικαταστήσετε την παρακάτω γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>*default release=cvs tag=RELENG_X_Y</pre></div></div><div class=paragraph><p>με την ακόλουθη:</p></div><div class="literalblock programlisting"><div class=content><pre>*default release=cvs tag=.</pre></div></div><div class=paragraph><p>Για περισσότερες πληροφορίες σχετικά με τα tags που μπορείτε να χρησιμοποιήσετε, παρακαλούμε διαβάστε στο Εγχειρίδιο την ενότητα <a href=./#cvs-tags>Ετικέτες (Tags) για το CVS</a>.</p></div></td></tr></tbody></table></div></li><li><p>Χρησιμοποιήστε την υπηρεσία CTM. Αν έχετε πολύ κακή συνδεσιμότητα (υψηλό κόστος σύνδεσης ή πρόσβαση μόνο μέσω email) το CTM αποτελεί για σας μια εναλλακτική λύση. Μπορεί ωστόσο να σας δημιουργήσει διάφορα προβλήματα και να καταλήξετε με χαλασμένα αρχεία. Για το λόγο αυτό, το CTM χρησιμοποιείται σπάνια, κάτι το οποίο αυξάνει ακόμα περισσότερο την πιθανότητα να μη δουλεύει σωστά για μεγάλα χρονικά διαστήματα. Σας συνιστούμε να χρησιμοποιήσετε το CVSup αν διαθέτετε modem 9600 bps ή ταχύτερο.</p></li></ol></div></li><li><p>Αν σκοπεύετε να ανακτήσετε τον πηγαίο κώδικα για κανονική χρήση (εκτέλεση) και όχι απλώς για να τον δείτε, τότε ανακτήστε <em>ολόκληρο</em> το FreeBSD-CURRENT και όχι κάποια επιλεγμένα τμήματα. Σε διαφορετική περίπτωση, είναι αρκετά πιθανό να συναντήσετε προβλήματα, καθώς πολλά κομμάτια του κώδικα εξαρτώνται από ανανεώσεις σε άλλα, και δεν μπορούν να μεταγλωττιστούν αυτόνομα.</p><div class=paragraph><p>Πριν μεταγλωττίσετε το FreeBSD-CURRENT, διαβάστε προσεκτικά το <span class=filename>Makefile</span> στον κατάλογο <span class=filename>/usr/src</span>. Θα πρέπει να <a href=#makeworld>μεταγλωττίσετε τον πυρήνα και όλο το βασικό σύστημα (world)</a> την πρώτη φορά, ως μέρος της διαδικασίας αναβάθμισης. Διαβάζοντας την <a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a> και το <span class=filename>/usr/src/UPDATING</span> θα είστε ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο σας σύστημα. Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο πλησιάζουμε σε μια νέα επίσημη έκδοση.</p></div></li><li><p>Γίνετε ενεργό μέλος! Αν χρησιμοποιείτε το FreeBSD-CURRENT, θέλουμε να ξέρουμε τη γνώμη σας για αυτό, ειδικά αν έχετε προτάσεις για βελτιώσεις ή διορθώσεις λαθών. Προτάσεις που συνοδεύονται και από κώδικα γίνονται δεκτές με ενθουσιασμό!</p></li></ol></div></div></div><div class=sect3><h4 id=stable>44.5.2. Χρησιμοποιώντας το FreeBSD-STABLE<a class=anchor href=#stable></a></h4><div class=sect4><h5 id=_τι_είναι_το_freebsd_stable>44.5.2.1. Τι Είναι το FreeBSD-STABLE;<a class=anchor href=#_τι_είναι_το_freebsd_stable></a></h5><div class=paragraph><p>Το FreeBSD-STABLE είναι ένας κλάδος ανάπτυξης από τον οποίο προκύπτουν οι "μεγάλες" (major) εκδόσεις. Οι αλλαγές εισάγονται σε αυτό τον κλάδο με διαφορετικό ρυθμό, και με τη γενική παραδοχή ότι έχουν πρώτα περάσει από το FreeBSD-CURRENT για δοκιμή. Ωστόσο, <em>δεν παύει</em> να είναι ένας κλάδος ανάπτυξης, και αυτό σημαίνει ότι ο κώδικας του FreeBSD-STABLE μπορεί μια δεδομένη χρονική στιγμή να είναι ακατάλληλος για συγκεκριμένες εφαρμογές. Πρόκειται για μια ακόμα γραμμή ανάπτυξης για τους προγραμματιστές, και δεν είναι απαραίτητα κατάλληλη για τους τελικούς χρήστες.</p></div></div><div class=sect4><h5 id=_ποιος_χρειάζεται_το_freebsd_stable>44.5.2.2. Ποιος Χρειάζεται το FreeBSD-STABLE;<a class=anchor href=#_ποιος_χρειάζεται_το_freebsd_stable></a></h5><div class=paragraph><p>Αν σας ενδιαφέρει να παρακολουθείτε ή να συμβάλλετε στην ανάπτυξη του FreeBSD, και ειδικά όσο αφορά την επόμενη επίσημη έκδοση του από τον ίδιο κλάδο (point release), είναι καλή ιδέα να παρακολουθείτε το FreeBSD-STABLE.</p></div><div class=paragraph><p>Αν και είναι αλήθεια ότι οι διορθώσεις ασφάλειας γίνονται και στον κλάδο FreeBSD-STABLE, ωστόσο <em>δεν χρειάζεται</em> να παρακολουθείτε το FreeBSD-STABLE μόνο για αυτό το λόγο. Κάθε αναφορά προβλήματος ασφάλειας του FreeBSD εξηγεί πως να διορθώσετε το πρόβλημα για κάθε επίσημη έκδοση η οποία επηρεάζεται από αυτό , και η παρακολούθηση ενός κλάδου ανάπτυξης μόνο για λόγους ασφαλείας, πιθανόν να φέρει επίσης και άλλες ανεπιθύμητες αλλαγές μαζί της.</p></div><div class=paragraph><p>Αν και καταβάλλουμε κάθε δυνατή προσπάθεια ώστε να εξασφαλίσουμε ότι ο κλάδος FreeBSD-STABLE μπορεί να μεταγλωττιστεί και να εκτελεστεί σε κάθε δεδομένη χρονική στιγμή, δεν μπορούμε ωστόσο να το εγγυηθούμε. Επιπρόσθετα, αν και ο κώδικας αναπτύσσεται στο FreeBSD-CURRENT πριν περάσει στο FreeBSD-STABLE, ο κόσμος που εκτελεί το FreeBSD-STABLE είναι περισσότερος, και έτσι είναι αναπόφευκτο να ανακαλύπτονται πιο πολλά σφάλματα και ακραίες περιπτώσεις στο FreeBSD-STABLE τα οποία δεν έχουν γίνει εμφανή στο FreeBSD-CURRENT.</p></div><div class=paragraph><p>Για τους λόγους αυτούς, <em>δεν</em> συνιστούμε να παρακολουθείτε τυφλά το FreeBSD-STABLE, και ειδικότερα είναι σημαντικό να μην αναβαθμίζετε σε αυτό εξυπηρετητές σε περιβάλλοντα παραγωγής, χωρίς να έχετε πρώτα ελέγξει αναλυτικά τον κώδικα στο δικό σας περιβάλλον ανάπτυξης.</p></div><div class=paragraph><p>Αν δεν διαθέτετε τους πόρους για να το κάνετε αυτό, σας συνιστούμε να χρησιμοποιείτε την τελευταία επίσημη έκδοση του FreeBSD, και να αναβαθμίζεστε από τη μια έκδοση στην επόμενη μέσω του μηχανισμού δυαδικών ενημερώσεων.</p></div></div><div class=sect4><h5 id=_χρησιμοποιώντας_το_freebsd_stable>44.5.2.3. Χρησιμοποιώντας το FreeBSD-STABLE<a class=anchor href=#_χρησιμοποιώντας_το_freebsd_stable></a></h5><div class="olist arabic"><ol class=arabic><li><p>Γραφτείτε συνδρομητής στη λίστα <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>ηλεκτρονική λίστα του FreeBSD-STABLE;</a>. Θα είστε έτσι ενημερωμένοι για εξαρτήσεις μεταγλώττισης που ίσως εμφανιστούν στο FreeBSD-STABLE, ή για άλλα προβλήματα που χρήζουν ειδικής προσοχής. Στη λίστα αυτή θα βρίσκετε επίσης ανακοινώσεις από μέλη της ομάδας ανάπτυξης, όταν πρόκειται να συμπεριληφθεί κάποια αμφιλεγόμενη ανανέωση ή διόρθωση, δίνοντας έτσι στους χρήστες την ευκαιρία να εκφέρουν γνώμη σχετικά με τα προβλήματα που θα προκαλέσει η προτεινόμενη αλλαγή.</p><div class=paragraph><p>Θα πρέπει να εγγραφείτε στην κατάλληλη λίστα SVN ανάλογα με τον κλάδο που παρακολουθείτε. Για παράδειγμα, αν παρακολουθείτε τον κλάδο 7-STABLE, η κατάλληλη λίστα είναι η <a href=https://lists.FreeBSD.org/subscription/svn-src-stable-7>svn-src-stable-7</a>. Αυτό θα σας επιτρέψει να βλέπετε τις καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται, καθώς και πληροφορίες για πιθανές παρενέργειες που μπορεί να έχει.</p></div><div class=paragraph><p>Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> και επιλέξτε τη λίστα στην οποία θέλετε να γίνετε συνδρομητής. Οδηγίες για την υπόλοιπη διαδικασία θα βρείτε επιτόπου. Αν σας ενδιαφέρει να παρακολουθείτε τις αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να εγγραφείτε στη λίστα <a href=https://lists.FreeBSD.org/subscription/svn-src-all>ηλεκτρονική λίστα μηνυμάτων SVN commit πηγαίου κώδικα του FreeBSD (εξαιρούνται τα δέντρα "user" και "projects")</a>.</p></div></li><li><p>Αν πρόκειται να εγκαταστήσετε ένα νέο σύστημα με σκοπό να εκτελείτε τα μηνιαία snapshot του FreeBSD-STABLE, παρακαλούμε να ελέγξετε την τοποθεσία <a href=https://www.FreeBSD.org/snapshots/>Snapshots</a> για περισσότερες πληροφορίες. Εναλλακτικά, είναι δυνατόν να εγκαταστήσετε το πιο πρόσφατο FreeBSD-STABLE από κάποιο <a href=./#mirrors>mirror site</a> ακολουθώντας τις παρακάτω οδηγίες ώστε να αναβαθμίσετε το σύστημα σας στην πλέον πρόσφατη έκδοση πηγαίου κώδικα του FreeBSD-STABLE.</p><div class=paragraph><p>Αν διαθέτετε ήδη κάποια προηγούμενη έκδοση του FreeBSD και επιθυμείτε να αναβαθμιστείτε μέσω του πηγαίου κώδικα, μπορείτε εύκολα να χρησιμοποιήσετε κάποιο <a href=./#mirrors>mirror site</a> του FreeBSD. Υπάρχουν δύο τρόποι για να γίνει αυτό:
.. Χρησιμοποιήστε το πρόγραμμα <a href=./#cvsup>cvsup</a> σε συνδυασμό με το <span class=filename>supfile</span> με την ονομασία <span class=filename>stable-supfile</span> το οποίο θα βρείτε στον κατάλογο <span class=filename>/usr/shared/examples/cvsup</span>. Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές. Πολλοί χρήστες εκτελούν το <code>cvsup</code> μέσω του <code>cron</code> ώστε να κρατάνε τον πηγαίο κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα. Θα πρέπει να προσαρμόσετε το υπόδειγμα του <span class=filename>supfile</span> που δίνουμε παραπάνω, και να ρυθμίσετε το <a href=./#cvsup>cvsup</a> για το περιβάλλον σας.
.. Χρησιμοποιήστε την υπηρεσία CTM. Αν δεν έχετε γρήγορη και φτηνή σύνδεση με το Internet, αυτή είναι η συνιστώμενη μέθοδος.</p></div></li><li><p>Ουσιαστικά, αν χρειάζεστε γρήγορη και κατά απαίτηση πρόσβαση στον πηγαίο κώδικα, και το εύρος ζώνης της σύνδεσης δεν αποτελεί πρόβλημα, χρησιμοποιήστε το <code>cvsup</code> ή το <code>ftp</code>. Διαφορετικά, χρησιμοποιήστε το CTM.</p></li><li><p>Πριν μεταγλωττίσετε το FreeBSD-STABLE, διαβάστε προσεκτικά το <span class=filename>Makefile</span> στον κατάλογο <span class=filename>/usr/src</span>. Θα πρέπει να <a href=#makeworld>μεταγλωττίσετε τον πυρήνα και όλο το βασικό σύστημα (world)</a> την πρώτη φορά, ως μέρος της διαδικασίας αναβάθμισης. Διαβάζοντας την <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>ηλεκτρονική λίστα του FreeBSD-STABLE;</a> και το <span class=filename>/usr/src/UPDATING</span> θα είστε ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο σας σύστημα. Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο πλησιάζουμε σε μια νέα επίσημη έκδοση.</p></li></ol></div></div></div></div><div class=sect2><h3 id=synching>44.6. Συγχρονίζοντας τον Πηγαίο σας Κώδικα<a class=anchor href=#synching></a></h3><div class=paragraph><p>Υπάρχουν διάφοροι τρόποι να χρησιμοποιήσετε μια σύνδεση Internet (ή email) για να ενημερώνετε οποιοδήποτε τμήμα πηγαίου κώδικα του FreeBSD Project σας ενδιαφέρει, ή και όλα αν το επιθυμείτε. Οι βασικές υπηρεσίες που προσφέρουμε είναι το <a href=./#anoncvs>Ανώνυμο CVS</a>, το <a href=./#cvsup>CVSup</a>, και το <a href=./#ctm>CTM</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Αν και είναι δυνατόν να ενημερώσετε μόνο κάποια τμήματα του δέντρου πηγαίου κώδικα, η μόνη διαδικασία ενημέρωσης που υποστηρίζεται αφορά την ενημέρωση ολόκληρου του δέντρου. Μετά την ενημέρωση, θα πρέπει να μεταγλωττίσετε ξανά τόσο το userland (δηλ. τα προγράμματα που εκτελούνται στην περιοχή χρήστη, όπως αυτά που βρίσκονται στους καταλόγους <span class=filename>/bin</span> και <span class=filename>/sbin</span>) όσο και τον πηγαίο κώδικα του πυρήνα. Αν ενημερώσετε μόνο ένα τμήμα του πηγαίου κώδικα, μόνο τον πυρήνα ή μόνο το userland, θα αντιμετωπίσετε προβλήματα. Τα προβλήματα αυτά μπορεί να κυμαίνονται από σφάλματα μεταγλώττισης μέχρι kernel panic και καταστροφή δεδομένων.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το Ανώνυμο CVS και το CVSup χρησιμοποιούν τη μέθοδο <em>pull</em> για την ενημέρωση του πηγαίου κώδικα. Στην περίπτωση του CVSup, ο χρήστης (η κάποιο script που εκτελείται μέσω <code>cron</code>) εκτελεί το πρόγραμμα <code>cvsup</code> το οποίο αλληλεπιδρά με ένα αντίστοιχο εξυπηρετητή <code>cvsupd</code> ώστε να ενημερώσει τα σχετικά αρχεία. Οι ενημερώσεις που λαμβάνετε είναι πάντοτε οι τελευταίες διαθέσιμες, και θα τις λάβετε μόνο όταν τις ζητήσετε. Μπορείτε εύκολα να περιορίσετε τις ενημερώσεις σε συγκεκριμένα αρχεία ή καταλόγους τα οποία σας ενδιαφέρουν. Οι ενημερώσεις δημιουργούνται δυναμικά από τον εξυπηρετητή, ανάλογα με το τι έχετε εγκατεστημένο και τι επιθυμείτε να λάβετε. Το Ανώνυμο CVS είναι κάπως πιο απλοϊκό από το CVSup, δεδομένου ότι είναι απλώς μια επέκταση του CVS που επιτρέπει την ανάκτηση αλλαγών απευθείας από κάποιο απομακρυσμένο CVS repository. Το CVSup είναι αρκετά πιο αποτελεσματικό σε αυτόν το τομέα, αλλά το Ανώνυμο CVS είναι απλούστερο στη χρήση.</p></div><div class=paragraph><p>Από την άλλη μεριά, το CTM δεν συγκρίνει άμεσα τον πηγαίο κώδικα που έχετε με αυτόν που υπάρχει στον κεντρικό εξυπηρετητή ώστε να ανακτήσει μόνο τις αλλαγές. Αντίθετα, στο κεντρικό μηχάνημα CTM, εκτελείται αρκετές φορές την ημέρα ένα script. Το script αυτό αναγνωρίζει τις αλλαγές στα αρχεία σε σχέση με την προηγούμενη εκτέλεση του, και έπειτα πακετάρει και συμπιέζει τις αλλαγές με τρόπο κατάλληλο για αποστολή μέσω email (μόνο εκτυπώσιμοι ASCII χαρακτήρες). Σε κάθε τέτοιο πακέτο αλλαγών αντιστοιχίζεται ένας μοναδιαίος αριθμός ακολουθίας (sequence number) που το αναγνωρίζει. Μετά τη λήψη τους, μπορείτε να δώσετε αυτά τα αρχεία διαφορών του CTM ("CTM deltas") στο βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=ctm_rmail&amp;sektion=1&amp;format=html">ctm_rmail(1)</a> το οποίο αυτόματα θα τα αποκωδικοποιήσει, θα τα επαληθεύσει, και θα εφαρμόσει τις αλλαγές στο αντίγραφο πηγαίου κώδικα του χρήστη. Η διαδικασία αυτή είναι πολύ πιο αποδοτική από το CVSup, και επιβαρύνει λιγότερο τους εξυπηρετητές μας, καθώς είναι μια διαδικασία τύπου <em>push</em> αντί για <em>pull</em>.</p></div><div class=paragraph><p>Υπάρχουν φυσικά κάποια σημεία που υστερεί. Αν από λάθος διαγράψετε κάποια τμήματα του πηγαίου σας κώδικα, το CVSup θα ανιχνεύσει και θα διορθώσει αυτόματα τη βλάβη για σας. Το CTM δεν θα το κάνει αυτό, και αν σβήσετε κάποιο τμήμα του δέντρου σας (και δεν έχετε αντίγραφο ασφαλείας) θα πρέπει να ξεκινήσετε από την αρχή (από το πιο πρόσφατο CVS "base delta") και να το ξανακτίσετε από την αρχή με το CTM. Με το Ανώνυμο CVS, μπορείτε απλώς να διαγράψετε τα προβληματικά αρχεία και να συγχρονίσετε ξανά τον πηγαίο σας κώδικα.</p></div></div><div class=sect2><h3 id=makeworld>44.7. Μεταγλωττίζοντας το Βασικό Σύστημα ("world")<a class=anchor href=#makeworld></a></h3><div class=paragraph><p>Έχοντας συγχρονίσει το τοπικό σας δέντρο πηγαίου κώδικα σε κάποια συγκεκριμένη έκδοση του FreeBSD (FreeBSD-STABLE, FreeBSD-CURRENT, κ.ο.κ.), μπορείτε έπειτα να το χρησιμοποιήσετε για να μεταγλωττίσετε το σύστημα σας από την αρχή.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Δημιουργήστε Ένα Αντίγραφο Ασφαλείας</div><div class=paragraph><p>Δεν μπορούμε παρά να τονίσουμε πόσο σημαντικό είναι να δημιουργήσετε ένα αντίγραφο ασφαλείας του συστήματος σας <em>πριν</em> ξεκινήσετε αυτή τη διαδικασία. Αν και η μεταγλώττιση του βασικού συστήματος είναι (όσο τουλάχιστον ακολουθείτε αυτές τις οδηγίες) μια σχετικά απλή διαδικασία, αναμφίβολα θα υπάρξουν και περιπτώσεις που λάθη δικά σας, ή άλλων (στο δέντρο πηγαίου κώδικα), θα σας οδηγήσουν σε ένα σύστημα που δεν θα μπορεί να εκκινήσει.</p></div><div class=paragraph><p>Βεβαιωθείτε ότι έχετε ενημερωμένο αντίγραφο ασφαλείας. Καλό θα είναι να έχετε επίσης πρόχειρη μια δισκέτα fixit ή ένα CD εκκίνησης. Ίσως να μην χρειαστεί ποτέ να τα χρησιμοποιήσετε, αλλά καλύτερα να είστε ασφαλής παρά να το μετανοιώνετε αργότερα!</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Γίνετε Συνδρομητής στη Σωστή Λίστα Ηλ. Ταχυδρομείου</div><div class=paragraph><p>Από τη φύση τους, οι κλάδοι FreeBSD-STABLE και FreeBSD-CURRENT βρίσκονται σε συνεχή <em>ανάπτυξη</em>. Όσοι συνεισφέρουν στο FreeBSD είναι απλώς άνθρωποι, και περιστασιακά λάθη απλώς συμβαίνουν.</p></div><div class=paragraph><p>Ορισμένες φορές τα λάθη αυτά είναι μάλλον ακίνδυνα, και το μόνο που κάνουν είναι να εμφανίζουν μερικές διαγνωστικές προειδοποιήσεις στο σύστημα σας. Ή μπορεί η αλλαγή να είναι καταστροφική, και να οδηγήσει το σύστημα σας σε αδυναμία εκκίνησης ή ακόμα και να καταστρέψει τα συστήματα αρχείων σας (ή και ακόμα χειρότερες συνέπειες).</p></div><div class=paragraph><p>Αν συμβούν τέτοια προβλήματα, σύντομα θα εμφανιστεί ένα μήνυμα τύπου "heads up" στις σχετικές λίστες ταχυδρομείου, το οποίο θα εξηγεί το πρόβλημα και ποια συστήματα επηρεάζει. Όταν το πρόβλημα λυθεί, θα γίνει μια αντίστοιχη "all clear" ανακοίνωση.</p></div><div class=paragraph><p>Αν προσπαθείτε να ακολουθήσετε το FreeBSD-STABLE ή το FreeBSD-CURRENT, και δεν διαβάζετε τις αντίστοιχες λίστες <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>ηλεκτρονική λίστα του FreeBSD-STABLE;</a> και <a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a>, ψάχνετε για μπελάδες.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Μην Χρησιμοποιήσετε την εντολή <code>make world</code></div><div class=paragraph><p>Μεγάλο μέρος της παλαιότερης τεκμηρίωσης, συνιστά τη χρήση της εντολής <code>make world</code>. Αν την χρησιμοποιήσετε, θα παραλειφθούν ορισμένα σημαντικά βήματα της διαδικασίας. Χρησιμοποιήστε τη μόνο αν είστε απόλυτα σίγουροι για αυτό που κάνετε. Για τις περισσότερες περιπτώσεις, η εντολή <code>make world</code> είναι λανθασμένη, και αντί για αυτή θα πρέπει να ακολουθήσετε τη διαδικασία που περιγράφουμε παρακάτω.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=canonical-build>44.7.1. Ο Κανονικός Τρόπος να Ενημερώσετε το Σύστημα σας<a class=anchor href=#canonical-build></a></h4><div class=paragraph><p>Πριν ενημερώσετε το σύστημα σας, θα πρέπει να ελέγξετε το <span class=filename>/usr/src/UPDATING</span> για τυχόν βήματα που θα πρέπει να εκτελέσετε πριν την εκκίνηση της μεταγλώττισης. Τα βήματα αυτά εξαρτώνται από την έκδοση του πηγαίου κώδικα που πρόκειται να χρησιμοποιήσετε. Έπειτα, ακολουθήστε τη διαδικασία που περιγράφεται στις επόμενες παραγράφους.</p></div><div class=paragraph><p>Η διαδικασία αναβάθμισης η οποία περιγράφεται εδώ βασίζεται στην υπόθεση ότι έχετε ήδη εγκαταστήσει μια παλιότερη έκδοση του FreeBSD, με μια παλιά έκδοση του μεταγλωττιστή, ένα παλιό πυρήνα, παλιά "εργαλεία χρήστη" και αρχεία ρυθμίσεων. Εργαλεία χρήστη θεωρούνται τα βασικά εκτελέσιμα, οι βιβλιοθήκες και τα αρχεία προγραμματισμού. Ο μεταγλωττιστής είναι κι αυτός μέρος των "εργαλείων χρήστη" στο FreeBSD, αλλά χρειάζεται ειδική μεταχείριση κατά τη διαδικασία αναβάθμισης.</p></div><div class=paragraph><p>Υποθέτουμε, επίσης, ότι έχετε ήδη κατεβάσει μια ενημερωμένη έκδοση από τον πηγαίο κώδικα του συστήματος. Αν ο πηγαίος κώδικας στο συγκεκριμένο σύστημα είναι από παλιότερη έκδοση, δείτε το <a href=#synching>Συγχρονίζοντας τον Πηγαίο σας Κώδικα</a> για λεπτομερείς οδηγίες σχετικά με το πως να συγχρονίσετε τον πηγαίο κώδικα σε μια νεότερη έκδοση.</p></div><div class=paragraph><p>Η αναβάθμιση του FreeBSD από τον πηγαίο κώδικά του φαίνεται να είναι πολύ απλή διαδικασία. Στην πραγματικότητα, έχει κάποιες ιδιαιτερότητες. Με τα χρόνια, καθώς οι εξαρτήσεις μεταξύ των βημάτων της αναβάθμισης ανακαλύπτονται ή αναλύονται καλύτερα, οι προγραμματιστές του FreeBSD αλλάζουν σιγά-σιγά αυτή τη διαδικασία. Οι παρακάτω παράγραφοι περιγράφουν τη λογική με την οποία έχει σχεδιασθεί η προτεινόμενη διαδικασία αναβάθμισης.</p></div><div class=paragraph><p>Μια επιτυχής διαδικασία αναβάθμισης πρέπει να καλύψει τουλάχιστον τις δύο πιο βασικές ιδιαιτερότητες μιας αναβάθμισης από πηγαίο κώδικα:</p></div><div class=ulist><ul><li><p>Ο παλιός μεταγλωττιστής συστήματος μπορεί να είναι ακατάλληλος για μεταγλώττιση του νέου πυρήνα. (Και οι μεταγλωττιστές έχουν ορισμένες φορές προβλήματα, όπως κάθε άλλο λογισμικό.) Οπότε ο νέος πυρήνας πρέπει να μεταγλωττιστεί με το νέο μεταγλωττιστή. Πιο συγκεκριμένα, ο νέος μεταγλωττιστής πρέπει να αναβαθμιστεί πριν από το νέο πυρήνα. Αυτό δε σημαίνει βέβαια ότι αυτός ο νέος μεταγλωττιστής πρέπει να <em>εγκατασταθεί</em> πριν μεταγλωττιστεί ο νέος πυρήνας.</p></li><li><p>Τα νέα εργαλεία χρήστη από το βασικό σύστημα του FreeBSD μπορεί να εξαρτώνται από τον τρόπο λειτουργίας του νέου πυρήνα. Οπότε ο νέος πυρήνας πρέπει να εγκατασταθεί πριν από το νέο βασικό σύστημα.</p></li></ul></div><div class=paragraph><p>Αυτά τα δύο σημεία είναι οι βασικοί λόγοι για τους οποίους προτείνονται τα κεντρικά βήματα μιας αναβάθμισης, τα βήματα <code>buildworld</code>, <code>buildkernel</code>, <code>installkernel</code>, και <code>installworld</code>. Στις επόμενες παραγράφους θα περιγράψουμε πιο αναλυτικά αυτά τα βήματα. Υπάρχουν κι άλλοι λόγοι όμως για τους οποίους χρειάζεται προσοχή όταν κάνετε μια τέτοια αναβάθμιση. Μερικοί από αυτούς είναι οι εξής:</p></div><div class=ulist><ul><li><p>Τα παλιά εργαλεία του βασικού συστήματος μπορεί να μην τρέχουν σωστά με το νέο πυρήνα. Γι αυτό πρέπει να εγκατασταθεί το ενημερωμένο βασικό σύστημα αμέσως μετά την εγκατάσταση του νέου πυρήνα.</p></li><li><p>Μερικές φορές χρειάζονται αλλαγές στα αρχεία ρυθμίσεων πριν εγκατασταθεί το νέο βασικό σύστημα. Άλλες φορές η εγκατάσταση όλων των αρχείων ρυθμίσεων μπορεί να δημιουργήσει προβλήματα στην εγκατάσταση. Γι αυτό έχουμε χωρίσει την ενημέρωση των αρχείων ρυθμίσεων σε δύο ξεχωριστά βήματα.</p></li><li><p>Στην πλειοψηφία των περιπτώσεων η διαδικασία εγκατάστασης αντικαθιστά ή προσθέτει αρχεία του συστήματος· δε σβήνει κανένα υπάρχον αρχείο. Σε μερικές περιπτώσεις αυτό μπορεί να δημιουργήσει προβλήματα. Όταν υπάρχει τέτοια περίπτωση, η διαδικασία εγκατάστασης τυπώνει ενημερωτικά μηνύματα για τα αρχεία τα οποία πρέπει να σβηστούν χειροκίνητα. Αυτό το βήμα μπορεί να αυτοματοποιηθεί στο μέλλον.</p></li></ul></div><div class=paragraph><p>Έχοντας όλες αυτές τις ιδιαιτερότητες μιας αναβάθμισης από πηγαίο κώδικα, καταλήξαμε στην παρακάτω διαδικασία αναβάθμισης. Ορισμένες φορές μπορεί να χρειάζεται να προσθέσετε κάποια βήματα σε αυτή τη διαδικασία. Τα βασικά βήματα όμως παραμένουν τα ίδια, κι είναι τα εξής:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>make buildworld</code></p><div class=paragraph><p>Αυτό το βήμα μεταγλωττίζει πρώτα μια ενημερωμένη έκδοση του ίδιου του μεταγλωττιστή συστήματος και μερικών απαραίτητων εργαλείων. Ύστερα, χρησιμοποιώντας το νέο μεταγλωττιστή, προετοιμάζει μια νέα έκδοση όλου του βασικού συστήματος του FreeBSD. Τα ενημερωμένα εκτελέσιμα, βιβλιοθήκες και αρχεία προγραμματισμού καταλήγουν στον κατάλογο <span class=filename>/usr/obj</span>.</p></div></li><li><p><code>make buildkernel</code></p><div class=paragraph><p>Σε αντίθεση με παλιότερες διαδικασίες αναβάθμισης (οι οποίες καλούσαν χειροκίνητα το <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> και το <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>) αυτό το βήμα μεταγλωττίζει τον πυρήνα του FreeBSD χρησιμοποιώντας τον ενημερωμένο μεταγλωττιστή συστήματος από τον κατάλογο <span class=filename>/usr/obj</span>. Αυτό σας προστατεύει από προβλήματα ασυμβατότητας μεταξύ του μεταγλωττιστή και του πυρήνα.</p></div></li><li><p><code>make installkernel</code></p><div class=paragraph><p>Εγκατάσταση του νέου πυρήνα και των αρθρωμάτων του στο δίσκο του συστήματος. Έτσι μπορεί πλέον το σύστημα να ξεκινήσει με το νέο, ενημερωμένο πυρήνα.</p></div></li><li><p>Εκκίνηση σε λειτουργία single user.</p><div class=paragraph><p>Η λειτουργία single user ελαχιστοποιεί την πιθανότητα να έχετε προβλήματα επειδή αναβαθμίσατε κάποιο πρόγραμμα που τρέχει ήδη. Είναι επίσης πιο ασφαλής, αφού δε χρειάζεται να τρέξετε τις εφαρμογές του παλιού βασικού συστήματος με το νέο πυρήνα.</p></div></li><li><p><code>mergemaster -p</code></p><div class=paragraph><p>Αυτό το βήμα ενημερώνει τα απολύτως βασικά αρχεία ρυθμίσεων του FreeBSD, για να μπορέσετε να εγκαταστήσετε σωστά το νέο βασικό σύστημα. Ενημερώνει, για παράδειγμα, τη βάση χρηστών και ομάδων χρηστών του FreeBSD. Κάθε φορά που προστίθεται ένας νέος χρήστης συστήματος ή μια νέα ομάδα χρηστών, το βήμα <code>installworld</code> της αναβάθμισης θεωρεί ότι έχετε ήδη ρυθμίσει τους νέους χρήστες ή τις νέες ομάδες. Αυτό ακριβώς κάνει σε αυτό το σημείο το εργαλείο <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>.</p></div></li><li><p><code>make installworld</code></p><div class=paragraph><p>Το επόμενο βήμα είναι να εγκαταστήσετε το ενημερωμένο βασικό σύστημα από τον κατάλογο <span class=filename>/usr/obj</span>. Μετά από αυτό έχετε πλέον ένα νέο πυρήνα και ένα ενημερωμένο βασικό σύστημα, το οποίο ταιριάζει με τον νέο πυρήνα.</p></div></li><li><p><code>mergemaster</code></p><div class=paragraph><p>Ένα από τα τελευταία βήματα είναι η αναβάθμιση των αρχείων ρυθμίσεων του συστήματος. Το εργαλείο <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> μπορεί να σας βοηθήσει σε αυτό το βήμα, αφού ενημερώνει τα αρχεία ρυθμίσεων κρατώντας και οποιεσδήποτε τοπικές αλλαγές έχετε κάνει στο σύστημά σας.</p></div></li><li><p>Επανεκκινήστε το σύστημα.</p><div class=paragraph><p>Μια τελευταία επανεκκίνηση του συστήματος σας εξασφαλίζει ότι το σύστημα ξεκινάει με το νέο πυρήνα, το ενημερωμένο βασικό σύστημα και τα καινούρια αρχεία ρυθμίσεων.</p></div></li></ol></div><div class=paragraph><p>Αν η αναβάθμιση που κάνετε είναι από μια έκδοση του FreeBSD σε μια πιο καινούρια έκδοση του ίδιου κλάδου ανάπτυξης, π.χ. από 7.0 σε 7.1, τότε μερικά από τα βήματα αυτή της διαδικασίας μπορεί να μη χρειάζονται αφού είναι λιγότερο πιθανό να συναντήσετε ασυμβατότητες μεταξύ του μεταγλωττιστή συστήματος, του πυρήνα, του βασικού συστήματος και των αρχείων ρυθμίσεων. Η αναβάθμιση σε τέτοιες περιπτώσεις, μεταξύ δύο minor εκδόσεων του FreeBSD, ίσως μπορεί να γίνει και με την παλιότερη διαδικασία: τρέχοντας <code>make world</code> και ύστερα μεταγλωττίζοντας και στήνοντας ένα νέο πυρήνα.</p></div><div class=paragraph><p>Όταν όμως αναβαθμίσετε το FreeBSD μεταξύ major εκδόσεων, καλύτερα να χρησιμοποιήσετε τη διαδικασία που περιγράφουμε εδώ. Αλλιώς μπορεί να αντιμετωπίσετε προβλήματα είτε κατά τη διάρκεια της αναβάθμισης ή αφού έχει πλέον ολοκληρωθεί.</p></div><div class=paragraph><p>Κάποιες από τις αναβαθμίσεις (π.χ. από μια έκδοση 4.<em>X</em> σε 5.0) μπορεί να απαιτούν μερικά χειροκίνητα βήματα (όπως το να μετακινήσετε ή να σβήσετε συγκεκριμένα αρχεία πριν το βήμα <code>installworld</code>). Πριν από κάθε αναβάθμιση διαβάστε προσεκτικά τις οδηγίες στο αρχείο <span class=filename>/usr/src/UPDATING</span>· ειδικά τις οδηγίες στο τέλος του αρχείου, οι οποίες περιγράφουν αναλυτικά την προτεινόμενη διαδικασία αναβάθμισης.</p></div><div class=paragraph><p>Αυτή η διαδικασία αναβάθμισης εξελίσσεται και διορθώνεται καθώς οι προγραμματιστές του FreeBSD ανακαλύπτουν καινούριες εξαρτήσεις μεταξύ των συστατικών του συστήματος ή κάνουν διορθώσεις για να αποφύγουν ασυμβατότητες μεταξύ των διαφορετικών υποσυστημάτων. Ελπίζουμε ότι τα κεντρικά βήματα της διαδικασίας που περιγράφεται εδώ δε θα αλλάξουν πολύ για αρκετό καιρό πλέον.</p></div><div class=paragraph><p>Ανακεφαλαιώνοντας όλα τα βήματα τα οποία περιγράψαμε παραπάνω, η προτεινόμενη διαδικασία αναβάθμισης του FreeBSD από τον πηγαίο κώδικα του συστήματος είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildworld</span>
<span class=c># make buildkernel</span>
<span class=c># make installkernel</span>
<span class=c># shutdown -r now</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Υπάρχουν κάποιες μάλλον σπάνιες περιπτώσεις, που απαιτείται μια επιπλέον εκτέλεση του <code>mergemaster -p</code> πριν το βήμα <code>buildworld</code>. Οι περιπτώσεις αυτές περιγράφονται στο <span class=filename>UPDATING</span>. Σε γενικές γραμμές πάντως, μπορείτε με ασφάλεια να παραλείψετε αυτό το βήμα, αν δεν αναβαθμίζετε το σύστημα σας μεταξύ πολλαπλών εκδόσεων του FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μετά την επιτυχή ολοκλήρωση του <code>installkernel</code>, θα πρέπει να επανεκκινήσετε σε κατάσταση ενός χρήστη (π.χ. χρησιμοποιώντας την εντολή <code>boot -s</code> στην προτροπή του φορτωτή εκκίνησης). Έπειτα εκτελέστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u /</span>
<span class=c># mount -a -t ufs</span>
<span class=c># adjkerntz -i</span>
<span class=c># mergemaster -p</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># mergemaster</span>
<span class=c># reboot</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Διαβάστε τις Επιπλέον Εξηγήσεις</div><div class=paragraph><p>Η διαδικασία που περιγράψαμε παραπάνω είναι μια απλή περίληψη για να σας βοηθήσει να ξεκινήσετε. Θα πρέπει ωστόσο να διαβάσετε τις παρακάτω ενότητες για να κατανοήσετε πλήρως κάθε βήμα, ειδικά αν θέλετε να χρησιμοποιήσετε δικό σας προσαρμοσμένο πυρήνα.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=src-updating>44.7.2. Διαβάστε το <span class=filename>/usr/src/UPDATING</span><a class=anchor href=#src-updating></a></h4><div class=paragraph><p>Πριν κάνετε οτιδήποτε άλλο, διαβάστε το <span class=filename>/usr/src/UPDATING</span> (ή το αντίστοιχο αρχείο, αν έχετε αποθηκεύσει τον πηγαίο κώδικα σε άλλο κατάλογο). Το αρχείο αυτό περιέχει σημαντικές πληροφορίες σχετικά με προβλήματα που μπορεί να συναντήσετε ή ίσως να καθορίζει τη σειρά με την οποία πρέπει να εκτελεστούν κάποιες εντολές. Αν το αρχείο <span class=filename>UPDATING</span> έρχεται σε σύγκρουση με κάτι που διαβάσατε εδώ, προτεραιότητα έχει το αρχείο <span class=filename>UPDATING</span>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Η ανάγνωση του αρχείου <span class=filename>UPDATING</span> δεν είναι αποδεκτό υποκατάστατο της συνδρομής στη σωστή λίστα ηλεκτρονικού ταχυδρομείου, όπως περιγράψαμε προηγουμένως. Οι δύο απαιτήσεις είναι συμπληρωματικές, δεν αλληλοαναιρούνται.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=make-conf>44.7.3. Ελέγξτε το <span class=filename>/etc/make.conf</span><a class=anchor href=#make-conf></a></h4><div class=paragraph><p>Εξετάστε τα αρχεία <span class=filename>/usr/shared/examples/etc/make.conf</span> και <span class=filename>/etc/make.conf</span>. Το πρώτο περιέχει κάποιες προεπιλεγμένες μεταβλητές (defines), οι περισσότερες από τις οποίες είναι ως σχόλια. Για να τα χρησιμοποιήσετε όταν μεταγλωττίζετε το σύστημα σας, προσθέστε τα στο <span class=filename>/etc/make.conf</span>. Να έχετε υπόψη σας, πως οτιδήποτε προσθέτετε στο αρχείο <span class=filename>/etc/make.conf</span> χρησιμοποιείτε επίσης κάθε φορά που εκτελείτε την εντολή <code>make</code>, έτσι είναι γενικά καλή ιδέα να βάλετε τιμές που είναι λογικές για το σύστημα σας.</p></div><div class=paragraph><p>Ένας τυπικός χρήστης θα θέλει πιθανώς να αντιγράψει τις γραμμές <code>CFLAGS</code> και <code>NO_PROFILE</code> από το αρχείο <span class=filename>/usr/shared/examples/etc/make.conf</span> στο <span class=filename>/etc/make.conf</span> αφαιρώντας ταυτόχρονα και το σύμβολο του σχολίου.</p></div><div class=paragraph><p>Εξετάστε και τις άλλες μεταβλητές (<code>COPTFLAGS</code>, <code>NOPORTDOCS</code> κ.ο.κ.) και αποφασίστε αν σχετίζονται με το επιθυμητό για σας αποτέλεσμα.</p></div></div><div class=sect3><h4 id=updating-etc>44.7.4. Ενημερώστε τα Αρχεία στο <span class=filename>/etc</span><a class=anchor href=#updating-etc></a></h4><div class=paragraph><p>Ο κατάλογος <span class=filename>/etc</span> περιέχει μεγάλο μέρος των πληροφοριών ρύθμισης του συστήματος σας, όπως επίσης και scripts που εκτελούνται κατά την εκκίνηση του συστήματος. Μερικά από τα scripts αυτά αλλάζουν από έκδοση σε έκδοση του FreeBSD.</p></div><div class=paragraph><p>Ορισμένα από τα αρχεία ρυθμίσεων χρησιμοποιούνται επίσης κατά την καθημερινή χρήση του συστήματος. Το <span class=filename>/etc/group</span> είναι ένα από αυτά.</p></div><div class=paragraph><p>Έχουν υπάρξει περιπτώσεις στο παρελθόν, όπου το <code>make installworld</code> ανέμενε από πριν την ύπαρξη συγκεκριμένων ονομάτων χρηστών (usernames) ή ομάδων (groups). Κατά τη διαδικασία της αναβάθμισης ήταν αρκετά πιθανό αυτοί οι χρήστες ή ομάδες να μην υπήρχαν. Αυτό δημιουργούσε προβλήματα στην διαδικασία. Σε κάποιες περιπτώσεις, το <code>make buildworld</code> θα ελέγξει αν υπάρχουν αυτοί οι χρήστες ή ομάδες.</p></div><div class=paragraph><p>Μια τέτοια περίπτωση παρουσιάστηκε όταν προστέθηκε ο χρήστης <code>smmsp</code>. Η διαδικασία αναβάθμισης αποτύγχανε σε πολλούς χρήστες, τη στιγμή που το <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a> προσπαθούσε να δημιουργήσει τον κατάλογο <span class=filename>/var/spool/clientmqueue</span>.</p></div><div class=paragraph><p>Η λύση είναι να εκτελέσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> σε κατάσταση προ-εγκατάστασης, δίνοντας την επιλογή <code>-p</code>. Αυτή θα συγκρίνει μόνο τα αρχεία που είναι απαραίτητα για την επιτυχία εκτέλεσης του <code>buildworld</code> ή του <code>installworld</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/mergemaster</span>
<span class=c># ./mergemaster.sh -p</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Αν αισθάνεστε ιδιαίτερα παρανοϊκός, μπορείτε να ελέγξετε το σύστημα σας για να δείτε ποια αρχεία ανήκουν στην ομάδα που μετονομάζετε ή διαγράφετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find / -group GID -print</span></code></pre></div></div><div class=paragraph><p>Η παραπάνω εντολή θα σας δείξει όλα τα αρχεία τα οποία ανήκουν στην ομάδα <em>GID</em> (μπορείτε να δώσετε όνομα ή αριθμητικό αναγνωριστικό της ομάδας).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=makeworld-singleuser>44.7.5. Μεταβείτε σε Κατάσταση Ενός Χρήστη<a class=anchor href=#makeworld-singleuser></a></h4><div class=paragraph><p>Ίσως προτιμάτε να μεταγλωττίσετε το σύστημα σε κατάσταση ενός χρήστη. Εκτός από το προφανές πλεονέκτημα της ελαφρά μεγαλύτερης ταχύτητας, η επανεγκατάσταση του συστήματος θα επηρεάσει πολλά σημαντικά αρχεία του συστήματος, όλα τα εκτελέσιμα αρχεία του βασικού συστήματος, τις βιβλιοθήκες, τα αρχεία include κ.α. Αν τα αλλάξετε αυτά σε ένα σύστημα που βρίσκεται σε κανονική λειτουργία (και ειδικά αν υπάρχουν ενεργοί χρήστες την δεδομένη στιγμή), ψάχνετε για μπελάδες.</p></div><div class=paragraph><p>Μια άλλη μέθοδος είναι να μεταγλωττίσετε το σύστημα σε κατάσταση κανονικής λειτουργίας, αλλά να μεταβείτε σε κατάσταση ενός χρήστη για την εγκατάσταση. Αν θέλετε να το κάνετε με αυτό τον τρόπο, απλώς μην εκτελέσετε τα ακόλουθα βήματα μέχρι το τέλος της μεταγλώττισης. Μπορείτε να αναβάλλετε τη μετάβαση σε κατάσταση ενός χρήστη μέχρι να είστε έτοιμοι για το <code>installkernel</code> ή <code>installworld</code>.</p></div><div class=paragraph><p>Ως υπερχρήστης μπορείτε να εκτελέσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown now</span></code></pre></div></div><div class=paragraph><p>σε ένα σύστημα σε κανονική λειτουργία για να μεταβείτε σε κατάσταση ενός χρήστη.</p></div><div class=paragraph><p>Εναλλακτικά, επανεκκινήστε το σύστημα και στην προτροπή του φορτωτή εκκίνησης, επιλέξτε "single user". Το σύστημα θα ξεκινήσει σε κατάσταση ενός χρήστη. Στην προτροπή της γραμμής εντολών θα πρέπει να γράψετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p</span>
<span class=c># mount -u /</span>
<span class=c># mount -a -t ufs</span>
<span class=c># swapon -a</span></code></pre></div></div><div class=paragraph><p>Θα γίνει έλεγχος στα συστήματα αρχείων, και προσάρτηση του <span class=filename>/</span> με δυνατότητα ανάγνωσης/εγγραφής. Έπειτα θα προσαρτηθούν όλα τα άλλα συστήματα αρχείων UFS τα οποία αναφέρονται στο <span class=filename>/etc/fstab</span>, και θα ενεργοποιηθεί το swap.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν το CMOS ρολόι του υπολογιστή σας είναι ρυθμισμένο σε τοπική ώρα και όχι σε GMT (αυτό είναι αλήθεια αν η έξοδος της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=date&amp;sektion=1&amp;format=html">date(1)</a> δεν δείχνει σωστή ημερομηνία και ώρα), ίσως χρειαστεί να εκτελέσετε επίσης την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adjkerntz -i</span></code></pre></div></div><div class=paragraph><p>Με αυτό τον τρόπο θα βεβαιωθείτε ότι οι τοπικές σας ρυθμίσεις ώρας έχουν ρυθμιστεί σωστά. Διαφορετικά, μπορεί να συναντήσετε προβλήματα αργότερα.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=cleaning-usr-obj>44.7.6. Διαγράψτε το <span class=filename>/usr/obj</span><a class=anchor href=#cleaning-usr-obj></a></h4><div class=paragraph><p>Καθώς γίνεται η επαναμεταγλώττιση, τμήματα του συστήματος τοποθετούνται από προεπιλογή σε υποκαταλόγους του <span class=filename>/usr/obj</span>. Οι υποκατάλογοι αυτοί αντιγράφουν τη δομή που ακολουθείται στο <span class=filename>/usr/src</span>.</p></div><div class=paragraph><p>Μπορείτε να επιταχύνετε τη διαδικασία του <code>make buildworld</code> και επίσης να γλυτώσετε από κάποια πιθανά προβλήματα, αν διαγράψετε και αυτό τον κατάλογο.</p></div><div class=paragraph><p>Κάποια αρχεία σε υποκαταλόγους του <span class=filename>/usr/obj</span> μπορεί να έχουν χαρακτηριστεί ως immutable μέσω του αντίστοιχου flag (για περισσότερες λεπτομέρειες δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>). Πριν διαγράψετε αυτά τα αρχεία, θα πρέπει πρώτα να καταργήσετε αυτό το flag.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/obj</span>
<span class=c># chflags -R noschg *</span>
<span class=c># rm -rf *</span></code></pre></div></div></div><div class=sect3><h4 id=updating-upgrading-compilebase>44.7.7. Επαναμεταγλωττίστε το Βασικό Σύστημα<a class=anchor href=#updating-upgrading-compilebase></a></h4><div class=sect4><h5 id=_αποθηκεύστε_την_έξοδο>44.7.7.1. Αποθηκεύστε την Έξοδο<a class=anchor href=#_αποθηκεύστε_την_έξοδο></a></h5><div class=paragraph><p>Καθώς εκτελείται η <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, είναι καλή ιδέα η έξοδος της να αποθηκεύεται σε κάποιο άλλο αρχείο. Αν κάτι πάει στραβά, θα έχετε ένα αντίγραφο του μηνύματος λάθους. Αν και αυτό ίσως δεν σας βοηθήσει να βρείτε τι πήγε στραβά, μπορεί να διευκολύνει άλλους αν στείλετε το μήνυμα σας σε μια από τις λίστες ηλεκτρονικού ταχυδρομείου του FreeBSD.</p></div><div class=paragraph><p>Ο ευκολότερος τρόπος για να γίνει αυτό, είναι χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=script&amp;sektion=1&amp;format=html">script(1)</a> με μια παράμετρο που να καθορίζει το όνομα του αρχείου στο οποίο θα αποθηκευτεί η έξοδος. Θα πρέπει να το εκτελέσετε αμέσως πριν ξεκινήσετε την μεταγλώττιση του βασικού συστήματος, και να γράψετε <code>exit</code> μόλις η διαδικασία ολοκληρωθεί.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># script /var/tmp/mw.out</span>
Script started, output file is /var/tmp/mw.out
<span class=c># make TARGET</span>
... μεταγλώττιση, μεταγλώττιση, μεταγλώττιση ...
<span class=c># exit</span>
Script <span class=k>done</span>, ...</code></pre></div></div><div class=paragraph><p>Αν αποφασίσετε να αποθηκεύσετε την έξοδο, <em>μη χρησιμοποιήσετε</em> για αυτό το σκοπό τον κατάλογο <span class=filename>/tmp</span>. Τα περιεχόμενα αυτού του καταλόγου πιθανώς να διαγραφούν την επόμενη φορά που θα εκκινήσετε το σύστημα σας. Ένας καλύτερος κατάλογος για την αποθήκευση του είναι ο <span class=filename>/var/tmp</span> (όπως στο προηγούμενο παράδειγμα) ή ο προσωπικός κατάλογος του <code>root</code>.</p></div></div><div class=sect4><h5 id=make-buildworld>44.7.7.2. Μεταγλωττίστε το Βασικό Σύστημα<a class=anchor href=#make-buildworld></a></h5><div class=paragraph><p>Θα πρέπει να βρίσκεστε στον κατάλογο <span class=filename>/usr/src</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div><div class=paragraph><p>(εκτός αν φυσικά έχετε αποθηκεύσει τον πηγαίο κώδικα σε κάποιο άλλο κατάλογο, οπότε απλώς μετακινηθείτε σε αυτόν).</p></div><div class=paragraph><p>Για να επαναμεταγλωττίσετε το βασικό σύστημα, χρησιμοποιήστε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>. Η εντολή αυτή διαβάζει τις σχετικές οδηγίες από το αρχείο <span class=filename>Makefile</span>, το οποίο περιγράφει με ποιο τρόπο πρέπει να μεταγλωττιστούν τα προγράμματα από τα οποία αποτελείται το FreeBSD, τη σειρά με την οποία πρέπει να γίνει η μεταγλώττιση κ.ο.κ.</p></div><div class=paragraph><p>Η γενική μορφή της εντολής που θα πληκτρολογήσετε είναι η παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -x -DVARIABLE target</span></code></pre></div></div><div class=paragraph><p>Στο παράδειγμα αυτό, το <code>-<em>x</em></code> αντιπροσωπεύει μια επιλογή που θέλετε να δώσετε στην <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>. Δείτε την σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> για παραδείγματα δυνατών επιλογών.</p></div><div class=paragraph><p>Η επιλογή <code>-D<em>VARIABLE</em></code> περνάει μια μεταβλητή στο <span class=filename>Makefile</span>. Η συμπεριφορά του <span class=filename>Makefile</span> ελέγχεται από τέτοιου είδους μεταβλητές. Πρόκειται για τις ίδιες μεταβλητές που καθορίζονται και στο <span class=filename>/etc/make.conf</span>, και αυτός είναι ένας ακόμα τρόπος καθορισμού τους.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -DNO_PROFILE target</span></code></pre></div></div><div class=paragraph><p>Το παραπάνω δείχνει ένα επιπλέον τρόπο να καθορίσετε ότι δεν θέλετε να μεταγλωττιστούν οι βιβλιοθήκες με πληροφορίες profiling, και αντιστοιχεί με την παρακάτω γραμμή στο <span class=filename>/etc/make.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>NO_PROFILE=    true 	#    Avoid compiling profiled libraries</pre></div></div><div class=paragraph><p>Το <em>target</em> δηλώνει στο <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> τι θέλετε να κάνετε. Σε κάθε <span class=filename>Makefile</span> ορίζεται ένας αριθμός διαφορετικών "targets", και η επιλογή που θα κάνετε, καθορίζει τι ακριβώς θα γίνει.</p></div><div class=paragraph><p>Κάποια από τα targets που καθορίζονται στο <span class=filename>Makefile</span>, δεν προορίζονται για άμεση εκτέλεση από το χρήστη. Αντί για αυτό, χρησιμοποιούνται από τη διαδικασία μεταγλώττισης για να μοιραστεί ο αριθμός των βημάτων που απαιτούνται για τη μεταγλώττιση του συστήματος, σε ένα αριθμό υπo-βημάτων.</p></div><div class=paragraph><p>Στις περισσότερες περιπτώσεις δεν θα χρειαστεί να δώσετε καμία παράμετρο στο <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, και έτσι η εντολή σας θα μοιάζει με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make target</span></code></pre></div></div><div class=paragraph><p>Όπου το <em>target</em> θα είναι μια από τις πολλές επιλογές μεταγλώττισης. Το πρώτο target θα πρέπει πάντα να είναι το <code>buildworld</code>.</p></div><div class=paragraph><p>Όπως εννοείται και από το όνομα, το <code>buildworld</code> μεταγλωττίζει ένα πλήρες δέντρο μέσα στον κατάλογο <span class=filename>/usr/obj</span>, ενώ το <code>installworld</code>, εγκαθιστά αυτό το δέντρο στο τρέχον μηχάνημα.</p></div><div class=paragraph><p>Η ύπαρξη διαφορετικών επιλογών, είναι χρήσιμη για δύο λόγους. Πρώτα από όλα, σας επιτρέπει να εκτελέσετε τη διαδικασία μεταγλώττισης με ασφάλεια, γνωρίζοντας ότι δεν πρόκειται να επηρεαστεί κανένα τμήμα του τρέχοντος συστήματος σας. Η διαδικασία μεταγλώττισης είναι "self hosted", απομονωμένη από την υπόλοιπη λειτουργία του μηχανήματος. Μπορείτε έτσι να εκτελέσετε το <code>buildworld</code> σε ένα μηχάνημα που βρίσκεται σε κανονική λειτουργία (πολλαπλών χρηστών) χωρίς να υπάρχει φόβος παρενεργειών. Ωστόσο, συνίσταται να εκτελέσετε το <code>installworld</code> σε κατάσταση λειτουργίας ενός χρήστη.</p></div><div class=paragraph><p>Ο δεύτερος λόγος είναι ότι σας επιτρέπει να χρησιμοποιήσετε προσαρτήσεις NFS για να αναβαθμίσετε πολλά μηχανήματα του δικτύου σας. Αν έχετε τρία μηχανήματα, τα <code>A</code>, <code>B</code> και <code>C</code> τα οποία θέλετε να αναβαθμίσετε, εκτελέστε το <code>make buildworld</code> και το <code>make installworld</code> στο μηχάνημα <code>A</code>. Το <code>B</code> και το <code>C</code> μπορούν να προσαρτήσουν τον κατάλογο <span class=filename>/usr/src</span> και τον <span class=filename>/usr/obj</span> από τον <code>A</code> μέσω NFS, και έπειτα μπορείτε να εκτελέσετε το <code>make installworld</code> για να εγκαταστήσετε το έτοιμο πλέον σύστημα στον <code>B</code> και <code>C</code>.</p></div><div class=paragraph><p>Αν και υπάρχει ακόμα το target <code>world</code>, δεν συνίσταται πλέον η χρήση του.</p></div><div class=paragraph><p>Εκτελέστε την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildworld</span></code></pre></div></div><div class=paragraph><p>Μπορείτε να καθορίσετε την επιλογή <code>-j</code> στην <code>make</code> ώστε να εκτελεστεί σε πολλαπλές διεργασίες. Αυτό είναι περισσότερο χρήσιμο σε μηχανήματα με πολλούς επεξεργαστές, ωστόσο καθώς το μεγαλύτερο μέρος της διαδικασίας μεταγλώττισης καθυστερεί εξαιτίας του σκληρού δίσκου (IO bound) και όχι της CPU, μπορεί να σας φανεί χρήσιμο ακόμα και σε μηχανήματα με ένα επεξεργαστή.</p></div><div class=paragraph><p>Σε ένα τυπικό μηχάνημα με μια CPU, θα μπορούσατε να δώσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -j4 buildworld</span></code></pre></div></div><div class=paragraph><p>Με την παραπάνω εντολή, το <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> θα χρησιμοποιεί μέχρι 4 διεργασίες κάθε χρονική στιγμή. Από την εμπειρία που έχουμε και από ότι αναφέρουν οι χρήστες στις λίστες, φαίνεται ότι η ρύθμιση αυτή δίνει γενικά την καλύτερη απόδοση.</p></div><div class=paragraph><p>Αν έχετε μηχάνημα με πολλούς επεξεργαστές, και χρησιμοποιείτε πυρήνα με δυνατότητα SMP, δοκιμάστε τιμές μεταξύ του 6 και του 10 για να δείτε ποια επιταχύνει καλύτερα το αποτέλεσμα.</p></div></div><div class=sect4><h5 id=_χρόνος_μεταγλώττισης>44.7.7.3. Χρόνος Μεταγλώττισης<a class=anchor href=#_χρόνος_μεταγλώττισης></a></h5><div class=paragraph><p>Ο χρόνος που απαιτείται για την μεταγλώττιση επηρεάζεται από πολλούς παράγοντες. Ωστόσο, σε σύγχρονα μηχανήματα η διαδικασία δεν κρατάει συνήθως παραπάνω από μία ή δύο ώρες, όταν γίνεται μεταγλώττιση του δέντρου FreeBSD-STABLE, και μάλιστα χωρίς να χρειάζεται να γίνουν ειδικές ρυθμίσεις ή κόλπα. Το δέντρο FreeBSD-CURRENT χρειάζεται γενικά λίγο περισσότερο χρόνο για να μεταγλωττιστεί.</p></div></div></div><div class=sect3><h4 id=new-kernel>44.7.8. Μεταγλωττίστε και Εγκαταστήστε Νέο Πυρήνα<a class=anchor href=#new-kernel></a></h4><div class=paragraph><p>Για να εκμεταλλευθείτε πλήρως το νέο σας σύστημα, θα πρέπει να επαναμεταγλωττίσετε τον πυρήνα. Αυτό είναι πρακτικά αναγκαίο, καθώς κάποιες δομές στη μνήμη πιθανώς να έχουν αλλάξει, και έτσι προγράμματα όπως τα <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> δεν θα λειτουργούν σωστά μέχρι να συγχρονίσετε τον πυρήνα με την έκδοση πηγαίου κώδικα του βασικού συστήματος.</p></div><div class=paragraph><p>Ο απλούστερος και πλέον ασφαλής τρόπος, είναι να μεταγλωττίσετε και να εγκαταστήσετε ένα πυρήνα βασισμένο στον <span class=filename>GENERIC</span>. Αν και ο <span class=filename>GENERIC</span> μπορεί να μην περιέχει όλες τις απαραίτητες συσκευές για το σύστημα σας, θα πρέπει να περιέχει ότι χρειάζεται ώστε να ξεκινήσετε ξανά το σύστημα σας σε κατάσταση λειτουργίας ενός χρήστη. Αυτό είναι ένα καλό τεστ σωστής λειτουργίας του συστήματος. Μετά την εκκίνηση με τον <span class=filename>GENERIC</span>, και αφού επαληθεύσετε τη σωστή λειτουργία του συστήματος, μπορείτε να μεταγλωττίσετε ένα νέο πυρήνα βασισμένο στο δικό σας προσαρμοσμένο αρχείο ρυθμίσεων.</p></div><div class=paragraph><p>Στο FreeBSD είναι σημαντικό να εκτελέσετε το <a href=#make-buildworld>build world</a> πριν μεταγλωττίσετε νέο πυρήνα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν θέλετε να μεταγλωττίσετε νέο πυρήνα, και έχετε ήδη ένα αρχείο με προσαρμοσμένες ρυθμίσεις, χρησιμοποιήστε απλώς την επιλογή <code>KERNCONF=MYKERNEL</code> με τον τρόπο που φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildkernel KERNCONF=MYKERNEL</span>
<span class=c># make installkernel KERNCONF=MYKERNEL</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Σημειώστε ότι αν έχετε ανεβάσει την τιμή του <code>kern.securelevel</code> πάνω από το 1, <em>και</em> έχετε θέσει το flag <code>noschg</code> ή κάποιο αντίστοιχο στο εκτελέσιμο αρχείο του πυρήνα, μάλλον θα χρειαστεί να μεταβείτε σε κατάσταση λειτουργίας ενός χρήστη για να χρησιμοποιήσετε το <code>installkernel</code>. Διαφορετικά, μπορείτε να εκτελέσετε και τις δύο αυτές εντολές από την κανονική κατάσταση λειτουργίας (πολλών χρηστών) χωρίς να δημιουργηθούν προβλήματα. Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> για λεπτομέρειες σχετικά με τη ρύθμιση <code>kern.securelevel</code> και τη σελίδα του <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> για λεπτομέρειες σχετικά με τα διάφορα flags που χρησιμοποιούνται σε αρχεία.</p></div></div><div class=sect3><h4 id=new-kernel-singleuser>44.7.9. Επανεκκινήστε σε Κατάσταση Λειτουργίας Ενός Χρήστη<a class=anchor href=#new-kernel-singleuser></a></h4><div class=paragraph><p>Θα πρέπει να επανεκκινήσετε σε κατάσταση λειτουργίας ενός χρήστη για να επαληθεύσετε τη λειτουργία του νέου πυρήνα. Για το σκοπό αυτό, χρησιμοποιήστε τις οδηγίες που είδαμε στο <a href=#makeworld-singleuser>Μεταβείτε σε Κατάσταση Ενός Χρήστη</a>.</p></div></div><div class=sect3><h4 id=make-installworld>44.7.10. Εγκαταστήστε τα Νέα Εκτελέσιμα του Συστήματος<a class=anchor href=#make-installworld></a></h4><div class=paragraph><p>Θα πρέπει τώρα να χρησιμοποιήσετε το <code>installworld</code> για να εγκαταστήσετε τα νέα εκτελέσιμα του συστήματος.</p></div><div class=paragraph><p>Εκτελέστε τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installworld</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν έχετε καθορίσει μεταβλητές στη γραμμή εντολών του <code>make buildworld</code> θα πρέπει να καθορίσετε τις ίδιες μεταβλητές και στην γραμμή εντολών του <code>make installworld</code>. Αυτό δεν είναι απαραίτητα αλήθεια για άλλες επιλογές. Για παράδειγμα, η επιλογή <code>-j</code> δεν πρέπει ποτέ να χρησιμοποιείτε με το <code>installworld</code>.</p></div><div class=paragraph><p>Για παράδειγμα αν εκτελέσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -DNO_PROFILE buildworld</span></code></pre></div></div><div class=paragraph><p>Θα πρέπει να εγκαταστήσετε το αποτέλεσμα χρησιμοποιώντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -DNO_PROFILE installworld</span></code></pre></div></div><div class=paragraph><p>διαφορετικά το <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> θα προσπαθήσει να εγκαταστήσει βιβλιοθήκες με profiling, τις οποίες όμως δεν μεταγλωττίσατε κατά τη διάρκεια της φάσης <code>make buildworld</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=post-installworld-updates>44.7.11. Ενημερώστε Όσα Αρχεία δεν Ενημερώθηκαν από το <code>make installworld</code><a class=anchor href=#post-installworld-updates></a></h4><div class=paragraph><p>Η επαναμεταγλώττιση του βασικού συστήματος δεν θα ενημερώσει ορισμένους καταλόγους (ειδικότερα τους <span class=filename>/etc</span>, <span class=filename>/var</span> και <span class=filename>/usr</span>) με τα νέα ή αλλαγμένα αρχεία ρυθμίσεων.</p></div><div class=paragraph><p>Ο απλούστερος τρόπος για να ενημερώσετε τα αρχεία αυτά είναι να χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>, αν και μπορείτε να το κάνετε και χειροκίνητα αν προτιμάτε. Άσχετα από τον τρόπο που θα προτιμήσετε, βεβαιωθείτε ότι έχετε πάρει αντίγραφο ασφαλείας του <span class=filename>/etc</span> σε περίπτωση που κάτι πάει στραβά.</p></div><div class=sect4><h5 id=mergemaster>44.7.11.1. <code>mergemaster</code><a class=anchor href=#mergemaster></a></h5><div class=paragraph><p>Το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> είναι ένα Bourne script το οποίο θα σας βοηθήσει να καθορίσετε τις διαφορές μεταξύ των εγκατεστημένων στο <span class=filename>/etc</span> αρχείων ρυθμίσεων, και των αντίστοιχων στο δέντρο πηγαίου κώδικα στο <span class=filename>/usr/src/etc</span>. Αυτή είναι και η συνιστώμενη λύση για να ενημερώσετε τα αρχεία ρυθμίσεων του συστήματος με τυχόν αλλαγές που έχουν γίνει στον νέο πηγαίο κώδικα.</p></div><div class=paragraph><p>Για να ξεκινήσετε, απλώς γράψτε <code>mergemaster</code> στην προτροπή της γραμμής εντολών και παρακολουθήστε την καθώς λειτουργεί. Το <code>mergemaster</code> θα δημιουργήσει ένα προσωρινό περιβάλλον root, από το <span class=filename>/</span> και κάτω, και θα το γεμίσει με διάφορα αρχεία ρυθμίσεων του συστήματος. Έπειτα θα γίνει σύγκριση αυτών των αρχείων με τα αντίστοιχα που βρίσκονται ήδη εγκατεστημένα στο σύστημα σας. Στο σημείο αυτό, θα σας δείξει τα αρχεία που διαφέρουν με μορφή <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>, όπου οι γραμμές που έχουν τροποποιηθεί ή είναι νέες θα φαίνονται με ένα <code>+</code>, ενώ με το <code>-</code> θα φαίνονται οι γραμμές που είτε αφαιρούνται εντελώς ή που αντικαθίστανται από μια νέα γραμμή. Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> για περισσότερες πληροφορίες σχετικά με τη σύνταξη του <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> και για τον τρόπο με τον οποίο φαίνονται οι διαφορές μεταξύ των αρχείων.</p></div><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> θα σας δείξει έπειτα κάθε αρχείο που παρουσιάζει διαφορές, και στο σημείο αυτό θα έχετε την δυνατότητα είτε να διαγράψετε το νέο αρχείο (το οποίο αναφέρεται ως προσωρινό αρχείο), είτε να εγκαταστήσετε το προσωρινό αρχείο χωρίς να κάνετε σε αυτό καμιά αλλαγή, είτε να συγχωνεύσετε τις αλλαγές των δύο αρχείων, ή τέλος να ξαναδείτε τις διαφορές μέσω της <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>.</p></div><div class=paragraph><p>Αν επιλέξετε να διαγράψετε το προσωρινό αρχείο, το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> θα καταλάβει ότι επιθυμείτε να διατηρήσετε το τρέχον αρχείο σας χωρίς αλλαγές, και να διαγράψετε τη νέα έκδοση. Η επιλογή αυτή γενικά δεν συνίσταται, εκτός αν δεν βλέπετε κανένα λόγο να αλλάξετε το τρέχον αρχείο. Μπορείτε να δείτε βοήθεια οποιαδήποτε στιγμή κατά τη διάρκεια της διαδικασίας, πληκτρολογώντας <kbd>?</kbd> στην προτροπή του <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>. Αν αποφασίσετε να παραλείψετε κάποιο αρχείο, αυτό θα εμφανιστεί ξανά μετά το τέλος όλων των άλλων αρχείων.</p></div><div class=paragraph><p>Αν επιλέξετε να εγκαταστήσετε το προσωρινό αρχείο χωρίς αλλαγές, αυτό θα αντικαταστήσει το ήδη εγκατεστημένο σας αρχείο. Αυτή είναι και η καλύτερη επιλογή για τα αρχεία τα οποία δεν έχετε αλλάξει εσείς χειροκίνητα.</p></div><div class=paragraph><p>Αν επιλέξετε να συγχωνεύσετε τα δύο αρχεία, θα εμφανιστεί ένας επεξεργαστής κειμένου με τα περιεχόμενα και των δύο αρχείων. Μπορείτε τώρα να τα συγχωνεύσετε παρατηρώντας ταυτόχρονα και τα δύο αρχεία δίπλα-δίπλα, και επιλέγοντας τμήματα και από τα δύο για να δημιουργήσετε την τελική έκδοση. Κατά τη σύγκριση αυτή, μπορείτε να χρησιμοποιήσετε το πλήκτρο <kbd>l</kbd> για να επιλέξετε τα περιεχόμενα που φαίνονται στην αριστερή πλευρά, ή το <kbd>r</kbd> για τα αντίστοιχα περιεχόμενα στη δεξιά. Το τελικό αποτέλεσμα θα είναι ένα αρχείο που θα αποτελείται από τμήματα και των δύο αρχείων, και το οποίο μπορείτε να εγκαταστήσετε. Η επιλογή αυτή χρησιμοποιείται συνήθως για αρχεία των οποίων το περιεχόμενο έχει μεταβληθεί από το χρήστη.</p></div><div class=paragraph><p>Αν επιλέξετε να δείτε ξανά τις διαφορές μέσω της <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>, αυτές θα εμφανιστούν ακριβώς όπως έγινε και πριν σας ρωτήσει το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> να επιλέξετε τι θέλετε να κάνετε με το αρχείο.</p></div><div class=paragraph><p>Μόλις ολοκληρωθεί η λειτουργία του <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> στα αρχεία συστήματος, θα σας ρωτήσει για άλλες επιλογές. Το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> ίσως σας ρωτήσει αν θέλετε να αναδημιουργήσετε το αρχείο των κωδικών (password file), και θα τελειώσει δίνοντας σας την επιλογή να διαγράψετε τυχόν προσωρινά αρχεία που δημιουργήθηκαν κατά την διαδικασία.</p></div></div><div class=sect4><h5 id=_χειροκίνητη_ενημέρωση>44.7.11.2. Χειροκίνητη Ενημέρωση<a class=anchor href=#_χειροκίνητη_ενημέρωση></a></h5><div class=paragraph><p>Αν επιθυμείτε να κάνετε την ενημέρωση χειροκίνητα, δεν μπορείτε απλώς να αντιγράψετε τα αρχεία από τον κατάλογο <span class=filename>/usr/src/etc</span> στον <span class=filename>/etc</span> και να περιμένετε ότι το σύστημα σας θα λειτουργήσει σωστά. Κάποια από αυτά τα αρχεία θα πρέπει να "εγκατασταθούν" πρώτα. Αυτό συμβαίνει επειδή ο κατάλογος <span class=filename>/usr/src/etc</span><em>δεν είναι</em> κανονικό αντίγραφο του <span class=filename>/etc</span>. Επιπρόσθετα, υπάρχουν αρχεία τα οποία πρέπει να βρίσκονται στον κατάλογο <span class=filename>/etc</span>, αλλά δεν υπάρχουν στον <span class=filename>/usr/src/etc</span>.</p></div><div class=paragraph><p>Αν χρησιμοποιείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> (όπως και συνίσταται), μπορείτε να διαβάσετε κατευθείαν την <a href=#updating-upgrading-rebooting>επόμενη ενότητα</a>.</p></div><div class=paragraph><p>Ο απλούστερος τρόπος να το κάνετε αυτό χειροκίνητα, είναι να εγκαταστήσετε τα αρχεία σε ένα νέο κατάλογο, και έπειτα να τα εξετάσετε ένα-ένα ψάχνοντας για τις αλλαγές.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Κρατήστε Ένα Αντίγραφο Ασφαλείας του Καταλόγου <span class=filename>/etc</span></div><div class=paragraph><p>Αν και θεωρητικά, τίποτα δεν πρόκειται να πειράξει αυτό τον κατάλογο αυτόματα, είναι πάντα καλύτερα να είμαστε σίγουροι. Για το λόγο αυτό, αντιγράψτε τον υπάρχοντα κατάλογο <span class=filename>/etc</span> σε κάποιο ασφαλές μέρος. Χρησιμοποιήστε μια εντολή όπως η παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp -Rp /etc /etc.old</span></code></pre></div></div><div class=paragraph><p>Η επιλογή <code>-R</code> πραγματοποιεί αναδρομική αντιγραφή, ενώ η <code>-p</code> διατηρεί τα δικαιώματα, την ιδιοκτησία, τις ημερομηνίες των αρχείων, κ.ο.κ.</p></div></td></tr></tbody></table></div><div class=paragraph><p>θα πρέπει να δημιουργήσετε μια ψευτο-δομή καταλόγων για να εγκαταστήσετε το νέο κατάλογο <span class=filename>/etc</span> και άλλα αρχεία. Μια λογική επιλογή είναι ο κατάλογος <span class=filename>/var/tmp/root</span>, και κάτω από αυτόν, θα πρέπει επίσης να δημιουργήσετε και μια ολόκληρη σειρά από τους υποκαταλόγους που απαιτούνται.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/root</span>
<span class=c># cd /usr/src/etc</span>
<span class=c># make DESTDIR=/var/tmp/root distrib-dirs distribution</span></code></pre></div></div><div class=paragraph><p>Οι παραπάνω εντολές θα δημιουργήσουν την απαιτούμενη δομή καταλόγων και θα εγκαταστήσουν τα αρχεία. Μεγάλο μέρος των υποκαταλόγων που έχουν δημιουργηθεί κάτω από τον <span class=filename>/var/tmp/root</span> είναι άδειοι, και πρέπει να διαγραφούν. Ο απλούστερος τρόπος για να γίνει αυτό, φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /var/tmp/root</span>
<span class=c># find -d . -type d | xargs rmdir 2/dev/null</span></code></pre></div></div><div class=paragraph><p>Αυτό θα διαγράψει όλους τους άδειους υποκαταλόγους. (Η έξοδος σφάλματος ανακατευθύνεται στο <span class=filename>/dev/null</span> ώστε να μην εμφανίζονται στην οθόνη προειδοποιήσεις για καταλόγους που δεν είναι άδειοι.)</p></div><div class=paragraph><p>Τώρα, ο <span class=filename>/var/tmp/root</span> περιέχει όλα τα αρχεία που θα πρέπει να τοποθετηθούν σε κατάλληλες θέσεις κάτω από τον <span class=filename>/</span>. Θα πρέπει τώρα να διατρέξετε καθένα από αυτά τα αρχεία, και να καθορίσετε πως καθένα από αυτά διαφέρει από το αντίστοιχο υπάρχον (εγκατεστημένο) αρχείο.</p></div><div class=paragraph><p>Σημειώστε ότι κάποια από τα αρχεία τα οποία έχουν εγκατασταθεί στον <span class=filename>/var/tmp/root</span> έχουν μια αρχική ".". Τη στιγμή που γράφονται αυτές οι γραμμές, τα μόνα αρχεία στα οποία συμβαίνει αυτό είναι τα αρχεία εκκίνησης του κελύφους στον κατάλογο <span class=filename>/var/tmp/root/</span> και <span class=filename>/var/tmp/root/root/</span>, αν και μπορεί να υπάρχουν και άλλα (ανάλογα με το πότε διαβάζετε το κείμενο). Βεβαιωθείτε ότι χρησιμοποιείτε την εντολή <code>ls -a</code> για να τα δείτε όλα.</p></div><div class=paragraph><p>Ο απλούστερος τρόπος για να συγκρίνετε δύο αρχεία, είναι να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diff /etc/shells /var/tmp/root/etc/shells</span></code></pre></div></div><div class=paragraph><p>Η παραπάνω εντολή θα σας δείξει τις διαφορές μεταξύ του αρχείου <span class=filename>/etc/shells</span> και του νέου αρχείου <span class=filename>/var/tmp/root/etc/shells</span>. Χρησιμοποιήστε τις διαφορές αυτές για να αποφασίσετε αν θα πρέπει να συγχωνεύσετε τις αλλαγές που έχετε κάνει, ή απλώς να αντιγράψετε το παλιό σας αρχείο πάνω από το νέο.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Προσθέστε την Ημερομηνία στο Όνομα του Νέου Root Καταλόγου, (<span class=filename>/var/tmp/root</span>) Ώστε να Μπορείτε Εύκολα να Συγκρίνετε Διαφορετικές Εκδόσεις Μεταξύ τους</div><div class=paragraph><p>Αν μεταγλωττίζετε συχνά το βασικό σύστημα, θα πρέπει επίσης να ενημερώνετε συχνά τον κατάλογο <span class=filename>/etc</span>, το οποίο μπορεί να είναι ενοχλητικό.</p></div><div class=paragraph><p>Μπορείτε να επιταχύνετε αυτή τη διαδικασία, τηρώντας ένα αντίγραφο του τελευταίου σετ αλλαγμένων αρχείων τα οποία συγχωνεύσατε στον κατάλογο <span class=filename>/etc</span>. Η παρακάτω διαδικασία θα σας δώσει μια ιδέα για το πως μπορεί να γίνει αυτό:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Μεταγλωττίστε το βασικό σύστημα όπως κάνετε συνήθως. Όταν θέλετε να ενημερώσετε τον <span class=filename>/etc</span> και τους άλλους καταλόγους, δώστε στον κατάλογο προορισμού ένα όνομα βασισμένο στην τρέχουσα ημερομηνία. Αν το κάνατε αυτό στις 14 Φεβρουαρίου 1998, θα γράφατε κάτι σαν το παρακάτω:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/root-19980214</span>
<span class=c># cd /usr/src/etc</span>
<span class=c># make DESTDIR=/var/tmp/root-19980214 \</span>
    distrib-dirs distribution</code></pre></div></div></li><li><p>Συγχωνεύστε τις αλλαγές από αυτό τον κατάλογο, με τον τρόπο που περιγράψαμε παραπάνω.</p><div class=paragraph><p><em>Μην διαγράψετε</em> τον κατάλογο <span class=filename>/var/tmp/root-19980214</span> όταν τελειώσετε με την παραπάνω διαδικασία.</p></div></li><li><p>Όταν κατεβάσετε την τελευταία έκδοση του πηγαίου κώδικα και τον μεταγλωττίσετε ξανά, ακολουθήστε το βήμα 1. Αυτό θα σας δώσει ένα κατάλογο που μπορεί να ονομάζεται <span class=filename>/var/tmp/root-19980221</span> (αν ανάμεσα στις δύο μεταγλωττίσεις παρεμβάλλεται διάστημα μιας εβδομάδας).</p></li><li><p>Μπορείτε τώρα να δείτε τις διαφορές που υπάρχουν ανάμεσα στις δύο εβδομάδες, χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> σε αναδρομική λειτουργία για να δημιουργήσετε τις διαφορές μεταξύ των δύο καταλόγων:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /var/tmp</span>
<span class=c># diff -r root-19980214 root-19980221</span></code></pre></div></div><div class=paragraph><p>Τυπικά, αυτό το σετ αλλαγών θα είναι πολύ μικρότερο από αυτό μεταξύ του <span class=filename>/var/tmp/root-19980221/etc</span> και του <span class=filename>/etc</span>. Καθώς αυτό το σετ αλλαγών είναι μικρότερο, είναι και πιο εύκολο να εφαρμόσετε αυτές τις αλλαγές στον κατάλογο <span class=filename>/etc</span>.</p></div></li><li><p>Μπορείτε τώρα να διαγράψετε τον παλιότερο από τους δύο καταλόγους <span class=filename>/var/tmp/root-*</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm -rf /var/tmp/root-19980214</span></code></pre></div></div></li><li><p>Επαναλάβετε αυτή τη διαδικασία κάθε φορά που θέλετε να συγχωνεύσετε τις αλλαγές στον κατάλογο <span class=filename>/etc</span>.</p></li></ol></div><div class=paragraph><p>Μπορείτε επίσης να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=date&amp;sektion=1&amp;format=html">date(1)</a> για να αυτοματοποιήσετε την δημιουργία των ονομάτων καταλόγων:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/root-`date &#34;+%Y%m%d&#34;`</span></code></pre></div></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=updating-upgrading-rebooting>44.7.12. Επανεκκίνηση<a class=anchor href=#updating-upgrading-rebooting></a></h4><div class=paragraph><p>Η διαδικασία έχει πλέον ολοκληρωθεί. Αφού επαληθεύσετε ότι όλα βρίσκονται στις σωστές θέσεις, μπορείτε να επανεκκινήσετε το σύστημα. Μια απλή εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> είναι επαρκής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div></div><div class=sect3><h4 id=_ολοκλήρωση>44.7.13. Ολοκλήρωση<a class=anchor href=#_ολοκλήρωση></a></h4><div class=paragraph><p>Έχετε πλέον αναβαθμίσει το FreeBSD σύστημα σας. Συγχαρητήρια.</p></div><div class=paragraph><p>Αν τα πράγματα δεν πήγαν εντελώς σωστά, είναι εύκολο να μεταγλωττίσετε ξανά οποιοδήποτε τμήμα του συστήματος. Για παράδειγμα, αν διαγράψετε κατά λάθος το <span class=filename>/etc/magic</span> ως μέρος μιας αναβάθμισης ή συγχώνευσης του <span class=filename>/etc</span>, η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=file&amp;sektion=1&amp;format=html">file(1)</a> θα σταματήσει να λειτουργεί. Στην περίπτωση αυτή, η διόρθωση είναι να εκτελέσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.bin/file</span>
<span class=c># make all install</span></code></pre></div></div></div><div class=sect3><h4 id=updating-questions>44.7.14. Ερωτήσεις<a class=anchor href=#updating-questions></a></h4><div class=sect4><h5 id=_πρέπει_να_μεταγλωττίσω_ξανά_ολόκληρο_το_βασικό_σύστημα_σε_κάθε_αλλαγή>44.7.14.1. Πρέπει να μεταγλωττίσω ξανά ολόκληρο το βασικό σύστημα σε κάθε αλλαγή;<a class=anchor href=#_πρέπει_να_μεταγλωττίσω_ξανά_ολόκληρο_το_βασικό_σύστημα_σε_κάθε_αλλαγή></a></h5><div class=paragraph><p>Δεν υπάρχει εύκολη απάντηση σε αυτό το ερώτημα, καθώς εξαρτάται από τη φύση της αλλαγής. Για παράδειγμα, αν εκτελέσετε το CVSup, και δείτε ότι ενημερώθηκαν τα παρακάτω αρχεία:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>src/games/cribbage/instr.c
src/games/sail/pl_main.c
src/release/sysinstall/config.c
src/release/sysinstall/media.c
src/shared/mk/bsd.port.mk</code></pre></div></div><div class=paragraph><p>Το πιθανότερο είναι ότι δεν χρειάζεται να μεταγλωττίσετε ξανά όλο το βασικό σύστημα. Μπορείτε απλώς να μεταβείτε στους σχετικούς υποκαταλόγους και να εκτελέσετε το <code>make all install</code>, και θα έχετε τελειώσει. Αν όμως υπάρχει κάποια σημαντική αλλαγή, για παράδειγμα το <span class=filename>src/lib/libc/stdlib</span>, θα πρέπει είτε να επαναμεταγλωττίσετε το βασικό σύστημα, ή τουλάχιστον αυτά τα κομμάτια τα οποία είναι στατικά συνδεδεμένα (όπως και οτιδήποτε άλλο έχετε προσθέσει εσείς και το οποίο είναι στατικά συνδεδεμένο).</p></div><div class=paragraph><p>Τελικά, η απόφαση είναι δική σας. Μπορεί να είστε ικανοποιημένος αν μεταγλωττίζετε το βασικό σύστημα κάθε δύο βδομάδες, αφήνοντας τις αλλαγές να συγκεντρωθούν στη διάρκεια αυτού του διαστήματος. Ή μπορεί να θέλετε να μεταγλωττίσετε μόνο τις αλλαγές, αν έχετε την πεποίθηση ότι μπορείτε να εντοπίσετε όλες τις εξαρτήσεις τους.</p></div><div class=paragraph><p>Και φυσικά, όλα αυτά εξαρτώνται από το πόσο συχνά θέλετε να ενημερώνετε το σύστημα σας, και από το αν ακολουθείτε το FreeBSD-STABLE ή το FreeBSD-CURRENT.</p></div></div><div class=sect4><h5 id=_η_μεταγλώττιση_μου_απέτυχε_με_πλήθος_μηνυμάτων_signal_11signal_11_ή_λάθη_με_άλλα_σήματα_τι_έχει_συμβεί>44.7.14.2. Η μεταγλώττιση μου απέτυχε με πλήθος μηνυμάτων signal 11signal 11 (ή λάθη με άλλα σήματα). Τι έχει συμβεί;<a class=anchor href=#_η_μεταγλώττιση_μου_απέτυχε_με_πλήθος_μηνυμάτων_signal_11signal_11_ή_λάθη_με_άλλα_σήματα_τι_έχει_συμβεί></a></h5><div class=paragraph><p>Αυτό συνήθως δείχνει προβλήματα υλικού. Η διαδικασία μεταγλώττισης του βασικού συστήματος είναι ένας αποτελεσματικός τρόπος να δοκιμάσετε το υλικό σας στα όρια του, και συχνά θα δείξει προβλήματα που σχετίζονται με τη μνήμη. Το πιο σύνηθες σύμπτωμα, είναι η απότομη διακοπή της μεταγλώττισης, με τον μεταγλωττιστή να φαίνεται ότι έχει λάβει κάποιο μυστηριώδες σήμα.</p></div><div class=paragraph><p>Ένα σίγουρο σημάδι για το παραπάνω, είναι να επανεκκινήσετε τη διαδικασία, και αυτή να σταματήσει σε διαφορετικό σημείο.</p></div><div class=paragraph><p>Στην περίπτωση αυτή, δεν υπάρχουν και πολλά που μπορείτε να κάνετε, εκτός από το να αρχίσετε να αλλάζετε εξαρτήματα στο μηχάνημα σας μέχρι να βρείτε αυτό που είναι υπαίτιο.</p></div></div><div class=sect4><h5 id=_μπορώ_να_διαγράψω_το_usrobj_όταν_τελειώσω>44.7.14.3. Μπορώ να διαγράψω το /usr/obj όταν τελειώσω;<a class=anchor href=#_μπορώ_να_διαγράψω_το_usrobj_όταν_τελειώσω></a></h5><div class=paragraph><p>Η σύντομη απάντηση είναι ναι.</p></div><div class=paragraph><p>Το <span class=filename>/usr/obj</span> περιέχει όλα τα αντικειμενικά αρχεία που παράγονται κατά τη διάρκεια της μεταγλώττισης. Συνήθως, ένα από τα πρώτα βήματα στην διαδικασία <code>make buildworld</code> είναι η διαγραφή αυτού του καταλόγου και η αναδημιουργία του. Στην περίπτωση αυτή, το να κρατήσετε τον κατάλογο <span class=filename>/usr/obj</span> αφού έχετε τελειώσει, δεν έχει και πολύ νόημα, ενώ αν τον σβήσετε θα κερδίσετε ένα μεγάλο κομμάτι ελεύθερου χώρου (την παρούσα στιγμή περίπου 2 GB).</p></div><div class=paragraph><p>Όμως, αν ξέρετε τι κάνετε, μπορείτε να οδηγήσετε το <code>make buildworld</code> να παραλείψει αυτό το βήμα. Αυτό θα επιταχύνει ιδιαίτερα τις νέες μεταγλωττίσεις, καθώς τα περισσότερα τμήματα του πηγαίου κώδικα δεν θα χρειάζονται ξανά μεταγλώττιση. Το μειονέκτημα είναι ότι ορισμένες φορές εμφανίζονται προβλήματα που έχουν σχέση με όχι και τόσο εμφανείς εξαρτήσεις, και μπορεί να οδηγήσουν σε μυστηριώδη αποτυχία της μεταγλώττισης. Τέτοια προβλήματα συχνά δημιουργούν "θόρυβο" στις λίστες του FreeBSD, όταν κάποιος χρήστης παραπονιέται ότι η μεταγλώττιση του αποτυγχάνει, χωρίς να αντιλαμβάνεται ότι αυτό οφείλεται στην προσπάθεια του να συντομεύσει την διαδικασία.</p></div></div><div class=sect4><h5 id=_μπορώ_να_συνεχίσω_μια_μεταγλώττιση_που_διέκοψα>44.7.14.4. Μπορώ να συνεχίσω μια μεταγλώττιση που διέκοψα;<a class=anchor href=#_μπορώ_να_συνεχίσω_μια_μεταγλώττιση_που_διέκοψα></a></h5><div class=paragraph><p>Αυτό εξαρτάται από το πόσο έχετε προχωρήσει στη διαδικασία μέχρι τη στιγμή που βρήκατε το πρόβλημα.</p></div><div class=paragraph><p><em>Σε γενικές γραμμές</em> (και αυτός δεν είναι κανόνας που ισχύει πάντα), η διεργασία του <code>make buildworld</code> μεταγλωττίζει νέα αντίγραφα βασικών εργαλείων (όπως τα <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a>, και <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>) καθώς και των βιβλιοθηκών συστήματος. Έπειτα εγκαθιστώνται αυτά τα εργαλεία και οι βιβλιοθήκες. Τα νέα εργαλεία και βιβλιοθήκες χρησιμοποιούνται έπειτα για να επαναμεταγλωττίσουν τους εαυτούς τους, και εγκαθίστανται ξανά. Ολόκληρο το σύστημα (το οποίο τώρα περιλαμβάνει και τα συνηθισμένα προγράμματα χρήστη όπως το <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a>) επαναμεταγλωττίζεται χρησιμοποιώντας τα νέα αρχεία του συστήματος.</p></div><div class=paragraph><p>Αν βρίσκεστε στο τελευταίο στάδιο, το οποίο θα το γνωρίζετε κοιτάζοντας την έξοδο που έχετε αποθηκεύσει, είναι σχετικά ασφαλές να κάνετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>... fix the problem ...
<span class=c># cd /usr/src</span>
<span class=c># make -DNO_CLEAN all</span></code></pre></div></div><div class=paragraph><p>Με τον τρόπο αυτό δεν θα αναιρέσετε την εργασία που έχει γίνει από το προηγούμενο <code>make buildworld</code>.</p></div><div class=paragraph><p>Αν δείτε το μήνυμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>--------------------------------------------------------------</span>
Building everything..
<span class=nt>--------------------------------------------------------------</span></code></pre></div></div><div class=paragraph><p>στην έξοδο της εντολής <code>make buildworld</code>, τότε είναι μάλλον ασφαλές να προχωρήσετε με αυτό τον τρόπο.</p></div><div class=paragraph><p>Αν δεν δείτε αυτό το μήνυμα, ή αν δεν είστε σίγουρος, τότε είναι καλύτερα να κάνετε πλήρη μεταγλώττιση παρά να μετανιώνετε αργότερα.</p></div></div><div class=sect4><h5 id=_πως_μπορώ_να_επιταχύνω_τη_μεταγλώττιση_του_βασικού_συστήματος>44.7.14.5. Πως μπορώ να επιταχύνω τη μεταγλώττιση του βασικού συστήματος;<a class=anchor href=#_πως_μπορώ_να_επιταχύνω_τη_μεταγλώττιση_του_βασικού_συστήματος></a></h5><div class=ulist><ul><li><p>Εκτελέστε την σε κατάσταση ενός χρήστη.</p></li><li><p>Βάλτε τους καταλόγους <span class=filename>/usr/src</span> και <span class=filename>/usr/obj</span> σε διαφορετικά συστήματα αρχείων τα οποία βρίσκονται και σε διαφορετικούς φυσικούς δίσκους. Αν είναι δυνατόν, βάλτε αυτούς τους δίσκους σε χωριστούς ελεγκτές.</p></li><li><p>Ακόμα καλύτερα, μοιράστε αυτά τα συστήματα αρχείων σε πολλαπλούς δίσκους, χρησιμοποιώντας το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> (concatenated disk driver, οδήγησης συνενωμένων δίσκων).</p></li><li><p>Απενεργοποιήστε το profiling (θέστε την μεταβλητή "NO_PROFILE=true" στο <span class=filename>/etc/make.conf</span>). Είναι σχεδόν σίγουρο ότι δεν το χρειάζεστε.</p></li><li><p>Στο αρχείο <span class=filename>/etc/make.conf</span>, θέστε το <code>CFLAGS</code> σε κάτι όπως <code>-O -pipe</code>. Η βελτιστοποίηση <code>-O2</code> χρειάζεται αρκετά περισσότερο χρόνο, και η διαφορά απόδοσης μεταξύ <code>-O</code> και <code>-O2</code> είναι συνήθως αμελητέα. Το <code>-pipe</code> επιτρέπει στον μεταγλωττιστή να χρησιμοποιήσει pipes για επικοινωνία αντί για προσωρινά αρχεία. Αυτό καταναλώνει περισσότερη μνήμη, αλλά χρησιμοποιεί λιγότερο το σκληρό δίσκο.</p></li><li><p>Χρησιμοποιήστε την επιλογή <code>-j<em>n</em></code> στο <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> ώστε να εκτελούνται παράλληλα πολλαπλές διεργασίες μεταγλώττισης. Αυτό συνήθως βοηθάει ακόμα και σε περίπτωση που έχετε μηχάνημα με ένα επεξεργαστή.</p></li><li><p>Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το σύστημα αρχείων στο οποίο είναι αποθηκευμένο το <span class=filename>/usr/src</span> με την επιλογή <code>noatime</code>. Αυτό αποτρέπει την καταγραφή ημερομηνίας / ώρας πρόσβασης στο σύστημα αρχείων. Κατά πάσα πιθανότητα, δεν χρειάζεστε αυτή την πληροφορία έτσι και αλλιώς.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o noatime /usr/src</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Το παράδειγμα προϋποθέτει ότι έχετε το <span class=filename>/usr/src</span> στο δικό του σύστημα αρχείων. Αν αυτό δεν συμβαίνει (αν είναι μέρος του <span class=filename>/usr</span> για παράδειγμα) θα χρειαστεί να χρησιμοποιήσετε αυτό το σημείο προσάρτησης, και όχι το <span class=filename>/usr/src</span>.</p></div></td></tr></tbody></table></div></li><li><p>Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το σύστημα αρχείων που περιέχει το <span class=filename>/usr/obj</span> με την επιλογή <code>async</code>. Με τον τρόπο αυτό, οι εγγραφές στο δίσκο θα γίνονται ασύγχρονα. Με άλλα λόγια, οι εγγραφές φαίνεται ότι ολοκληρώνονται άμεσα, ενώ η πραγματική εγγραφή στο δίσκο γίνεται λίγα δευτερόλεπτα αργότερα. Αυτό επιτρέπει την ομαδοποίηση των εγγραφών, το οποίο μπορεί να προσφέρει δραματική βελτίωση απόδοσης.</p><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Να έχετε υπόψιν σας ότι αυτή η επιλογή μπορεί να κάνει το σύστημα αρχείων σας πολύ πιο ευαίσθητο. Με την επιλογή αυτή, υπάρχει αυξημένη πιθανότητα το σύστημα αρχείων να βρεθεί σε μη επισκευάσιμη κατάσταση αν υπάρξει διακοπή ρεύματος.</p></div><div class=paragraph><p>Αν το σύστημα αρχείων περιέχει μόνο το <span class=filename>/usr/obj</span>, το παραπάνω δεν είναι πρόβλημα. Αν ωστόσο έχετε και άλλα πολύτιμα δεδομένα στο ίδιο σύστημα αρχείων, σιγουρευτείτε ότι έχετε ενημερωμένα αντίγραφα ασφαλείας πριν ενεργοποιήσετε αυτή την επιλογή.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o async /usr/obj</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Όπως και προηγουμένως, αν το <span class=filename>/usr/obj</span> δεν είναι σύστημα αρχείων από μόνο του, αντικαταστήστε το στο παράδειγμα με το όνομα του πραγματικού σημείου προσάρτησης.</p></div></td></tr></tbody></table></div></li></ul></div></div><div class=sect4><h5 id=_τι_να_κάνω_αν_κάτι_πάει_στραβά>44.7.14.6. Τι να κάνω αν κάτι πάει στραβά;<a class=anchor href=#_τι_να_κάνω_αν_κάτι_πάει_στραβά></a></h5><div class=paragraph><p>Σιγουρευτείτε ότι το περιβάλλον σας δεν έχει υπολείμματα από προηγούμενες μεταγλωττίσεις. Αυτό είναι αρκετά απλό.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags -R noschg /usr/obj/usr</span>
<span class=c># rm -rf /usr/obj/usr</span>
<span class=c># cd /usr/src</span>
<span class=c># make cleandir</span>
<span class=c># make cleandir</span></code></pre></div></div><div class=paragraph><p>Ναι, θα πρέπει να εκτελέσετε το <code>make cleandir</code> δύο φορές.</p></div><div class=paragraph><p>Επανεκκινήστε έπειτα όλη τη διαδικασία, ξεκινώντας με το <code>make buildworld</code>.</p></div><div class=paragraph><p>Αν έχετε ακόμα προβλήματα, στείλτε το μήνυμα λάθους και την έξοδο του <code>uname -a</code> στην <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>ηλεκτρονική λίστα γενικών ερωτήσεων του FreeBSD</a>. Να είστε προετοιμασμένοι να απαντήσετε επιπλέον ερωτήσεις σχετικά με την εγκατάσταση σας!</p></div></div></div></div><div class=sect2><h3 id=make-delete-old>44.8. Διαγραφή Παρωχημένων Αρχείων, Καταλόγων και Βιβλιοθηκών<a class=anchor href=#make-delete-old></a></h3><div class=paragraph><p>Κατά την συνεχή ανάπτυξη του FreeBSD είναι φυσιολογικό κάποια αρχεία κατά καιρούς να χαρακτηρίζονται ως παρωχημένα. Αυτό μπορεί να συμβεί αν οι λειτουργίες που παρείχαν υλοποιούνται πλέον διαφορετικά, αν ο ο αριθμός έκδοσης της βιβλιοθήκης έχει αλλάξει ή ακόμα και αν έχει διαγραφεί οριστικά από το σύστημα. Στα αρχεία αυτά περιλαμβάνονται επίσης βιβλιοθήκες κατάλογοι που πρέπει να διαγραφούν όταν γίνεται αναβάθμιση του συστήματος. Το όφελος για το χρήστη είναι ότι το σύστημα του δεν γεμίζει από παλιά αρχεία τα οποία καταλαμβάνουν άχρηστο χώρο στο μέσο αποθήκευσης και στο backup. Επιπρόσθετα, αν κάποια παλιά βιβλιοθήκη είχε προβλήματα σταθερότητας ή ασφάλειας θα πρέπει να την αναβαθμίσετε για να κρατήσετε το σύστημα σας σταθτερό και ασφαλές. Τα αρχεία, οι κατάλογοι και οι βιβλιοθήκες που θεωρούνται παρωχημένες φαίνονται στο <span class=filename>/usr/src/ObsoleteFiles.inc</span>. Οι παρακάτω οδηγίες θα σας βοηθήσουν να διαγράψετε αυτά τα αρχεία κατά τη διαδικασία αναβάθμισης του συστήματος.</p></div><div class=paragraph><p>Υποθέτουμε ότι χρησιμοποιείτε τα βήματα που περιγράφονται στο <a href=#canonical-build>Ο Κανονικός Τρόπος να Ενημερώσετε το Σύστημα σας</a>. Μετά την επιτυχή εκτέλση της εντολής <code>make installworld</code> και του <code>mergemaster</code> που ακολουθεί, θα πρέπει να ελέγξετε για παρωχημένα αρχεία και βιβλιοθήκες όπως φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make check-old</span></code></pre></div></div><div class=paragraph><p>Αν βρεθούν παρωχημένα αρχεία, μπορείτε να τα διαγράψετε με τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Δείτε το <span class=filename>/usr/src/Makefile</span> για περισσότερες ενδιαφέρουσες επιλογές της <code>make</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για κάθε αρχείο που θα διαγραφεί, θα σας ζητηθεί να επιβεβαιώσετε την ενέργεια. Μπορείτε να παραλείψετε την ερώτηση και να αφήσετε το σύστημα να διαγράψει αυτά τα αρχεία αυτόματα χρησιμοποιώντας την μεταβλητή του make <code>BATCH_DELETE_OLD_FILES</code> με τον τρόπο που φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -DBATCH_DELETE_OLD_FILES delete-old</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Η διαγραφή παρωχημένων αρχείων, θα προκαλέσει δυσλειτουργία των εφαρμογών που εξακολουθούν να βασίζονται σε αυτά. Αυτό συμβαίνει ιδιαίτερα σε παλιές βιβλιοθήκες. Στις περισσότερες περιπτώσεις, θα πρέπει να επαναμεταγλωττίσετε τα προγράμματα, ports ή βιβλιοθήκες που χρησιμοποιούσαν την παλιά βιβλιοθήκη πριν εκτελέσετε την εντολή <code>make delete-old-libs</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μπορείτε να βρείτε προγράμματα που ελέγχουν τις εξαρτήσεις των κοινόχρηστων βιβλιοθηκών στη Συλλογή των Ports, στο <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/libchk/>sysutils/libchk</a> ή <a class=package href=https://cgit.freebsd.org/ports/tree/sysuilts/bsdadminscripts/>sysuilts/bsdadminscripts</a>.</p></div><div class=paragraph><p>Οι παρωχημένες κοινόχρηστες βιβλιοθήκες μπορούν να δημιουργήσουν προβλήματα λόγω συγκρούσεων με νεώτερες εκδόσεις. Σε αυτές τις περιπτώσεις, θα δείτει μηνύματα όπως τα παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/usr/bin/ld: warning libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so may conflict with librpcsvc.so.5</code></pre></div></div><div class=paragraph><p>Για να επιλύσετε τέτοιου είδους προβλήματα, βρείτε ποιο port εγκατέστησε την βιβλιοθήκη:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info -W /usr/local/lib/libtiff.so</span>
/usr/local/lib/libtiff.so was installed by package tiff-3.9.4
<span class=c># pkg_info -W /usr/local/lib/libXext.so</span>
/usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</code></pre></div></div><div class=paragraph><p>Έπειτα, απεγκαταστήστε, επαναμεταγλωττίστε και επανεγκατασήστε το port. Για να αυτοματοποιήσετε αυτή τη διαδικασία μπορείτε να χρησιμοποιήσετε τα βοηθητικά προγράμματα <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> και <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a>. Αφού βεβαιωθείτε ότι οι παλιές βιβλιοθήκες δεν χρησιμοποιούνται πλέον από κανένα πρόγραμμα, μπορείτε να τις διαγράψετε με την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old-libs</span></code></pre></div></div></div><div class=sect2><h3 id=small-lan>44.9. Διαδικασία για Πολλαπλά Μηχανήματα<a class=anchor href=#small-lan></a></h3><div class=paragraph><p>Αν έχετε πολλαπλά μηχανήματα στα οποία πρόκειται να χρησιμοποιήσετε το ίδιο δέντρο πηγαίου κώδικα, είναι σπατάλη πόρων (δίσκου, δικτύου και επεξεργαστή) να επαναλαμβάνετε σε όλα τη διαδικασία ανάκτησης και μεταγλώττισης. Η λύση είναι να ορίσετε ένα μηχάνημα να εκτελεί το μεγαλύτερο μέρος της εργασίας, ενώ τα υπόλοιπα θα μπορούν να την ανακτούν μέσω NFS. Στην ενότητα αυτή θα παρουσιάσουμε ένα τρόπο με τον οποίο μπορεί να γίνει αυτό.</p></div><div class=sect3><h4 id=small-lan-preliminaries>44.9.1. Προκαταρκτικά<a class=anchor href=#small-lan-preliminaries></a></h4><div class=paragraph><p>Πρώτα από όλα, αναγνωρίστε το σετ των μηχανημάτων στα οποία σκοπεύετε να χρησιμοποιήσετε τα ίδια εκτελέσιμα. Θα ονομάσουμε αυτή την ομάδα <em>σετ μεταγλώττισης</em>. Κάθε μηχάνημα μπορεί να έχει δικό του προσαρμοσμένο πυρήνα, αλλά θα έχουν όλα τα ίδια εκτελέσιμα userland. Από το σετ αυτό, επιλέξτε ένα μηχάνημα το οποίο θα γίνει το <em>μηχάνημα μεταγλώττισης</em>. Θα είναι το μηχάνημα στο οποίο θα μεταγλωττίζεται το βασικό σύστημα και ο πυρήνας. Το ιδανικό είναι να επιλέξετε ένα γρήγορο μηχάνημα, στο οποίο να υπάρχει αρκετός ελεύθερος χρόνος στον επεξεργαστή για να εκτελεί τα <code>make buildworld</code> και <code>make buildkernel</code>. Θα πρέπει επίσης να επιλέξετε ένα <em>μηχάνημα δοκιμών</em> στο οποίο θα δοκιμάζετε τις ενημερώσεις λογισμικού πριν τις μεταφέρετε στην παραγωγή. Μπορεί να είναι και το ίδιο το μηχάνημα μεταγλώττισης, αλλά αυτό δεν είναι απαραίτητο.</p></div><div class=paragraph><p>Όλα τα μηχανήματα στο σετ μεταγλώττισης χρειάζεται να προσαρτήσουν το <span class=filename>/usr/obj</span> και το <span class=filename>/usr/src</span> από το ίδιο μηχάνημα, και στο ίδιο σημείο προσάρτησης. Το ιδανικό είναι αυτά τα δύο συστήματα αρχείων να βρίσκονται σε διαφορετικό φυσικό δίσκο στο μηχάνημα μεταγλώττισης, αλλά μπορείτε να τα προσαρτήσετε μέσω NFS ακόμα και σε αυτό το μηχάνημα. Αν έχετε πολλαπλά σετ μεταγλώττισης, το <span class=filename>/usr/src</span> θα πρέπει να βρίσκεται σε ένα από τα μηχανήματα μεταγλώττισης, και να προσαρτάται στα υπόλοιπα μέσω NFS.</p></div><div class=paragraph><p>Τέλος, βεβαιωθείτε ότι τα αρχεία <span class=filename>/etc/make.conf</span> και <span class=filename>/etc/src.conf</span> σε όλα τα μηχανήματα του σετ μεταγλώττισης, είναι ίδια με τα αντίστοιχα στο μηχάνημα μεταγλώττισης. Αυτό σημαίνει ότι το μηχάνημα μεταγλώττισης θα πρέπει να μεταγλωττίζει όλα τα τμήματα του βασικού συστήματος τα οποία θα εγκατασταθούν σε κάθε μηχάνημα του σετ. Επίσης, σε κάθε μηχάνημα στο σετ μεταγλώττισης θα πρέπει να οριστεί το όνομα του δικού του προσαρμοσμένου πυρήνα μέσω της μεταβλητής <code>KERNCONF</code> στο <span class=filename>/etc/make.conf</span>, ενώ και το μηχάνημα μεταγλώττισης θα πρέπει να έχει μια λίστα όλων των άλλων στο <code>KERNCONF</code>, ξεκινώντας από το δικό του. Το μηχάνημα μεταγλώττισης, θα πρέπει να έχει τα αρχεία ρύθμισης του πυρήνα όλων των άλλων μηχανημάτων στον κατάλογο <span class=filename>/usr/src/sys/arch/conf</span> αν πρόκειται να μεταγλωττίζει τους πυρήνες τους.</p></div></div><div class=sect3><h4 id=small-lan-base-system>44.9.2. Το Βασικό Σύστημα<a class=anchor href=#small-lan-base-system></a></h4><div class=paragraph><p>Έχοντας πραγματοποιήσει όλα τα παραπάνω, είστε έτοιμος να μεταγλωττίσετε τα πάντα. Μεταγλωττίστε τον πυρήνα και το βασικό σύστημα όπως περιγράψαμε στο <a href=#make-buildworld>Μεταγλωττίστε το Βασικό Σύστημα</a> χρησιμοποιώντας το μηχάνημα μεταγλώττισης, αλλά μην εγκαταστήσετε τίποτα. Μετά το τέλος της μεταγλώττισης, χρησιμοποιήστε το μηχάνημα δοκιμών και εγκαταστήστε τον πυρήνα που μόλις δημιουργήσατε. Αν το μηχάνημα αυτό προσαρτά το <span class=filename>/usr/src</span> και το <span class=filename>/usr/obj</span> μέσω NFS, όταν το επανεκκινήσετε σε κατάσταση ενός χρήστη, θα χρειαστεί να ενεργοποιήσετε το δίκτυο και να τα προσαρτήσετε. Ο ευκολότερος τρόπος για αυτό, είναι να εκκινήσετε σε κατάσταση πολλαπλών χρηστών και έπειτα να εκτελέσετε <code>shutdown now</code> για να μεταβείτε σε κατάσταση ενός χρήστη. Μόλις γίνει αυτό, μπορείτε να εγκαταστήσετε τον νέο πυρήνα και το βασικό σύστημα, και να εκτελέσετε το <code>mergemaster</code> όπως θα κάνατε συνήθως. Όταν τελειώσετε, επανεκκινήστε αυτό το μηχάνημα στην κανονική λειτουργία πολλαπλών χρηστών.</p></div><div class=paragraph><p>Όταν βεβαιωθείτε ότι όλα λειτουργούν σωστά στο μηχάνημα δοκιμών, χρησιμοποιήστε την ίδια διαδικασία για να εγκαταστήσετε το νέο λογισμικό σε κάθε ένα από τα υπόλοιπα μηχανήματα του σετ μεταγλώττισης.</p></div></div><div class=sect3><h4 id=small-lan-ports>44.9.3. Ports<a class=anchor href=#small-lan-ports></a></h4><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε τις ίδιες ιδέες και για το δέντρο των ports. Το πρώτο κρίσιμο βήμα είναι να προσαρτήσετε το <span class=filename>/usr/ports</span> από το ίδιο μηχάνημα, σε όλα τα μηχανήματα του σετ μεταγλώττισης. Μπορείτε έπειτα να ρυθμίσετε το <span class=filename>/etc/make.conf</span> ώστε να διαμοιράζονται τα distfiles. Θα πρέπει να θέσετε το <code>DISTDIR</code> σε ένα κοινόχρηστο κατάλογο, στον οποίο θα δώσετε δικαιώματα εγγραφής σε οποιοδήποτε χρήστη έχετε δηλώσει ως <code>root</code> στο NFS. Σε κάθε μηχάνημα θα πρέπει επίσης να οριστεί η μεταβλητή <code>WRKDIRPREFIX</code> ώστε να δείχνει σε ένα τοπικό κατάλογο. Τέλος, αν σκοπεύετε να μεταγλωττίζετε και να διανέμετε έτοιμα πακέτα, θα πρέπει να θέσετε την μεταβλητή <code>PACKAGES</code> σε ένα κατάλογο, όπως κάνατε και με την <code>DISTDIR</code>.</p></div></div></div></div></div><div class=sect1><h2 id=dtrace>Chapter 45. DTrace<a class=anchor href=#dtrace></a></h2><div class=sectionbody><div class=sect2><h3 id=dtrace-synopsis>45.1. Σύνοψη<a class=anchor href=#dtrace-synopsis></a></h3><div class=paragraph><p>Το DTrace, γνωστό επίσης ως Dynamic Tracing, είναι ένα εργαλείο το οποίο αναπτύχθηκε από την Sun™ για τον εντοπισμό προβλημάτων απόδοσης σε συστήματα που πρόκειται να χρησιμοποιηθούν ή χρησιμοποιούνται ήδη στην παραγωγή. Δεν πρόκειται για εργαλείο αποσφαλμάτωσης, αλλά για εργαλείο ανάλυσης πραγματικού χρόνου, με το οποίο μπορούν να εντοπιστούν προβλήματα απόδοσης και άλλες καταστάσεις.</p></div><div class=paragraph><p>Το DTrace είναι ένα θαυμάσιο εργαλείο profiling και διαθέτει εντυπωσιακό πλήθος χαρακτηριστικών για την διάγνωση προβλημάτων του συστήματος. Μπορεί επίσης να χρησιμοποιηθεί για να εκτελέσει από πριν έτοιμα scripts, με τα οποία μπορείτε να εκμεταλλευθείτε καλύτερα τις δυνατότητες του. Οι χρήστες μπορούν ακόμα να γράψουν και τα δικά τους βοηθητικά προγράμματα, χρησιμοποιώντας την Γλώσσα D που παρέχει το DTrace, και να προσαρμόσουν με αυτό τον τρόπο το profiling στις δικές τους ανάγκες.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα γνωρίζετε:</p></div><div class=ulist><ul><li><p>Τι είναι το DTrace και τι δυνατότητες παρέχει.</p></li><li><p>Τις διαφορές υλοποίησης μεταξύ του DTrace του Solaris™ και του FreeBSD.</p></li><li><p>Πως να ενεργοποιήσετε και να χρησιμοποιήσετε το DTrace στο FreeBSD.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε βασικές έννοιες του UNIX® και του FreeBSD (<a href=./#basics>Βασικές Έννοιες στο UNIX®</a>).</p></li><li><p>Να είστε εξοικειωμένος με τις βασικές διαδικασίες ρύθμισης και μεταγλώττισης προσαρμοσμένου πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li><li><p>Να είστε εξοικειωμένος με την ασφάλεια και τον τρόπο που αυτή σχετίζεται με το FreeBSD (<a href=./#security>Ασφάλεια</a>).</p></li><li><p>Να κατανοείτε πως μπορείτε να ανακτήσετε τον πηγαίο κώδικα του FreeBSD και να τον χρησιμοποιήσετε ώστε να επαναμεταγλωττίσετε το σύστημα σας (<a href=./#updating-upgrading>Ενημέρωση και Αναβάθμιση του FreeBSD</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Τη δεδομένη στιγμή, το DTrace θεωρείται ότι είναι σε πειραματικό στάδιο. Ορισμένες επιλογές μπορεί να υπολείπονται σε λειτουργικότητα, και κάποια τμήματα ίσως να μη λειτουργούν καθόλου. Με την πάροδο του χρόνου, οι παραπάνω δυνατότητες θα θεωρηθούν έτοιμες για χρήση σε μηχανήματα παραγωγής, και η παρούσα τεκμηρίωση θα ανανεωθεί ώστε να αντιπροσωπεύει αυτή την κατάσταση.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=dtrace-implementation>45.2. Διαφορές στην Υλοποίηση<a class=anchor href=#dtrace-implementation></a></h3><div class=paragraph><p>Αν και το DTrace στο FreeBSD είναι αρκετά όμοιο με αυτό του Solaris™, υπάρχουν κάποιες διαφορές που θα πρέπει να τις εξηγήσουμε πριν συνεχίσουμε. Η μεγαλύτερη διαφορά που θα παρατηρήσουν οι χρήστες, είναι ότι στο FreeBSD το DTrace πρέπει να ενεργοποιηθεί χειροκίνητα. Υπάρχουν διάφορες επιλογές και αρθρώματα για τον πυρήνα που πρέπει να ενεργοποιηθούν ώστε το DTrace να λειτουργεί σωστά. Θα εξηγήσουμε αργότερα αυτές τις ρυθμίσεις.</p></div><div class=paragraph><p>Η επιλογή <code>DDB_CTF</code> του πυρήνα χρησιμοποιείται για να ενεργοποιήσει την υποστήριξη φορτώματος των δεδομένων CTF από τον πυρήνα και τα αρθρώματα του. Το CTF είναι το Compact C Type format του Solaris™, το οποίο ενθυλακώνει μια ελαττωμένη μορφή πληροφοριών αποσφαλμάτωσης (debugging), όμοια με το DWARF και τα stabs. Αυτά τα δεδομένα CTF προστίθενται στα εκτελέσιμα μέσω των εργαλείων <code>ctfconvert</code> και <code>ctfmerge</code>. Το βοηθητικό πρόγραμμα <code>ctfconvert</code> ερμηνεύει τα τμήματα των DWARFELF που περιέχουν πληροφορίες debug (δημιουργούνται από το μεταγλωττιστή), και το <code>ctfmerge</code> συγχωνεύει τα τμήματα CTF και ELF από τα αντικείμενα σε άλλα εκτελέσιμα ή κοινόχρηστες βιβλιοθήκες. Περισσότερες πληροφορίες για την ενεργοποίηση των παραπάνω στη μεταγλώττιση του πυρήνα και του συστήματος του FreeBSD, θα δούμε παρακάτω.</p></div><div class=paragraph><p>Στο FreeBSD κάποιοι παροχείς είναι διαφορετικοί σε σχέση με το Solaris™. Ο πιο αξιοσημείωτος είναι ο παροχέας <code>dtmalloc</code> ο οποίος επιτρέπει το tracing του <code>malloc()</code> ανάλογα με τον τύπο του, στον πυρήνα του FreeBSD.</p></div><div class=paragraph><p>Μόνο ο <code>root</code> μπορεί να χρησιμοποιήσει το DTrace στο FreeBSD. Αυτό σχετίζεται με διαφορές στην ασφάλεια, καθώς το Solaris™ διαθέτει κάποιους ελέγχους ασφάλειας χαμηλού επιπέδου, οι οποίοι δεν υπάρχουν ακόμα στο FreeBSD. Για το λόγο αυτό, η χρήση της συσκευής <span class=filename>/dev/dtrace/dtrace</span> απαγορεύεται αυστηρά για όλους τους χρήστες εκτός από τον <code>root</code>.</p></div><div class=paragraph><p>Τέλος, το λογισμικό DTrace βρίσκεται υπό την άδεια CDDL της Sun™. Μπορείτε να διαβάσετε το κείμενο της άδειας <code>Common Development and Distribution License</code> στο FreeBSD, στο αρχείο <span class=filename>/usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE</span> ή να το διαβάσετε online στη διεύθυνση <a href=http://www.opensolaris.org/os/licensing>http://www.opensolaris.org/os/licensing</a>.</p></div><div class=paragraph><p>Η άδεια ουσιαστικά σημαίνει ότι ένας πυρήνας FreeBSD με τις επιλογές του DTrace, εξακολουθεί να βρίσκεται υπό την άδεια BSD. Ωστόσο το CDDL εμπλέκεται τη στιγμή που γίνεται διανομή των αρθρωμάτων σε δυαδική μορφή, ή τη στιγμή που φορτώνονται.</p></div></div><div class=sect2><h3 id=dtrace-enable>45.3. Ενεργοποίηση της Υποστήριξης DTrace<a class=anchor href=#dtrace-enable></a></h3><div class=paragraph><p>Για να ενεργοποιήσετε την υποστήριξη για το DTrace, προσθέστε τις ακόλουθες γραμμές στο αρχείο ρυθμίσεων του πυρήνα:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_HOOKS
options         DDB_CTF</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι χρήστες της αρχιτεκτονικής AMD64 θα θέλουν να προσθέσουν την ακόλουθη γραμμή στο αρχείο ρυθμίσεων του πυρήνα τους:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_FRAME</pre></div></div><div class=paragraph><p>Η επιλογή αυτή παρέχει υποστήριξη για τη λειτουργία FBT. Το DTrace μπορεί να λειτουργήσει και χωρίς αυτήν. Ωστόσο, θα παρέχει περιορισμένη υποστήριξη για function boundary tracing.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Όλος ο πηγαίος κώδικας θα πρέπει να μεταγλωττιστεί ξανά με τις επιλογές CTF. Για να γίνει αυτό, μεταγλωττίστε ξανά το FreeBSD χρησιμοποιώντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>

<span class=c># make WITH_CTF=1 kernel</span></code></pre></div></div><div class=paragraph><p>Θα χρειαστεί να επανεκκινήσετε το σύστημα.</p></div><div class=paragraph><p>Μετά την επανεκκίνηση, και με τον νέο πυρήνα φορτωμένο πλέον στη μνήμη, θα πρέπει να προσθέσετε υποστήριξη για το κέλυφος Korn. Αυτό απαιτείται, καθώς τα εργαλεία DTrace περιλαμβάνουν διάφορα βοηθητικά προγράμματα τα οποία είναι γραμμένα σε <code>ksh</code>. Εγκαταστήστε το port <a class=package href=https://cgit.freebsd.org/ports/tree/shells/ksh93/>shells/ksh93</a>. Μπορείτε επίσης να εκτελέσετε αυτά τα εργαλεία και μέσω του <a class=package href=https://cgit.freebsd.org/ports/tree/shells/pdksh/>shells/pdksh</a> ή του <a class=package href=https://cgit.freebsd.org/ports/tree/shells/mksh/>shells/mksh</a>.</p></div><div class=paragraph><p>Τέλος, ανακτήστε την τρέχουσα σειρά εργαλείων DTrace. Η τελευταία έκδοση διατίθεται στην τοποθεσία <a href=http://www.opensolaris.org/os/community/dtrace/dtracetoolkit/>http://www.opensolaris.org/os/community/dtrace/dtracetoolkit/</a>. Διατίθεται και πρόγραμμα εγκατάστασης, το οποίο δεν είναι ωστόσο απαραίτητο να εκτελέσετε προκειμένου να χρησιμοποιήσετε τα εργαλεία.</p></div></div><div class=sect2><h3 id=dtrace-using>45.4. Χρησιμοποιώντας το DTrace<a class=anchor href=#dtrace-using></a></h3><div class=paragraph><p>Πριν χρησιμοποιήσετε τις λειτουργίες του DTrace, θα πρέπει να υπάρχει η αντίστοιχη συσκευή. Για να φορτώσετε τη συσκευή, θα πρέπει να δώσετε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload dtraceall</span></code></pre></div></div><div class=paragraph><p>Θα πρέπει να έχετε πλέον υποστήριξη DTrace. Για να δείτε όλα τα probes, θα πρέπει να εκτελέσετε ως διαχειριστής την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dtrace -l | more</span></code></pre></div></div><div class=paragraph><p>Όλη η έξοδος περνάει μέσω του βοηθητικού προγράμματος <code>more</code>, διαφορετικά γρήγορα θα υπερχείλιζε την προσωρινή μνήμη της οθόνης. Στο σημείο αυτό, θα πρέπει να θεωρηθεί ότι το DTrace λειτουργεί. Είναι πλέον ώρα να εξετάσουμε αυτή τη σειρά εργαλείων.</p></div><div class=paragraph><p>Η σειρά των εργαλείων είναι μια συλλογή από έτοιμα scripts που εκτελούνται με το DTrace ώστε να συλλέξουν πληροφορίες σχετικά με το σύστημα. Υπάρχουν scripts που ελέγχουν για ανοικτά αρχεία, τη μνήμη, τη χρήση της CPU και πολλά ακόμα. Κάντε εξαγωγή των scripts με την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gunzip -c DTraceToolkit* | tar xvf -</span></code></pre></div></div><div class=paragraph><p>Μετακινηθείτε στον κατάλογο που τα αποσυμπιέσατε με την εντολή <code>cd</code> και αλλάξτε τα δικαιώματα εκτέλεσης σε όλα τα αρχεία, όπως στα αρχεία με τα μικρά γράμματα, σε <code>755</code>.</p></div><div class=paragraph><p>Θα χρειαστεί να γίνουν αλλαγές στο περιεχόμενο σε όλα τα scripts. Όσα περιέχουν το <span class=filename>/usr/bin/ksh</span> θα πρέπει να αλλαχθούν σε <span class=filename>/usr/local/bin/ksh</span>, τα άλλα που περιέχουν το <span class=filename>/usr/bin/sh</span> θα πρέπει να αλλαχθούν σε <span class=filename>/bin/sh</span>, και τέλος αυτά που περιέχουν το <span class=filename>/usr/bin/perl</span> θα πρέπει να αλλαχθούν σε <span class=filename>/usr/local/bin/perl</span>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Στο σημείο αυτό είναι σημαντικό να υπενθυμίσουμε στον αναγνώστη ότι η υποστήριξη DTrace στο FreeBSD είναι <em>ατελής</em> και πειραματική. Πολλά από αυτά τα scripts δεν θα λειτουργήσουν, καθώς είναι είτε πολύ προσανατολισμένα στο Solaris™, ή χρησιμοποιούν probes τα οποία δεν υποστηρίζονται τη δεδομένη στιγμή.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Τη στιγμή που γράφονται αυτές οι γραμμές, μόνο δύο scripts από τη σειρά εργαλείων του DTrace υποστηρίζονται πλήρως στο FreeBSD: το <span class=filename>hotkernel</span> και το <span class=filename>procsystime</span>. Αυτά τα δύο θα εξερευνήσουμε στα επόμενα τμήματα αυτής της ενότητας.</p></div><div class=paragraph><p>Το <span class=filename>hotkernel</span> έχει σχεδιαστεί να αναγνωρίζει ποια συνάρτηση καταναλώνει το μεγαλύτερο χρόνο στον πυρήνα. Εκτελώντας το υπό κανονικές συνθήκες, θα δείτε έξοδο παρόμοια με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./hotkernel</span>
Sampling... Hit Ctrl-C to end.</code></pre></div></div><div class=paragraph><p>Ο διαχειριστής του συστήματος θα πρέπει να χρησιμοποιήσει το συνδυασμό πλήκτρων <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span> για να σταματήσει τη διεργασία. Με τον τερματισμό του, το script θα απεικονίσει μια σειρά από συναρτήσεις του πυρήνα και πληροφορίες σχετικά με το χρόνο τους, ταξινομώντας τις σε αύξουσα σειρά ανάλογα με το χρόνο:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kernel<span class=sb>`</span>_thread_lock_flags                                   2   0.0%
0xc1097063                                                  2   0.0%
kernel<span class=sb>`</span>sched_userret                                        2   0.0%
kernel<span class=sb>`</span>kern_select                                          2   0.0%
kernel<span class=sb>`</span>generic_copyin                                       3   0.0%
kernel<span class=sb>`</span>_mtx_assert                                          3   0.0%
kernel<span class=sb>`</span>vm_fault                                             3   0.0%
kernel<span class=sb>`</span>sopoll_generic                                       3   0.0%
kernel<span class=sb>`</span>fixup_filename                                       4   0.0%
kernel<span class=sb>`</span>_isitmyx                                             4   0.0%
kernel<span class=sb>`</span>find_instance                                        4   0.0%
kernel<span class=sb>`</span>_mtx_unlock_flags                                    5   0.0%
kernel<span class=sb>`</span>syscall                                              5   0.0%
kernel<span class=sb>`</span>DELAY                                                5   0.0%
0xc108a253                                                  6   0.0%
kernel<span class=sb>`</span>witness_lock                                         7   0.0%
kernel<span class=sb>`</span>read_aux_data_no_wait                                7   0.0%
kernel<span class=sb>`</span>Xint0x80_syscall                                     7   0.0%
kernel<span class=sb>`</span>witness_checkorder                                   7   0.0%
kernel<span class=sb>`</span>sse2_pagezero                                        8   0.0%
kernel<span class=sb>`</span>strncmp                                              9   0.0%
kernel<span class=sb>`</span>spinlock_exit                                       10   0.0%
kernel<span class=sb>`</span>_mtx_lock_flags                                     11   0.0%
kernel<span class=sb>`</span>witness_unlock                                      15   0.0%
kernel<span class=sb>`</span>sched_idletd                                       137   0.3%
0xc10981a5                                              42139  99.3%</code></pre></div></div><div class=paragraph><p>Το script αυτό λειτουργεί επίσης με αρθρώματα του πυρήνα. Για να χρησιμοποιήσετε αυτό το χαρακτηριστικό, εκτελέστε το με την επιλογή <code>-m</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./hotkernel -m</span>
Sampling... Hit Ctrl-C to end.
^C
MODULE                                                  COUNT   PCNT
0xc107882e                                                  1   0.0%
0xc10e6aa4                                                  1   0.0%
0xc1076983                                                  1   0.0%
0xc109708a                                                  1   0.0%
0xc1075a5d                                                  1   0.0%
0xc1077325                                                  1   0.0%
0xc108a245                                                  1   0.0%
0xc107730d                                                  1   0.0%
0xc1097063                                                  2   0.0%
0xc108a253                                                 73   0.0%
kernel                                                    874   0.4%
0xc10981a5                                             213781  99.6%</code></pre></div></div><div class=paragraph><p>Το <span class=filename>procsystime</span> script συλλαμβάνει και τυπώνει τον χρόνο των κλήσεων συστήματος για μια συγκεκριμένη διεργασία μέσω του PID ή του ονόματος της. Στο παρακάτω παράδειγμα έχουμε ξεκινήσει μια νέα διεργασία του <span class=filename>/bin/csh</span>. Εκτελέσαμε το <span class=filename>procsystime</span> και το αφήσαμε στην αναμονή καθώς γράφαμε μερικές εντολές στο <code>csh</code> που είχαμε ανοίξει. Αυτά είναι τα αποτελέσματα της δοκιμής μας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./procsystime -n csh</span>
Tracing... Hit Ctrl-C to end...
^C

Elapsed Times <span class=k>for </span>processes csh,

         SYSCALL          TIME <span class=o>(</span>ns<span class=o>)</span>
          getpid               6131
       sigreturn               8121
           close              19127
           fcntl              19959
             dup              26955
         setpgid              28070
            <span class=nb>stat              </span>31899
       setitimer              40938
           wait4              62717
       sigaction              67372
     sigprocmask             119091
    gettimeofday             183710
           write             263242
          execve             492547
           ioctl             770073
           vfork            3258923
      sigsuspend            6985124
            <span class=nb>read         </span>3988049784</code></pre></div></div><div class=paragraph><p>Όπως φαίνεται, η κλήση του συστήματος για ανάγνωση (<code>read()</code>) είναι αυτή που καταναλώνει τον περισσότερο χρόνο σε νανοδευτερόλεπτα, ενώ το λιγότερο τον καταναλώνει η κλήση συστήματος <code>getpid()</code>.</p></div></div><div class=sect2><h3 id=dtrace-language>45.5. Η Γλώσσα D<a class=anchor href=#dtrace-language></a></h3><div class=paragraph><p>Η σειρά εργαλείων DTrace, περιλαμβάνει αρκετά scripts γραμμένα στην ειδική γλώσσα του DTrace. Η γλώσσα αυτή ονομάζεται "η γλώσσα D" στην τεκμηρίωση της Sun™, και είναι αρκετά όμοια με τη C++. Αναλυτική περιγραφή αυτής της γλώσσας είναι πέρα από τους σκοπούς αυτού του κειμένου. Υπάρχει ενεργή συζήτηση σχετικά με αυτή, στη διεύθυνση <a href=http://wikis.sun.com/display/DTrace/Documentation>http://wikis.sun.com/display/DTrace/Documentation</a>.</p></div><div class=paragraph><p>path: "/books/handbook/partiv/"
---
:leveloffset: +1</p></div></div></div></div><h1 id=serialcomms class=sect0>Part IV: Serial Communications<a class=anchor href=#serialcomms></a></h1><div class=sect1><h2 id=serial-synopsis>Chapter 46. Σύνοψη<a class=anchor href=#serial-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Το UNIX® πάντοτε υποστήριζε σειριακές επικοινωνίες. Για την ακρίβεια, τα πρώτα UNIX® μηχανήματα βασίζονταν σε σειριακές γραμμές για την είσοδο και έξοδο στο χρήστη. Τα πράγματα ωστόσο έχουν αλλάξει πολύ από τις μέρες που το συνηθισμένο "τερματικό" αποτελούνταν από ένα σειριακό εκτυπωτή 10 χαρακτήρων το δευτερόλεπτο και ένα πληκτρολόγιο. Το κεφάλαιο αυτό θα καλύψει κάποιους από τους τρόπους σειριακής επικοινωνίας που χρησιμοποιούνται από το FreeBSD.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να συνδέσετε τερματικά στο FreeBSD σύστημα σας.</p></li><li><p>Πως να χρησιμοποιήσετε ένα modem για να συνδεθείτε σε απομακρυσμένα συστήματα.</p></li><li><p>Πως να επιτρέψετε σε απομακρυσμένους χρήστες να συνδεθούν στο σύστημα σας μέσω modem.</p></li><li><p>Πως να εκκινήσετε το σύστημα σας μέσω σειριακής κονσόλας.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να ξέρετε πως θα ρυθμίσετε και θα εγκαταστήσετε ένα νέο πυρήνα (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li><li><p>Να κατανοείτε τις άδειες και διεργασίες του UNIX® (<a href=./#basics>Βασικές Έννοιες στο UNIX®</a>).</p></li><li><p>Να έχετε πρόσβαση στο τεχνικό εγχειρίδιο του υλικού σας (modem ή κάρτα πολλαπλών σειριακών θυρών) που θέλετε να χρησιμοποιήσετε στο FreeBSD.</p></li></ul></div></div></div><div class=sect1><h2 id=serial>Chapter 47. Εισαγωγή<a class=anchor href=#serial></a></h2><div class=sectionbody><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα αρχεία συσκευών των σειριακών θυρών μετονομάστηκαν από <span class=filename>/dev/cuadN</span> σε <span class=filename>/dev/cuauN</span> και από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν την παρακάτω τεκμηρίωση σύμφωνα με τις παραπάνω αλλαγές.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=serial-terminology>47.1. Ορολογία<a class=anchor href=#serial-terminology></a></h3><div class=dlist><dl><dt class=hdlist1>bps</dt><dd><p>Bits Ανά Δευτερόλεπτο - ο ρυθμός μετάδοσης των δεδομένων</p></dd><dt class=hdlist1>DTE</dt><dd><p>Data Terminal Equipment, Τερματικός Εξοπλισμός Δεδομένων - για παράδειγμα, ο υπολογιστής σας</p></dd><dt class=hdlist1>DCE</dt><dd><p>Data Communications Equipment, Εξοπλισμός Επικοινωνίας Δεδομένων - το modem σας</p></dd><dt class=hdlist1>RS-232</dt><dd><p>Πρότυπο της EIA για το υλικό που χρησιμοποιείται στις σειριακές επικοινωνίες</p></dd></dl></div><div class=paragraph><p>Όταν αναφερόμαστε στο ρυθμό μετάδοσης δεδομένων επικοινωνίας, δεν χρησιμοποιούμε πάντοτε τον όρο "baud". Το baud αναφέρεται στον αριθμό των μεταβάσεων του ηλεκτρικού σήματος στη μονάδα του χρόνου, ενώ κανονικά πρέπει να χρησιμοποιείται το "bps" (bits ανά δευτερόλεπτο) που είναι ο <em>σωστός</em> όρος (η τουλάχιστον δεν φαίνεται να ενοχλεί πολύ τους σχολαστικούς).</p></div></div><div class=sect2><h3 id=serial-cables-ports>47.2. Θύρες και Καλώδια<a class=anchor href=#serial-cables-ports></a></h3><div class=paragraph><p>Για να συνδέσετε ένα modem ή τερματικό στο FreeBSD σύστημα σας, θα χρειαστείτε μια σειριακή θύρα στον υπολογιστή σας, και το κατάλληλο καλώδιο για να συνδέσετε τη σειριακή συσκευή σας. Αν είστε ήδη εξοικειωμένος με το υλικό σας και το καλώδιο που απαιτείται, μπορείτε με ασφάλεια να παραλείψετε αυτή την ενότητα.</p></div><div class=sect3><h4 id=term-cables>47.2.1. Καλώδια<a class=anchor href=#term-cables></a></h4><div class=paragraph><p>Υπάρχουν αρκετοί διαφορετικοί τύποι σειριακών καλωδίων. Οι δύο πιο κοινοί τύποι για τους σκοπούς μας, είναι τα καλώδια τύπου null-modem και τα τυποποιημένα καλώδια RS-232 (γνωστά και ως "ευθείες"). Η τεκμηρίωση του υλικού σας θα πρέπει να περιγράφει τον τύπο του καλωδίου που απαιτείται.</p></div><div class=sect4><h5 id=term-cables-null>47.2.1.1. Καλώδια Τύπου Null-modem<a class=anchor href=#term-cables-null></a></h5><div class=paragraph><p>Ένα καλώδιο τύπου null-modem, μεταφέρει απευθείας κάποια σήματα όπως η "Γείωση Σήματος (SG)", αλλά αντιστρέφει τις συνδέσεις σε κάποια άλλα. Για παράδειγμα, ο ακροδέκτης "Μετάδοσης Δεδομένων" (γνωστός και ως TD) της μιας πλευράς, συνδέεται με τον ακροδέκτη "Λήψης Δεδομένων" (γνωστός και ως RD) της άλλης.</p></div><div class=paragraph><p>Μπορείτε επίσης να φτιάξετε το δικό σας καλώδιο τύπου null-modem (π.χ. για λόγους ποιότητας) για χρήση με τερματικά. Ο παρακάτω πίνακας δείχνει τα <a href=#serialcomms-signal-names>σήματα</a> του RS-232 και τους αριθμούς των ακροδεκτών σε ένα συνδέτη DB-25. Σημειώστε επίσης ότι το πρότυπο ορίζει απευθείας σύνδεση των ακροδεκτών 1 της κάθε άκρης. Πρόκειται για τον ακροδέκτη της <em>Προστατευτικής Γείωσης</em>, αλλά συχνά η σύνδεση του παραλείπεται. Μερικά τερματικά λειτουργούν κανονικά χρησιμοποιώντας μόνο τους ακροδέκτες 2, 3 και 7, ενώ κάποιοι άλλα απαιτούν διαφορετικές ρυθμίσεις σε σχέση με τα παραδείγματα που φαίνονται παρακάτω.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 4. Καλώδιο Null-Modem DB-25 σε DB-25</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Σήμα</th><th class="tableblock halign-left valign-top">Ακροδέκτης #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Ακροδέκτης #</th><th class="tableblock halign-left valign-top">Σήμα</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr></tbody></table><div class=paragraph><p>Παρακάτω φαίνονται δύο διατάξεις που είναι πιο κοινές στις μέρες μας.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 5. Καλώδιο Null-Modem DB-9 σε DB-9</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Σήμα</th><th class="tableblock halign-left valign-top">Ακροδέκτης #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Ακροδέκτης #</th><th class="tableblock halign-left valign-top">Σήμα</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 6. Καλώδιο Null-Modem DB-9 σε DB-25</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Σήμα</th><th class="tableblock halign-left valign-top">Ακροδέκτης #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Ακροδέκτης #</th><th class="tableblock halign-left valign-top">Σήμα</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>συνδέεται στο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όταν ένας ακροδέκτης σε μια άκρη χρειάζεται να συνδεθεί με δύο ακροδέκτες στην άλλη, συνήθως ενώνουμε τους ακροδέκτες μεταξύ τους στη μια άκρη με ένα μικρό καλώδιο, και χρησιμοποιούμε ένα μακρύτερο καλώδιο για την ένωση με την άλλη άκρη.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η παραπάνω διάταξη φαίνεται να είναι η πιο διαδεδομένη. Σε μια παραλλαγή (που εξηγείται στο βιβλίο <em>Το RS-232 με Απλά Βήματα</em>), το SG συνδέεται στο SG, το TD συνδέεται στο RD, τα RTS και CTS συνδέονται στο DCD, το DTR συνδέεται στο DSR, και αντίστροφα.</p></div></div><div class=sect4><h5 id=term-cables-std>47.2.1.2. Τυποποιημένα Καλώδια RS-232C<a class=anchor href=#term-cables-std></a></h5><div class=paragraph><p>Ένα τυποποιημένο σειριακό καλώδιο RS-232C, μεταφέρει όλα τα σήματα απευθείας από τη μια άκρη στην άλλη, χωρίς καμιά αλλαγή στους ακροδέκτες. Αυτό απλά σημαίνει ότι ο ακροδέκτης "Μετάδοσης Δεδομένων (TD)" της μιας άκρης, συνδέεται στον ακροδέκτη "Μετάδοσης Δεδομένων (TD)" της άλλης άκρης. Αυτό είναι και το είδος του καλωδίου που θα χρησιμοποιήσετε για να συνδέσετε ένα modem στο FreeBSD σύστημα σας, και είναι επίσης κατάλληλο για ορισμένα τερματικά.</p></div></div></div><div class=sect3><h4 id=term-ports>47.2.2. Θύρες<a class=anchor href=#term-ports></a></h4><div class=paragraph><p>Οι σειριακές θύρες είναι οι συσκευές που μεταφέρουν τα δεδομένα μεταξύ του FreeBSD συστήματος και του τερματικού. Η ενότητα αυτή περιγράφει τα είδη των θυρών που υπάρχουν, και πως τα χειρίζεται το FreeBSD.</p></div><div class=sect4><h5 id=term-portkinds>47.2.2.1. Είδη Θυρών<a class=anchor href=#term-portkinds></a></h5><div class=paragraph><p>Υπάρχουν διάφορα είδη σειριακών θυρών. Πριν αγοράσετε ή κατασκευάσετε κάποιο καλώδιο, θα πρέπει να βεβαιωθείτε ότι ταιριάζει με τη θύρα του τερματικού και του FreeBSD συστήματος σας.</p></div><div class=paragraph><p>Τα περισσότερα τερματικά διαθέτουν θύρες DB-25. Οι προσωπικοί υπολογιστές, συμπεριλαμβανομένων και αυτών που εκτελούν FreeBSD, μπορεί να έχουν θύρες τύπου DB-25 ή DB-9. Αν διαθέτετε κάρτα πολλαπλών σειριακών θυρών στον υπολογιστή σας, μπορεί να διαθέτει θύρες τύπου RJ-12 ή RJ-45.</p></div><div class=paragraph><p>Δείτε την τεκμηρίωση που συνοδεύει το υλικό σας, για τις τεχνικές προδιαγραφές της θύρας που χρησιμοποιεί. Συνήθως μπορείτε να βγάλετε συμπέρασμα αν απλώς κοιτάξετε την υποδοχή.</p></div></div><div class=sect4><h5 id=term-portnames>47.2.2.2. Ονόματα Θυρών<a class=anchor href=#term-portnames></a></h5><div class=paragraph><p>Στο FreeBSD, έχετε πρόσβαση σε κάθε σειριακή θύρα μέσω μιας καταχώρισης στον κατάλογο <span class=filename>/dev</span>. Υπάρχουν δύο διαφορετικά είδη καταχωρίσεων:</p></div><div class=ulist><ul><li><p>Οι θύρες που μπορούν να χρησιμοποιηθούν για είσοδο στο σύστημα, ονομάζονται <span class=filename>/dev/ttyuN</span> όπου το <em>N</em> είναι ο αριθμός της θύρας (η αρίθμηση ξεκινάει από το μηδέν). Γενικά, οι θύρες αυτές προορίζονται για σύνδεση με τερματικά. Οι θύρες εισόδου απαιτούν να είναι ενεργό το σήμα ανίχνευσης φέροντος (DCD) στη σειριακή γραμμή, προκειμένου να λειτουργήσουν σωστά.</p></li><li><p>Οι θύρες κλήσης ή εξόδου, ονομάζονται <span class=filename>/dev/cuauN</span>. Οι θύρες αυτές δεν χρησιμοποιούνται συνήθως για τερματικά, αλλά για modems. Μπορείτε να χρησιμοποιήσετε αυτή τη θύρα για κάποιο τερματικό που δεν υποστηρίζει το σήμα ανίχνευσης φέροντος.</p></li></ul></div><div class=paragraph><p>Αν έχετε συνδέσει ένα τερματικό στην πρώτη σειριακή θύρα (που στο MS-DOS® αναφέρεται ως <span class=filename>COM1</span>), θα πρέπει να χρησιμοποιήσετε την συσκευή <span class=filename>/dev/ttyu0</span> για να αναφερθείτε στο τερματικό. Αν το τερματικό είναι στη δεύτερη σειριακή θύρα (που είναι επίσης γνωστή ως <span class=filename>COM2</span>) χρησιμοποιήστε τη συσκευή <span class=filename>/dev/ttyu1</span>, κ.ο.κ.</p></div></div></div></div><div class=sect2><h3 id=_ρύθμιση_του_πυρήνα_3>47.3. Ρύθμιση του Πυρήνα<a class=anchor href=#_ρύθμιση_του_πυρήνα_3></a></h3><div class=paragraph><p>Το FreeBSD από προεπιλογή υποστηρίζει τέσσερις σειριακές θύρες. Στον κόσμο του MS-DOS® οι θύρες αυτές είναι γνωστές ως: <span class=filename>COM1</span>, <span class=filename>COM2</span>, <span class=filename>COM3</span>, και <span class=filename>COM4</span>. Το FreeBSD αυτή τη στιγμή υποστηρίζει "κουτές" σειριακές κάρτες πολλαπλών θυρών, όπως τις BocaBoard 1008 και 2016, όπως και πιο ευφυής κάρτες, όπως αυτές που κατασκευάζονται από την Digiboard και την Stallion Technologies. Ο προεπιλεγμένος πυρήνας ωστόσο, εκτελεί ανίχνευση μόνο για τις τυπικές σειριακές (COM) θύρες.</p></div><div class=paragraph><p>Για να δείτε αν ο πυρήνας σας αναγνωρίζει οποιαδήποτε από τις σειριακές θύρες, παρατηρήστε τα μηνύματα κατά τη διάρκεια εκκίνησης του συστήματος, ή χρησιμοποιήστε την εντολή <code>/sbin/dmesg</code> για να ξαναδείτε τα μηνύματα του πυρήνα κατά τη διάρκεια της εκκίνησης. Πιο συγκεκριμένα, αναζητήστε τα μηνύματα που ξεκινούν με τους χαρακτήρες <code>sio</code>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Για να δείτε μόνο τα μηνύματα που περιέχουν τη λέξη <code>sio</code>, χρησιμοποιήστε την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dmesg | grep &#39;sio&#39;</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Για παράδειγμα, σε ένα σύστημα με τέσσερις σειριακές θύρες, τα μηνύματα του πυρήνα που σχετίζονται με αυτές φαίνονται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: <span class=nb>type </span>16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: <span class=nb>type </span>16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: <span class=nb>type </span>16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>Αν ο πυρήνας σας δεν αναγνωρίζει όλες τις σειριακές σας θύρες, πιθανόν να χρειαστεί να τον ρυθμίσετε χρησιμοποιώντας το αρχείο <span class=filename>/boot/device.hints</span>. Μπορείτε επίσης να μετατρέψετε σε σχόλιο (ή και να διαγράψετε τελείως) γραμμές που αναφέρονται σε συσκευές που δεν υπάρχουν στο σύστημα σας.</p></div><div class=paragraph><p>Παρακαλούμε ανατρέξτε στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> για περισσότερες πληροφορίες σχετικά με τις σειριακές θύρες και τις ρυθμίσεις των καρτών πολλαπλών σειριακών θυρών. Αν χρησιμοποιείτε αρχείο ρυθμίσεων που προέρχεται από κάποια παλαιότερη έκδοση του FreeBSD, θα πρέπει να είστε ιδιαίτερα προσεκτικοί, καθώς κάποιες από τις επιλογές των συσκευών και η σύνταξη τους έχουν αλλάξει στις νεότερες εκδόσεις.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το <code>port IO_COM1</code> υποκαθιστά το <code>port 0x3f8</code>, <code>IO_COM2</code> είναι το <code>0x2f8</code>, <code>IO_COM3</code> είναι το <code>0x3e8</code>, και το <code>IO_COM4</code> είναι το <code>0x2e8</code>. Αυτές είναι και οι πιο κοινές ρυθμίσεις για τις παραπάνω θύρες. Οι γραμμές interrupt 4, 3, 5 και 9 είναι οι πλέον συνηθισμένες στις σειριακές θύρες. Σημειώστε επίσης ότι οι συνηθισμένες σειριακές θύρες <em>δεν</em> μπορούν να μοιράζονται το ίδιο interrupt με κάποια άλλη συσκευή σε υπολογιστές που διαθέτουν δίαυλο τύπου ISA (οι κάρτες πολλαπλών θυρών διαθέτουν ειδικά κυκλώματα που επιτρέπουν σε όλα τα 16550Α που χρησιμοποιεί η κάρτα να λειτουργούν χρησιμοποιώντας μόνο μία ή δύο γραμμές interrupt).</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_ειδικά_αρχεία_συσκευών>47.4. Ειδικά Αρχεία Συσκευών<a class=anchor href=#_ειδικά_αρχεία_συσκευών></a></h3><div class=paragraph><p>Η πρόσβαση στις περισσότερες συσκευές του πυρήνα, επιτυγχάνεται μέσω "ειδικών αρχείων συσκευών", τα οποία βρίσκονται στον κατάλογο <span class=filename>/dev/</span>. Στις συσκευές <span class=filename>sio</span> η πρόσβαση επιτυγχάνεται μέσω των αρχείων <span class=filename>/dev/ttyuN</span> (για συσκευές εισόδου, dial-in) και <span class=filename>/dev/cuauN</span> (για συσκευές εξόδου, call-out). Το FreeBSD παρέχει επίσης συσκευές αρχικοποίησης (<span class=filename>/dev/ttyuN.init</span> και <span class=filename>/dev/cuauN.init</span>) και συσκευές κλειδώματος (<span class=filename>/dev/ttyuN.lock</span> και <span class=filename>/dev/cuauN.lock</span>). Οι συσκευές αρχικοποίησης χρησιμοποιούνται για την ρύθμιση των αρχικών παραμέτρων επικοινωνίας στη θύρα, κάθε φορά που ανοίγει. Τέτοιες παράμετροι είναι π.χ. το <code>crtscts</code> για τα modems που χρησιμοποιούν σηματοδοσία <code>RTS/CTS</code> για έλεγχο ροής. Οι συσκευές κλειδώματος χρησιμοποιούνται για να κλειδώνουν κάποιες ρυθμίσεις στις θύρες, ώστε να μην μπορούν να αλλαχθούν από άλλους χρήστες ή προγράμματα. Για πληροφορίες σχετικές με τις ρυθμίσεις τερματικών, την αρχικοποίηση και τα κλειδώματα συσκευών, και τη ρύθμιση παραμέτρων στα τερματικά, δείτε αντίστοιχα τις σελίδες manual <a href="https://man.freebsd.org/cgi/man.cgi?query=termios&amp;sektion=4&amp;format=html">termios(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, και <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a>.</p></div></div><div class=sect2><h3 id=serial-hw-config>47.5. Ρυθμίσεις Σειριακών Θυρών<a class=anchor href=#serial-hw-config></a></h3><div class=paragraph><p>Η συσκευή <span class=filename>ttyuN</span> (ή <span class=filename>cuauN</span>) είναι η κανονική συσκευή που μπορείτε να χρησιμοποιήσετε στις εφαρμογές σας. Όταν μια διαδικασία ανοίγει μια συσκευή, χρησιμοποιούνται κάποιες προεπιλεγμένες ρυθμίσεις I/O για το τερματικό. Μπορείτε να δείτε αυτές τις ρυθμίσεις με την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -a -f /dev/ttyu1</span></code></pre></div></div><div class=paragraph><p>Αν αλλάξετε τις ρυθμίσεις σε αυτή τη συσκευή, αυτές θα παραμείνουν μέχρι το κλείσιμο της συσκευής. Όταν ανοιχθεί ξανά, θα έχει επανέλθει στις προεπιλεγμένες ρυθμίσεις. Για να αλλάξετε τις προεπιλεγμένες ρυθμίσεις, μπορείτε να ανοίξετε και να αλλάξετε τις ρυθμίσεις της συσκευής "αρχικής κατάστασης". Για παράδειγμα, για να ενεργοποιήσετε τη λειτουργία <code>CLOCAL</code>, να ορίσετε επικοινωνία 8bit και έλεγχο ροής μέσω <code>XON/XOFF</code> για τη συσκευή <span class=filename>ttyu5</span>, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</span></code></pre></div></div><div class=paragraph><p>Η αρχικοποίηση των σειριακών συσκευών για όλο το σύστημα, ελέγχεται από το αρχείο <span class=filename>/etc/rc.d/serial</span>. Το αρχείο αυτό επηρεάζει τις προεπιλεγμένες ρυθμίσεις των σειριακών συσκευών.</p></div><div class=paragraph><p>Για να αποτρέψετε την αλλαγή συγκεκριμένων ρυθμίσεων από κάποια εφαρμογή, αλλάξτε τις ρυθμίσεις της συσκευής "κλειδώματος". Για παράδειγμα, για να κλειδώσετε την ταχύτητα της συσκευής <span class=filename>ttyu5</span> στα 57600 bps, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu5.lock 57600</span></code></pre></div></div><div class=paragraph><p>Τώρα, μια εφαρμογή που ανοίγει τη θύρα <span class=filename>ttyu5</span> και επιχειρεί να αλλάξει την ταχύτητα της θύρας, θα αναγκαστεί να παραμείνει στα 57600 bps.</p></div><div class=paragraph><p>Φυσικά, θα πρέπει να ρυθμίσετε τις συσκευές αρχικοποίησης και κλειδώματος, ώστε να είναι εγγράψιμες μόνο από τον λογαριασμό του <code>root</code>.</p></div></div></div></div><div class=sect1><h2 id=term>Chapter 48. Τερματικά<a class=anchor href=#term></a></h2><div class=sectionbody><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα αρχεία συσκευών των σειριακών θυρών μετονομάστηκαν από <span class=filename>/dev/cuadN</span> σε <span class=filename>/dev/cuauN</span> και από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν την παρακάτω τεκμηρίωση σύμφωνα με τις παραπάνω αλλαγές.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Τα τερματικά παρέχουν μια βολική και χαμηλού κόστους μέθοδο πρόσβασης στο FreeBSD σύστημα σας, όταν δεν βρίσκεστε μπροστά στην κονσόλα ή σε κάποιο συνδεμένο δίκτυο. Η ενότητα αυτή περιγράφει πως να χρησιμοποιήσετε τερματικά στο FreeBSD.</p></div><div class=sect2><h3 id=term-uses>48.1. Χρήσεις και Είδη Τερματικών<a class=anchor href=#term-uses></a></h3><div class=paragraph><p>Τα αρχικά συστήματα UNIX® δεν είχαν κονσόλες. Αντίθετα, οι χρήστες εισέρχονταν στο σύστημα και εκτελούσαν τα προγράμματα τους μέσω τερματικών που συνδέονταν στις σειριακές θύρες του υπολογιστή. Αυτό μοιάζει αρκετά με τη χρήση modem και λογισμικού εξομοίωσης τερματικού για σύνδεση σε ένα απομακρυσμένο σύστημα. Με τον τρόπο αυτό μπορείτε βέβαια να εκτελέσετε εργασίες μόνο σε περιβάλλον κειμένου.</p></div><div class=paragraph><p>Τα σημερινά PC διαθέτουν κονσόλες ικανές να απεικονίσουν γραφικά πολύ υψηλής ποιότητας, αλλά η ικανότητα σύνδεσης στο μηχάνημα μέσω σειριακής θύρας, υπάρχει ακόμα σχεδόν σε όλα τα σημερινά συστήματα τύπου UNIX®. Το FreeBSD δεν αποτελεί εξαίρεση. Συνδέοντας ένα τερματικό σε μια αχρησιμοποίητη σειριακή θύρα, μπορείτε να εισέλθετε στο σύστημα και να εκτελέσετε οποιοδήποτε πρόγραμμα κειμένου το οποίο θα μπορούσατε φυσιολογικά να εκτελέσετε στην κονσόλα ή σε ένα παράθυρο <code>xterm</code> του συστήματος X Window.</p></div><div class=paragraph><p>Για χρήση σε επιχειρήσεις, είναι δυνατόν να συνδέσετε πολλά τερματικά σε ένα FreeBSD σύστημα και να τα τοποθετήσετε στις θέσεις εργασίας των υπαλλήλων. Ένας οικιακός χρήστης μπορεί να χρησιμοποιήσει κάποιο παλιό υπολογιστή (π.χ. ένα παλιό IBM PC ή Macintosh®) ως τερματικό ενός πολύ ισχυρότερου υπολογιστή που εκτελεί FreeBSD. Με τον τρόπο αυτό, μπορείτε να μετατρέψετε αυτό που κανονικά θα ήταν σύστημα ενός χρήστη, σε ένα πανίσχυρο σύστημα πολλαπλών χρηστών.</p></div><div class=paragraph><p>Στο FreeBSD υπάρχουν τρία είδη τερματικών:</p></div><div class=ulist><ul><li><p><a href=#term-dumb>Κουτά Τερματικά</a></p></li><li><p><a href=#term-pcs>PC που λειτουργούν ως τερματικά</a></p></li><li><p><a href=#term-x>Τερματικά X</a></p></li></ul></div><div class=paragraph><p>Οι παρακάτω υποενότητες περιγράφουν καθένα από αυτούς τους τύπους.</p></div><div class=sect3><h4 id=term-dumb>48.1.1. Κουτά Τερματικά<a class=anchor href=#term-dumb></a></h4><div class=paragraph><p>Τα κουτά τερματικά είναι εξειδικευμένες συσκευές που επιτρέπουν τη σύνδεση σε υπολογιστές μέσω σειριακών γραμμών. Αποκαλούνται "κουτά" ακριβώς επειδή η μόνη υπολογιστική ισχύ που έχουν είναι για απεικόνιση, αποστολή, και λήψη κειμένου. Δεν μπορείτε να εκτελέσετε προγράμματα σε αυτά. Όλη η ισχύς τους προέρχεται από τον υπολογιστή που θα τα συνδέσετε, και μέσω αυτού μπορείτε να εκτελέσετε συντάκτες κειμένου, μεταγλωττιστές, προγράμματα email, παιχνίδια κ.ο.κ.</p></div><div class=paragraph><p>Υπάρχουν εκατοντάδες είδη κουτών τερματικών από αρκετούς κατασκευαστές, όπως το VT-100 της Digital Equipment Corporation και το WY-75 της Wyse. Σχεδόν οποιοσδήποτε τύπος μπορεί να λειτουργήσει με το FreeBSD. Μερικά τερματικά υψηλού κόστους μπορούν επίσης να απεικονίσουν και γραφικά, αλλά αυτή τη δυνατότητα μπορούν να την εκμεταλλευθούν σχετικά λίγα πακέτα λογισμικού.</p></div><div class=paragraph><p>Τα κουτά τερματικά είναι δημοφιλή σε περιβάλλοντα εργασίας όπου οι εργαζόμενοι δεν χρειάζονται πρόσβαση σε γραφικές εφαρμογές, όπως αυτές που παρέχονται από το σύστημα X Window.</p></div></div><div class=sect3><h4 id=term-pcs>48.1.2. PC που Λειτουργούν ως Τερματικά<a class=anchor href=#term-pcs></a></h4><div class=paragraph><p>Αν ένα <a href=#term-dumb>κουτό τερματικό</a> έχει ακριβώς την ισχύ που χρειάζεται για να δείχνει, να στέλνει, και να λαμβάνει κείμενο, τότε και κάθε υπολογιστής που σας περισσεύει μπορεί να λειτουργήσει σαν κουτό τερματικό. Το μόνο που χρειάζεστε είναι το σωστό καλώδιο και κάποιο πρόγραμμα <em>εξομοίωσης τερματικού</em> το οποίο θα εκτελείτε στον υπολογιστή αυτό.</p></div><div class=paragraph><p>Η παραπάνω διάταξη είναι δημοφιλής για οικιακή χρήση. Αν για παράδειγμα κάποιος δουλεύει στην κονσόλα του συστήματος σας, μπορείτε να εκτελέσετε την εργασία σας (με την προϋπόθεσή ότι είναι μόνο κείμενο) την ίδια στιγμή, χρησιμοποιώντας ένα λιγότερο ισχυρό σύστημα το οποίο συνδέεται στο FreeBSD σας ως τερματικό.</p></div><div class=paragraph><p>Υπάρχουν δύο τουλάχιστον βοηθητικά προγράμματα στο βασικό σύστημα του FreeBSD που μπορούν να χρησιμοποιηθούν για να δουλέψετε μέσω σειριακής σύνδεσης: το <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> και το <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>.</p></div><div class=paragraph><p>Για να συνδεθείτε από ένα άλλο μηχάνημα που εκτελεί FreeBSD στη σειριακή σύνδεση ενός άλλου συστήματος, μπορείτε να χρησιμοποιήσετε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l serial-port-device</span></code></pre></div></div><div class=paragraph><p>Όπου το "serial-port-device" είναι το όνομα του αρχείου συσκευής που αντιπροσωπεύει μια σειριακή θύρα στο σύστημα σας. Αυτά τα αρχεία συσκευών καλούνται <span class=filename>/dev/cuauN</span>.</p></div><div class=paragraph><p>Το "N" στο όνομα της συσκευής, αντιπροσωπεύει τον αριθμό της σειριακής θύρας.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σημειώστε ότι η αρίθμηση των συσκευών στο FreeBSD ξεκινά από το μηδέν, και όχι από το ένα (όπως συμβαίνει για παράδειγμα στα συστήματα που σχετίζονται με το MS-DOS®). Αυτό πρακτικά σημαίνει ότι η θύρα που στο MS-DOS® καλείται <span class=filename>COM1</span> θα είναι συνήθως η <span class=filename>/dev/cuau0</span> στο FreeBSD.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Κάποιοι χρήστες προτιμούν να χρησιμοποιούν άλλα προγράμματα που διατίθενται μέσω της Συλλογής των Ports. Τα Ports περιλαμβάνουν αρκετά βοηθητικά προγράμματα με λειτουργίες παρόμοιες με το <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> και το <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>, για παράδειγμα το <a class=package href=https://cgit.freebsd.org/ports/tree/comms/minicom/>comms/minicom</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=term-x>48.1.3. Τερματικά X<a class=anchor href=#term-x></a></h4><div class=paragraph><p>Τα τερματικά X είναι τα πιο εξελιγμένα είδη τερματικών που υπάρχουν. Αντί να συνδέονται σε σειριακή θύρα, συνήθως συνδέονται μέσω δικτύου, π.χ. Ethernet. Αντί να περιορίζονται μόνο σε εφαρμογές κειμένου, μπορούν να απεικονίσουν οποιαδήποτε εφαρμογή των X.</p></div><div class=paragraph><p>Αναφέραμε τα τερματικά X μόνο για λόγους πληρότητας αυτής της ενότητας. Στο κεφάλαιο αυτό ωστόσο, <em>δεν</em> καλύπτεται η εγκατάσταση, ρύθμιση, και χρήση των τερματικών X.</p></div></div></div><div class=sect2><h3 id=term-config>48.2. Ρύθμιση<a class=anchor href=#term-config></a></h3><div class=paragraph><p>Η ενότητα αυτή περιγράφει τι χρειάζεται να ρυθμίσετε στο FreeBSD σύστημα σας για να είναι δυνατή η είσοδος σε αυτό μέσω τερματικού. Προϋποθέτει ότι έχετε ήδη ρυθμίσει τον πυρήνα σας να υποστηρίζει τη σειριακή θύρα στην οποία είναι συνδεμένη το τερματικό-και ότι το έχετε ήδη συνδέσει.</p></div><div class=paragraph><p>Στο <a href=./#boot>Η Διαδικασία Εκκίνησης του FreeBSD</a> είδαμε ότι η διεργασία <code>init</code> είναι υπεύθυνη για τον έλεγχο των άλλων διεργασιών, και για την αρχικοποίηση κατά την εκκίνηση του συστήματος. Μια από τις εργασίες που εκτελεί η <code>init</code> είναι να διαβάζει το αρχείο <span class=filename>/etc/ttys</span> και να ξεκινά μια διεργασία <code>getty</code> σε κάθε διαθέσιμο τερματικό. Η διεργασία <code>getty</code> αναλαμβάνει να διαβάσει το όνομα χρήστη και να ξεκινήσει το πρόγραμμα <code>login</code>.</p></div><div class=paragraph><p>Για να ρυθμιστούν τα τερματικά στο FreeBSD σύστημα σας, θα πρέπει να εκτελέσετε τα ακόλουθα βήματα ως <code>root</code>:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Προσθέστε μια γραμμή στο <span class=filename>/etc/ttys</span> με το όνομα της συσκευής όπως φαίνεται στον κατάλογο <span class=filename>/dev</span>, αν δεν υπάρχει ήδη.</p></li><li><p>Καθορίστε ότι θα εκτελείται η <code>/usr/libexec/getty</code> στην θύρα, και επιλέξτε τον κατάλληλο τύπο <em>getty</em> από το αρχείο <span class=filename>/etc/gettytab</span>.</p></li><li><p>Καθορίστε τον προεπιλεγμένο τύπο τερματικού.</p></li><li><p>Ενεργοποιήστε τη θύρα θέτοντας την αντίστοιχη επιλογή στο "on".</p></li><li><p>Επιλέξτε αν η θύρα θα είναι ασφαλής με την επιλογή "secure".</p></li><li><p>Εξαναγκάστε την <code>init</code> να διαβάσει ξανά το αρχείο <span class=filename>/etc/ttys</span>.</p></li></ol></div><div class=paragraph><p>Ως προαιρετικό βήμα, μπορείτε να δημιουργήσετε ένα προσαρμοσμένο τύπο <em>getty</em> για να τον χρησιμοποιήσετε στο βήμα 2, στην καταχώριση του <span class=filename>/etc/gettytab</span>. Στο κεφάλαιο αυτό δεν θα σας εξηγήσουμε πως γίνεται αυτό. Σας προτρέπουμε να διαβάσετε τις σελίδες manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> για περισσότερες πληροφορίες.</p></div><div class=sect3><h4 id=term-etcttys>48.2.1. Προσθέτοντας μια Καταχώριση στο <span class=filename>/etc/ttys</span><a class=anchor href=#term-etcttys></a></h4><div class=paragraph><p>Το αρχείο <span class=filename>/etc/ttys</span> περιέχει μια λίστα όλων των θυρών του FreeBSD συστήματος σας στις οποίες θέλετε να επιτρέπεται η είσοδος στο σύστημα. Για παράδειγμα, υπάρχει μια καταχώριση σε αυτό το αρχείο για την πρώτη εικονική κονσόλα <span class=filename>ttyv0</span>. Μέσω αυτής της καταχώρισης, μπορείτε να εισέλθετε στο σύστημα από την κονσόλα. Το αρχείο αυτό περιέχει επίσης καταχωρίσεις για άλλες εικονικές κονσόλες, σειριακές θύρες και ψευδό-τερματικά. Για κάποιο τερματικό που είναι συνδεμένο απευθείας σε μια σειριακή θύρα, γράψτε απλώς την καταχώριση της σειριακής συσκευής όπως φαίνεται στον κατάλογο <span class=filename>/dev</span>, χωρίς να γράψετε και τον κατάλογο <span class=filename>/dev</span> (για παράδειγμα, η συσκευή <span class=filename>/dev/ttyv0</span> θα καταχωρισθεί ως <span class=filename>ttyv0</span>).</p></div><div class=paragraph><p>Η προεπιλεγμένη εγκατάσταση του FreeBSD περιέχει ένα αρχείο <span class=filename>/etc/ttys</span> το οποίο υποστηρίζει τις πρώτες τέσσερις σειριακές θύρες: <span class=filename>ttyu0</span> ως και <span class=filename>ttyu3</span>. Αν συνδέσετε τερματικό σε κάποια από αυτές τις θύρες, δεν χρειάζεται να προσθέσετε άλλη καταχώριση.</p></div><div id=ex-etc-ttys class=exampleblock><div class=title>Παράδειγμα 20. Προσθήκη Καταχωρίσεων για τα Τερματικά στο <span class=filename>/etc/ttys</span></div><div class=content><div class=paragraph><p>Ας υποθέσουμε ότι θέλουμε να συνδέσουμε δύο τερματικά στο σύστημα: ένα Wyse-50 και ένα παλιό IBM PC 286 στο οποίο εκτελούμε την εφαρμογή Procomm με την οποία εξομοιώνεται ένα τερματικό τύπου VT-100. Συνδέουμε το Wyse στη δεύτερη σειριακή θύρα και το 286 στην έκτη σειριακή θύρα (η οποία βρίσκεται σε μια κάρτα πολλαπλών θυρών). Οι αντίστοιχες καταχωρίσεις στο αρχείο <span class=filename>/etc/ttys</span> θα μοιάζουν με τις παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu1  &#34;/usr/libexec/getty std.38400&#34;  wy50  on  insecure
ttyu5   &#34;/usr/libexec/getty std.19200&#34;  vt100  on  insecure</pre></div></div><div class=ulist><ul><li><p>Το πρώτο πεδίο, είναι συνήθως το όνομα του ειδικού αρχείου τερματικού όπως φαίνεται στον κατάλογο <span class=filename>/dev</span>.</p></li><li><p>Το δεύτερο πεδίο, είναι η εντολή που θα εκτελεστεί για αυτή τη γραμμή, η οποία είναι συνήθως η <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>. Η <code>getty</code> αρχικοποιεί και ανοίγει τη γραμμή, ρυθμίζει την ταχύτητα, εμφανίζει την προτροπή για εισαγωγή ονόματος χρήστη, και εκτελεί το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a>.Το πρόγραμμα <code>getty</code> δέχεται μια (προαιρετική) παράμετρο στη γραμμή εντολής του, τον τύπο του <em>getty</em>. Ο τύπος του <em>getty</em> καθορίζει τα χαρακτηριστικά της γραμμής του τερματικού, όπως π.χ. το ρυθμό μετάδοσης σε bps και την ισοτιμία (parity). Το πρόγραμμα <code>getty</code> διαβάζει αυτά τα χαρακτηριστικά από το αρχείο <span class=filename>/etc/gettytab</span>.Το αρχείο <span class=filename>/etc/gettytab</span> περιέχει πολλές καταχωρίσεις για γραμμές τερματικών, τόσο παλιές όσο και καινούριες. Στις περισσότερες από αυτές τις περιπτώσεις, οι καταχωρίσεις που ξεκινούν με το κείμενο <code>std</code>, θα λειτουργήσουν για απευθείας συνδεδεμένα τερματικά. Αυτές οι καταχωρίσεις αγνοούν την ισοτιμία. Υπάρχει μια καταχώριση <code>std</code> για κάθε ρυθμό μετάδοσης, από 110 ως 115200. Φυσικά, μπορείτε να προσθέσετε τις δικές σας καταχωρίσεις σε αυτό το αρχείο. Η σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> περιέχει περισσότερες πληροφορίες.Όταν ρυθμίζετε τον τύπο της <em>getty</em> στο αρχείο <span class=filename>/etc/ttys</span>, βεβαιωθείτε ότι ταιριάζουν οι αντίστοιχες ρυθμίσεις επικοινωνιών στο τερματικό σας.Στο παράδειγμα μας, το Wyse-50 δεν χρησιμοποιεί ισοτιμία και συνδέεται στα 38400 bps. Το 286 PC δεν χρησιμοποιεί ισοτιμία, και συνδέεται στα 19200 bps.</p></li><li><p>Το τρίτο πεδίο είναι ο τύπος του τερματικού που συνδέεται συνήθως σε αυτή τη γραμμή tty. Για θύρες επιλογικών συνδέσεων (dial-up), η τιμή αυτού του πεδίου συχνά θα είναι <code>unknown</code> ή <code>dialup</code>, καθώς οι χρήστες θα μπορούν να πραγματοποιήσουν σύνδεση με οποιοδήποτε λογισμικό ή τερματικό. Για άμεσα συνδεμένα τερματικά, ο τύπος τερματικού δεν αλλάζει, έτσι μπορείτε να βάλετε ένα πραγματικό τύπο τερματικού σε αυτό το πεδίο, τον οποίο θα βρείτε στη βάση δεδομένων του <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a>.Για παράδειγμα, το Wyse-50 χρησιμοποιεί τον πραγματικό τύπο τερματικού του, ενώ το 286 PC που εκτελεί το Procomm, έχει ρυθμιστεί να εξομοιώνει τερματικό τύπου VT-100.</p></li><li><p>Το τέταρτο πεδίο καθορίζει αν η θύρα θα είναι ενεργή. Τοποθετώντας εδώ τη λέξη <code>on</code>, η <code>init</code> θα ξεκινήσει το πρόγραμμα που αναφέρεται στο δεύτερο πεδίο, την <code>getty</code>. Αν βάλετε <code>off</code> σε αυτό το πεδίο, δεν θα εκτελεστεί η <code>getty</code>, και έτσι δεν θα μπορεί να γίνει είσοδος στο σύστημα από τη συγκεκριμένη θύρα.</p></li><li><p>Το τελευταίο πεδίο χρησιμοποιείται για να καθορίσει αν η θύρα είναι ασφαλής. Αν χαρακτηρίσετε μια θύρα ως ασφαλή, σημαίνει ότι την εμπιστεύεστε αρκετά ώστε να επιτρέπετε την είσοδο του <code>root</code> μέσω αυτής (ή οποιουδήποτε λογαριασμού με ID 0). Δεν επιτρέπεται η είσοδος του <code>root</code> σε μια θύρα που έχει χαρακτηριστεί μη-ασφαλής. Σε μη-ασφαλείς θύρες, οι χρήστες πρέπει να εισέρχονται χρησιμοποιώντας ένα συνηθισμένο λογαριασμό χρήστη, και να χρησιμοποιούν την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> ή άλλο αντίστοιχο μηχανισμό για να αποκτήσουν προνόμια υπερχρήστη.Σας συνιστούμε ανεπιφύλακτα να χρησιμοποιήσετε τη ρύθμιση "insecure", ακόμα και για τερματικά που βρίσκονται σε κλειδωμένα δωμάτια. Είναι αρκετά εύκολο να εισέλθετε ως κανονικός χρήστης και να χρησιμοποιήσετε την εντολή <code>su</code> αν χρειάζεστε προνόμια υπερχρήστη.</p></li></ul></div></div></div></div><div class=sect3><h4 id=term-hup>48.2.2. Εξαναγκάστε την <code>init</code> να Ξαναδιαβάσει το <span class=filename>/etc/ttys</span><a class=anchor href=#term-hup></a></h4><div class=paragraph><p>Έχοντας κάνει τις απαραίτητες αλλαγές στο αρχείο <span class=filename>/etc/ttys</span>, θα πρέπει να στείλετε σήμα SIGHUP (hangup) στην διεργασία <code>init</code> για να την αναγκάσετε να διαβάσει ξανά το αρχείο ρυθμίσεων της. Για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η <code>init</code> είναι πάντοτε η πρώτη διεργασία που εκτελείται σε ένα σύστημα, και έτσι θα έχει πάντοτε τον αριθμό διεργασίας (PID) 1.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν όλες οι ρυθμίσεις είναι σωστές, τα καλώδια είναι στη θέση τους, και τα τερματικά είναι ενεργά, θα εκτελεστεί η <code>getty</code> σε κάθε τερματικό, και στο σημείο αυτό θα δείτε την προτροπή εισόδου (login) στις οθόνες των τερματικών σας.</p></div></div></div><div class=sect2><h3 id=term-debug>48.3. Αντιμετώπιση Προβλημάτων Σύνδεσης<a class=anchor href=#term-debug></a></h3><div class=paragraph><p>Ακόμα και αν δώσετε μεγάλη προσοχή στις λεπτομέρειες, πάντα μπορεί να πάει κάτι στραβά όταν ρυθμίζετε ένα τερματικό. Εδώ θα βρείτε μια λίστα από συμπτώματα και συνιστώμενες διορθώσεις.</p></div><div class=sect3><h4 id=_δεν_εμφανίζεται_προτροπή_εισόδου_login>48.3.1. Δεν Εμφανίζεται Προτροπή Εισόδου (login)<a class=anchor href=#_δεν_εμφανίζεται_προτροπή_εισόδου_login></a></h4><div class=paragraph><p>Βεβαιωθείτε ότι το τερματικό είναι συνδεμένο στο ηλεκτρικό δίκτυο και ενεργοποιημένο. Αν είναι προσωπικός υπολογιστής που ενεργεί ως τερματικό, βεβαιωθείτε ότι εκτελεί λογισμικό εξομοίωσης τερματικού στην σωστή σειριακή θύρα.</p></div><div class=paragraph><p>Βεβαιωθείτε ότι το καλώδιο είναι καλά συνδεμένο τόσο στο τερματικό, όσο και στον υπολογιστή που εκτελεί FreeBSD. Βεβαιωθείτε ότι είναι το σωστό είδος καλωδίου.</p></div><div class=paragraph><p>Βεβαιωθείτε ότι το τερματικό και το FreeBSD συμφωνούν όσο αφορά τις ρυθμίσεις της ταχύτητας μετάδοσης και ισοτιμίας. Ελέγξτε τη φωτεινότητα και την αντίθεση της οθόνης του τερματικού, και αυξήστε τις αν χρειάζεται. Αν πρόκειται για τερματικό με εκτυπωτή (χωρίς οθόνη), βεβαιωθείτε ότι διαθέτει επάρκεια χαρτιού και μελανιού.</p></div><div class=paragraph><p>Βεβαιωθείτε ότι εκτελείται η διαδικασία <code>getty</code> που εξυπηρετεί το τερματικό. Για να δείτε μια λίστα με τις ενεργές διαδικασίες <code>getty</code>, χρησιμοποιήστε την εντολή <code>ps</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -axww|grep getty</span></code></pre></div></div><div class=paragraph><p>Θα πρέπει να δείτε μια καταχώριση για το τερματικό σας. Για παράδειγμα, η ακόλουθη οθόνη δείχνει ότι η διεργασία <code>getty</code> εκτελείτε στη δεύτερη σειριακή θύρα <span class=filename>ttyu1</span> και χρησιμοποιεί την καταχώριση <code>std.38400</code> στο αρχείο <span class=filename>/etc/gettytab</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</code></pre></div></div><div class=paragraph><p>Αν δεν εκτελείται καμιά διεργασία <code>getty</code>, βεβαιωθείτε ότι έχετε ενεργοποιήσει τη θύρα στο <span class=filename>/etc/ttys</span>. Επίσης θυμηθείτε να εκτελέσετε την εντολή <code>kill -HUP 1</code> μετά την τροποποίηση του αρχείου <span class=filename>ttys</span>.</p></div><div class=paragraph><p>Αν εκτελείται η διεργασία <code>getty</code> αλλά το τερματικό εξακολουθεί να μη δείχνει προτροπή εισόδου, ή αν δείχνει προτροπή αλλά δεν σας επιτρέπει να γράψετε, ίσως το τερματικό σας ή το καλώδιο να μην επιτρέπουν συνεννόηση μέσω υλικού (hardware handshake). Δοκιμάστε να αλλάξετε την καταχώριση στο αρχείο <span class=filename>/etc/ttys</span> από <code>std.38400</code> σε <code>3wire.38400</code> (θυμηθείτε να εκτελέσετε την εντολή <code>kill -HUP 1</code> μετά την τροποποίηση του <span class=filename>/etc/ttys</span>). Η καταχώριση <code>3wire</code> είναι αντίστοιχη με την <code>std</code>, αλλά αγνοεί το hardware handshaking. Μπορεί επίσης να χρειαστεί να μειώσετε το ρυθμό σηματοδοσίας (baud) και να ενεργοποιήσετε τον έλεγχο ροής μέσω λογισμικού όταν χρησιμοποιείτε το <code>3wire</code>, προκειμένου να αποφύγετε υπερχείλιση της προσωρινής μνήμης (buffer overflow).</p></div></div><div class=sect3><h4 id=_αν_βλέπετε_σκουπίδια_αντί_για_προτροπή_εισόδου>48.3.2. Αν Βλέπετε Σκουπίδια Αντί για Προτροπή Εισόδου<a class=anchor href=#_αν_βλέπετε_σκουπίδια_αντί_για_προτροπή_εισόδου></a></h4><div class=paragraph><p>Βεβαιωθείτε ότι το τερματικό και το FreeBSD συμφωνούν στο ρυθμό bps και στις ρυθμίσεις ισοτιμίας. Ελέγξτε τις διεργασίες <code>getty</code> για να βεβαιωθείτε ότι εκτελείτε το σωστό τύπο <em>getty</em>. Αν αυτό δεν συμβαίνει, επεξεργαστείτε το αρχείο <span class=filename>/etc/ttys</span> και εκτελέστε την εντολή <code>kill -HUP 1</code>.</p></div></div><div class=sect3><h4 id=_οι_χαρακτήρες_εμφανίζονται_διπλοί_το_password_εμφανίζεται_κατά_την_πληκτρολόγηση>48.3.3. Οι Χαρακτήρες Εμφανίζονται Διπλοί, το Password Εμφανίζεται κατά την Πληκτρολόγηση<a class=anchor href=#_οι_χαρακτήρες_εμφανίζονται_διπλοί_το_password_εμφανίζεται_κατά_την_πληκτρολόγηση></a></h4><div class=paragraph><p>Αλλάξτε τη ρύθμιση του τερματικού (ή του προγράμματος εξομοίωσης τερματικού) από "half duplex" ή "local echo" σε "full duplex".</p></div></div></div></div></div><div class=sect1><h2 id=dialup>Chapter 49. Υπηρεσία Εισόδου μέσω Επιλογικής Σύνδεσης (dial-in)<a class=anchor href=#dialup></a></h2><div class=sectionbody><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα αρχεία συσκευών των σειριακών θυρών μετονομάστηκαν από <span class=filename>/dev/cuadN</span> σε <span class=filename>/dev/cuauN</span> και από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν την παρακάτω τεκμηρίωση σύμφωνα με τις παραπάνω αλλαγές.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η ρύθμιση του FreeBSD συστήματος σας για είσοδο μέσω επιλογικής σύνδεσης, είναι αρκετά όμοια με τη σύνδεση τερματικών, εκτός από το γεγονός ότι χρησιμοποιούνται modems αντί για τερματικά.</p></div><div class=sect2><h3 id=_εξωτερικά_και_εσωτερικά_modems>49.1. Εξωτερικά και Εσωτερικά Modems<a class=anchor href=#_εξωτερικά_και_εσωτερικά_modems></a></h3><div class=paragraph><p>Τα εξωτερικά modems είναι μάλλον πιο βολικά για επιλογικές κλήσεις, καθώς οι περισσότερες ρυθμίσεις τους μπορούν να αποθηκευθούν μόνιμα στη μή-πτητική μνήμη RAM που διαθέτουν. Τα εξωτερικά modems διαθέτουν συνήθως φωτεινές ενδείξεις που δείχνουν την κατάσταση σημαντικών σημάτων του RS-232. Ίσως τα φωτάκια που αναβοσβήνουν να εντυπωσιάζουν τους επισκέπτες, αλλά είναι επίσης χρήσιμα για να φαίνεται πότε το modem λειτουργεί σωστά.</p></div><div class=paragraph><p>Τα εσωτερικά modems συνήθως δεν διαθέτουν αυτή τη μνήμη RAM, και έτσι οι ρυθμίσεις τους περιορίζονται μόνο στην αλλαγή θέσης σε κάποιους διακόπτες ρυθμίσεων (DIP switches). Αν το εσωτερικό σας modem διαθέτει φωτεινές ενδείξεις, μάλλον θα είναι δύσκολο να τις δείτε όταν το κάλυμμα του συστήματος σας είναι στη θέση του.</p></div><div class=sect3><h4 id=_modems_και_καλώδια>49.1.1. Modems και Καλώδια<a class=anchor href=#_modems_και_καλώδια></a></h4><div class=paragraph><p>Αν χρησιμοποιείτε εξωτερικό modem, θα χρειαστείτε φυσικά το σωστό καλώδιο. Συνήθως επαρκεί το τυποποιημένο καλώδιο RS-232C, εφόσον διαθέτει συνδέσεις για όλα τα συνηθισμένα σήματα:</p></div><table id=serialcomms-signal-names class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 7. Ονομασίες Σημάτων</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Ακρωνύμια</th><th class="tableblock halign-left valign-top">Ονόματα</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Λήψη Δεδομένων (Received Data)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αποστολή Δεδομένων (Transmitted Data)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τερματικό Δεδομένων σε Ετοιμότητα (Data Terminal Ready)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Σύνολο Δεδομένων σε Ετοιμότητα (Data Set Ready)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανίχνευση Φέροντος Σήματος (Data Carrier Detect). Ανίχνευση σύνδεσης της γραμμής RS-232C</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Γείωση Σήματος (Signal Ground)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αίτηση Αποστολής (Request to Send)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ετοιμότητα για Αποστολή (Clear to Send)</p></td></tr></tbody></table><div class=paragraph><p>Το FreeBSD χρειάζεται τα σήματα RTS και CTS για έλεγχο ροής σε ταχύτητες πάνω από 2400 bps, το σήμα CD για να ανιχνεύει πότε έχει απαντηθεί μια κλήση ή πότε η γραμμή έχει κλείσει, και το σήμα DTR για να επαναφέρει το modem στην αρχική του κατάσταση μετά τη λήξη μιας σύνδεσης. Μερικά καλώδια δεν διαθέτουν όλα τα απαραίτητα σήματα, έτσι αν έχετε προβλήματα με τον τερματισμό της συνεδρίας εισόδου με το κλείσιμο της γραμμής, πιθανόν να ευθύνεται το καλώδιο που χρησιμοποιείτε.</p></div><div class=paragraph><p>Όπως και άλλα λειτουργικά συστήματα τύπου UNIX®, το FreeBSD χρησιμοποιεί τα σήματα του υλικού για να αντιληφθεί πότε έχει απαντηθεί μια κλήση, καθώς και για τον τερματισμό της και την επαναφορά του modem στην αρχική του κατάσταση μετά το τέλος της. Το FreeBSD αποφεύγει να στέλνει εντολές στο modem ή να παρακολουθεί αναφορές κατάστασης από αυτό. Αν είστε εξοικειωμένος με συνδέσεις modems σε BBS (Bulletin Board Systems) που βασίζονται σε PC, αυτό μπορεί να σας φανεί άβολο.</p></div></div></div><div class=sect2><h3 id=_κυκλώματα_σειριακής_διασύνδεσης>49.2. Κυκλώματα Σειριακής Διασύνδεσης<a class=anchor href=#_κυκλώματα_σειριακής_διασύνδεσης></a></h3><div class=paragraph><p>Το FreeBSD υποστηρίζει τα κυκλώματα επικοινωνιών που βασίζονται στα NS8250, NS16450, NS16550, και NS16550A και EIA RS-232C (CCITT V.24). Οι συσκευές 8250 και 16450 έχουν ενδιάμεση μνήμη (buffer) μεγέθους ενός χαρακτήρα. Η συσκευή 16550 διαθέτει ενδιάμεση μνήμη 16 χαρακτήρων, η οποία επιτρέπει την καλύτερη απόδοση της. (Λόγω προβλημάτων στη σχεδίαση του 16550, δεν είναι δυνατή η χρήση αυτής της μνήμης, αν είναι δυνατόν χρησιμοποιήστε τα 16550Α). Καθώς οι συσκευές που διαθέτουν ενδιάμεση μνήμη ενός χαρακτήρα απαιτούν περισσότερη εργασία από το λειτουργικό σύστημα σε σχέση με αυτές που διαθέτουν 16 χαρακτήρες, συνίστανται ιδιαίτερα οι συσκευές που βασίζονται στο 16550Α. Αν το σύστημα σας έχει πολλές ενεργές σειριακές πόρτες, ή πρόκειται να λειτουργήσει κάτω από βαρύ φόρτο, οι κάρτες που βασίζονται στο 16550A είναι καλύτερες, καθώς παρέχουν επικοινωνία με μικρότερο ρυθμό σφαλμάτων.</p></div></div><div class=sect2><h3 id=_γρήγορη_επισκόπηση>49.3. Γρήγορη Επισκόπηση<a class=anchor href=#_γρήγορη_επισκόπηση></a></h3><div class=paragraph><p>Όπως και με τα τερματικά, η <code>init</code> εκτελεί μια διεργασία <code>getty</code> για κάθε σειριακή θύρα που έχει ρυθμιστεί για εισερχόμενες επιλογικές συνδέσεις. Για παράδειγμα, αν έχετε συνδέσει ένα modem στη θύρα <span class=filename>/etc/ttyu0</span>, η εντολή <code>ps ax</code> θα δείξει κάτι σαν το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyu0</code></pre></div></div><div class=paragraph><p>Όταν κάποιος χρήστης καλέσει στη γραμμή αυτή και το modem συνδεθεί, ενεργοποιείται από το modem η γραμμή CD. Ο πυρήνας παρατηρεί ότι έχει ανιχνευθεί φέρον σήμα, και ολοκληρώνει τη διαδικασία ανοίγματος της θύρας από το modem. To <code>getty</code> στέλνει μια προτροπή <code>login:</code> στην από πριν καθορισμένη αρχική ταχύτητα της θύρας. Το <code>getty</code> παρακολουθεί για να δει αν λαμβάνονται έγκυροι χαρακτήρες, και στην τυπική ρύθμιση, αν ανακαλύψει ότι λαμβάνει σκουπίδια (πιθανώς λόγω διαφοράς στην ταχύτητα σύνδεσης του modem σε σχέση με την ταχύτητα του <code>getty</code>), προσπαθεί να ρυθμίσει την ταχύτητα της γραμμής μέχρι να λάβει φυσιολογικούς χαρακτήρες.</p></div><div class=paragraph><p>Αφού ο χρήστης εισάγει τον κωδικό του, το <code>getty</code> εκτελεί το <span class=filename>/usr/bin/login</span>, το οποίο και ολοκληρώνει τη διαδικασία εισόδου, ζητώντας από τον χρήστη τον κωδικό του, και ξεκινώντας έπειτα το κέλυφος του.</p></div></div><div class=sect2><h3 id=_αρχεία_ρυθμίσεων>49.4. Αρχεία Ρυθμίσεων<a class=anchor href=#_αρχεία_ρυθμίσεων></a></h3><div class=paragraph><p>Υπάρχουν τρία αρχεία ρυθμίσεων συστήματος στον κατάλογο <span class=filename>/etc</span>, τα οποία πιθανώς θα χρειαστεί να επεξεργαστείτε για να επιτρέψετε την είσοδο μέσω επιλογικής σύνδεσης στο FreeBSD σύστημα σας. Το πρώτο αρχείο είναι το <span class=filename>/etc/gettytab</span>, το οποίο περιέχει πληροφορίες ρύθμισης για τον δαίμονα <span class=filename>/usr/libexec/getty</span> Το δεύτερο αρχείο είναι το <span class=filename>/etc/ttys</span> το οποίο περιέχει πληροφορίες που γνωστοποιούν στην <span class=filename>/sbin/init</span> σε ποιες συσκευές <span class=filename>tty</span> θα πρέπει να εκτελούνται διεργασίες <code>getty</code>. Τέλος, μπορείτε να βάλετε εντολές αρχικοποίησης της θύρας στο script <span class=filename>/etc/rc.d/serial</span>.</p></div><div class=paragraph><p>Υπάρχουν δύο "σχολές" όσο αφορά τη χρήση modems για είσοδο σε ένα σύστημα UNIX®. Η πρώτη, προτιμά να ρυθμίζει τα modems και τα συστήματα με τέτοιο τρόπο, ώστε άσχετα με τι ταχύτητα συνδέεται ο απομακρυσμένος χρήστης, η τοπική σύνδεση υπολογιστή - modem μέσω του RS-232C να έχει πάντα την ίδια κλειδωμένη ταχύτητα. Το όφελος μιας τέτοιας ρύθμισης είναι ότι ο απομακρυσμένος χρήστης βλέπει πάντα άμεσα την προτροπή εισόδου. Το μειονέκτημα, είναι ότι το σύστημα δεν γνωρίζει την πραγματική ταχύτητα σύνδεσης του χρήστη, και έτσι προγράμματα πλήρους οθόνης όπως το Emacs, δεν γνωρίζουν πως να ρυθμίσουν την ταχύτητα ανανέωσης της οθόνης τους ώστε να αντιμετωπίσουν καλύτερα τις αργές συνδέσεις.</p></div><div class=paragraph><p>Η άλλη σχολή ρυθμίζει τη διεπαφή RS-232 του modem να αλλάζει ταχύτητα, ώστε να ακολουθεί την ταχύτητα σύνδεσης του απομακρυσμένου χρήστη. Για παράδειγμα, συνδέσεις τύπου V.32bis (14.4 Kbps) στο modem, μπορεί να το κάνουν να μεταβάλλει την ταχύτητα σύνδεσης στο RS-232 σε 19.2 Kbps, ενώ συνδέσεις ταχύτητας 2400 bps θα μεταβάλλουν αντίστοιχα την ταχύτητα της διεπαφής σε 2400 bps. Επειδή η <code>getty</code> δεν αναγνωρίζει με κάποιο τρόπο την ταχύτητα σύνδεσης που αναφέρει το modem, δίνει την πρώτη προτροπή <code>login:</code> στην αρχικά ρυθμισμένη ταχύτητα, και εξετάζει τους χαρακτήρες που λαμβάνει ως απάντηση. Αν ο χρήστης δει σκουπίδια, θεωρείται ότι γνωρίζει ότι πρέπει να πιέσει το <kbd>Enter</kbd> μέχρι να πάρει μια προτροπή που μπορεί να αναγνωρίσει. Αν οι ρυθμοί δεδομένων δεν ταιριάζουν, η <code>getty</code> βλέπει οτιδήποτε γράφει ο χρήστης ως "σκουπίδια", και έτσι δοκιμάζει την επόμενη ταχύτητα και στέλνει ξανά την προτροπή <code>login:</code>. Η διαδικασία μπορεί να επαναληφθεί όσες φορές χρειάζεται, αλλά συνήθως χρειάζονται μόνο μια-δυο προσπάθειες μέχρι ο χρήστης να λάβει κανονική προτροπή. Προφανώς αυτή η ακολουθία εισόδου δεν είναι τόσο καθαρή όπως η προηγούμενη μέθοδος "κλειδωμένης ταχύτητας", αλλά κάποιος χρήστης που βρίσκεται σε γραμμή χαμηλής ταχύτητας, μάλλον θα λάβει καλύτερη απόκριση σε εφαρμογές πλήρους οθόνης.</p></div><div class=paragraph><p>Σε αυτή την ενότητα θα προσπαθήσουμε να σας δώσουμε πληροφορίες και για τους δύο τύπους ρυθμίσεων, αλλά θεωρούμε καλύτερο το είδος σύνδεσης όπου η ταχύτητα υπολογιστή - modem ακολουθεί την ταχύτητα της σύνδεσης.</p></div><div class=sect3><h4 id=_etcgettytab>49.4.1. <span class=filename>/etc/gettytab</span><a class=anchor href=#_etcgettytab></a></h4><div class=paragraph><p>Το <span class=filename>/etc/gettytab</span> είναι ένα αρχείο τύπου <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> με πληροφορίες ρύθμισης για την <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>. Παρακαλούμε δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> για πιο πλήρεις πληροφορίες σχετικά με τη μορφή του αρχείου και την λίστα με τις δυνατότητες του.</p></div><div class=sect4><h5 id=_ρύθμιση_για_κλειδωμένη_ταχύτητα>49.4.1.1. Ρύθμιση για Κλειδωμένη Ταχύτητα<a class=anchor href=#_ρύθμιση_για_κλειδωμένη_ταχύτητα></a></h5><div class=paragraph><p>Αν πρόκειται να κλειδώσετε την επικοινωνία του modem σας σε μια συγκεκριμένη ταχύτητα, κατά πάσα πιθανότητα δεν θα χρειαστεί να κάνετε αλλαγές στο <span class=filename>/etc/gettytab</span>.</p></div></div><div class=sect4><h5 id=_ρύθμιση_για_μεταβλητή_ταχύτητα>49.4.1.2. Ρύθμιση για Μεταβλητή Ταχύτητα<a class=anchor href=#_ρύθμιση_για_μεταβλητή_ταχύτητα></a></h5><div class=paragraph><p>θα χρειαστεί να προσθέσετε μια καταχώριση στο <span class=filename>/etc/gettytab</span> για να δώσετε πληροφορίες στην <code>getty</code> σχετικά με τις ταχύτητες που επιθυμείτε να χρησιμοποιήσετε στο modem σας. Αν έχετε ένα modem 2400 bps, μπορείτε πιθανόν να χρησιμοποιήσετε την καταχώριση <code>D2400</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</pre></div></div><div class=paragraph><p>Αν έχετε modem υψηλότερης ταχύτητας, πιθανόν να χρειαστεί να προσθέσετε μια καταχώριση στο <span class=filename>/etc/gettytab</span>. Παρακάτω φαίνεται μια καταχώριση που μπορεί να χρησιμοποιηθεί για modem 14.4 Kbps με μέγιστη ταχύτητα σειριακής θύρας 19.2 Kbps:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</pre></div></div><div class=paragraph><p>Αυτό θα έχει ως αποτέλεσμα συνδέσεις 8bit χωρίς ισοτιμία.</p></div><div class=paragraph><p>Το παραπάνω παράδειγμα, ξεκινά το ρυθμό επικοινωνίας στα 19.2 Kbps (για μια σύνδεση V.32bis), και έπειτα δοκιμάζει κυκλικά στα 9600 bps (για V.32), 2400 bps, 1200 bps, 300 bps, και πίσω στα 19.2 Kbps. Αυτή η κυκλική εναλλαγή ρυθμού επιτυγχάνεται με την ικανότητα <code>nx=</code> ("next table"). Κάθε μια από τις γραμμές χρησιμοποιεί μια καταχώριση <code>tc=</code> ("table continuation") για να βρει τις υπόλοιπες "τυποποιημένες" ρυθμίσεις για κάποιο συγκεκριμένο ρυθμό μετάδοσης δεδομένων.</p></div><div class=paragraph><p>Αν έχετε modem 28.8 Kbps ή/και θέλετε να επωφεληθείτε από την συμπίεση ενός modem 14.4 Kbps, θα πρέπει να χρησιμοποιήσετε ρυθμό επικοινωνίας μεγαλύτερο από 19.2 Kbps. Παρακάτω φαίνεται ένα παράδειγμα μια καταχώρισης στο <span class=filename>gettytab</span> που ξεκινάει από τα 57.6 Kbps:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</pre></div></div><div class=paragraph><p>Αν έχετε αργό επεξεργαστή ή μεγάλο φορτίο, και το σύστημα σας δεν διαθέτει σειριακές θύρες που να βασίζονται στο 16550Α, ίσως λάβετε λάθη <code>sio</code> "silo" στα 57.6 Kbps.</p></div></div></div><div class=sect3><h4 id=dialup-ttys>49.4.2. <span class=filename>/etc/ttys</span><a class=anchor href=#dialup-ttys></a></h4><div class=paragraph><p>Έχουμε ήδη καλύψει τη ρύθμιση του αρχείου <span class=filename>/etc/ttys</span> στο <a href=#ex-etc-ttys>Προσθήκη Καταχωρίσεων για τα Τερματικά στο <span class=filename>/etc/ttys</span></a>. Η ρύθμιση για modems είναι παρόμοια, αλλά πρέπει να δώσουμε διαφορετικό όρισμα στην <code>getty</code> και να καθορίσουμε διαφορετικό τύπο τερματικού. Η γενική μορφή τόσο για κλειδωμένη όσο και για μεταβλητή ταχύτητα είναι η παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty xxx&#34;   dialup on</pre></div></div><div class=paragraph><p>Το πρώτο πεδίο στην παραπάνω γραμμή είναι το ειδικό αρχείο συσκευής για αυτή την καταχώριση - το <span class=filename>ttyu0</span> αντιστοιχεί στο αρχείο <span class=filename>/dev/ttyu0</span> το οποίο και θα παρακολουθεί η <code>getty</code>. Το δεύτερο πεδίο, <code>"/usr/libexec/getty xxx"</code> (το <em>xxx</em> θα έχει την αρχική τιμή ικανότητας του <span class=filename>gettytab</span>), είναι η διεργασία που θα εκτελέσει η <code>init</code> στη συσκευή. Το τρίτο πεδίο, <code>dialup</code>, είναι ο προεπιλεγμένος τύπος τερματικού. Η τέταρτη παράμετρος, <code>on</code>, δείχνει στην <code>init</code> ότι η γραμμή είναι σε λειτουργική κατάσταση. Μπορεί να υπάρχει και μια πέμπτη παράμετρος, η <code>secure</code>, αλλά θα πρέπει να χρησιμοποιείται μόνο για τερματικά στα οποία η φυσική πρόσβαση είναι ασφαλής (όπως είναι η κονσόλα του συστήματος).</p></div><div class=paragraph><p>Ο προεπιλεγμένος τύπος τερματικού (<code>dialup</code> στο παραπάνω παράδειγμα) μπορεί να αλλάξει ανάλογα με τις προτιμήσεις σας. Το <code>dialup</code> είναι ο παραδοσιακός τύπος τερματικού για επιλογικές γραμμές. Οι χρήστες μπορούν έτσι να προσαρμόζουν τα scripts σύνδεσης τους ώστε να αναγνωρίζουν το <code>dialup</code> και να ρυθμίζουν αυτόματα τον τύπο τερματικού. Ωστόσο, είναι μάλλον ευκολότερο να καθορίσετε το <code>vt102</code> ως τον προεπιλεγμένο τύπο τερματικού, καθώς οι χρήστες χρησιμοποιούν συνήθως εξομοίωση VT102 στα απομακρυσμένα τους συστήματα.</p></div><div class=paragraph><p>Αφού κάνετε τις αλλαγές στο <span class=filename>/etc/ttys</span>, μπορείτε να στείλετε στη διεργασία <code>init</code> ένα σήμα HUP για να ξαναδιαβάσει το αρχείο. Μπορείτε να χρησιμοποιήσετε την παρακάτω εντολή για αυτό το σκοπό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>Αν αυτή είναι η πρώτη φορά που ρυθμίζετε το σύστημα σας, ίσως θέλετε να περιμένετε μέχρι να ολοκληρώσετε πλήρως τη σύνδεση και ρύθμιση του modem σας πριν στείλετε σήμα στην <code>init</code>.</p></div><div class=sect4><h5 id=_ρύθμιση_για_κλειδωμένη_ταχύτητα_2>49.4.2.1. Ρύθμιση για Κλειδωμένη Ταχύτητα<a class=anchor href=#_ρύθμιση_για_κλειδωμένη_ταχύτητα_2></a></h5><div class=paragraph><p>Για λειτουργία σε κλειδωμένη ταχύτητα, θα πρέπει η καταχώριση σας στο <span class=filename>ttys</span> να παρέχει στην <code>getty</code> μια καταχώριση σταθερής ταχύτητας. Για ένα modem με ταχύτητα θύρας κλειδωμένη στα 19.2 Kbps, η καταχώριση <span class=filename>ttys</span> θα μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty std.19200&#34;   dialup on</pre></div></div><div class=paragraph><p>Αν το modem σας είναι κλειδωμένο σε διαφορετικό ρυθμό δεδομένων, αντικαταστήστε με την κατάλληλη τιμή το <code>std.19200</code> στην καταχώριση <code>std.speed</code>. Βεβαιωθείτε ότι χρησιμοποιείτε ένα έγκυρο τύπο, όπως ορίζεται στο <span class=filename>/etc/gettytab</span>.</p></div></div><div class=sect4><h5 id=_ρύθμιση_για_μεταβλητή_ταχύτητα_2>49.4.2.2. Ρύθμιση για Μεταβλητή Ταχύτητα<a class=anchor href=#_ρύθμιση_για_μεταβλητή_ταχύτητα_2></a></h5><div class=paragraph><p>Σε μια τέτοια ρύθμιση, η καταχώριση σας για το <span class=filename>ttys</span> θα πρέπει να αναφέρεται στην αρχική "auto-baud" (sic) καταχώριση του <span class=filename>/etc/gettytab</span>. Για παράδειγμα, αν προσθέσατε την παραπάνω συνιστώμενη καταχώριση για modem με μεταβλητή ταχύτητας σειριακής, και με αρχική ταχύτητα τα 19.2 Kbps (την καταχώριση <span class=filename>gettytab</span> που περιέχει ως σημείο εκκίνησης το <code>V19200</code>), η καταχώριση σας στο <span class=filename>ttys</span> θα μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty V19200&#34;   dialup on</pre></div></div></div></div><div class=sect3><h4 id=_etcrc_dserial>49.4.3. <span class=filename>/etc/rc.d/serial</span><a class=anchor href=#_etcrc_dserial></a></h4><div class=paragraph><p>Τα modems υψηλής ταχύτητας, όπως τα V.32, V.32bis και V.34, απαιτούν έλεγχο ροής μέσω υλικού (<code>RTS/CTS</code>). Μπορείτε να προσθέσετε εντολές <code>stty</code> στο <span class=filename>/etc/rc.d/serial</span> για να θέσετε στον πυρήνα του FreeBSD την κατάλληλη παράμετρο έλεγχου ροής μέσω υλικού των θυρών modem.</p></div><div class=paragraph><p>Για παράδειγμα, για να θέσετε την επιλογή <code>termios</code> στην τιμή <code>crtscts</code> στις συσκευές αρχικοποίησης της δεύτερης σειριακής θύρας (<span class=filename>COM2</span>) για επιλογικές κλήσεις εισόδου και εξόδου, θα πρέπει να προσθέσετε τις παρακάτω γραμμές στο αρχείο <span class=filename>/etc/rc.d/serial</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Serial port initial configuration
stty -f /dev/ttyu1.init crtscts
stty -f /dev/cuau1.init crtscts</pre></div></div></div></div><div class=sect2><h3 id=_ρυθμίσεις_μνήμης>49.5. Ρυθμίσεις Μνήμης<a class=anchor href=#_ρυθμίσεις_μνήμης></a></h3><div class=paragraph><p>Αν έχετε ένα modem στο οποίο μπορείτε να αποθηκεύσετε τις παραμέτρους μόνιμα στην μη-πτητική RAM που διαθέτει, θα πρέπει να χρησιμοποιήσετε ένα πρόγραμμα τερματικού (όπως το Telix μέσω του MS-DOS® ή του <code>tip</code> στο FreeBSD) για να ρυθμίσετε τις παραμέτρους. Συνδεθείτε στο modem χρησιμοποιώντας την ίδια αρχική ταχύτητα επικοινωνίας με αυτή που έχετε δηλώσει ως αρχική ταχύτητα στην <code>getty</code>, και ρυθμίστε τις παραμέτρους στη μνήμη του ώστε να ταιριάζουν με τις παρακάτω απαιτήσεις:</p></div><div class=ulist><ul><li><p>Το σήμα CD θα είναι ενεργό όταν το modem είναι συνδεμένο</p></li><li><p>Το σήμα DTR θα είναι ενεργό κατά τη λειτουργία. Απενεργοποίηση του DTR κλείνει τη γραμμή και επαναφέρει το modem στην αρχική του κατάσταση.</p></li><li><p>Το CTS θα χρησιμοποιείται για έλεγχο ροής μεταδιδόμενων δεδομένων</p></li><li><p>Ο έλεγχος ροής XON/XOFF θα είναι ανενεργός</p></li><li><p>Το RTS θα χρησιμοποιείται για έλεγχο ροής ληφθέντων δεδομένων</p></li><li><p>Ήσυχη λειτουργία (Quiet mode, χωρίς αποστολή κωδικών αποτελεσμάτων)</p></li><li><p>Δεν θα γίνεται echo των εντολών</p></li></ul></div><div class=paragraph><p>Θα πρέπει να διαβάσετε την τεκμηρίωση του modem σας για να βρείτε τις εντολές που πρέπει να αποστείλετε. Ίσως επίσης χρειαστεί να αλλάξετε τη θέση κάποιων ρυθμιστικών διακοπτών (dip switches).</p></div><div class=paragraph><p>Για παράδειγμα, για να ρυθμίσετε τις παραπάνω παραμέτρους σε ένα εξωτερικό modem U.S. Robotics® Sportster® 14,400, θα έπρεπε να στείλετε τις παρακάτω εντολές στο modem:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</pre></div></div><div class=paragraph><p>Μπορείτε με την ευκαιρία να ρυθμίσετε και άλλους παραμέτρους του modem, όπως για το αν θα χρησιμοποιείται το πρωτόκολλο V.42bis ή συμπίεση MNP5.</p></div><div class=paragraph><p>Το εξωτερικό modem U.S. Robotics® Sportster® 14,400 διαθέτει επίσης και κάποιους ρυθμιστικούς διακόπτες που πρέπει να ρυθμιστούν. Για άλλα modem, ίσως μπορείτε να χρησιμοποιήσετε αυτές τις ρυθμίσεις ως αναφορά:</p></div><div class=ulist><ul><li><p>Διακόπτης 1: Άνω Θέση - Κανονική λειτουργία DTR</p></li><li><p>Διακόπτης 2: N/A (Κωδικός Αποτελέσματος ως Κείμενο/Κωδικός Αποτελέσματος ως Αριθμός)</p></li><li><p>Διακόπτης 3: Άνω θέση - Χωρίς Κωδικό Αποτελέσματος</p></li><li><p>Διακόπτης 4: Κάτω θέση - Χωρίς echo και offline εντολές</p></li><li><p>Διακόπτης 5: Άνω θέση - Αυτόματη Απάντηση</p></li><li><p>Διακόπτης 6: Άνω θέση - Φυσιολογική Ανίχνευση Φέροντος Σήματος</p></li><li><p>Διακόπτης 7: Άνω θέση - Φόρτωση Προεπιλογών από NVRAM (μη-πτητική μνήμη)</p></li><li><p>Διακόπτης 8: N/A (Έξυπνος/Κουτός Τρόπος Λειτουργίας)</p></li></ul></div><div class=paragraph><p>Θα πρέπει να απενεργοποιήσετε ή να απομονώσετε τους κωδικούς αποτελεσμάτων στο modem, για να αποφύγετε προβλήματα που μπορούν να δημιουργηθούν αν η <code>getty</code> από λάθος στείλει προτροπή <code>login:</code> στο modem ενώ αυτό βρίσκεται σε κατάσταση εντολών. Στην περίπτωση αυτή, το modem μπορεί να αναπαράγει ξανά την εντολή (echo) ή να στείλει κάποιο κωδικό αποτελέσματος. Αυτό μπορεί να έχει ως αποτέλεσμα μια μακρόχρονη και χαζή συνομιλία μεταξύ του modem και της <code>getty</code>.</p></div><div class=sect3><h4 id=_ρυθμίσεις_για_κλειδωμένη_ταχύτητα>49.5.1. Ρυθμίσεις για Κλειδωμένη Ταχύτητα<a class=anchor href=#_ρυθμίσεις_για_κλειδωμένη_ταχύτητα></a></h4><div class=paragraph><p>Για λειτουργία σε κλειδωμένη ταχύτητα, θα χρειαστεί να ρυθμίσετε το modem να διατηρεί σταθερή ταχύτητα υπολογιστή - modem, άσχετα με την ταχύτητα επικοινωνίας της επιλογικής σύνδεσης. Σε ένα εξωτερικό modem U.S. Robotics® Sportster® 14,400, οι εντολές αυτές θα κλειδώσουν την επικοινωνία υπολογιστή - modem στην ίδια ταχύτητα που έγινε η λήψη των εντολών:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
AT&amp;B1&amp;W</pre></div></div></div><div class=sect3><h4 id=_ρυθμίσεις_για_μεταβλητή_ταχύτητα>49.5.2. Ρυθμίσεις για Μεταβλητή Ταχύτητα<a class=anchor href=#_ρυθμίσεις_για_μεταβλητή_ταχύτητα></a></h4><div class=paragraph><p>Για λειτουργία σε μεταβλητή ταχύτητα, θα χρειαστεί να ρυθμίσετε το modem σας να προσαρμόζει την ταχύτητα της σειριακής θύρας του ώστε να ταιριάζει με αυτή της εισερχόμενης κλήσης. Σε ένα εξωτερικό modem U.S. Robotics® Sportster® 14,400, οι εντολές αυτές θα κλειδώσουν την ταχύτητα μεταφοράς δεδομένων με διόρθωση λαθών του modem στην ταχύτητα που χρησιμοποιήθηκε για την αποστολή των εντολών, αλλά θα επιτρέψουν στην ταχύτητα της σειριακής θύρας να μεταβάλλεται για συνδέσεις που δεν έχουν διόρθωση λαθών:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
AT&amp;B2&amp;W</pre></div></div></div><div class=sect3><h4 id=_έλεγχος_των_ρυθμίσεων_του_modem>49.5.3. Έλεγχος των Ρυθμίσεων του Modem<a class=anchor href=#_έλεγχος_των_ρυθμίσεων_του_modem></a></h4><div class=paragraph><p>Τα περισσότερα modem υψηλής ταχύτητας, παρέχουν εντολές με τις οποίες μπορείτε να παρακολουθήσετε τις τρέχουσες παραμέτρους λειτουργίας τους με σχετικά κατανοητό τρόπο. Στο εξωτερικό modem U.S. Robotics® Sportster® 14,400, η εντολή <code>ATI5</code> δείχνει τις ρυθμίσεις που είναι αποθηκευμένες στη μη-πτητική RAM του modem. Για να δείτε τις πραγματικές παραμέτρους λειτουργίας του modem (όπως αυτές επηρεάζονται από τις θέσεις των ρυθμιστικών διακοπτών του), χρησιμοποιήστε τις εντολές <code>ATZ</code> και μετά <code>ATI4</code>.</p></div><div class=paragraph><p>Αν διαθέτετε modem άλλης εταιρίας, ελέγξτε τις οδηγίες χρήσης του για να δείτε πως μπορείτε να ελέγξετε με σιγουριά τις παραμέτρους ρύθμισης του.</p></div></div></div><div class=sect2><h3 id=_αντιμετώπιση_προβλημάτων_3>49.6. Αντιμετώπιση Προβλημάτων<a class=anchor href=#_αντιμετώπιση_προβλημάτων_3></a></h3><div class=paragraph><p>Παρακάτω θα βρείτε μερικά βήματα που μπορείτε να ακολουθήσετε για να ελέγξετε τη λειτουργία του modem στο σύστημα σας.</p></div><div class=sect3><h4 id=_ελέγχοντας_το_σύστημα_σας>49.6.1. Ελέγχοντας το Σύστημα σας<a class=anchor href=#_ελέγχοντας_το_σύστημα_σας></a></h4><div class=paragraph><p>Συνδέστε το modem στο FreeBSD σύστημα σας, εκκινήστε το, και αν το modem σας διαθέτει φωτεινές ενδείξεις κατάστασης, παρακολουθήστε τις για να δείτε αν ενεργοποιείται η ένδειξη DTR όταν εμφανίζεται η προτροπή <code>login:</code> στην κονσόλα του συστήματος. Αν η ένδειξη αυτή είναι ενεργή, σημαίνει ότι το FreeBSD έχει ξεκινήσει μια διεργασία <code>getty</code> στην αντίστοιχη θύρα επικοινωνιών και αναμένει το modem να απαντήσει μια κλήση.</p></div><div class=paragraph><p>Αν δεν ενεργοποιείται η ένδειξη DTR, εισέλθετε στο σύστημα μέσω της κονσόλας, και δώστε την εντολή <code>ps ax</code> για να δείτε αν το FreeBSD προσπαθεί να εκτελέσει διεργασία <code>getty</code> στη σωστή θύρα. Ανάμεσα στις διεργασίες, θα δείτε γραμμές όπως τις παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu1</code></pre></div></div><div class=paragraph><p>Αν δείτε κάτι διαφορετικό, όπως το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyu0</code></pre></div></div><div class=paragraph><p>και το modem δεν έχει απαντήσει ακόμα καμία κλήση, σημαίνει ότι η <code>getty</code> έχει ολοκληρώσει το άνοιγμα της σειριακής θύρας. Αυτό πιθανόν σημαίνει ότι υπάρχει πρόβλημα με την καλωδίωση, ή ότι το modem δεν είναι σωστά ρυθμισμένο, καθώς η <code>getty</code> δεν θα πρέπει να μπορεί να ανοίξει τη θύρα πριν ενεργοποιηθεί το σήμα CD (carrier detect, ανίχνευσης φέροντος) από το modem.</p></div><div class=paragraph><p>Αν δεν βλέπετε κάποιες διεργασίες <code>getty</code> να περιμένουν να ανοίξουν την επιθυμητή θύρα <span class=filename>ttyuN</span>, ελέγξτε ξανά τις καταχωρίσεις σας στο <span class=filename>/etc/ttys</span> για τυχόν λάθη. Ελέγξτε επίσης το αρχείο καταγραφής <span class=filename>/var/log/messages</span> για να δείτε αν υπάρχουν κάποια μηνύματα από την <code>init</code> ή την <code>getty</code> σχετικά με τα προβλήματα. Αν υπάρχουν μηνύματα, ελέγξτε ξανά τα αρχεία ρυθμίσεων <span class=filename>/etc/ttys</span> και <span class=filename>/etc/gettytab</span>, όπως και τα ειδικά αρχεία συσκευών <span class=filename>/dev/ttyuN</span> για πιθανά λάθη, ελλιπείς καταχωρίσεις, ή μη-ύπαρξη των ειδικών αρχείων συσκευών.</p></div></div><div class=sect3><h4 id=_προσπαθήστε_να_εκτελέσετε_σύνδεση_εισόδου>49.6.2. Προσπαθήστε να Εκτελέσετε Σύνδεση Εισόδου<a class=anchor href=#_προσπαθήστε_να_εκτελέσετε_σύνδεση_εισόδου></a></h4><div class=paragraph><p>Δοκιμάστε να εισέλθετε στο σύστημα σας μέσω απομακρυσμένης σύνδεσης. Βεβαιωθείτε ότι χρησιμοποιείτε 8 bits, 1 stop bit και επικοινωνία χωρίς ισοτιμία στο απομακρυσμένο σύστημα. Αν δε λάβετε άμεσα την προτροπή εισόδου, ή αν λαμβάνετε σκουπίδια, δοκιμάστε να πιέζετε <kbd>Enter</kbd> με ρυθμό περίπου μια φορά το δευτερόλεπτο. Αν ακόμα δεν λαμβάνετε την προτροπή <code>login:</code>, δοκιμάστε μετά από λίγο να στείλετε ένα <code>BREAK</code>. Αν κάνετε κλήση από ένα modem υψηλής ταχύτητας, δοκιμάστε ξανά, αφού κλειδώσετε την ταχύτητα επικοινωνίας υπολογιστή - modem από το οποίο καλείτε (μέσω π.χ. της <code>AT&amp;B1</code> σε ένα U.S. Robotics® Sportster® modem).</p></div><div class=paragraph><p>Αν δεν μπορείτε ακόμα να λάβετε προτροπή <code>login:</code>, ελέγξτε ξανά και ξανά το αρχείο <span class=filename>/etc/gettytab</span>.</p></div><div class=ulist><ul><li><p>Το όνομα της αρχικής ικανότητας που καθορίζεται στο αρχείο <span class=filename>/etc/ttys</span> για τη γραμμή πρέπει να ταιριάζει με το όνομα της ικανότητας στο <span class=filename>/etc/gettytab</span></p></li><li><p>Κάθε καταχώριση <code>nx=</code> ταιριάζει με το όνομα μιας αντίστοιχης ικανότητας στο <span class=filename>gettytab</span></p></li><li><p>Κάθε καταχώριση <code>tc=</code> ταιριάζει με το όνομα μιας αντίστοιχης ικανότητας στο <span class=filename>gettytab</span></p></li></ul></div><div class=paragraph><p>Αν κάνετε κλήση αλλά το modem στο FreeBSD σύστημα δεν απαντάει, βεβαιωθείτε ότι το modem είναι ρυθμισμένο να απαντάει την τηλεφωνική γραμμή όταν ενεργοποιείται το σήμα DTR. Αν το modem φαίνεται να είναι ρυθμισμένο σωστά, επαληθεύστε ότι η γραμμή DTR είναι ενεργή ελέγχοντας τις φωτεινές ενδείξεις του modem (αν υπάρχουν).</p></div><div class=paragraph><p>Αν έχετε ελέγξει τα πάντα πολλές φορές, και ακόμα δεν φαίνεται να βρίσκετε τη λύση, κάντε ένα διάλειμμα και προσπαθήστε ξανά αργότερα. Αν ακόμα δεν λειτουργεί, ίσως είναι καλή ιδέα να στείλετε ένα μήνυμα στην <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>ηλεκτρονική λίστα γενικών ερωτήσεων του FreeBSD</a> περιγράφοντας το πρόβλημα σας και το modem σας, και οι καλοί άνθρωποι που παρακολουθούν την λίστα θα προσπαθήσουν να σας βοηθήσουν.</p></div></div></div></div></div><div class=sect1><h2 id=dialout>Chapter 50. Υπηρεσία Επιλογικής Σύνδεσης<a class=anchor href=#dialout></a></h2><div class=sectionbody><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα αρχεία συσκευών των σειριακών θυρών μετονομάστηκαν από <span class=filename>/dev/cuadN</span> σε <span class=filename>/dev/cuauN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν την παρακάτω τεκμηρίωση σύμφωνα με τις παραπάνω αλλαγές.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Παρακάτω θα βρείτε κάποιες συμβουλές για να μπορέσετε να συνδέσετε τον υπολογιστή σας μέσω modem σε κάποιο άλλο υπολογιστή. Με τον τρόπο αυτό, μπορείτε να δημιουργήσετε σύνδεση τερματικού προς ένα απομακρυσμένο υπολογιστή.</p></div><div class=paragraph><p>Η υπηρεσία αυτή χρησιμεύει επίσης για να συνδεθείτε σε μια BBS.</p></div><div class=paragraph><p>Αυτό το είδος σύνδεσης μπορεί να φανεί εξαιρετικά χρήσιμο για να πάρετε κάποιο αρχείο από το Internet αν έχετε πρόβλημα σύνδεσης μέσω PPP. Αν θέλετε να πάρετε κάτι μέσω FTP και δεν μπορείτε να συνδεθείτε μέσω PPP, συνδεθείτε μέσω τερματικού σε ένα άλλο υπολογιστή, και κατεβάστε σε αυτόν το αρχείο μέσω FTP. Έπειτα, χρησιμοποιήστε το πρωτόκολλο zmodem για να το μεταφέρετε στον υπολογιστή σας.</p></div><div class=sect2><h3 id=hayes-unsupported>50.1. Το τύπου Hayes Modem μου δεν Υποστηρίζεται, Τι Μπορώ να Κάνω;<a class=anchor href=#hayes-unsupported></a></h3><div class=paragraph><p>Στην πραγματικότητα, η σελίδα manual της <code>tip</code> δεν είναι ενημερωμένη. Υπάρχει ήδη κατάλληλο γενικό πρόγραμμα κλήσης για modems της Hayes. Απλώς χρησιμοποιήστε την καταχώριση <code>at=hayes</code> στο αρχείο <span class=filename>/etc/remote</span>.</p></div><div class=paragraph><p>Το πρόγραμμα οδήγησης Hayes δεν είναι αρκετά έξυπνο ώστε να αναγνωρίζει κάποια από τα προχωρημένα χαρακτηριστικά των νεώτερων modems. Μπορεί να μπερδευτεί από μηνύματα όπως τα <code>BUSY</code>, <code>NO DIALTONE</code>, ή <code>CONNECT 115200</code>. Θα πρέπει να απενεργοποιήσετε αυτά τα μηνύματα όταν χρησιμοποιείται την <code>tip</code> (στέλνοντας την εντολή <code>ATX0&amp;W</code>).</p></div><div class=paragraph><p>Επίσης, το μέγιστο χρονικό διάστημα το οποίο περιμένει η <code>tip</code> είναι 60 δευτερόλεπτα. Το modem σας θα πρέπει να έχει μικρότερο χρονικό περιθώριο, αλλιώς η tip θα νομίζει ότι υπάρχει πρόβλημα επικοινωνίας. Δοκιμάστε την εντολή <code>ATS7=45&amp;W</code>.</p></div></div><div class=sect2><h3 id=direct-at>50.2. Πως Υποτίθεται Ότι θα Στείλω Αυτές τις <code>ΑΤ</code> Εντολές;<a class=anchor href=#direct-at></a></h3><div class=paragraph><p>Δημιουργήστε αυτό που ονομάζεται "απευθείας" καταχώριση στο αρχείο <span class=filename>/etc/remote</span>. Για παράδειγμα, αν το modem σας είναι συνδεμένο στην πρώτη σειριακή θύρα, <span class=filename>/dev/cuau0</span>, προσθέστε την ακόλουθη γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>cuau0:dv=/dev/cuau0:br#19200:pa=none</pre></div></div><div class=paragraph><p>Στην ικανότητα br, χρησιμοποιήστε τον υψηλότερο ρυθμό bps που υποστηρίζει το modem σας. Έπειτα, πληκτρολογήστε <code>tip cuau0</code> και θα συνδεθείτε με το modem σας</p></div><div class=paragraph><p>Ή χρησιμοποιήστε την <code>cu</code> ως <code>root</code>, δίνοντας την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -lline -sspeed</span></code></pre></div></div><div class=paragraph><p>Το <em>line</em> είναι η σειριακή θύρα (π.χ. <span class=filename>/dev/cuau0</span>) και το <em>speed</em> είναι η ταχύτητα (π.χ. <code>57600</code>). Όταν τελειώσετε με τις εντολές ΑΤ, γράψτε <code>~.</code> για να τερματίσετε τη σύνδεση.</p></div></div><div class=sect2><h3 id=gt-failure>50.3. Το Σύμβολο <code>@</code> της Ικανότητας pn Δεν Λειτουργεί!<a class=anchor href=#gt-failure></a></h3><div class=paragraph><p>Το σύμβολο <code>@</code> της ικανότητας τηλεφωνικού αριθμού (pn, phone number) οδηγεί την tip να διαβάσει το αρχείο <span class=filename>/etc/phones</span> για ένα τηλεφωνικό αριθμό. Αλλά το σύμβολο <code>@</code> είναι επίσης ένας ειδικός χαρακτήρας σε αρχεία ικανοτήτων όπως το <span class=filename>/etc/remote</span>. Θα πρέπει να χρησιμοποιήσετε την ανάποδη κάθετο για να δηλώσετε ότι δεν επιθυμείτε να έχει επίδραση ειδικού χαρακτήρα:</p></div><div class="literalblock programlisting"><div class=content><pre>pn=\@</pre></div></div></div><div class=sect2><h3 id=dial-command-line>50.4. Πως Μπορώ να Καλέσω Ένα Τηλεφωνικό Αριθμό Από την Γραμμή Εντολών;<a class=anchor href=#dial-command-line></a></h3><div class=paragraph><p>Βάλτε μια "γενική" καταχώριση στο αρχείο <span class=filename>/etc/remote</span>. Για παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>Έπειτα μπορείτε να δίνετε εντολές όπως:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip -115200 5551234</span></code></pre></div></div><div class=paragraph><p>Αν προτιμάτε την <code>cu</code> αντί για την <code>tip</code>, χρησιμοποιήστε μια γενική καταχώριση για την <code>cu</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>και πληκτρολογήστε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu 5551234 -s 115200</span></code></pre></div></div></div><div class=sect2><h3 id=set-bps>50.5. Πρέπει να Πληκτρολογώ το Ρυθμό bps Κάθε Φορά που το Κάνω Αυτό;<a class=anchor href=#set-bps></a></h3><div class=paragraph><p>Θα πρέπει να προσθέσετε μια καταχώριση <code>tip1200</code> ή <code>cu1200</code>, αλλά μπορείτε να βάλετε την δική σας επιθυμητή τιμή στην ικανότητα br. Η εντολή <code>tip</code> θεωρεί ότι τα 1200 bps είναι μια καλή προεπιλογή, και για το λόγο αυτό ψάχνει να βρει μια καταχώριση <code>tip1200</code>. Δεν χρειάζεται ωστόσο να χρησιμοποιήσετε ταχύτητα 1200 bps.</p></div></div><div class=sect2><h3 id=terminal-server>50.6. Έχω Πρόσβαση σε Ένα Αριθμό Υπολογιστών Μέσω Ενός Εξυπηρετητή Τερματικών<a class=anchor href=#terminal-server></a></h3><div class=paragraph><p>Αντί να περιμένετε μέχρι να συνδεθείτε και να πληκτρολογείτε <code>CONNECT host</code> κάθε φορά, χρησιμοποιήστε την ικανότητα <code>cm</code> του tip. Για παράδειγμα, δείτε τις παρακάτω καταχωρίσεις στο <span class=filename>/etc/remote</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>pain|pain.deep13.com|Forrester&#39;s machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre></div></div><div class=paragraph><p>Το παραπάνω, θα σας επιτρέψει να γράφετε <code>tip pain</code> ή <code>tip muffin</code> για να συνδέεστε στους υπολογιστές <code>pain</code> ή <code>muffin</code>, και <code>tip deep13</code> για να συνδέεστε στον εξυπηρετητή τερματικών.</p></div></div><div class=sect2><h3 id=tip-multiline>50.7. Μπορεί η Tip να Δοκιμάσει Περισσότερες Από Μια Γραμμές για κάθε Σύνδεση;<a class=anchor href=#tip-multiline></a></h3><div class=paragraph><p>Αυτό το πρόβλημα συνήθως εμφανίζεται σε ένα πανεπιστήμιο που έχει αρκετές γραμμές για modem, αλλά και χιλιάδες φοιτητές που προσπαθούν να τις χρησιμοποιήσουν.</p></div><div class=paragraph><p>Δημιουργήστε μια καταχώριση για το πανεπιστήμιο σας στο <span class=filename>/etc/remote</span> και χρησιμοποιήστε το <code>@</code> στην ικανότητα <code>pn</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:</pre></div></div><div class=paragraph><p>Έπειτα, δημιουργήστε μια λίστα με τους αριθμούς τηλεφώνων του πανεπιστημίου στο <span class=filename>/etc/phones</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre></div></div><div class=paragraph><p>Η <code>tip</code> θα δοκιμάσει κάθε μία, με τη σειρά που εμφανίζονται, και θα σταματήσει. Αν θέλετε να συνεχίζει την προσπάθεια, εκτελέστε την <code>tip</code> μέσα σε ένα βρόγχο while.</p></div></div><div class=sect2><h3 id=multi-controlp>50.8. Γιατί Πρέπει να Πιέσω <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> Δύο Φορές για να Στείλω το Συνδυασμό <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> Μια Φορά;<a class=anchor href=#multi-controlp></a></h3><div class=paragraph><p>Ο συνδυασμός πλήκτρων <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> αποτελεί τον προεπιλεγμένο χαρακτήρα "εξαναγκασμού (force)", και χρησιμοποιείται για να καταλάβει η <code>tip</code> ότι ο επόμενος χαρακτήρας θα πρέπει να χρησιμοποιηθεί όπως είναι. Μπορείτε να θέσετε τον χαρακτήρα εξαναγκασμού σε οποιοδήποτε άλλο χαρακτήρα, χρησιμοποιώντας την ακολουθία διαφυγής <code>~s</code>, η οποία σημαίνει "ρύθμισε μια μεταβλητή".</p></div><div class=paragraph><p>Πληκτρολογήστε <code>~sforce=single-char</code> και συνεχίστε με ένα χαρακτήρα νέας γραμμής. Το <em>single-char</em> είναι οποιοσδήποτε μονός χαρακτήρας. Αν αφήσετε κενό το <em>single-char</em>, ο χαρακτήρας εξαναγκασμού θα είναι ο nul, τον οποίο μπορείτε να πληκτρολογήσετε χρησιμοποιώντας το συνδυασμό πλήκτρων <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> ή <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Space</kbd></span>. Μια αρκετά καλή τιμή για το <em>single-char</em> είναι το <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>, που χρησιμοποιείται μόνο σε κάποιους εξυπηρετητές τερματικών.</p></div><div class=paragraph><p>Μπορείτε να ορίσετε το χαρακτήρα εξαναγκασμού σε όποιον εσείς επιθυμείτε, με την ακόλουθη καταχώριση στο αρχείο <span class=filename>$HOME/.tiprc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>force=single-char</pre></div></div></div><div class=sect2><h3 id=uppercase>50.9. Ξαφνικά Ότι Γράφω Εμφανίζεται με Κεφαλαία Γράμματα!!<a class=anchor href=#uppercase></a></h3><div class=paragraph><p>Μάλλον έχετε πιέσει <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span>, που είναι ο "χαρακτήρας ανύψωσης" της <code>tip</code>, και είναι σχεδιασμένος ειδικά για όσους έχουν πρόβλημα με το πλήκτρο <kbd>CAPS LOCK</kbd>. Χρησιμοποιήστε την εντολή <code>~s</code> που δείξαμε παραπάνω, για να θέσετε μια λογική τιμή στη μεταβλητή <code>raisechar</code>. Στην πραγματικότητα, μπορείτε να θέσετε την ίδια τιμή με τον χαρακτήρα εξαναγκασμού, αν δεν σκοπεύετε ποτέ να χρησιμοποιήσετε κάποια από αυτές τις δυνατότητες.</p></div><div class=paragraph><p>Παρακάτω φαίνεται ένα υπόδειγμα αρχείου <span class=filename>.tiprc</span>, το οποίο είναι τέλειο για χρήστες του Emacs που χρειάζεται να πληκτρολογούν συχνά <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> και <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span>:</p></div><div class="literalblock programlisting"><div class=content><pre>force=^^
raisechar=^^</pre></div></div><div class=paragraph><p>Ο χαρακτήρας <code>^^</code> είναι ο <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>.</p></div></div><div class=sect2><h3 id=tip-filetransfer>50.10. Πως Μπορώ να Μεταφέρω Αρχεία με την <code>tip</code>;<a class=anchor href=#tip-filetransfer></a></h3><div class=paragraph><p>Αν επικοινωνείτε με άλλο UNIX® σύστημα, μπορείτε να στείλετε και να λάβετε αρχεία με τις εντολές <code>~p</code> (put) και <code>~t</code> (take). Οι εντολές αυτές εκτελούν τις cat και echo στο απομακρυσμένο σύστημα για να λαμβάνουν και να στέλνουν αρχεία. Η σύνταξη τους είναι:</p></div><div class=paragraph><p><code>~p</code> τοπικό-αρχείο [απομακρυσμένο-αρχείο]</p></div><div class=paragraph><p><code>~t</code> απομακρυσμένο-αρχείο [τοπικό-αρχείο]</p></div><div class=paragraph><p>Οι παραπάνω εντολές δεν διαθέτουν έλεγχο λαθών. Θα είναι καλύτερο να χρησιμοποιήσετε κάποιο άλλο πρωτόκολλο, όπως το zmodem.</p></div></div><div class=sect2><h3 id=zmodem-tip>50.11. Πως Μπορώ να Εκτελέσω το zmodem με την <code>tip</code>;<a class=anchor href=#zmodem-tip></a></h3><div class=paragraph><p>Για να λάβετε αρχεία, ξεκινήστε το πρόγραμμα αποστολής στον απομακρυσμένο υπολογιστή. Έπειτα πληκτρολογήστε <code>~C rz</code> για να ξεκινήσετε την τοπική λήψη.</p></div><div class=paragraph><p>Για να στείλετε αρχεία, ξεκινήστε το πρόγραμμα λήψης στον απομακρυσμένο υπολογιστή. Έπειτα πληκτρολογήστε <code>~C sz files</code> για να στείλετε τα αρχεία στο απομακρυσμένο σύστημα.</p></div></div></div></div><div class=sect1><h2 id=serialconsole-setup>Chapter 51. Ρύθμιση της Σειριακής Κονσόλας<a class=anchor href=#serialconsole-setup></a></h2><div class=sectionbody><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα αρχεία συσκευών των σειριακών θυρών μετονομάστηκαν από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν την παρακάτω τεκμηρίωση σύμφωνα με τις παραπάνω αλλαγές.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=serialconsole-intro>51.1. Εισαγωγή<a class=anchor href=#serialconsole-intro></a></h3><div class=paragraph><p>Το FreeBSD έχει την ικανότητα να εκκινήσει σε ένα σύστημα το οποίο ως κονσόλα διαθέτει ένα "κουτό" τερματικό συνδεμένο σε μια σειριακή θύρα. Αυτή η ρύθμιση είναι χρήσιμη σε δύο κατηγορίες ανθρώπων: διαχειριστές συστημάτων που επιθυμούν να εγκαταστήσουν FreeBSD σε μηχανήματα τα οποία δεν διαθέτουν πληκτρολόγιο ή οθόνη, και προγραμματιστές που επιθυμούν να εκσφαλματώνουν τον πυρήνα ή οδηγούς συσκευών.</p></div><div class=paragraph><p>Όπως περιγράφεται στο <a href=./#boot>Η Διαδικασία Εκκίνησης του FreeBSD</a>, το FreeBSD χρησιμοποιεί σύστημα εκκίνησης τριών σταδίων. Τα πρώτα δύο στάδια είναι στον κώδικα του boot block, ο οποίος αποθηκεύεται στην αρχή της κατάτμησης (slice) του δίσκου εκκίνησης του FreeBSD. Το boot block κατόπιν φορτώνει και εκτελεί τον φορτωτή εκκίνησης (<span class=filename>/boot/loader</span>) ως κώδικα του τρίτου σταδίου.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε την σειριακή κονσόλα, θα πρέπει να ρυθμίσετε τον κώδικα του boot block, το φορτωτή εκκίνησης, και τον πυρήνα.</p></div></div><div class=sect2><h3 id=serialconsole-howto-fast>51.2. Ρύθμιση Σειριακής Κονσόλας (Σύντομη Έκδοση)<a class=anchor href=#serialconsole-howto-fast></a></h3><div class=paragraph><p>Η ενότητα αυτή υποθέτει ότι σκοπεύετε να χρησιμοποιήσετε τις προεπιλεγμένες ρυθμίσεις, και θέλετε απλώς μια γρήγορη επισκόπηση της διαδικασίας ρύθμισης της σειριακής κονσόλας.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Συνδέστε το σειριακό καλώδιο στην <span class=filename>COM1</span> και στο τερματικό.</p></li><li><p>Για να δείτε όλα τα μηνύματα εκκίνησης στην σειριακή κονσόλα, δώστε την παρακάτω εντολή ως υπερχρήστης:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;console=&#34;comconsole&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></li><li><p>Επεξεργαστείτε το <span class=filename>/etc/ttys</span> και αλλάξτε το <code>off</code> σε <code>on</code> και το <code>dialup</code> σε <code>vt100</code> για την καταχώριση <span class=filename>ttyu0</span>. Διαφορετικά, δεν θα χρειάζεται κωδικός πρόσβασης για τη σύνδεση μέσω της σειριακής κονσόλας, το οποίο αποτελεί πιθανό κενό ασφαλείας.</p></li><li><p>Επανεκκινήστε το σύστημα για να δείτε αν ίσχυσαν οι αλλαγές.</p></li></ol></div></div></div><div class=paragraph><p>Αν χρειάζεστε διαφορετικές ρυθμίσεις, θα βρείτε λεπτομέρειες για την ρύθμιση στο <a href=#serialconsole-howto>Ρύθμιση Σειριακής Κονσόλας</a>.</p></div></div><div class=sect2><h3 id=serialconsole-howto>51.3. Ρύθμιση Σειριακής Κονσόλας<a class=anchor href=#serialconsole-howto></a></h3><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Προετοιμάστε ένα σειριακό καλώδιο.</p><div class=paragraph><p>Θα χρειαστείτε είτε ένα καλώδιο τύπου null-modem, είτε ένα τυποποιημένο σειριακό καλώδιο και ένα προσαρμογέα null-modem. Δείτε το <a href=#serial-cables-ports>Θύρες και Καλώδια</a> για λεπτομέρειες σχετικά με τα είδη των σειριακών καλωδίων.</p></div></li><li><p>Αποσυνδέστε το πληκτρολόγιο σας.</p><div class=paragraph><p>Τα περισσότερα PC ψάχνουν για το πληκτρολόγιο κατά την διάρκεια των διαγνωστικών εκκίνησης (POST, Power On Self Test), και θα αναφέρουν σφάλμα αν το πληκτρολόγιο δεν είναι συνδεμένο. Μερικά μηχανήματα παραπονιούνται ηχηρά για την έλλειψη πληκτρολογίου, και δεν συνεχίζουν την εκκίνηση μέχρι να το συνδέσετε.</p></div><div class=paragraph><p>Αν ο υπολογιστής σας παραπονιέται για το λάθος, αλλά ξεκινά έτσι και αλλιώς, δεν χρειάζεται να κάνετε τίποτα ιδιαίτερο για αυτό. (Μερικά μηχανήματα με BIOS της Phoenix, λένε απλώς <code>Keyboard Failed</code> και συνεχίζουν την εκκίνηση κανονικά.)</p></div><div class=paragraph><p>Αν ο υπολογιστής σας αρνείται να εκκινήσει χωρίς πληκτρολόγιο, θα πρέπει να ρυθμίσετε το BIOS ώστε να αγνοεί το λάθος (αν γίνεται). Συμβουλευτείτε το εγχειρίδιο της μητρικής σας για λεπτομέρειες σχετικά με αυτή τη διαδικασία.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Ρυθμίστε το πληκτρολόγιο σε "Not installed" στο BIOS. Η ρύθμιση αυτή απλώς αποτρέπει το BIOS από το να ανιχνεύει το πληκτρολόγιο στην εκκίνηση, και δεν πρόκειται να σας εμποδίσει να το χρησιμοποιήσετε κανονικά. Μπορείτε να αφήσετε το πληκτρολόγιο συνδεμένο ακόμα και όταν έχετε ενεργοποιήσει τη ρύθμιση "Not installed". Αν δεν υπάρχει η παραπάνω ρύθμιση στο BIOS, ψάξτε για την επιλογή "Halt on Error". Αλλάξτε τη σε "All but Keyboard" ή ακόμα και σε "No Errors", και θα έχετε το ίδιο αποτέλεσμα.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν το σύστημα σας διαθέτει ποντίκι τύπου PS/2®, πιθανόν να πρέπει να το αποσυνδέσετε και αυτό. Τα ποντίκια τύπου PS/2® έχουν κάποια κυκλώματα κοινά με το πληκτρολόγιο, γεγονός που μπορεί να προκαλέσει σύγχυση στο πρόγραμμα ανίχνευσης του πληκτρολογίου. Κάποια συστήματα, όπως το Gateway 2000 Pentium 90 MHz με AMI BIOS, συμπεριφέρονται με αυτό τον τρόπο. Σε γενικές γραμμές, αυτό δεν είναι πρόβλημα καθώς το ποντίκι έτσι και αλλιώς δεν είναι χρήσιμο χωρίς το πληκτρολόγιο.</p></div></td></tr></tbody></table></div></li><li><p>Συνδέστε ένα κουτό τερματικό στην <span class=filename>COM1</span> (<span class=filename>sio0</span>).</p><div class=paragraph><p>Αν δεν έχετε κουτό τερματικό, μπορείτε να συνδέσετε ένα παλιό PC/XT με ένα πρόγραμμα για modem, ή να χρησιμοποιήσετε τη σειριακή θύρα σε ένα άλλο μηχάνημα UNIX®. Αν δεν έχετε σειριακή θύρα <span class=filename>COM1</span> (<span class=filename>sio0</span>), αγοράστε μια. Τη δεδομένη στιγμή δεν υπάρχει τρόπος να επιλέξετε άλλη θύρα εκτός από την <span class=filename>COM1</span>, χωρίς να επαναμεταγλωττίσετε τα boot blocks. Αν χρησιμοποιείτε ήδη την <span class=filename>COM1</span> για κάποια άλλη συσκευή, θα πρέπει να την αφαιρέσετε προσωρινά, και να εγκαταστήσετε νέο boot block και πυρήνα, μόλις συνδεθείτε στο FreeBSD. (Υποθέτουμε ότι η <span class=filename>COM1</span> θα είναι έτσι και αλλιώς διαθέσιμη σε ένα εξυπηρετητή αρχείων/υπολογισμών/τερματικών. Αν πραγματικά χρειάζεστε την <span class=filename>COM1</span> για κάτι άλλο (και δεν μπορείτε αυτό το κάτι άλλο να το μετακινήσετε στην <span class=filename>COM2</span> (<span class=filename>sio1</span>)), μάλλον δεν θα έπρεπε να ασχοληθείτε καθόλου με όλο αυτό το θέμα).</p></div></li><li><p>Βεβαιωθείτε ότι το αρχείο ρυθμίσεων του πυρήνα σας έχει τις κατάλληλες επιλογές (flags) για την <span class=filename>COM1</span> (<span class=filename>sio0</span>).</p><div class=paragraph><p>Οι σχετικές επιλογές είναι:</p></div><div class=dlist><dl><dt class=hdlist1><code>0x10</code></dt><dd><p>Ενεργοποιεί την υποστήριξη κονσόλας για αυτή τη θύρα. Αν δεν τεθεί αυτή η επιλογή, τα υπόλοιπα flags για την κονσόλα δεν λαμβάνονται υπόψιν. Τη δεδομένη στιγμή, η υποστήριξη κονσόλας μπορεί να είναι ενεργοποιημένη μόνο σε μια θύρα. Η πρώτη που καθορίζεται στο αρχείο ρυθμίσεων, είναι και αυτή που θα προτιμηθεί. Από μόνη της, η επιλογή αυτή δεν θα ενεργοποιήσει την κονσόλα στη συγκεκριμένη σειριακή θύρα. Θα πρέπει να θέσετε το παρακάτω flag ή να χρησιμοποιήσετε την επιλογή <code>-h</code> που περιγράφεται παρακάτω, μαζί με αυτό το flag.</p></dd><dt class=hdlist1><code>0x20</code></dt><dd><p>Εξαναγκάζει τη συγκεκριμένη θύρα να γίνει η κονσόλα (εκτός αν υπάρχει άλλη κονσόλα υψηλότερης προτεραιότητας) άσχετα με την επιλογή <code>-h</code> που περιγράφεται παρακάτω. Θα πρέπει να χρησιμοποιήσετε το flag <code>0x20</code> μαζί με το flag <code>0x10</code>.</p></dd><dt class=hdlist1><code>0x40</code></dt><dd><p>Παρακρατεί τη συγκεκριμένη θύρα (σε συνδυασμό με την <code>0x10</code>) κάνοντας την μη διαθέσιμη για κανονική πρόσβαση. Δεν θα πρέπει να θέσετε αυτή την επιλογή στη σειριακή θύρα που σκοπεύετε να χρησιμοποιήσετε ως σειριακή κονσόλα. Η μόνη χρήση αυτού του flag, είναι να καθορίσετε ότι η θύρα θα χρησιμοποιηθεί για απομακρυσμένη εκσφαλμάτωση του πυρήνα (kernel debugging). Δείτε <a href=https://docs.freebsd.org/en/books/developers-handbook/>Το Βιβλίο του Προγραμματιστή</a> για περισσότερες λεπτομέρειες σχετικά με την απομακρυσμένη εκσφαλμάτωση.</p><div class=paragraph><p>Παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre>device sio0 flags 0x10</pre></div></div><div class=paragraph><p>Δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> για περισσότερες λεπτομέρειες.</p></div><div class=paragraph><p>Αν δεν έχουν καθοριστεί flags, θα πρέπει να εκτελέσετε το UserConfig (σε διαφορετική κονσόλα) ή να επαναμεταγλωττίσετε τον πυρήνα.</p></div></dd></dl></div></li><li><p>Δημιουργήστε το αρχείο <span class=filename>boot.config</span> στον ριζικό κατάλογο της κατάτμησης <code>a</code> του δίσκου εκκίνησης.</p><div class=paragraph><p>Το αρχείο αυτό θα κατευθύνει τον κώδικα του boot block σχετικά με το πως θέλετε να εκκινήσει το σύστημα. Για να ενεργοποιήσετε την σειριακή κονσόλα, θα χρειαστείτε μία ή περισσότερες από τις παρακάτω επιλογές-αν θέλετε να προσδιορίσετε πολλαπλές επιλογές, θα πρέπει να τις περιλάβετε όλες στην ίδια γραμμή.</p></div><div class=dlist><dl><dt class=hdlist1><code>-h</code></dt><dd><p>Εναλλάσσει μεταξύ της εσωτερικής και της σειριακής κονσόλας. Για παράδειγμα, αν ξεκινήσετε από την εσωτερική κονσόλα (οθόνη), μπορείτε να χρησιμοποιήσετε την επιλογή <code>-h</code> για να κατευθύνετε το φορτωτή εκκίνησης και τον πυρήνα να χρησιμοποιήσουν τη σειριακή θύρα ως συσκευή κονσόλας. Εναλλακτικά, αν εκκινήσετε μέσω της σειριακής θύρας, μπορείτε να χρησιμοποιήσετε την επιλογή <code>-h</code> για να κατευθύνετε το φορτωτή εκκίνησης και τον πυρήνα να χρησιμοποιήσουν την κανονική κονσόλα αντί για τη σειριακή.</p></dd><dt class=hdlist1><code>-D</code></dt><dd><p>Εναλλάσσει μεταξύ της απλής και της διπλής κονσόλας. Στην ρύθμιση απλής κονσόλας, θα χρησιμοποιηθεί είτε η εσωτερική κονσόλα (απεικόνιση σε οθόνη) είτε η σειριακή θύρα, ανάλογα με το πως έχει τεθεί η επιλογή <code>-h</code> που εξετάσαμε παραπάνω. Σε περίπτωση διπλής κονσόλας, θα ενεργοποιηθούν ταυτόχρονα τόσο η εσωτερική όσο και η σειριακή κονσόλα, άσχετα από τη ρύθμιση της επιλογής <code>-h</code>. Σημειώστε ωστόσο ότι η ρύθμιση διπλής κονσόλας μπορεί να ενεργοποιηθεί μόνο κατά την εκκίνηση, όσο εκτελείται το boot block. Μόλις δοθεί ο έλεγχος στο φορτωτή εκκίνησης, η μοναδική κονσόλα που παραμένει είναι αυτή που καθορίζεται από την επιλογή <code>-h</code>.</p></dd><dt class=hdlist1><code>-P</code></dt><dd><p>Ενεργοποιεί την ανίχνευση πληκτρολογίου του boot block. Αν δεν βρεθεί πληκτρολόγιο, ενεργοποιούνται αυτόματα οι επιλογές <code>-D</code> και <code>-h</code>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Λόγω περιορισμών χώρου στην τρέχουσα έκδοση των boot blocks, η επιλογή <code>-P</code> μπορεί να ανιχνεύσει μόνο εκτεταμένα (extended) πληκτρολόγια. Πληκτρολόγια με λιγότερα από 101 πλήκτρα (και χωρίς τα πλήκτρα <kbd>F11</kbd> και <kbd>F12</kbd>) ίσως να μην ανιχνευθούν. Εξαιτίας αυτού του περιορισμού, είναι πιθανό να μην ανιχνευθούν και κάποια πληκτρολόγια φορητών υπολογιστών. Αν συμβαίνει αυτό στο σύστημα σας, θα πρέπει να σταματήσετε να χρησιμοποιείτε την επιλογή <code>-P</code>. Δυστυχώς, δεν υπάρχει κάποιος τρόπος να παρακάμψετε αυτό το πρόβλημα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Χρησιμοποιήστε είτε την επιλογή <code>-P</code> για να επιλέξετε την κονσόλα αυτόματα, ή την επιλογή <code>-h</code> για να ενεργοποιήσετε τη σειριακή κονσόλα.</p></div><div class=paragraph><p>Μπορείτε επίσης να περιλάβετε και άλλες επιλογές που περιγράφονται στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a>.</p></div><div class=paragraph><p>Όλες οι επιλογές εκκίνησης, εκτός της <code>-P</code>, θα περάσουν στο φορτωτή εκκίνησης (<span class=filename>/boot/loader</span>). Ο φορτωτής εκκίνησης θα καθορίσει αν η κονσόλα θα δημιουργηθεί στην οθόνη ή στη σειριακή θύρα, αφού εξετάσει μόνο την επιλογή <code>-h</code>. Αυτό σημαίνει ότι αν καθορίσετε την επιλογή <code>-D</code> αλλά όχι την επιλογή <code>-h</code> στο <span class=filename>/boot.config</span>, θα μπορείτε να χρησιμοποιήσετε την σειριακή θύρα ως κονσόλα μόνο κατά την εκτέλεση του boot block. Ο φορτωτής εκκίνησης όμως θα χρησιμοποιήσει την εσωτερική κονσόλα (οθόνη).</p></div></dd></dl></div></li><li><p>Εκκινήστε το μηχάνημα.</p><div class=paragraph><p>Όταν ξεκινήσετε το FreeBSD μηχάνημα, τα boot blocks θα δείξουν τα περιεχόμενα του <span class=filename>/boot.config</span> στην κονσόλα. Για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/boot.config: <span class=nt>-P</span>
Keyboard: no</code></pre></div></div><div class=paragraph><p>Η δεύτερη γραμμή θα εμφανιστεί μόνο αν βάλετε την επιλογή <code>-P</code> στο <span class=filename>/boot.config</span>, και δείχνει αν υπάρχει ή όχι συνδεμένο πληκτρολόγιο. Τα μηνύματα αυτά κατευθύνονται στην σειριακή ή στην εσωτερική κονσόλα, ή ακόμα και στις δύο, ανάλογα με την επιλογή που έχει γίνει στο <span class=filename>/boot.config</span>.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Επιλογές</th><th class="tableblock halign-left valign-top">Το μήνυμα εμφανίζεται στην</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>καμία</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική κονσόλα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή κονσόλα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική και σειριακή κονσόλα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή και εσωτερική κονσόλα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, πληκτρολόγιο συνδεμένο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική κονσόλα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, χωρίς πληκτρολόγιο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή κονσόλα</p></td></tr></tbody></table><div class=paragraph><p>Μετά τα παραπάνω μηνύματα, θα υπάρξει μια μικρή παύση πριν τα boot blocks συνεχίσουν φορτώνοντας το φορτωτή εκκίνησης, και πριν εμφανιστούν περισσότερα μηνύματα στην κονσόλα. Υπό κανονικές συνθήκες, δεν χρειάζεται να διακόψετε τα boot blocks, αλλά ίσως θέλετε να το κάνετε αυτό για να βεβαιωθείτε ότι όλα είναι ρυθμισμένα σωστά.</p></div><div class=paragraph><p>Πιέστε οποιοδήποτε πλήκτρο εκτός από το <kbd>Enter</kbd> στην κονσόλα για να διακόψετε τη διαδικασία εκκίνησης. Τα boot blocks θα σας ρωτήσουν για περισσότερες πληροφορίες. Θα πρέπει να δείτε κάτι όπως το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div><div class=paragraph><p>Επαληθεύστε ότι το παραπάνω μήνυμα εμφανίζεται είτε στη σειριακή κονσόλα, ή στην εσωτερική κονσόλα ή και στις δύο, ανάλογα με τις επιλογές που έχετε βάλει στο αρχείο <span class=filename>/boot.config</span>. Αν το μήνυμα εμφανίζεται στην σωστή κονσόλα, πιέστε <kbd>Enter</kbd> για να συνεχίσετε με τη διαδικασία εκκίνησης.</p></div><div class=paragraph><p>Αν επιθυμείτε σειριακή κονσόλα, αλλά δεν βλέπετε την προτροπή σε αυτήν, υπάρχει κάποιο λάθος στις ρυθμίσεις. Στο μεταξύ, γράψτε <code>-h</code> και πιέστε <kbd>Enter</kbd> ή <kbd>Return</kbd> (αν γίνεται) για να πείτε στο boot block (και έπειτα στο φορτωτή εκκίνησης και τον πυρήνα) να επιλέξει τη σειριακή θύρα για την κονσόλα. Μόλις το σύστημα ξεκινήσει, κοιτάξτε ξανά τις ρυθμίσεις για να βρείτε που είναι το λάθος.</p></div></li></ol></div></div></div><div class=paragraph><p>Μετά τη φόρτωση του φορτωτή εκκίνησης, βρίσκεστε στο τρίτο στάδιο της διαδικασίας εκκίνησης και έχετε ακόμα τη δυνατότητα να επιλέξετε μεταξύ της εσωτερικής και σειριακής κονσόλας, θέτοντας τις κατάλληλες μεταβλητές περιβάλλοντος στο φορτωτή εκκίνησης. Δείτε το <a href=#serialconsole-loader>Αλλαγή Κονσόλας μέσω του Φορτωτή Εκκίνησης</a>.</p></div></div><div class=sect2><h3 id=serialconsole-summary>51.4. Περίληψη<a class=anchor href=#serialconsole-summary></a></h3><div class=paragraph><p>Εδώ θα βρείτε μια περίληψη των διάφορων επιλογών που παρουσιάστηκαν σε αυτή την ενότητα, και την κονσόλα που επιλέχθηκε τελικά.</p></div><div class=sect3><h4 id=_1η_περίπτωση_έχετε_θέσει_το_flag_0x10_για_τη_θύρα_sio0>51.4.1. 1η Περίπτωση: Έχετε Θέσει το Flag 0x10 για τη Θύρα <span class=filename>sio0</span><a class=anchor href=#_1η_περίπτωση_έχετε_θέσει_το_flag_0x10_για_τη_θύρα_sio0></a></h4><div class="literalblock programlisting"><div class=content><pre>device sio0 flags 0x10</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Επιλογές στο /boot.config</th><th class="tableblock halign-left valign-top">Κονσόλα κατά τη διάρκεια των boot blocks</th><th class="tableblock halign-left valign-top">Κονσόλα κατά τη διάρκεια του φορτωτή εκκίνησης</th><th class="tableblock halign-left valign-top">Κονσόλα στον πυρήνα</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>καμία</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή και εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή και εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, πληκτρολόγιο συνδεμένο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, χωρίς πληκτρολόγιο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή και εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr></tbody></table></div><div class=sect3><h4 id=_2η_περίπτωση_έχετε_θέσει_το_flag_0x30_για_την_θύρα_sio0>51.4.2. 2η Περίπτωση: Έχετε Θέσει το Flag 0x30 για την Θύρα <span class=filename>sio0</span><a class=anchor href=#_2η_περίπτωση_έχετε_θέσει_το_flag_0x30_για_την_θύρα_sio0></a></h4><div class="literalblock programlisting"><div class=content><pre>device sio0 flags 0x30</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Επιλογές στο /boot.config</th><th class="tableblock halign-left valign-top">Κονσόλα κατά τη διάρκεια των boot blocks</th><th class="tableblock halign-left valign-top">Κονσόλα κατά τη διάρκεια του φορτωτή εκκίνησης</th><th class="tableblock halign-left valign-top">Κονσόλα στον πυρήνα</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>καμία</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή και εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή και εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, πληκτρολόγιο συνδεμένο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, χωρίς πληκτρολόγιο</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή και εσωτερική</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>σειριακή</p></td></tr></tbody></table></div></div><div class=sect2><h3 id=serialconsole-tips>51.5. Συμβουλές για την Σειριακή Κονσόλα<a class=anchor href=#serialconsole-tips></a></h3><div class=sect3><h4 id=_ρύθμιση_μεγαλύτερης_ταχύτητας_για_τη_σειριακή_θύρα>51.5.1. Ρύθμιση Μεγαλύτερης Ταχύτητας για τη Σειριακή Θύρα<a class=anchor href=#_ρύθμιση_μεγαλύτερης_ταχύτητας_για_τη_σειριακή_θύρα></a></h4><div class=paragraph><p>Οι προεπιλεγμένες ρυθμίσεις της σειριακής θύρας είναι: 9600 baud, 8 bits, χωρίς ισοτιμία (parity), 1 stop bit. Αν θέλετε να αλλάξετε την προεπιλεγμένη ταχύτητα της κονσόλας, έχετε τις παρακάτω επιλογές:</p></div><div class=ulist><ul><li><p>Επαναμεταγλωττίστε τα boot blocks θέτοντας τη μεταβλητή <code>BOOT_COMCONSOLE_SPEED</code> για να ορίσετε την νέα ταχύτητα κονσόλας. Δείτε το <a href=#serialconsole-com2>Χρησιμοποιώντας Σειριακή Θύρα Εκτός της <span class=filename>sio0</span> για την Κονσόλα.</a> για λεπτομερείς οδηγίες σχετικά με τη μεταγλώττιση και εγκατάσταση νέων boot blocks.</p><div class=paragraph><p>Αν η ενεργοποίηση της σειριακής κονσόλας δεν γίνεται μέσω της επιλογής <code>-h</code>, ή αν η σειριακή κονσόλα που χρησιμοποιείται από τον πυρήνα είναι διαφορετική από αυτή που χρησιμοποιείται από τα boot blocks, θα πρέπει επίσης να προσθέσετε την παρακάτω επιλογή στο αρχείο ρυθμίσεων του πυρήνα, και να μεταγλωττίσετε ένα νέο πυρήνα:</p></div><div class="literalblock programlisting"><div class=content><pre>options CONSPEED=19200</pre></div></div></li><li><p>Στις επιλογές εκκίνησης του πυρήνα, χρησιμοποιήστε το <code>-S</code>. Μπορείτε επίσης να προσθέσετε την επιλογή <code>-S</code> στο <span class=filename>/boot.config</span>. Η σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> περιέχει μια λίστα των υποστηριζόμενων επιλογών, και περιγράφει πως να τις προσθέσετε στο αρχείο <span class=filename>/boot.config</span>.</p></li><li><p>Ενεργοποιήστε την επιλογή <code>comconsole_speed</code> στο αρχείο <span class=filename>/boot/loader.conf</span>.</p><div class=paragraph><p>Για να λειτουργήσει αυτή η επιλογή, θα πρέπει επίσης να θέσετε τιμές για τις επιλογές <code>console</code>, <code>boot_serial</code>, και <code>boot_multicons</code> στο ίδιο αρχείο, το <span class=filename>/boot/loader.conf</span>. Παρακάτω φαίνεται ένα παράδειγμα χρήσης του <code>comconsole_speed</code> για αλλαγή ταχύτητα της σειριακής κονσόλας:</p></div><div class="literalblock programlisting"><div class=content><pre>boot_multicons=&#34;YES&#34;
boot_serial=&#34;YES&#34;
comconsole_speed=&#34;115200&#34;
console=&#34;comconsole,vidconsole&#34;</pre></div></div></li></ul></div></div><div class=sect3><h4 id=serialconsole-com2>51.5.2. Χρησιμοποιώντας Σειριακή Θύρα Εκτός της <span class=filename>sio0</span> για την Κονσόλα.<a class=anchor href=#serialconsole-com2></a></h4><div class=paragraph><p>Θα πρέπει να επαναμεταγλωττίσετε κάποια προγράμματα για να χρησιμοποιήσετε ως κονσόλα μια σειριακή θύρα εκτός της <span class=filename>sio0</span>. Αν για οποιοδήποτε λόγο θέλετε να χρησιμοποιήσετε άλλη σειριακή θύρα, θα πρέπει να επαναμεταγλωττίσετε τα boot blocks, το φορτωτή εκκίνησης και τον πυρήνα, με τον τρόπο που φαίνεται παρακάτω.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Ανακτήστε τον πηγαίο κώδικα του πυρήνα. (Δείτε το <a href=./#updating-upgrading>Ενημέρωση και Αναβάθμιση του FreeBSD</a>)</p></li><li><p>Επεξεργαστείτε το αρχείο <span class=filename>/etc/make.conf</span> και θέστε την επιλογή <code>BOOT_COMCONSOLE_PORT</code> στη διεύθυνση της θύρας που θέλετε να χρησιμοποιήσετε (0x3F8, 0x2F8, 0x3E8 or 0x2E8). Μπορείτε να χρησιμοποιήσετε μόνο τις θύρες <span class=filename>sio0</span> ως <span class=filename>sio3</span> (<span class=filename>COM1</span> ως <span class=filename>COM4</span>). Κάρτες πολλαπλών θυρών, δεν πρόκειται να λειτουργήσουν. Δεν χρειάζεται να ρυθμίσετε την τιμή του interrupt.</p></li><li><p>Δημιουργήστε ένα αρχείο ρύθμισης προσαρμοσμένου πυρήνα, και προσθέστε τα κατάλληλα flags για τη σειριακή θύρα που επιθυμείτε να χρησιμοποιήσετε. Για παράδειγμα, αν θέλετε η <span class=filename>sio1</span> (<span class=filename>COM2</span>) να γίνει η κονσόλα:</p><div class="literalblock programlisting"><div class=content><pre>device sio1 flags 0x10</pre></div></div><div class=paragraph><p>ή</p></div><div class="literalblock programlisting"><div class=content><pre>device sio1 flags 0x30</pre></div></div><div class=paragraph><p>Δεν θα πρέπει να θέσετε flags κονσόλας για τις άλλες σειριακές θύρες.</p></div></li><li><p>Μεταγλωττίστε και εγκαταστήστε ξανά τα boot blocks και τον φορτωτή εκκίνησης:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot</span>
<span class=c># make clean</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div></li><li><p>Επαναμεταγλωττίστε και εγκαταστήστε τον πυρήνα.</p></li><li><p>Γράψτε τα boot blocks στον δίσκο εκκίνησης χρησιμοποιώντας την <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> και εκκινήστε με το νέο πυρήνα.</p></li></ol></div></div><div class=sect3><h4 id=serialconsole-ddb>51.5.3. Είσοδος στον DDB Debugger Μέσω της Σειριακής Γραμμής<a class=anchor href=#serialconsole-ddb></a></h4><div class=paragraph><p>Αν θέλετε να εισέλθετε στον debugger του πυρήνα από την σειριακή κονσόλα (κάτι που είναι χρήσιμο για να εκτελέσετε διαγνωστικά από απομακρυσμένη τοποθεσία, αλλά επίσης και επικίνδυνο αν στείλετε κατά λάθος BREAK μέσω της σειριακής θύρας!) θα πρέπει να περιλάβετε την παρακάτω επιλογή στον πυρήνα σας:</p></div><div class="literalblock programlisting"><div class=content><pre>options BREAK_TO_DEBUGGER
options DDB</pre></div></div></div><div class=sect3><h4 id=_προτροπή_εισόδου_στην_σειριακή_κονσόλα>51.5.4. Προτροπή Εισόδου στην Σειριακή Κονσόλα<a class=anchor href=#_προτροπή_εισόδου_στην_σειριακή_κονσόλα></a></h4><div class=paragraph><p>Αν και αυτό δεν είναι απαραίτητο, ίσως να θέλετε να έχετε προτροπή εισόδου (<em>login</em>) μέσω της σειριακής γραμμής, τώρα που μπορείτε πλέον να δείτε τα μηνύματα εκκίνησης και να εισέλθετε στο debugger του πυρήνα μέσω της σειριακής κονσόλας. Η διαδικασία περιγράφεται παρακάτω.</p></div><div class=paragraph><p>Με κάποιο συντάκτη κειμένου, ανοίξτε το αρχείο <span class=filename>/etc/ttys</span> και βρείτε τις γραμμές:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyu1 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyu2 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyu3 &#34;/usr/libexec/getty std.9600&#34; unknown off secure</pre></div></div><div class=paragraph><p>Οι καταχωρίσεις από <span class=filename>ttyu0</span> ως <span class=filename>ttyu3</span> αντιστοιχούν στις <span class=filename>COM1</span> ως <span class=filename>COM4</span>. Αλλάξτε το <code>off</code> σε <code>on</code> για την θύρα που επιθυμείτε. Αν έχετε αλλάξει την ταχύτητα της σειριακής θύρας, θα χρειαστεί να αλλάξετε το <code>std.9600</code> ώστε να ταιριάζει με την τρέχουσα ρύθμιση, π.χ. <code>std.19200</code>.</p></div><div class=paragraph><p>Μάλλον θα θέλετε να αλλάξετε και τον τύπο του τερματικού, από <code>unknown</code> στον πραγματικό τύπου του σειριακού σας τερματικού.</p></div><div class=paragraph><p>Αφού αλλάξετε τις ρυθμίσεις, θα πρέπει να εκτελέσετε την εντολή <code>kill -HUP 1</code> ώστε να ενεργοποιηθούν.</p></div></div></div><div class=sect2><h3 id=serialconsole-loader>51.6. Αλλαγή Κονσόλας μέσω του Φορτωτή Εκκίνησης<a class=anchor href=#serialconsole-loader></a></h3><div class=paragraph><p>Σε προηγούμενες ενότητες, περιγράψαμε πως να ρυθμίσετε την σειριακή κονσόλα αλλάζοντας τις ρυθμίσεις του boot block. Στην ενότητα αυτή, δείχνουμε πως μπορείτε να καθορίσετε την κονσόλα δίνοντας κάποιες εντολές και μεταβλητές περιβάλλοντος στον φορτωτή εκκίνησης. Καθώς ο φορτωτής εκκίνησης καλείται από το τρίτο στάδιο της διαδικασίας εκκίνησης, και μετά το boot block, οι ρυθμίσεις του φορτωτή εκκίνησης υπερισχύουν σε σχέση με αυτές του boot block.</p></div><div class=sect3><h4 id=_ρύθμιση_της_σειριακής_κονσόλας>51.6.1. Ρύθμιση της Σειριακής Κονσόλας<a class=anchor href=#_ρύθμιση_της_σειριακής_κονσόλας></a></h4><div class=paragraph><p>Μπορείτε εύκολα να καθορίσετε ότι θα χρησιμοποιηθεί η σειριακή κονσόλα στον φορτωτή εκκίνησης και στον πυρήνα που θα φορτωθεί, γράφοντας απλώς μια γραμμή στο <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>console=&#34;comconsole&#34;</pre></div></div><div class=paragraph><p>Η ρύθμιση αυτή θα ενεργοποιηθεί, άσχετα με το boot block που συζητήσαμε στην προηγούμενη ενότητα.</p></div><div class=paragraph><p>Είναι καλύτερα η γραμμή αυτή να είναι η πρώτη στο αρχείο <span class=filename>/boot/loader.conf</span>, ώστε να βλέπετε τα αρχικά μηνύματα εκκίνησης στη σειριακή κονσόλα.</p></div><div class=paragraph><p>Με τον ίδιο τρόπο, μπορείτε να καθορίσετε την εσωτερική κονσόλα ως:</p></div><div class="literalblock programlisting"><div class=content><pre>console=&#34;vidconsole&#34;</pre></div></div><div class=paragraph><p>Αν δεν καθορίσετε τη μεταβλητή περιβάλλοντος <code>console</code>, ο φορτωτής εκκίνησης (και έπειτα ο πυρήνας) θα χρησιμοποιήσουν οποιαδήποτε κονσόλα έχετε καθορίσει στο boot block με την επιλογή <code>-h</code>.</p></div><div class=paragraph><p>Μπορείτε να καθορίσετε την κονσόλα στο <span class=filename>/boot/loader.conf.local</span> ή στο <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> για περισσότερες πληροφορίες.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Τη δεδομένη στιγμή, ο φορτωτής εκκίνησης δεν έχει επιλογή αντίστοιχη με την <code>-P</code> του boot block, και δεν υπάρχει κάποιος τρόπος να γίνει αυτόματη επιλογή μεταξύ εσωτερικής και σειριακής κονσόλας ανάλογα με την παρουσία πληκτρολογίου.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_χρήση_σειριακής_θύρας_εκτός_της_sio0_για_την_κονσόλα>51.6.2. Χρήση Σειριακής Θύρας Εκτός της <span class=filename>sio0</span> για την Κονσόλα<a class=anchor href=#_χρήση_σειριακής_θύρας_εκτός_της_sio0_για_την_κονσόλα></a></h4><div class=paragraph><p>Θα πρέπει να επαναμεταγλωττίσετε το φορτωτή εκκίνησης ώστε να χρησιμοποιήσει μια σειριακή θύρα διαφορετική από την <span class=filename>sio0</span> για τη σειριακή κονσόλα. Ακολουθήστε τη διαδικασία που περιγράφεται στο <a href=#serialconsole-com2>Χρησιμοποιώντας Σειριακή Θύρα Εκτός της <span class=filename>sio0</span> για την Κονσόλα.</a>.</p></div></div></div><div class=sect2><h3 id=serialconsole-caveats>51.7. Πιθανές Παγίδες<a class=anchor href=#serialconsole-caveats></a></h3><div class=paragraph><p>Η γενική ιδέα είναι να επιτρέπεται σε όσους το επιθυμούν, να δημιουργήσουν εξειδικευμένους εξυπηρετητές που δεν απαιτούν κάρτες γραφικών και πληκτρολόγια. Δυστυχώς, αν και τα περισσότερα συστήματα θα σας επιτρέψουν να εκκινήσετε χωρίς πληκτρολόγιο, σε πολύ λίγα θα μπορέσετε να εκκινήσετε χωρίς κάρτα γραφικών. Τα μηχανήματα με BIOS της AMI μπορούν να ρυθμιστούν με αυτό τον τρόπο, αλλάζοντας την επιλογή "graphics adapter" στις ρυθμίσεις του CMOS σε "Not installed."</p></div><div class=paragraph><p>Τα περισσότερα μηχανήματα ωστόσο δεν υποστηρίζουν αυτή την επιλογή, και θα αρνηθούν να εκκινήσουν αν δεν βάλετε μια κάρτα γραφικών. Στα μηχανήματα αυτά θα πρέπει να αφήσετε μια στοιχειώδη (ακόμα και μονόχρωμη) κάρτα γραφικών, αν και δεν είναι απαραίτητο να συνδέσετε και οθόνη. Μπορείτε επίσης να δοκιμάσετε να εγκαταστήσετε BIOS της AMI.</p></div></div></div></div><div class=sect1><h2 id=ppp-and-slip>Chapter 52. PPP<a class=anchor href=#ppp-and-slip></a></h2><div class=sectionbody><div class=sect2><h3 id=ppp-and-slip-synopsis>52.1. Σύνοψη<a class=anchor href=#ppp-and-slip-synopsis></a></h3><div class=paragraph><p>Το FreeBSD διαθέτει πλήθος τρόπων για τη σύνδεση ενός υπολογιστή με ένα άλλο. Για να επιτύχετε σύνδεση μέσω modem στο Internet ή σε ένα άλλο δίκτυο, ή για να επιτρέψετε σε άλλους να συνδεθούν μέσω του συστήματος σας, απαιτείται η χρήση PPP ή SLIP. Το κεφάλαιο αυτό περιγράφει λεπτομερώς τον τρόπο ρύθμισης των παραπάνω υπηρεσιών για χρήση μέσω modem.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να ρυθμίσετε το PPP χρήστη (User PPP).</p></li><li><p>Πως να ρυθμίσετε το PPP πυρήνα (Kernel PPP, μόνο για FreeBSD 7.X).</p></li><li><p>Πως να ρυθμίσετε το PPPoE (PPP μέσω Ethernet).</p></li><li><p>Πως να ρυθμίσετε το PPPoA (PPP μέσω ATM).</p></li><li><p>Πως να ρυθμίσετε ένα πελάτη και εξυπηρετητή SLIP (μόνο για FreeBSD 7.X).</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να είστε εξοικειωμένος με τη βασική ορολογία των δικτύων.</p></li><li><p>Να κατανοείτε τις βασικές έννοιες και το σκοπό των επιλογικών συνδέσεων και του PPP και/ή SLIP.</p></li></ul></div><div class=paragraph><p>Μπορεί να αναρωτιέστε ποια είναι η βασική διαφορά μεταξύ του PPP χρήστη και του PPP πυρήνα. Η απάντηση είναι απλή: το PPP χρήστη επεξεργάζεται τα δεδομένα εισόδου και εξόδου μέσω προγραμμάτων χρήστη (userland) αντί διαμέσου του πυρήνα του λειτουργικού. Αυτό προκαλεί κάποιες επιβαρύνσεις λόγω της αντιγραφής δεδομένων μεταξύ του πυρήνα και της εφαρμογής χρήστη, αλλά επιτρέπει κατά πολύ πιο πλούσια (από άποψη δυνατοτήτων) υλοποίηση του PPP πρωτοκόλλου. Το PPP χρήστη χρησιμοποιεί τη συσκευή <span class=filename>tun</span> για την επικοινωνία με τον έξω κόσμο, ενώ το PPP πυρήνα χρησιμοποιεί την συσκευή <span class=filename>ppp</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σε όλο το κεφάλαιο, το PPP χρήστη θα αναφέρεται απλά ως ppp εκτός και αν χρειάζεται να γίνει διάκριση σε σχέση με άλλο λογισμικό PPP όπως το pppd (μόνο για το FreeBSD 7.X). Εκτός αν αναφέρεται διαφορετικά, όλες οι εντολές που εξηγούνται στο κεφάλαιο αυτό θα πρέπει να εκτελούνται ως <code>root</code>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=userppp>52.2. Χρησιμοποιώντας το PPP Χρήστη<a class=anchor href=#userppp></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, τα ονόματα συσκευών για τις σειριακές θύρες μετονομάστηκαν από <span class=filename>/dev/cuadN</span> σε <span class=filename>/dev/cuauN</span> και από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα χρειαστεί να προσαρμόσουν τις παρακάτω οδηγίες σύμφωνα με αυτές τις αλλαγές.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_ppp_χρήστη>52.2.1. PPP Χρήστη<a class=anchor href=#_ppp_χρήστη></a></h4><div class=sect4><h5 id=_προϋποθέσεις>52.2.1.1. Προϋποθέσεις<a class=anchor href=#_προϋποθέσεις></a></h5><div class=paragraph><p>Το κείμενο αυτό προϋποθέτει ότι έχετε τα παρακάτω:</p></div><div class=ulist><ul><li><p>Λογαριασμό σε κάποιο Παροχέα Υπηρεσιών Internet (ISP) στον οποίο συνδέεστε χρησιμοποιώντας PPP.</p></li><li><p>Ένα modem ή άλλη συσκευή συνδεμένη στο σύστημα σας, και ρυθμισμένη σωστά ώστε να σας επιτρέπει να συνδεθείτε στον ISP σας.</p></li><li><p>Τους αριθμούς κλήσης για τον ISP σας.</p></li><li><p>Το όνομα χρήστη (login) και τον κωδικό σας (password). Είτε κανονικό όνομα και κωδικό (τύπου UNIX®) ή ένα ζεύγος ονόματος / κωδικού τύπου PAP ή CHAP.</p></li><li><p>Τις IP διευθύνσεις ενός ή περισσότερων διακομιστών ονομάτων (DNS). Φυσιολογικά, ο ISP σας θα σας δώσει δύο τέτοιες διευθύνσεις. Αν δεν έχετε τουλάχιστον μία, μπορείτε να ενεργοποιήσετε την εντολή <code>enable dns</code> στο <span class=filename>ppp.conf</span> και το ppp θα ρυθμίσει τους διακομιστές ονομάτων για σας. Το χαρακτηριστικό αυτό εξαρτάται από την υποστήριξη της διαπραγμάτευσης DNS από τον ISP σας.</p></li></ul></div><div class=paragraph><p>Ο ISP σας ενδεχομένως να σας δώσει και τις παρακάτω πληροφορίες, αλλά δεν είναι εντελώς απαραίτητες:</p></div><div class=ulist><ul><li><p>Τη διεύθυνση IP για την πύλη (gateway) του ISP σας. Η πύλη είναι το μηχάνημα μέσω του οποίου συνδέεστε, και θα αποτελέσει την <em>προεπιλεγμένη διαδρομή</em> (default route) για το μηχάνημα σας. Αν δεν έχετε αυτή την πληροφορία, θα χρησιμοποιηθεί μια εικονική, και όταν συνδεθείτε θα λάβετε την κανονική διεύθυνση από τον διακομιστή PPP του ISP σας.</p><div class=paragraph><p>Αυτή η διεύθυνση IP αναφέρεται ως <code>HISADDR</code> από το ppp.</p></div></li><li><p>Τη μάσκα δικτύου (netmask) που πρέπει να χρησιμοποιήσετε. Αν ο ISP σας δε σας την παρέχει, μπορείτε με ασφάλεια να χρησιμοποιήσετε την τιμή <code>255.255.255.255</code>.</p></li><li><p>Αν ο ISP σας παρέχει στατική διεύθυνση και όνομα υπολογιστή (hostname) μπορείτε να χρησιμοποιήσετε αυτά. Διαφορετικά, θα αφήσουμε τον απομακρυσμένο υπολογιστή να δώσει όποια διεύθυνση IP θεωρεί κατάλληλη.</p></li></ul></div><div class=paragraph><p>Αν σας λείπουν κάποιες από τις απαιτούμενες πληροφορίες, επικοινωνήστε με τον ISP σας.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σε ολόκληρη την παρούσα ενότητα, πολλά από τα παραδείγματα που δείχνουν τα περιεχόμενα των αρχείων ρυθμίσεων, είναι αριθμημένα ανά γραμμή. Οι αριθμοί αυτοί εξυπηρετούν στην παρουσίαση και τη συζήτηση του κάθε παραδείγματος, και δεν πρέπει να γραφούν μέσα στο πραγματικό αρχείο. Είναι επίσης σημαντικό να τηρείτε η σωστή στοίχιση σε κάθε αρχείο, με τη χρήση στηλοθετών (tabs) και κενών διαστημάτων.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_αυτόματη_ρύθμιση_ppp>52.2.1.2. Αυτόματη Ρύθμιση PPP<a class=anchor href=#_αυτόματη_ρύθμιση_ppp></a></h5><div class=paragraph><p>Τόσο το <code>ppp</code> όσο και το <code>pppd</code> (η υλοποίηση του PPP σε επίπεδο πυρήνα, μόνο στο FreeBSD 7.X) χρησιμοποιούν τα αρχεία ρυθμίσεων στον κατάλογο <span class=filename>/etc/ppp</span>. Μπορείτε να βρείτε παραδείγματα για το ppp χρήστη στον κατάλογο <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class=paragraph><p>H ρύθμιση του <code>ppp</code> απαιτεί την τροποποίηση ενός αριθμού από αρχεία, ανάλογα με τις απαιτήσεις σας. Το τι θα βάλετε σε αυτά, εξαρτάται σε ένα ποσοστό από το αν ο ISP σας αποδίδει στατικές διευθύνσεις IP (δηλ. σας παρέχει μια διεύθυνση IP η οποία δεν αλλάζει) ή δυναμικές (δηλ. η IP διεύθυνση σας αλλάζει κάθε φορά που συνδέεστε στον ISP σας).</p></div><div class=sect5><h6 id=userppp-staticIP>52.2.1.2.1. PPP και Στατικές Διευθύνσεις IP<a class=anchor href=#userppp-staticIP></a></h6><div class=paragraph><p>Θα χρειαστεί να τροποποιήσετε το αρχείο ρυθμίσεων <span class=filename>/etc/ppp/ppp.conf</span>. Θα πρέπει να μοιάζει με αυτό που φαίνεται παρακάτω:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι γραμμές που τελειώνουν με <code>:</code> ξεκινούν στην πρώτη στήλη (αρχή της γραμμής) - όλες οι άλλες γραμμές θα πρέπει να στοιχισθούν με τον τρόπο που φαίνεται, με τη χρήση κενών ή στηλοθετών.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION (built COMPILATIONDATE)
4       set device /dev/cuau0
5       set speed 115200
6       set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \&#34;\&#34; AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT&#34;
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone &#34;(123) 456 7890&#34;
13      set authname foo
14      set authkey bar
15      set login &#34;TIMEOUT 10 \&#34;\&#34; \&#34;\&#34; gin:--gin: \\U word: \\P col: ppp&#34;
16      set timeout 300
17      set ifaddr x.x.x.x y.y.y.y 255.255.255.255 0.0.0.0
18      add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Γραμμή 1</dt><dd><p>Αναγνωρίζει την προεπιλεγμένη καταχώριση. Οι εντολές σε αυτή την καταχώριση εκτελούνται αυτόματα, όταν εκτελείται το ppp.</p></dd><dt class=hdlist1>Γραμμή 2</dt><dd><p>Ενεργοποιεί την καταγραφή (logging) των παραμέτρων. Όταν οι ρυθμίσεις που έχουν γίνει λειτουργούν ικανοποιητικά, η γραμμή αυτή θα πρέπει να μικρύνει στην παρακάτω:</p><div class="literalblock programlisting"><div class=content><pre>set log phase tun</pre></div></div><div class=paragraph><p>για να αποφευχθούν μεγάλα μεγέθη στα αρχεία καταγραφής.</p></div></dd><dt class=hdlist1>Γραμμή 3</dt><dd><p>Λέει στο PPP πως να αναφέρει πληροφορίες για τον εαυτό του στην άλλη μεριά της σύνδεσης. Η διαδικασία αυτή γίνεται αν το PPP έχει πρόβλημα στην διαπραγμάτευση και ολοκλήρωση της σύνδεσης, παρέχοντας με αυτό τον τρόπο πληροφορίες στον απομακρυσμένο διαχειριστή. Οι πληροφορίες αυτές μπορεί να είναι χρήσιμες στην επίλυση του προβλήματος.</p></dd><dt class=hdlist1>Γραμμή 4</dt><dd><p>Αναγνωρίζει τη συσκευή στην οποία είναι συνδεμένο το modem. Η συσκευή <span class=filename>COM1</span> είναι η <span class=filename>/dev/cuau0</span> και η <span class=filename>COM2</span> είναι η <span class=filename>/dev/cuau1</span>.</p></dd><dt class=hdlist1>Γραμμή 5</dt><dd><p>Καθορίζει την ταχύτητα με την οποία επιθυμείτε να συνδεθείτε. Αν δεν λειτουργεί η τιμή 115200 (η οποία πρέπει να λειτουργεί με κάθε σχετικά σύγχρονο modem), δοκιμάστε με 38400.</p></dd><dt class=hdlist1>Γραμμές 6 & 7</dt><dd><p>Το αλφαριθμητικό που θα χρησιμοποιηθεί για την κλήση. Το PPP χρήστη χρησιμοποιεί σύνταξη expect-send παρόμοια με αυτή που χρησιμοποιεί το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a>. Δείτε τη σελίδα manual για πληροφορίες σχετικά με τις δυνατότητες αυτής της γλώσσας.</p><div class=paragraph><p>Σημειώστε ότι αυτή η εντολή συνεχίζει στην επόμενη γραμμή για λόγους αναγνωσιμότητας. Αυτό μπορεί να γίνει σε κάθε εντολή του <span class=filename>ppp.conf</span>, εφόσον το <code>\</code> είναι ο τελευταίος χαρακτήρας της γραμμής.</p></div></dd><dt class=hdlist1>Γραμμή 8</dt><dd><p>Καθορίζει το χρόνο τερματισμού λόγω αδράνειας της σύνδεσης. Τα 180 δευτερόλεπτα είναι η προεπιλεγμένη τιμή, έτσι η γραμμή αυτή είναι εδώ καθαρά διακοσμητική.</p></dd><dt class=hdlist1>Γραμμή 9</dt><dd><p>Λέει στο PPP να ρωτήσει την άλλη πλευρά για να επιβεβαιώσει τις τοπικές ρυθμίσεις του resolver. Αν εκτελείτε τοπικό διακομιστή ονομάτων (DNS), θα πρέπει να μετατρέψετε αυτή τη γραμμή σε σχόλιο ή να την αφαιρέσετε.</p></dd><dt class=hdlist1>Γραμμή 10</dt><dd><p>Κενή γραμμή ώστε η ανάγνωση του αρχείου να είναι πιο εύκολη. Οι κενές γραμμές αγνοούνται από το PPP.</p></dd><dt class=hdlist1>Γραμμή 11</dt><dd><p>Αναγνωρίζει την καταχώριση ενός παροχέα με το όνομα "provider". Μπορείτε εδώ να χρησιμοποιήσετε το όνομα του ISP σας, ώστε αργότερα να ξεκινάτε τη σύνδεση σας με την επιλογή <code>load <em>ISP</em></code>.</p></dd><dt class=hdlist1>Γραμμή 12</dt><dd><p>Θέτει τον αριθμό κλήσης για αυτό τον παροχέα. Μπορείτε να καθορίσετε πολλαπλούς αριθμούς κλήσης χρησιμοποιώντας άνω-κάτω τελεία (<code>:</code>) ή τον χαρακτήρα (<code>|</code>) ως διαχωριστικό. Η διαφορά μεταξύ των δύο διαχωριστικών περιγράφεται στο <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>. Περιληπτικά, αν θέλετε να δοκιμάζονται κυκλικά όλοι οι αριθμοί, χρησιμοποιήστε την άνω-κάτω τελεία. Αν θέλετε να γίνεται πάντοτε απόπειρα κλήσης του πρώτου αριθμού και οι υπόλοιποι να δοκιμάζονται μόνο αν ο πρώτος αποτύχει, χρησιμοποιήστε το χαρακτήρα παροχέτευσης. Να γράφετε πάντοτε όλο το σύνολο των τηλεφωνικών αριθμών με τον τρόπο που φαίνεται.</p><div class=paragraph><p>Αν ο αριθμός τηλεφώνου περιέχει κενά, θα πρέπει να τον περικλείσετε σε εισαγωγικά (<code>"</code>). Η παράλειψη τους, αν και είναι απλό σφάλμα, μπορεί να προκαλέσει προβλήματα που δεν μπορούν να εντοπιστούν εύκολα.</p></div></dd><dt class=hdlist1>Γραμμές 13 & 14</dt><dd><p>Αναγνωρίζει το όνομα χρήστη και τον κωδικό του. Όταν συνδέεστε χρησιμοποιώντας προτροπή τύπου UNIX®, οι τιμές αυτές αναφέρονται από την εντολή <code>set login</code> χρησιμοποιώντας τις μεταβλητές \U και \P. Όταν συνδέεστε με χρήση PAP ή CHAP, οι τιμές αυτές χρησιμοποιούνται την ώρα της πιστοποίησης ταυτότητας του χρήστη.</p></dd><dt class=hdlist1>Γραμμή 15</dt><dd><p>Αν χρησιμοποιείτε PPP ή CHAP, δεν θα υπάρχει στο σημείο αυτό προτροπή εισόδου (login), και θα πρέπει να μετατρέψετε τη γραμμή αυτή σε σχόλιο ή να την αφαιρέσετε. Δείτε την <a href=#userppp-PAPnCHAP>Πιστοποίηση PAP και CHAP</a> για περισσότερες λεπτομέρειες.</p><div class=paragraph><p>Το αλφαριθμητικό εισόδου χρησιμοποιεί σύνταξη παρόμοια με το <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a>, όπως συμβαίνει και με το αλφαριθμητικό κλήσης. Στο παράδειγμα μας, το αλφαριθμητικό χρησιμοποιείται για μια υπηρεσία στην οποία η συνεδρία εισόδου μοιάζει με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>J. Random Provider
login: foo
password: bar
protocol: ppp</code></pre></div></div><div class=paragraph><p>Θα χρειαστεί να αλλάξετε αυτό το script ανάλογα με τις ανάγκες σας. Όταν γράφετε αυτό το script την πρώτη φορά, βεβαιωθείτε ότι έχετε ενεργοποιήσει το αρχείο καταγραφής για το "chat" ώστε να μπορείτε να προσδιορίσετε αν η διαδικασία αναγνώρισης προχωράει σωστά.</p></div></dd><dt class=hdlist1>Γραμμή 16</dt><dd><p>Θέτει το χρόνο αδράνειας (σε δευτερόλεπτα) για τη σύνδεση. Εδώ, η σύνδεση θα κλείσει αυτόματα αν δεν υπάρχει κίνηση για 300 δευτερόλεπτα. Αν δεν θέλετε να γίνεται ποτέ τερματισμός της σύνδεσης λόγω αδράνειας, θέστε αυτή τη τιμή σε μηδέν, ή χρησιμοποιήστε την επιλογή <code>-ddial</code> στη γραμμή εντολής.</p></dd><dt class=hdlist1>Γραμμή 17</dt><dd><p>Θέτει τη διεύθυνση της διεπαφής. Το αλφαριθμητικό <em>x.x.x.x</em> θα πρέπει να αντικατασταθεί με τη διεύθυνση IP που σας έχει αποδοθεί από τον παροχέα σας. Το αλφαριθμητικό <em>y.y.y.y</em> θα πρέπει να αντικατασταθεί με την διεύθυνση IP που έχει καθορίσει ο ISP σας ως πύλη (gateway, το μηχάνημα στο οποίο συνδέεστε). Αν ο ISP σας δεν σας έχει δώσει διεύθυνση πύλης, χρησιμοποιήστε την <code>10.0.0.2/0</code>. Αν πρέπει να χρησιμοποιήσετε μια IP διεύθυνση που έχετε "μαντέψει", βεβαιωθείτε ότι έχετε δημιουργήσει μια καταχώριση στο <span class=filename>/etc/ppp/ppp.linkup</span> σύμφωνα με τις οδηγίες για το <a href=#userppp-dynamicIP>PPP και Δυναμικές IP Διευθύνσεις</a>. Αν παραλείψετε αυτή τη γραμμή, το <code>ppp</code> δεν θα μπορεί να εκτελεστεί σε κατάσταση <code>-auto</code>.</p></dd><dt class=hdlist1>Γραμμή 18</dt><dd><p>Προσθέστε μια προεπιλεγμένη διαδρομή (default route) προς το μηχάνημα πύλης (gateway) του ISP σας. Η ειδική λέξη <code>HISADDR</code> αντικαθίσταται με την διεύθυνση πύλης που καθορίζεται στη γραμμή 17. Είναι σημαντικό η γραμμή αυτή να εμφανίζεται μετά την γραμμή 17, διαφορετικά το <code>HISADDR</code> δεν θα έχει ακόμα λάβει αρχική τιμή.</p><div class=paragraph><p>Αν δεν επιθυμείτε να εκτελέσετε το ppp σε κατάσταση <code>-auto</code>, θα πρέπει να μετακινήσετε αυτή τη γραμμή στο αρχείο <span class=filename>ppp.linkup</span>.</p></div></dd></dl></div><div class=paragraph><p>Δεν είναι απαραίτητο να προσθέσετε καταχώριση στο αρχείο <span class=filename>ppp.linkup</span> όταν έχετε στατική διεύθυνση IP και εκτελείτε το ppp σε κατάσταση <code>-auto</code>. Στην περίπτωση αυτή, οι καταχωρίσεις σας στον πίνακα δρομολόγησης είναι σωστές πριν καν συνδεθείτε. Ίσως ωστόσο να θέλετε να δημιουργήσετε μια καταχώριση για να εκτελέσετε κάποια προγράμματα μετά την αποκατάσταση της σύνδεσης. Θα το εξηγήσουμε αυτό αργότερα σε ένα παράδειγμα με το sendmail.</p></div><div class=paragraph><p>Μπορείτε να βρείτε παραδείγματα αρχείων ρυθμίσεων στον κατάλογο <span class=filename>usr/shared/examples/ppp/</span>.</p></div></div><div class=sect5><h6 id=userppp-dynamicIP>52.2.1.2.2. PPP και Δυναμικές Διευθύνσεις IP<a class=anchor href=#userppp-dynamicIP></a></h6><div class=paragraph><p>Αν ο παροχέας σας δεν δίνει στατικές διευθύνσεις, το <code>ppp</code> μπορεί να ρυθμιστεί να διαπραγματεύεται την τοπική και την απομακρυσμένη διεύθυνση. Αυτό γίνεται "μαντεύοντας" μια διεύθυνση IP, και επιτρέποντας στο <code>ppp</code> να την θέσει έπειτα σωστά, χρησιμοποιώντας το πρωτόκολλο IPCP (IP Configuration Protocol) μετά τη σύνδεση. Το αρχείο ρυθμίσεων <span class=filename>ppp.conf</span> είναι το ίδιο όπως και στο <a href=#userppp-staticIP>PPP και Στατικές Διευθύνσεις IP</a>, με την παρακάτω μόνο αλλαγή:</p></div><div class="literalblock programlisting"><div class=content><pre>17      set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0</pre></div></div><div class=paragraph><p>Όπως και προηγουμένως, δεν πρέπει να περιλάβετε τον αριθμό γραμμής. Απαιτείται εσοχή ενός τουλάχιστον κενού διαστήματος.</p></div><div class=dlist><dl><dt class=hdlist1>Γραμμή 17</dt><dd><p>Ο αριθμός μετά το χαρακτήρα <code>/</code> είναι το πλήθος των bits της διεύθυνσης για το οποίο θα επιμείνει το ppp. Ίσως θέλετε να χρησιμοποιήσετε αριθμούς IP πιο κατάλληλους για την περίσταση, αλλά το παράδειγμα που δίνουμε παραπάνω θα λειτουργήσει πάντα.</p><div class=paragraph><p>Το τελευταίο όρισμα (το <code>0.0.0.0</code>) λέει στο PPP να αρχίσει τις διαπραγματεύσεις με την διεύθυνση <code>0.0.0.0</code> αντί για την <code>10.0.0.1</code>. Αυτό είναι απαραίτητο σε ορισμένους ISP. Μη χρησιμοποιήσετε το <code>0.0.0.0</code> ως πρώτο όρισμα στην <code>set ifaddr</code>, καθώς θα εμποδίσει την PPP να ρυθμίσει την αρχική διαδρομή στην κατάσταση <code>-auto</code> .</p></div></dd></dl></div><div class=paragraph><p>Αν δεν χρησιμοποιείτε την επιλογή <code>-auto</code>, θα χρειαστεί να δημιουργήσετε μια καταχώριση στο αρχείο <span class=filename>/etc/ppp/ppp.linkup</span>. Το αρχείο <span class=filename>ppp.linkup</span> χρησιμοποιείται μετά την αποκατάσταση της σύνδεσης. Στο σημείο αυτό, το <code>ppp</code> θα έχει ήδη αποδώσει διεύθυνση στην διεπαφή και θα είναι πλέον δυνατόν να προσθέσετε τις καταχωρίσεις στον πίνακα δρομολόγησης:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2      add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Γραμμή 1</dt><dd><p>Με την αποκατάσταση της σύνδεσης, το <code>ppp</code> θα ψάξει για μια καταχώριση στο <span class=filename>ppp.linkup</span> σύμφωνα με τους παρακάτω κανόνες: Αρχικά θα προσπαθήσει να ταιριάξει την πρώτη ετικέτα που έχει χρησιμοποιηθεί στο αρχείο <span class=filename>ppp.conf</span>. Αν αυτό αποτύχει, θα ψάξει για μια καταχώριση για την διεύθυνση IP της πύλης. Η καταχώριση αυτή είναι μια ετικέτα μορφής IP διεύθυνσης, με τέσσερις οκτάδες. Αν δεν έχει ακόμα βρεθεί η σωστή καταχώριση, θα γίνει ανίχνευση για την καταχώριση <code>MYADDR</code>.</p></dd><dt class=hdlist1>Γραμμή 2</dt><dd><p>Η γραμμή αυτή λέει στο <code>ppp</code> να προσθέσει μια προεπιλεγμένη διαδρομή η οποία να δείχνει στο <code>HISADDR</code>. Το <code>HISADDR</code> θα αντικατασταθεί με τη διεύθυνση IP της πύλης όπως αυτή αποδόθηκε μέσω του πρωτοκόλλου IPCP.</p></dd></dl></div><div class=paragraph><p>Δείτε την καταχώριση <code>pmdemand</code> στα αρχεία <span class=filename>/usr/shared/examples/ppp/ppp.conf.sample</span> και <span class=filename>/usr/shared/examples/ppp/ppp.linkup.sample</span> για ένα πιο λεπτομερές παράδειγμα.</p></div></div><div class=sect5><h6 id=_λήψη_εισερχόμενων_κλήσεων>52.2.1.2.3. Λήψη Εισερχόμενων Κλήσεων<a class=anchor href=#_λήψη_εισερχόμενων_κλήσεων></a></h6><div class=paragraph><p>Όταν ρυθμίζετε το ppp να λαμβάνει εισερχόμενες κλήσεις σε ένα μηχάνημα που συνδέεται σε ένα τοπικό δίκτυο (LAN), θα πρέπει να αποφασίσετε αν θέλετε να προωθούνται πακέτα προς αυτό. Αν ναι, θα πρέπει να αποδώσετε στο μηχάνημα μια διεύθυνση IP η οποία να ανήκει στο ίδιο υποδίκτυο με το LAN, και να χρησιμοποιήσετε την εντολή <code>enable proxy</code> στο αρχείο <span class=filename>/etc/ppp/ppp.conf</span>. Θα πρέπει επίσης να επιβεβαιώσετε ότι το αρχείο <span class=filename>/etc/rc.conf</span> περιέχει τα παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;</pre></div></div></div><div class=sect5><h6 id=_ποιο_getty>52.2.1.2.4. Ποιο getty;<a class=anchor href=#_ποιο_getty></a></h6><div class=paragraph><p>Η ενότητα <a href=./#dialup>Υπηρεσία Εισόδου μέσω Επιλογικής Σύνδεσης (dial in)</a> παρέχει μια καλή περιγραφή σχετικά με την ενεργοποίηση υπηρεσιών επιλογικών κλήσεων χρησιμοποιώντας την <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>.</p></div><div class=paragraph><p>Μια εναλλακτική στην <code>getty</code> είναι η <a href=http://mgetty.greenie.net/>mgetty</a> (από το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a>), μια πιο έξυπνη έκδοση της <code>getty</code>, η οποία έχει σχεδιαστεί για να λαμβάνει υπόψιν τις επιλογικές γραμμές.</p></div><div class=paragraph><p>Τα πλεονεκτήματα της <code>mgetty</code> είναι ότι <em>επικοινωνεί</em> ενεργά με τα modem, το οποίο σημαίνει ότι αν η θύρα είναι απενεργοποιημένη στο <span class=filename>/etc/ttys</span>, το modem σας δεν θα απαντήσει στην κλήση.</p></div><div class=paragraph><p>Μεταγενέστερες εκδόσεις της <code>mgetty</code> (από την 0.99beta και μετά) υποστηρίζουν επίσης αυτόματη ανίχνευση PPP streams, επιτρέποντας στους πελάτες σας πρόσβαση στον εξυπηρετητή χωρίς χρήση scripts.</p></div><div class=paragraph><p>Διαβάστε την ενότητα <a href=#userppp-mgetty>Mgetty και AutoPPP</a> για περισσότερες πληροφορίες σχετικά με την <code>mgetty</code>.</p></div></div><div class=sect5><h6 id=_άδειες_για_το_ppp>52.2.1.2.5. Άδειες για το PPP<a class=anchor href=#_άδειες_για_το_ppp></a></h6><div class=paragraph><p>Φυσιολογικά, η εκτέλεση της εντολής <code>ppp</code> πρέπει να γίνεται ως χρήστης <code>root</code>. Αν ωστόσο θέλετε να επιτρέψετε την εκτέλεση του <code>ppp</code> σε κατάσταση εξυπηρετητή ως κανονικός χρήστης (με τον τρόπο που περιγράφεται παρακάτω) θα πρέπει να δώσετε σε αυτό το χρήστη τα κατάλληλα δικαιώματα για να εκτελεί το <code>ppp</code>, προσθέτοντας τον στην ομάδα <code>network</code> στο αρχείο <span class=filename>/etc/group</span>.</p></div><div class=paragraph><p>Θα πρέπει επίσης να τους δώσετε πρόσβαση σε ένα ή περισσότερα τμήματα του αρχείου ρυθμίσεων, χρησιμοποιώντας την εντολή <code>allow</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>allow users fred mary</pre></div></div><div class=paragraph><p>Αν χρησιμοποιήσετε την επιλογή αυτή στο τμήμα <code>default</code>, θα δώσετε σε αυτούς τους χρήστες πρόσβαση σε όλες τις ρυθμίσεις.</p></div></div><div class=sect5><h6 id=_κελύφη_ppp_για_χρήστες_με_δυναμικά_ip>52.2.1.2.6. Κελύφη PPP για Χρήστες με Δυναμικά IP<a class=anchor href=#_κελύφη_ppp_για_χρήστες_με_δυναμικά_ip></a></h6><div class=paragraph><p>Δημιουργήστε ένα αρχείο με το όνομα <span class=filename>/etc/ppp/ppp-shell</span> το οποίο να περιέχει τα παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
IDENT=`echo $0 | sed -e &#39;s/^.*-\(.*\)$/\1/&#39;`
CALLEDAS=&#34;$IDENT&#34;
TTY=`tty`

if [ x$IDENT = xdialup ]; then
        IDENT=`basename $TTY`
fi

echo &#34;PPP for $CALLEDAS on $TTY&#34;
echo &#34;Starting PPP for $IDENT&#34;

exec /usr/sbin/ppp -direct $IDENT</pre></div></div><div class=paragraph><p>Το script αυτό θα πρέπει να γίνει εκτελέσιμο. Δημιουργήστε τώρα ένα συμβολικό δεσμό που να ονομάζεται <span class=filename>ppp-dialup</span> χρησιμοποιώντας τις παρακάτω εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s ppp-shell /etc/ppp/ppp-dialup</span></code></pre></div></div><div class=paragraph><p>Θα πρέπει να χρησιμοποιήσετε αυτό το script ως το <em>κέλυφος</em> για όλους τους dialup χρήστες. Εδώ φαίνεται ένα παράδειγμα του <span class=filename>/etc/passwd</span> για ένα χρήστη dialup με όνομα <code>pchilds</code> (θυμηθείτε ότι δεν πρέπει να τροποποιείτε άμεσα το αρχείο των κωδικών, αλλά μέσω της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>).</p></div><div class="literalblock programlisting"><div class=content><pre>pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup</pre></div></div><div class=paragraph><p>Δημιουργήστε ένα κατάλογο <span class=filename>/home/ppp</span> προσβάσιμο για ανάγνωση από όλους, ο οποίος θα περιέχει τα παρακάτω κενά αρχεία:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-r--r--r--</span>   1 root     wheel           0 May 27 02:23 .hushlogin
<span class=nt>-r--r--r--</span>   1 root     wheel           0 May 27 02:22 .rhosts</code></pre></div></div><div class=paragraph><p>τα οποία εμποδίζουν την εμφάνιση του μηνύματος από το αρχείο <span class=filename>/etc/motd</span>.</p></div></div><div class=sect5><h6 id=_κελύφη_ppp_για_χρήστες_με_στατικό_ip>52.2.1.2.7. Κελύφη PPP για Χρήστες με Στατικό IP<a class=anchor href=#_κελύφη_ppp_για_χρήστες_με_στατικό_ip></a></h6><div class=paragraph><p>Δημιουργήστε το αρχείο <span class=filename>ppp-shell</span> όπως φαίνεται παραπάνω, και για κάθε λογαριασμό με στατικό IP, δημιουργήστε ένα συμβολικό δεσμό προς το <span class=filename>ppp-shell</span>.</p></div><div class=paragraph><p>Για παράδειγμα, αν έχετε τρεις πελάτες dialup, τους <code>fred</code>, <code>sam</code>, και <code>mary</code>, στους οποίους εκτελείτε δρομολόγηση /24 CIDR, θα πρέπει να γράψετε τα παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred</span>
<span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam</span>
<span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary</span></code></pre></div></div><div class=paragraph><p>Για κάθε λογαριασμό χρήστη dialup, θα πρέπει να ρυθμιστεί το κέλυφος στο συμβολικό δεσμό που δημιουργήθηκε παραπάνω (για παράδειγμα ο συμβολικός δεσμός για το κέλυφος του χρήστη <code>mary</code> θα πρέπει να είναι ο <span class=filename>/etc/ppp/ppp-mary</span>).</p></div></div><div class=sect5><h6 id=_ρύθμιση_του_ppp_conf_για_χρήστες_με_δυναμικό_ip>52.2.1.2.8. Ρύθμιση του <span class=filename>ppp.conf</span> για Χρήστες με Δυναμικό IP<a class=anchor href=#_ρύθμιση_του_ppp_conf_για_χρήστες_με_δυναμικό_ip></a></h6><div class=paragraph><p>Το αρχείο <span class=filename>/etc/ppp/ppp.conf</span> θα πρέπει να περιέχει κάτι αντίστοιχο με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set debug phase lcp chat
  set timeout 0

ttyu0:
  set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
  enable proxy

ttyu1:
  set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
  enable proxy</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η στοίχιση είναι σημαντική.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για κάθε συνεδρία, φορτώνεται η ενότητα <code>default:</code>. Για κάθε γραμμή dialup που ενεργοποιείται στο <span class=filename>/etc/ttys</span>, θα πρέπει να δημιουργήσετε μια καταχώριση όμοια με αυτή που φαίνεται παραπάνω για το <code>ttyu0:</code>. Κάθε γραμμή θα πρέπει να παίρνει μια μοναδική διεύθυνση IP από το απόθεμα των IP διευθύνσεων που προορίζονται για τους δυναμικούς χρήστες.</p></div></div><div class=sect5><h6 id=_ρύθμιση_του_ppp_conf_για_χρήστες_με_στατικό_ip>52.2.1.2.9. Ρύθμιση του <span class=filename>ppp.conf</span> για Χρήστες με Στατικό IP<a class=anchor href=#_ρύθμιση_του_ppp_conf_για_χρήστες_με_στατικό_ip></a></h6><div class=paragraph><p>Εκτός από τα περιεχόμενα του υποδείγματος <span class=filename>/usr/shared/examples/ppp/ppp.conf</span> θα πρέπει να προσθέσετε μια ενότητα για καθένα από τους χρήστες dialup στους οποίους έχει αποδοθεί στατικό IP. Θα συνεχίσουμε με το παράδειγμα μας με τους χρήστες <code>fred</code>, <code>sam</code>, και <code>mary</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>fred:
  set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255

sam:
  set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255

mary:
  set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255</pre></div></div><div class=paragraph><p>Το αρχείο <span class=filename>/etc/ppp/ppp.linkup</span> θα πρέπει επίσης να περιέχει πληροφορίες δρομολόγησης για κάθε χρήστη με στατικό IP (αν απαιτείται). Η παρακάτω γραμμή θα προσθέσει μια διαδρομή προς τη διεύθυνση δικτύου <code>203.14.101.0/24</code> μέσω της σύνδεσης ppp του πελάτη.</p></div><div class="literalblock programlisting"><div class=content><pre>fred:
  add 203.14.101.0 netmask 255.255.255.0 HISADDR

sam:
  add 203.14.102.0 netmask 255.255.255.0 HISADDR

mary:
  add 203.14.103.0 netmask 255.255.255.0 HISADDR</pre></div></div></div><div class=sect5><h6 id=userppp-mgetty>52.2.1.2.10. <code>mgetty</code> και AutoPPP<a class=anchor href=#userppp-mgetty></a></h6><div class=paragraph><p>Το port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a>, έρχεται με προεπιλεγμένη την επιλογή <code>AUTO_PPP</code>, επιτρέποντας έτσι στην <code>mgetty</code> να ανιχνεύει την φάση LCP των συνδέσεων PPP και να εκτελεί αυτόματα ένα κέλυφος ppp. Ωστόσο, καθώς με αυτό τον τρόπο δεν ενεργοποιείται η προεπιλεγμένη ακολουθία ονόματος χρήστη και κωδικού, είναι απαραίτητο να γίνει πιστοποίηση των χρηστών με τη χρήση PAP ή CHAP.</p></div><div class=paragraph><p>Η ενότητα αυτή προϋποθέτει ότι ο χρήστης έχει ρυθμίσει, μεταγλωττίσει και εγκαταστήσει με επιτυχία το port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> στο σύστημα του.</p></div><div class=paragraph><p>Βεβαιωθείτε ότι το αρχείο σας <span class=filename>/usr/local/etc/mgetty+sendfax/login.config</span> περιέχει τα παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>/AutoPPP/ -     -		      /etc/ppp/ppp-pap-dialup</pre></div></div><div class=paragraph><p>Αυτό θα πει στην <code>mgetty</code> να εκτελέσει το script <span class=filename>ppp-pap-dialup</span> για τις PPP συνδέσεις που ανιχνεύθηκαν.</p></div><div class=paragraph><p>Δημιουργήστε ένα αρχείο με το όνομα <span class=filename>/etc/ppp/ppp-pap-dialup</span> το οποίο θα περιέχει τα ακόλουθα (το αρχείο θα πρέπει να είναι εκτελέσιμο):</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT</pre></div></div><div class=paragraph><p>Για κάθε γραμμή dialup που είναι ενεργοποιημένη στο <span class=filename>/etc/ttys</span>, δημιουργήστε μια αντίστοιχη καταχώριση στο αρχείο <span class=filename>/etc/ppp/ppp.conf</span>. Η καταχώριση αυτή μπορεί να συνυπάρχει χωρίς πρόβλημα με αυτές που ορίσαμε παραπάνω.</p></div><div class="literalblock programlisting"><div class=content><pre>pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</pre></div></div><div class=paragraph><p>Κάθε χρήστης που εισέρχεται με αυτό τον τρόπο, θα πρέπει να διαθέτει όνομα χρήστη/κωδικό στο αρχείο <span class=filename>/etc/ppp/ppp.secret</span>. Εναλλακτικά, μπορείτε να προσθέσετε την παρακάτω επιλογή ώστε να γίνεται πιστοποίηση των χρηστών μέσω PAP με βάση τα στοιχεία του αρχείου <span class=filename>/etc/passwd</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable passwdauth</pre></div></div><div class=paragraph><p>Αν θέλετε να αποδώσετε στατικό IP σε κάποιους χρήστες, μπορείτε να καθορίσετε την διεύθυνση ως τρίτο όρισμα στο αρχείο <span class=filename>/etc/ppp/ppp.secret</span>. Για παραδείγματα, δείτε το αρχείο <span class=filename>/usr/shared/examples/ppp/ppp.secret.sample</span>.</p></div></div><div class=sect5><h6 id=_επεκτάσεις_ms>52.2.1.2.11. Επεκτάσεις MS<a class=anchor href=#_επεκτάσεις_ms></a></h6><div class=paragraph><p>Είναι δυνατόν να ρυθμίσετε το PPP ώστε να παρέχει διευθύνσεις DNS και NetBIOS κατά απαίτηση.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε αυτές τις επεκτάσεις με την έκδοση 1.x του PPP, θα πρέπει να προσθέσετε τις παρακάτω γραμμές στο σχετικό τμήμα του <span class=filename>/etc/ppp/ppp.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>Για το PPP από την έκδοση 2 και πάνω:</p></div><div class="literalblock programlisting"><div class=content><pre>accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>Το παραπάνω θα ενημερώσει τους πελάτες για τον κύριο και δευτερεύοντα εξυπηρετητή DNS, και για τον εξυπηρετητή ονομάτων NetBIOS.</p></div><div class=paragraph><p>Από την έκδοση 2 και πάνω, αν παραλειφθεί η γραμμή <code>set dns</code>, το PPP θα χρησιμοποιήσει τις γραμμές που θα βρει στο <span class=filename>/etc/resolv.conf</span>.</p></div></div><div class=sect5><h6 id=userppp-PAPnCHAP>52.2.1.2.12. Πιστοποίηση PAP και CHAP<a class=anchor href=#userppp-PAPnCHAP></a></h6><div class=paragraph><p>Κάποιοι ISP ρυθμίζουν τα συστήματα τους με τέτοιο τρόπο, ώστε το κομμάτι της σύνδεσης που ασχολείται με την πιστοποίηση του χρήστη να γίνεται μέσω των μηχανισμών PAP ή CHAP. Αν συμβαίνει αυτό στη δική σας περίπτωση, ο ISP σας δεν θα σας στείλει προτροπή login όταν συνδεθείτε, αλλά θα αρχίσει απευθείας τη μετάδοση PPP.</p></div><div class=paragraph><p>Το PAP είναι λιγότερο ασφαλές από το CHAP, αλλά η ασφάλεια εδώ δεν είναι τόσο σπουδαίο θέμα, καθώς οι κωδικοί (αν και στέλνονται ως κανονικό κείμενο) μεταδίδονται μόνο μέσω σειριακής γραμμής. Έτσι δεν υπάρχει πραγματική δυνατότητα των crackers να "κρυφακούσουν".</p></div><div class=paragraph><p>Χρησιμοποιώντας ως αναφορά τις ενότητες <a href=#userppp-staticIP>PPP και Στατικές Διευθύνσεις IP</a> ή <a href=#userppp-dynamicIP>PPP και Δυναμικές Διευθύνσεις IP</a>, θα πρέπει να γίνουν οι παρακάτω αλλαγές:</p></div><div class="literalblock programlisting"><div class=content><pre>13      set authname MyUserName
14      set authkey MyPassword
15      set login</pre></div></div><div class=dlist><dl><dt class=hdlist1>Γραμμή 13</dt><dd><p>Η γραμμή αυτή καθορίζει το όνομα χρήστη για τα PAP/CHAP. Θα χρειαστεί να εισάγετε την σωστή τιμή για το <em>MyUserName</em>.</p></dd><dt class=hdlist1>Γραμμή 14</dt><dd><p>Η γραμμή αυτή καθορίζει τον κωδικό για τα PAP/CHAP. Θα χρειαστεί να εισάγετε την σωστή τιμή για το <em>MyPassword</em>. Ίσως θέλετε να προσθέσετε μια ακόμα γραμμή, όπως την παρακάτω:</p><div class="literalblock programlisting"><div class=content><pre>16      accept PAP</pre></div></div><div class=paragraph><p>ή</p></div><div class="literalblock programlisting"><div class=content><pre>16      accept CHAP</pre></div></div><div class=paragraph><p>για να είναι φανερή η πρόθεση σας, ωστόσο τόσο το PAP όσο και το CHAP γίνονται δεκτά από προεπιλογή.</p></div></dd><dt class=hdlist1>Γραμμή 15</dt><dd><p>Ο ISP σας δεν θα απαιτεί φυσιολογικά να εισέλθετε στον εξυπηρετητή αν χρησιμοποιείτε PAP ή CHAP. Για το λόγο αυτό, θα πρέπει να απενεργοποιήσετε το αλφαριθμητικό "set login".</p></dd></dl></div></div><div class=sect5><h6 id=_αλλάζοντας_άμεσα_τις_ρυθμίσεις_του_ppp>52.2.1.2.13. Αλλάζοντας Άμεσα τις Ρυθμίσεις του <code>ppp</code><a class=anchor href=#_αλλάζοντας_άμεσα_τις_ρυθμίσεις_του_ppp></a></h6><div class=paragraph><p>Είναι δυνατόν να επικοινωνήσετε με το πρόγραμμα <code>ppp</code> καθώς εκτελείται στον παρασκήνιο, αλλά μόνο αν έχετε ρυθμίσει μια κατάλληλη διαγνωστική θύρα για αυτό το σκοπό. Για να το κάνετε αυτό, προσθέστε την παρακάτω γραμμή στις ρυθμίσεις σας:</p></div><div class="literalblock programlisting"><div class=content><pre>set server /var/run/ppp-tun%d DiagnosticPassword 0177</pre></div></div><div class=paragraph><p>Αυτό οδηγεί το PPP να "ακούει" στο καθορισμένο UNIX® socket του τομέα, και να ρωτάει τους πελάτες για τον κωδικό που έχει καθοριστεί πριν επιτρέψει την πρόσβαση. Το <code>%d</code> στο όνομα, αντικαθίσταται με τον αριθμό της συσκευής <span class=filename>tun</span> που χρησιμοποιείται.</p></div><div class=paragraph><p>Από τη στιγμή που ρυθμιστεί το socket, το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> μπορεί να χρησιμοποιηθεί σε scripts με τα οποία επιθυμείτε να διαχειριστείτε το πρόγραμμα <code>ppp</code> το οποίο εκτελείται ήδη.</p></div></div></div><div class=sect4><h5 id=userppp-nat>52.2.1.3. Χρησιμοποιώντας τη Δυνατότητα Μετάφρασης Διευθύνσεων (NAT) του PPP<a class=anchor href=#userppp-nat></a></h5><div class=paragraph><p>Το PPP έχει την ικανότητα να χρησιμοποιήσει δικό του εσωτερικό NAT, χωρίς να απαιτούνται οι ικανότητες ανακατεύθυνσης του πυρήνα. Μπορείτε να ενεργοποιήσετε αυτή τη λειτουργία με την ακόλουθη γραμμή στο <span class=filename>/etc/ppp/ppp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nat enable yes</pre></div></div><div class=paragraph><p>Εναλλακτικά, το NAT του PPP μπορεί να ενεργοποιηθεί με την επιλογή <code>-nat</code> στην γραμμή εντολών. Μπορείτε ακόμα να βάλετε την επιλογή <code>ppp_nat</code> στο αρχείο <span class=filename>/etc/rc.conf</span>. Η επιλογή αυτή είναι ενεργοποιημένη από προεπιλογή.</p></div><div class=paragraph><p>Αν χρησιμοποιήσετε αυτό το χαρακτηριστικό, μάλλον θα βρείτε χρήσιμες και τις παρακάτω επιλογές για το <span class=filename>/etc/ppp/ppp.conf</span>, με τις οποίες ενεργοποιείται η προώθηση εισερχόμενων συνδέσεων:</p></div><div class="literalblock programlisting"><div class=content><pre>nat port tcp 10.0.0.2:ftp ftp
nat port tcp 10.0.0.2:http http</pre></div></div><div class=paragraph><p>ή αν δεν εμπιστεύεστε καθόλου το εξωτερικό δίκτυο:</p></div><div class="literalblock programlisting"><div class=content><pre>nat deny_incoming yes</pre></div></div></div><div class=sect4><h5 id=userppp-final>52.2.1.4. Τελικές Ρυθμίσεις Συστήματος<a class=anchor href=#userppp-final></a></h5><div class=paragraph><p>Έχετε πλέον ρυθμίσει το <code>ppp</code>, αλλά υπάρχουν μερικά ακόμα πράγματα που πρέπει να κάνετε πριν να είναι έτοιμο για λειτουργία. Όλα περιλαμβάνουν την επεξεργασία του αρχείου <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Ξεκινώντας από την αρχή του αρχείου αυτού, βεβαιωθείτε ότι είναι ορισμένη η γραμμή <code>hostname=</code>, π.χ.:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;foo.example.com&#34;</pre></div></div><div class=paragraph><p>Αν ο ISP σας παρέχει στατική IP διεύθυνση και όνομα, είναι μάλλον καλύτερο να χρησιμοποιήσετε αυτό το όνομα ως όνομα για το μηχάνημα σας.</p></div><div class=paragraph><p>Ψάξτε για τη μεταβλητή <code>network_interfaces</code>. Αν θέλετε να ρυθμίσετε το σύστημα σας να καλεί τον ISP σας κατά απαίτηση, βεβαιωθείτε ότι υπάρχει στη λίστα η συσκευή <span class=filename>tun0</span>, διαφορετικά αφαιρέστε την.</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 tun0&#34;
ifconfig_tun0=</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η μεταβλητή <code>ifconfig_tun0</code> θα πρέπει να είναι άδεια, και θα πρέπει να δημιουργηθεί ένα αρχείο με όνομα <span class=filename>/etc/start_if.tun0</span>. Το αρχείο αυτό θα πρέπει να περιέχει την παρακάτω γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp -auto mysystem</pre></div></div><div class=paragraph><p>Το script αυτό εκτελείται κατά τη διάρκεια ρύθμισης του δικτύου, ξεκινώντας έτσι το δαίμονα ppp σε κατάσταση αυτόματης λειτουργίας. Αν διαθέτετε κάποιο τοπικό δίκτυο (LAN) για το οποίο το μηχάνημα αυτό έχει το ρόλο της πύλης, ίσως να θέλετε επίσης να χρησιμοποιήσετε την επιλογή <code>-alias</code>. Δείτε τη σελίδα manual για περισσότερες λεπτομέρειες.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Βεβαιωθείτε ότι η μεταβλητή για το πρόγραμμα router έχει τεθεί στο <code>NO</code> μέσω της επόμενης γραμμής στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>router_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Είναι σημαντικό να μην ξεκινήσει ο δαίμονας <code>routed</code>, ο οποίος συνήθως διαγράφει τις προεπιλεγμένες τιμές του πίνακα δρομολόγησης που δημιουργούνται από το <code>ppp</code>.</p></div><div class=paragraph><p>Είναι μάλλον καλή ιδέα να εξασφαλίσετε ότι η γραμμή <code>sendmail_flags</code> δεν περιλαμβάνει την επιλογή <code>-q</code>, διαφορετικά το <code>sendmail</code> θα προσπαθεί κάθε τόσο να κάνει αναζήτηση του δικτύου, με πιθανό αποτέλεσμα το μηχάνημα σας να εκτελεί τηλεφωνική σύνδεση (dial out). Μπορείτε να δοκιμάσετε:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_flags=&#34;-bd&#34;</pre></div></div><div class=paragraph><p>Το μειονέκτημα του παραπάνω, είναι ότι πρέπει να εξαναγκάσετε το <code>sendmail</code> να επανεξετάσει την ουρά των μηνυμάτων, κάθε φορά που αποκαθίσταται η σύνδεση ppp, γράφοντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/sendmail -q</span></code></pre></div></div><div class=paragraph><p>Ίσως θέλετε να χρησιμοποιήσετε την εντολή <code>!bg</code> στο <span class=filename>ppp.linkup</span> για να γίνεται το παραπάνω αυτόματα:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</pre></div></div><div class=paragraph><p>Αν αυτό δεν σας αρέσει, είναι δυνατόν να ρυθμίσετε ένα "dfilter" το οποίο να αποκόπτει την κίνηση SMTP. Δείτε τα υποδείγματα για περισσότερες λεπτομέρειες.</p></div><div class=paragraph><p>Το μόνο που μένει είναι να επανεκκινήσετε το μηχάνημα. Μετά την επανεκκίνηση, μπορείτε είτε να γράψετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=paragraph><p>και έπειτα <code>dial provider</code> για να ξεκινήσετε τη συνεδρία PPP, ή αν θέλετε το <code>ppp</code> να αποκαθιστά τις συνεδρίες αυτόματα κάθε φορά που υπάρχει κίνηση προς το εξωτερικό δίκτυο (και δεν έχετε δημιουργήσει το script <span class=filename>start_if.tun0</span>) μπορείτε να γράψετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -auto provider</span></code></pre></div></div></div><div class=sect4><h5 id=_περίληψη>52.2.1.5. Περίληψη<a class=anchor href=#_περίληψη></a></h5><div class=paragraph><p>Για να ανακεφαλαιώσουμε, τα παρακάτω βήματα είναι απαραίτητα όταν εγκαθιστάτε το ppp για πρώτη φορά:</p></div><div class=paragraph><p>Από τη μεριά του μηχανήματος-πελάτη:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Βεβαιωθείτε ότι περιλαμβάνεται στον πυρήνα σας η συσκευή <span class=filename>tun</span>.</p></li><li><p>Βεβαιωθείτε ότι υπάρχει το αρχείο της συσκευής <span class=filename>tunN</span> στον κατάλογο <span class=filename>/dev</span>.</p></li><li><p>Δημιουργήστε μια καταχώριση στο αρχείο <span class=filename>/etc/ppp/ppp.conf</span>. Το παράδειγμα για το <span class=filename>pmdemand</span> θα πρέπει να είναι επαρκές για τους περισσότερους ISPs.</p></li><li><p>Αν έχετε δυναμική διεύθυνση IP, δημιουργήστε μια καταχώριση στο <span class=filename>/etc/ppp/ppp.linkup</span>.</p></li><li><p>Ενημερώστε το αρχείο <span class=filename>/etc/rc.conf</span>.</p></li><li><p>Δημιουργήστε το script <span class=filename>start_if.tun0</span> αν χρειάζεστε κλήση κατά απαίτηση.</p></li></ol></div><div class=paragraph><p>Από τη μεριά του εξυπηρετητή:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Βεβαιωθείτε ότι περιλαμβάνεται στον πυρήνα σας η συσκευή <span class=filename>tun</span>.</p></li><li><p>Βεβαιωθείτε ότι υπάρχει το αρχείο της συσκευής <span class=filename>tunN</span> στον κατάλογο <span class=filename>/dev</span>.</p></li><li><p>Δημιουργήστε μια καταχώριση στο <span class=filename>/etc/passwd</span> (χρησιμοποιώντας το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>).</p></li><li><p>Δημιουργήστε ένα αρχείο profile στον προσωπικό κατάλογο του χρήστη, το οποίο να εκτελεί την εντολή <code>ppp -direct direct-server</code> ή κάποια αντίστοιχη.</p></li><li><p>Δημιουργήστε μια καταχώριση στο <span class=filename>/etc/ppp/ppp.conf</span>. Το παράδειγμα για το <span class=filename>direct-server</span> θα πρέπει να είναι επαρκές.</p></li><li><p>Δημιουργήστε μια καταχώριση στο <span class=filename>/etc/ppp/ppp.linkup</span>.</p></li><li><p>Ενημερώστε το αρχείο <span class=filename>/etc/rc.conf</span>.</p></li></ol></div></div></div></div><div class=sect2><h3 id=ppp>52.3. Χρησιμοποιώντας το PPP του Πυρήνα<a class=anchor href=#ppp></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Η ενότητα αυτή είναι έγκυρη και μπορεί να εφαρμοστεί μόνο σε συστήματα FreeBSD 7.X.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_ρυθμίζοντας_το_ppp_του_πυρήνα>52.3.1. Ρυθμίζοντας το PPP του Πυρήνα<a class=anchor href=#_ρυθμίζοντας_το_ppp_του_πυρήνα></a></h4><div class=paragraph><p>Πριν ξεκινήσετε να ρυθμίζετε το PPP στο μηχάνημα σας, βεβαιωθείτε ότι το <code>pppd</code> βρίσκεται στον κατάλογο <span class=filename>/usr/sbin</span> και ότι υπάρχει ο κατάλογος <span class=filename>/etc/ppp</span>.</p></div><div class=paragraph><p>Το <code>pppd</code> έχει δύο καταστάσεις λειτουργίας:</p></div><div class="olist arabic"><ol class=arabic><li><p>Ως πελάτης ("client") - όταν θέλετε να συνδέσετε το μηχάνημα σας με τον έξω κόσμο μέσω σειριακής σύνδεσης σύνδεσης ή γραμμής modem.</p></li><li><p>Ως εξυπηρετητής ("server") - το μηχάνημα σας είναι συνδεμένο στο δίκτυο και χρησιμοποιείται για να συνδέσει άλλους υπολογιστές, χρησιμοποιώντας το PPP.</p></li></ol></div><div class=paragraph><p>Και στις δύο περιπτώσεις θα χρειαστεί να δημιουργήσετε ένα αρχείο επιλογών (<span class=filename>/etc/ppp/options</span> ή <span class=filename>~/.ppprc</span> αν στο μηχάνημα σας υπάρχουν περισσότεροι από ένας χρήστες που χρησιμοποιούν το PPP).</p></div><div class=paragraph><p>Θα χρειαστείτε επίσης και κάποιο λογισμικό για χρήση με modem και σειριακές συνδέσεις (κατά προτίμηση το <a class=package href=https://cgit.freebsd.org/ports/tree/comms/kermit/>comms/kermit</a>), ώστε να μπορείτε να καλέσετε και να αποκαταστήσετε τη σύνδεση με τον απομακρυσμένο εξυπηρετητή.</p></div></div><div class=sect3><h4 id=_χρησιμοποιώντας_το_pppd_ως_πελάτης>52.3.2. Χρησιμοποιώντας το <code>pppd</code> ως Πελάτης<a class=anchor href=#_χρησιμοποιώντας_το_pppd_ως_πελάτης></a></h4><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε το <span class=filename>/etc/ppp/options</span> που φαίνεται παρακάτω, για να συνδεθείτε σε μια γραμμή PPP ενός εξυπηρετητή τερματικών (terminal server) της Cisco.</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts         # enable hardware flow control
modem           # modem control line
noipdefault     # remote PPP server must supply your IP address
                # if the remote host does not send your IP during IPCP
                # negotiation, remove this option
passive         # wait for LCP packets
domain ppp.foo.com      # put your domain name here

:remote_ip    # put the IP of remote PPP host here
                # it will be used to route packets via PPP link
                # if you didn&#39;t specified the noipdefault option
                # change this line to local_ip:remote_ip

defaultroute    # put this if you want that PPP server will be your
                # default router</pre></div></div><div class=paragraph><p>Για να συνδεθείτε:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Καλέστε τον απομακρυσμένο εξυπηρετητή χρησιμοποιώντας το Kermit (ή κάποιο άλλο πρόγραμμα για modem) και εισάγετε το όνομα χρήστη και τον κωδικό σας (ή ότι άλλο χρειάζεται για να ενεργοποιήσετε το PPP στον απομακρυσμένο υπολογιστή).</p></li><li><p>Βγείτε από το Kermit (χωρίς να κλείσετε τη γραμμή).</p></li><li><p>Πληκτρολογήστε τα παρακάτω:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/pppd /dev/tty01 19200</span></code></pre></div></div><div class=paragraph><p>Βεβαιωθείτε ότι χρησιμοποιείτε το σωστό όνομα συσκευής και την κατάλληλη ταχύτητα.</p></div></li></ol></div><div class=paragraph><p>Ο υπολογιστής σας είναι τώρα συνδεμένος μέσω PPP. Αν η σύνδεση αποτύχει, μπορείτε να χρησιμοποιήσετε την επιλογή <code>debug</code> στο αρχείο <span class=filename>/etc/ppp/options</span> και να ελέγξετε τα μηνύματα στην κονσόλα για να ανιχνεύσετε το πρόβλημα.</p></div><div class=paragraph><p>Το παρακάτω script <span class=filename>/etc/ppp/pppup</span> αυτοματοποιεί και τα 3 στάδια:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pgrep -l pppd
pid=`pgrep pppd`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
pgrep -l kermit
pid=`pgrep kermit`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p>Το αρχείο <span class=filename>/etc/ppp/kermit.dial</span> είναι ένα script για το Kermit το οποίο κάνει την κλήση και την πιστοποίηση του χρήστη στον απομακρυσμένο υπολογιστή (στο τέλος αυτού του εγγράφου, θα βρείτε ένα παράδειγμα για ένα τέτοιο script).</p></div><div class=paragraph><p>Χρησιμοποιήστε το παρακάτω script <span class=filename>/etc/ppp/pppdown</span> για να αποσυνδέσετε την γραμμή PPP:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`pgrep pppd`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill -TERM ${pid}
fi

pgrep -l kermit
pid=`pgrep kermit`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

/sbin/ifconfig ppp0 down
/sbin/ifconfig ppp0 delete
kermit -y /etc/ppp/kermit.hup
/etc/ppp/ppptest</pre></div></div><div class=paragraph><p>Ελέγξτε αν εκτελείται ακόμα το <code>pppd</code>, εκτελώντας το <span class=filename>/usr/etc/ppp/ppptest</span>, το οποίο θα μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`pgrep pppd`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;pppd running: PID=&#39; ${pid-NONE}
else
        echo &#39;No pppd running.&#39;
fi
set -x
netstat -n -I ppp0
ifconfig ppp0</pre></div></div><div class=paragraph><p>Για να κλείσετε την γραμμή, εκτελέστε το <span class=filename>/etc/ppp/kermit.hup</span>, το οποίο θα πρέπει να περιέχει:</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01	; put your modem device here
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
echo \13
exit</pre></div></div><div class=paragraph><p>Μια εναλλακτική μέθοδος που χρησιμοποιεί το <code>chat</code> αντί για το <code>kermit</code>:</p></div><div class=paragraph><p>Τα παρακάτω δύο αρχεία επαρκούν για τη δημιουργία μιας σύνδεσης <code>pppd</code>.</p></div><div class=paragraph><p><span class=filename>/etc/ppp/options</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/cuad1 115200

crtscts		# enable hardware flow control
modem		# modem control line
connect &#34;/usr/bin/chat -f /etc/ppp/login.chat.script&#34;
noipdefault	# remote PPP serve must supply your IP address
	        # if the remote host doesn&#39;t send your IP during
                # IPCP negotiation, remove this option
passive         # wait for LCP packets
domain your.domain	# put your domain name here

:		# put the IP of remote PPP host here
	        # it will be used to route packets via PPP link
                # if you didn&#39;t specified the noipdefault option
                # change this line to local_ip:remote_ip

defaultroute	# put this if you want that PPP server will be
	        # your default router</pre></div></div><div class=paragraph><p><span class=filename>/etc/ppp/login.chat.script</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το παρακάτω θα πρέπει να γραφεί σε μια μόνο γραμμή.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ABORT BUSY ABORT &#39;NO CARRIER&#39; &#34;&#34; AT OK ATDTphone.number
  CONNECT &#34;&#34; TIMEOUT 10 ogin:-\\r-ogin: login-id
  TIMEOUT 5 sword: password</pre></div></div><div class=paragraph><p>Μόλις τροποποιήσετε και εγκαταστήσετε σωστά τα παραπάνω αρχεία, το μόνο που χρειάζεται να κάνετε είναι να εκτελέσετε την εντολή <code>pppd</code>, με τον τρόπο που φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pppd</span></code></pre></div></div></div><div class=sect3><h4 id=_χρησιμοποιώντας_το_pppd_ως_εξυπηρετητή>52.3.3. Χρησιμοποιώντας το <code>pppd</code> ως Εξυπηρετητή<a class=anchor href=#_χρησιμοποιώντας_το_pppd_ως_εξυπηρετητή></a></h4><div class=paragraph><p>Το <span class=filename>/etc/ppp/options</span> θα πρέπει να περιέχει κάτι αντίστοιχο με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts                         # Hardware flow control
netmask 255.255.255.0           # netmask (not required)
192.114.208.20:192.114.208.165  # IP&#39;s of local and remote hosts
                                # local ip must be different from one
                                # you assigned to the Ethernet (or other)
                                # interface on your machine.
                                # remote IP is IP address that will be
                                # assigned to the remote machine
domain ppp.foo.com              # your domain
passive                         # wait for LCP
modem                           # modem line</pre></div></div><div class=paragraph><p>Το script <span class=filename>/etc/ppp/pppserv</span> που φαίνεται παρακάτω, θα πει στο pppd να λειτουργήσει ως εξυπηρετητής:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pgrep -l pppd
pid=`pgrep pppd`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
pgrep -l kermit
pid=`pgrep kermit`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

# reset ppp interface
ifconfig ppp0 down
ifconfig ppp0 delete

# enable autoanswer mode
kermit -y /etc/ppp/kermit.ans

# run ppp
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p>Χρησιμοποιήστε το παρακάτω script <span class=filename>/etc/ppp/pppservdown</span> για να σταματήσετε τον εξυπηρετητή:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pgrep -l pppd
pid=`pgrep pppd`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
pgrep -l kermit
pid=`pgrep kermit`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi
ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.noans</pre></div></div><div class=paragraph><p>Το παρακάτω script για το Kermit (<span class=filename>/etc/ppp/kermit.ans</span>) μπορεί να ενεργοποιεί και να απενεργοποιεί την λειτουργία αυτόματης απάντησης στο modem σας.</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
inp 5 OK
echo \13
out ATS0=1\13   ; change this to out ATS0=0\13 if you want to disable
                ; autoanswer mode
inp 5 OK
echo \13
exit</pre></div></div><div class=paragraph><p>Στον απομακρυσμένο υπολογιστή, χρησιμοποιείται το script <span class=filename>/etc/ppp/kermit.dial</span> για κλήση και πιστοποίηση του χρήστη. Θα πρέπει να το τροποποιήσετε σύμφωνα με τις ανάγκες σας. Βάλτε το όνομα χρήστη και τον κωδικό σας σε αυτό το script. Θα χρειαστεί επίσης να αλλάξετε την γραμμή για την είσοδο (input) ανάλογα με τις απαντήσεις που δίνει το modem σας και ο απομακρυσμένος υπολογιστής.</p></div><div class="literalblock programlisting"><div class=content><pre>;
; put the com line attached to the modem here:
;
set line /dev/tty01
;
; put the modem speed here:
;
set speed 19200
set file type binary            ; full 8 bit file xfer
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none
set modem hayes
set dial hangup off
set carrier auto                ; Then SET CARRIER if necessary,
set dial display on             ; Then SET DIAL if necessary,
set input echo on
set input timeout proceed
set input case ignore
def \%x 0                       ; login prompt counter
goto slhup

:slcmd                          ; put the modem in command mode
echo Put the modem in command mode.
clear                           ; Clear unread characters from input buffer
pause 1
output +++                      ; hayes escape sequence
input 1 OK\13\10                ; wait for OK
if success goto slhup
output \13
pause 1
output at\13
input 1 OK\13\10
if fail goto slcmd              ; if modem doesn&#39;t answer OK, try again

:slhup                          ; hang up the phone
clear                           ; Clear unread characters from input buffer
pause 1
echo Hanging up the phone.
output ath0\13                  ; hayes command for on hook
input 2 OK\13\10
if fail goto slcmd              ; if no OK answer, put modem in command mode

:sldial                         ; dial the number
pause 1
echo Dialing.
output atdt9,550311\13\10               ; put phone number here
assign \%x 0                    ; zero the time counter

:look
clear                           ; Clear unread characters from input buffer
increment \%x                   ; Count the seconds
input 1 {CONNECT }
if success goto sllogin
reinput 1 {NO CARRIER\13\10}
if success goto sldial
reinput 1 {NO DIALTONE\13\10}
if success goto slnodial
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 60 goto look
else goto slhup

:sllogin                        ; login
assign \%x 0                    ; zero the time counter
pause 1
echo Looking for login prompt.

:slloop
increment \%x                   ; Count the seconds
clear                           ; Clear unread characters from input buffer
output \13
;
; put your expected login prompt here:
;
input 1 {Username: }
if success goto sluid
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 10 goto slloop         ; try 10 times to get a login prompt
else goto slhup                 ; hang up and start again if 10 failures

:sluid
;
; put your userid here:
;
output ppp-login\13
input 1 {Password: }
;
; put your password here:
;
output ppp-password\13
input 1 {Entering SLIP mode.}
echo
quit

:slnodial
echo \7No dialtone.  Check the telephone line!\7
exit 1

; local variables:
; mode: csh
; comment-start: &#34;; &#34;
; comment-start-skip: &#34;; &#34;
; end:</pre></div></div></div></div><div class=sect2><h3 id=ppp-troubleshoot>52.4. Αντιμετώπιση Προβλημάτων σε Συνδέσεις PPP<a class=anchor href=#ppp-troubleshoot></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Από το FreeBSD 8.0 και μετά, το πρόγραμμα οδήγησης <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> αντικαταστάθηκε από το <a href="https://man.freebsd.org/cgi/man.cgi?query=uart&amp;sektion=4&amp;format=html">uart(4)</a>. Τα ονόματα συσκευών των σειριακών θυρών έχουν αλλάξει από <span class=filename>/dev/cuadN</span> σε <span class=filename>/dev/cuauN</span> και από <span class=filename>/dev/ttydN</span> σε <span class=filename>/dev/ttyuN</span>. Οι χρήστες του FreeBSD 7.X θα πρέπει να προσαρμόσουν τις παρακάτω οδηγίες σύμφωνα με αυτές τις αλλαγές.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η ενότητα αυτή καλύπτει μερικά από τα προβλήματα που μπορεί να παρουσιαστούν όταν γίνεται χρήση του PPP μέσω σύνδεσης modem. Για παράδειγμα, θα πρέπει να ξέρετε με ακρίβεια τα μηνύματα εισόδου που θα εμφανίσει το σύστημα το οποίο καλείτε. Μερικοί ISP δίνουν την προτροπή <code>ssword</code>, ενώ άλλοι δίνουν την <code>password</code>. Αν δεν έχετε γράψει σωστά το script για το <code>ppp</code>, η απόπειρα εισόδου θα αποτύχει. Ο πιο συνηθισμένος τρόπος να εκσφαλματώσετε μια σύνδεση <code>ppp</code>, είναι να συνδεθείτε χειροκίνητα. Οι πληροφορίες που εμφανίζονται παρακάτω, θα σας οδηγήσουν βήμα προς βήμα στη χειροκίνητη αποκατάσταση της σύνδεσης.</p></div><div class=sect3><h4 id=_ελέγξτε_τα_αρχεία_συσκευών>52.4.1. Ελέγξτε τα Αρχεία Συσκευών<a class=anchor href=#_ελέγξτε_τα_αρχεία_συσκευών></a></h4><div class=paragraph><p>Αν χρησιμοποιείτε προσαρμοσμένο πυρήνα, βεβαιωθείτε ότι έχετε περιλάβει την παρακάτω γραμμή στο αρχείο ρυθμίσεων του πυρήνα σας:</p></div><div class="literalblock programlisting"><div class=content><pre>device   uart</pre></div></div><div class=paragraph><p>Αν χρησιμοποιείτε τον πυρήνα <code>GENERIC</code>, δεν χρειάζεται να κάνετε κάποια αλλαγή, καθώς η συσκεύη <span class=filename>uart</span> περιλαμβάνεται ήδη σε αυτόν. Απλώς ελέγξτε τα μηνύματα της <code>dmesg</code> για την συσκευή modem, χρησιμοποιώντας την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | grep uart</span></code></pre></div></div><div class=paragraph><p>Θα πρέπει να δείτε κάποια έξοδο σχετική με τις συσκευές <span class=filename>uart</span>. Πρόκειται για τις θύρες COM που χρειαζόμαστε. Αν το modem σας λειτουργεί ως τυποποιημένη σειριακή θύρα, θα πρέπει να το δείτε να αναφέρεται ως <span class=filename>uart1</span>, ή <span class=filename>COM2</span>. Αν συμβαίνει αυτό, δεν χρειάζεται να επαναμεταγλωττίσετε τον πυρήνα σας. Αν η σειριακή θύρα που αντιστοιχεί στο modem σας είναι η <span class=filename>uart1</span> ή <span class=filename>COM2</span> στο DOS, η αντίστοιχη συσκευή modem θα είναι η <span class=filename>/dev/cuau1</span>.</p></div></div><div class=sect3><h4 id=_χειροκίνητη_σύνδεση>52.4.2. Χειροκίνητη Σύνδεση<a class=anchor href=#_χειροκίνητη_σύνδεση></a></h4><div class=paragraph><p>Η χειροκίνητη σύνδεση στο Internet με χρήση της <code>ppp</code>, είναι ένας γρήγορος και εύκολος τρόπος να εντοπίσετε τυχόν προβλήματα σύνδεσης, ή απλώς να πάρετε πληροφορίες σχετικά με το πως ο ISP σας αντιμετωπίζει τις συνδέσεις πελατών <code>ppp</code>. Θα ξεκινήσουμε την εφαρμογή PPP από την γραμμή εντολών. Σημειώστε ότι σε όλα μας τα παραδείγματα, θα χρησιμοποιούμε το <em>example</em> ως το όνομα του υπολογιστή που εκτελεί το PPP. Μπορείτε να ξεκινήσετε το <code>ppp</code>, γράφοντας απλώς <code>ppp</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=paragraph><p>Έχουμε τώρα ξεκινήσει το <code>ppp</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>device /dev/cuau1</code></pre></div></div><div class=paragraph><p>Θέτουμε τη συσκευή modem. Στο παράδειγμα μας, είναι η <span class=filename>cuau1</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>speed 115200</code></pre></div></div><div class=paragraph><p>Θέτουμε την ταχύτητα σύνδεσης, σε αυτή την περίπτωση χρησιμοποιούμε 115,200 kbps.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>enable </span>dns</code></pre></div></div><div class=paragraph><p>Λέμε στο <code>ppp</code> να ρυθμίσει τον resolver και προσθέτουμε τις κατάλληλες γραμμές για το διακομιστή ονομάτων στο <span class=filename>/etc/resolv.conf</span>. Αν το <code>ppp</code> δεν μπορεί να καθορίσει το όνομα του διακομιστή, μπορούμε να το καθορίσουμε με χειροκίνητο τρόπο αργότερα.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; term</code></pre></div></div><div class=paragraph><p>Αλλάζουμε σε κατάσταση "terminal" ώστε να μπορούμε να ελέγξουμε το modem χειροκίνητα.</p></div><div class="literalblock programlisting"><div class=content><pre>deflink: Entering terminal mode on /dev/cuau1
type &#39;~h&#39; for help</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>at
OK
atdt123456789</code></pre></div></div><div class=paragraph><p>Χρησιμοποιούμε το <code>at</code> για να αρχικοποιήσουμε το modem, και έπειτα χρησιμοποιούμε το <code>atdt</code> και τον αριθμό του ISP για να ξεκινήσουμε τη διαδικασία της κλήσης.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>CONNECT</code></pre></div></div><div class=paragraph><p>Εδώ έχουμε επιβεβαίωση της σύνδεσης. Αν έχουμε προβλήματα σύνδεσης τα οποία δεν σχετίζονται με το υλικό μας, εδώ είναι το σημείο που πρέπει να προσπαθήσουμε να τα επιλύσουμε.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Login:myusername</code></pre></div></div><div class=paragraph><p>Η προτροπή αυτή είναι για να δώσουμε το όνομα χρήστη. Χρησιμοποιήστε το όνομα χρήστη που σας έχει δοθεί από τον ISP σας.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Pass:mypassword</code></pre></div></div><div class=paragraph><p>Η προτροπή αυτή είναι για τον κωδικό πρόσβασης. Απαντήστε με τον κωδικό που σας έχει δοθεί από τον ISP σας. Ο κωδικός αυτός δεν θα εμφανιστεί στην οθόνη σας, όπως ακριβώς συμβαίνει και με τον κωδικό σας όταν τον γράφετε στην προτροπή εισόδου του FreeBSD συστήματος σας.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Shell or PPP:ppp</code></pre></div></div><div class=paragraph><p>Ανάλογα με τον ISP σας, μπορεί να μην δείτε και καθόλου την παραπάνω προτροπή. Στην παραπάνω περίπτωση μας ρωτάει αν επιθυμούμε να εκτελέσουμε κάποιο κέλυφος (shell) στο μηχάνημα του παροχέα, ή αν θέλουμε να εκκινήσουμε το <code>ppp</code>. Στο παράδειγμα μας επιλέξαμε να χρησιμοποιήσουμε <code>ppp</code> καθώς θέλουμε να συνδεθούμε στο Internet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Ppp ON example&gt;</code></pre></div></div><div class=paragraph><p>Παρατηρήστε ότι στο παράδειγμα το πρώτο <code>p</code> είναι κεφαλαίο. Αυτό δείχνει ότι έχουμε συνδεθεί επιτυχώς με τον ISP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPp ON example&gt;</code></pre></div></div><div class=paragraph><p>Έχουμε πιστοποιηθεί με επιτυχία από τον ISP μας, και περιμένουμε να μας αποδοθεί διεύθυνση IP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt;</code></pre></div></div><div class=paragraph><p>Έχει πλέον καθοριστεί διεύθυνση IP, και έχουμε ολοκληρώσει τη σύνδεση με επιτυχία.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt;add default HISADDR</code></pre></div></div><div class=paragraph><p>Εδώ προσθέτουμε την προεπιλεγμένη διαδρομή (default route). Το βήμα αυτό είναι απαραίτητο πριν μπορέσουμε να επικοινωνήσουμε με τον έξω κόσμο, καθώς τη δεδομένη στιγμή η μόνη σύνδεση που έχουμε είναι με ένα υπολογιστή από την άλλη μεριά της γραμμής. Αν το παραπάνω αποτύχει επειδή υπάρχουν ήδη καθορισμένες διαδρομές, μπορείτε να βάλετε ένα θαυμαστικό <code>!</code> μπροστά από το <code>add</code>. Εναλλακτικά, μπορείτε να κάνετε αυτή τη ρύθμιση πριν επιχειρήσετε τη σύνδεση, και θα γίνει αυτόματα διαπραγμάτευση της νέας διαδρομής.</p></div><div class=paragraph><p>Αν όλα πήγαν καλά, θα πρέπει τώρα να έχετε ενεργή σύνδεση με το Internet, την οποία μπορείτε να μετακινήσετε στο παρασκήνιο χρησιμοποιώντας το συνδυασμό πλήκτρων <span class=keyseq><kbd>CTRL</kbd>+<kbd>z</kbd></span>. Αν παρατηρήσετε το <code>PPP</code> να γίνεται ξανά <code>ppp</code>, η σύνδεση έχει διακοπεί. Με τον τρόπο αυτό μπορείτε να παρακολουθείτε την κατάσταση της σύνδεση σας. Τα κεφαλαία P δείχνουν ότι υπάρχει σύνδεση με τον ISP ενώ τα μικρά p δείχνουν ότι για κάποιο λόγο η σύνδεση έχει χαθεί. Το <code>ppp</code> έχει μόνο αυτές τις δύο καταστάσεις.</p></div><div class=sect4><h5 id=_αντιμετώπιση_προβλημάτων_4>52.4.2.1. Αντιμετώπιση Προβλημάτων<a class=anchor href=#_αντιμετώπιση_προβλημάτων_4></a></h5><div class=paragraph><p>Αν έχετε απευθείας γραμμή και δεν φαίνεται να μπορείτε να αποκαταστήσετε τη σύνδεση, απενεργοποιήστε τον έλεγχο ροής μέσω υλικού (CTS/RTS) χρησιμοποιώντας την επιλογή <code>set ctsrts off</code>. Το παραπάνω συμβαίνει συνήθως αν είστε συνδεμένος σε κάποιο εξυπηρετητή τερματικών με δυνατότητα PPP, όπου το PPP σταματάει να αποκρίνεται όταν προσπαθεί να γράψει δεδομένα στη σύνδεση σας. Στην περίπτωση αυτή, συνήθως περιμένει για κάποιο σήμα CTS (Clear To Send) το οποίο δεν έρχεται ποτέ. Αν ωστόσο χρησιμοποιήσετε αυτή την επιλογή, θα πρέπει επίσης να χρησιμοποιήσετε και την επιλογή <code>set accmap</code> η οποία ενδεχομένως απαιτείται για να απομονωθεί το υλικό που εξαρτάται από τη μετάδοση συγκεκριμένων χαρακτήρων από τη μια άκρη στην άλλη, συνήθως μέσω του XON/XOFF. Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> για περισσότερες πληροφορίες σχετικά με αυτή την επιλογή και πως μπορείτε να την χρησιμοποιήσετε.</p></div><div class=paragraph><p>Αν διαθέτετε ένα παλαιότερο modem, ίσως χρειαστεί να χρησιμοποιήσετε την επιλογή <code>set parity even</code>. Η προεπιλεγμένη ρύθμιση είναι να μην υπάρχει ισοτιμία (parity none), αλλά σε παλιά modems (και σε κάποιους ISP) χρησιμοποιείται για έλεγχο λαθών (η χρήση της προκαλεί ωστόσο μεγάλη αύξηση στη μετακίνηση δεδομένων). Ίσως χρειαστείτε αυτή την επιλογή, αν ο ISP σας είναι η Compuserve.</p></div><div class=paragraph><p>Το PPP ίσως να μην επανέλθει στην κατάσταση εντολών, το οποίο είναι συνήθως σφάλμα διαπραγμάτευσης, καθώς ο ISP περιμένει από τη δική σας μεριά να ξεκινήσει τη διαπραγμάτευση. Στο σημείο αυτό, η χρήση της εντολής <code>~p</code> θα εξαναγκάσει το ppp να αρχίσει να στέλνει τις πληροφορίες σχετικά με τη ρύθμιση.</p></div><div class=paragraph><p>Αν δεν πάρετε ποτέ προτροπή εισόδου, το πιθανότερο είναι να πρέπει να χρησιμοποιήσετε πιστοποίηση PAP ή CHAP αντί για την τύπου UNIX® πιστοποίηση που περιγράψαμε στο παραπάνω παράδειγμα. Για να χρησιμοποιήσετε PAP ή CHAP απλώς προσθέστε τις παρακάτω επιλογές στην εφαρμογή PPP πριν βρεθείτε σε κατάσταση τερματικού:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authname myusername</code></pre></div></div><div class=paragraph><p>Θα πρέπει να αντικαταστήσετε το <em>myusername</em> με το όνομα χρήστη που σας έχει δοθεί από τον ISP σας.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authkey mypassword</code></pre></div></div><div class=paragraph><p>Θα πρέπει να αντικαταστήσετε το <em>mypassword</em> με τον κωδικό χρήστη που σας έχει δοθεί από τον ISP σας.</p></div><div class=paragraph><p>Αν συνδέεστε κανονικά, αλλά δεν φαίνεται να μπορείτε να επικοινωνήσετε με καμιά διεύθυνση, προσπαθήστε να χρησιμοποιήσετε την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> με μια διεύθυνση IP για να δείτε αν θα λάβετε απάντηση. Αν βλέπετε απώλεια πακέτων 100%, το πιο πιθανό είναι ότι δεν έχετε καθορίσει κάποια προεπιλεγμένη διαδρομή. Ελέγξτε ξανά ότι έχετε ρυθμίσει την επιλογή <code>add default HISADDR</code> κατά τη διάρκεια της σύνδεσης. Αν μπορείτε να επικοινωνήσετε με μια απομακρυσμένη διεύθυνση IP, το πιθανότερο είναι ότι δεν έχετε βάλει τη διεύθυνση κάποιου διακομιστή ονομάτων στο αρχείο <span class=filename>/etc/resolv.conf</span>. Το αρχείο αυτό θα πρέπει να μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>domain example.com
nameserver x.x.x.x
nameserver y.y.y.y</pre></div></div><div class=paragraph><p>Όπου τα <em>x.x.x.x</em> και <em>y.y.y.y</em> θα πρέπει να αντικατασταθούν με τις διευθύνσεις IP των διακομιστών DNS του ISP σας. Ενδεχομένως οι πληροφορίες αυτές να σας έχουν δοθεί κατά την εγγραφή σας στην υπηρεσία. Αν όχι, θα μπορέσετε να τις βρείτε εύκολα με ένα τηλεφώνημα στον ISP σας.</p></div><div class=paragraph><p>Μπορείτε επίσης να ενεργοποιήσετε την καταγραφή συμβάντων για την PPP σύνδεση σας, μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a>. Απλώς προσθέστε:</p></div><div class="literalblock programlisting"><div class=content><pre>!ppp
*.*     /var/log/ppp.log</pre></div></div><div class=paragraph><p>στο <span class=filename>/etc/syslog.conf</span>. Τις περισσότερες φορές, αυτή η λειτουργία υπάρχει ήδη.</p></div></div></div></div><div class=sect2><h3 id=pppoe>52.5. Χρησιμοποιώντας PPP μέσω Ethernet (PPPoE)<a class=anchor href=#pppoe></a></h3><div class=paragraph><p>Η ενότητα αυτή περιγράφει πως να ρυθμίσετε μια σύνδεση PPP μέσω Ethernet (PPPoE).</p></div><div class=sect3><h4 id=_ρύθμιση_του_πυρήνα_4>52.5.1. Ρύθμιση του Πυρήνα<a class=anchor href=#_ρύθμιση_του_πυρήνα_4></a></h4><div class=paragraph><p>Δεν απαιτείται πλέον ειδική ρύθμιση του πυρήνα για τη λειτουργία PPPoE. Αν ο πυρήνας σας δεν περιλαμβάνει την απαραίτητη υποστήριξη netgraph, το ppp θα την φορτώσει αυτόματα ως άρθρωμα.</p></div></div><div class=sect3><h4 id=_ρύθμιση_του_ppp_conf>52.5.2. Ρύθμιση του <span class=filename>ppp.conf</span><a class=anchor href=#_ρύθμιση_του_ppp_conf></a></h4><div class=paragraph><p>Παρακάτω φαίνεται ένα υπόδειγμα αρχείου <span class=filename>ppp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set log Phase tun command # you can add more detailed logging if you wish
  set ifaddr 10.0.0.1/0 10.0.0.2/0

name_of_service_provider:
  set device PPPoE:xl1 # replace xl1 with your Ethernet device
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set dial
  set login
  add default HISADDR</pre></div></div></div><div class=sect3><h4 id=_εκτέλεση_του_ppp>52.5.3. Εκτέλεση του ppp<a class=anchor href=#_εκτέλεση_του_ppp></a></h4><div class=paragraph><p>Ως χρήστης <code>root</code>, μπορείτε να εκτελέσετε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -ddial name_of_service_provider</span></code></pre></div></div></div><div class=sect3><h4 id=_εκκίνηση_του_ppp_κατά_την_εκκίνηση>52.5.4. Εκκίνηση του ppp κατά την Εκκίνηση<a class=anchor href=#_εκκίνηση_του_ppp_κατά_την_εκκίνηση></a></h4><div class=paragraph><p>Προσθέστε τις παρακάτω γραμμές στο αρχείο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;	# if you want to enable nat for your local network, otherwise NO
ppp_profile=&#34;name_of_service_provider&#34;</pre></div></div></div><div class=sect3><h4 id=_χρήση_μιας_ετικέτας_υπηρεσίας_pppoe>52.5.5. Χρήση μιας Ετικέτας Υπηρεσίας PPPoE<a class=anchor href=#_χρήση_μιας_ετικέτας_υπηρεσίας_pppoe></a></h4><div class=paragraph><p>Μερικές φορές θα χρειαστεί να χρησιμοποιήσετε μια ετικέτα υπηρεσίας (service tag) για την αποκατάσταση της σύνδεσης σας. Οι ετικέτες υπηρεσιών χρησιμοποιούνται για τον διαχωρισμό μεταξύ διαφορετικών εξυπηρετητών PPPoE που βρίσκονται στο ίδιο δίκτυο.</p></div><div class=paragraph><p>Η τεκμηρίωση που σας έχει δώσει ο ISP σας, θα πρέπει να έχει τις απαιτούμενες πληροφορίες για την ετικέτα υπηρεσίας που χρειάζεστε. Αν δεν μπορείτε να την βρείτε, ρωτήστε την εξυπηρέτηση πελατών του ISP σας.</p></div><div class=paragraph><p>Ως τελευταία λύση, θα μπορούσατε να δοκιμάσετε την μέθοδο που συνίσταται στο πρόγραμμα <a href=http://www.roaringpenguin.com/pppoe/>Roaring Penguin PPPoE</a> το οποίο μπορείτε να βρείτε στην <a href=./#ports>Συλλογή των Ports</a>. Να έχετε υπόψη σας, ότι αυτό μπορεί να αποπρογραμματίσει και να αχρηστεύσει το modem σας, έτσι σκεφτείτε το καλά πριν το κάνετε. Απλώς εγκαταστήστε το πρόγραμμα που δίνει ο παροχέας σας μαζί με το modem. Έπειτα, εισέλθετε στο μενού <b class=menuref>System</b> του προγράμματος. Εκεί θα πρέπει να είναι το όνομα του προφίλ σας. Συνήθως γράφει <em>ISP</em>.</p></div><div class=paragraph><p>Το όνομα του προφίλ (ετικέτα υπηρεσίας) θα χρησιμοποιηθεί στην καταχώριση για την ρύθμιση του PPPoE στο αρχείο <span class=filename>ppp.conf</span>, ως το τμήμα που δηλώνει τον παροχέα στην εντολή <code>set device</code> (δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> για πλήρεις λεπτομέρειες). θα δείχνει όπως το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>set device PPPoE:xl1:ISP</pre></div></div><div class=paragraph><p>Μην ξεχάσετε να αλλάξετε το <em>xl1</em> με τη σωστή συσκευή που αντιστοιχεί στην κάρτα Ethernet που χρησιμοποιείτε.</p></div><div class=paragraph><p>Μην ξεχάσετε να αλλάξετε το <em>ISP</em> με το προφίλ που βρήκατε παραπάνω.</p></div><div class=paragraph><p>Για περισσότερες πληροφορίες, δείτε:</p></div><div class=ulist><ul><li><p><a href=http://renaud.waldura.com/doc/freebsd/pppoe/>Φθηνότερες Ευρυζωνικές Συνδέσεις μέσω FreeBSD σε Γραμμή DSL</a> από τον Renaud Waldura.</p></li></ul></div></div><div class=sect3><h4 id=ppp-3com>52.5.6. Το PPPoE σε Modem 3Com® HomeConnect™ ADSL Dual Link<a class=anchor href=#ppp-3com></a></h4><div class=paragraph><p>Αυτό το modem δεν ακολουθεί το <a href=http://www.faqs.org/rfcs/rfc2516.html>RFC 2516</a> (<em>Μια μέθοδος για μετάδοση PPP μέσω Ethernet (PPPoE)</em>, γραμμένο από τους L. Mamakos, K. Lidl, J. Evarts, D. Carrel, D. Simone, και R. Wheeler). Αντίθετα, χρησιμοποιεί διαφορετικούς τύπους κωδικών πακέτων για τα πλαίσια Ethernet. Παρακαλούμε να εκφράσετε τα παράπονα σας στην <a href=http://www.3com.com/>3Com</a> αν νομίζετε ότι θα πρέπει να συμμορφωθεί με τις προδιαγραφές του PPPoE.</p></div><div class=paragraph><p>Για να μπορεί το FreeBSD να επικοινωνεί με αυτή τη συσκευή, θα πρέπει να τεθεί ένα κατάλληλο sysctl. Αυτό μπορεί να γίνεται αυτόματα κατά την εκκίνηση, με την ενημέρωση του αρχείου <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.graph.nonstandard_pppoe=1</pre></div></div><div class=paragraph><p>ή μπορεί να γίνει άμεσα με την εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.graph.nonstandard_pppoe=1</span></code></pre></div></div><div class=paragraph><p>Δυστυχώς, επειδή πρόκειται για μια ρύθμιση που επηρεάζει ολόκληρο το σύστημα, δεν είναι δυνατόν να επικοινωνείτε ταυτόχρονα με ένα κανονικό πελάτη ή εξυπηρετητή PPPoE και με ένα ADSL modem 3Com® HomeConnect™.</p></div></div></div><div class=sect2><h3 id=pppoa>52.6. Χρησιμοποιώντας PPP μέσω ATM (PPPoA)<a class=anchor href=#pppoa></a></h3><div class=paragraph><p>Ή ενότητα που ακολουθεί, περιγράφει πως να ρυθμίσετε το PPP για λειτουργία μέσω ATM (PPPoA). Το PPPoA είναι μια δημοφιλής επιλογή στους παροχείς υπηρεσιών DSL στην Ευρώπη.</p></div><div class=sect3><h4 id=_χρησιμοποιώντας_pppoa_με_το_alcatel_speedtouch_usb>52.6.1. Χρησιμοποιώντας PPPoA με το Alcatel SpeedTouch™ USB<a class=anchor href=#_χρησιμοποιώντας_pppoa_με_το_alcatel_speedtouch_usb></a></h4><div class=paragraph><p>Η υποστήριξη PPPooA για αυτή τη συσκευή, παρέχεται ως port στο FreeBSD, καθώς το firmware της συσκευής διανέμεται υπό την άδεια <a href=http://www.speedtouchdsl.com/disclaimer_lx.htm>Alcatel’s license agreement</a> και δεν μπορεί να διανεμηθεί ελεύθερα με το βασικό σύστημα του FreeBSD.</p></div><div class=paragraph><p>Για να εγκαταστήσετε το λογισμικό, απλά χρησιμοποιήστε την <a href=./#ports>Συλλογή των Ports</a>. Εγκαταστήστε το port <a class=package href=https://cgit.freebsd.org/ports/tree/net/pppoa/>net/pppoa</a> και ακολουθήστε τις οδηγίες που περιλαμβάνονται σε αυτό.</p></div><div class=paragraph><p>Όπως πολλές συσκευές USB, το Alcatel SpeedTouch™ χρειάζεται να κατεβάσει το firmware του από τον υπολογιστή στο οποίο είναι συνδεμένο, προκειμένου να λειτουργήσει σωστά. Η διαδικασία αυτή μπορεί να αυτοματοποιηθεί στο FreeBSD, ώστε η μεταφορά να γίνεται κάθε φορά που συνδέεται η συσκευή στη θύρα USB. Μπορείτε να προσθέσετε τις παρακάτω πληροφορίες στο αρχείο <span class=filename>/etc/usbd.conf</span> για να ενεργοποιήσετε την αυτόματη μεταφορά του firmware. Θα πρέπει να επεξεργαστείτε αυτό το αρχείο ως χρήστης <code>root</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>device &#34;Alcatel SpeedTouch USB&#34;
    devname &#34;ugen[0-9]+&#34;
    vendor 0x06b9
    product 0x4061
    attach &#34;/usr/local/sbin/modem_run -f /usr/local/libdata/mgmt.o&#34;</pre></div></div><div class=paragraph><p>Για να ενεργοποιήσετε το usbd, το δαίμονα USB, προσθέστε την παρακάτω γραμμή στο αρχείο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>usbd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Μπορεί επίσης να ρυθμίσετε το ppp ώστε να εκτελεί αυτόματα κλήση κατά την εκκίνηση του συστήματος. Για να γίνει αυτό, προσθέστε τις παρακάτω γραμμές στο <span class=filename>/etc/rc.conf</span>. Θα πρέπει και πάλι να εκτελέσετε τη διαδικασία αυτή ως <code>root</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_profile=&#34;adsl&#34;</pre></div></div><div class=paragraph><p>Για να λειτουργήσει σωστά το παραπάνω, θα πρέπει να έχετε χρησιμοποιήσει το υπόδειγμα του αρχείου <span class=filename>ppp.conf</span> το οποίο παρέχεται με το port <a class=package href=https://cgit.freebsd.org/ports/tree/net/pppoa/>net/pppoa</a>.</p></div></div><div class=sect3><h4 id=_χρησιμοποιώντας_το_mpd>52.6.2. Χρησιμοποιώντας το mpd<a class=anchor href=#_χρησιμοποιώντας_το_mpd></a></h4><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε το mpd για να συνδεθείτε σε ένα πλήθος υπηρεσιών, και ειδικότερα υπηρεσίες PPTP. Μπορείτε να βρείτε το mpd στην Συλλογή των Ports, στο <a class=package href=https://cgit.freebsd.org/ports/tree/net/mpd/>net/mpd</a>. Πολλά ADSL modem απαιτούν τη δημιουργία ενός PPTP τούνελ μεταξύ του modem και του υπολογιστή. Ένα τέτοιο modem είναι το Alcatel SpeedTouch™ Home.</p></div><div class=paragraph><p>Πρώτα πρέπει να εγκαταστήσετε το port, και μετά μπορείτε να ρυθμίσετε το mpd ώστε να καλύπτει τις απαιτήσεις σας και τις ρυθμίσεις του παροχέα σας. Το port εγκαθιστά κάποια παραδείγματα αρχείων ρυθμίσεων στον κατάλογο <span class=filename>PREFIX/etc/mpd/</span>. Τα αρχεία αυτά περιέχουν αρκετά καλή τεκμηρίωση των ρυθμίσεων. Σημειώστε εδώ, ότι το <em>PREFIX</em> είναι ο κατάλογος στον οποίο εγκαθίστανται τα ports, και από προεπιλογή είναι ο <span class=filename>/usr/local/</span>. Μετά την εγκατάσταση του port, θα βρείτε ένα πλήρη οδηγό για τη ρύθμιση του mpd σε μορφή HTML. Η τεκμηρίωση εγκαθίσταται στον κατάλογο <span class=filename>PREFIX/shared/doc/mpd/</span>. Παρακάτω φαίνεται ένα υπόδειγμα ρυθμίσεων για σύνδεση σε μια υπηρεσία ADSL μέσω του mpd. Οι ρυθμίσεις χωρίζονται σε δύο αρχεία, πρώτα δείχνουμε το <span class=filename>mpd.conf</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το παρακάτω υπόδειγμα <span class=filename>mpd.conf</span> λειτουργεί μόνο με την έκδοση 4.X του mpd.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <i class=conum data-value=1></i><b>(1)</b>
    set bundle password password <i class=conum data-value=2></i><b>(2)</b>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Το όνομα χρήστη με το οποίο γίνεται η πιστοποίηση στον ISP σας.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Ο κωδικός με τον οποίο γίνεται η πιστοποίηση στον ISP σας.</td></tr></tbody></table></div><div class=paragraph><p>Το αρχείο <span class=filename>mpd.links</span> περιέχει πληροφορίες σχετικά με τη σύνδεση ή τις συνδέσεις που θα πραγματοποιηθούν. Για παράδειγμα, το <span class=filename>mpd.links</span> που συνοδεύει το παραπάνω παράδειγμα, φαίνεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <i class=conum data-value=1></i><b>(1)</b>
    set pptp peer 10.0.0.138 <i class=conum data-value=2></i><b>(2)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Η διεύθυνση IP του FreeBSD υπολογιστή σας, στον οποίο θα χρησιμοποιήσετε το mpd.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Η διεύθυνση IP του ADSL modem σας. Για το Alcatel SpeedTouch™ Home, η διεύθυνση αυτή είναι από προεπιλογή η <code>10.0.0.138</code>.</td></tr></tbody></table></div><div class=paragraph><p>Είναι δυνατόν να αρχικοποιήσετε τη σύνδεση εύκολα, δίνοντας την παρακάτω εντολή ως <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpd -b adsl</span></code></pre></div></div><div class=paragraph><p>Μπορείτε να δείτε την κατάσταση της σύνδεσης με την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig ng0
ng0: <span class=nv>flags</span><span class=o>=</span>88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt; mtu 1500
     inet 216.136.204.117 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>Το mpd αποτελεί τον συνιστώμενο τρόπο σύνδεσης του FreeBSD με μια υπηρεσία ADSL.</p></div></div><div class=sect3><h4 id=_χρησιμοποιώντας_το_pptpclient>52.6.3. Χρησιμοποιώντας το pptpclient<a class=anchor href=#_χρησιμοποιώντας_το_pptpclient></a></h4><div class=paragraph><p>Μπορείτε επίσης να χρησιμοποιήσετε το FreeBSD για να συνδεθείτε σε άλλες υπηρεσίες PPPoA χρησιμοποιώντας το <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a>.</p></div><div class=paragraph><p>Για να χρησιμοποιήσετε το <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a> για να συνδεθείτε σε μια υπηρεσία DSL, εγκαταστήστε το port ή το πακέτο, και επεξεργαστείτε το αρχείο <span class=filename>/etc/ppp/ppp.conf</span>. Θα χρειαστεί να είστε <code>root</code> για να κάνετε και τις δύο παραπάνω διαδικασίες. Παρακάτω φαίνεται ένα παράδειγμα μιας ενότητας του <span class=filename>ppp.conf</span>. Για περισσότερες πληροφορίες σχετικά με τις επιλογές του <span class=filename>ppp.conf</span>, δείτε τη σελίδα manual του ppp, <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <i class=conum data-value=1></i><b>(1)</b>
 set authkey password <i class=conum data-value=2></i><b>(2)</b>
 set ifaddr 0 0
 add default HISADDR</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Το όνομα χρήστη για τον λογαριασμό σας στον παροχέα DSL.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Ο κωδικός για τον λογαριασμό σας.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Καθώς θα πρέπει να γράψετε τον κωδικό σας μορφή απλού κειμένου στο αρχείο <span class=filename>ppp.conf</span>, θα πρέπει να βεβαιωθείτε ότι κανένας άλλος δεν θα μπορεί να διαβάσει τα περιεχόμενα αυτού του αρχείου. Με τις παρακάτω εντολές, μπορείτε να εξασφαλίσετε ότι το αρχείο θα μπορεί να διαβαστεί μόνο μέσα από το λογαριασμό του <code>root</code>. Δείτε τις σελίδες manual των <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a> για περισσότερες πληροφορίες.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:wheel /etc/ppp/ppp.conf</span>
<span class=c># chmod 600 /etc/ppp/ppp.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Αυτό θα ανοίξει ένα τούνελ για μια συνεδρία PPP με τον DSL δρομολογητή σας. Τα DSL modem τύπου ethernet έχουν μια προκαθορισμένη διεύθυνση IP στο τοπικό σας δίκτυο, στην οποία μπορείτε να συνδεθείτε. Στην περίπτωση του Alcatel SpeedTouch™ Home, η διεύθυνση αυτή είναι <code>10.0.0.138</code>. Η τεκμηρίωση που διαθέτει ο δρομολογητής σας, θα αναφέρει ποια διεύθυνση χρησιμοποιεί η συσκευή σας. Για να ανοίξετε το τούνελ και να ξεκινήσετε μια συνεδρία PPP, εκτελέστε την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pptp address adsl</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Είναι καλή ιδέα να προσθέσετε ένα "&" στο τέλος της προηγούμενης εντολής, διαφορετικά το pptp δεν θα σας επιστρέψει τον έλεγχο (προτροπή) του τερματικού σας.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Θα δημιουργηθεί μια συσκευή <span class=filename>tun</span> (εικονικό τούνελ) για την αλληλεπίδραση μεταξύ των διεργασιών pptp και ppp. Μόλις επιστρέψει η προτροπή στο τερματικό σας, ή το pptp επιβεβαιώσει τη σύνδεση, μπορείτε να εξετάσετε το τούνελ με τον τρόπο που φαίνεται παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig tun0
tun0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
        inet 216.136.204.21 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffff00
        Opened by PID 918</code></pre></div></div><div class=paragraph><p>Αν δεν μπορέσετε να συνδεθείτε, ελέγξτε τις ρυθμίσεις του δρομολογητή σας, οι οποίες συνήθως είναι προσβάσιμες μέσω telnet ή μέσω κάποιου φυλλομετρητή. Αν ακόμα δεν μπορείτε να συνδεθείτε, θα πρέπει να εξετάσετε την έξοδο της εντολής <code>pptp</code> και τα περιεχόμενα του αρχείου καταγραφής του ppp, <span class=filename>/var/log/ppp.log</span> για πιθανά στοιχεία.</p></div></div></div><div class=sect2><h3 id=slip>52.7. Χρησιμοποιώντας το SLIP<a class=anchor href=#slip></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Η ενότητα αυτή εφαρμόζεται και είναι έγκυρη μόνο σε συστήματα FreeBSD 7.X.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=slipc>52.7.1. Ρυθμίζοντας ένα Πελάτη SLIP<a class=anchor href=#slipc></a></h4><div class=paragraph><p>Παρακάτω παρουσιάζουμε ένα τρόπο να ρυθμίσετε ένα μηχάνημα FreeBSD ως πελάτη SLIP σε ένα δίκτυο με στατικές διευθύνσεις. Για μηχανήματα τα οποία λαμβάνουν όνομα δυναμικά (η διεύθυνση τους αλλάζει κάθε φορά που συνδέονται), πιθανόν να χρειαστεί να κάνετε πιο πολύπλοκες ρυθμίσεις.</p></div><div class=paragraph><p>Αρχικά, θα πρέπει να καθορίσετε σε ποια σειριακή θύρα είναι συνδεμένο το modem σας. Αρκετοί χρήστες δημιουργούν ένα συμβολικό δεσμό π.χ. <span class=filename>/dev/modem</span>, το οποίο δείχνει στην πραγματική συσκευή <span class=filename>/dev/cuadN</span>. Αυτό σας επιτρέπει να συνεχίσετε να χρησιμοποιείτε το ίδιο όνομα συσκευής, ακόμα και αν μετακινήσετε το modem σε διαφορετική θύρα. Είναι μάλλον άβολο να πρέπει να αλλάξετε πλήθος αρχείων στο <span class=filename>/etc</span> καθώς και τα αρχεία <span class=filename>.kermrc</span> σε όλο το σύστημα!</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το <span class=filename>/dev/cuad0</span> είναι η <span class=filename>COM1</span>, το <span class=filename>/dev/cuad1</span> είναι η <span class=filename>COM2</span>, κ.ο.κ.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Βεβαιωθείτε ότι το αρχείο ρυθμίσεων του πυρήνα σας περιέχει τα παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>device   sl</pre></div></div><div class=paragraph><p>Το παραπάνω περιλαμβάνεται στον πυρήνα <span class=filename>GENERIC</span>, και αν δεν το έχετε διαγράψει, δεν θα έχετε πρόβλημα.</p></div><div class=sect4><h5 id=_ρυθμίσεις_που_θα_χρειαστεί_να_κάνετε_μόνο_μια_φορά>52.7.1.1. Ρυθμίσεις που θα Χρειαστεί να Κάνετε Μόνο μια Φορά<a class=anchor href=#_ρυθμίσεις_που_θα_χρειαστεί_να_κάνετε_μόνο_μια_φορά></a></h5><div class="olist arabic procedure"><ol class=arabic><li><p>Προσθέστε το μηχάνημα σας, την πύλη (gateway) και τους διακομιστές ονομάτων (nameservers) στο αρχείο <span class=filename>/etc/hosts</span>. Στο παράδειγμα μας, το αρχείο αυτό μοιάζει με το παρακάτω:</p><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost loghost
136.152.64.181          water.CS.Example.EDU water.CS water
136.152.64.1            inr-3.CS.Example.EDU inr-3 slip-gateway
128.32.136.9            ns1.Example.EDU ns1
128.32.136.12           ns2.Example.EDU ns2</pre></div></div></li><li><p>Βεβαιωθείτε ότι η ενότητα <code>files</code> βρίσκεται πριν το <code>dns</code> στην ενότητα <code>hosts:</code> του αρχείου <span class=filename>/etc/nsswitch.conf</span>. Αν δεν υπάρχουν αυτές οι παράμετροι, μπορεί να εμφανιστούν παράξενα συμπτώματα.</p></li><li><p>Τροποποιήστε το αρχείο <span class=filename>/etc/rc.conf</span>.</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Ορίστε το όνομα του υπολογιστή σας, τροποποιώντας τη γραμμή που γράφει:</p><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;myname.my.domain&#34;</pre></div></div><div class=paragraph><p>Θα πρέπει εδώ να τοποθετήσετε το πλήρες όνομα του υπολογιστή σας.</p></div></li><li><p>Ορίστε τον προεπιλεγμένο δρομολογητή, αλλάζοντας τη γραμμή:</p><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;NO&#34;</pre></div></div><div class=paragraph><p>σε:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;slip-gateway&#34;</pre></div></div></li></ol></div></li><li><p>Δημιουργήστε ένα αρχείο <span class=filename>/etc/resolv.conf</span> το οποίο θα περιέχει:</p><div class="literalblock programlisting"><div class=content><pre>domain CS.Example.EDU
nameserver 128.32.136.9
nameserver 128.32.136.12</pre></div></div><div class=paragraph><p>Όπως μπορείτε να δείτε, το παραπάνω ορίζει τους διακομιστές DNS. Φυσικά, τα πραγματικά ονόματα και οι διευθύνσεις των τομέων εξαρτώνται από το περιβάλλον σας.</p></div></li><li><p>Ρυθμίστε κωδικό πρόσβασης για τους χρήστες <code>root</code> και <code>toor</code> (καθώς και για όσους άλλους λογαριασμούς δεν έχουν κωδικό).</p></li><li><p>Επανεκκινήστε το μηχάνημα σας, και βεβαιωθείτε ότι έχει τεθεί σωστά το όνομα υπολογιστή.</p></li></ol></div></div><div class=sect4><h5 id=_δημιουργώντας_μια_σύνδεση_slip>52.7.1.2. Δημιουργώντας μια Σύνδεση SLIP<a class=anchor href=#_δημιουργώντας_μια_σύνδεση_slip></a></h5><div class="olist arabic procedure"><ol class=arabic><li><p>Μετά την κλήση, γράψτε την εντολή <code>slip</code> στην προτροπή, γράψτε το όνομα του μηχανήματος σας και τον κωδικό. Το τι ακριβώς χρειάζεται να γράψετε, εξαρτάται από το περιβάλλον σας. Αν χρησιμοποιείτε το Kermit, μπορείτε να χρησιμοποιήσετε ένα script όπως το ακόλουθο:</p><div class="literalblock programlisting"><div class=content><pre># kermit setup
set modem hayes
set line /dev/modem
set speed 115200
set parity none
set flow rts/cts
set terminal bytesize 8
set file type binary
# The next macro will dial up and login
define slip dial 643-9600, input 10 =&gt;, if failure stop, -
output slip\x0d, input 10 Username:, if failure stop, -
output silvia\x0d, input 10 Password:, if failure stop, -
output ***\x0d, echo \x0aCONNECTED\x0a</pre></div></div><div class=paragraph><p>Φυσικά, θα πρέπει να αλλάξετε το όνομα χρήστη και τον κωδικό ώστε να ταιριάζουν με τα δικά σας. Μετά από αυτό, μπορείτε απλώς να πληκτρολογήσετε <code>slip</code> στην προτροπή σύνδεσης του Kermit.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η ύπαρξη του κωδικού σας σε μορφή απλού κειμένου σε οποιοδήποτε σημείο ενός συστήματος αρχείων, είναι γενικά <em>κακή</em> ιδέα. Προχωρήστε με δική σας ευθύνη.</p></div></td></tr></tbody></table></div></li><li><p>Αφήστε το Kermit εκεί (μπορείτε να το στείλετε στο παρασκήνιο χρησιμοποιώντας τα πλήκτρα <span class=keyseq><kbd>Ctrl</kbd>+<kbd>z</kbd></span>) και ως <code>root</code>, γράψτε:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># slattach -h -c -s 115200 /dev/modem</span></code></pre></div></div><div class=paragraph><p>Αν μπορείτε να κάνετε <code>ping</code> σε υπολογιστές στην άλλη μεριά του δρομολογητή, είστε συνδεμένοι! Αν αυτό δεν δουλεύει, δοκιμάστε την επιλογή <code>-a</code> αντί για την <code>-c</code> ως όρισμα στην <code>slattach</code>.</p></div></li></ol></div></div><div class=sect4><h5 id=_πως_να_τερματίσετε_την_σύνδεση>52.7.1.3. Πως να Τερματίσετε την Σύνδεση<a class=anchor href=#_πως_να_τερματίσετε_την_σύνδεση></a></h5><div class=paragraph><p>Κάντε τα ακόλουθα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -INT `cat /var/run/slattach.modem.pid`</span></code></pre></div></div><div class=paragraph><p>για να τερματίσετε το <code>slattach</code>. Θυμηθείτε ότι πρέπει να είστε <code>root</code> για να εκτελέσετε το παραπάνω. Έπειτα επανέλθετε στο <code>kermit</code> (εκτελώντας την <code>fg</code> αν το είχατε στείλει στο παρασκήνιο) και τερματίστε το (πιέζοντας <kbd>q</kbd>).</p></div><div class=paragraph><p>Η σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=slattach&amp;sektion=8&amp;format=html">slattach(8)</a> αναφέρει ότι μπορείτε να χρησιμοποιήσετε την εντολή <code>ifconfig sl0 down</code> για να διακόψετε τη σύνδεση, αλλά αυτό δεν φαίνεται να έχει κανένα αποτέλεσμα. (To <code>ifconfig sl0</code> αναφέρει το ίδιο πράγμα.)</p></div><div class=paragraph><p>Μερικές φορές, το modem σας μπορεί να αρνηθεί να κλείσει τη γραμμή. Στις περιπτώσεις αυτές, ξεκινήστε ξανά το <code>kermit</code> και τερματίστε το ξανά. Τη δεύτερη φορά συνήθως πετυχαίνει.</p></div></div><div class=sect4><h5 id=_αντιμετώπιση_προβλημάτων_5>52.7.1.4. Αντιμετώπιση Προβλημάτων<a class=anchor href=#_αντιμετώπιση_προβλημάτων_5></a></h5><div class=paragraph><p>Αν το παραπάνω δεν λειτουργήσει, ρωτήστε στη λίστα <a href=https://lists.FreeBSD.org/subscription/freebsd-net>freebsd-net</a>. Μερικά από τα συνηθισμένα προβλήματα τα οποία έχουμε μέχρι στιγμής αντιμετωπίσει:</p></div><div class=ulist><ul><li><p>Να μην έχει χρησιμοποιηθεί η επιλογή <code>-c</code> ή <code>-a</code> στην <code>slattach</code> (Αυτό κανονικά δεν είναι κρίσιμο σφάλμα, αλλά μερικοί χρήστες ανέφεραν ότι αυτό έλυσε τα προβλήματα τους.)</p></li><li><p>Χρήση του <code>s10</code> αντί για <code>sl0</code> (η διαφορά μπορεί να είναι πολύ μικρή σε μερικές γραμματοσειρές).</p></li><li><p>Δοκιμάστε την εντολή <code>ifconfig sl0</code> για να δείτε την κατάσταση της διεπαφής. Για παράδειγμα, μπορεί να δείτε το παρακάτω:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig sl0</span>
sl0: <span class=nv>flags</span><span class=o>=</span>10&lt;POINTOPOINT&gt;
        inet 136.152.64.181 <span class=nt>--</span><span class=o>&gt;</span> 136.152.64.1 netmask ffffff00</code></pre></div></div></li><li><p>Αν η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> δίνει μηνύματα <code>no route to host</code>, ίσως υπάρχει πρόβλημα με τον πίνακα δρομολόγησης σας. Μπορείτε να χρησιμοποιήσετε την εντολή <code>netstat -r</code> για να δείτε την τρέχουσα δρομολόγηση:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -r</span>
Routing tables
Destination      Gateway            Flags     Refs     Use  IfaceMTU    Rtt    Netmasks:

<span class=o>(</span>root node<span class=o>)</span>
<span class=o>(</span>root node<span class=o>)</span>

Route Tree <span class=k>for </span>Protocol Family inet:
<span class=o>(</span>root node<span class=o>)</span> <span class=o>=&gt;</span>
default          inr-3.Example.EDU  UG          8   224515  sl0 -      -
localhost.Exampl localhost.Example. UH          5    42127  lo0 -       0.438
inr-3.Example.ED water.CS.Example.E UH          1        0  sl0 -      -
water.CS.Example localhost.Example. UGH        34 47641234  lo0 -       0.438
<span class=o>(</span>root node<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Τα παραπάνω παραδείγματα είναι από ένα σχετικά απασχολημένο σύστημα. Οι αριθμοί θα διαφέρουν στο σύστημα σας, ανάλογα με τη δραστηριότητα του δικτύου.</p></div></li></ul></div></div></div><div class=sect3><h4 id=slips>52.7.2. Ρυθμίζοντας Ένα Εξυπηρετητή SLIP<a class=anchor href=#slips></a></h4><div class=paragraph><p>Το κείμενο αυτό παρέχει κάποιες υποδείξεις για τη ρύθμιση ενός FreeBSD συστήματος ως εξυπηρετητή SLIP. Τυπικά αυτό σημαίνει ότι το σύστημα σας θα ρυθμιστεί να ξεκινά αυτόματα τις συνδέσεις μετά την είσοδο απομακρυσμένων πελατών SLIP.</p></div><div class=sect4><h5 id=slips-prereqs>52.7.2.1. Προϋποθέσεις<a class=anchor href=#slips-prereqs></a></h5><div class=paragraph><p>Η ενότητα αυτή είναι ιδιαίτερα τεχνικής φύσεως, και για το λόγο αυτό απαιτείται να έχετε τις αντίστοιχες γνώσεις για να την κατανοήσετε. Υποθέτουμε ότι έχετε μια εξοικείωση με το πρωτόκολλο TCP/IP και ειδικότερα με τη διευθυνσιοδότηση κόμβων, τις μάσκες δικτύων, τα υποδίκτυα, τη δρομολόγηση και τα πρωτόκολλα δρομολόγησης όπως το RIP. Η ρύθμιση των υπηρεσιών SLIP σε ένα εξυπηρετητή επιλογικών συνδέσεων απαιτεί γνώση αυτών των εννοιών, και αν δεν είστε εξοικειωμένος με αυτές, σας παρακαλούμε να διαβάσετε είτε το <em>TCP/IP Network Administration</em> του Craig Hunt (εκδόσεις O’Reilly & Associates, Inc, Αριθμός ISBN 0-937175-82-X) ή κάποιο από τα βιβλία του Douglas Comer σχετικά με το πρωτόκολλο TCP/IP.</p></div><div class=paragraph><p>Επιπλέον, υποθέτουμε ότι ήδη έχετε ρυθμίσει το modem σας και έχετε τροποποιήσει τα κατάλληλα αρχεία ρυθμίσεων του συστήματος ώστε να επιτρέπεται η είσοδος στο σύστημα μέσω των modem. Αν δεν έχετε ακόμα προετοιμάσει το σύστημα για αυτό, παρακαλούμε δείτε το <a href=./#dialup>Υπηρεσία Εισόδου μέσω Επιλογικής Σύνδεσης (dial-in)</a> για λεπτομέρειες σχετικά με τη ρύθμιση των επιλογικών συνδέσεων. Ενδεχομένως να θέλετε επίσης να δείτε τις σελίδες manual της <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> για πληροφορίες σχετικά με το πρόγραμμα οδήγησης της σειριακής θύρας, τα <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>, και <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> για πληροφορίες που σχετίζονται με τη ρύθμιση του συστήματος ώστε να δέχεται είσοδο χρηστών μέσω modem, και ίσως και τη <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> για πληροφορίες σχετικά με τις παραμέτρους σειριακών θυρών (όπως την <code>clocal</code> για σειριακές διεπαφές που είναι απευθείας συνδεμένες).</p></div></div><div class=sect4><h5 id=_γρήγορη_επισκόπηση_2>52.7.2.2. Γρήγορη Επισκόπηση<a class=anchor href=#_γρήγορη_επισκόπηση_2></a></h5><div class=paragraph><p>Τυπικά, ένας εξυπηρετητής SLIP που χρησιμοποιεί FreeBSD λειτουργεί με τον εξής τρόπο: ένας χρήστης SLIP καλεί τον εξυπηρετητή SLIP, και εισέρχεται στο σύστημα μέσω ενός ειδικού αναγνωριστικού εισόδου για το SLIP. Το κέλυφος του χρήστη είναι το <span class=filename>/usr/sbin/sliplogin</span>. Το πρόγραμμα <code>sliplogin</code> διαβάζει το αρχείο <span class=filename>/etc/sliphome/slip.hosts</span> για να βρει μια γραμμή που να ταιριάζει με τον χρήστη, και αν υπάρχει, συνδέει την σειριακή γραμμή σε μια διαθέσιμη διεπαφή SLIP και έπειτα εκτελεί το script του κελύφους <span class=filename>/etc/sliphome/slip.login</span> για να ρυθμίσει τη διεπαφή SLIP.</p></div><div class=sect5><h6 id=_ένα_παράδειγμα_εισόδου_σε_εξυπηρετητή_slip>52.7.2.2.1. Ένα Παράδειγμα Εισόδου σε Εξυπηρετητή SLIP<a class=anchor href=#_ένα_παράδειγμα_εισόδου_σε_εξυπηρετητή_slip></a></h6><div class=paragraph><p>Για παράδειγμα, για ένα χρήστη SLIP με ID <code>Shelmerg</code>, η αντίστοιχη καταχώριση στο <span class=filename>/etc/master.passwd</span> θα έμοιαζε με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/sliplogin</pre></div></div><div class=paragraph><p>Όταν εισέλθει ο <code>Shelmerg</code>, το <code>sliplogin</code> θα ψάξει το <span class=filename>/etc/sliphome/slip.hosts</span> για μια γραμμή με ID χρήστη που να ταιριάζει. Για παράδειγμα, μπορεί να υπάρχει μια γραμμή στο <span class=filename>/etc/sliphome/slip.hosts</span> που να γράφει:</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg        dc-slip sl-helmer       0xfffffc00		  autocomp</pre></div></div><div class=paragraph><p>Το <code>sliplogin</code> θα βρει τη γραμμή αυτή, θα συνδέσει τη σειριακή γραμμή στην επόμενη διαθέσιμη διεπαφή SLIP, και έπειτα θα εκτελέσει το <span class=filename>/etc/sliphome/slip.login</span> όπως φαίνεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp</pre></div></div><div class=paragraph><p>Αν όλα πάνε καλά, το <span class=filename>/etc/sliphome/slip.login</span> θα εκτελέσει μια εντολή <code>ifconfig</code> για τη διεπαφή SLIP στην οποία έχει συνδεθεί η <code>sliplogin</code> (η διεπαφή 0 στο παραπάνω παράδειγμα, η πρώτη παράμετρος της λίστας που δίνεται στο <span class=filename>slip.login</span>) ώστε να ρυθμιστούν η τοπική διεύθυνση IP (<code>dc-slip</code>), η απομακρυσμένη διεύθυνση IP (<code>sl-helmer</code>), η μάσκα δικτύου για τη διεπαφή SLIP (<code>0xfffffc00</code>), και οποιεσδήποτε πρόσθετες επιλογές (<code>autocomp</code>). Αν κάτι πάει στραβά, θα μπορέσετε να το εντοπίσετε από τα αρχεία καταγραφής της <code>sliplogin</code>. Η <code>sliplogin</code> καταγράφει τα μηνύματα χρησιμοποιώντας το δαίμονα syslogd ο οποίος συνήθως χρησιμοποιεί το αρχείο <span class=filename>/var/log/messages</span> (δείτε τις σελίδες βοήθειας για τα <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> και ενδεχομένως ελέγξτε το <span class=filename>/etc/syslog.conf</span> για να δείτε την τοποθεσία και το αρχείο που χρησιμοποιεί το syslogd για την καταγραφή).</p></div></div></div><div class=sect4><h5 id=_ρύθμιση_του_πυρήνα_5>52.7.2.3. Ρύθμιση του Πυρήνα<a class=anchor href=#_ρύθμιση_του_πυρήνα_5></a></h5><div class=paragraph><p>Ο προεπιλεγμένος πυρήνας του FreeBSD (ο <span class=filename>GENERIC</span>) διαθέτει ενσωματωμένη υποστήριξη SLIP (<a href="https://man.freebsd.org/cgi/man.cgi?query=sl&amp;sektion=4&amp;format=html">sl(4)</a>). Στην περίπτωση που θέλετε να δημιουργήσετε προσαρμοσμένο πυρήνα, προσθέστε την παρακάτω γραμμή στο αρχείο ρυθμίσεων του πυρήνα σας:</p></div><div class="literalblock programlisting"><div class=content><pre>device   sl</pre></div></div><div class=paragraph><p>Το FreeBSD, από προεπιλογή, δεν προωθεί πακέτα. Αν θέλετε ο εξυπηρετητής σας να ενεργεί ως δρομολογητής, θα πρέπει να επεξεργαστείτε το αρχείο <span class=filename>/etc/rc.conf</span> και να αλλάξετε τη ρύθμιση της μεταβλητής <code>gateway_enable</code> σε <code>YES</code>. Με τον τρόπο αυτό, θα είναι σίγουρο ότι η επιλογή της δρομολόγησης θα διατηρηθεί μετά από μια επανεκκίνηση.</p></div><div class=paragraph><p>Θα πρέπει έπειτα να επανεκκινήσετε για να ενεργοποιηθούν οι νέες ρυθμίσεις.</p></div><div class=paragraph><p>Για να εφαρμόσετε αυτές τις ρυθμίσεις άμεσα, μπορείτε να εκτελέσετε την παρακάτω εντολή ως <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/routing start</span></code></pre></div></div><div class=paragraph><p>Παρακαλούμε δείτε το <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a> για περισσότερες πληροφορίες σχετικά με την ρύθμιση του πυρήνα του FreeBSD.</p></div></div><div class=sect4><h5 id=_ρύθμιση_του_sliplogin>52.7.2.4. Ρύθμιση του Sliplogin<a class=anchor href=#_ρύθμιση_του_sliplogin></a></h5><div class=paragraph><p>Όπως αναφέρθηκε και πριν, υπάρχουν τρία αρχεία στον κατάλογο <span class=filename>/etc/sliphome</span> τα οποία χρησιμοποιούνται στη ρύθμιση του <span class=filename>/usr/sbin/sliplogin</span> (δείτε και τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a>): το <span class=filename>slip.hosts</span>, το οποίο ορίζει τους χρήστες SLIP και τις αντίστοιχες IP διευθύνσεις τους, το <span class=filename>slip.login</span> το οποίο συνήθως ρυθμίζει απλά την διεπαφή SLIP, και προαιρετικά το <span class=filename>slip.logout</span>, το οποίο αναιρεί τις αλλαγές του <span class=filename>slip.login</span> όταν τερματίσει η σειριακή σύνδεση.</p></div><div class=sect5><h6 id=_ρύθμιση_του_slip_hosts>52.7.2.4.1. Ρύθμιση του <span class=filename>slip.hosts</span><a class=anchor href=#_ρύθμιση_του_slip_hosts></a></h6><div class=paragraph><p>Το <span class=filename>/etc/sliphome/slip.hosts</span> περιέχει γραμμές με τέσσερα πεδία που χωρίζονται μεταξύ τους με κενά διαστήματα:</p></div><div class=ulist><ul><li><p>Το αναγνωριστικό εισόδου του χρήστη SLIP</p></li><li><p>Την τοπική διεύθυνση (τοπική ως προς τον εξυπηρετητή SLIP) της διασύνδεσης SLIP</p></li><li><p>Την απομακρυσμένη διεύθυνση της διασύνδεσης SLIP</p></li><li><p>Τη μάσκα του δικτύου</p></li></ul></div><div class=paragraph><p>Η τοπική και η απομακρυσμένη διεύθυνση, μπορεί να είναι ονόματα υπολογιστών (τα οποία να μετατρέπονται σε διευθύνσεις IP μέσω του <span class=filename>/etc/hosts</span> ή μέσω του DNS, ανάλογα με τις καταχωρίσεις που υπάρχουν στο αρχείο <span class=filename>/etc/nsswitch.conf</span>), και η μάσκα δικτύου μπορεί να είναι ένα όνομα το οποίο να μπορεί να διευκρινιστεί μέσω αναζήτησης στο <span class=filename>/etc/networks</span>. Σε ένα δοκιμαστικό σύστημα, το <span class=filename>/etc/sliphome/slip.hosts</span> μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# login local-addr      remote-addr     mask            opt1    opt2
#                                               (normal,compress,noicmp)
#
Shelmerg  dc-slip       sl-helmerg      0xfffffc00      autocomp</pre></div></div><div class=paragraph><p>Στο τέλος της γραμμής, βρίσκονται μια ή περισσότερες από τις παρακάτω επιλογές:</p></div><div class=ulist><ul><li><p><code>normal</code> - χωρίς συμπίεση των επικεφαλίδων</p></li><li><p><code>compress</code> - με συμπίεση των επικεφαλίδων</p></li><li><p><code>autocomp</code> - με συμπίεση των επικεφαλίδων, αν επιτρέπεται από τον απομακρυσμένο υπολογιστή</p></li><li><p><code>noicmp</code> - απενεργοποίηση των πακέτων ICMP (με τον τρόπο αυτό τα πακέτα "ping" θα απορρίπτονται αντί να καταναλώνουν το εύρος ζώνης της σύνδεσης σας)</p></li></ul></div><div class=paragraph><p>Οι επιλογές που έχετε για τις τοπικές και απομακρυσμένες διευθύνσεις των SLIP συνδέσεων σας, εξαρτώνται από το αν πρόκειται να αφιερώσετε ένα υποδίκτυο TCP/IP ή αν πρόκειται να χρησιμοποιήσετε "proxy ARP" στο SLIP εξυπηρετητή σας (δεν είναι "πραγματικό" proxy ARP, αλλά στην ενότητα αυτή περιγράφεται με αυτό τον όρο). Αν δεν είστε σίγουρος ποια μέθοδο να επιλέξετε ή πως να αποδίδετε διευθύνσεις IP, παρακαλούμε ανατρέξτε στα βιβλία του TCP/IP που αναφέρονται στις Προϋποθέσεις SLIP (<a href=#slips-prereqs>Προϋποθέσεις</a>) ή/και συμβουλευθείτε το διαχειριστή δικτύου σας.</p></div><div class=paragraph><p>Αν πρόκειται να χρησιμοποιήσετε ξεχωριστό υποδίκτυο για τους SLIP πελάτες σας, θα χρειαστεί να διαθέσετε τον αριθμό υποδικτύου από την διεύθυνση IP που σας έχει αποδοθεί και να αποδώσετε στους πελάτες SLIP διευθύνσεις που ανήκουν σε αυτό το υποδίκτυο. Έπειτα, θα χρειαστεί μάλλον να καθορίσετε μια στατική διαδρομή στο υποδίκτυο SLIP μέσω του εξυπηρετητή SLIP στον κοντινότερο σας δρομολογητή IP.</p></div><div class=paragraph><p>Διαφορετικά, αν χρησιμοποιήσετε τη μέθοδο "proxy ARP", θα χρειαστεί να αποδίδετε στους SLIP πελάτες σας διευθύνσεις IP που ανήκουν στο υποδίκτυο Ethernet στο οποίο ανήκει ο εξυπηρετητής SLIP, και θα χρειαστεί επίσης να ρυθμίσετε τα scripts <span class=filename>/etc/sliphome/slip.login</span> και <span class=filename>/etc/sliphome/slip.logout</span> να χρησιμοποιούν το <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> για να χειρίζονται τις καταχωρίσεις "proxy ARP" στον πίνακα ARP του εξυπηρετητή SLIP.</p></div></div><div class=sect5><h6 id=_ρύθμιση_του_slip_login>52.7.2.4.2. Ρύθμιση του <span class=filename>slip.login</span><a class=anchor href=#_ρύθμιση_του_slip_login></a></h6><div class=paragraph><p>Ένα τυπικό <span class=filename>/etc/sliphome/slip.login</span> μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6</pre></div></div><div class=paragraph><p>Το αρχείο <span class=filename>slip.login</span> εκτελεί απλώς το <code>ifconfig</code> για την κατάλληλη διεπαφή SLIP, με τις τοπικές και απομακρυσμένες διευθύνσεις και τη μάσκα δικτύου της διεπαφής αυτής.</p></div><div class=paragraph><p>Αν έχετε αποφασίσει να χρησιμοποιήσετε την μέθοδο "proxy ARP" (αντί να χρησιμοποιήσετε διαφορετικό υποδίκτυο για τους πελάτες SLIP), το αρχείο <span class=filename>/etc/sliphome/slip.login</span> θα μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
# Answer ARP requests for the SLIP client with our Ethernet addr
/usr/sbin/arp -s $5 00:11:22:33:44:55 pub</pre></div></div><div class=paragraph><p>Η πρόσθετη γραμμή σε αυτό το <span class=filename>slip.login</span>, η <code>arp -s $5 00:11:22:33:44:55 pub</code>, δημιουργεί μια καταχώριση ARP στον πίνακα ARP του εξυπηρετητή SLIP. Αυτή η καταχώριση ARP κάνει τον εξυπηρετητή SLIP να απαντά με την διεύθυνση Ethernet MAC όταν κάποιος άλλος κόμβος IP στο Ethernet επιθυμεί να επικοινωνήσει με την διεύθυνση IP του πελάτη SLIP.</p></div><div class=paragraph><p>Όταν χρησιμοποιείτε το παραπάνω παράδειγμα, βεβαιωθείτε ότι έχετε αντικαταστήσει την διεύθυνση MAC του Ethernet (<code>00:11:22:33:44:55</code>) με την αντίστοιχη της δικής σας κάρτας Ethernet, διαφορετικά το "proxy ARP" σίγουρα δεν θα λειτουργήσει! Μπορείτε να ανακαλύψετε τη διεύθυνση MAC του δικού σας εξυπηρετητή SLIP κοιτάζοντας τα αποτελέσματα της εντολής <code>netstat -i</code>. Η δεύτερη γραμμή της εξόδου θα μοιάζει με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ed0   1500  &lt;Link&gt;0.2.c1.28.5f.4a         191923	0   129457     0   116</code></pre></div></div><div class=paragraph><p>Αυτό δείχνει ότι στο συγκεκριμένο σύστημα η διεύθυνση MAC του Ethernet είναι <code>00:02:c1:28:5f:4a</code>. Οι τελείες στην διεύθυνση που δείχνει η <code>netstat -i</code> πρέπει να αντικατασταθούν με άνω-κάτω τελείες, και κάθε μονό δεκαεξαδικό ψηφίο πρέπει να μετατραπεί σε διπλό προσθέτοντας από μπροστά ένα μηδενικό. Η διεύθυνση μετατρέπεται με αυτό τον τρόπο σε μια μορφή που μπορεί να χρησιμοποιήσει η <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a>. Δείτε τη σελίδα manual της <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> για περισσότερες πληροφορίες σχετικά με τη χρήση της εντολής αυτής.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όταν δημιουργείτε το <span class=filename>/etc/sliphome/slip.login</span> και το <span class=filename>/etc/sliphome/slip.logout</span>, θα πρέπει να θέσετε το bit "εκτέλεσης" (π.χ. <code>chmod 755 /etc/sliphome/slip.login /etc/sliphome/slip.logout</code>), διαφορετικά η <code>sliplogin</code> δεν θα μπορεί να τα εκτελέσει.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_ρύθμιση_του_slip_logout>52.7.2.4.3. Ρύθμιση του <span class=filename>slip.logout</span><a class=anchor href=#_ρύθμιση_του_slip_logout></a></h6><div class=paragraph><p>Το <span class=filename>/etc/sliphome/slip.logout</span> δεν είναι απόλυτα απαραίτητο (εκτός αν πρόκειται να υλοποιήσετε "proxy ARP"), αλλά αν σκοπεύετε να το δημιουργήσετε, μπορείτε να χρησιμοποιήσετε ως υπόδειγμα το παρακάτω απλό παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down</pre></div></div><div class=paragraph><p>Αν χρησιμοποιείτε "proxy ARP", θα θέλετε το <span class=filename>/etc/sliphome/slip.logout</span> να διαγράφει την καταχώριση ARP του πελάτη SLIP:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
# Quit answering ARP requests for the SLIP client
/usr/sbin/arp -d $5</pre></div></div><div class=paragraph><p>Η <code>arp -d $5</code> διαγράφει την καταχώριση ARP που προστέθηκε με την εκτέλεση του <span class=filename>slip.login</span> του "proxy ARP", κατά την είσοδο του πελάτη SLIP.</p></div><div class=paragraph><p>Πρέπει να το επαναλάβουμε άλλη μια φορά: Βεβαιωθείτε ότι το <span class=filename>/etc/sliphome/slip.logout</span> έχει οριστεί ως εκτελέσιμο μετά την δημιουργία του (π.χ., <code>chmod 755 /etc/sliphome/slip.logout</code>).</p></div></div></div><div class=sect4><h5 id=_παράγοντες_που_πρέπει_να_λάβετε_υπόψη_σας_στη_δρομολόγηση>52.7.2.5. Παράγοντες που Πρέπει να Λάβετε Υπόψη σας στη Δρομολόγηση<a class=anchor href=#_παράγοντες_που_πρέπει_να_λάβετε_υπόψη_σας_στη_δρομολόγηση></a></h5><div class=paragraph><p>Αν δεν χρησιμοποιείτε την μέθοδο "proxy ARP" για να δρομολογείτε πακέτα μεταξύ των πελατών SLIP και του υπόλοιπου δικτύου σας (και ενδεχομένως και του Internet), θα πρέπει μάλλον να προσθέσετε στατικές διαδρομές προς τον πλησιέστερο σας προεπιλεγμένο δρομολογητή για να δρομολογείτε το υποδίκτυο των SLIP πελατών σας διαμέσου του εξυπηρετητή SLIP.</p></div><div class=sect5><h6 id=_στατικές_διαδρομές>52.7.2.5.1. Στατικές Διαδρομές<a class=anchor href=#_στατικές_διαδρομές></a></h6><div class=paragraph><p>Η προσθήκη στατικών διαδρομών προς τους πλησιέστερους σας προεπιλεγμένους δρομολογητές, μπορεί να είναι προβληματική (ή και αδύνατη αν δεν έχετε τα κατάλληλα δικαιώματα πρόσβασης). Αν η εταιρία σας διαθέτει δίκτυο με πολλαπλούς δρομολογητές, κάποια μοντέλα (π.χ. από την Cisco και την Proteon), εκτός ότι πρέπει να ρυθμιστούν με την στατική διαδρομή προς το υποδίκτυο SLIP, πρέπει επίσης να ρυθμιστούν με τις στατικές διαδρομές που θα αναφέρουν στους άλλους δρομολογητές. Θα χρειαστεί να πειραματιστείτε και να δοκιμάσετε διάφορες ρυθμίσεις για να δουλέψει η δρομολόγηση μέσω στατικών διαδρομών.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=mail>Chapter 53. Ηλεκτρονικό Ταχυδρομείο<a class=anchor href=#mail></a></h2><div class=sectionbody><div class=sect2><h3 id=mail-synopsis>53.1. Σύνοψη<a class=anchor href=#mail-synopsis></a></h3><div class=paragraph><p>Το "ηλεκτρονικό ταχυδρομείο", ευρύτερα γνωστό ως email, είναι στις μέρες μας μια από τις πλέον διαδεδομένες μορφές επικοινωνίας. Το κεφάλαιο αυτό παρέχει μια βασική εισαγωγή στη λειτουργία ενός διακομιστή email στο FreeBSD, καθώς και μια εισαγωγή στη διαδικασία αποστολής και λήψης email στο FreeBSD. Ωστόσο η αναφορά αυτή δεν πρέπει να θεωρηθεί πλήρης, καθώς υπάρχουν ακόμα αρκετοί παράγοντες που πρέπει να ληφθούν υπόψιν και έχουν εδώ παραλειφθεί. Για πιο πλήρη ανάλυση του θέματος, ο αναγνώστης παραπέμπεται στα πολλά εξαιρετικά βιβλία που αναφέρονται στο <a href=./#bibliography>Βιβλιογραφία</a>.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Το λογισμικό που χρησιμοποιείται στην αποστολή και λήψη ηλεκτρονικού ταχυδρομείου.</p></li><li><p>Που βρίσκονται τα βασικά αρχεία ρυθμίσεων του sendmail στο FreeBSD.</p></li><li><p>Τη διαφορά μεταξύ απομακρυσμένων και τοπικών θυρίδων ταχυδρομείου (mailboxes).</p></li><li><p>Πως να εμποδίσετε ανεπιθύμητους spammers από το να χρησιμοποιήσουν τον δικό σας εξυπηρετητή email ως αναμεταδότη.</p></li><li><p>Πως να εγκαταστήσετε και να ρυθμίσετε ένα εναλλακτικό Αντιπρόσωπο Μεταφοράς Ταχυδρομείου (Mail Transfer Agent) στο σύστημα σας, αντικαθιστώντας έτσι το sendmail.</p></li><li><p>Πως να αντιμετωπίσετε συνηθισμένα προβλήματα στον διακομιστή ταχυδρομείου.</p></li><li><p>Πως να χρησιμοποιήσετε το SMTP με το UUCP.</p></li><li><p>Πως να ρυθμίσετε το σύστημα σας μόνο για αποστολή email.</p></li><li><p>Πως να χρησιμοποιήσετε το email μέσω επιλογικής (dialup) σύνδεσης.</p></li><li><p>Πως να ρυθμίσετε πιστοποίηση αυθεντικότητας στο SMTP για πρόσθετη ασφάλεια.</p></li><li><p>Πως να εγκαταστήσετε και να χρησιμοποιήσετε μια εφαρμογή αποστολής και λήψης email για χρήστες, όπως το mutt.</p></li><li><p>Πως να κατεβάσετε το email σας από ένα απομακρυσμένο διακομιστή POP ή IMAP.</p></li><li><p>Πως να εφαρμόσετε φίλτρα και κανόνες στην εισερχόμενη αλληλογραφία σας, με αυτόματο τρόπο.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να ρυθμίσετε σωστά τη σύνδεση του δικτύου σας (<a href=./#advanced-networking>Προχωρημένα Θέματα Δικτύωσης</a>).</p></li><li><p>Να ρυθμίσετε σωστά τις πληροφορίες DNS για τον διακομιστή αλληλογραφίας σας (<a href=./#network-servers>Εξυπηρετητές Δικτύου</a>).</p></li><li><p>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=mail-using>53.2. Χρησιμοποιώντας το Ηλεκτρονικό Ταχυδρομείο<a class=anchor href=#mail-using></a></h3><div class=paragraph><p>Σε κάθε ανταλλαγή ηλεκτρονικού ταχυδρομείου, συνεργάζονται πέντε βασικά τμήματα: Το <a href=#mail-mua>πρόγραμμα χρήστη</a>, ο <a href=#mail-mta>δαίμονας του εξυπηρετητή</a>, το <a href=#mail-dns>DNS</a>, μια <a href=#mail-receive>απομακρυσμένη ή τοπική θυρίδα ταχυδρομείου (mailbox)</a> και φυσικά ο <a href=#mail-host>υπολογιστής που διαχειρίζεται το email (mailhost)</a>.</p></div><div class=sect3><h4 id=mail-mua>53.2.1. Το Πρόγραμμα Χρήστη<a class=anchor href=#mail-mua></a></h4><div class=paragraph><p>Η κατηγορία αυτή περιλαμβάνει προγράμματα όπως τα mutt, alpine, elm, και <code>mail</code>, καθώς και προγράμματα που διαθέτουν GUI όπως είναι τα balsa, xfmail (για να δώσουμε μερικά παραδείγματα) και κάποια πιο "εξελιγμένα" όπως είναι οι φυλλομετρητές για το WWW. Τα προγράμματα αυτά, απλώς μεταβιβάζουν τις συναλλαγές ταχυδρομείου στον τοπικό <a href=#mail-host>"mailhost"</a>, είτε καλώντας κάποιον από τους <a href=#mail-mta>δαίμονες του εξυπηρετητή</a> που είναι διαθέσιμοι, ή παραδίδοντας τις απευθείας μέσω TCP.</p></div></div><div class=sect3><h4 id=mail-mta>53.2.2. Δαίμονας Εξυπηρετητή Mailhost<a class=anchor href=#mail-mta></a></h4><div class=paragraph><p>Το FreeBSD έρχεται με το sendmail εγκατεστημένο από προεπιλογή, αλλά υποστηρίζει επίσης και μεγάλο αριθμό από άλλους δαίμονες ταχυδρομείου, περιλαμβανομένων και των:</p></div><div class=ulist><ul><li><p>exim</p></li><li><p>postfix</p></li><li><p>qmail</p></li></ul></div><div class=paragraph><p>Ο δαίμονας έχει συνήθως δύο λειτουργίες-είναι υπεύθυνος για τη λήψη εισερχόμενου mail, όπως επίσης και την παράδοση του εξερχόμενου mail. Όμως, <em>δεν είναι</em> υπεύθυνος για τη συλλογή του mail με τη χρήση πρωτοκόλλων όπως τα POP ή IMAP για την ανάγνωση του ταχυδρομείου σας, ούτε επιτρέπει τη σύνδεση στις τοπικές θυρίδες τύπου <span class=filename>mbox</span> ή Maildir. Πιθανόν να χρειαστείτε κάποιο επιπρόσθετο <a href=#mail-receive>δαίμονα</a> για αυτό το σκοπό.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Παλιότερες εκδόσεις του sendmail έχουν κάποια σοβαρά προβλήματα ασφαλείας, μέσω των οποίων μπορεί κάποιος εισβολέας να αποκτήσει τοπική ή απομακρυσμένη πρόσβαση στο μηχάνημα σας. Για να αποφύγετε προβλήματα τέτοιου είδους, βεβαιωθείτε ότι χρησιμοποιείτε κάποια πρόσφατη έκδοση. Εναλλακτικά, μπορείτε να εγκαταστήσετε κάποιο άλλο MTA από την <a href=./#ports>Συλλογή των Ports του FreeBSD</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mail-dns>53.2.3. Email και DNS<a class=anchor href=#mail-dns></a></h4><div class=paragraph><p>Το Σύστημα Ονομασίας Περιοχών (DNS) και ο δαίμονας του, ο <code>named</code>, έχουν σημαντικό ρόλο στην παράδοση του email. Για την παράδοση του email από το ένα site σε ένα άλλο, ο δαίμονας του εξυπηρετητή θα ψάξει για το απομακρυσμένο site στο DNS, για να καθορίσει ποιος υπολογιστής λαμβάνει το email για το συγκεκριμένο προορισμό. Η διαδικασία αυτή συμβαίνει επίσης όταν ο δικός σας εξυπηρετητής λαμβάνει email από κάποιο απομακρυσμένο υπολογιστή.</p></div><div class=paragraph><p>Το DNS είναι υπεύθυνο για την αντιστοίχηση ονομάτων υπολογιστών σε διευθύνσεις IP, όπως και για την αποθήκευση πληροφοριών που σχετίζονται με την παράδοση ηλεκτρονικού ταχυδρομείου, όπως οι εγγραφές MX. Η εγγραφή MX (Mail Exchanger) αναγνωρίζει ποιος υπολογιστής (ή υπολογιστές) θα είναι υπεύθυνος για τη λήψη ταχυδρομείου ενός συγκεκριμένου τομέα (domain). Αν δεν έχετε εγγραφή MX για τον υπολογιστή ή τον τομέα σας, το email θα παραδίδεται απευθείας στον υπολογιστή σας, με την προϋπόθεσή ότι έχετε εγγραφή τύπου A που να δείχνει στον υπολογιστή σας ή στην IP διεύθυνση του.</p></div><div class=paragraph><p>Μπορείτε να δείτε τις εγγραφές MX για οποιοδήποτε τομέα, χρησιμοποιώντας την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=host&amp;sektion=1&amp;format=html">host(1)</a>, όπως φαίνεται στο παρακάτω παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% host <span class=nt>-t</span> mx FreeBSD.org
FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by mx1.FreeBSD.org</code></pre></div></div></div><div class=sect3><h4 id=mail-receive>53.2.4. Λαμβάνοντας Mail<a class=anchor href=#mail-receive></a></h4><div class=paragraph><p>Ο mailhost είναι υπεύθυνος για την λήψη mail που προορίζεται για τον τομέα σας. Θα συλλέξει όλο το mail που έρχεται προς τον τομέα, και θα το αποθηκεύσει είτε στο <span class=filename>mbox</span> (την προεπιλεγμένη μέθοδο για αποθήκευση mail) ή σε μορφή Maildir, ανάλογα με τις ρυθμίσεις που έχετε κάνει. Από τη στιγμή που το mail έχει αποθηκευθεί, μπορείτε είτε να το διαβάσετε τοπικά, χρησιμοποιώντας εφαρμογές όπως το <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> ή το mutt, ή να το δείτε μέσω απομακρυσμένης σύνδεσης, χρησιμοποιώντας κάποιο πρωτόκολλο όπως το POP ή το IMAP. Αυτό σημαίνει ότι αν επιθυμείτε να διαβάζετε το mail σας μόνο τοπικά, δεν χρειάζεται να εγκαταστήσετε εξυπηρετητή POP ή IMAP.</p></div><div class=sect4><h5 id=pop-and-imap>53.2.4.1. Πρόσβαση σε Απομακρυσμένες Θυρίδες μέσω POP και IMAP<a class=anchor href=#pop-and-imap></a></h5><div class=paragraph><p>Για να έχετε απομακρυσμένη πρόσβαση στις θυρίδες ταχυδρομείου, είναι απαραίτητο να έχετε πρόσβαση σε ένα εξυπηρετητή POP ή IMAP. Τα πρωτόκολλα αυτά, επιτρέπουν στους χρήστες να συνδέονται στις θυρίδες τους από απόσταση, με μεγάλη ευκολία. Και τα δύο πρωτόκολλα (POP και IMAP) επιτρέπουν στους χρήστες απομακρυσμένη πρόσβαση στις θυρίδες τους, αλλά το IMAP προσφέρει αρκετά πλεονεκτήματα, ορισμένα από τα οποία φαίνονται παρακάτω:</p></div><div class=ulist><ul><li><p>Το IMAP μπορεί να αποθηκεύσει μηνύματα σε ένα απομακρυσμένο εξυπηρετητή, όπως επίσης και να τα ανακτήσει.</p></li><li><p>Το IMAP υποστηρίζει ταυτόχρονες ενημερώσεις.</p></li><li><p>Το IMAP μπορεί να φανεί εξαιρετικά χρήσιμο σε συνδέσεις χαμηλής ταχύτητας, καθώς επιτρέπει στους χρήστες να κατεβάσουν τη δομή των μηνυμάτων, χωρίς να κατεβάσουν το περιεχόμενο τους. Μπορεί επίσης να εκτελέσει εργασίες όπως εύρεση μηνυμάτων απευθείας στον εξυπηρετητή, ελαχιστοποιώντας με αυτό τον τρόπο τη μεταφορά δεδομένων μεταξύ των πελατών και των εξυπηρετητών.</p></li></ul></div><div class=paragraph><p>Για να εγκαταστήσετε ένα εξυπηρετητή POP ή IMAP θα πρέπει να ακολουθήσετε τα επόμενα βήματα:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Επιλέξτε ένα εξυπηρετητή IMAP ή POP που να εξυπηρετεί τις ανάγκες σας. Οι παρακάτω εξυπηρετητές POP και IMAP είναι αρκετά διαδεδομένοι και αποτελούν καλά παραδείγματα:</p><div class=ulist><ul><li><p>qpopper</p></li><li><p>teapop</p></li><li><p>imap-uw</p></li><li><p>courier-imap</p></li><li><p>dovecot</p></li></ul></div></li><li><p>Εγκαταστήστε το δαίμονα POP ή IMAP της επιλογής σας, από την Συλλογή των Ports.</p></li><li><p>Αν χρειάζεται, τροποποιήστε το αρχείο <span class=filename>/etc/inetd.conf</span> για να φορτώσετε τον εξυπηρετητή POP ή IMAP.</p></li></ol></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Θα πρέπει να σημειώσουμε ότι τόσο το POP όσο και το IMAP μεταδίδουν πληροφορίες όπως το όνομα χρήστη και τον κωδικό σε μορφή απλού κειμένου. Αυτό σημαίνει ότι αν θέλετε να ασφαλίσετε τη μετάδοση πληροφοριών μέσω αυτών των πρωτοκόλλων, θα πρέπει να περάσετε αυτές τις συνδέσεις μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> (tunneling) ή να χρησιμοποιήσετε SSL. Η διαδικασία tunneling περιγράφεται με λεπτομέρεια στο <a href=./#security-ssh-tunneling>SSH Tunneling</a> και το SSL στο <a href=./#openssl>OpenSSL</a>.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=local>53.2.4.2. Πρόσβαση σε Τοπικές Θυρίδες Ταχυδρομείου<a class=anchor href=#local></a></h5><div class=paragraph><p>Μπορείτε να έχετε τοπική πρόσβαση στις θυρίδες ταχυδρομείου χρησιμοποιώντας απευθείας κάποιο πρόγραμμα αποστολής/λήψης (MUA) στον εξυπηρετητή που είναι αποθηκευμένες. Κατάλληλες εφαρμογές για αυτό το σκοπό είναι π.χ. το mutt ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>.</p></div></div></div><div class=sect3><h4 id=mail-host>53.2.5. Ο Εξυπηρετητής Mail<a class=anchor href=#mail-host></a></h4><div class=paragraph><p>Εξυπηρετητής mail θεωρείται ο υπολογιστής ο οποίος είναι υπεύθυνος για την παράδοση και λήψη mail για τον υπολογιστή σας, και ενδεχομένως για το δίκτυο σας.</p></div></div></div><div class=sect2><h3 id=sendmail>53.3. Ρύθμιση του sendmail<a class=anchor href=#sendmail></a></h3><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> είναι ο προεπιλεγμένος Αντιπρόσωπος Μεταφοράς Ταχυδρομείου (Mail Transfer Agent, MTA) στο FreeBSD. Δουλειά του είναι να δέχεται το email από τους Αντιπροσώπους Email Χρήστη (Mail User Agents, MUA) και να το παραδίδει στο κατάλληλο mailer που ορίζεται στο αρχείο ρυθμίσεων του. Το sendmail μπορεί επίσης να δεχθεί συνδέσεις δικτύου και να παραδώσει το mail σε τοπικές θυρίδες ή και σε κάποιο άλλο πρόγραμμα.</p></div><div class=paragraph><p>Το sendmail χρησιμοποιεί τα ακόλουθα αρχεία ρυθμίσεων:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Όνομα Αρχείου</th><th class="tableblock halign-left valign-top">Λειτουργία</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/access</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Η βάση δεδομένων πρόσβασης του sendmail.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/aliases</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Παρωνύμια (aliases) για τις θυρίδες (Mailboxes)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/local-host-names</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Λίστα των υπολογιστών για τους οποίους το sendmail δέχεται mail</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailer.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ρυθμίσεις του προγράμματος mailer</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Πίνακας παραδόσεων του mailer</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/sendmail.cf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το κεντρικό αρχείο ρυθμίσεων του sendmail</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/virtusertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Πίνακας εικονικών χρηστών και περιοχών (domains)</p></td></tr></tbody></table><div class=sect3><h4 id=_etcmailaccess>53.3.1. <span class=filename>/etc/mail/access</span><a class=anchor href=#_etcmailaccess></a></h4><div class=paragraph><p>Η βάση δεδομένων πρόσβασης καθορίζει ποιοι υπολογιστές ή διευθύνσεις IP έχουν πρόσβαση στον τοπικό εξυπηρετητή mail και τι είδους πρόσβαση έχουν. Η καταχώρηση ενός υπολογιστή μπορεί να έχει τις επιλογές <code>OK</code>, <code>REJECT</code>, <code>RELAY</code> ή απλά να μεταβιβάζει τον έλεγχο στη ρουτίνα διαχείρισης λαθών του sendmail με κάποιο συγκεκριμένο σφάλμα. Οι υπολογιστές που είναι καταχωρημένοι με την επιλογή <code>OK</code>, η οποία είναι και η προεπιλεγμένη, επιτρέπεται να στείλουν email σε αυτό τον υπολογιστή, εφόσον ο τελικός προορισμός του μηνύματος είναι το τοπικό μηχάνημα. Οι υπολογιστές που είναι καταχωρημένοι με την επιλογή <code>REJECT</code> απορρίπτονται για οποιαδήποτε επικοινωνία έχει να κάνει με μετάδοση mail. Οι υπολογιστές που είναι καταχωρημένοι με την επιλογή <code>RELAY</code>, έχουν τη δυνατότητα να στείλουν mail προς οποιαδήποτε κατεύθυνση μέσω του συγκεκριμένου εξυπηρετητή.</p></div><div class=exampleblock><div class=title>Παράδειγμα 21. Ρύθμιση της Βάσης Δεδομένων Πρόσβασης του sendmail</div><div class=content><div class="literalblock programlisting"><div class=content><pre>cyberspammer.com                550 We do not accept mail from spammers
FREE.STEALTH.MAILER@            550 We do not accept mail from spammers
another.source.of.spam          REJECT
okay.cyberspammer.com           OK
128.32                          RELAY</pre></div></div></div></div><div class=paragraph><p>Σε αυτό το παράδειγμα έχουμε πέντε καταχωρήσεις. Οι διευθύνσεις που φαίνονται στην αριστερή πλευρά του πίνακα, επηρεάζονται από τη ενέργεια που φαίνεται στη δεξιά πλευρά. Τα πρώτα δύο παραδείγματα, επιστρέφουν ένα κωδικό σφάλματος στη ρουτίνα διαχείρισης λαθών του sendmail. Το μήνυμα εκτυπώνεται στον απομακρυσμένο υπολογιστή, όταν το mail που λαμβάνεται ανήκει σε κάποια από τις κατηγορίες της αριστερής πλευράς του πίνακα. Η επόμενη καταχώρηση απορρίπτει την παραλαβή mail από ένα συγκεκριμένο υπολογιστή στο Internet, τον <code>another.source.of.spam</code>. Η επόμενη καταχώρηση κάνει δεκτές τις συνδέσεις mail από τον υπολογιστή <code>okay.cyberspammer.com</code>, το όνομα του οποίου προσδιορίζεται ακριβέστερα σε σχέση με τη γραμμή <code>cyberspammer.com</code> που είδαμε παραπάνω. Γραμμές που καθορίζουν ονόματα με μεγαλύτερη ακρίβεια, έχουν προτεραιότητα σε σχέση με πιο ανακριβείς. Η τελευταία καταχώρηση επιτρέπει την αναμετάδοση (relaying) ηλεκτρονικού ταχυδρομείου από υπολογιστές με διευθύνσεις IP που ξεκινάνε με <code>128.32</code>. Οι υπολογιστές αυτοί, μπορούν να στείλουν mail μέσω του συγκεκριμένου εξυπηρετητή, το οποίο να κατευθύνεται σε άλλους εξυπηρετητές ταχυδρομείου.</p></div><div class=paragraph><p>Σε περίπτωση ανανέωσης αυτού του αρχείου, θα πρέπει να εκτελέσετε την εντολή <code>make</code> στον κατάλογο <span class=filename>/etc/mail/</span> για να ανανεώσετε τη βάση δεδομένων.</p></div></div><div class=sect3><h4 id=_etcmailaliases>53.3.2. <span class=filename>/etc/mail/aliases</span><a class=anchor href=#_etcmailaliases></a></h4><div class=paragraph><p>Η βάση δεδομένων των παρωνυμίων (aliases), περιέχει μια λίστα από εικονικές θυρίδες ταχυδρομείου που επεκτείνονται σε άλλους χρήστες, αρχεία ή και άλλα παρωνύμια. Μερικά παραδείγματα χρήσης του <span class=filename>/etc/mail/aliases</span> φαίνονται παρακάτω:</p></div><div class=exampleblock><div class=title>Παράδειγμα 22. Παρωνύμια Mail</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre></div></div></div></div><div class=paragraph><p>Η μορφή του αρχείου είναι απλή. Το όνομα της θυρίδας βρίσκεται στην αριστερή πλευρά της άνω-κάτω τελείας, και επεκτείνεται στον προορισμό που βρίσκεται στη δεξιά πλευρά. Το πρώτο παράδειγμα, ορίζει ότι η θυρίδα του χρήστη <code>root</code> θα είναι στην πραγματικότητα η θυρίδα <code>localuser</code>. Για την θυρίδα αυτή, γίνεται ξανά αναζήτηση στη βάση δεδομένων των παρωνυμιών. Αν δεν βρεθεί άλλο όνομα που να ταιριάζει, το μήνυμα θα παραδοθεί στον τοπικό χρήστη <code>localuser</code>. Το επόμενο παράδειγμα δείχνει μια λίστα ταχυδρομείου. Τα μηνύματα που απευθύνονται στη θυρίδα <code>ftp-bugs</code>, κατευθύνονται σε τρεις τοπικές θυρίδες, τις <code>joe</code>, <code>eric</code> και <code>paul</code>. Σημειώστε ότι είναι δυνατόν να καθοριστεί μια απομακρυσμένη θυρίδα χρησιμοποιώντας τη μορφή <a href=mailto:user@example.com>user@example.com</a>. Το επόμενο παράδειγμα, δείχνει πως μπορεί να γίνει εγγραφή του mail σε ένα αρχείο, στη συγκεκριμένη περίπτωση το <span class=filename>/dev/null</span>. Το τελευταίο παράδειγμα, δείχνει πως γίνεται η αποστολή mail προς ένα πρόγραμμα. Στο παράδειγμα αυτό, το μήνυμα γράφεται στην τυποποιημένη είσοδο (standard input) του προγράμματος <span class=filename>/usr/local/bin/procmail</span> χρησιμοποιώντας ένα UNIX® pipe.</p></div><div class=paragraph><p>Κάθε φορά που γίνεται ενημέρωση αυτού του αρχείου, θα πρέπει να εκτελείτε την εντολή <code>make</code> στον κατάλογο <span class=filename>/etc/mail/</span>, ώστε να ενημερωθεί η βάση δεδομένων.</p></div></div><div class=sect3><h4 id=_etcmaillocal_host_names>53.3.3. <span class=filename>/etc/mail/local-host-names</span><a class=anchor href=#_etcmaillocal_host_names></a></h4><div class=paragraph><p>Πρόκειται για μια λίστα από ονόματα υπολογιστών, την οποία το <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> θα δέχεται ως ονόματα για το τοπικό μηχάνημα. Τοποθετήστε σε αυτήν τα ονόματα των υπολογιστών ή των τομέων για τους οποίους θέλετε το sendmail να λαμβάνει mail. Για παράδειγμα, αν ο συγκεκριμένος εξυπηρετητής mail πρόκειται να λαμβάνει mail για τον τομέα <code>example.com</code> και για τον υπολογιστή <code>mail.example.com</code>, το αρχείο <span class=filename>local-host-names</span> θα μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>example.com
mail.example.com</pre></div></div><div class=paragraph><p>Κάθε φορά που ενημερώνεται αυτό το αρχείο, θα πρέπει να γίνεται επανεκκίνηση του <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> για να διαβάσει τις αλλαγές.</p></div></div><div class=sect3><h4 id=_etcmailsendmail_cf>53.3.4. <span class=filename>/etc/mail/sendmail.cf</span><a class=anchor href=#_etcmailsendmail_cf></a></h4><div class=paragraph><p>Το <span class=filename>sendmail.cf</span> είναι το κεντρικό αρχείο ρυθμίσεων του sendmail. Το αρχείο αυτό ρυθμίζει τη συνολική συμπεριφορά του sendmail, που περιλαμβάνει μεταξύ άλλων την επανεγγραφή διευθύνσεων και την αποστολή μηνυμάτων απόρριψης προς απομακρυσμένους εξυπηρετητές mail. Καθώς το αρχείο αυτό περιέχει τόσο διαφορετικές ρυθμίσεις, είναι φυσικό να είναι αρκετά πολύπλοκο και οι λεπτομέρειες του είναι έξω από το σκοπό αυτής της ενότητας. Ευτυχώς, αυτό το αρχείο σπάνια χρειάζεται να αλλαχθεί σε τυπικούς εξυπηρετητές mail.</p></div><div class=paragraph><p>Το βασικό αρχείο ρυθμίσεων του sendmail μπορεί να παραχθεί με τη βοήθεια μακροεντολών τύπου <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> που καθορίζουν τη συμπεριφορά και τα χαρακτηριστικά του sendmail. Για περισσότερες πληροφορίες, παρακαλούμε διαβάστε το <span class=filename>/usr/src/contrib/sendmail/cf/README</span>.</p></div><div class=paragraph><p>Για να ισχύσουν οι αλλαγές που κάνετε σε αυτό το αρχείο, θα πρέπει να επανεκκινήσετε το sendmail.</p></div></div><div class=sect3><h4 id=_etcmailvirtusertable>53.3.5. <span class=filename>/etc/mail/virtusertable</span><a class=anchor href=#_etcmailvirtusertable></a></h4><div class=paragraph><p>Το αρχείο <span class=filename>virtusertable</span> αντιστοιχεί διευθύνσεις mail εικονικών τομέων σε πραγματικές θυρίδες ταχυδρομείου. Οι θυρίδες αυτές μπορεί να είναι τοπικές, απομακρυσμένες, παρωνύμια που έχουν οριστεί στο <span class=filename>/etc/mail/aliases</span>, ή αρχεία.</p></div><div class=exampleblock><div class=title>Παράδειγμα 23. Παράδειγμα Αντιστοίχησης Mail Εικονικού Τομέα</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe</pre></div></div></div></div><div class=paragraph><p>Στο παραπάνω παράδειγμα, έχουμε μια αντιστοίχηση για τον τομέα <code>example.com</code>. Η επεξεργασία αυτού του αρχείου γίνεται από πάνω προς τα κάτω, και σταματάει στην εύρεση του πρώτου ονόματος που ταιριάζει. Η πρώτη γραμμή του παραδείγματος, αντιστοιχεί το <a href=mailto:root@example.com>root@example.com</a> στην τοπική θυρίδα <code>root</code>. Η επόμενη καταχώρηση αντιστοιχεί το <a href=mailto:postmaster@example.com>postmaster@example.com</a> στη θυρίδα <code>postmaster</code> στον υπολογιστή <code>noc.example.net</code>. Τέλος, αν δεν βρεθεί καμιά αντιστοίχηση για τον τομέα <code>example.com</code>, θα εφαρμοστεί η τελευταία αντιστοίχηση, η οποία ταιριάζει με οποιοδήποτε mail σταλθεί προς τον τομέα <code>example.com</code>. Στην περίπτωση αυτή, το μήνυμα θα παραδοθεί στην τοπική θυρίδα <code>joe</code>.</p></div></div></div><div class=sect2><h3 id=mail-changingmta>53.4. Αλλάζοντας τον Αντιπρόσωπο Μεταφοράς Ταχυδρομείου (MTA)<a class=anchor href=#mail-changingmta></a></h3><div class=paragraph><p>Όπως έχουμε ήδη αναφέρει, το FreeBSD έρχεται με το sendmail προεγκατεστημένο ως Αντιπρόσωπο Μεταφοράς Ταχυδρομείου (Mail Transfer Agent, MTA). Το πρόγραμμα αυτό είναι από προεπιλογή υπεύθυνο για την εισερχόμενη και εξερχόμενη αλληλογραφία.</p></div><div class=paragraph><p>Υπάρχει ωστόσο πληθώρα λόγων για τους οποίους κάποιοι διαχειριστές επιλέγουν να αλλάξουν το MTA του συστήματος τους. Οι λόγοι αυτοί κυμαίνονται από το ότι απλά θέλουν να δοκιμάσουν κάποιο άλλο MTA, ως και το ότι χρειάζονται κάποιο ιδιαίτερο χαρακτηριστικό ή δυνατότητα που υπάρχει σε κάποιο άλλο mailer. Ευτυχώς, το FreeBSD κάνει εύκολη την αλλαγή του αντιπροσώπου.</p></div><div class=sect3><h4 id=_εγκαταστήστε_νέο_mta>53.4.1. Εγκαταστήστε Νέο MTA<a class=anchor href=#_εγκαταστήστε_νέο_mta></a></h4><div class=paragraph><p>Υπάρχουν αρκετοί MTA για να επιλέξετε. Ένα καλό σημείο εκκίνησης είναι η <a href=./#ports>Συλλογή των Ports του FreeBSD</a> όπου και θα μπορέσετε να βρείτε αρκετούς. Φυσικά είστε ελεύθερος να επιλέξετε όποιο MTA θέλετε από οπουδήποτε, όσο τουλάχιστον μπορείτε να το κάνετε να εκτελείτε στο FreeBSD.</p></div><div class=paragraph><p>Ξεκινήστε εγκαθιστώντας το νέο σας MTA. Μετά την εγκατάσταση, θα έχετε την ευκαιρία να αποφασίσετε αν πραγματικά καλύπτει τις ανάγκες σας, καθώς και να ολοκληρώσετε τις ρυθμίσεις του πριν μεταφέρετε τη διαχείριση mail του συστήματος από το sendmail στο νέο σας πρόγραμμα. Κατά την εγκατάσταση, βεβαιωθείτε ότι το νέο σας λογισμικό δεν θα προσπαθήσει να εγκατασταθεί πάνω στα υπάρχοντα εκτελέσιμα του συστήματος, όπως το <span class=filename>/usr/bin/sendmail</span>. Διαφορετικά, θα έχετε ουσιαστικά βάλει το νέο σας λογισμικό mail σε χρήση, πριν προλάβετε καλά-καλά να το ρυθμίσετε.</p></div><div class=paragraph><p>Παρακαλούμε να διαβάσετε την τεκμηρίωση του MTA που επιλέξατε, για πληροφορίες σχετικά με τη ρύθμιση του.</p></div></div><div class=sect3><h4 id=mail-disable-sendmail>53.4.2. Απενεργοποιήστε το sendmail<a class=anchor href=#mail-disable-sendmail></a></h4><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Αν απενεργοποιήσετε τη δυνατότητα αποστολής (εξερχόμενα) του sendmail, είναι σημαντικό να την αντικαταστήσετε με ένα εναλλακτικό σύστημα παράδοσης mail. Αν επιλέξετε να μην κάνετε το παραπάνω, τα μηνύματα του συστήματος, όπως αυτά που παράγονται από το <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>, δεν θα μπορούν να παραδοθούν μέσω email, όπως είναι το αναμενόμενο. Πολλά τμήματα του συστήματος σας αναμένουν ότι υπάρχει σε λειτουργία ένα σύστημα συμβατό με το sendmail. Αν οι εφαρμογές συνεχίζουν να χρησιμοποιούν τα εκτελέσιμα του sendmail προσπαθώντας να στείλουν email μετά την απενεργοποίηση του, το mail πιθανώς θα βρεθεί σε μια ανενεργή ουρά του sendmail και δεν θα παραδοθεί ποτέ.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να απενεργοποιήσετε εντελώς το sendmail, συμπεριλαμβανομένης και της υπηρεσίας εξερχόμενων μηνυμάτων, χρησιμοποιήστε:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;
sendmail_submit_enable=&#34;NO&#34;
sendmail_outbound_enable=&#34;NO&#34;
sendmail_msp_queue_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>στο <span class=filename>/etc/rc.conf.</span></p></div><div class=paragraph><p>Αν θέλετε να απενεργοποιήσετε μόνο την υπηρεσία εισερχομένων του sendmail θα πρέπει να θέσετε:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>στο <span class=filename>/etc/rc.conf</span>. Περισσότερες πληροφορίες για τις επιλογές εκκίνησης του sendmail, διατίθενται από την αντίστοιχη σελίδα manual, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.sendmail&amp;sektion=8&amp;format=html">rc.sendmail(8)</a>.</p></div></div><div class=sect3><h4 id=_εκκίνηση_του_νέου_σας_mta_κατά_την_εκκίνηση>53.4.3. Εκκίνηση του Νέου σας MTA κατά την Εκκίνηση<a class=anchor href=#_εκκίνηση_του_νέου_σας_mta_κατά_την_εκκίνηση></a></h4><div class=paragraph><p>Το νέο σας MTA θα ξεκινάει κατά την εκκίνηση, αν προσθέσετε μια κατάλληλη γραμμή στο αρχείο <span class=filename>/etc/rc.conf</span>. Δείτε το παρακάτω παράδειγμα για το postfix:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;postfix_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Το MTA θα ξεκινάει πλέον κατά την εκκίνηση.</p></div></div><div class=sect3><h4 id=_αντικαθιστώντας_το_sendmail_από_προεπιλεγμένο_mailer_συστήματος>53.4.4. Αντικαθιστώντας το sendmail από Προεπιλεγμένο Mailer Συστήματος<a class=anchor href=#_αντικαθιστώντας_το_sendmail_από_προεπιλεγμένο_mailer_συστήματος></a></h4><div class=paragraph><p>Το sendmail είναι τόσο γνωστό ως στάνταρ λογισμικό στα συστήματα UNIX®, ώστε πολλά άλλα προγράμματα θεωρούν ότι είναι ήδη εγκατεστημένο και ρυθμισμένο. Για το λόγο αυτό, πολλά εναλλακτικά MTA παρέχουν δικές τους συμβατές υλοποιήσεις του sendmail. Οι υλοποιήσεις αυτές παρέχουν παρόμοιο σύνολο εντολών, και μπορούν έτσι να χρησιμοποιηθούν ώστε να αντικαταστήσουν "απευθείας" το sendmail.</p></div><div class=paragraph><p>Για το λόγο αυτό, αν χρησιμοποιείτε κάποιο εναλλακτικό mailer, θα θέλετε να εξασφαλίσετε ότι άλλα προγράμματα που προσπαθούν να εκτελέσουν τα τυπικά εκτελέσιμα του sendmail όπως το <span class=filename>/usr/bin/sendmail</span>, θα εκτελέσουν στην πραγματικότητα τον επιλεγμένο σας mailer. Ευτυχώς, το FreeBSD παρέχει ένα σύστημα που καλείτε <a href="https://man.freebsd.org/cgi/man.cgi?query=mailwrapper&amp;sektion=8&amp;format=html">mailwrapper(8)</a> και το οποίο αναλαμβάνει αυτή τη δουλειά για σας.</p></div><div class=paragraph><p>Όταν το sendmail λειτουργεί όπως έχει εγκατασταθεί αρχικά, θα βρείτε κάτι όπως το παρακάτω στο <span class=filename>/etc/mail/mailer.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail	 /usr/libexec/sendmail/sendmail
send-mail	/usr/libexec/sendmail/sendmail
mailq		/usr/libexec/sendmail/sendmail
newaliases	/usr/libexec/sendmail/sendmail
hoststat	/usr/libexec/sendmail/sendmail
purgestat	/usr/libexec/sendmail/sendmail</pre></div></div><div class=paragraph><p>Αυτό σημαίνει ότι όταν εκτελείται κάποια από αυτές τις συνηθισμένες εντολές (όπως το ίδιο το <span class=filename>sendmail</span>), το σύστημα στην πραγματικότητα εκτελεί ένα αντίγραφο του mailwrapper που ονομάζεται <span class=filename>sendmail</span>, και το οποίο ελέγχει το <span class=filename>mailer.conf</span> και εκτελεί το <span class=filename>/usr/libexec/sendmail/sendmail</span> αντί αυτού. Το σύστημα αυτό διευκολύνει ιδιαίτερα την αλλαγή των εκτελέσιμων που εκτελούνται στην πραγματικότητα όταν γίνεται κλήση των προεπιλεγμένων λειτουργιών του <span class=filename>sendmail</span>.</p></div><div class=paragraph><p>Έτσι, αν θέλετε να εκτελείται το <span class=filename>/usr/local/supermailer/bin/sendmail-compat</span> αντί για το sendmail, θα μπορούσατε να αλλάξετε το <span class=filename>/etc/mail/mailer.conf</span> ώστε να γράφει:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail	 /usr/local/supermailer/bin/sendmail-compat
send-mail	/usr/local/supermailer/bin/sendmail-compat
mailq		/usr/local/supermailer/bin/mailq-compat
newaliases	/usr/local/supermailer/bin/newaliases-compat
hoststat	/usr/local/supermailer/bin/hoststat-compat
purgestat	/usr/local/supermailer/bin/purgestat-compat</pre></div></div></div><div class=sect3><h4 id=_ολοκληρώνοντας>53.4.5. Ολοκληρώνοντας<a class=anchor href=#_ολοκληρώνοντας></a></h4><div class=paragraph><p>Μόλις έχετε ρυθμίσει τα πάντα όπως επιθυμείτε, μπορείτε είτε να κάνετε kill τις διεργασίες του sendmail που δεν χρειάζεστε πλέον και να εκκινήσετε τις αντίστοιχες του νέου σας λογισμικού, ή απλώς να κάνετε επανεκκίνηση. Η επανεκκίνηση θα σας δώσει επίσης την ευκαιρία να βεβαιωθείτε ότι το σύστημα σας έχει ρυθμιστεί σωστά, ώστε το νέο σας MTA να ξεκινάει αυτόματα σε κάθε εκκίνηση.</p></div></div></div><div class=sect2><h3 id=mail-trouble>53.5. Αντιμετώπιση Προβλημάτων<a class=anchor href=#mail-trouble></a></h3><div class=sect3><h4 id=_γιατί_πρέπει_να_χρησιμοποιώ_το_πλήρες_όνομα_fqdn_για_υπολογιστές_που_βρίσκονται_στον_τομέα_μου>53.5.1. Γιατί πρέπει να χρησιμοποιώ το πλήρες όνομα (FQDN) για υπολογιστές που βρίσκονται στον τομέα μου;<a class=anchor href=#_γιατί_πρέπει_να_χρησιμοποιώ_το_πλήρες_όνομα_fqdn_για_υπολογιστές_που_βρίσκονται_στον_τομέα_μου></a></h4><div class=paragraph><p>Το πιο πιθανό είναι να διαπιστώσετε ότι ο υπολογιστής βρίσκεται στην πραγματικότητα σε διαφορετικό τομέα. Για παράδειγμα, αν βρίσκεστε στο <code>foo.bar.edu</code> και θέλετε να επικοινωνήσετε με ένα υπολογιστή με το όνομα <code>mumble</code> στον τομέα <code>bar.edu</code>, θα πρέπει να αναφερθείτε σε αυτόν με το πλήρες του όνομα, <code>mumble.bar.edu</code>, αντί για απλώς <code>mumble</code>.</p></div><div class=paragraph><p>Παραδοσιακά, αυτό επιτρεπόταν από τους DNS resolvers του BIND. Ωστόσο, η τρέχουσα έκδοση του BIND που περιλαμβάνεται στο FreeBSD, δεν παρέχει πλέον συντομεύσεις για μη-πλήρη ονόματα τομέων, εκτός για τον τομέα στον οποίο βρίσκεστε. Έτσι, ένας υπολογιστής με μη-πλήρες όνομα <code>mumble</code> θα πρέπει να βρεθεί ως <code>mumble.foo.bar.edu</code>, ή θα γίνει αναζήτηση για αυτόν στο ριζικό τομέα.</p></div><div class=paragraph><p>Η συμπεριφορά αυτή είναι διαφορετική από την προηγούμενη, όπου η αναζήτηση συνεχιζόταν και στο <code>mumble.bar.edu</code>, και το <code>mumble.edu</code>. Ρίξτε μια ματιά στο RFC 1535 για το λόγο που το παραπάνω θεωρείτε κακή πρακτική, ή ακόμα και κενό ασφαλείας.</p></div><div class=paragraph><p>Ένας τρόπος για να παρακάμψετε το πρόβλημα είναι να προσθέσετε τη γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>search foo.bar.edu bar.edu</pre></div></div><div class=paragraph><p>αντί για την προηγούμενη:</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>στο αρχείο <span class=filename>/etc/resolv.conf</span>. Βεβαιωθείτε ωστόσο ότι η σειρά αναζήτησης δεν πηγαίνει πέρα από το "όριο μεταξύ τοπικής και δημόσιας διαχείρισης", όπως το αποκαλεί το RFC 1535.</p></div></div><div class=sect3><h4 id=_το_sendmail_δίνει_το_μήνυμα_mail_loops_back_to_myself_το_mail_επιστρέφει_στον_εαυτό_μου>53.5.2. Το sendmail δίνει το μήνυμα mail loops back to myself (το mail επιστρέφει στον εαυτό μου)<a class=anchor href=#_το_sendmail_δίνει_το_μήνυμα_mail_loops_back_to_myself_το_mail_επιστρέφει_στον_εαυτό_μου></a></h4><div class=paragraph><p>Η απάντηση σε αυτό, υπάρχει στο FAQ του sendmail όπως φαίνεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>Λαμβάνω αυτά τα μηνύματα λάθους:

553 MX list for domain.net points back to relay.domain.net
554 &lt;user@domain.net&gt;... Local configuration error

Πως μπορώ να λύσω το πρόβλημα;

Έχετε ζητήσει το mail προς ένα τομέα (π.χ. το domain.net) να
προωθείται προς ένα συγκεκριμένο υπολογιστή (στην περίπτωση αυτή
το relay.domain.net) χρησιμοποιώντας μια εγγραφή
MXMX record, αλλά το
μηχάνημα αναμετάδοσης (relay) δεν αναγνωρίζει τον εαυτό του ως
domain.net.  Προσθέστε το domain.net στο /etc/mail/local-host-names
[είναι γνωστό ως /etc/sendmail.cw πριν την έκδοση 8.10]
(αν χρησιμοποιείτε το FEATURE(use_cw_file)), διαφορετικά προσθέστε το
Cw domain.net στο /etc/mail/sendmail.cf.</pre></div></div><div class=paragraph><p>Μπορείτε να βρείτε το FAQ του sendmail στη διεύθυνση <a href=http://www.sendmail.org/faq/>http://www.sendmail.org/faq/</a>, και συνίσταται να το διαβάσετε αν θέλετε να "πειράξετε" τις ρυθμίσεις του mail σας.</p></div></div><div class=sect3><h4 id=_πως_μπορώ_να_εκτελέσω_εξυπηρετητή_mail_σε_υπολογιστή_που_συνδέεται_μέσω_επιλογικής_σύνδεσης_ppp>53.5.3. Πως μπορώ να εκτελέσω εξυπηρετητή mail σε υπολογιστή που συνδέεται μέσω επιλογικής σύνδεσης PPP;<a class=anchor href=#_πως_μπορώ_να_εκτελέσω_εξυπηρετητή_mail_σε_υπολογιστή_που_συνδέεται_μέσω_επιλογικής_σύνδεσης_ppp></a></h4><div class=paragraph><p>Θέλετε να συνδέσετε ένα FreeBSD μηχάνημα σε ένα τοπικό δίκτυο (LAN) στο Internet. Το FreeBSD μηχάνημα θα γίνει πύλη ταχυδρομείου για το LAN. Η σύνδεση PPP δεν είναι αποκλειστική.</p></div><div class=paragraph><p>Υπάρχουν τουλάχιστον δύο τρόποι για να το κάνετε αυτό. Ο ένας είναι με τη χρήση UUCP.</p></div><div class=paragraph><p>Ένας άλλος τρόπος είναι να βάλετε ένα εξυπηρετητή Internet ο οποίος έχει συνεχή σύνδεση, να σας παρέχει υπηρεσία δευτερεύοντος MX για τον τομέα σας. Για παράδειγμα, αν ο τομέας της εταιρίας σας είναι <code>example.com</code> και ο παροχέας σας Internet έχει ορίσει το <code>example.net</code> να παρέχει υπηρεσίες δευτερεύοντος MX για τον τομέα σας:</p></div><div class="literalblock programlisting"><div class=content><pre>example.com.          MX        10      example.com.
                      MX        20      example.net.</pre></div></div><div class=paragraph><p>Μόνο ένας υπολογιστής μπορεί να καθοριστεί ως τελικός παραλήπτης (προσθέστε το <code>Cw example.com</code> στο αρχείο <span class=filename>/etc/mail/sendmail.cf</span> στο <code>example.com</code>).</p></div><div class=paragraph><p>Όταν το μηχάνημα που στέλνει μέσω του <code>sendmail</code> προσπαθεί να παραδώσει το mail θα προσπαθήσει να συνδεθεί στο δικό σας (<code>example.com</code>) μέσω της σύνδεσης modem. Το πιο πιθανό είναι ότι δεν θα τα καταφέρει, γιατί δεν θα είστε συνδεμένος εκείνη τη στιγμή. Το sendmail θα το παραδώσει αυτόματα στην υπηρεσία δευτερεύοντος MX, π.χ. τον παροχέα σας Internet (<code>example.net</code>). Το δευτερεύον MX θα προσπαθεί περιοδικά να συνδεθεί στο μηχάνημα σας και να παραδώσει το mail στον κύριο εξυπηρετητή MX (<code>example.com</code>).</p></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε κάτι όπως το παρακάτω ως script εισόδου:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Put me in /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) &amp;
/usr/sbin/ppp -direct pppmyisp</pre></div></div><div class=paragraph><p>Αν πρόκειται να χρησιμοποιήσετε χωριστό script για την είσοδο κάποιου χρήστη, μπορείτε να χρησιμοποιήσετε αντί για το παραπάνω το <code>sendmail -qRexample.com</code> στο script. Αυτό θα εξαναγκάσει την άμεση επεξεργασία όλου του mail στην ουρά για το <code>example.com</code>.</p></div><div class=paragraph><p>Πιο λεπτομερής περιγραφή της κατάστασης φαίνεται παρακάτω:</p></div><div class=paragraph><p>Μήνυμα από την <a href=https://lists.FreeBSD.org/subscription/freebsd-isp>ηλεκτρονική λίστα του FreeBSD για τους παροχείς υπηρεσιών Internet</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>&gt; παρέχουμε δευτερεύον MX για ένα πελάτη.  Ο πελάτης συνδέεται στις
&gt; υπηρεσίες μας αρκετές φορές τη μέρα αυτόματα, για να λαμβάνει τα email του
&gt; στο πρωτεύον του MX (Δεν καλούμε την τοποθεσία του όταν λαμβάνουμε email
&gt; για τον τομέα του).  Το sendmail μας στέλνει το  mailqueue κάθε 30 λεπτά.
&gt; Τη δεδομένη στιγμή θα πρέπει να μείνει συνδεμένος για 30 λεπτά,
&gt; για να είναι βέβαιος ότι όλο το email του θα έχει
&gt; παραδοθεί στον πρωτεύοντα MX.
&gt;
&gt; Υπάρχει κάποια εντολή που να εξαναγκάσει το sendmail να στείλει
&gt; όλα τα mails άμεσα; Ο χρήστης φυσικά δεν έχει δικαιώματα
&gt; root στο μηχάνημα μας.

Στην ενότητα privacy flags του sendmail.cf, υπάρχει ένας
ορισμός Opgoaway,restrictqrun

Αφαιρέστε το restrictqrun για να επιτρέψετε σε μη-root χρήστες να ξεκινήσουν
την επεξεργασία της ουράς.
Μπορεί επίσης να θέλετε να αναδιατάξετε τα MX.  Είμαστε το 1ο MX για αυτού
του είδους τους πελάτες, και έχουμε ορίσει:

# If we are the best MX for a host, try directly instead of generating
# local config error.
OwTrue

Με τον τρόπο αυτό, ένα απομακρυσμένο site θα παραδίδει απευθείας σε σας,
χωρίς να προσπαθεί τη σύνδεση με το χρήστη.  Έπειτα τα στέλνετε στον
πελάτη σας.  Αυτό λειτουργεί μόνο για μηχανήματα, και έτσι
χρειάζεται να βάλετε τον πελάτη σας να ονομάσει το μηχάνημα του mail
customer.com και επίσης
hostname.customer.com στο DNS.  Απλώς προσθέστε μια εγγραφή
τύπου A στο DNS για το customer.com.</pre></div></div></div><div class=sect3><h4 id=_γιατί_λαμβάνω_συνέχεια_μηνύματα_λάθους_relaying_denied_όταν_στέλνω_mail_από_άλλους_υπολογιστές>53.5.4. Γιατί λαμβάνω συνέχεια μηνύματα λάθους Relaying Denied όταν στέλνω mail από άλλους υπολογιστές;<a class=anchor href=#_γιατί_λαμβάνω_συνέχεια_μηνύματα_λάθους_relaying_denied_όταν_στέλνω_mail_από_άλλους_υπολογιστές></a></h4><div class=paragraph><p>Στις προεπιλεγμένες εγκαταστάσεις του FreeBSD, το sendmail είναι ρυθμισμένο να στέλνει mail μόνο από τον υπολογιστή στον οποίο εκτελείται. Για παράδειγμα, αν υπάρχει διαθέσιμος διακομιστής POP, οι χρήστες θα μπορούν να ελέγχουν το mail τους από το σχολείο, το γραφείο, ή άλλη απομακρυσμένη τοποθεσία, αλλά θα εξακολουθούν να μην μπορούν να στείλουν προς εξωτερικές διευθύνσεις. Τυπικά, λίγο μετά από μια απόπειρα αποστολής, θα σταλεί ένα email από τον MAILER-DAEMON με το μήνυμα λάθους <code>5.7 Relaying Denied</code>.</p></div><div class=paragraph><p>Υπάρχουν διάφοροι τρόποι για να ξεπεράσετε το πρόβλημα. Ο πλέον απλός είναι να βάλετε τη διεύθυνση του ISP σας σε ένα αρχείο relay-domains, <span class=filename>/etc/mail/relay-domains</span>. Ένας γρήγορος τρόπος για να το κάνετε αυτό είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;your.isp.example.com&#34; &gt; /etc/mail/relay-domains</span></code></pre></div></div><div class=paragraph><p>Αφού δημιουργήσετε ή επεξεργαστείτε αυτό το αρχείο, θα πρέπει να επανεκκινήσετε το sendmail. Αυτό δουλεύει μια χαρά αν είστε διαχειριστής εξυπηρετητή και δεν επιθυμείτε να στέλνετε mail τοπικά, ή αν θέλετε να χρησιμοποιήσετε ένα σύστημα τύπου point και click σε ένα άλλο μηχάνημα ή ακόμα και σε άλλο ISP. Είναι επίσης πολύ χρήσιμο αν έχετε ρυθμίσει μόνο ένα ή δύο λογαριασμούς mail. Αν θέλετε να προσθέσετε μεγαλύτερο αριθμό διευθύνσεων, μπορείτε να ανοίξετε αυτό το αρχείο με τον επιθυμητό συντάκτη κειμένου, και να προσθέσετε όλους τους τομείς, ένα σε κάθε γραμμή:</p></div><div class="literalblock programlisting"><div class=content><pre>your.isp.example.com
other.isp.example.net
users-isp.example.org
www.example.org</pre></div></div><div class=paragraph><p>Τώρα, οποιαδήποτε αποστολή mail από το σύστημα σας από οποιοδήποτε υπολογιστή αυτής της λίστας (με την προϋπόθεσή ο χρήστης να έχει λογαριασμό στο σύστημα σας), θα είναι επιτυχής. Πρόκειται για ένα πολύ καλό τρόπο να επιτρέψετε στους χρήστες να στέλνουν mail από το σύστημα σας μέσω απομακρυσμένης σύνδεσης, χωρίς να επιτρέπετε σε άλλους να στέλνουν SPAM μέσω του συστήματος σας.</p></div></div></div><div class=sect2><h3 id=mail-advanced>53.6. Προχωρημένα Θέματα<a class=anchor href=#mail-advanced></a></h3><div class=paragraph><p>Η ακόλουθη ενότητα καλύπτει πιο προχωρημένα θέματα, όπως τη ρύθμιση του mail και ρυθμίσεις για ένα ολόκληρο τομέα.</p></div><div class=sect3><h4 id=mail-config>53.6.1. Βασικές Ρυθμίσεις<a class=anchor href=#mail-config></a></h4><div class=paragraph><p>Χωρίς να χρειαστεί να κάνετε καμιά ρύθμιση, θα μπορείτε να στείλετε mail προς εξωτερικούς υπολογιστές, αρκεί να έχετε ρυθμίσει το <span class=filename>/etc/resolv.conf</span> ή να εκτελείτε το δικό σας εξυπηρετητή DNS. Αν θέλετε να παραλαμβάνετε mail για τον υπολογιστή σας στο δικό σας sendmail MTA, υπάρχουν δύο μέθοδοι:</p></div><div class=ulist><ul><li><p>Μπορείτε να έχετε δικό σας τομέα και δικό σας εξυπηρετητή DNS για τον τομέα σας. Για παράδειγμα, <code>FreeBSD.org</code></p></li><li><p>Να παραλαμβάνετε mail απευθείας στο μηχάνημα σας. Αυτό γίνεται αν το mail παραδίδεται απευθείας στον υπολογιστή σας, χρησιμοποιώντας τον όνομα του (πρέπει να βρίσκεται στο DNS). Για παράδειγμα, <code>example.FreeBSD.org</code>.</p></li></ul></div><div class=paragraph><p>Όποια επιλογή από τις παραπάνω και να κάνατε, για να είναι δυνατή η παραλαβή mail απευθείας στον υπολογιστή σας, θα πρέπει να έχετε μόνιμη στατική διεύθυνση IP (όχι δυναμική, όπως είναι οι περισσότερες επιλογικές συνδέσεις PPP). Αν βρίσκεστε πίσω από κάποιο firewall, θα πρέπει να επιτρέπει τη διακίνηση SMTP προς εσάς. Αν θέλετε να λαμβάνετε mail απευθείας στον υπολογιστή σας, θα πρέπει να εξασφαλίσετε <em>ένα</em> από τα παρακάτω:</p></div><div class=ulist><ul><li><p>Να βεβαιωθείτε ότι η εγγραφή MX (με το χαμηλότερο αριθμό) στο DNS σας, δείχνει προς τη διεύθυνση IP του μηχανήματος σας.</p></li><li><p>Να βεβαιωθείτε ότι δεν υπάρχει καμιά εγγραφή MX στο DNS για τον υπολογιστή σας.</p></li></ul></div><div class=paragraph><p>Όποιο από τα παραπάνω και αν κάνετε, θα μπορείτε να λαμβάνετε mail απευθείας στον υπολογιστή σας.</p></div><div class=paragraph><p>Δοκιμάστε αυτό:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hostname</span>
example.FreeBSD.org
<span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX</code></pre></div></div><div class=paragraph><p>Αν βλέπετε το παραπάνω, το mail που κατευθύνεται απευθείας στο <a href=mailto:yourlogin@example.FreeBSD.org>yourlogin@example.FreeBSD.org</a> θα πρέπει να λαμβάνεται χωρίς προβλήματα (θεωρώντας ότι το sendmail εκτελείτε σωστά στον υπολογιστή <code>example.FreeBSD.org</code>).</p></div><div class=paragraph><p>Αν αντί για αυτό δείτε κάτι σαν το παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by hub.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Όλο το mail που κατευθύνεται προς τον υπολογιστή σας (<code>example.FreeBSD.org</code>) θα καταλήξει να συλλέγεται στο <code>hub</code> με το ίδιο όνομα χρήστη, αντί να σταλεί απευθείας στο μηχάνημα σας.</p></div><div class=paragraph><p>Τις παραπάνω πληροφορίες, τις χειρίζεται ο δικός σας εξυπηρετητής DNS. Η εγγραφή DNS που περιέχει τις πληροφορίες δρομολόγησης για το mail, είναι η <em>M</em>ail e<em>X</em>change. Αν δεν υπάρχει εγγραφή MX, το mail θα παραδίδεται απευθείας στον υπολογιστή μέσω της IP διεύθυνσης του.</p></div><div class=paragraph><p>Η καταχώριση MX για τον <code>freefall.FreeBSD.org</code> έμοιαζε κάποια στιγμή με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>freefall        MX   30   mail.crl.net
freefall        MX   40   agora.rdrop.com
freefall        MX   10   freefall.FreeBSD.org
freefall        MX   20   who.cdrom.com</pre></div></div><div class=paragraph><p>Όπως μπορείτε να δείτε, ο <code>freefall</code> είχε πολλές καταχωρήσεις MX. Η καταχώρηση με τον μικρότερο αριθμό, είναι ο υπολογιστής που λαμβάνει το mail απευθείας, αν είναι διαθέσιμος. Αν για κάποιο λόγο δεν είναι προσβάσιμος, οι άλλοι (που ορισμένες φορές καλούνται "backup MXes") δέχονται τα μηνύματα προσωρινά και τα μεταβιβάζουν σε κάποιο υπολογιστή με χαμηλότερη αρίθμηση, μόλις γίνει διαθέσιμος. Τελικά τα μηνύματα καταλήγουν στον υπολογιστή με το μικρότερο αριθμό.</p></div><div class=paragraph><p>Οι εναλλακτικές τοποθεσίες MX, θα πρέπει να χρησιμοποιούν διαφορετικές γραμμές για τη σύνδεση τους με το Internet. Αυτή είναι η καλύτερη λύση. Ο παροχέας σας ή κάποιο άλλο φιλικό site, δεν θα έχουν κανένα πρόβλημα να σας παρέχουν αυτή την υπηρεσία.</p></div></div><div class=sect3><h4 id=mail-domain>53.6.2. Mail για τον Τομέα Σας<a class=anchor href=#mail-domain></a></h4><div class=paragraph><p>Για να δημιουργήσετε ένα "mailhost" (δηλ. ένα εξυπηρετητή mail) θα πρέπει οποιοδήποτε mail στέλνεται προς κάποιο σταθμό εργασίας, να λαμβάνεται σε αυτόν. Βασικά θα θέλετε να "διεκδικείτε" οποιοδήποτε mail που κατευθύνεται προς οποιοδήποτε όνομα μηχανήματος του τομέα σας (στην περίπτωση μας το <code>*.FreeBSD.org</code>) και να το ανακατευθύνετε προς τον εξυπηρετητή mail, ώστε οι χρήστες σας να μπορούν να λάβουν το mail τους από τον κεντρικό εξυπηρετητή.</p></div><div class=paragraph><p>Για ευκολία, θα πρέπει να έχετε ένα λογαριασμό χρήστη με το ίδιο <em>όνομα χρήστη</em> και στα δύο μηχανήματα. Χρησιμοποιήστε για το σκοπό αυτό την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>.</p></div><div class=paragraph><p>Ο mailhost που θα χρησιμοποιήσετε, πρέπει να είναι το καθορισμένο μηχάνημα για την ανταλλαγή μηνυμάτων για κάθε σταθμό εργασίας του δικτύου. Αυτό γίνεται στις ρυθμίσεις DNS με τον ακόλουθο τρόπο:</p></div><div class="literalblock programlisting"><div class=content><pre>example.FreeBSD.org        A      204.216.27.XX		; Workstation
                           MX  10 hub.FreeBSD.org	   ; Mailhost</pre></div></div><div class=paragraph><p>Με τον τρόπο αυτό, το mail που κατευθύνεται προς κάποιο σταθμό εργασίας θα ανακατευθυνθεί προς το mailhost, άσχετα με το που δείχνει η εγγραφή τύπου Α. Το mail στέλνεται προς τον υπολογιστή MX.</p></div><div class=paragraph><p>Δεν μπορείτε να κάνετε το παραπάνω, αν δεν εκτελείτε το δικό σας εξυπηρετητή DNS. Αν αυτό δεν συμβαίνει, και δεν μπορείτε να το αλλάξετε, συνεννοηθείτε με τον παροχέα σας (ISP) ή με όποιον σας παρέχει υπηρεσίες DNS.</p></div><div class=paragraph><p>Αν παρέχετε υπηρεσίες εικονικού ταχυδρομείου, οι παρακάτω πληροφορίες θα σας φανούν χρήσιμες. Για το παράδειγμα μας, θα υποθέσουμε ότι έχετε ένα πελάτη με το δικό του τομέα, στην περίπτωση μας το <code>customer1.org</code>, και θέλετε όλο το mail για το <code>customer1.org</code> να στέλνεται στο δικό σας mailhost, <code>mail.myhost.com</code>. Η καταχώριση σας στο DNS θα μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>customer1.org		MX	10	mail.myhost.com</pre></div></div><div class=paragraph><p>Σημειώστε ότι <em>δεν χρειάζεστε</em> εγγραφή τύπου Α για το <code>customer1.org</code> αν θέλετε απλώς να χειρίζεστε email για αυτό τον τομέα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Να έχετε υπόψη σας ότι δεν θα μπορείτε να κάνετε ping το <code>customer1.org</code> αν δεν υπάρχει για αυτό εγγραφή τύπου Α.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το τελευταίο πράγμα που πρέπει να κάνετε, είναι να ορίσετε στο sendmail που εκτελείται στο δικό σας mailhost, για ποιους τομείς ή / και μηχανήματα θα δέχεται mail. Υπάρχουν μερικοί διαφορετικοί τρόποι για να γίνει αυτό. Μπορείτε να χρησιμοποιήσετε έναν από τους παρακάτω:</p></div><div class=ulist><ul><li><p>Προσθέστε τα μηχανήματα στο αρχείο <span class=filename>/etc/mail/local-host-names</span> αν χρησιμοποιείτε τη δυνατότητα <code>FEATURE(use_cw_file)</code>. Αν χρησιμοποιείτε κάποια έκδοση του sendmail πριν την 8.10, το αρχείο είναι το <span class=filename>/etc/sendmail.cw</span>.</p></li><li><p>Προσθέστε μια γραμμή <code>Cwyour.host.com</code> στο αρχείο σας <span class=filename>/etc/sendmail.cf</span> ή στο αρχείο <span class=filename>/etc/mail/sendmail.cf</span> αν χρησιμοποιείτε την έκδοση 8.10 του sendmail ή κάποια μεταγενέστερη.</p></li></ul></div></div></div><div class=sect2><h3 id=SMTP-UUCP>53.7. SMTP με UUCP<a class=anchor href=#SMTP-UUCP></a></h3><div class=paragraph><p>Η προεπιλεγμένη ρύθμιση του sendmail που έρχεται με το FreeBSD, προορίζεται για δικτυακές τοποθεσίες που είναι απευθείας συνδεδεμένες στο Internet. Σε περιπτώσεις που είναι επιθυμητή η ανταλλαγή email μέσω UUCP, θα πρέπει να χρησιμοποιηθεί διαφορετικό αρχείο ρυθμίσεων για το sendmail.</p></div><div class=paragraph><p>Η χειροκίνητη ρύθμιση του αρχείου <span class=filename>/etc/mail/sendmail.cf</span> ανήκει στα προχωρημένα θέματα. Η έκδοση 8 του sendmail παράγει αρχεία ρυθμίσεων μέσω του προεπεξεργαστή <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a>, όπου οι ρυθμίσεις γίνονται σε ένα ανώτερο επίπεδο αφαίρεσης. Μπορείτε να βρείτε τα αρχεία ρύθμισης του<a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> στον κατάλογο <span class=filename>/usr/shared/sendmail/cf</span>. Διαβάστε το <span class=filename>README</span> στον κατάλογο <span class=filename>cf</span> για μια βασική εισαγωγή στις ρυθμίσεις του <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a>.</p></div><div class=paragraph><p>Ο καλύτερος τρόπος για την παράδοση mail μέσω του UUCP, είναι με την χρήση της δυνατότητας <code>mailertable</code>. Παράγεται με αυτό τον τρόπο μια βάση δεδομένων που μπορεί να χρησιμοποιήσει το sendmail για να πάρει αποφάσεις σχετικά με την δρομολόγηση.</p></div><div class=paragraph><p>Θα πρέπει αρχικά να δημιουργήσετε το αρχείο <span class=filename>.mc</span>. Θα βρείτε μερικά παραδείγματα στον κατάλογο <span class=filename>/usr/shared/sendmail/cf/cf</span>. Υποθέτοντας ότι έχετε ονομάσει το αρχείο σας <span class=filename>foo.mc</span>, το μόνο που χρειάζεται να κάνετε για να το μετατρέψετε σε ένα έγκυρο αρχείο <span class=filename>sendmail.cf</span> είναι:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/mail</span>
<span class=c># make foo.cf</span>
<span class=c># cp foo.cf /etc/mail/sendmail.cf</span></code></pre></div></div><div class=paragraph><p>Ένα τυπικό αρχείο <span class=filename>.mc</span> θα δείχνει όπως το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`Your version number&#39;) OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable&#39;)

define(`UUCP_RELAY&#39;, your.uucp.relay)
define(`UUCP_MAX_SIZE&#39;, 200000)
define(`confDONT_PROBE_INTERFACES&#39;)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    your.alias.host.name
Cw    youruucpnodename.UUCP</pre></div></div><div class=paragraph><p>Οι γραμμές που περιέχουν τις δυνατότητες <code>accept_unresolvable_domains</code>, <code>nocanonify</code>, and <code>confDONT_PROBE_INTERFACES</code> θα αποτρέψουν τη χρήση του DNS κατά την παράδοση του mail. Η οδηγία <code>UUCP_RELAY</code> απαιτείται για την υποστήριξη παράδοσης μέσω του UUCP. Απλώς τοποθετήστε εκεί ένα όνομα μηχανήματος στο Internet που να μπορεί να χειριστεί διευθύνσεις ψευδο-τομέων .UUCP. Το πιο πιθανό είναι να βάλετε εκεί τον αναμεταδότη (relay) για mail που παρέχει ο ISP σας.</p></div><div class=paragraph><p>Έχοντας κάνει το παραπάνω, θα χρειαστείτε ένα αρχείο <span class=filename>/etc/mail/mailertable</span>. Αν έχετε μόνο μια σύνδεση με τον έξω κόσμο που χρησιμοποιείται για όλα σας τα mail, το παρακάτω αρχείο είναι επαρκές:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
.                             uucp-dom:your.uucp.relay</pre></div></div><div class=paragraph><p>Ένα πιο πολύπλοκο παράδειγμα θα μοιάζει με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre></div></div><div class=paragraph><p>Οι τρεις πρώτες γραμμές χειρίζονται ειδικές περιπτώσεις, όπου το mail που απευθύνεται σε κάποιο τομέα δεν θα πρέπει να σταλθεί στην προεπιλεγμένη διαδρομή, αλλά αντίθετα σε κάποιο γειτονικό UUCP προκειμένου να "συντομευθεί" το μονοπάτι παράδοσης. Η επόμενη γραμμή χειρίζεται το mail προς τον τοπικό τομέα Ethernet, όπου είναι δυνατή η παράδοση μέσω SMTP. Τέλος, οι γειτονικοί UUCP αναφέρονται με γραφή ψευδο-τομέων UUCP ώστε να επιτρέπεται σε κάποιον <code>uucp-neighbor !recipient</code> να παρακάμψει τους προεπιλεγμένους κανόνες. Η τελευταία γραμμή είναι πάντα μια μοναδική τελεία, η οποία ταιριάζει με οτιδήποτε άλλο, με παράδοση UUCP σε ένα γειτονικό UUCP ο οποίος ενεργεί ως γενική πύλη mail προς τον υπόλοιπο κόσμο. Όλα τα ονόματα υπολογιστών που βρίσκονται μετά το <code>uucp-dom:</code> θα πρέπει να είναι έγκυροι UUCP γείτονες, όπως μπορείτε να βεβαιώσετε χρησιμοποιώντας το <code>uuname</code>.</p></div><div class=paragraph><p>Σας υπενθυμίζουμε ότι αυτό το αρχείο πρέπει να μετατραπεί σε μια βάση δεδομένων DBM πριν χρησιμοποιηθεί. Μπορείτε να βάλετε τη γραμμή εντολών που απαιτείται για να επιτευχθεί αυτό ως σχόλιο στην αρχή του αρχείου <span class=filename>mailertable</span>. Πρέπει πάντοτε να εκτελείτε αυτή την εντολή κάθε φορά που αλλάζετε το αρχείο <span class=filename>mailertable</span>.</p></div><div class=paragraph><p>Μια τελευταία υπόδειξη: αν δεν είστε βέβαιοι για το αν θα λειτουργήσει κάποια συγκεκριμένη δρομολόγηση mail, θυμηθείτε την επιλογή <code>-bt</code> του sendmail. Αυτή ξεκινάει το sendmail σε <em>κατάσταση δοκιμής διευθύνσεων</em>. Γράψτε <code>3,0</code>, ακολουθούμενο από τη διεύθυνση που θέλετε να ελέγξετε για δρομολόγηση mail. Η τελευταία γραμμή θα σας πει τον εσωτερικό αντιπρόσωπο mail που χρησιμοποιήθηκε, τη διεύθυνση προορισμού με την οποία κλήθηκε, καθώς και την (πιθανώς μεταφρασμένη) διεύθυνση. Μπορείτε να βγείτε από αυτή την κατάσταση, πληκτρολογώντας <span class=keyseq><kbd>Ctrl</kbd>+<kbd>D</kbd></span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sendmail <span class=nt>-bt</span>
ADDRESS TEST MODE <span class=o>(</span>ruleset 3 NOT automatically invoked<span class=o>)</span>
Enter &lt;ruleset&gt; &lt;address&gt;
<span class=o>&gt;</span> 3,0 foo@example.com
canonify           input: foo @ example <span class=nb>.</span> com
...
parse            returns: <span class=nv>$# </span>uucp-dom <span class=nv>$@</span> your.uucp.relay <span class=nv>$:</span> foo &lt; @ example <span class=nb>.</span> com <span class=nb>.</span> <span class=o>&gt;</span>
<span class=o>&gt;</span> ^D</code></pre></div></div></div><div class=sect2><h3 id=outgoing-only>53.8. Ρύθμιση Εξυπηρετητή Μόνο για Αποστολή<a class=anchor href=#outgoing-only></a></h3><div class=paragraph><p>Υπάρχουν πολλές περιπτώσεις, που μπορεί να θέλετε μόνο να στέλνετε mail μέσω κάποιου αναμεταδότη. Μερικά παραδείγματα:</p></div><div class=ulist><ul><li><p>Ο υπολογιστής σας χρησιμοποιείται ως desktop, αλλά θέλετε να χρησιμοποιήσετε προγράμματα όπως το <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. Για να γίνει αυτό θα πρέπει να χρησιμοποιήσετε τον αναμεταδότη mail που παρέχει ο ISP σας.</p></li><li><p>Ο υπολογιστής σας είναι ένας εξυπηρετητής που δεν χειρίζεται το mail τοπικά, αλλά χρειάζεται να το δώσει εξ' ολοκλήρου σε κάποιο αναμεταδότη για επεξεργασία.</p></li></ul></div><div class=paragraph><p>Οποιοδήποτε σχεδόν MTA είναι ικανό να καλύψει τον παραπάνω ρόλο. Δυστυχώς, μπορεί να είναι πολύ δύσκολο να ρυθμίσετε σωστά ένα πλήρες MTA ώστε απλώς να στέλνει το mail προς αναμετάδοση. Προγράμματα όπως το sendmail και το postfix είναι υπερβολικά μεγάλα για αυτή τη δουλειά.</p></div><div class=paragraph><p>Επιπρόσθετα, αν χρησιμοποιείτε κάποια συνηθισμένη υπηρεσία πρόσβασης στο Internet, η συμφωνία με την εταιρία παροχής μπορεί να σας απαγορεύει να εκτελείτε το δικό σας "εξυπηρετητή mail".</p></div><div class=paragraph><p>Ο ευκολότερος τρόπος για να εκπληρώσετε αυτές τις ανάγκες είναι να εγκαταστήσετε το port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> Εκτελέστε τις ακόλουθες εντολές ως <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/mail/ssmtp</span>
<span class=c># make install replace clean</span></code></pre></div></div><div class=paragraph><p>Μετά την εγκατάσταση, το <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> μπορεί να ρυθμιστεί με ένα αρχείο τεσσάρων μόλις γραμμών, το οποίο βρίσκεται στο <span class=filename>/usr/local/etc/ssmtp/ssmtp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_</pre></div></div><div class=paragraph><p>Βεβαιωθείτε ότι χρησιμοποιείτε την πραγματική διεύθυνση email για τον <code>root</code>. Βάλτε τον αναμεταδότη mail του ISP σας στη θέση <code>mail.example.com</code> (μερικοί ISP τον ονομάζουν "εξυπηρετητή εξερχόμενου ταχυδρομείου" ή "εξυπηρετητή SMTP").</p></div><div class=paragraph><p>Βεβαιωθείτε ότι έχετε απενεργοποιήσει πλήρως το sendmail, ακόμα και την υπηρεσία εξερχόμενων μηνυμάτων. Δείτε το <a href=#mail-disable-sendmail>Απενεργοποιήστε το sendmail</a> για λεπτομέρειες.</p></div><div class=paragraph><p>Υπάρχουν κάποιες ακόμα διαθέσιμες επιλογές στο <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a>. Δείτε το παράδειγμα του αρχείου ρυθμίσεων στο <span class=filename>/usr/local/etc/ssmtp</span> ή τη σελίδα manual του ssmtp για περισσότερα παραδείγματα και πληροφορίες.</p></div><div class=paragraph><p>Ρυθμίζοντας το ssmtp με αυτό τον τρόπο, θα είναι δυνατή η σωστή λειτουργία οποιουδήποτε λογισμικού στον υπολογιστή σας που χρειάζεται να στείλει mail. Επίσης δεν παραβιάζεται με αυτό τον τρόπο η άδεια χρήσης του ISP σας και δεν μπορεί ο υπολογιστής σας να παραβιαστεί και να χρησιμοποιηθεί για την αποστολή ανεπιθύμητων μηνυμάτων (spam).</p></div></div><div class=sect2><h3 id=SMTP-dialup>53.9. Χρησιμοποιώντας το Mail Μέσω Επιλογικής (Dialup) Σύνδεσης<a class=anchor href=#SMTP-dialup></a></h3><div class=paragraph><p>Αν έχετε στατική διεύθυνση IP, δεν θα χρειαστεί να αλλάξετε καμιά από τις προεπιλογές. Ρυθμίστε το όνομα του υπολογιστή σας ώστε να ταιριάζει με αυτό που σας έχει οριστεί για το Internet, και το sendmail θα κάνει τα υπόλοιπα.</p></div><div class=paragraph><p>Αν λαμβάνετε δυναμική IP και χρησιμοποιείτε επιλογική PPP σύνδεση με το Internet, πιθανόν διαθέτετε μια θυρίδα ταχυδρομείου (mailbox) στον εξυπηρετητή mail του παροχέα σας. Ας υποθέσουμε ότι ο τομέας του ISP σας είναι <code>example.net</code>, και ότι το όνομα χρήστη σας είναι <code>user</code>, το μηχάνημα σας λέγεται <code>bsd.home</code>, και ο ISP σας, σας έχει πει ότι μπορείτε να χρησιμοποιήσετε το <code>relay.example.net</code> ως αναμεταδότη για το mail.</p></div><div class=paragraph><p>Για να μπορέσετε να λάβετε mail από τη θυρίδα σας, θα χρειαστείτε κάποιο αντιπρόσωπο ανάληψης (retrieval agent). Το βοηθητικό πρόγραμμα fetchmail είναι μια καλή επιλογή, καθώς υποστηρίζει πολλά διαφορετικά πρωτόκολλα. Το πρόγραμμα αυτό είναι διαθέσιμο ως πακέτο ή από την Συλλογή των Ports (<a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a>). Συνήθως, ο ISP σας θα παρέχει την υπηρεσία POP. Αν χρησιμοποιείτε PPP χρήστη, μπορείτε να κατεβάσετε αυτόματα το mail σας μετά την αποκατάσταση της σύνδεσης σας, χρησιμοποιώντας την ακόλουθη καταχώριση στο <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
!bg su user -c fetchmail</pre></div></div><div class=paragraph><p>Αν χρησιμοποιείτε το sendmail (όπως φαίνεται παρακάτω) για να παραδώσετε mail σε μη-τοπικούς λογαριασμούς, πιθανόν να θέλετε το sendmail να επεξεργάζεται την ουρά του mail αμέσως μετά την αποκατάσταση της σύνδεσης. Για να το κάνετε αυτό, βάλτε την παρακάτω εντολή αμέσως μετά την εντολή <code>fetchmail</code> στο αρχείο <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  !bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p>Ας υποθέσουμε ότι υπάρχει ένας λογαριασμός για τον <code>user</code> στον <code>bsd.home</code>. Στον προσωπικό κατάλογο του <code>user</code> στο <code>bsd.home</code>, δημιουργήστε ένα αρχείο <span class=filename>.fetchmailrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.net protocol pop3 fetchall pass MySecret</pre></div></div><div class=paragraph><p>Το αρχείο αυτό δεν θα πρέπει να είναι αναγνώσιμο από κανένα, εκτός από τον <code>user</code>, καθώς περιέχει τον κωδικό <code>MySecret</code>.</p></div><div class=paragraph><p>Για να μπορείτε να στείλετε mail με τη σωστή επικεφαλίδα <code>from:</code>, θα πρέπει να ρυθμίσετε το sendmail να χρησιμοποιεί το <a href=mailto:user@example.net>user@example.net</a> αντί για το <a href=mailto:user@bsd.home>user@bsd.home</a>. Ίσως επίσης να θέλετε να ρυθμίσετε το sendmail να στέλνει όλο το mail μέσω του <code>relay.example.net</code>, ώστε η μετάδοση του mail να είναι ταχύτερη.</p></div><div class=paragraph><p>Το ακόλουθο αρχείο <span class=filename>.mc</span> θα πρέπει να είναι επαρκές:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.example.net&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;,`deferred&#39;)dnl</pre></div></div><div class=paragraph><p>Διαβάστε την προηγούμενη ενότητα για λεπτομέρειες σχετικά με την μετατροπή αυτού του αρχείου <span class=filename>.mc</span> σε ένα αρχείο <span class=filename>sendmail.cf</span>. Επίσης, μη ξεχάσετε να επανεκκινήσετε το sendmail μετά την ενημέρωση του <span class=filename>sendmail.cf</span>.</p></div></div><div class=sect2><h3 id=SMTP-Auth>53.10. Πιστοποίηση Αυθεντικότητας στο SMTP<a class=anchor href=#SMTP-Auth></a></h3><div class=paragraph><p>Η χρήση SMTP με πιστοποίηση αυθεντικότητας στον εξυπηρετητή ταχυδρομείου σας, μπορεί να σας προσφέρει μια σειρά από οφέλη. Μπορεί να προσθέσει ένα ακόμα επίπεδο ασφάλειας στο sendmail, ενώ έχει και το πλεονέκτημα ότι δίνει τη δυνατότητα στους χρήστες φορητών υπολογιστών (που συχνά συνδέονται μέσω διαφορετικών δικτύων) να χρησιμοποιούν τον ίδιο εξυπηρετητή ταχυδρομείου χωρίς την ανάγκη επαναρύθμισης κάθε φορά του προγράμματος αποστολής / λήψης ταχυδρομείου.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Εγκαταστήστε το <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a> από τη Συλλογή των Ports. Το port αυτό υποστηρίζει μια σειρά από επιλογές που μπορείτε να θέσετε κατά την μεταγλώττιση. Για να μπορέσετε να χρησιμοποιήσετε την μέθοδο αυθεντικοποίησης στο SMTP που συζητάμε εδώ, βεβαιωθείτε ότι είναι ενεργοποιημένη η επιλογή <code>LOGIN</code>.</p></li><li><p>Μετά την εγκατάσταση του <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a>, τροποποιήστε το αρχείο <span class=filename>/usr/local/lib/sasl2/Sendmail.conf</span> (ή δημιουργήστε το αν δεν υπάρχει) και προσθέστε την παρακάτω γραμμή:</p><div class="literalblock programlisting"><div class=content><pre>pwcheck_method: saslauthd</pre></div></div></li><li><p>Εγκαταστήστε έπειτα το <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2-saslauthd/>security/cyrus-sasl2-saslauthd</a>, και προσθέστε στο <span class=filename>/etc/rc.conf</span> την ακόλουθη γραμμή:</p><div class="literalblock programlisting"><div class=content><pre>saslauthd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Τέλος, ξεκινήστε το δαίμονα saslauthd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/saslauthd start</span></code></pre></div></div><div class=paragraph><p>Ο δαίμονας αυτός δρα ως ενδιάμεσος για το sendmail ώστε να γίνεται πιστοποίηση αυθεντικότητας μέσω της βάσης δεδομένων κωδικών <span class=filename>passwd</span> του FreeBSD συστήματος σας. Με αυτό τον τρόπο απαλλάσσεστε από την ανάγκη δημιουργίας νέου σετ από ονόματα χρηστών και κωδικούς για κάθε χρήστη που χρειάζεται να χρησιμοποιήσει πιστοποίηση στο SMTP. Χρησιμοποιείται το ίδιο όνομα και κωδικός, τόσο για είσοδο στο σύστημα, όσο και για το mail.</p></div></li><li><p>Επεξεργαστείτε τώρα το <span class=filename>/etc/make.conf</span> και προσθέστε τις ακόλουθες γραμμές:</p><div class="literalblock programlisting"><div class=content><pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL
SENDMAIL_LDFLAGS=-L/usr/local/lib
SENDMAIL_LDADD=-lsasl2</pre></div></div><div class=paragraph><p>Οι γραμμές αυτές, παρέχουν στο sendmail τις κατάλληλες ρυθμίσεις ώστε να συνδεθεί σωστά με το <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a> κατά τη διάρκεια της μεταγλώττισης. Βεβαιωθείτε ότι είναι εγκατεστημένο το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a> πριν ξεκινήσετε την επαναμεταγλώττιση του sendmail.</p></div></li><li><p>Επαναμεταγλωττίστε το sendmail εκτελώντας τις παρακάτω εντολές:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libsmutil</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/lib/libsm</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/usr.sbin/sendmail</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make &amp;&amp; make install</span></code></pre></div></div><div class=paragraph><p>Η μεταγλώττιση του sendmail δεν πρέπει να παρουσιάσει προβλήματα, αν το <span class=filename>/usr/src</span> δεν έχει αλλάξει σε μεγάλο βαθμό και εφόσον υπάρχουν οι κοινόχρηστες βιβλιοθήκες που απαιτούνται.</p></div></li><li><p>Μετά την μεταγλώττιση και επανεγκατάσταση του sendmail, επεξεργαστείτε το αρχείο <span class=filename>/etc/mail/freebsd.mc</span> (ή όποιο αρχείο χρησιμοποιείτε ως <span class=filename>.mc</span>. Πολλοί διαχειριστές επιλέγουν να χρησιμοποιήσουν την έξοδο της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> ως όνομα για το αρχείο <span class=filename>.mc</span> για να εξασφαλίσουν ότι είναι μοναδικό). Προσθέστε σε αυτό τις ακόλουθες γραμμές:</p><div class="literalblock programlisting"><div class=content><pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl</pre></div></div><div class=paragraph><p>Οι επιλογές αυτές ρυθμίζουν τις διαφορετικές μεθόδους που έχει στη διάθεση του το sendmail, προκειμένου να πιστοποιήσει τους χρήστες. Αν θέλετε να χρησιμοποιήσετε κάποια μέθοδο διαφορετική από το pwcheck, δείτε την τεκμηρίωση που περιλαμβάνεται.</p></div></li><li><p>Τέλος, εκτελέστε <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> ενώ βρίσκεστε στον κατάλογο <span class=filename>/etc/mail</span>. Με τον τρόπο αυτό, θα χρησιμοποιηθεί το νέο σας <span class=filename>.mc</span> αρχείο και θα δημιουργηθεί ένα αρχείο <span class=filename>.cf</span> με όνομα <span class=filename>freebsd.cf</span> (ή οτιδήποτε όνομα είχατε δώσει στο αρχείο <span class=filename>.mc</span>). Χρησιμοποιήστε έπειτα την εντολή <code>make install restart</code>, η οποία θα αντιγράψει το αρχείο στο <span class=filename>sendmail.cf</span>, και θα επανεκκινήσει σωστά το sendmail. Για περισσότερες λεπτομέρειες σχετικά με αυτή τη διαδικασία, θα πρέπει να διαβάσετε το αρχείο <span class=filename>/etc/mail/Makefile</span>.</p></li></ol></div><div class=paragraph><p>Αν όλα πήγαν καλά, θα πρέπει να μπορείτε να δώσετε τα στοιχεία εισόδου σας στο πρόγραμμα που χρησιμοποιείτε για αποστολή και λήψη mail, και να στείλετε ένα δοκιμαστικό μήνυμα. Για να διερευνήσετε περισσότερο τη λειτουργία, θέστε την επιλογή <code>LogLevel</code> του sendmail στο 13 και παρακολουθήστε το <span class=filename>/var/log/maillog</span> για τυχόν λάθη.</p></div><div class=paragraph><p>Για περισσότερες πληροφορίες, παρακαλούμε να δείτε τη σελίδα του sendmail που αφορά την <a href=http://www.sendmail.org/~ca/email/auth.html>πιστοποίηση αυθεντικότητας στο SMTP</a>.</p></div></div><div class=sect2><h3 id=mail-agents>53.11. Προγράμματα Ταχυδρομείου για τον Χρήστη<a class=anchor href=#mail-agents></a></h3><div class=paragraph><p>Ένα πρόγραμμα Αντιπροσώπου Ταχυδρομείου Χρήστη (Mail User Agent, MUA), είναι μια εφαρμογή που χρησιμοποιείται για την αποστολή και λήψη email. Επιπλέον, καθώς το email "εξελίσσεται" και γίνεται πιο πολύπλοκο, τα MUA γίνονται όλο και ισχυρότερα όσο αφορά τον τρόπο που αλληλεπιδρούν με το email. Αυτό δίνει στους χρήστες περισσότερες λειτουργίες και ευελιξία. To FreeBSD περιέχει υποστήριξη για μεγάλο αριθμό από προγράμματα ταχυδρομείου, και όλα μπορούν να εγκατασταθούν πολύ εύκολα μέσω της <a href=./#ports>Συλλογής των Ports του FreeBSD</a>. Οι χρήστες μπορούν να επιλέξουν μεταξύ γραφικών προγραμμάτων, όπως το evolution ή το balsa, και προγράμματα κονσόλας όπως τα mutt, alpine ή <code>mail</code>, ή ακόμα και τις διεπαφές web που προσφέρονται από μερικούς μεγάλους οργανισμούς.</p></div><div class=sect3><h4 id=mail-command>53.11.1. mail<a class=anchor href=#mail-command></a></h4><div class=paragraph><p>Το <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> είναι το προεπιλεγμένο πρόγραμμα ταχυδρομείου (MUA) in FreeBSD. Πρόκειται για ένα MUA κονσόλας, το οποίο προσφέρει όλες τις βασικές λειτουργίες που απαιτούνται για την αποστολή και λήψη email σε μορφή κειμένου, αν και έχει περιορισμένες δυνατότητες όσο αφορά συνημμένα αρχεία και υποστηρίζει μόνο τοπικές θυρίδες.</p></div><div class=paragraph><p>Αν και το <code>mail</code> δεν υποστηρίζει εγγενώς τη λήψη email μέσω διακομιστών POP ή IMAP, είναι ωστόσο δυνατόν να κατεβάσετε τα email σε μια τοπική θυρίδα (<span class=filename>mbox</span>) χρησιμοποιώντας κάποια εφαρμογή όπως το fetchmail, το οποίο θα συζητήσουμε αργότερα σε αυτό το κεφάλαιο (<a href=#mail-fetchmail>Χρησιμοποιώντας το fetchmail</a>).</p></div><div class=paragraph><p>Για την αποστολή και λήψη email, εκτελέστε την εντολή <code>mail</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail</code></pre></div></div><div class=paragraph><p>Τα περιεχόμενα της θυρίδας του χρήστη στον κατάλογο <span class=filename>/var/mail</span> θα διαβαστούν αυτόματα από το πρόγραμμα <code>mail</code>. Αν η θυρίδα ταχυδρομείου είναι άδεια, το πρόγραμμα τερματίζεται με το μήνυμα ότι δεν βρέθηκε αλληλογραφία. Μετά την ανάγνωση της θυρίδας, ξεκινά η διεπαφή της εφαρμογής και εμφανίζεται μια λίστα με μηνύματα. Τα μηνύματα αριθμούνται αυτόματα, όπως φαίνεται στο παρακάτω παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mail version 8.1 6/6/93.  Type ? <span class=k>for </span>help.
<span class=s2>&#34;/var/mail/marcs&#34;</span>: 3 messages 3 new
<span class=o>&gt;</span>N  1 root@localhost        Mon Mar  8 14:05  14/510   <span class=s2>&#34;test&#34;</span>
 N  2 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;user account&#34;</span>
 N  3 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;sample&#34;</span></code></pre></div></div><div class=paragraph><p>Τα μηνύματα μπορούν πλέον να διαβαστούν με την εντολή <kbd>t</kbd> της εντολής <code>mail</code>, ακολουθούμενη με τον αριθμό του mail που θέλετε να εμφανιστεί. Στο παράδειγμα αυτό θα διαβάσουμε το πρώτο μήνυμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: <span class=nb>test
</span>Date: Mon,  8 Mar 2004 14:05:52 +0200 <span class=o>(</span>SAST<span class=o>)</span>
From: root@localhost <span class=o>(</span>Charlie Root<span class=o>)</span>

This is a <span class=nb>test </span>message, please reply <span class=k>if </span>you receive it.</code></pre></div></div><div class=paragraph><p>Όπως φαίνεται στο παραπάνω παράδειγμα, η χρήση του πλήκτρου <kbd>t</kbd> θα προκαλέσει την εμφάνιση του μηνύματος με πλήρεις επικεφαλίδες. Για να δείτε ξανά τη λίστα με τα μηνύματα, χρησιμοποιήστε το πλήκτρο <kbd>h</kbd>.</p></div><div class=paragraph><p>Αν το mail απαιτεί απάντηση, μπορείτε να χρησιμοποιήσετε την εντολή <code>mail</code> χρησιμοποιώντας τις ενσωματωμένες εντολές <kbd>R</kbd> ή <kbd>r</kbd>. Το πλήκτρο <kbd>R</kbd> οδηγεί το <code>mail</code> να απαντήσει μόνο στον αποστολέα του μηνύματος, ενώ το <kbd>r</kbd> απαντάει όχι μόνο στον αποστολέα, αλλά σε όλους τους παραλήπτες του μηνύματος. Μπορείτε επίσης να προσθέσετε μετά από τις εντολές αυτές, τον αριθμό του μηνύματος στο οποίο θέλετε να απαντήσετε. Αφού το κάνετε αυτό, θα πρέπει να γράψετε την απάντηση σας και να σημειώσετε το τέλος της γράφοντας μια μόνο <kbd>.</kbd> σε μια νέα γραμμή. Μπορείτε να δείτε ένα παράδειγμα παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; R 1
To: root@localhost
Subject: Re: <span class=nb>test

</span>Thank you, I did get your email.
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Για να στείλετε νέο mail, θα πρέπει να χρησιμοποιήσετε το πλήκτρο <kbd>m</kbd>, ακολουθούμενο από την διεύθυνση του παραλήπτη. Μπορείτε να δώσετε πολλαπλούς παραλήπτες, χωρίζοντας μεταξύ τους τις διευθύνσεις με <kbd>,</kbd>. Μπορείτε έπειτα να βάλετε το θέμα του μηνύματος και να συνεχίσετε με το περιεχόμενο. Το τέλος του μηνύματος καθορίζεται γράφοντας μια μοναδική <kbd>.</kbd> σε μια νέα γραμμή.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :<span class=o>)</span>
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Όσο βρίσκεστε μέσα στην εντολή <code>mail</code>, μπορείτε να χρησιμοποιήσετε το πλήκτρο <kbd>?</kbd> για την εμφάνιση βοήθειας οποιαδήποτε στιγμή. Μπορείτε επίσης να συμβουλευτείτε την σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> για περισσότερες πληροφορίες σχετικά με την εντολή <code>mail</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Όπως αναφέραμε προηγουμένως, η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> δεν σχεδιάστηκε αρχικά για να χειρίζεται συνημμένα, και για το λόγο αυτό οι δυνατότητες τις στο συγκεκριμένο θέμα είναι μικρές. Νεώτερα MUA, όπως το mutt, χειρίζονται τα συνημμένα με πολύ πιο έξυπνο τρόπο. Αλλά αν παρ' όλα αυτά επιθυμείτε να χρησιμοποιήσετε την εντολή <code>mail</code>, μάλλον θα σας φανεί χρήσιμο το port <a class=package href=https://cgit.freebsd.org/ports/tree/converters/mpack/>converters/mpack</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mutt-command>53.11.2. mutt<a class=anchor href=#mutt-command></a></h4><div class=paragraph><p>Το mutt είναι ένα μικρό, αλλά πολύ ισχυρό πρόγραμμα αποστολής και λήψης mail, με εξαιρετικά χαρακτηριστικά τα οποία περιλαμβάνουν:</p></div><div class=ulist><ul><li><p>Την ικανότητα να δείχνει μηνύματα με την μορφή συζητήσεων</p></li><li><p>Υποστήριξη PGP για ψηφιακή υπογραφή και κρυπτογράφηση email</p></li><li><p>Υποστήριξη MIME</p></li><li><p>Υποστήριξη Maildir</p></li><li><p>Εξαιρετικές δυνατότητες παραμετροποίησης</p></li></ul></div><div class=paragraph><p>Όλες αυτές οι δυνατότητες, κάνουν το mutt ένα από τα πιο εξελιγμένα διαθέσιμα προγράμματα ταχυδρομείου. Δείτε την τοποθεσία <a href=http://www.mutt.org>http://www.mutt.org</a> για περισσότερες πληροφορίες σχετικά με το mutt.</p></div><div class=paragraph><p>Μπορείτε να εγκαταστήσετε τη σταθερή έκδοση του mutt μέσω του port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt/>mail/mutt</a>, ενώ και η τρέχουσα υπό εξέλιξη έκδοση είναι διαθέσιμη μέσω του port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt-devel/>mail/mutt-devel</a>. Μετά την εγκατάσταση του port, μπορείτε να εκτελέσετε το mutt, με την ακόλουθη εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mutt</code></pre></div></div><div class=paragraph><p>Το mutt θα διαβάσει αυτόματα τα περιεχόμενα της θυρίδας ταχυδρομείου χρήστη στον κατάλογο <span class=filename>/var/mail</span>, και θα δείξει τα περιεχόμενα του αν αυτό είναι εφικτό. Αν δεν υπάρχουν mails στη θυρίδα του χρήστη, το mutt θα εισέλθει σε κατάσταση αναμονής εντολών. Το παρακάτω παράδειγμα, δείχνει το mutt να απεικονίζει μια λίστα μηνυμάτων:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt1.png alt=mutt1></div></div><div class=paragraph><p>Για να διαβάσετε ένα email, επιλέξτε το χρησιμοποιώντας τα βελάκια, και πιέστε <kbd>Enter</kbd>. Μπορείτε να δείτε ένα παράδειγμα απεικόνισης mail από το mutt παρακάτω:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt2.png alt=mutt2></div></div><div class=paragraph><p>Όπως και το <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, το mutt, σας επιτρέπει να απαντήσετε τόσο στον αποστολέα του μηνύματος, όσο και σε όλους τους παραλήπτες. Για να απαντήσετε μόνο στον αποστολέα του email, χρησιμοποιήστε το πλήκτρο <kbd>r</kbd>. Για να απαντήσετε στην ομάδα χρηστών η οποία περιλαμβάνει τόσο τον αρχικό αποστολέα, όσο και τους υπόλοιπους παραλήπτες του μηνύματος, χρησιμοποιήστε το πλήκτρο <kbd>g</kbd>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το mutt χρησιμοποιεί το <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> ως συντάκτη κειμένου για δημιουργία και απάντηση σε email. Η ρύθμιση αυτή μπορεί να αλλαχθεί από το χρήστη δημιουργώντας ή τροποποιώντας το αρχείο <span class=filename>.muttrc</span> στον προσωπικό του κατάλογο, και θέτοντας τη μεταβλητή <code>editor</code>, ή αλλάζοντας την μεταβλητή περιβάλλοντος <code>EDITOR</code>. Δείτε την τοποθεσία <a href=http://www.mutt.org/>http://www.mutt.org/</a> για περισσότερες πληροφορίες σχετικά με τη ρύθμιση του mutt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Για να συντάξετε ένα νέο μήνυμα, πιέστε το πλήκτρο <kbd>m</kbd>. Αφού γράψετε το κατάλληλο θέμα, το mutt θα ξεκινήσει το <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> επιτρέποντας σας να γράψετε το mail. Μόλις ολοκληρώσετε, αποθηκεύστε και τερματίστε το <code>vi</code> και το mutt θα συνεχίσει, δείχνοντας σας μια οθόνη περίληψης του mail το οποίο πρόκειται να σταλεί. Για να στείλετε το mail, πιέστε το πλήκτρο <kbd>y</kbd>. Μπορείτε να δείτε παρακάτω ένα παράδειγμα της οθόνης περίληψης:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt3.png alt=mutt3></div></div><div class=paragraph><p>Το mutt περιέχει επίσης εκτεταμένη βοήθεια, στην οποία μπορείτε να έχετε πρόσβαση σχεδόν από κάθε σημείο του μενού, πιέζοντας το πλήκτρο <kbd>?</kbd>. Η γραμμή στην κορυφή της οθόνης δείχνει επίσης τις συντομεύσεις πληκτρολογίου, όπου υπάρχουν.</p></div></div><div class=sect3><h4 id=alpine-command>53.11.3. alpine<a class=anchor href=#alpine-command></a></h4><div class=paragraph><p>Το alpine απευθύνεται κυρίως στον αρχάριο χρήστη, αλλά περιλαμβάνει επίσης κάποια προχωρημένα χαρακτηριστικά.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Το alpine έχει ιστορικό προβλημάτων ασφαλείας. Στο παρελθόν, ανακαλύφθηκαν προβλήματα που επέτρεπαν σε απομακρυσμένους εισβολείς να εκτελέσουν το δικό τους κώδικα στο τοπικό σύστημα, στέλνοντας απλώς ένα ειδικά διαμορφωμένο email. Όλα αυτά τα <em>γνωστά</em> προβλήματα έχουν πλέον διορθωθεί, αλλά ο κώδικας του alpine είναι γραμμένος με ιδιαίτερα ανασφαλή τρόπο, και ο Υπεύθυνος Ασφάλειας του FreeBSD, πιστεύει ότι είναι αρκετά πιθανόν να υπάρχουν και άλλα κενά ασφαλείας που δεν έχουν ανακαλυφθεί ακόμα. Εγκαταστήστε το alpine με δική σας ευθύνη.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η τρέχουσα έκδοση του alpine μπορεί να εγκατασταθεί χρησιμοποιώντας το port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/alpine/>mail/alpine</a>. Μετά την εγκατάσταση του port το alpine μπορεί να ξεκινήσει χρησιμοποιώντας την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% alpine</code></pre></div></div><div class=paragraph><p>Την πρώτη φορά που θα εκτελέσετε το alpine θα σας δείξει μια αρχική σελίδα χαιρετισμού, με μια σύντομη εισαγωγή, καθώς και μια αίτηση από την ομάδα ανάπτυξης του alpine να τους στείλετε ένα ανώνυμο mail το οποίο θα τους βοηθήσει να έχουν μια ιδέα για το πόσοι χρήστες χρησιμοποιούν το λογισμικό. Για να στείλετε αυτό το ανώνυμο μήνυμα, πιέστε <kbd>Enter</kbd>, ή εναλλακτικά πιέστε <kbd>E</kbd> για να κλείσετε την οθόνη χαιρετισμού χωρίς να στείλετε το ανώνυμο μήνυμα. Ένα παράδειγμα της σελίδας χαιρετισμού φαίνεται παρακάτω:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine1.png alt=pine1></div></div><div class=paragraph><p>Θα εμφανιστεί κατόπιν το κύριο μενού, στο οποίο μπορείτε να μετακινηθείτε εύκολα χρησιμοποιώντας τα βελάκια. Αυτό το κύριο μενού παρέχει πλήκτρα συντόμευσης για δημιουργία νέων mail, για ανίχνευση στους καταλόγους mail, και ακόμα για διαχείριση καταχωρήσεων στο βιβλίο διευθύνσεων. Κάτω από το κύριο μενού, εμφανίζονται συντομεύσεις πληκτρολογίου σχετικές με την εργασία που γίνεται τη συγκεκριμένη στιγμή.</p></div><div class=paragraph><p>Ο προεπιλεγμένος κατάλογος που ανοίγει το alpine είναι το <span class=filename>inbox</span>. Για να δείτε το ευρετήριο των μηνυμάτων, πιέστε το <kbd>I</kbd>, ή επιλέξτε το <span class=guimenuitem>MESSAGE INDEX</span> όπως φαίνεται παρακάτω:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine2.png alt=pine2></div></div><div class=paragraph><p>Το ευρετήριο μηνυμάτων δείχνει μηνύματα από τον τρέχοντα κατάλογο, και μπορείτε να μετακινηθείτε σε αυτό με τα βελάκια. Μπορείτε να διαβάσετε το επιλεγμένο μήνυμα, πιέζοντας το πλήκτρο <kbd>Enter</kbd>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine3.png alt=pine3></div></div><div class=paragraph><p>Στην εικόνα που φαίνεται παρακάτω, το alpine απεικονίζει ένα υπόδειγμα μηνύματος. Στο κάτω μέρος της οθόνης φαίνονται σχετικές συντομεύσεις πληκτρολογίου. Ένα παράδειγμα τέτοιας συντόμευσης, είναι το πλήκτρο <kbd>r</kbd> το οποίο λέει στο MUA να δημιουργήσει απάντηση προς το τρέχον μήνυμα που απεικονίζεται.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine4.png alt=pine4></div></div><div class=paragraph><p>Η απάντηση σε ένα mail μέσω του alpine γίνεται με τη χρήση του συντάκτη κειμένου pico, ο οποίος εγκαθίσταται από προεπιλογή μαζί με το alpine. Το pico διευκολύνει τη μετακίνηση μέσα στο μήνυμα, και είναι κάπως πιο εύκολο για τους αρχάριους χρήστες σε σχέση με το <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> ή το <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>. Μόλις ολοκληρώσετε την απάντηση, μπορείτε να στείλετε το μήνυμα πιέζοντας τα πλήκτρα <span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>. Το alpine θα σας ζητήσει να το επιβεβαιώσετε.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine5.png alt=pine5></div></div><div class=paragraph><p>Μπορείτε να προσαρμόσετε το alpine με τη χρήση της επιλογής <span class=guimenuitem>SETUP</span> από το κύριο μενού. Συμβουλευθείτε την τοποθεσία <a href=http://www.washington.edu/alpine/>http://www.washington.edu/alpine/</a> για περισσότερες πληροφορίες.</p></div></div></div><div class=sect2><h3 id=mail-fetchmail>53.12. Χρησιμοποιώντας το fetchmail<a class=anchor href=#mail-fetchmail></a></h3><div class=paragraph><p>Το fetchmail είναι ένας πλήρης πελάτης για IMAP και POP, ο οποίος επιτρέπει στους χρήστες να κατεβάζουν αυτόματα mail από απομακρυσμένους εξυπηρετητές IMAP και POP και να το αποθηκεύουν σε τοπικές θυρίδες, από όπου μπορεί έπειτα να υπάρχει πιο εύκολη πρόσβαση. Το fetchmail μπορεί να εγκατασταθεί χρησιμοποιώντας το port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> και παρέχει διάφορα χαρακτηριστικά, μερικά από τα οποία περιλαμβάνουν:</p></div><div class=ulist><ul><li><p>Υποστήριξη των πρωτοκόλλων POP3, APOP, KPOP, IMAP, ETRN και ODMR.</p></li><li><p>Δυνατότητα προώθησης email μέσω SMTP, το οποίο επιτρέπει τη φυσιολογική λειτουργία του φιλτραρίσματος, της προώθησης, και των παρωνυμίων (aliases).</p></li><li><p>Μπορεί να λειτουργήσει σε κατάσταση δαίμονα, ώστε να ελέγχει περιοδικά για νέα μηνύματα.</p></li><li><p>Μπορεί να ανακτά πολλαπλές θυρίδες και να τις προωθεί, ανάλογα με τις ρυθμίσεις του, σε διαφορετικούς τοπικούς χρήστες.</p></li></ul></div><div class=paragraph><p>Αν και είναι έξω από τους σκοπούς αυτού του κειμένου να εξηγήσει όλες τις δυνατότητες του fetchmail, θα αναφερθούμε σε κάποιες βασικές λειτουργίες. Το fetchmail χρησιμοποιεί ένα αρχείο ρυθμίσεων γνωστό ως <span class=filename>.fetchmailrc</span>, για να λειτουργήσει σωστά. Το αρχείο αυτό περιέχει τις πληροφορίες του εξυπηρετητή αλλά και τα στοιχεία εισόδου του χρήστη. Λόγω των ευαίσθητων πληροφοριών του αρχείου αυτού, σας συμβουλεύουμε να χρησιμοποιήσετε την παρακάτω εντολή ώστε η ανάγνωση του να επιτρέπεται μόνο από τον ιδιοκτήτη του:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>600 .fetchmailrc</code></pre></div></div><div class=paragraph><p>Το <span class=filename>.fetchmailrc</span> που φαίνεται παρακάτω είναι ένα παράδειγμα με το οποίο μπορείτε να κατεβάσετε τη θυρίδα ενός χρήστη μέσω του πρωτοκόλλου POP. Κατευθύνει το fetchmail να συνδεθεί στο <code>example.com</code> χρησιμοποιώντας όνομα χρήστη <code>joesoap</code> και κωδικό <code>XXX</code>. Το παράδειγμα υποθέτει ότι ο χρήστης <code>joesoap</code> είναι επίσης και χρήστης του τοπικού συστήματος.</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com protocol pop3 username &#34;joesoap&#34; password &#34;XXX&#34;</pre></div></div><div class=paragraph><p>Το επόμενο παράδειγμα, δείχνει σύνδεση σε πολλαπλούς POP και IMAP εξυπηρετητές, και ανακατευθύνει σε διαφορετικούς τοπικούς χρήστες όπου είναι απαραίτητο:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com proto pop3:
user &#34;joesoap&#34;, with password &#34;XXX&#34;, is &#34;jsoap&#34; here;
user &#34;andrea&#34;, with password &#34;XXXX&#34;;
poll example2.net proto imap:
user &#34;john&#34;, with password &#34;XXXXX&#34;, is &#34;myth&#34; here;</pre></div></div><div class=paragraph><p>Το βοηθητικό πρόγραμμα fetchmail μπορεί να λειτουργήσει σε κατάσταση δαίμονα, αν το εκτελέσετε με την επιλογή <code>-d</code>, ακολουθούμενη από ένα διάστημα (σε δευτερόλεπτα) το οποίο θα χρησιμοποιηθεί για να ερωτώνται οι εξυπηρετητές που είναι καταχωρημένοι στο αρχείο <span class=filename>.fetchmailrc</span>. Το παρακάτω παράδειγμα οδηγεί το fetchmail να ανιχνεύει για νέο mail κάθε 600 δευτερόλεπτα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% fetchmail <span class=nt>-d</span> 600</code></pre></div></div><div class=paragraph><p>Μπορείτε να βρείτε περισσότερες πληροφορίες για το fetchmail στην τοποθεσία <a href=http://fetchmail.berlios.de/>http://fetchmail.berlios.de/</a>.</p></div></div><div class=sect2><h3 id=mail-procmail>53.13. Χρησιμοποιώντας το procmail<a class=anchor href=#mail-procmail></a></h3><div class=paragraph><p>Το βοηθητικό πρόγραμμα procmail είναι μια απίστευτα ισχυρή εφαρμογή που μπορεί να χρησιμοποιηθεί για το φιλτράρισμα του εισερχόμενου mail. Επιτρέπει στους χρήστες να ορίζουν "κανόνες" οι οποίοι μπορεί να ταιριάζουν σε εισερχόμενα mail και να εκτελούν διάφορες λειτουργίες, ή να ανακατευθύνουν το mail σε εναλλακτικές θυρίδες ή / και διευθύνσεις ταχυδρομείου. Το procmail μπορεί να εγκατασταθεί χρησιμοποιώντας το port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/procmail/>mail/procmail</a>. Μετά την εγκατάσταση του, μπορεί να ενσωματωθεί σχεδόν σε οποιοδήποτε MTA. Συμβουλευθείτε την τεκμηρίωση του MTA που χρησιμοποιείτε για περισσότερες πληροφορίες. Εναλλακτικά, μπορείτε να ενσωματώσετε το procmail προσθέτοντας την ακόλουθη γραμμή σε ένα αρχείο <span class=filename>.forward</span> στον κατάλογο του χρήστη, χρησιμοποιώντας τις δυνατότητες του procmail:</p></div><div class="literalblock programlisting"><div class=content><pre>&#34;|exec /usr/local/bin/procmail || exit 75&#34;</pre></div></div><div class=paragraph><p>Στην παρακάτω ενότητα, θα δείξουμε μερικούς από τους βασικούς κανόνες του procmail, καθώς και σύντομες περιγραφές της λειτουργίας τους. Πρέπει να τοποθετήσετε αυτούς (και άλλους) κανόνες σε ένα αρχείο <span class=filename>.procmailrc</span>, το οποίο θα πρέπει να βρίσκεται μέσα στον κατάλογο του χρήστη:</p></div><div class=paragraph><p>Μπορείτε να βρείτε τους περισσότερους από αυτούς τους κανόνες, στη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=procmailex&amp;sektion=5&amp;format=html">procmailex(5)</a>.</p></div><div class=paragraph><p>Προώθηση όλου του email της διεύθυνσης <a href=mailto:user@example.com>user@example.com</a> προς την εξωτερική διεύθυνση <a href=mailto:goodmail@example2.com>goodmail@example2.com</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^From.*user@example.com
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Προώθηση όλων των email που είναι μικρότερα από 1000 bytes προς μια εξωτερική διεύθυνση email <a href=mailto:goodmail@example2.com>goodmail@example2.com</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* &lt; 1000
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Αποστολή όλου του mail που στάλθηκε προς το <a href=mailto:alternate@example.com>alternate@example.com</a> σε μια θυρίδα που καλείται <span class=filename>alternate</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^TOalternate@example.com
alternate</pre></div></div><div class=paragraph><p>Αποστολή όλου του mail με θέμα "Spam" προς το <span class=filename>/dev/null</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
^Subject:.*Spam
/dev/null</pre></div></div><div class=paragraph><p>Μια χρήσιμη λύση που ξεχωρίζει τα email από τις λίστες ταχυδρομείου <code>FreeBSD.org</code> και τοποθετεί το κάθε μήνυμα σε διαφορετική θυρίδα:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}</pre></div></div></div></div></div><div class=sect1><h2 id=network-servers>Chapter 54. Εξυπηρετητές Δικτύου<a class=anchor href=#network-servers></a></h2><div class=sectionbody><div class=sect2><h3 id=network-servers-synopsis>54.1. Σύνοψη<a class=anchor href=#network-servers-synopsis></a></h3><div class=paragraph><p>Το κεφάλαιο αυτό καλύπτει ορισμένες από τις πιο συχνά χρησιμοποιούμενες δικτυακές υπηρεσίες των συστημάτων UNIX®. Θα παρουσιάσουμε την εγκατάσταση, ρύθμιση, έλεγχο και συντήρηση πολλών διαφορετικών τύπων δικτυακών υπηρεσιών. Σε όλο το κεφάλαιο, για τη δική σας διευκόλυνση, υπάρχουν παραδείγματα διαφόρων αρχείων ρυθμίσεων.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να διαχειρίζεστε την υπηρεσία inetd.</p></li><li><p>Πως να ρυθμίσετε ένα δικτυακό σύστημα αρχείων.</p></li><li><p>Πως να ρυθμίσετε ένα εξυπηρετητή δικτυακών πληροφοριών για το διαμοιρασμό λογαριασμών χρηστών.</p></li><li><p>Πως να χρησιμοποιήσετε το DHCP για την αυτόματη ρύθμιση των παραμέτρων του δικτύου.</p></li><li><p>Πως να ρυθμίσετε ένα εξυπηρετητή ονομασίας περιοχών (DNS).</p></li><li><p>Πως να ρυθμίσετε τον εξυπηρετητή ιστοσελίδων Apache.</p></li><li><p>Πως να ρυθμίσετε ένα εξυπηρετητή μεταφοράς αρχείων (FTP).</p></li><li><p>Πως να ρυθμίσετε ένα εξυπηρετητή αρχείων και εκτυπωτών για πελάτες Windows® με χρήση της εφαρμογής Samba.</p></li><li><p>Πως να συγχρονίσετε την ημερομηνία και την ώρα, και να ρυθμίσετε ένα εξυπηρετητή ώρας με τη βοήθεια του NTP πρωτοκόλλου.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε τις βασικές έννοιες των αρχείων script <span class=filename>/etc/rc</span>.</p></li><li><p>Να είστε εξοικειωμένοι με τη βασική ορολογία των δικτύων.</p></li><li><p>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-inetd>54.2. The inetd"Super-Server"<a class=anchor href=#network-inetd></a></h3><div class=sect3><h4 id=network-inetd-overview>54.2.1. Overview<a class=anchor href=#network-inetd-overview></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> is sometimes referred to as the "Internet Super-Server" because it manages connections for several services. When a connection is received by inetd, it determines which program the connection is destined for, spawns the particular process and delegates the socket to it (the program is invoked with the service socket as its standard input, output and error descriptors). Running inetd for servers that are not heavily used can reduce the overall system load, when compared to running each daemon individually in stand-alone mode.</p></div><div class=paragraph><p>Primarily, inetd is used to spawn other daemons, but several trivial protocols are handled directly, such as chargen, auth, and daytime.</p></div><div class=paragraph><p>This section will cover the basics in configuring inetd through its command-line options and its configuration file, <span class=filename>/etc/inetd.conf</span>.</p></div></div><div class=sect3><h4 id=network-inetd-settings>54.2.2. Settings<a class=anchor href=#network-inetd-settings></a></h4><div class=paragraph><p>inetd is initialized through the <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> system. The <code>inetd_enable</code> option is set to <code>NO</code> by default, but may be turned on by sysinstall during installation, depending on the configuration chosen by the user. Placing:</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>or</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>into <span class=filename>/etc/rc.conf</span> will enable or disable inetd starting at boot time. The command:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/rc.d/inetd rcvar</pre></div></div><div class=paragraph><p>can be run to display the current effective setting.</p></div><div class=paragraph><p>Additionally, different command-line options can be passed to inetd via the <code>inetd_flags</code> option.</p></div></div><div class=sect3><h4 id=network-inetd-cmdline>54.2.3. Command-Line Options<a class=anchor href=#network-inetd-cmdline></a></h4><div class=paragraph><p>Like most server daemons, inetd has a number of options that it can be passed in order to modify its behaviour. The full list of options reads:</p></div><div class=paragraph><p><code>inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname] [-p filename] [-R rate] [-s maximum] [configuration file]</code></p></div><div class=paragraph><p>Options can be passed to inetd using the <code>inetd_flags</code> option in <span class=filename>/etc/rc.conf</span>. By default, <code>inetd_flags</code> is set to <code>-wW -C 60</code>, which turns on TCP wrapping for inetd’s services, and prevents any single IP address from requesting any service more than 60 times in any given minute.</p></div><div class=paragraph><p>Novice users may be pleased to note that these parameters usually do not need to be modified, although we mention the rate-limiting options below as they be useful should you find that you are receiving an excessive amount of connections. A full list of options can be found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> manual.</p></div><div class=dlist><dl><dt class=hdlist1>-c maximum</dt><dd><p>Specify the default maximum number of simultaneous invocations of each service; the default is unlimited. May be overridden on a per-service basis with the <code>max-child</code> parameter.</p></dd><dt class=hdlist1>-C rate</dt><dd><p>Specify the default maximum number of times a service can be invoked from a single IP address in one minute; the default is unlimited. May be overridden on a per-service basis with the <code>max-connections-per-ip-per-minute</code> parameter.</p></dd><dt class=hdlist1>-R rate</dt><dd><p>Specify the maximum number of times a service can be invoked in one minute; the default is 256. A rate of 0 allows an unlimited number of invocations.</p></dd><dt class=hdlist1>-s maximum</dt><dd><p>Specify the maximum number of times a service can be invoked from a single IP address at any one time; the default is unlimited. May be overridden on a per-service basis with the <code>max-child-per-ip</code> parameter.</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-conf>54.2.4. <span class=filename>inetd.conf</span><a class=anchor href=#network-inetd-conf></a></h4><div class=paragraph><p>Configuration of inetd is done via the file <span class=filename>/etc/inetd.conf</span>.</p></div><div class=paragraph><p>When a modification is made to <span class=filename>/etc/inetd.conf</span>, inetd can be forced to re-read its configuration file by running the command:</p></div><div id=network-inetd-reread class=exampleblock><div class=title>Παράδειγμα 24. Reloading the inetd configuration file</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/inetd reload</span></code></pre></div></div></div></div><div class=paragraph><p>Each line of the configuration file specifies an individual daemon. Comments in the file are preceded by a "#". The format of each entry in <span class=filename>/etc/inetd.conf</span> is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
user[:group][/login-class]
server-program
server-program-arguments</pre></div></div><div class=paragraph><p>An example entry for the <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> daemon using IPv4 might read:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre></div></div><div class=dlist><dl><dt class=hdlist1>service-name</dt><dd><p>This is the service name of the particular daemon. It must correspond to a service listed in <span class=filename>/etc/services</span>. This determines which port inetd must listen to. If a new service is being created, it must be placed in <span class=filename>/etc/services</span> first.</p></dd><dt class=hdlist1>socket-type</dt><dd><p>Either <code>stream</code>, <code>dgram</code>, <code>raw</code>, or <code>seqpacket</code>. <code>stream</code> must be used for connection-based, TCP daemons, while <code>dgram</code> is used for daemons utilizing the UDP transport protocol.</p></dd><dt class=hdlist1>protocol</dt><dd><p>One of the following:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Protocol</th><th class="tableblock halign-left valign-top">Explanation</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp, tcp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp, udp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Both TCP IPv4 and v6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Both UDP IPv4 and v6</p></td></tr></tbody></table></dd><dt class=hdlist1>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]</dt><dd><p><code>wait|nowait</code> indicates whether the daemon invoked from inetd is able to handle its own socket or not. <code>dgram</code> socket types must use the <code>wait</code> option, while stream socket daemons, which are usually multi-threaded, should use <code>nowait</code>. <code>wait</code> usually hands off multiple sockets to a single daemon, while <code>nowait</code> spawns a child daemon for each new socket.</p><div class=paragraph><p>The maximum number of child daemons inetd may spawn can be set using the <code>max-child</code> option. If a limit of ten instances of a particular daemon is needed, a <code>/10</code> would be placed after <code>nowait</code>. Specifying <code>/0</code> allows an unlimited number of children</p></div><div class=paragraph><p>In addition to <code>max-child</code>, two other options which limit the maximum connections from a single place to a particular daemon can be enabled. <code>max-connections-per-ip-per-minute</code> limits the number of connections from any particular IP address per minutes, e.g. a value of ten would limit any particular IP address connecting to a particular service to ten attempts per minute. <code>max-child-per-ip</code> limits the number of children that can be started on behalf on any single IP address at any moment. These options are useful to prevent intentional or unintentional excessive resource consumption and Denial of Service (DoS) attacks to a machine.</p></div><div class=paragraph><p>In this field, either of <code>wait</code> or <code>nowait</code> is mandatory. <code>max-child</code>, <code>max-connections-per-ip-per-minute</code> and <code>max-child-per-ip</code> are optional.</p></div><div class=paragraph><p>A stream-type multi-threaded daemon without any <code>max-child</code>, <code>max-connections-per-ip-per-minute</code> or <code>max-child-per-ip</code> limits would simply be: <code>nowait</code>.</p></div><div class=paragraph><p>The same daemon with a maximum limit of ten daemons would read: <code>nowait/10</code>.</p></div><div class=paragraph><p>The same setup with a limit of twenty connections per IP address per minute and a maximum total limit of ten child daemons would read: <code>nowait/10/20</code>.</p></div><div class=paragraph><p>These options are utilized by the default settings of the <a href="https://man.freebsd.org/cgi/man.cgi?query=fingerd&amp;sektion=8&amp;format=html">fingerd(8)</a> daemon, as seen here:</p></div><div class="literalblock programlisting"><div class=content><pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</pre></div></div><div class=paragraph><p>Finally, an example of this field with a maximum of 100 children in total, with a maximum of 5 for any one IP address would read: <code>nowait/100/0/5</code>.</p></div></dd><dt class=hdlist1>user</dt><dd><p>This is the username that the particular daemon should run as. Most commonly, daemons run as the <code>root</code> user. For security purposes, it is common to find some servers running as the <code>daemon</code> user, or the least privileged <code>nobody</code> user.</p></dd><dt class=hdlist1>server-program</dt><dd><p>The full path of the daemon to be executed when a connection is received. If the daemon is a service provided by inetd internally, then <code>internal</code> should be used.</p></dd><dt class=hdlist1>server-program-arguments</dt><dd><p>This works in conjunction with <code>server-program</code> by specifying the arguments, starting with <code>argv[0]</code>, passed to the daemon on invocation. If <code>mydaemon -d</code> is the command line, <code>mydaemon -d</code> would be the value of <code>server-program-arguments</code>. Again, if the daemon is an internal service, use <code>internal</code> here.</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-security>54.2.5. Security<a class=anchor href=#network-inetd-security></a></h4><div class=paragraph><p>Depending on the choices made at install time, many of inetd’s services may be enabled by default. If there is no apparent need for a particular daemon, consider disabling it. Place a "#" in front of the daemon in question in <span class=filename>/etc/inetd.conf</span>, and then <a href=#network-inetd-reread>reload the inetd configuration</a>. Some daemons, such as fingerd, may not be desired at all because they provide information that may be useful to an attacker.</p></div><div class=paragraph><p>Some daemons are not security-conscious and have long, or non-existent, timeouts for connection attempts. This allows an attacker to slowly send connections to a particular daemon, thus saturating available resources. It may be a good idea to place <code>max-connections-per-ip-per-minute</code>, <code>max-child</code> or <code>max-child-per-ip</code> limitations on certain daemons if you find that you have too many connections.</p></div><div class=paragraph><p>By default, TCP wrapping is turned on. Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> manual page for more information on placing TCP restrictions on various inetd invoked daemons.</p></div></div><div class=sect3><h4 id=network-inetd-misc>54.2.6. Miscellaneous<a class=anchor href=#network-inetd-misc></a></h4><div class=paragraph><p>daytime, time, echo, discard, chargen, and auth are all internally provided services of inetd.</p></div><div class=paragraph><p>The auth service provides identity network services, and is configurable to a certain degree, whilst the others are simply on or off.</p></div><div class=paragraph><p>Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> manual page for more in-depth information.</p></div></div></div><div class=sect2><h3 id=network-nfs>54.3. Network File System (NFS)<a class=anchor href=#network-nfs></a></h3><div class=paragraph><p>Among the many different file systems that FreeBSD supports is the Network File System, also known as NFS. NFS allows a system to share directories and files with others over a network. By using NFS, users and programs can access files on remote systems almost as if they were local files.</p></div><div class=paragraph><p>Some of the most notable benefits that NFS can provide are:</p></div><div class=ulist><ul><li><p>Local workstations use less disk space because commonly used data can be stored on a single machine and still remain accessible to others over the network.</p></li><li><p>There is no need for users to have separate home directories on every network machine. Home directories could be set up on the NFS server and made available throughout the network.</p></li><li><p>Storage devices such as floppy disks, CDROM drives, and Zip® drives can be used by other machines on the network. This may reduce the number of removable media drives throughout the network.</p></li></ul></div><div class=sect3><h4 id=_how_nfs_works>54.3.1. How NFS Works<a class=anchor href=#_how_nfs_works></a></h4><div class=paragraph><p>NFS consists of at least two main parts: a server and one or more clients. The client remotely accesses the data that is stored on the server machine. In order for this to function properly a few processes have to be configured and running.</p></div><div class=paragraph><p>The server has to be running the following daemons:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Daemon</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nfsd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The NFS daemon which services requests from the NFS clients.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>mountd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The NFS mount daemon which carries out the requests that <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsd&amp;sektion=8&amp;format=html">nfsd(8)</a> passes on to it.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpcbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This daemon allows NFS clients to discover which port the NFS server is using.</p></td></tr></tbody></table><div class=paragraph><p>The client can also run a daemon, known as nfsiod. The nfsiod daemon services the requests from the NFS server. This is optional, and improves performance, but is not required for normal and correct operation. See the <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsiod&amp;sektion=8&amp;format=html">nfsiod(8)</a> manual page for more information.</p></div></div><div class=sect3><h4 id=network-configuring-nfs>54.3.2. Configuring NFS<a class=anchor href=#network-configuring-nfs></a></h4><div class=paragraph><p>NFS configuration is a relatively straightforward process. The processes that need to be running can all start at boot time with a few modifications to your <span class=filename>/etc/rc.conf</span> file.</p></div><div class=paragraph><p>On the NFS server, make sure that the following options are configured in the <span class=filename>/etc/rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>rpcbind_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_flags=&#34;-r&#34;</pre></div></div><div class=paragraph><p>mountd runs automatically whenever the NFS server is enabled.</p></div><div class=paragraph><p>On the client, make sure this option is present in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nfs_client_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The <span class=filename>/etc/exports</span> file specifies which file systems NFS should export (sometimes referred to as "share"). Each line in <span class=filename>/etc/exports</span> specifies a file system to be exported and which machines have access to that file system. Along with what machines have access to that file system, access options may also be specified. There are many such options that can be used in this file but only a few will be mentioned here. You can easily discover other options by reading over the <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> manual page.</p></div><div class=paragraph><p>Here are a few example <span class=filename>/etc/exports</span> entries:</p></div><div class=paragraph><p>The following examples give an idea of how to export file systems, although the settings may be different depending on your environment and network configuration. For instance, to export the <span class=filename>/cdrom</span> directory to three example machines that have the same domain name as the server (hence the lack of a domain name for each) or have entries in your <span class=filename>/etc/hosts</span> file. The <code>-ro</code> flag makes the exported file system read-only. With this flag, the remote system will not be able to write any changes to the exported file system.</p></div><div class="literalblock programlisting"><div class=content><pre>/cdrom -ro host1 host2 host3</pre></div></div><div class=paragraph><p>The following line exports <span class=filename>/home</span> to three hosts by IP address. This is a useful setup if you have a private network without a DNS server configured. Optionally the <span class=filename>/etc/hosts</span> file could be configured for internal hostnames; please review <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> for more information. The <code>-alldirs</code> flag allows the subdirectories to be mount points. In other words, it will not mount the subdirectories but permit the client to mount only the directories that are required or needed.</p></div><div class="literalblock programlisting"><div class=content><pre>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre></div></div><div class=paragraph><p>The following line exports <span class=filename>/a</span> so that two clients from different domains may access the file system. The <code>-maproot=root</code> flag allows the <code>root</code> user on the remote system to write data on the exported file system as <code>root</code>. If the <code>-maproot=root</code> flag is not specified, then even if a user has <code>root</code> access on the remote system, he will not be able to modify files on the exported file system.</p></div><div class="literalblock programlisting"><div class=content><pre>/a  -maproot=root  host.example.com box.example.org</pre></div></div><div class=paragraph><p>In order for a client to access an exported file system, the client must have permission to do so. Make sure the client is listed in your <span class=filename>/etc/exports</span> file.</p></div><div class=paragraph><p>In <span class=filename>/etc/exports</span>, each line represents the export information for one file system to one host. A remote host can only be specified once per file system, and may only have one default entry. For example, assume that <span class=filename>/usr</span> is a single file system. The following <span class=filename>/etc/exports</span> would be invalid:</p></div><div class="literalblock programlisting"><div class=content><pre># Invalid when /usr is one file system
/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>One file system, <span class=filename>/usr</span>, has two lines specifying exports to the same host, <code>client</code>. The correct format for this situation is:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>The properties of one file system exported to a given host must all occur on one line. Lines without a client specified are treated as a single host. This limits how you can export file systems, but for most people this is not an issue.</p></div><div class=paragraph><p>The following is an example of a valid export list, where <span class=filename>/usr</span> and <span class=filename>/exports</span> are local file systems:</p></div><div class="literalblock programlisting"><div class=content><pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre></div></div><div class=paragraph><p>The mountd daemon must be forced to recheck the <span class=filename>/etc/exports</span> file whenever it has been modified, so the changes can take effect. This can be accomplished either by sending a HUP signal to the running daemon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div><div class=paragraph><p>or by invoking the <code>mountd</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> script with the appropriate parameter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/mountd onereload</span></code></pre></div></div><div class=paragraph><p>Please refer to <a href=./#configtuning-rcd>Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD</a> for more information about using rc scripts.</p></div><div class=paragraph><p>Alternatively, a reboot will make FreeBSD set everything up properly. A reboot is not necessary though. Executing the following commands as <code>root</code> should start everything up.</p></div><div class=paragraph><p>On the NFS server:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rpcbind</span>
<span class=c># nfsd -u -t -n 4</span>
<span class=c># mountd -r</span></code></pre></div></div><div class=paragraph><p>On the NFS client:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nfsiod -n 4</span></code></pre></div></div><div class=paragraph><p>Now everything should be ready to actually mount a remote file system. In these examples the server’s name will be <code>server</code> and the client’s name will be <code>client</code>. If you only want to temporarily mount a remote file system or would rather test the configuration, just execute a command like this as <code>root</code> on the client:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount server:/home /mnt</span></code></pre></div></div><div class=paragraph><p>This will mount the <span class=filename>/home</span> directory on the server at <span class=filename>/mnt</span> on the client. If everything is set up correctly you should be able to enter <span class=filename>/mnt</span> on the client and see all the files that are on the server.</p></div><div class=paragraph><p>If you want to automatically mount a remote file system each time the computer boots, add the file system to the <span class=filename>/etc/fstab</span> file. Here is an example:</p></div><div class="literalblock programlisting"><div class=content><pre>server:/home	/mnt	nfs	rw	0	0</pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> manual page lists all the available options.</p></div></div><div class=sect3><h4 id=_locking>54.3.3. Locking<a class=anchor href=#_locking></a></h4><div class=paragraph><p>Some applications (e.g. mutt) require file locking to operate correctly. In the case of NFS, rpc.lockd can be used for file locking. To enable it, add the following to the <span class=filename>/etc/rc.conf</span> file on both client and server (it is assumed that the NFS client and server are configured already):</p></div><div class="literalblock programlisting"><div class=content><pre>rpc_lockd_enable=&#34;YES&#34;
rpc_statd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Start the application by using:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/nfslocking start</span></code></pre></div></div><div class=paragraph><p>If real locking between the NFS clients and NFS server is not required, it is possible to let the NFS client do locking locally by passing <code>-L</code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a>. Refer to the <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a> manual page for further details.</p></div></div><div class=sect3><h4 id=_practical_uses>54.3.4. Practical Uses<a class=anchor href=#_practical_uses></a></h4><div class=paragraph><p>NFS has many practical uses. Some of the more common ones are listed below:</p></div><div class=ulist><ul><li><p>Set several machines to share a CDROM or other media among them. This is cheaper and often a more convenient method to install software on multiple machines.</p></li><li><p>On large networks, it might be more convenient to configure a central NFS server in which to store all the user home directories. These home directories can then be exported to the network so that users would always have the same home directory, regardless of which workstation they log in to.</p></li><li><p>Several machines could have a common <span class=filename>/usr/ports/distfiles</span> directory. That way, when you need to install a port on several machines, you can quickly access the source without downloading it on each machine.</p></li></ul></div></div><div class=sect3><h4 id=network-amd>54.3.5. Automatic Mounts with amd<a class=anchor href=#network-amd></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> (the automatic mounter daemon) automatically mounts a remote file system whenever a file or directory within that file system is accessed. Filesystems that are inactive for a period of time will also be automatically unmounted by amd. Using amd provides a simple alternative to permanent mounts, as permanent mounts are usually listed in <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>amd operates by attaching itself as an NFS server to the <span class=filename>/host</span> and <span class=filename>/net</span> directories. When a file is accessed within one of these directories, amd looks up the corresponding remote mount and automatically mounts it. <span class=filename>/net</span> is used to mount an exported file system from an IP address, while <span class=filename>/host</span> is used to mount an export from a remote hostname.</p></div><div class=paragraph><p>An access to a file within <span class=filename>/host/foobar/usr</span> would tell amd to attempt to mount the <span class=filename>/usr</span> export on the host <code>foobar</code>.</p></div><div class=exampleblock><div class=title>Παράδειγμα 25. Mounting an Export with amd</div><div class=content><div class=paragraph><p>You can view the available mounts of a remote host with the <code>showmount</code> command. For example, to view the mounts of a host named <code>foobar</code>, you can use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /host/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>As seen in the example, the <code>showmount</code> shows <span class=filename>/usr</span> as an export. When changing directories to <span class=filename>/host/foobar/usr</span>, amd attempts to resolve the hostname <code>foobar</code> and automatically mount the desired export.</p></div><div class=paragraph><p>amd can be started by the startup scripts by placing the following lines in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>amd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Additionally, custom flags can be passed to amd from the <code>amd_flags</code> option. By default, <code>amd_flags</code> is set to:</p></div><div class="literalblock programlisting"><div class=content><pre>amd_flags=&#34;-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map&#34;</pre></div></div><div class=paragraph><p>The <span class=filename>/etc/amd.map</span> file defines the default options that exports are mounted with. The <span class=filename>/etc/amd.conf</span> file defines some of the more advanced features of amd.</p></div><div class=paragraph><p>Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=amd.conf&amp;sektion=8&amp;format=html">amd.conf(8)</a> manual pages for more information.</p></div></div><div class=sect3><h4 id=network-nfs-integration>54.3.6. Problems Integrating with Other Systems<a class=anchor href=#network-nfs-integration></a></h4><div class=paragraph><p>Certain Ethernet adapters for ISA PC systems have limitations which can lead to serious network problems, particularly with NFS. This difficulty is not specific to FreeBSD, but FreeBSD systems are affected by it.</p></div><div class=paragraph><p>The problem nearly always occurs when (FreeBSD) PC systems are networked with high-performance workstations, such as those made by Silicon Graphics, Inc., and Sun Microsystems, Inc. The NFS mount will work fine, and some operations may succeed, but suddenly the server will seem to become unresponsive to the client, even though requests to and from other systems continue to be processed. This happens to the client system, whether the client is the FreeBSD system or the workstation. On many systems, there is no way to shut down the client gracefully once this problem has manifested itself. The only solution is often to reset the client, because the NFS situation cannot be resolved.</p></div><div class=paragraph><p>Though the "correct" solution is to get a higher performance and capacity Ethernet adapter for the FreeBSD system, there is a simple workaround that will allow satisfactory operation. If the FreeBSD system is the <em>server</em>, include the option <code>-w=1024</code> on the mount from the client. If the FreeBSD system is the <em>client</em>, then mount the NFS file system with the option <code>-r=1024</code>. These options may be specified using the fourth field of the <span class=filename>fstab</span> entry on the client for automatic mounts, or by using the <code>-o</code> parameter of the <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> command for manual mounts.</p></div><div class=paragraph><p>It should be noted that there is a different problem, sometimes mistaken for this one, when the NFS servers and clients are on different networks. If that is the case, make <em>certain</em> that your routers are routing the necessary UDP information, or you will not get anywhere, no matter what else you are doing.</p></div><div class=paragraph><p>In the following examples, <code>fastws</code> is the host (interface) name of a high-performance workstation, and <code>freebox</code> is the host (interface) name of a FreeBSD system with a lower-performance Ethernet adapter. Also, <span class=filename>/sharedfs</span> will be the exported NFS file system (see <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a>), and <span class=filename>/project</span> will be the mount point on the client for the exported file system. In all cases, note that additional options, such as <code>hard</code> or <code>soft</code> and <code>bg</code> may be desirable in your application.</p></div><div class=paragraph><p>Examples for the FreeBSD system (<code>freebox</code>) as the client in <span class=filename>/etc/fstab</span> on <code>freebox</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>fastws:/sharedfs /project nfs rw,-r=1024 0 0</pre></div></div><div class=paragraph><p>As a manual mount command on <code>freebox</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -r=1024 fastws:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>Examples for the FreeBSD system as the server in <span class=filename>/etc/fstab</span> on <code>fastws</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>freebox:/sharedfs /project nfs rw,-w=1024 0 0</pre></div></div><div class=paragraph><p>As a manual mount command on <code>fastws</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -w=1024 freebox:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>Nearly any 16-bit Ethernet adapter will allow operation without the above restrictions on the read or write size.</p></div><div class=paragraph><p>For anyone who cares, here is what happens when the failure occurs, which also explains why it is unrecoverable. NFS typically works with a "block" size of 8 K (though it may do fragments of smaller sizes). Since the maximum Ethernet packet is around 1500 bytes, the NFS "block" gets split into multiple Ethernet packets, even though it is still a single unit to the upper-level code, and must be received, assembled, and <em>acknowledged</em> as a unit. The high-performance workstations can pump out the packets which comprise the NFS unit one right after the other, just as close together as the standard allows. On the smaller, lower capacity cards, the later packets overrun the earlier packets of the same unit before they can be transferred to the host and the unit as a whole cannot be reconstructed or acknowledged. As a result, the workstation will time out and try again, but it will try again with the entire 8 K unit, and the process will be repeated, ad infinitum.</p></div><div class=paragraph><p>By keeping the unit size below the Ethernet packet size limitation, we ensure that any complete Ethernet packet received can be acknowledged individually, avoiding the deadlock situation.</p></div><div class=paragraph><p>Overruns may still occur when a high-performance workstations is slamming data out to a PC system, but with the better cards, such overruns are not guaranteed on NFS "units". When an overrun occurs, the units affected will be retransmitted, and there will be a fair chance that they will be received, assembled, and acknowledged.</p></div></div></div><div class=sect2><h3 id=network-nis>54.4. Network Information System (NIS/YP)<a class=anchor href=#network-nis></a></h3><div class=sect3><h4 id=_what_is_it>54.4.1. What Is It?<a class=anchor href=#_what_is_it></a></h4><div class=paragraph><p>NIS, which stands for Network Information Services, was developed by Sun Microsystems to centralize administration of UNIX® (originally SunOS™) systems. It has now essentially become an industry standard; all major UNIX® like systems (Solaris™, HP-UX, AIX®, Linux, NetBSD, OpenBSD, FreeBSD, etc) support NIS.</p></div><div class=paragraph><p>NIS was formerly known as Yellow Pages, but because of trademark issues, Sun changed the name. The old term (and yp) is still often seen and used.</p></div><div class=paragraph><p>It is a RPC-based client/server system that allows a group of machines within an NIS domain to share a common set of configuration files. This permits a system administrator to set up NIS client systems with only minimal configuration data and add, remove or modify configuration data from a single location.</p></div><div class=paragraph><p>It is similar to the Windows NT® domain system; although the internal implementation of the two are not at all similar, the basic functionality can be compared.</p></div></div><div class=sect3><h4 id=_termsprocesses_you_should_know>54.4.2. Terms/Processes You Should Know<a class=anchor href=#_termsprocesses_you_should_know></a></h4><div class=paragraph><p>There are several terms and several important user processes that you will come across when attempting to implement NIS on FreeBSD, whether you are trying to create an NIS server or act as an NIS client:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Term</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>NIS domainname</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>An NIS master server and all of its clients (including its slave servers) have a NIS domainname. Similar to an Windows NT® domain name, the NIS domainname does not have anything to do with DNS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpcbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Must be running in order to enable RPC (Remote Procedure Call, a network protocol used by NIS). If rpcbind is not running, it will be impossible to run an NIS server, or to act as an NIS client.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"Binds" an NIS client to its NIS server. It will take the NIS domainname from the system, and using RPC, connect to the server. ypbind is the core of client-server communication in an NIS environment; if ypbind dies on a client machine, it will not be able to access the NIS server.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypserv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Should only be running on NIS servers; this is the NIS server process itself. If <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> dies, then the server will no longer be able to respond to NIS requests (hopefully, there is a slave server to take over for it). There are some implementations of NIS (but not the FreeBSD one), that do not try to reconnect to another server if the server it used before dies. Often, the only thing that helps in this case is to restart the server process (or even the whole server) or the ypbind process on the client.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpc.yppasswdd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Another process that should only be running on NIS master servers; this is a daemon that will allow NIS clients to change their NIS passwords. If this daemon is not running, users will have to login to the NIS master server and change their passwords there.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_how_does_it_work>54.4.3. How Does It Work?<a class=anchor href=#_how_does_it_work></a></h4><div class=paragraph><p>There are three types of hosts in an NIS environment: master servers, slave servers, and clients. Servers act as a central repository for host configuration information. Master servers hold the authoritative copy of this information, while slave servers mirror this information for redundancy. Clients rely on the servers to provide this information to them.</p></div><div class=paragraph><p>Information in many files can be shared in this manner. The <span class=filename>master.passwd</span>, <span class=filename>group</span>, and <span class=filename>hosts</span> files are commonly shared via NIS. Whenever a process on a client needs information that would normally be found in these files locally, it makes a query to the NIS server that it is bound to instead.</p></div><div class=sect4><h5 id=_machine_types>54.4.3.1. Machine Types<a class=anchor href=#_machine_types></a></h5><div class=ulist><ul><li><p>A <em>NIS master server</em>. This server, analogous to a Windows NT® primary domain controller, maintains the files used by all of the NIS clients. The <span class=filename>passwd</span>, <span class=filename>group</span>, and other various files used by the NIS clients live on the master server.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is possible for one machine to be an NIS master server for more than one NIS domain. However, this will not be covered in this introduction, which assumes a relatively small-scale NIS environment.</p></div></td></tr></tbody></table></div></li><li><p><em>NIS slave servers</em>. Similar to the Windows NT® backup domain controllers, NIS slave servers maintain copies of the NIS master’s data files. NIS slave servers provide the redundancy, which is needed in important environments. They also help to balance the load of the master server: NIS Clients always attach to the NIS server whose response they get first, and this includes slave-server-replies.</p></li><li><p><em>NIS clients</em>. NIS clients, like most Windows NT® workstations, authenticate against the NIS server (or the Windows NT® domain controller in the Windows NT® workstations case) to log on.</p></li></ul></div></div></div><div class=sect3><h4 id=_using_nisyp>54.4.4. Using NIS/YP<a class=anchor href=#_using_nisyp></a></h4><div class=paragraph><p>This section will deal with setting up a sample NIS environment.</p></div><div class=sect4><h5 id=_planning>54.4.4.1. Planning<a class=anchor href=#_planning></a></h5><div class=paragraph><p>Let us assume that you are the administrator of a small university lab. This lab, which consists of 15 FreeBSD machines, currently has no centralized point of administration; each machine has its own <span class=filename>/etc/passwd</span> and <span class=filename>/etc/master.passwd</span>. These files are kept in sync with each other only through manual intervention; currently, when you add a user to the lab, you must run <code>adduser</code> on all 15 machines. Clearly, this has to change, so you have decided to convert the lab to use NIS, using two of the machines as servers.</p></div><div class=paragraph><p>Therefore, the configuration of the lab now looks something like:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Machine name</th><th class="tableblock halign-left valign-top">IP address</th><th class="tableblock halign-left valign-top">Machine role</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ellington</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS master</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>coltrane</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS slave</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>basie</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Faculty workstation</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bird</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Client machine</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cli[1-11]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.[6-17]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Other client machines</p></td></tr></tbody></table><div class=paragraph><p>If you are setting up a NIS scheme for the first time, it is a good idea to think through how you want to go about it. No matter what the size of your network, there are a few decisions that need to be made.</p></div><div class=sect5><h6 id=_choosing_a_nis_domain_name>54.4.4.1.1. Choosing a NIS Domain Name<a class=anchor href=#_choosing_a_nis_domain_name></a></h6><div class=paragraph><p>This might not be the "domainname" that you are used to. It is more accurately called the "NIS domainname". When a client broadcasts its requests for info, it includes the name of the NIS domain that it is part of. This is how multiple servers on one network can tell which server should answer which request. Think of the NIS domainname as the name for a group of hosts that are related in some way.</p></div><div class=paragraph><p>Some organizations choose to use their Internet domainname for their NIS domainname. This is not recommended as it can cause confusion when trying to debug network problems. The NIS domainname should be unique within your network and it is helpful if it describes the group of machines it represents. For example, the Art department at Acme Inc. might be in the "acme-art" NIS domain. For this example, assume you have chosen the name <code>test-domain</code>.</p></div><div class=paragraph><p>However, some operating systems (notably SunOS™) use their NIS domain name as their Internet domain name. If one or more machines on your network have this restriction, you <em>must</em> use the Internet domain name as your NIS domain name.</p></div></div><div class=sect5><h6 id=_physical_server_requirements>54.4.4.1.2. Physical Server Requirements<a class=anchor href=#_physical_server_requirements></a></h6><div class=paragraph><p>There are several things to keep in mind when choosing a machine to use as a NIS server. One of the unfortunate things about NIS is the level of dependency the clients have on the server. If a client cannot contact the server for its NIS domain, very often the machine becomes unusable. The lack of user and group information causes most systems to temporarily freeze up. With this in mind you should make sure to choose a machine that will not be prone to being rebooted regularly, or one that might be used for development. The NIS server should ideally be a stand alone machine whose sole purpose in life is to be an NIS server. If you have a network that is not very heavily used, it is acceptable to put the NIS server on a machine running other services, just keep in mind that if the NIS server becomes unavailable, it will affect <em>all</em> of your NIS clients adversely.</p></div></div></div><div class=sect4><h5 id=_nis_servers>54.4.4.2. NIS Servers<a class=anchor href=#_nis_servers></a></h5><div class=paragraph><p>The canonical copies of all NIS information are stored on a single machine called the NIS master server. The databases used to store the information are called NIS maps. In FreeBSD, these maps are stored in <span class=filename>/var/yp/[domainname]</span> where <span class=filename>[domainname]</span> is the name of the NIS domain being served. A single NIS server can support several domains at once, therefore it is possible to have several such directories, one for each supported domain. Each domain will have its own independent set of maps.</p></div><div class=paragraph><p>NIS master and slave servers handle all NIS requests with the <code>ypserv</code> daemon. <code>ypserv</code> is responsible for receiving incoming requests from NIS clients, translating the requested domain and map name to a path to the corresponding database file and transmitting data from the database back to the client.</p></div><div class=sect5><h6 id=_setting_up_a_nis_master_server>54.4.4.2.1. Setting Up a NIS Master Server<a class=anchor href=#_setting_up_a_nis_master_server></a></h6><div class=paragraph><p>Setting up a master NIS server can be relatively straight forward, depending on your needs. FreeBSD comes with support for NIS out-of-the-box. All you need is to add the following lines to <span class=filename>/etc/rc.conf</span>, and FreeBSD will do the rest for you.</p></div><div class="exampleblock procedure"><div class=content><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;</pre></div></div><div class=paragraph><p>This line will set the NIS domainname to <code>test-domain</code> upon network setup (e.g. after reboot).</p></div><div class="literalblock programlisting"><div class=content><pre>nis_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>This will tell FreeBSD to start up the NIS server processes when the networking is next brought up.</p></div><div class="literalblock programlisting"><div class=content><pre>nis_yppasswdd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>This will enable the <code>rpc.yppasswdd</code> daemon which, as mentioned above, will allow users to change their NIS password from a client machine.</p></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Depending on your NIS setup, you may need to add further entries. See the <a href=#network-nis-server-is-client>section about NIS servers that are also NIS clients</a>, below, for details.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Now, all you have to do is to run the command <code>/etc/netstart</code> as superuser. It will set up everything for you, using the values you defined in <span class=filename>/etc/rc.conf</span>.</p></div></div><div class=sect5><h6 id=_initializing_the_nis_maps>54.4.4.2.2. Initializing the NIS Maps<a class=anchor href=#_initializing_the_nis_maps></a></h6><div class=paragraph><p>The <em>NIS maps</em> are database files, that are kept in the <span class=filename>/var/yp</span> directory. They are generated from configuration files in the <span class=filename>/etc</span> directory of the NIS master, with one exception: the <span class=filename>/etc/master.passwd</span> file. This is for a good reason, you do not want to propagate passwords to your <code>root</code> and other administrative accounts to all the servers in the NIS domain. Therefore, before we initialize the NIS maps, you should:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/master.passwd /var/yp/master.passwd</span>
<span class=c># cd /var/yp</span>
<span class=c># vi master.passwd</span></code></pre></div></div><div class=paragraph><p>You should remove all entries regarding system accounts (<code>bin</code>, <code>tty</code>, <code>kmem</code>, <code>games</code>, etc), as well as any accounts that you do not want to be propagated to the NIS clients (for example <code>root</code> and any other UID 0 (superuser) accounts).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Make sure the <span class=filename>/var/yp/master.passwd</span> is neither group nor world readable (mode 600)! Use the <code>chmod</code> command, if appropriate.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When you have finished, it is time to initialize the NIS maps! FreeBSD includes a script named <code>ypinit</code> to do this for you (see its manual page for more information). Note that this script is available on most UNIX® Operating Systems, but not on all. On Digital UNIX/Compaq Tru64 UNIX it is called <code>ypsetup</code>. Because we are generating maps for an NIS master, we are going to pass the <code>-m</code> option to <code>ypinit</code>. To generate the NIS maps, assuming you already performed the steps above, run:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# ypinit <span class=nt>-m</span> test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] y

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</span></code></pre></div></div><div class=paragraph><p><code>ypinit</code> should have created <span class=filename>/var/yp/Makefile</span> from <span class=filename>/var/yp/Makefile.dist</span>. When created, this file assumes that you are operating in a single server NIS environment with only FreeBSD machines. Since <code>test-domain</code> has a slave server as well, you must edit <span class=filename>/var/yp/Makefile</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/Makefile</code></pre></div></div><div class=paragraph><p>You should comment out the line that says</p></div><div class="literalblock programlisting"><div class=content><pre>NOPUSH = &#34;True&#34;</pre></div></div><div class=paragraph><p>(if it is not commented out already).</p></div></div><div class=sect5><h6 id=_setting_up_a_nis_slave_server>54.4.4.2.3. Setting up a NIS Slave Server<a class=anchor href=#_setting_up_a_nis_slave_server></a></h6><div class=paragraph><p>Setting up an NIS slave server is even more simple than setting up the master. Log on to the slave server and edit the file <span class=filename>/etc/rc.conf</span> as you did before. The only difference is that we now must use the <code>-s</code> option when running <code>ypinit</code>. The <code>-s</code> option requires the name of the NIS master be passed to it as well, so our command line looks like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>coltrane# ypinit <span class=nt>-s</span> ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don&#39;</span>t forget to update map ypservers on ellington.</code></pre></div></div><div class=paragraph><p>You should now have a directory called <span class=filename>/var/yp/test-domain</span>. Copies of the NIS master server’s maps should be in this directory. You will need to make sure that these stay updated. The following <span class=filename>/etc/crontab</span> entries on your slave servers should do the job:</p></div><div class="literalblock programlisting"><div class=content><pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre></div></div><div class=paragraph><p>These two lines force the slave to sync its maps with the maps on the master server. Although these entries are not mandatory, since the master server attempts to ensure any changes to its NIS maps are communicated to its slaves and because password information is vital to systems depending on the server, it is a good idea to force the updates. This is more important on busy networks where map updates might not always complete.</p></div><div class=paragraph><p>Now, run the command <code>/etc/netstart</code> on the slave server as well, which again starts the NIS server.</p></div></div></div><div class=sect4><h5 id=_nis_clients>54.4.4.3. NIS Clients<a class=anchor href=#_nis_clients></a></h5><div class=paragraph><p>An NIS client establishes what is called a binding to a particular NIS server using the <code>ypbind</code> daemon. <code>ypbind</code> checks the system’s default domain (as set by the <code>domainname</code> command), and begins broadcasting RPC requests on the local network. These requests specify the name of the domain for which <code>ypbind</code> is attempting to establish a binding. If a server that has been configured to serve the requested domain receives one of the broadcasts, it will respond to <code>ypbind</code>, which will record the server’s address. If there are several servers available (a master and several slaves, for example), <code>ypbind</code> will use the address of the first one to respond. From that point on, the client system will direct all of its NIS requests to that server. <code>ypbind</code> will occasionally "ping" the server to make sure it is still up and running. If it fails to receive a reply to one of its pings within a reasonable amount of time, <code>ypbind</code> will mark the domain as unbound and begin broadcasting again in the hopes of locating another server.</p></div><div class=sect5><h6 id=_setting_up_a_nis_client>54.4.4.3.1. Setting Up a NIS Client<a class=anchor href=#_setting_up_a_nis_client></a></h6><div class=paragraph><p>Setting up a FreeBSD machine to be a NIS client is fairly straightforward.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Edit the file <span class=filename>/etc/rc.conf</span> and add the following lines in order to set the NIS domainname and start <code>ypbind</code> upon network startup:</p><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre></div></div></li><li><p>To import all possible password entries from the NIS server, remove all user accounts from your <span class=filename>/etc/master.passwd</span> file and use <code>vipw</code> to add the following line to the end of the file:</p><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This line will afford anyone with a valid account in the NIS server’s password maps an account. There are many ways to configure your NIS client by changing this line. See the <a href=#network-netgroups>netgroups section</a> below for more information. For more detailed reading see O’Reilly’s book on <code>Managing NFS and NIS</code>.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>You should keep at least one local account (i.e. not imported via NIS) in your <span class=filename>/etc/master.passwd</span> and this account should also be a member of the group <code>wheel</code>. If there is something wrong with NIS, this account can be used to log in remotely, become <code>root</code>, and fix things.</p></div></td></tr></tbody></table></div></li><li><p>To import all possible group entries from the NIS server, add this line to your <span class=filename>/etc/group</span> file:</p><div class="literalblock programlisting"><div class=content><pre>+:*::</pre></div></div></li></ol></div></div></div><div class=paragraph><p>After completing these steps, you should be able to run <code>ypcat passwd</code> and see the NIS server’s passwd map.</p></div></div></div></div><div class=sect3><h4 id=_nis_security>54.4.5. NIS Security<a class=anchor href=#_nis_security></a></h4><div class=paragraph><p>In general, any remote user can issue an RPC to <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> and retrieve the contents of your NIS maps, provided the remote user knows your domainname. To prevent such unauthorized transactions, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> supports a feature called "securenets" which can be used to restrict access to a given set of hosts. At startup, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> will attempt to load the securenets information from a file called <span class=filename>/var/yp/securenets</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This path varies depending on the path specified with the <code>-p</code> option. This file contains entries that consist of a network specification and a network mask separated by white space. Lines starting with "#" are considered to be comments. A sample securenets file might look like this:</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</pre></div></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> receives a request from an address that matches one of these rules, it will process the request normally. If the address fails to match a rule, the request will be ignored and a warning message will be logged. If the <span class=filename>/var/yp/securenets</span> file does not exist, <code>ypserv</code> will allow connections from any host.</p></div><div class=paragraph><p>The <code>ypserv</code> program also has support for Wietse Venema’s TCP Wrapper package. This allows the administrator to use the TCP Wrapper configuration files for access control instead of <span class=filename>/var/yp/securenets</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While both of these access control mechanisms provide some security, they, like the privileged port test, are vulnerable to "IP spoofing" attacks. All NIS-related traffic should be blocked at your firewall.</p></div><div class=paragraph><p>Servers using <span class=filename>/var/yp/securenets</span> may fail to serve legitimate NIS clients with archaic TCP/IP implementations. Some of these implementations set all host bits to zero when doing broadcasts and/or fail to observe the subnet mask when calculating the broadcast address. While some of these problems can be fixed by changing the client configuration, other problems may force the retirement of the client systems in question or the abandonment of <span class=filename>/var/yp/securenets</span>.</p></div><div class=paragraph><p>Using <span class=filename>/var/yp/securenets</span> on a server with such an archaic implementation of TCP/IP is a really bad idea and will lead to loss of NIS functionality for large parts of your network.</p></div><div class=paragraph><p>The use of the TCP Wrapper package increases the latency of your NIS server. The additional delay may be long enough to cause timeouts in client programs, especially in busy networks or with slow NIS servers. If one or more of your client systems suffers from these symptoms, you should convert the client systems in question into NIS slave servers and force them to bind to themselves.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_barring_some_users_from_logging_on>54.4.6. Barring Some Users from Logging On<a class=anchor href=#_barring_some_users_from_logging_on></a></h4><div class=paragraph><p>In our lab, there is a machine <code>basie</code> that is supposed to be a faculty only workstation. We do not want to take this machine out of the NIS domain, yet the <span class=filename>passwd</span> file on the master NIS server contains accounts for both faculty and students. What can we do?</p></div><div class=paragraph><p>There is a way to bar specific users from logging on to a machine, even if they are present in the NIS database. To do this, all you must do is add <code>-username</code> to the end of the <span class=filename>/etc/master.passwd</span> file on the client machine, where <em>username</em> is the username of the user you wish to bar from logging in. This should preferably be done using <code>vipw</code>, since <code>vipw</code> will sanity check your changes to <span class=filename>/etc/master.passwd</span>, as well as automatically rebuild the password database when you finish editing. For example, if we wanted to bar user <code>bill</code> from logging on to <code>basie</code> we would:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>basie# vipw
<span class=o>[</span>add <span class=nt>-bill</span> to the end, <span class=nb>exit</span><span class=o>]</span>
vipw: rebuilding the database...
vipw: <span class=k>done

</span>basie# <span class=nb>cat</span> /etc/master.passwd

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class=k>*</span>:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:<span class=k>*</span>:2:5::0:0:System &amp;:/:/sbin/nologin
bin:<span class=k>*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
<span class=nb>tty</span>:<span class=k>*</span>:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:<span class=k>*</span>:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:<span class=k>*</span>:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:<span class=k>*</span>:8:8::0:0:News Subsystem:/:/sbin/nologin
man:<span class=k>*</span>:9:9::0:0:Mister Man Pages:/usr/shared/man:/sbin/nologin
<span class=nb>bind</span>:<span class=k>*</span>:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:<span class=k>*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class=k>*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:<span class=k>*</span>:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:<span class=k>*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
<span class=nt>-bill</span>

basie#</code></pre></div></div></div><div class=sect3><h4 id=network-netgroups>54.4.7. Using Netgroups<a class=anchor href=#network-netgroups></a></h4><div class=paragraph><p>The method shown in the previous section works reasonably well if you need special rules for a very small number of users and/or machines. On larger networks, you <em>will</em> forget to bar some users from logging onto sensitive machines, or you may even have to modify each machine separately, thus losing the main benefit of NIS: <em>centralized</em> administration.</p></div><div class=paragraph><p>The NIS developers' solution for this problem is called <em>netgroups</em>. Their purpose and semantics can be compared to the normal groups used by UNIX® file systems. The main differences are the lack of a numeric ID and the ability to define a netgroup by including both user accounts and other netgroups.</p></div><div class=paragraph><p>Netgroups were developed to handle large, complex networks with hundreds of users and machines. On one hand, this is a Good Thing if you are forced to deal with such a situation. On the other hand, this complexity makes it almost impossible to explain netgroups with really simple examples. The example used in the remainder of this section demonstrates this problem.</p></div><div class=paragraph><p>Let us assume that your successful introduction of NIS in your laboratory caught your superiors' interest. Your next job is to extend your NIS domain to cover some of the other machines on campus. The two tables contain the names of the new users and new machines as well as brief descriptions of them.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">User Name(s)</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>alpha</code>, <code>beta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Normal employees of the IT department</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>charlie</code>, <code>delta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The new apprentices of the IT department</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>echo</code>, <code>foxtrott</code>, <code>golf</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ordinary employees</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>able</code>, <code>baker</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The current interns</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machine Name(s)</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>war</code>, <code>death</code>, <code>famine</code>, <code>pollution</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Your most important servers. Only the IT employees are allowed to log onto these machines.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pride</code>, <code>greed</code>, <code>envy</code>, <code>wrath</code>, <code>lust</code>, <code>sloth</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Less important servers. All members of the IT department are allowed to login onto these machines.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>one</code>, <code>two</code>, <code>three</code>, <code>four</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ordinary workstations. Only the <em>real</em> employees are allowed to use these machines.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>trashcan</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A very old machine without any critical data. Even the intern is allowed to use this box.</p></td></tr></tbody></table><div class=paragraph><p>If you tried to implement these restrictions by separately blocking each user, you would have to add one <code>-user</code> line to each system’s <span class=filename>passwd</span> for each user who is not allowed to login onto that system. If you forget just one entry, you could be in trouble. It may be feasible to do this correctly during the initial setup, however you <em>will</em> eventually forget to add the lines for new users during day-to-day operations. After all, Murphy was an optimist.</p></div><div class=paragraph><p>Handling this situation with netgroups offers several advantages. Each user need not be handled separately; you assign a user to one or more netgroups and allow or forbid logins for all members of the netgroup. If you add a new machine, you will only have to define login restrictions for netgroups. If a new user is added, you will only have to add the user to one or more netgroups. Those changes are independent of each other: no more "for each combination of user and machine do…​" If your NIS setup is planned carefully, you will only have to modify exactly one central configuration file to grant or deny access to machines.</p></div><div class=paragraph><p>The first step is the initialization of the NIS map netgroup. FreeBSD’s <a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a> does not create this map by default, but its NIS implementation will support it once it has been created. To create an empty map, simply type</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/netgroup</code></pre></div></div><div class=paragraph><p>and start adding content. For our example, we need at least four netgroups: IT employees, IT apprentices, normal employees and interns.</p></div><div class="literalblock programlisting"><div class=content><pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre></div></div><div class=paragraph><p><code>IT_EMP</code>, <code>IT_APP</code> etc. are the names of the netgroups. Each bracketed group adds one or more user accounts to it. The three fields inside a group are:</p></div><div class="olist arabic"><ol class=arabic><li><p>The name of the host(s) where the following items are valid. If you do not specify a hostname, the entry is valid on all hosts. If you do specify a hostname, you will enter a realm of darkness, horror and utter confusion.</p></li><li><p>The name of the account that belongs to this netgroup.</p></li><li><p>The NIS domain for the account. You can import accounts from other NIS domains into your netgroup if you are one of the unlucky fellows with more than one NIS domain.</p></li></ol></div><div class=paragraph><p>Each of these fields can contain wildcards. See <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a> for details.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Netgroup names longer than 8 characters should not be used, especially if you have machines running other operating systems within your NIS domain. The names are case sensitive; using capital letters for your netgroup names is an easy way to distinguish between user, machine and netgroup names.</p></div><div class=paragraph><p>Some NIS clients (other than FreeBSD) cannot handle netgroups with a large number of entries. For example, some older versions of SunOS™ start to cause trouble if a netgroup contains more than 15 <em>entries</em>. You can circumvent this limit by creating several sub-netgroups with 15 users or less and a real netgroup that consists of the sub-netgroups:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre></div></div><div class=paragraph><p>You can repeat this process if you need more than 225 users within a single netgroup.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Activating and distributing your new NIS map is easy:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# <span class=nb>cd</span> /var/yp
ellington# make</code></pre></div></div><div class=paragraph><p>This will generate the three NIS maps <span class=filename>netgroup</span>, <span class=filename>netgroup.byhost</span> and <span class=filename>netgroup.byuser</span>. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a> to check if your new NIS maps are available:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington% ypcat <span class=nt>-k</span> netgroup
ellington% ypcat <span class=nt>-k</span> netgroup.byhost
ellington% ypcat <span class=nt>-k</span> netgroup.byuser</code></pre></div></div><div class=paragraph><p>The output of the first command should resemble the contents of <span class=filename>/var/yp/netgroup</span>. The second command will not produce output if you have not specified host-specific netgroups. The third command can be used to get the list of netgroups for a user.</p></div><div class=paragraph><p>The client setup is quite simple. To configure the server <code>war</code>, you only have to start <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> and replace the line</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>with</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::</pre></div></div><div class=paragraph><p>Now, only the data for the users defined in the netgroup <code>IT_EMP</code> is imported into <code>war</code>'s password database and only these users are allowed to login.</p></div><div class=paragraph><p>Unfortunately, this limitation also applies to the <code>~</code> function of the shell and all routines converting between user names and numerical user IDs. In other words, <code>cd ~user</code> will not work, <code>ls -l</code> will show the numerical ID instead of the username and <code>find . -user joe -print</code> will fail with <code>No such user</code>. To fix this, you will have to import all user entries <em>without allowing them to login onto your servers</em>.</p></div><div class=paragraph><p>This can be achieved by adding another line to <span class=filename>/etc/master.passwd</span>. This line should contain:</p></div><div class=paragraph><p><code>+:::::::::/sbin/nologin</code>, meaning "Import all entries but replace the shell with <span class=filename>/sbin/nologin</span> in the imported entries". You can replace any field in the <code>passwd</code> entry by placing a default value in your <span class=filename>/etc/master.passwd</span>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Make sure that the line <code>:::::::::/sbin/nologin` is placed after `@IT_EMP:::::::::</code>. Otherwise, all user accounts imported from NIS will have <span class=filename>/sbin/nologin</span> as their login shell.</p></div></td></tr></tbody></table></div><div class=paragraph><p>After this change, you will only have to change one NIS map if a new employee joins the IT department. You could use a similar approach for the less important servers by replacing the old <code>+:::::::::</code> in their local version of <span class=filename>/etc/master.passwd</span> with something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>The corresponding lines for the normal workstations could be:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>And everything would be fine until there is a policy change a few weeks later: The IT department starts hiring interns. The IT interns are allowed to use the normal workstations and the less important servers; and the IT apprentices are allowed to login onto the main servers. You add a new netgroup <code>IT_INTERN</code>, add the new IT interns to this netgroup and start to change the configuration on each and every machine…​ As the old saying goes: "Errors in centralized planning lead to global mess".</p></div><div class=paragraph><p>NIS' ability to create netgroups from other netgroups can be used to prevent situations like these. One possibility is the creation of role-based netgroups. For example, you could create a netgroup called <code>BIGSRV</code> to define the login restrictions for the important servers, another netgroup called <code>SMALLSRV</code> for the less important servers and a third netgroup called <code>USERBOX</code> for the normal workstations. Each of these netgroups contains the netgroups that are allowed to login onto these machines. The new entries for your NIS map netgroup should look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre></div></div><div class=paragraph><p>This method of defining login restrictions works reasonably well if you can define groups of machines with identical restrictions. Unfortunately, this is the exception and not the rule. Most of the time, you will need the ability to define login restrictions on a per-machine basis.</p></div><div class=paragraph><p>Machine-specific netgroup definitions are the other possibility to deal with the policy change outlined above. In this scenario, the <span class=filename>/etc/master.passwd</span> of each box contains two lines starting with "+". The first of them adds a netgroup with the accounts allowed to login onto this machine, the second one adds all other accounts with <span class=filename>/sbin/nologin</span> as shell. It is a good idea to use the "ALL-CAPS" version of the machine name as the name of the netgroup. In other words, the lines should look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>+@BOXNAME:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>Once you have completed this task for all your machines, you will not have to modify the local versions of <span class=filename>/etc/master.passwd</span> ever again. All further changes can be handled by modifying the NIS map. Here is an example of a possible netgroup map for this scenario with some additional goodies:</p></div><div class="literalblock programlisting"><div class=content><pre># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</pre></div></div><div class=paragraph><p>If you are using some kind of database to manage your user accounts, you should be able to create the first part of the map with your database’s report tools. This way, new users will automatically have access to the boxes.</p></div><div class=paragraph><p>One last word of caution: It may not always be advisable to use machine-based netgroups. If you are deploying a couple of dozen or even hundreds of identical machines for student labs, you should use role-based netgroups instead of machine-based netgroups to keep the size of the NIS map within reasonable limits.</p></div></div><div class=sect3><h4 id=_important_things_to_remember>54.4.8. Important Things to Remember<a class=anchor href=#_important_things_to_remember></a></h4><div class=paragraph><p>There are still a couple of things that you will need to do differently now that you are in an NIS environment.</p></div><div class=ulist><ul><li><p>Every time you wish to add a user to the lab, you must add it to the master NIS server <em>only</em>, and <em>you must remember to rebuild the NIS maps</em>. If you forget to do this, the new user will not be able to login anywhere except on the NIS master. For example, if we needed to add a new user <code>jsmith</code> to the lab, we would:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd jsmith</span>
<span class=c># cd /var/yp</span>
<span class=c># make test-domain</span></code></pre></div></div><div class=paragraph><p>You could also run <code>adduser jsmith</code> instead of <code>pw useradd jsmith</code>.</p></div></li><li><p><em>Keep the administration accounts out of the NIS maps</em>. You do not want to be propagating administrative accounts and passwords to machines that will have users that should not have access to those accounts.</p></li><li><p><em>Keep the NIS master and slave secure, and minimize their downtime</em>. If somebody either hacks or simply turns off these machines, they have effectively rendered many people without the ability to login to the lab.</p><div class=paragraph><p>This is the chief weakness of any centralized administration system. If you do not protect your NIS servers, you will have a lot of angry users!</p></div></li></ul></div></div><div class=sect3><h4 id=_nis_v1_compatibility>54.4.9. NIS v1 Compatibility<a class=anchor href=#_nis_v1_compatibility></a></h4><div class=paragraph><p>FreeBSD’s ypserv has some support for serving NIS v1 clients. FreeBSD’s NIS implementation only uses the NIS v2 protocol, however other implementations include support for the v1 protocol for backwards compatibility with older systems. The ypbind daemons supplied with these systems will try to establish a binding to an NIS v1 server even though they may never actually need it (and they may persist in broadcasting in search of one even after they receive a response from a v2 server). Note that while support for normal client calls is provided, this version of ypserv does not handle v1 map transfer requests; consequently, it cannot be used as a master or slave in conjunction with older NIS servers that only support the v1 protocol. Fortunately, there probably are not any such servers still in use today.</p></div></div><div class=sect3><h4 id=network-nis-server-is-client>54.4.10. NIS Servers That Are Also NIS Clients<a class=anchor href=#network-nis-server-is-client></a></h4><div class=paragraph><p>Care must be taken when running ypserv in a multi-server domain where the server machines are also NIS clients. It is generally a good idea to force the servers to bind to themselves rather than allowing them to broadcast bind requests and possibly become bound to each other. Strange failure modes can result if one server goes down and others are dependent upon it. Eventually all the clients will time out and attempt to bind to other servers, but the delay involved can be considerable and the failure mode is still present since the servers might bind to each other all over again.</p></div><div class=paragraph><p>You can force a host to bind to a particular server by running <code>ypbind</code> with the <code>-S</code> flag. If you do not want to do this manually each time you reboot your NIS server, you can add the following lines to your <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nis_client_enable=&#34;YES&#34;	# run client stuff as well
nis_client_flags=&#34;-S NIS domain,server&#34;</pre></div></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> for further information.</p></div></div><div class=sect3><h4 id=_password_formats>54.4.11. Password Formats<a class=anchor href=#_password_formats></a></h4><div class=paragraph><p>One of the most common issues that people run into when trying to implement NIS is password format compatibility. If your NIS server is using DES encrypted passwords, it will only support clients that are also using DES. For example, if you have Solaris™ NIS clients in your network, then you will almost certainly need to use DES encrypted passwords.</p></div><div class=paragraph><p>To check which format your servers and clients are using, look at <span class=filename>/etc/login.conf</span>. If the host is configured to use DES encrypted passwords, then the <code>default</code> class will contain an entry like this:</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Further entries elided]</pre></div></div><div class=paragraph><p>Other possible values for the <code>passwd_format</code> capability include <code>blf</code> and <code>md5</code> (for Blowfish and MD5 encrypted passwords, respectively).</p></div><div class=paragraph><p>If you have made changes to <span class=filename>/etc/login.conf</span>, you will also need to rebuild the login capability database, which is achieved by running the following command as <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The format of passwords already in <span class=filename>/etc/master.passwd</span> will not be updated until a user changes his password for the first time <em>after</em> the login capability database is rebuilt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next, in order to ensure that passwords are encrypted with the format that you have chosen, you should also check that the <code>crypt_default</code> in <span class=filename>/etc/auth.conf</span> gives precedence to your chosen password format. To do this, place the format that you have chosen first in the list. For example, when using DES encrypted passwords, the entry would be:</p></div><div class="literalblock programlisting"><div class=content><pre>crypt_default	=	des blf md5</pre></div></div><div class=paragraph><p>Having followed the above steps on each of the FreeBSD based NIS servers and clients, you can be sure that they all agree on which password format is used within your network. If you have trouble authenticating on an NIS client, this is a pretty good place to start looking for possible problems. Remember: if you want to deploy an NIS server for a heterogenous network, you will probably have to use DES on all systems because it is the lowest common standard.</p></div></div></div><div class=sect2><h3 id=network-dhcp>54.5. Automatic Network Configuration (DHCP)<a class=anchor href=#network-dhcp></a></h3><div class=sect3><h4 id=_what_is_dhcp>54.5.1. What Is DHCP?<a class=anchor href=#_what_is_dhcp></a></h4><div class=paragraph><p>DHCP, the Dynamic Host Configuration Protocol, describes the means by which a system can connect to a network and obtain the necessary information for communication upon that network. FreeBSD versions prior to 6.0 use the ISC (Internet Software Consortium) DHCP client (<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>) implementation. Later versions use the OpenBSD <code>dhclient</code> taken from OpenBSD 3.7. All information here regarding <code>dhclient</code> is for use with either of the ISC or OpenBSD DHCP clients. The DHCP server is the one included in the ISC distribution.</p></div></div><div class=sect3><h4 id=_what_this_section_covers>54.5.2. What This Section Covers<a class=anchor href=#_what_this_section_covers></a></h4><div class=paragraph><p>This section describes both the client-side components of the ISC and OpenBSD DHCP client and server-side components of the ISC DHCP system. The client-side program, <code>dhclient</code>, comes integrated within FreeBSD, and the server-side portion is available from the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port. The <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> manual pages, in addition to the references below, are useful resources.</p></div></div><div class=sect3><h4 id=_how_it_works>54.5.3. How It Works<a class=anchor href=#_how_it_works></a></h4><div class=paragraph><p>When <code>dhclient</code>, the DHCP client, is executed on the client machine, it begins broadcasting requests for configuration information. By default, these requests are on UDP port 68. The server replies on UDP 67, giving the client an IP address and other relevant network information such as netmask, router, and DNS servers. All of this information comes in the form of a DHCP "lease" and is only valid for a certain time (configured by the DHCP server maintainer). In this manner, stale IP addresses for clients no longer connected to the network can be automatically reclaimed.</p></div><div class=paragraph><p>DHCP clients can obtain a great deal of information from the server. An exhaustive list may be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a>.</p></div></div><div class=sect3><h4 id=_freebsd_integration>54.5.4. FreeBSD Integration<a class=anchor href=#_freebsd_integration></a></h4><div class=paragraph><p>FreeBSD fully integrates the ISC or OpenBSD DHCP client, <code>dhclient</code> (according to the FreeBSD version you run). DHCP client support is provided within both the installer and the base system, obviating the need for detailed knowledge of network configurations on any network that runs a DHCP server. <code>dhclient</code> has been included in all FreeBSD distributions since 3.2.</p></div><div class=paragraph><p>DHCP is supported by sysinstall. When configuring a network interface within sysinstall, the second question asked is: "Do you want to try DHCP configuration of the interface?". Answering affirmatively will execute <code>dhclient</code>, and if successful, will fill in the network configuration information automatically.</p></div><div class=paragraph><p>There are two things you must do to have your system use DHCP upon startup:</p></div><div class=ulist><ul><li><p>Make sure that the <span class=filename>bpf</span> device is compiled into your kernel. To do this, add <code>device bpf</code> to your kernel configuration file, and rebuild the kernel. For more information about building kernels, see <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>.</p><div class=paragraph><p>The <span class=filename>bpf</span> device is already part of the <span class=filename>GENERIC</span> kernel that is supplied with FreeBSD, so if you do not have a custom kernel, you should not need to create one in order to get DHCP working.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For those who are particularly security conscious, you should be warned that <span class=filename>bpf</span> is also the device that allows packet sniffers to work correctly (although they still have to be run as <code>root</code>). <span class=filename>bpf</span><em>is</em> required to use DHCP, but if you are very sensitive about security, you probably should not add <span class=filename>bpf</span> to your kernel in the expectation that at some point in the future you will be using DHCP.</p></div></td></tr></tbody></table></div></li><li><p>Edit your <span class=filename>/etc/rc.conf</span> to include the following:</p><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;DHCP&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Be sure to replace <code>fxp0</code> with the designation for the interface that you wish to dynamically configure, as described in <a href=./#config-network-setup>Ρυθμίζοντας Τις Κάρτες Δικτύου</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>If you are using a different location for <code>dhclient</code>, or if you wish to pass additional flags to <code>dhclient</code>, also include the following (editing as necessary):</p></div><div class="literalblock programlisting"><div class=content><pre>dhcp_program=&#34;/sbin/dhclient&#34;
dhcp_flags=&#34;&#34;</pre></div></div></li></ul></div><div class=paragraph><p>The DHCP server, dhcpd, is included as part of the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port in the ports collection. This port contains the ISC DHCP server and documentation.</p></div></div><div class=sect3><h4 id=_files>54.5.5. Files<a class=anchor href=#_files></a></h4><div class=ulist><ul><li><p><span class=filename>/etc/dhclient.conf</span></p><div class=paragraph><p><code>dhclient</code> requires a configuration file, <span class=filename>/etc/dhclient.conf</span>. Typically the file contains only comments, the defaults being reasonably sane. This configuration file is described by the <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> manual page.</p></div></li><li><p><span class=filename>/sbin/dhclient</span></p><div class=paragraph><p><code>dhclient</code> is statically linked and resides in <span class=filename>/sbin</span>. The <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> manual page gives more information about <code>dhclient</code>.</p></div></li><li><p><span class=filename>/sbin/dhclient-script</span></p><div class=paragraph><p><code>dhclient-script</code> is the FreeBSD-specific DHCP client configuration script. It is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a>, but should not need any user modification to function properly.</p></div></li><li><p><span class=filename>/var/db/dhclient.leases</span></p><div class=paragraph><p>The DHCP client keeps a database of valid leases in this file, which is written as a log. <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a> gives a slightly longer description.</p></div></li></ul></div></div><div class=sect3><h4 id=_further_reading_3>54.5.6. Further Reading<a class=anchor href=#_further_reading_3></a></h4><div class=paragraph><p>The DHCP protocol is fully described in <a href=http://www.freesoft.org/CIE/RFC/2131/>RFC 2131</a>. An informational resource has also been set up at <a href=http://www.dhcp.org/>http://www.dhcp.org/</a>.</p></div></div><div class=sect3><h4 id=network-dhcp-server>54.5.7. Installing and Configuring a DHCP Server<a class=anchor href=#network-dhcp-server></a></h4><div class=sect4><h5 id=_what_this_section_covers_2>54.5.7.1. What This Section Covers<a class=anchor href=#_what_this_section_covers_2></a></h5><div class=paragraph><p>This section provides information on how to configure a FreeBSD system to act as a DHCP server using the ISC (Internet Software Consortium) implementation of the DHCP server.</p></div><div class=paragraph><p>The server is not provided as part of FreeBSD, and so you will need to install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port to provide this service. See <a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a> for more information on using the Ports Collection.</p></div></div><div class=sect4><h5 id=_dhcp_server_installation>54.5.7.2. DHCP Server Installation<a class=anchor href=#_dhcp_server_installation></a></h5><div class=paragraph><p>In order to configure your FreeBSD system as a DHCP server, you will need to ensure that the <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> device is compiled into your kernel. To do this, add <code>device bpf</code> to your kernel configuration file, and rebuild the kernel. For more information about building kernels, see <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>.</p></div><div class=paragraph><p>The <span class=filename>bpf</span> device is already part of the <span class=filename>GENERIC</span> kernel that is supplied with FreeBSD, so you do not need to create a custom kernel in order to get DHCP working.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Those who are particularly security conscious should note that <span class=filename>bpf</span> is also the device that allows packet sniffers to work correctly (although such programs still need privileged access). <span class=filename>bpf</span><em>is</em> required to use DHCP, but if you are very sensitive about security, you probably should not include <span class=filename>bpf</span> in your kernel purely because you expect to use DHCP at some point in the future.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The next thing that you will need to do is edit the sample <span class=filename>dhcpd.conf</span> which was installed by the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port. By default, this will be <span class=filename>/usr/local/etc/dhcpd.conf.sample</span>, and you should copy this to <span class=filename>/usr/local/etc/dhcpd.conf</span> before proceeding to make changes.</p></div></div><div class=sect4><h5 id=_configuring_the_dhcp_server>54.5.7.3. Configuring the DHCP Server<a class=anchor href=#_configuring_the_dhcp_server></a></h5><div class=paragraph><p><span class=filename>dhcpd.conf</span> is comprised of declarations regarding subnets and hosts, and is perhaps most easily explained using an example :</p></div><div class="literalblock programlisting"><div class=content><pre>option domain-name &#34;example.com&#34;;<i class=conum data-value=1></i><b>(1)</b>
option domain-name-servers 192.168.4.100;<i class=conum data-value=2></i><b>(2)</b>
option subnet-mask 255.255.255.0;<i class=conum data-value=3></i><b>(3)</b>

default-lease-time 3600;<i class=conum data-value=4></i><b>(4)</b>
max-lease-time 86400;<i class=conum data-value=5></i><b>(5)</b>
ddns-update-style none;<i class=conum data-value=6></i><b>(6)</b>

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<i class=conum data-value=7></i><b>(7)</b>
  option routers 192.168.4.1;<i class=conum data-value=8></i><b>(8)</b>
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<i class=conum data-value=9></i><b>(9)</b>
  fixed-address mailhost.example.com;<i class=conum data-value=10></i><b>(10)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This option specifies the domain that will be provided to clients as the default search domain. See <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> for more information on what this means.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>This option specifies a comma separated list of DNS servers that the client should use.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The netmask that will be provided to clients.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>A client may request a specific length of time that a lease will be valid. Otherwise the server will assign a lease with this expiry value (in seconds).</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>This is the maximum length of time that the server will lease for. Should a client request a longer lease, a lease will be issued, although it will only be valid for <code>max-lease-time</code> seconds.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>This option specifies whether the DHCP server should attempt to update DNS when a lease is accepted or released. In the ISC implementation, this option is <em>required</em>.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>This denotes which IP addresses should be used in the pool reserved for allocating to clients. IP addresses between, and including, the ones stated are handed out to clients.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Declares the default gateway that will be provided to clients.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>The hardware MAC address of a host (so that the DHCP server can recognize a host when it makes a request).</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>Specifies that the host should always be given the same IP address. Note that using a hostname is correct here, since the DHCP server will resolve the hostname itself before returning the lease information.</td></tr></tbody></table></div><div class=paragraph><p>Once you have finished writing your <span class=filename>dhcpd.conf</span>, you should enable the DHCP server in <span class=filename>/etc/rc.conf</span>, i.e. by adding:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;
dhcpd_ifaces=&#34;dc0&#34;</pre></div></div><div class=paragraph><p>Replace the <code>dc0</code> interface name with the interface (or interfaces, separated by whitespace) that your DHCP server should listen on for DHCP client requests.</p></div><div class=paragraph><p>Then, you can proceed to start the server by issuing the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/isc-dhcpd.sh start</span></code></pre></div></div><div class=paragraph><p>Should you need to make changes to the configuration of your server in the future, it is important to note that sending a <code>SIGHUP</code> signal to dhcpd does <em>not</em> result in the configuration being reloaded, as it does with most daemons. You will need to send a <code>SIGTERM</code> signal to stop the process, and then restart it using the command above.</p></div></div><div class=sect4><h5 id=_files_2>54.5.7.4. Files<a class=anchor href=#_files_2></a></h5><div class=ulist><ul><li><p><span class=filename>/usr/local/sbin/dhcpd</span></p><div class=paragraph><p>dhcpd is statically linked and resides in <span class=filename>/usr/local/sbin</span>. The <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd&amp;sektion=8&amp;format=html">dhcpd(8)</a> manual page installed with the port gives more information about dhcpd.</p></div></li><li><p><span class=filename>/usr/local/etc/dhcpd.conf</span></p><div class=paragraph><p>dhcpd requires a configuration file, <span class=filename>/usr/local/etc/dhcpd.conf</span> before it will start providing service to clients. This file needs to contain all the information that should be provided to clients that are being serviced, along with information regarding the operation of the server. This configuration file is described by the <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a> manual page installed by the port.</p></div></li><li><p><span class=filename>/var/db/dhcpd.leases</span></p><div class=paragraph><p>The DHCP server keeps a database of leases it has issued in this file, which is written as a log. The manual page <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.leases&amp;sektion=5&amp;format=html">dhcpd.leases(5)</a>, installed by the port gives a slightly longer description.</p></div></li><li><p><span class=filename>/usr/local/sbin/dhcrelay</span></p><div class=paragraph><p>dhcrelay is used in advanced environments where one DHCP server forwards a request from a client to another DHCP server on a separate network. If you require this functionality, then install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-relay/>net/isc-dhcp3-relay</a> port. The <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcrelay&amp;sektion=8&amp;format=html">dhcrelay(8)</a> manual page provided with the port contains more detail.</p></div></li></ul></div></div></div></div><div class=sect2><h3 id=network-dns>54.6. Domain Name System (DNS)<a class=anchor href=#network-dns></a></h3><div class=sect3><h4 id=_overview>54.6.1. Overview<a class=anchor href=#_overview></a></h4><div class=paragraph><p>FreeBSD utilizes, by default, a version of BIND (Berkeley Internet Name Domain), which is the most common implementation of the DNS protocol. DNS is the protocol through which names are mapped to IP addresses, and vice versa. For example, a query for <code>www.FreeBSD.org</code> will receive a reply with the IP address of The FreeBSD Project’s web server, whereas, a query for <code>ftp.FreeBSD.org</code> will return the IP address of the corresponding FTP machine. Likewise, the opposite can happen. A query for an IP address can resolve its hostname. It is not necessary to run a name server to perform DNS lookups on a system.</p></div><div class=paragraph><p>FreeBSD currently comes with BIND9 DNS server software by default. Our installation provides enhanced security features, a new file system layout and automated <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> configuration.</p></div><div class=paragraph><p>DNS is coordinated across the Internet through a somewhat complex system of authoritative root, Top Level Domain (TLD), and other smaller-scale name servers which host and cache individual domain information.</p></div><div class=paragraph><p>Currently, BIND is maintained by the Internet Software Consortium <a href=http://www.isc.org/>http://www.isc.org/</a>.</p></div></div><div class=sect3><h4 id=_terminology>54.6.2. Terminology<a class=anchor href=#_terminology></a></h4><div class=paragraph><p>To understand this document, some terms related to DNS must be understood.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Term</th><th class="tableblock halign-left valign-top">Definition</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Forward DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mapping of hostnames to IP addresses.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Origin</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Refers to the domain covered in a particular zone file.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>named, BIND, name server</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Common names for the BIND name server package within FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Resolver</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A system process through which a machine queries a name server for zone information.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Reverse DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The opposite of forward DNS; mapping of IP addresses to hostnames.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Root zone</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The beginning of the Internet zone hierarchy. All zones fall under the root zone, similar to how all files in a file system fall under the root directory.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Zone</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>An individual domain, subdomain, or portion of the DNS administered by the same authority.</p></td></tr></tbody></table><div class=paragraph><p>Examples of zones:</p></div><div class=ulist><ul><li><p><code>.</code> is the root zone.</p></li><li><p><code>org.</code> is a Top Level Domain (TLD) under the root zone.</p></li><li><p><code>example.org.</code> is a zone under the <code>org.</code> TLD.</p></li><li><p><code>1.168.192.in-addr.arpa</code> is a zone referencing all IP addresses which fall under the <code>192.168.1.*</code> IP space.</p></li></ul></div><div class=paragraph><p>As one can see, the more specific part of a hostname appears to its left. For example, <code>example.org.</code> is more specific than <code>org.</code>, as <code>org.</code> is more specific than the root zone. The layout of each part of a hostname is much like a file system: the <span class=filename>/dev</span> directory falls within the root, and so on.</p></div></div><div class=sect3><h4 id=_reasons_to_run_a_name_server>54.6.3. Reasons to Run a Name Server<a class=anchor href=#_reasons_to_run_a_name_server></a></h4><div class=paragraph><p>Name servers usually come in two forms: an authoritative name server, and a caching name server.</p></div><div class=paragraph><p>An authoritative name server is needed when:</p></div><div class=ulist><ul><li><p>One wants to serve DNS information to the world, replying authoritatively to queries.</p></li><li><p>A domain, such as <code>example.org</code>, is registered and IP addresses need to be assigned to hostnames under it.</p></li><li><p>An IP address block requires reverse DNS entries (IP to hostname).</p></li><li><p>A backup or second name server, called a slave, will reply to queries.</p></li></ul></div><div class=paragraph><p>A caching name server is needed when:</p></div><div class=ulist><ul><li><p>A local DNS server may cache and respond more quickly than querying an outside name server.</p></li></ul></div><div class=paragraph><p>When one queries for <code>www.FreeBSD.org</code>, the resolver usually queries the uplink ISP’s name server, and retrieves the reply. With a local, caching DNS server, the query only has to be made once to the outside world by the caching DNS server. Every additional query will not have to look to the outside of the local network, since the information is cached locally.</p></div></div><div class=sect3><h4 id=_how_it_works_2>54.6.4. How It Works<a class=anchor href=#_how_it_works_2></a></h4><div class=paragraph><p>In FreeBSD, the BIND daemon is called named for obvious reasons.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">File</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The BIND daemon.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rndc&amp;sektion=8&amp;format=html">rndc(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name server control utility.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directory where BIND zone information resides.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb/named.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration file of the daemon.</p></td></tr></tbody></table><div class=paragraph><p>Depending on how a given zone is configured on the server, the files related to that zone can be found in the <span class=filename>master</span>, <span class=filename>slave</span>, or <span class=filename>dynamic</span> subdirectories of the <span class=filename>/etc/namedb</span> directory. These files contain the DNS information that will be given out by the name server in response to queries.</p></div></div><div class=sect3><h4 id=_starting_bind>54.6.5. Starting BIND<a class=anchor href=#_starting_bind></a></h4><div class=paragraph><p>Since BIND is installed by default, configuring it all is relatively simple.</p></div><div class=paragraph><p>The default named configuration is that of a basic resolving name server, ran in a <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> environment. To start the server one time with this configuration, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/named forcestart</span></code></pre></div></div><div class=paragraph><p>To ensure the named daemon is started at boot each time, put the following line into the <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>There are obviously many configuration options for <span class=filename>/etc/namedb/named.conf</span> that are beyond the scope of this document. However, if you are interested in the startup options for named on FreeBSD, take a look at the <code>named_*</code> flags in <span class=filename>/etc/defaults/rc.conf</span> and consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> manual page. The <a href=./#configtuning-rcd>Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD</a> section is also a good read.</p></div></div><div class=sect3><h4 id=_configuration_files_2>54.6.6. Configuration Files<a class=anchor href=#_configuration_files_2></a></h4><div class=paragraph><p>Configuration files for named currently reside in <span class=filename>/etc/namedb</span> directory and will need modification before use, unless all that is needed is a simple resolver. This is where most of the configuration will be performed.</p></div><div class=sect4><h5 id=_using_make_localhost>54.6.6.1. Using <code>make-localhost</code><a class=anchor href=#_using_make_localhost></a></h5><div class=paragraph><p>To configure a master zone for the localhost visit the <span class=filename>/etc/namedb</span> directory and run the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh make-localhost</span></code></pre></div></div><div class=paragraph><p>If all went well, a new file should exist in the <span class=filename>master</span> subdirectory. The filenames should be <span class=filename>localhost.rev</span> for the local domain name and <span class=filename>localhost-v6.rev</span> for IPv6 configurations. As the default configuration file, required information will be present in the <span class=filename>named.conf</span> file.</p></div></div><div class=sect4><h5 id=_etcnamedbnamed_conf>54.6.6.2. <span class=filename>/etc/namedb/named.conf</span><a class=anchor href=#_etcnamedbnamed_conf></a></h5><div class="literalblock programlisting"><div class=content><pre>// $FreeBSD$
//
// Refer to the named.conf(5) and named(8) man pages, and the documentation
// in /usr/shared/doc/bind9 for more details.
//
// If you are going to set up an authoritative server, make sure you
// understand the hairy details of how DNS works.  Even with
// simple mistakes, you can break connectivity for affected parties,
// or cause huge amounts of useless Internet traffic.

options {
	directory	&#34;/etc/namedb&#34;;
	pid-file	&#34;/var/run/named/pid&#34;;
	dump-file	&#34;/var/dump/named_dump.db&#34;;
	statistics-file	&#34;/var/stats/named.stats&#34;;

// If named is being used only as a local resolver, this is a safe default.
// For named to be accessible to the network, comment this option, specify
// the proper IP address, or delete this option.
	listen-on	{ 127.0.0.1; };

// If you have IPv6 enabled on this system, uncomment this option for
// use as a local resolver.  To give access to the network, specify
// an IPv6 address, or the keyword &#34;any&#34;.
//	listen-on-v6	{ ::1; };

// In addition to the &#34;forwarders&#34; clause, you can force your name
// server to never initiate queries of its own, but always ask its
// forwarders only, by enabling the following line:
//
//	forward only;

// If you&#39;ve got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the Internet.
/*
	forwarders {
		127.0.0.1;
	};
*/</pre></div></div><div class=paragraph><p>Just as the comment says, to benefit from an uplink’s cache, <code>forwarders</code> can be enabled here. Under normal circumstances, a name server will recursively query the Internet looking at certain name servers until it finds the answer it is looking for. Having this enabled will have it query the uplink’s name server (or name server provided) first, taking advantage of its cache. If the uplink name server in question is a heavily trafficked, fast name server, enabling this may be worthwhile.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><code>127.0.0.1</code> will <em>not</em> work here. Change this IP address to a name server at your uplink.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>	/*
	 * If there is a firewall between you and nameservers you want
	 * to talk to, you might need to uncomment the query-source
	 * directive below.  Previous versions of BIND always asked
	 * questions using port 53, but BIND versions 8 and later
	 * use a pseudo-random unprivileged UDP port by default.
	 */
	 // query-source address * port 53;
};

// If you enable a local name server, don&#39;t forget to enter 127.0.0.1
// first in your /etc/resolv.conf so this server will be queried.
// Also, make sure to enable it in /etc/rc.conf.

zone &#34;.&#34; {
	type hint;
	file &#34;named.root&#34;;
};

zone &#34;0.0.127.IN-ADDR.ARPA&#34; {
	type master;
	file &#34;master/localhost.rev&#34;;
};

// RFC 3152
zone &#34;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA&#34; {
	type master;
	file &#34;master/localhost-v6.rev&#34;;
};

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example slave zone config entries.  It can be convenient to become
// a slave at least for the zone your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// primary.
//
// Never forget to include the reverse lookup (IN-ADDR.ARPA) zone!
// (This is named after the first bytes of the IP address, in reverse
// order, with &#34;.IN-ADDR.ARPA&#34; appended.)
//
// Before starting to set up a primary zone, make sure you fully
// understand how DNS and BIND works.  There are sometimes
// non-obvious pitfalls.  Setting up a slave zone is simpler.
//
// NB: Don&#39;t blindly enable the examples below. :-)  Use actual names
// and addresses instead.

/* An example master zone
zone &#34;example.net&#34; {
	type master;
	file &#34;master/example.net&#34;;
};
*/

/* An example dynamic zone
key &#34;exampleorgkey&#34; {
	algorithm hmac-md5;
	secret &#34;sf87HJqjkqh8ac87a02lla==&#34;;
};
zone &#34;example.org&#34; {
	type master;
	allow-update {
		key &#34;exampleorgkey&#34;;
	};
	file &#34;dynamic/example.org&#34;;
};
*/

/* Examples of forward and reverse slave zones
zone &#34;example.com&#34; {
	type slave;
	file &#34;slave/example.com&#34;;
	masters {
		192.168.1.1;
	};
};
zone &#34;1.168.192.in-addr.arpa&#34; {
	type slave;
	file &#34;slave/1.168.192.in-addr.arpa&#34;;
	masters {
		192.168.1.1;
	};
};
*/</pre></div></div><div class=paragraph><p>In <span class=filename>named.conf</span>, these are examples of slave entries for a forward and reverse zone.</p></div><div class=paragraph><p>For each new zone served, a new zone entry must be added to <span class=filename>named.conf</span>.</p></div><div class=paragraph><p>For example, the simplest zone entry for <code>example.org</code> can look like:</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type master;
	file &#34;master/example.org&#34;;
};</pre></div></div><div class=paragraph><p>The zone is a master, as indicated by the <code>type</code> statement, holding its zone information in <span class=filename>/etc/namedb/master/example.org</span> indicated by the <code>file</code> statement.</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type slave;
	file &#34;slave/example.org&#34;;
};</pre></div></div><div class=paragraph><p>In the slave case, the zone information is transferred from the master name server for the particular zone, and saved in the file specified. If and when the master server dies or is unreachable, the slave name server will have the transferred zone information and will be able to serve it.</p></div></div><div class=sect4><h5 id=_zone_files>54.6.6.3. Zone Files<a class=anchor href=#_zone_files></a></h5><div class=paragraph><p>An example master zone file for <code>example.org</code> (existing within <span class=filename>/etc/namedb/master/example.org</span>) is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600        ; 1 hour
example.org.    IN      SOA      ns1.example.org. admin.example.org. (
                                2006051501      ; Serial
                                10800           ; Refresh
                                3600            ; Retry
                                604800          ; Expire
                                86400           ; Minimum TTL
                        )

; DNS Servers
                IN      NS      ns1.example.org.
                IN      NS      ns2.example.org.

; MX Records
                IN      MX 10   mx.example.org.
                IN      MX 20   mail.example.org.

                IN      A       192.168.1.1

; Machine Names
localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5

; Aliases
www             IN      CNAME   @</pre></div></div><div class=paragraph><p>Note that every hostname ending in a "." is an exact hostname, whereas everything without a trailing "." is referenced to the origin. For example, <code>www</code> is translated into <code>www.origin</code>. In our fictitious zone file, our origin is <code>example.org.</code>, so <code>www</code> would translate to <code>www.example.org.</code></p></div><div class=paragraph><p>The format of a zone file follows:</p></div><div class="literalblock programlisting"><div class=content><pre>recordname      IN recordtype   value</pre></div></div><div class=paragraph><p>The most commonly used DNS records:</p></div><div class=dlist><dl><dt class=hdlist1>SOA</dt><dd><p>start of zone authority</p></dd><dt class=hdlist1>NS</dt><dd><p>an authoritative name server</p></dd><dt class=hdlist1>A</dt><dd><p>a host address</p></dd><dt class=hdlist1>CNAME</dt><dd><p>the canonical name for an alias</p></dd><dt class=hdlist1>MX</dt><dd><p>mail exchanger</p></dd><dt class=hdlist1>PTR</dt><dd><p>a domain name pointer (used in reverse DNS)</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>example.org. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>example.org.</code></dt><dd><p>the domain name, also the origin for this zone file.</p></dd><dt class=hdlist1><code>ns1.example.org.</code></dt><dd><p>the primary/authoritative name server for this zone.</p></dd><dt class=hdlist1><code>admin.example.org.</code></dt><dd><p>the responsible person for this zone, email address with "@" replaced. (<a href=mailto:admin@example.org>admin@example.org</a> becomes <code>admin.example.org</code>)</p></dd><dt class=hdlist1><code>2006051501</code></dt><dd><p>the serial number of the file. This must be incremented each time the zone file is modified. Nowadays, many admins prefer a <code>yyyymmddrr</code> format for the serial number. <code>2006051501</code> would mean last modified 05/15/2006, the latter <code>01</code> being the first time the zone file has been modified this day. The serial number is important as it alerts slave name servers for a zone when it is updated.</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>       IN NS           ns1.example.org.</pre></div></div><div class=paragraph><p>This is an NS entry. Every name server that is going to reply authoritatively for the zone must have one of these entries.</p></div><div class="literalblock programlisting"><div class=content><pre>localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5</pre></div></div><div class=paragraph><p>The A record indicates machine names. As seen above, <code>ns1.example.org</code> would resolve to <code>192.168.1.2</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>                IN      A       192.168.1.1</pre></div></div><div class=paragraph><p>This line assigns IP address <code>192.168.1.1</code> to the current origin, in this case <code>example.org</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>www             IN CNAME        @</pre></div></div><div class=paragraph><p>The canonical name record is usually used for giving aliases to a machine. In the example, <code>www</code> is aliased to the "master" machine which name equals to domain name <code>example.org</code> (<code>192.168.1.1</code>). CNAMEs can be used to provide alias hostnames, or round robin one hostname among multiple machines.</p></div><div class="literalblock programlisting"><div class=content><pre>               IN MX   10      mail.example.org.</pre></div></div><div class=paragraph><p>The MX record indicates which mail servers are responsible for handling incoming mail for the zone. <code>mail.example.org</code> is the hostname of the mail server, and 10 being the priority of that mail server.</p></div><div class=paragraph><p>One can have several mail servers, with priorities of 10, 20 and so on. A mail server attempting to deliver to <code>example.org</code> would first try the highest priority MX (the record with the lowest priority number), then the second highest, etc, until the mail can be properly delivered.</p></div><div class=paragraph><p>For in-addr.arpa zone files (reverse DNS), the same format is used, except with PTR entries instead of A or CNAME.</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600

1.168.192.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

        IN      NS      ns1.example.org.
        IN      NS      ns2.example.org.

1       IN      PTR     example.org.
2       IN      PTR     ns1.example.org.
3       IN      PTR     ns2.example.org.
4       IN      PTR     mx.example.org.
5       IN      PTR     mail.example.org.</pre></div></div><div class=paragraph><p>This file gives the proper IP address to hostname mappings of our above fictitious domain.</p></div></div></div><div class=sect3><h4 id=_caching_name_server>54.6.7. Caching Name Server<a class=anchor href=#_caching_name_server></a></h4><div class=paragraph><p>A caching name server is a name server that is not authoritative for any zones. It simply asks queries of its own, and remembers them for later use. To set one up, just configure the name server as usual, omitting any inclusions of zones.</p></div></div><div class=sect3><h4 id=_security>54.6.8. Security<a class=anchor href=#_security></a></h4><div class=paragraph><p>Although BIND is the most common implementation of DNS, there is always the issue of security. Possible and exploitable security holes are sometimes found.</p></div><div class=paragraph><p>While FreeBSD automatically drops named into a <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> environment; there are several other security mechanisms in place which could help to lure off possible DNS service attacks.</p></div><div class=paragraph><p>It is always good idea to read <a href=http://www.cert.org/>CERT</a>'s security advisories and to subscribe to the <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>ηλεκτρονική λίστα Ανακοινώσεων για Θέματα Ασφάλειας του FreeBSD</a> to stay up to date with the current Internet and FreeBSD security issues.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If a problem arises, keeping sources up to date and having a fresh build of named would not hurt.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_further_reading_4>54.6.9. Further Reading<a class=anchor href=#_further_reading_4></a></h4><div class=paragraph><p>BIND/named manual pages: <a href="https://man.freebsd.org/cgi/man.cgi?query=rndc&amp;sektion=8&amp;format=html">rndc(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named.conf&amp;sektion=8&amp;format=html">named.conf(8)</a></p></div><div class=ulist><ul><li><p><a href=http://www.isc.org/products/BIND/>Official ISC BIND Page</a></p></li><li><p><a href=http://www.isc.org/sw/guild/bf/>Official ISC BIND Forum</a></p></li><li><p><a href="http://www.nominum.com/getOpenSourceResource.php?id=6">BIND FAQ</a></p></li><li><p><a href=http://www.oreilly.com/catalog/dns5/>O’Reilly DNS and BIND 5th Edition</a></p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1034.txt>RFC1034 - Domain Names - Concepts and Facilities</a></p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1035.txt>RFC1035 - Domain Names - Implementation and Specification</a></p></li></ul></div></div></div><div class=sect2><h3 id=network-apache>54.7. Ο εξυπηρετητής HTTP Apache<a class=anchor href=#network-apache></a></h3><div class=sect3><h4 id=_σύνοψη>54.7.1. Σύνοψη<a class=anchor href=#_σύνοψη></a></h4><div class=paragraph><p>Το FreeBSD χρησιμοποιείται για να φιλοξενεί παγκοσμίως ιστοσελίδες μεγάλης επισκεψιμότητας. Οι περισσότεροι διακομιστές web στο διαδίκτυο χρησιμοποιούν τον εξυπηρετητή HTTP Apache. Τα πακέτα λογισμικού του Apache θα πρέπει να περιέχονται στο μέσο εγκατατάστασης του FreeBSD που χρησιμοποιείτε. Αν δεν εγκαταστήσατε τον Apache κατά την διάρκεια της εγκατάστασης του FreeBSD, τότε μπορείτε να τον εγκαταστήσετε από το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13/>www/apache13</a> ή από το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache20/>www/apache20</a>.</p></div><div class=paragraph><p>Αφού ολοκληρώσετε επιτυχώς την εγκατάσταση του Apache, θα πρέπει να κάνετε τις απαραίτητες ρυθμίσεις.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αυτή η ενότητα καλύπτει την έκδοση εξυπηρετητών Apache HTTP 1.3.X, μιας που αυτή η έκδοση είναι η πιο διαδεδομένη για το FreeBSD. Ο Apache 2.X παρουσιάζει πολλές νέες τεχνολογίες αλλά αυτές δεν περιγράφονται σε αυτή την ενότητα. Περισσότερες πληροφορίες για τον Apache 2.X, μπορείτε να δείτε στην σελίδα <a href=http://httpd.apache.org/>http://httpd.apache.org/</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_ρυθμίσεις>54.7.2. Ρυθμίσεις<a class=anchor href=#_ρυθμίσεις></a></h4><div class=paragraph><p>Στο FreeBSD το σημαντικότερο αρχείο ρυθμίσεων του Εξυπηρετητή HTTP Apache είναι το <span class=filename>/usr/local/etc/apache/httpd.conf</span>. Είναι ένα τυπικό UNIX® ρυθμιστικό αρχείο κειμένου, με γραμμές σχολίων που ξεκινούν με τον χαρακτήρα <code>#</code>. Σκοπός μας εδώ δεν είναι μια ολοκληρωμένη περιγραφή όλων των πιθανών επιλογών, επομένως θα περιγράψουμε μόνο τις πιο δημοφιλείς επιλογές ρυθμίσεις (configuration directives).</p></div><div class=dlist><dl><dt class=hdlist1><code>ServerRoot "/usr/local"</code></dt><dd><p>Εδώ περιγράφεται ο προεπιλεγμένος ιεραρχικά κατάλογος εγκατάστασης για τον Apache. Τα εκτελέσιμα αρχεία είναι αποθηκευμένα στους υποκαταλόγους <span class=filename>bin</span> και <span class=filename>sbin</span> του καταλόγου "ServerRoot" και τα αρχεία ρυθμίσεων αποθηκεύονται στον κατάλογο <span class=filename>etc/apache</span>.</p></dd><dt class=hdlist1><code>ServerAdmin you@your.address</code></dt><dd><p>Η ηλεκτρονική διεύθυνση στην οποία θα πρέπει να αποστέλλονται αναφορές προβλημάτων σχετικά με τον εξυπηρετητή. Αυτή η διεύθυνση εμφανίζεται σε κάποιες σελίδες που δημιουργούνται από τον εξυπηρετητή, όπως οι σελίδες σφαλμάτων.</p></dd><dt class=hdlist1><code>ServerName www.example.com</code></dt><dd><p>Το <code>ServerName</code> σας επιτρέπει να θέσετε ένα όνομα κόμβου (hostname) για τον εξυπηρετητή σας, το οποίο αποστέλλεται πίσω στους clients αν είναι διαφορετικό από εκείνο που έχετε ήδη ρυθμίσει στον κόμβο σας (εδώ μπορείτε, για παράδειγμα, να χρησιμοποιήσετε <code>www</code> αντί του πραγματικού ονόματος του κόμβου).</p></dd><dt class=hdlist1><code>DocumentRoot "/usr/local/www/data"</code></dt><dd><p><code>DocumentRoot</code>: Είναι ο κατάλογος από τον οποίο θα προσφέρονται τα έγγραφα σας. Προεπιλεγμένα, όλα τα αιτήματα θα εξυπηρετούνται από αυτό τον κατάλογο, αλλά μπορούν επίσης να χρησιμοποιηθούν συμβολικοί δεσμοί (symbolic link) ή παρωνύμια (aliases) που θα στοχεύουν σε άλλες τοποθεσίες.</p></dd></dl></div><div class=paragraph><p>Πριν κάνετε οποιαδήποτε αλλαγή, είναι καλό να δημιουργείτε αντίγραφα ασφαλείας (backup) του αρχείου ρυθμίσεων του Apache. Μόλις κρίνετε πως είστε ικανοποιημένος με τις αρχικές ρυθμίσεις μπορείτε να ξεκινήσετε με την εκτέλεση του Apache.</p></div></div><div class=sect3><h4 id=_εκτέλεση_του_apache>54.7.3. Εκτέλεση του Apache<a class=anchor href=#_εκτέλεση_του_apache></a></h4><div class=paragraph><p>O Apache δεν τρέχει διαμέσου του υπερ-διακομιστή inetd όπως κάνουν πολλοί άλλοι δικτυακοί εξυπηρετητές. Είναι ρυθμισμένος να τρέχει αυτόνομα για να εξυπηρετεί καλύτερα τις αιτήσεις HTTP των πελατών του, δηλαδή των προγραμμάτων πλοήγησης (browsers). Η εγκατάσταση του Apache από τα FreeBSD Ports περιέχει ένα βοηθητικό shell script για την εκκίνηση, το σταμάτημα και την επανεκκίνηση του εξυπηρετητή. Για να ξεκινήσετε τον Apache για πρώτη φορά, απλά τρέξτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl start</span></code></pre></div></div><div class=paragraph><p>Μπορείτε οποιαδήποτε στιγμή να σταματήσετε τον εξυπηρετητή, πληκτρολογώντας:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl stop</span></code></pre></div></div><div class=paragraph><p>Μετά από αλλαγές που πιθανώς να κάνατε για οποιονδήποτε λόγο στο αρχείο ρυθμίσεων, θα χρειαστεί να επανεκκινήσετε τον εξυπηρετητή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl restart</span></code></pre></div></div><div class=paragraph><p>Για να επανεκκινήσετε τον Apache δίχως να διακόψετε τις τρέχουσες συνδέσεις, τρέξτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl graceful</span></code></pre></div></div><div class=paragraph><p>Περισσότερες πληροφορίες θα βρείτε στη σελίδα βοήθειας του <a href="https://man.freebsd.org/cgi/man.cgi?query=apachectl&amp;sektion=8&amp;format=html">apachectl(8)</a>.</p></div><div class=paragraph><p>Για να ξεκινάει ο Apache αυτόματα κατά τη διάρκεια εκκίνησης του συστήματος, προσθέστε την ακόλουθη γραμμή στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>apache_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Αν επιθυμείτε να παρέχονται κατά την εκκίνηση του συστήματος πρόσθετες επιλογές στην γραμμή εντολών για το πρόγραμμα Apache <code>httpd</code> μπορείτε να τις δηλώσετε με μια πρόσθετη γραμμή στο <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>apache_flags=&#34;&#34;</pre></div></div><div class=paragraph><p>Τώρα που έχει ξεκινήσει ο εξυπηρετής web, μπορείτε να δείτε την ιστοσελίδα σας στοχεύοντας το πρόγραμμα πλοήγησης στο <code><a href=http://localhost/ class=bare>http://localhost/</a></code>. Η προκαθορισμένη σελίδα που εμφανίζεται είναι η <span class=filename>/usr/local/www/data/index.html</span>.</p></div></div><div class=sect3><h4 id=_virtual_hosting>54.7.4. Virtual Hosting<a class=anchor href=#_virtual_hosting></a></h4><div class=paragraph><p>Ο Apache υποστηρίζει δύο διαφορετικούς τύπους Virtual Hosting. Το Ονομαστικό virtual hosting χρησιμοποιεί τους HTTP/1.1 headers για να καθορίσει τον κόμβο. Αυτό επιτρέπει την κοινή χρήση της ίδιας IP για πολλά και διαφορετικά domains.</p></div><div class=paragraph><p>Για να ρυθμίσετε τον Apache να χρησιμοποιεί το Ονομαστικό Virtual Hosting εισάγετε μια καταχώριση στο <span class=filename>httpd.conf</span> σαν την ακόλουθη:</p></div><div class="literalblock programlisting"><div class=content><pre>NameVirtualHost *</pre></div></div><div class=paragraph><p>Αν ο διακομιστής web ονομάζεται <code>www.domain.tld</code> και επιθυμείτε να εγκαταστήσετε ένα virtual domain για το <code>www.someotherdomain.tld</code> τότε θα πρέπει να προσθέσετε τις ακόλουθες καταχωρήσεις στο <span class=filename>httpd.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&lt;VirtualHost <span class=k>*</span><span class=o>&gt;</span>
ServerName www.domain.tld
DocumentRoot /www/domain.tld
&lt;/VirtualHost&gt;

&lt;VirtualHost <span class=k>*</span><span class=o>&gt;</span>
ServerName www.someotherdomain.tld
DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</code></pre></div></div><div class=paragraph><p>Αντικαταστήστε τις παραπάνω διευθύνσεις με εκείνες που επιθυμείτε να χρησιμοποιήσετε και την κατάλληλη διαδρομή προς τα έγγραφά σας.</p></div><div class=paragraph><p>Για περισσότερες πληροφορίες σχετικά με τις ρυθμίσεις για τα virtual host, σας προτρέπουμε να συμβουλευτείτε την επίσημη τεκμηρίωση του Apache στο <a href=http://httpd.apache.org/docs/vhosts/>http://httpd.apache.org/docs/vhosts/</a>.</p></div></div><div class=sect3><h4 id=_apache_modules>54.7.5. Apache Modules<a class=anchor href=#_apache_modules></a></h4><div class=paragraph><p>Υπάρχουν πολλοί και διάφοροι διαθέσιμοι τύποι αρθρωμάτων (modules) για τον Apache, τα οποία επεκτείνουν κι εμπλουτίζουν τις λειτουργίες του βασικού εξυπηρετητή. Η Συλλογή των Ports του FreeBSD παρέχει έναν εύκολο τρόπο για να εγκαταστήσετε τον Apache και μερικά από τα πιο δημοφιλή αρθρώματα.</p></div><div class=sect4><h5 id=_mod_ssl>54.7.5.1. mod_ssl<a class=anchor href=#_mod_ssl></a></h5><div class=paragraph><p>Το άρθρωμα mod_ssl χρησιμοποιεί την βιβλιοθήκη OpenSSL για να παρέχει ισχυρή κρυπτογράφηση διαμέσου των πρωτοκόλων Secure Sockets Layer (SSL v2/v3) και Transport Layer Security (TLS v1). Το άρθρωμα παρέχει όλα τα απαραίτητα συστατικά για να μπορεί να αιτείται υπογεγγραμμένα πιστοποιητικά από έμπιστους εξουσιοδοτημένους φορείς πιστοποίησης έτσι ώστε να μπορείτε να τρέχετε έναν ασφαλή εξυπηρετητή web στο FreeBSD.</p></div><div class=paragraph><p>Εάν δεν έχετε εγκαταστήσει ακόμη τον Apache, μπορείτε να εγκαταστήσετε την έκδοση του Apache 1.3.X που περιλαμβάνει το mod_ssl από την port <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-modssl/>www/apache13-modssl</a> . Το SSL είναι επίσης διαθέσιμο για τον Apache 2.X στην port <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache20/>www/apache20</a>, όπου το SSL είναι ενεργοποιημένο από προεπιλογή.</p></div></div><div class=sect4><h5 id=_δυναμικές_ιστοσελίδες_με_perl_php>54.7.5.2. Δυναμικές Ιστοσελίδες με Perl & PHP<a class=anchor href=#_δυναμικές_ιστοσελίδες_με_perl_php></a></h5><div class=paragraph><p>Την τελευταία δεκαετία, πολλές επιχειρήσεις στρέψανε τις δραστηριότητες τους προς το Ίντερνετ με σκοπό να βελτιώσουν τα έσοδα τους και για μεγαλύτερη προβολή. Αυτό με τη σειρά του δημιούργησε την ανάγκη για διαδραστικό διαδικτυακό περιεχόμενο. Ενώ κάποιες εταιρείες, όπως η Microsoft®, παρουσίασαν λύσεις ενσωματωμένες στα ιδιόκτητα προϊόντα τους, η κοινότητα ανοιχτού λογισμικού έλαβε το μήνυμα. Στις σύγχρονες επιλογές για διαδικτυακές σελίδες δυναμικού περιεχομένου περιλαμβάνονται τα Django, Ruby on Rails, mod_perl και mod_php. mod_perl & mod_php.</p></div><div class=sect5><h6 id=_mod_perl>54.7.5.2.1. mod_perl<a class=anchor href=#_mod_perl></a></h6><div class=paragraph><p>Το γεγονός συνύπαρξης Apache/Perl φέρνει κοντά τη μεγάλη δύναμη της γλώσσας προγραμματισμού Perl και τον εξυπηρετητή HTTP Apache. Με το άρθρωμα mod_perl έχετε τη δυνατότητα να γράψετε επεκτάσεις για τον Apache εξ' ολοκλήρου σε Perl. Επιπλέον, ο διατηρήσιμος μεταγλωττιστής που είναι ενσωματωμένος στον εξυπηρετητή σας επιτρέπει να αποφύγετε την χρήση ενός εξωτερικού μεταγλωττιστή Perl και να επιβαρυνθείτε από το χρόνο εκκίνησης του.</p></div><div class=paragraph><p>Το mod_perl διατίθεται με διάφορους τρόπους. Για να χρησιμοποιήσετε το mod_perl να θυμάστε ότι το mod_perl 1.0 mod_perl 1.0 δουλεύει μόνο με τον Apache 1.3 και το mod_perl 2.0 δουλεύει μόνο με τον Apache 2. Το mod_perl 1.0 είναι διαθέσιμο στο port <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_perl/>www/mod_perl</a> ενώ μια στατικά μεταγλωττισμένη έκδοση είναι διαθέσιμη στο <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-modperl/>www/apache13-modperl</a>. Το mod_perl 2.0 διατίθεται στο port <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_perl2/>www/mod_perl2</a>.</p></div></div><div class=sect5><h6 id=_mod_php>54.7.5.2.2. mod_php<a class=anchor href=#_mod_php></a></h6><div class=paragraph><p>Το PHP, γνωστό και ως "PHP: Hypertext Preprocessor" είναι μια script γλώσσα προγραμματισμού γενικής χρήσης αλλά ιδιαίτερα κατάλληλη για ανάπτυξη λογισμικού Web. Η σύνταξή της προέρχεται από τις C, Java™ και Perl και έχει την δυνατότητα να ενσωματώνεται σε κώδικα HTML, με σκοπό να επιτρέπει στους προγραμματιστές web να γράφουν γρήγορα δυναμικές ιστοσελίδες.</p></div><div class=paragraph><p>Ο Apache υποστηρίζει το PHP5. Μπορείτε να ξεκινήσετε εγκαθιστώντας το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a>.</p></div><div class=paragraph><p>Αν το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> εγκαθίσταται για πρώτη φορά, αυτόματα θα σας εμφανιστούν όλες οι δυνατές επιλογές <code>OPTIONS</code>. Αν κάποιο μενού δεν εμφανίζεται, π.χ. επειδή το πακέτο <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> είχε εγκατασταθεί στο παρελθόν, μπορείτε πάντα να ρυθμίσετε από την αρχή το πακέτο, τρέχοντας στον κατάλογο του port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make config</span></code></pre></div></div><div class=paragraph><p>Στις επιλογές εγκατάστασης, διαλέξτε την επιλογή <code>APACHE</code> ώστε να συμπεριληφθεί και το άρθρωμα mod_php για τον εξυπηρετητή Apache.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μερικές τοποθεσίες χρησιμοποιούν ακόμη το PHP4 για διάφορους λόγους (π.χ. θέματα συμβατότητος ή επειδή έχουν ήδη εγκατεστημένες εφαρμογές που το απαιτούν). Αν είναι ανάγκη να χρησιμοποιήσετε το mod_php4 αντί του mod_php5, τότε χρησιμοποιείστε το port <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php4/>lang/php4</a>. Το port <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php4/>lang/php4</a> υποστηρίζει πολλές από τις ρυθμίσεις και τις επιλογές εγκατάστασης του port <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a>.</p></div></td></tr></tbody></table></div><div class=dlist><dl><dt class=hdlist1>Με αυτό τον τρόπο θα εγκατασταθούν και θα ρυθμιστούν τα απαιτούμενα αρθρώματα ώστε να υποστηρίζουν δυναμικές εφαρμογές PHP. Για επιβεβαίωση ελέγξτε πως έχουν προστεθεί στις αντίστοιχες ενότητες του <span class=filename>/usr/local/etc/apache/httpd.conf</span> τα ακόλουθα</dt></dl></div><div class="literalblock programlisting"><div class=content><pre>LoadModule php5_module        libexec/apache/libphp5.so</pre></div></div><div class="literalblock programlisting"><div class=content><pre>AddModule mod_php5.c
    &lt;IfModule mod_php5.c&gt;
        DirectoryIndex index.php index.html
    &lt;/IfModule&gt;
    &lt;IfModule mod_php5.c&gt;
        AddType application/x-httpd-php .php
        AddType application/x-httpd-php-source .phps
    &lt;/IfModule&gt;</pre></div></div><div class=paragraph><p>Αφού ολοκληρώσετε τον έλεγχο, για να φορτωθεί το άρθρωμα PHP χρειάζεται μια απλή κλήση με την εντολή <code>apachectl</code> για μια κανονική (graceful) επανεκκίνηση:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div><div class=paragraph><p>Για μελλοντικές αναβαθμίσεις του PHP, δεν απαιτείται η εντολή <code>make config</code>. Οι επιλεγμένες <code>OPTIONS</code> αποθηκεύονται αυτόματα από το μηχανισμό εγκατάστασης των Ports του FreeBSD.</p></div><div class=paragraph><p>Η σύνθεση του PHP στο FreeBSD, είναι εξαιρετικά στοιχειακή, και ο βασικός κορμός που έχει εγκατασταθεί είναι πολύ περιορισμένος. Είναι πολύ εύκολο όμως να προσθέσουμε επεκτάσεις χρησιμοποιώντας το port <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5-extensions/>lang/php5-extensions</a>. Αυτό το port παρέχει μενού επιλογών για την εγκατάσταση των επεκτάσιμων συστατικών του PHP. Εναλλακτικά, μπορείτε να εγκαταστήσετε καθεμία επέκταση ξεχωριστά χρησιμοποιώντας το κατάλληλο port.</p></div><div class=paragraph><p>Για παράδειγμα, για να προσθέσετε στο PHP5, τη δυνατότητα υποστήριξης για βάσεις δεδομένωνMySQL απλά εγκαταστήστε το port <a class=package href=https://cgit.freebsd.org/ports/tree/databases/php5-mysql/>databases/php5-mysql</a>.</p></div><div class=paragraph><p>Μετά την εγκατάσταση ενός νέου αρθρώματος ή κάποιας άλλης επέκτασης, ο εξυπηρετητής Apache θα πρέπει να επαναφορτωθεί για να ενεργοποιηθούν οι νέες ρυθμίσεις:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div></div></div></div></div><div class=sect2><h3 id=network-ftp>54.8. Πρωτόκολο Μεταφοράς Αρχείων (FTP)<a class=anchor href=#network-ftp></a></h3><div class=sect3><h4 id=_σύνοψη_2>54.8.1. Σύνοψη<a class=anchor href=#_σύνοψη_2></a></h4><div class=paragraph><p>Το Πρωτόκολο Μεταφοράς Αρχείων (File Transfer Protocol - FTP) παρέχει στους χρήστες έναν εύκολο τρόπο για να μεταφέρουν τα αρχεία τους από και προς έναν εξυπηρετητή FTP. Το βασικό σύστημα του FreeBSD περιλαμβάνει ένα εξυπηρετητή FTP, το ftpd. Αυτό καθιστά την εγκατάσταση και την διαχείριση του εξυπηρετητή FTP πολύ εύκολη υπόθεση.</p></div></div><div class=sect3><h4 id=_ρυθμίσεις_2>54.8.2. Ρυθμίσεις<a class=anchor href=#_ρυθμίσεις_2></a></h4><div class=paragraph><p>Το πιο σημαντικό βήμα στις ρυθμίσεις είναι να αποφασίσετε σε ποιούς λογαριασμούς θα επιτραπεί η πρόσβαση στον εξυπηρετητή FTP. Ένα συνηθισμένο σύστημα FreeBSD δημιουργεί μερικούς λογαριασμούς συστήματος για διάφορους δαίμονες, αλλά δεν πρέπει να επιτρέπεται η πρόσβαση στο σύστημα με αυτούς τους λογαριασμούς. Το αρχείο <span class=filename>/etc/ftpusers</span> περιέχει μια λίστα από χρήστες για τους οποίους απορρίπτεται η πρόσβαση μέσω FTP. Προεπιλεγμένα, περιέχονται οι προαναφερθέντες λογαριασμοί του συστήματος, αλλά μπορείτε επίσης να προσθέσετε συγκεκριμένους χρήστες που δε θα πρέπει να έχουν πρόσβαση μέσω FTP.</p></div><div class=paragraph><p>Μπορείτε αν θέλετε να περιορίσετε την πρόσβαση σε κάποιους χρήστες, δίχως όμως να τους εμποδίσετε πλήρως. Αυτό μπορεί να συμβεί με τις ρυθμίσεις του αρχείου <span class=filename>/etc/ftpchroot</span>. Αυτό το αρχείο περιέχει λίστες χρηστών και ομάδων περιορισμένης πρόσβασης FTP. Η σελίδα βοήθειας <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpchroot&amp;sektion=5&amp;format=html">ftpchroot(5)</a> περιέχει όλες τις απαραίτητες λεπτομέρειες, επομένως δε θα χρειαστεί να μπούμε σε λεπτομέρειες εδώ.</p></div><div class=paragraph><p>Αν επιθυμείτε να ενεργοποιήσετε ανώνυμη πρόσβαση FTP στον εξυπηρετητή σας, θα πρέπει να δημιουργήσετε, στο FreeBSD σύστημα σας, ένα χρήστη με όνομα <code>ftp</code> . Οι ανώνυμοι χρήστες θα μπορούν να εισέρχονται στον εξυπηρετητή FTP με το γενικό όνομα χρήστη <code>ftp</code> ή με <code>anonymous</code> και με οποιαδήποτε κωδικό πρόσβασης (συνηθίζεται να ζητείται η διεύθυνση email του χρήστη ως κωδικός πρόσβασης). Ο εξυπηρετητής FTP θα καλέσει το <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> μόλις εισέλθη ο ανώνυμος χρήστης, για να του περιορίσει την πρόσβαση, επιτρέποντας του μόνο τον αρχικό κατάλογο (home directory) του χρήστη <code>ftp</code>.</p></div><div class=paragraph><p>Υπάρχουν δύο αρχεία κειμένου για τον ορισμό μηνυμάτων καλωσορίσματος που θα εμφανίζονται στους πελάτες FTP. Το περιεχόμενο του αρχείου <span class=filename>/etc/ftpwelcome</span> εμφανίζεται στους χρήστες πριν φτάσουν στην προτροπή εισόδου. Μετά από μια πετυχημένη είσοδο στο σύστημα, εμφανίζεται το περιεχόμενο του αρχείου <span class=filename>/etc/ftpmotd</span>. Παρατηρήστε πως η διαδρομή σε αυτό το αρχείο είναι σχετική με το περιβάλλον πρόσβασης, επομένως για τους ανώνυμους χρήστες θα εμφανίζεται το περιεχόμενο του αρχείου <span class=filename>~ftp/etc/ftpmotd</span>.</p></div><div class=paragraph><p>Αφού ρυθμίσετε κατάλληλα τον εξυπηρετητή FTP, θα πρέπει να τον ενεργοποιήσετε στο αρχείο <span class=filename>/etc/inetd.conf</span>. Το μόνο που χρειάζεται να κάνετε είναι να αφαιρέσετε το σύμβολο σχολιασμού "#" μπροστά από την υπάρχουσα γραμμή ftpd :</p></div><div class="literalblock programlisting"><div class=content><pre>ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l</pre></div></div><div class=paragraph><p>Όπως εξηγήσαμε στο <a href=#network-inetd-reread>Reloading the inetd configuration file</a>, η διεργασία inetd θα πρέπει να ξαναφορτώνεται αν έχουν γίνει αλλαγές στο αρχείο ρυθμίσεων της.</p></div><div class=paragraph><p>Τώρα μπορείτε να δώσετε τα στοιχεία του λογαριασμού σας για να εισέλθετε στον εξυπηρετητή FTP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftp localhost</code></pre></div></div></div><div class=sect3><h4 id=_συντήρηση>54.8.3. Συντήρηση<a class=anchor href=#_συντήρηση></a></h4><div class=paragraph><p>Ο δαίμονας ftpd χρησιμοποιεί το <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> για την δημιουργία μηνυμάτων αναφοράς. Προεπιλεγμένα, ο δαίμονας των log του συστήματος θα εναποθέτει τις σχετικές με το FTP αναφορές στο αρχείο <span class=filename>/var/log/xferlog</span>. Η τοποθεσία του αρχείου αναφοράς μπορεί να τροποποιηθεί αλλάζοντας την ακόλουθη γραμμή στο <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp.info      /var/log/xferlog</pre></div></div><div class=paragraph><p>Πρέπει να είστε ενήμεροι για τα προβλήματα που μπορούν να παρουσιαστούν σχετικά με τη λειτουργία ενός ανώνυμου εξυπηρετητή FTP. Ειδικότερα, θα πρέπει να σκεφτείτε σοβαρά αν όντως επιθυμείτε να έχουν δυνατότητα να ανεβάζουν αρχεία οι ανώνυμοι χρήστες σας. Αν αφήσετε οποιονδήποτε ανώνυμο χρήστη να ανεβάζει αρχεία, μπορεί ξαφνικά να ανακαλύψετε πως ο εξυπηρετητής σας FTP χρησιμοποιείται για διακίνηση πειρατικού εμπορικού λογισμικού ή για άλλο, ακόμα χειρότερο, παράνομο υλικό. Εάν όντως χρειάζεται οι χρήστες να έχουν άδεια προσθήκης αρχείων, τότε θα πρέπει να ρυθμίσετε τις άδειες έτσι ώστε τα αρχεία αυτά να μην είναι ορατά από άλλους ανώνυμους χρήστες, έως ότου να πάρουν την ασφαλή έγκριση σας.</p></div></div></div><div class=sect2><h3 id=network-samba>54.9. File and Print Services for Microsoft® Windows® clients (Samba)<a class=anchor href=#network-samba></a></h3><div class=sect3><h4 id=_overview_2>54.9.1. Overview<a class=anchor href=#_overview_2></a></h4><div class=paragraph><p>Samba is a popular open source software package that provides file and print services for Microsoft® Windows® clients. Such clients can connect to and use FreeBSD filespace as if it was a local disk drive, or FreeBSD printers as if they were local printers.</p></div><div class=paragraph><p>Samba software packages should be included on your FreeBSD installation media. If you did not install Samba when you first installed FreeBSD, then you can install it from the <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba3/>net/samba3</a> port or package.</p></div></div><div class=sect3><h4 id=_configuration_5>54.9.2. Configuration<a class=anchor href=#_configuration_5></a></h4><div class=paragraph><p>A default Samba configuration file is installed as <span class=filename>/usr/local/etc/smb.conf.default</span>. This file must be copied to <span class=filename>/usr/local/etc/smb.conf</span> and customized before Samba can be used.</p></div><div class=paragraph><p>The <span class=filename>smb.conf</span> file contains runtime configuration information for Samba, such as definitions of the printers and "file system shares" that you would like to share with Windows® clients. The Samba package includes a web based tool called swat which provides a simple way of configuring the <span class=filename>smb.conf</span> file.</p></div><div class=sect4><h5 id=_using_the_samba_web_administration_tool_swat>54.9.2.1. Using the Samba Web Administration Tool (SWAT)<a class=anchor href=#_using_the_samba_web_administration_tool_swat></a></h5><div class=paragraph><p>The Samba Web Administration Tool (SWAT) runs as a daemon from inetd. Therefore, the following line in <span class=filename>/etc/inetd.conf</span> should be uncommented before swat can be used to configure Samba:</p></div><div class="literalblock programlisting"><div class=content><pre>swat   stream  tcp     nowait/400      root    /usr/local/sbin/swat</pre></div></div><div class=paragraph><p>As explained in <a href=#network-inetd-reread>Reloading the inetd configuration file</a>, the inetd must be reloaded after this configuration file is changed.</p></div><div class=paragraph><p>Once swat has been enabled in <span class=filename>inetd.conf</span>, you can use a browser to connect to <a href=http://localhost:901>http://localhost:901</a>. You will first have to log on with the system <code>root</code> account.</p></div><div class=paragraph><p>Once you have successfully logged on to the main Samba configuration page, you can browse the system documentation, or begin by clicking on the <b class=menuref>Globals</b> tab. The <b class=menuref>Globals</b> section corresponds to the variables that are set in the <code>[global]</code> section of <span class=filename>/usr/local/etc/smb.conf</span>.</p></div></div><div class=sect4><h5 id=_global_settings>54.9.2.2. Global Settings<a class=anchor href=#_global_settings></a></h5><div class=paragraph><p>Whether you are using swat or editing <span class=filename>/usr/local/etc/smb.conf</span> directly, the first directives you are likely to encounter when configuring Samba are:</p></div><div class=dlist><dl><dt class=hdlist1><code>workgroup</code></dt><dd><p>NT Domain-Name or Workgroup-Name for the computers that will be accessing this server.</p></dd><dt class=hdlist1><code>netbios name</code></dt><dd><p>This sets the NetBIOS name by which a Samba server is known. By default it is the same as the first component of the host’s DNS name.</p></dd><dt class=hdlist1><code>server string</code></dt><dd><p>This sets the string that will be displayed with the <code>net view</code> command and some other networking tools that seek to display descriptive text about the server.</p></dd></dl></div></div><div class=sect4><h5 id=_security_settings>54.9.2.3. Security Settings<a class=anchor href=#_security_settings></a></h5><div class=paragraph><p>Two of the most important settings in <span class=filename>/usr/local/etc/smb.conf</span> are the security model chosen, and the backend password format for client users. The following directives control these options:</p></div><div class=dlist><dl><dt class=hdlist1><code>security</code></dt><dd><p>The two most common options here are <code>security = share</code> and <code>security = user</code>. If your clients use usernames that are the same as their usernames on your FreeBSD machine then you will want to use user level security. This is the default security policy and it requires clients to first log on before they can access shared resources.</p><div class=paragraph><p>In share level security, client do not need to log onto the server with a valid username and password before attempting to connect to a shared resource. This was the default security model for older versions of Samba.</p></div></dd><dt class=hdlist1><code>passdb backend</code></dt><dd><p>Samba has several different backend authentication models. You can authenticate clients with LDAP, NIS+, a SQL database, or a modified password file. The default authentication method is <code>smbpasswd</code>, and that is all that will be covered here.</p></dd></dl></div><div class=paragraph><p>Assuming that the default <code>smbpasswd</code> backend is used, the <span class=filename>/usr/local/private/smbpasswd</span> file must be created to allow Samba to authenticate clients. If you would like to give your UNIX® user accounts access from Windows® clients, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># smbpasswd -a username</span></code></pre></div></div><div class=paragraph><p>Please see the <a href=http://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/>Official Samba HOWTO</a> for additional information about configuration options. With the basics outlined here, you should have everything you need to start running Samba.</p></div></div></div><div class=sect3><h4 id=_starting_samba>54.9.3. Starting Samba<a class=anchor href=#_starting_samba></a></h4><div class=paragraph><p>The <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba3/>net/samba3</a> port adds a new startup script, which can be used to control Samba. To enable this script, so that it can be used for example to start, stop or restart Samba, add the following line to the <span class=filename>/etc/rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>samba_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This will also configure Samba to automatically start at system boot time.</p></div></td></tr></tbody></table></div><div class=paragraph><p>It is possible then to start Samba at any time by typing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/samba start</span>
Starting SAMBA: removing stale tdbs :
Starting nmbd.
Starting smbd.</code></pre></div></div><div class=paragraph><p>Please refer to <a href=./#configtuning-rcd>Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD</a> for more information about using rc scripts.</p></div><div class=paragraph><p>Samba actually consists of three separate daemons. You should see that both the nmbd and smbd daemons are started by the <span class=filename>samba.sh</span> script. If you enabled winbind name resolution services in <span class=filename>smb.conf</span>, then you will also see that the winbindd daemon is started.</p></div><div class=paragraph><p>You can stop Samba at any time by typing :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/samba.sh stop</span></code></pre></div></div><div class=paragraph><p>Samba is a complex software suite with functionality that allows broad integration with Microsoft® Windows® networks. For more information about functionality beyond the basic installation described here, please see <a href=http://www.samba.org>http://www.samba.org</a>.</p></div></div></div><div class=sect2><h3 id=network-ntp>54.10. Συγχρονισμός Ρολογιού Συστήματος με NTP<a class=anchor href=#network-ntp></a></h3><div class=sect3><h4 id=_σύνοψη_3>54.10.1. Σύνοψη<a class=anchor href=#_σύνοψη_3></a></h4><div class=paragraph><p>Με το πέρασμα του χρόνου, το ρολόι συστήματος ενός υπολογιστή έχει την τάση να αποσυγχρονίζεται. Το Πρωτόκολο Χρονισμού Δικτύων (Network Time Protocol ή NTP) παρέχει ένα τρόπο για να εξασφαλίσετε την ακρίβεια του clock σας.</p></div><div class=paragraph><p>Πολλές διαδικτυακές υπηρεσίες βασίζονται ή ωφελούνται σε μεγάλο βαθμό από την ακρίβεια του ρολογιού συστήματος ενός υπολογιστή. Για παράδειγμα, ένας εξυπηρετητής web μπορεί να δεχθεί αιτήσεις για αποστολή ενός αρχείου όταν το αρχείο αυτό έχει τροποποιηθεί μέχρι κάποια συγκεκριμένη ώρα. Σε ένα περιβάλλον τοπικού δικτύου, είναι θεμελιώδης αρχή οι υπολογιστές που θα διαμοιραστούν αρχεία από τον ίδιο διακομιστή αρχείων να έχουν συγχρονισμένα ρολόγια, έτσι ώστε τα χρονικά χαρακτηριστικά του αρχείου να συμφωνούν. Επίσης διεργασίες όπως η <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> βασίζονται σε ένα ακριβές ρολόι ώστε να μπορούν να τρέχουν εντολές στους προκαθορισμένους χρόνους.</p></div><div class=paragraph><p>Το FreeBSD διατίθεται με τον εξυπηρετητή NTP <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>, ο οποίος μπορεί να χρησιμοποιηθεί για να συγχρονίζει το ρολόι συστήματος του υπολογιστή σας, εξετάζοντας άλλους εξυπηρετητές NTP ή να παρέχει ο ίδιος υπηρεσίες συγχρονισμού σε άλλα μηχανήματα.</p></div></div><div class=sect3><h4 id=_επιλογή_των_κατάλληλων_εξυπηρετητών_ntp>54.10.2. Επιλογή των Κατάλληλων Εξυπηρετητών NTP<a class=anchor href=#_επιλογή_των_κατάλληλων_εξυπηρετητών_ntp></a></h4><div class=paragraph><p>Για να συγχρονίσετε το ρολόι συστήματος του υπολογιστή σας θα πρέπει να βρείτε έναν ή περισσότερους διαθέσιμους NTP εξυπηρετητές για να χρησιμοποιήσετε. Ο διαχειριστής δικτύου ή ο ISP σας μπορεί να έχουν εγκαταστήσει κάποιον εξυπηρετητή NTP για αυτό το σκοπό - ελέγξτε την τεκμηρίωση τους να δείτε αν υπάρχει τέτοια περίπτωση. Επιπλέον, υπάρχει μία <a href=http://ntp.isc.org/bin/view/Servers/WebHome>online λίστα εξυπηρετητών δημόσιας πρόσβασης</a>, που μπορείτε να χρησιμοποιήσετε για να βρείτε έναν κοντινό εξυπηρετητή NTP. Όποιον εξυπηρετητή κι αν επιλέξετε, ενημερωθείτε για την πολιτική χρήσης του και ζητήστε άδεια να τον χρησιμοποιήσετε αν χρειάζεται τέτοια άδεια.</p></div><div class=paragraph><p>Είναι καλή ιδέα να επιλέξετε πολλούς εξυπηρετητές NTP, οι οποίοι να μην συνδέονται μεταξύ τους, στην περίπτωση που κάποιος από τους εξυπηρετητές που χρησιμοποιείτε γίνει απρόσιτος ή το ρολόι του είναι ανακριβές. Ο εξυπηρετητής <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> του FreeBSD χειρίζεται έξυπνα τις απαντήσεις που λαμβάνει από τους υπόλοιπους εξυπηρετητές - ευνοεί τους πιο αξιόπιστους και δείχνει μικρότερη προτίμηση στους λιγότερο αξιόπιστους εξυπηρετητές.</p></div></div><div class=sect3><h4 id=_ρυθμίστε_το_μηχάνημα_σας>54.10.3. Ρυθμίστε Το Μηχάνημα Σας<a class=anchor href=#_ρυθμίστε_το_μηχάνημα_σας></a></h4><div class=sect4><h5 id=_βασικές_ρυθμίσεις>54.10.3.1. Βασικές Ρυθμίσεις<a class=anchor href=#_βασικές_ρυθμίσεις></a></h5><div class=paragraph><p>Αν επιθυμείτε να συγχρονίζεται το clock σας μόνο κατά την εκκίνηση λειτουργίας του μηχανήματος, τότε μπορείτε να χρησιμοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a>. Αυτός ο τρόπος συγχρονισμού είναι κατάλληλος για μηχανήματα desktop τα οποία κάνουν επανακκίνηση ανά τακτά χρονικά διαστήματα και μόνο σε ειδικές περιπτώσεις έχουν ανάγκη συγχρονισμού. Αντιθέτως, τα υπόλοιπα μηχανήματα θα πρέπει να τρέχουν την διεργασία <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>.</p></div><div class=paragraph><p>Είναι καλή πρακτική τα μηχανήματα που τρέχουν <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> να χρησιμοποιούν και το <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> κατά τη διάρκεια εκκίνησης τους. Το <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> μεταβάλλει το clock βαθμιαία, ενώ το <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> ρυθμίζει άμεσα το clock ανεξάρτητα από το πόσο μεγάλη είναι η χρονική διαφορά μεταξύ πραγματικής και τρέχουσας ώρας του clock του μηχανήματος.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> κατά την εκκίνηση, προσθέστε <code>ntpdate_enable="YES"</code> στο <span class=filename>/etc/rc.conf</span>. Θα πρέπει να προσδιορίσετε στο <code>ntpdate_flags</code> όλους τους διακομιστές με τους οποίους επιθυμείτε να συγχρονίζεστε και όλα τα flag που θέλετε να συνοδεύουν το<a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a>.</p></div></div><div class=sect4><h5 id=_γενικές_ρυθμίσεις>54.10.3.2. Γενικές Ρυθμίσεις<a class=anchor href=#_γενικές_ρυθμίσεις></a></h5><div class=paragraph><p>Οι ρυθμίσεις του NTP βρίσκονται στο αρχείο <span class=filename>/etc/ntp.conf</span> και είναι στη μορφή που περιγράφεται στο <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a>. Ακολουθεί ένα απλό παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</pre></div></div><div class=paragraph><p>Η επιλογή <code>server</code> προσδιορίζει ποιοι εξυπηρετητές θα χρησιμοποιηθούν, παραθέτοντας έναν σε κάθε γραμμή. Αν ένας εξυπηρετητής φέρει το πρόθεμα <code>prefer</code>, όπως συμβαίνει με τον <code>ntplocal.example.com</code>, τότε αυτός ο εξυπηρετητής είναι ο προτιμώμενος. Θα απορριφθεί η απάντηση από τον προτιμώμενο εξυπηρετητή σε περίπτωση που διαφέρει σημαντικά από όλους τους άλλους εξυπηρετητές, Σε περίπτωση που δεν υπάρχει μεγάλη απόκλιση θα χρησιμοποιηθεί δίχως να ληφθούν υπόψιν οι άλλες απαντήσεις. Το πρόθεμα <code>prefer</code> συνήθως χρησιμοποιείται με εξυπηρετητές NTP ακριβείας, όπως αυτοί που φέρουν ειδικούς μηχανισμούς παρακολούθησης χρονισμού.</p></div><div class=paragraph><p>Η επιλογή <code>driftfile</code> προσδιορίζει ποιό αρχείο χρησιμοποιείται για να διατηρεί τη συχνότητα διόρθωσης του clock του συστήματος. Το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> χρησιμοποιεί αυτόματα αυτή τη τιμή για να αντισταθμίζει τις φυσικές αποκλίσεις του clock, επιτρέποντας του να διατηρεί μια λογική ρύθμιση, ακόμη κι αν του απαγορευτεί για κάποιο χρονικό διάστημα η πρόσβαση προς όλες τις εξωτερικές πηγές συγχρονισμού.</p></div><div class=paragraph><p>Η επιλογή <code>driftfile</code> προσδιορίζει ποιό αρχείο χρησιμοποιείται για να αποθηκεύει πληροφορίες σχετικά με τις προηγούμενες απαντήσεις από τους εξυπηρετητές NTP. Αυτό το αρχείο περιέχει εσωτερικές πληροφορίες του NTP. Δεν θα έπρεπε να τροποποιείτε από καμμία άλλη διεργασία.</p></div></div><div class=sect4><h5 id=_έλεγχος_πρόσβασης_στον_εξυπηρετητή_σας>54.10.3.3. Έλεγχος Πρόσβασης στον Εξυπηρετητή Σας<a class=anchor href=#_έλεγχος_πρόσβασης_στον_εξυπηρετητή_σας></a></h5><div class=paragraph><p>Προεπιλεγμένα, ο εξυπηρετητής σας NTP θα είναι προσβάσιμος από όλους τους κόμβους στο διαδίκτυο. Η επιλογή <code>restrict</code> στο <span class=filename>/etc/ntp.conf</span> σας επιτρέπει να ελέγχετε ποια μηχανήματα θα μπορούν να έχουν πρόσβαση στον εξυπηρετή σας.</p></div><div class=paragraph><p>Αν επιθυμείτε να απορρίψετε την πρόσβαση προς τον εξυπηρετητή σας NTP για όλα τα μηχανήματα, προσθέστε την ακόλουθη γραμμή στο <span class=filename>/etc/ntp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>restrict default ignore</pre></div></div><div class=paragraph><p>Αν θέλετε μόνο να επιτρέψετε τον συγχρονισμό του εξυπηρετητή σας με μηχανήματα εντός του δικτύου σας, αλλά δίχως δυνατότητα ρύθμισης του εξυπηρετητή ή να γίνουν ομοιόβαθμα με άδεια συγχρονισμού, τότε αντιθέτως προσθέστε:</p></div><div class="literalblock programlisting"><div class=content><pre>restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</pre></div></div><div class=paragraph><p>όπου <code>192.168.1.0</code> είναι η διεύθυνση IP του δικτύου και <code>255.255.255.0</code> είναι η μάσκα του δικτύου σας.</p></div><div class=paragraph><p>Το <span class=filename>/etc/ntp.conf</span> μπορεί να περιέχει πολλαπλές επιλογές <code>restrict</code>. Για περισσότερες πληροφορίες, δείτε την υποενότητα <code>Υποστήριξη Ελέγχου Πρόσβασης (Access Control Support)</code>, υποενότητα του <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a>.</p></div></div></div><div class=sect3><h4 id=_εκτέλεση_του_ntp_εξυπηρετητή_σας>54.10.4. Εκτέλεση του NTP Εξυπηρετητή Σας<a class=anchor href=#_εκτέλεση_του_ntp_εξυπηρετητή_σας></a></h4><div class=paragraph><p>Για να βεβαιωθείτε πως ο εξυπηρετητής NTP θα ξεκινάει κατά την διάρκεια εκκίνησης του συστήματος, προσθέστε τη γραμμή <code>ntpd_enable="YES"</code> στο <span class=filename>/etc/rc.conf</span>. Για να ξεκινήσετε τον εξυπηρετητή δίχως να επανεκκινήσετε το μηχάνημα σας, τρέξτε <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> προσδιορίζοντας κάθε επιπρόσθετη παράμετρο από τα <code>ntpd_flags</code> στο <span class=filename>/etc/rc.conf</span>. Για παράδειγμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ntpd -p /var/run/ntpd.pid</span></code></pre></div></div></div><div class=sect3><h4 id=_χρήση_του_ntpd_με_προσωρινή_σύνδεση_στο_ίντερνετ>54.10.5. Χρήση του ntpd με Προσωρινή Σύνδεση στο Ίντερνετ<a class=anchor href=#_χρήση_του_ntpd_με_προσωρινή_σύνδεση_στο_ίντερνετ></a></h4><div class=paragraph><p>Το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> δεν χρειάζεται μια μόνιμη σύνδεση στο Ίντερνετ για να δουλέψει σωστά. Αν έχετε μια προσωρινή σύνδεση που είναι ρυθμισμένη να κάνει κλήσεις μέσω τηλεφώνου (dial out on demand), είναι καλό να μην είναι η κίνηση δεδομένων του NTP το αίτιο της κλήσης ή αυτή που θα κρατάει ενεργή την σύνδεση. Αν χρησιμοποιείτε PPP χρήστη, μπορείτε να χρησιμοποιήσετε <code>φίλτρα</code> στους κώδικες παραπομπής του <span class=filename>/etc/ppp/ppp.conf</span>, όπως για παράδειγμα:</p></div><div class="literalblock programlisting"><div class=content><pre> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</pre></div></div><div class=paragraph><p>Για περισσότερες λεπτομέρειες δείτε το <code>PACKET FILTERING</code> στην ενότητα <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> και τα παραδείγματα στο <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Σημείωση: Μερικοί ISP μπλοκάρουν την χρήση θύρας με χαμηλό αριθμό, εμποδίζοντας στο NTP να δουλεύει αφού οι απαντήσεις δεν φτάνουν ποτέ στο μηχάνημα σας.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_περαιτέρω_πληροφορίες>54.10.6. Περαιτέρω Πληροφορίες<a class=anchor href=#_περαιτέρω_πληροφορίες></a></h4><div class=paragraph><p>Η τεκμηρίωση για τους εξυπηρετητές NTP διατίθεται και σε φόρμα HTML στο <span class=filename>/usr/shared/doc/ntp/</span>.</p></div></div></div></div></div><div class=sect1><h2 id=firewalls>Chapter 55. Firewalls<a class=anchor href=#firewalls></a></h2><div class=sectionbody><div class=sect2><h3 id=firewalls-intro>55.1. Σύνοψη<a class=anchor href=#firewalls-intro></a></h3><div class=paragraph><p>Το firewall (τείχος προστασίας) καθιστά δυνατό το φιλτράρισμα της εισερχόμενης και εξερχόμενης κίνησης που διέρχεται από το σύστημα σας. Ένα firewall μπορεί να χρησιμοποιεί ένα ή περισσότερα σετ "κανόνων" για να επιθεωρεί τα πακέτα κατά την είσοδο ή έξοδο τους από μια δικτυακή σύνδεση, και να τα επιτρέπει ή να τα απορρίπτει. Οι κανόνες του firewall μπορούν να ελέγχουν ένα ή περισσότερα χαρακτηριστικά των πακέτων, συμπεριλαμβανομένων μεταξύ άλλων και του τύπου του πρωτοκόλλου, καθώς και την διεύθυνση ή/και θύρα (port) της αφετηρίας ή του προορισμού.</p></div><div class=paragraph><p>Τα firewalls μπορούν να ενισχύσουν σημαντικά την ασφάλεια ενός κόμβου ή ενός δικτύου. Μπορούν να χρησιμοποιηθούν για μία ή περισσότερες από τις ακόλουθες λειτουργίες:</p></div><div class=ulist><ul><li><p>Να προστατεύουν και να απομονώνουν τις εφαρμογές, τις υπηρεσίες και τα μηχανήματα του εσωτερικού σας δικτύου από ανεπιθύμητη κίνηση που προέρχεται από το Internet.</p></li><li><p>Να περιορίζουν ή να αποκλείουν την πρόσβαση μηχανημάτων του εσωτερικού δικτύου σε υπηρεσίες του Internet.</p></li><li><p>Να υποστηρίζουν μετάφραση δικτυακών διευθύνσεων (NAT), η οποία επιτρέπει στο εσωτερικό σας δίκτυο να χρησιμοποιεί ιδιωτικές IP διευθύνσεις και να μοιράζεται μία μοναδική σύνδεση με το Internet (είτε μέσω μίας μοναδικής δημόσιας IP διεύθυνσης, είτε μέσω ενός πλήθους δημοσίων διευθύνσεων που ανατίθενται αυτόματα).</p></li></ul></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Πως να δημιουργήσετε σωστούς κανόνες φιλτραρίσματος πακέτων.</p></li><li><p>Τους διάφορους τύπους firewall που υπάρχουν στο FreeBSD και τις διαφορές τους.</p></li><li><p>Πως να ρυθμίσετε και να χρησιμοποιήσετε το PF firewall του OpenBSD.</p></li><li><p>Πως να ρυθμίσετε και να χρησιμοποιήσετε το IPFILTER.</p></li><li><p>Πως να ρυθμίσετε και να χρησιμοποιήσετε το IPFW.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε βασικές αρχές του FreeBSD και του Internet.</p></li></ul></div></div><div class=sect2><h3 id=firewalls-concepts>55.2. Βασικές Έννοιες των Firewalls<a class=anchor href=#firewalls-concepts></a></h3><div class=paragraph><p>Υπάρχουν δύο βασικοί τρόποι για τη δημιουργία κανόνων σε ένα firewall: ο "inclusive" και ο "exclusive". Ένα exclusive firewall επιτρέπει τη διέλευση όλης της κίνησης, εκτός από αυτή που ταιριάζει με τους κανόνες του. Ένα inclusive firewall κάνει το ανάποδο. Επιτρέπει μόνο τη διέλευση της κίνησης που ταιριάζει με τους κανόνες του, και αποκλείει οτιδήποτε άλλο.</p></div><div class=paragraph><p>Τα inclusive firewalls προσφέρουν πολύ καλύτερο έλεγχο της εξερχόμενης κίνησης και για το λόγο αυτό είναι καλύτερα για συστήματα που προσφέρουν υπηρεσίες στο δημόσιο Internet. Ελέγχουν επίσης και τα πακέτα που προέρχονται από το δημόσιο Internet με προορισμό το ιδιωτικό σας δίκτυο. Από προεπιλογή, όλη η κίνηση που δεν ταιριάζει με τους κανόνες απορρίπτεται και καταγράφεται. Τα inclusive firewalls είναι γενικά ασφαλέστερα από τα exclusive, καθώς μειώνουν σημαντικά την πιθανότητα διέλευσης ανεπιθύμητης κίνησης μέσα από αυτά.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Εκτός και αν αναφέρεται διαφορετικά, όλα τα παραδείγματα ρυθμίσεων και κανόνων που φαίνονται σε αυτό το κεφάλαιο, δημιουργούν inclusive firewalls.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η ασφάλεια μπορεί να γίνει ακόμα ισχυρότερη με τη χρήση ενός "stateful firewall". Αυτός ο τύπος firewall αποθηκεύει την κατάσταση των συνδέσεων που μεταφέρουν δεδομένα μέσα από αυτό, και επιτρέπει μόνο την κίνηση που είτε ταιριάζει με μια από τις υπάρχουσες συνδέσεις, ή που ξεκινά μια νέα σύνδεση. Το μειονέκτημα ενός stateful firewall είναι ότι μπορεί να είναι ευάλωτο σε επιθέσεις Denial of Service (Άρνησης Υπηρεσίας, DoS) αν δεχθεί ταυτόχρονα πολλές αιτήσεις για άνοιγμα νέων συνδέσεων σε μικρό χρονικό διάστημα. Με τα περισσότερα firewalls, είναι δυνατόν να γίνει συνδυασμός και των δύο συμπεριφορών (τόσο stateful όσο και μη-stateful) ώστε να δημιουργηθεί το βέλτιστο firewall για την συγκεκριμένη χρήση.</p></div></div><div class=sect2><h3 id=firewalls-apps>55.3. Προγράμματα Firewall<a class=anchor href=#firewalls-apps></a></h3><div class=paragraph><p>Το FreeBSD έχει τρία διαφορετικά προγράμματα firewall ενσωματωμένα στο βασικό σύστημα. Είναι τα: <em>IPFILTER</em> (γνωστό επίσης και ως IPF), το <em>IPFIREWALL</em> (γνωστό επίσης και ως IPFW), και το <em>PacketFilter</em> του <em>OpenBSD</em> (γνωστό επίσης και ως PF). Το FreeBSD ενσωματώνει επίσης δύο προγράμματα για διαμόρφωση κυκλοφορίας (traffic shaping, έλεγχος του διαθέσιμου εύρους ζώνης): το <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> και το <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>. Το Dummynet είναι κατά παράδοση στενά συνδεμένο με το IPFW, και το ALTQ με το PF. Η διαμόρφωση κυκλοφορίας για το IPFILTER μπορεί τη δεδομένη στιγμή να γίνει με το IPFILTER για το NAT και το φιλτράρισμα και με το IPFW σε συνδυασμό με το <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> <em>ή</em> χρησιμοποιώντας το PF σε συνδυασμό με το ALTQ. Τόσο το IPFW όσο και το PF χρησιμοποιούν κανόνες για να ελέγξουν την κίνηση των πακέτων από και προς το σύστημά σας, αν και διαθέτουν διαφορετικούς τρόπους για να το επιτύχουν, και οι κανόνες τους χρησιμοποιούν διαφορετική σύνταξη.</p></div><div class=paragraph><p>Ο λόγος για τον οποίο το FreeBSD διαθέτει πολλαπλά firewall, είναι ότι διαφορετικοί άνθρωποι έχουν διαφορετικές ανάγκες και προτιμήσεις. Δεν υπάρχει ένα και μοναδικό firewall που να είναι το καλύτερο.</p></div><div class=paragraph><p>Ο συγγραφέας προτιμά το IPFILTER, καθώς οι κανόνες τύπου stateful που διαθέτει είναι λιγότερο πολύπλοκοι όταν χρησιμοποιούνται σε ένα περιβάλλον NAT, ενώ διαθέτει και ενσωματωμένο ftp proxy το οποίο τους απλοποιεί ακόμα περισσότερο, επιτρέποντας ασφαλή σύνδεση σε εξωτερικούς εξυπηρετητές FTP.</p></div><div class=paragraph><p>Καθώς όλα τα firewall βασίζονται στην επιθεώρηση τιμών ελέγχου των πακέτων, ο διαχειριστής που πρόκειται να δημιουργήσει τους κανόνες πρέπει να κατανοεί τον τρόπο λειτουργίας του TCP/IP, το ρόλο των διαφόρων τιμών στα πεδία ελέγχου των πακέτων και πως χρησιμοποιούνται στην ανταλλαγή πληροφοριών σε μια συνηθισμένη συνεδρία. Για περισσότερες λεπτομέρειες, διαβάστε το <a href=http://www.ipprimer.com/overview.cfm>http://www.ipprimer.com/overview.cfm</a>.</p></div></div><div class=sect2><h3 id=firewalls-pf>55.4. Το Packet Filter (PF) και το ALTQ του OpenBSD<a class=anchor href=#firewalls-pf></a></h3><div class=paragraph><p>Τον Ιούλιο του 2003, η εφαρμογή firewall του OpenBSD (γνωστή ως PF) μεταφέρθηκε στο FreeBSD και έγινε διαθέσιμη στην Συλλογή των Ports. Το FreeBSD 5.3 που κυκλοφόρησε το 2004, ήταν η πρώτη επίσημη έκδοση η οποία περιείχε το PF ως τμήμα του βασικού πλέον συστήματος. Το PF είναι ένα ολοκληρωμένο firewall, με πλήθος χαρακτηριστικών, το οποίο επίσης διαθέτει προαιρετικά υποστήριξη για το ALTQ (Alternate Queuing). Το ALTQ προσφέρει υπηρεσίες Διασφάλισης Ποιότητας (Quality of Service, QoS).</p></div><div class=paragraph><p>Το OpenBSD Project κάνει εξαιρετική δουλειά στη συντήρηση του <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a>. Για το λόγο αυτό, η παρούσα ενότητα του Εγχειριδίου εστιάζει κυρίως στις ιδιαιτερότητες του PF όσο αφορά το FreeBSD, ενώ παρέχει και μερικές γενικές πληροφορίες σχετικά με τη χρήση του. Για πιο λεπτομερείς πληροφορίες σχετικά με τη χρήση του PF, παρακαλούμε διαβάστε το <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a>.</p></div><div class=paragraph><p>Περισσότερες πληροφορίες σχετικά με το PF στο FreeBSD μπορείτε να βρείτε στο <a href=http://pf4freebsd.love2party.net/>http://pf4freebsd.love2party.net/</a>.</p></div><div class=sect3><h4 id=_χρησιμοποιώντας_τα_αρθρώματα_πυρήνα_για_το_pf>55.4.1. Χρησιμοποιώντας τα Αρθρώματα Πυρήνα για το PF<a class=anchor href=#_χρησιμοποιώντας_τα_αρθρώματα_πυρήνα_για_το_pf></a></h4><div class=paragraph><p>Για να φορτώσετε το άρθρωμα πυρήνα για το PF, προσθέστε την παρακάτω γραμμή στο στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Εκτελέστε έπειτα το script εκκίνησης για να φορτώσετε το άρθρωμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/pf start</span></code></pre></div></div><div class=paragraph><p>Σημειώστε ότι το άρθρωμα PF δεν πρόκειται να φορτωθεί αν δεν βρει το καθορισμένο αρχείο κανόνων. Το προεπιλεγμένο αρχείο είναι το <span class=filename>/etc/pf.conf</span>. Αν το αρχείο κανόνων βρίσκεται σε κάποια άλλη τοποθεσία, μπορείτε να την καθορίσετε προσθέτοντας μια γραμμή όπως την παρακάτω στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre></div></div><div class=paragraph><p>Μπορείτε να βρείτε ένα παράδειγμα του αρχείου <span class=filename>pf.conf</span> στον κατάλογο <span class=filename>/usr/shared/examples/pf</span></p></div><div class=paragraph><p>Το άρθρωμα PF μπορεί επίσης να φορτωθεί χειροκίνητα από την γραμμή εντολών:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload pf.ko</span></code></pre></div></div><div class=paragraph><p>Η υποστήριξης καταγραφής του PF παρέχεται από το άρθρωμα <code>pflog.ko</code> και μπορείτε να την φορτώσετε προσθέτοντας την παρακάτω γραμμή στο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>pflog_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Εκτελέστε έπειτα το script εκκίνησης για να φορτώσετε το άρθρωμα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/pflog start</span></code></pre></div></div><div class=paragraph><p>Αν χρειάζεστε κάποιο από τα προχωρημένα χαρακτηριστικά του PF, θα πρέπει να μεταγλωττίσετε την υποστήριξη για το PF απευθείας μέσα στον πυρήνα.</p></div></div><div class=sect3><h4 id=_επιλογές_του_pf_για_τον_πυρήνα>55.4.2. Επιλογές του PF για τον Πυρήνα<a class=anchor href=#_επιλογές_του_pf_για_τον_πυρήνα></a></h4><div class=paragraph><p>Αν και δεν είναι απαραίτητο να μεταγλωττίσετε την υποστήριξη PF μέσα στον πυρήνα του FreeBSD, ίσως να θέλετε να χρησιμοποιήσετε ένα από τα προχωρημένα χαρακτηριστικά του PF το οποίο δεν περιλαμβάνεται στο άρθρωμα του πυρήνα: το <a href="https://man.freebsd.org/cgi/man.cgi?query=pfsync&amp;sektion=4&amp;format=html">pfsync(4)</a>. Πρόκειται για μια ψευδο-συσκευή η οποία αποκαλύπτει συγκεκριμένες αλλαγές στον πίνακα καταστάσεων που χρησιμοποιείται από το PF. Μπορεί να συνδυαστεί με το <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> για να δημιουργηθούν με το PF firewalls με δυνατότητα αυτόματης αλλαγής σε περίπτωση αποτυχίας (failover). Περισσότερες πληροφορίες σχετικά με το CARP μπορείτε να βρείτε στο <a href=./#carp>Common Access Redundancy Protocol (CARP)</a> του Εγχειριδίου.</p></div><div class=paragraph><p>Μπορείτε να δείτε όλες τις επιλογές πυρήνα για το PF στο αρχείο <span class=filename>/usr/src/sys/conf/NOTES</span>. Οι επιλογές φαίνονται επίσης παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>device pf
device pflog
device pfsync</pre></div></div><div class=paragraph><p>Η επιλογή <code>device pf</code> ενεργοποιεί την υποστήριξη για το firewall "Packet Filter" (<a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a>).</p></div><div class=paragraph><p>Η επιλογή <code>device pflog</code> ενεργοποιεί την προαιρετική ψευδο-δικτυακή συσκευή <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> που μπορεί να χρησιμοποιηθεί για την καταγραφή της κίνησης σε ένα <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> descriptor. Ο δαίμονας <a href="https://man.freebsd.org/cgi/man.cgi?query=pflogd&amp;sektion=8&amp;format=html">pflogd(8)</a> μπορεί να αποθηκεύσει την καταγραφή αυτή στο σκληρό δίσκο.</p></div><div class=paragraph><p>Η επιλογή <code>device pfsync</code> ενεργοποιεί την προαιρετική ψευδό-δικτυακή συσκευή <a href="https://man.freebsd.org/cgi/man.cgi?query=pfsync&amp;sektion=4&amp;format=html">pfsync(4)</a> η οποία χρησιμοποιείται για να ανιχνεύει "αλλαγές κατάστασης".</p></div></div><div class=sect3><h4 id=_επιλογές_στο_rc_conf>55.4.3. Επιλογές στο <span class=filename>rc.conf</span><a class=anchor href=#_επιλογές_στο_rc_conf></a></h4><div class=paragraph><p>Το PF και το <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> μπορούν να ρυθμιστούν κατά την εκκίνηση με τις παρακάτω καταχωρίσεις στο <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_enable=&#34;YES&#34;                 # Enable PF (load module if required)
pf_rules=&#34;/etc/pf.conf&#34;         # rules definition file for pf
pf_flags=&#34;&#34;                     # additional flags for pfctl startup
pflog_enable=&#34;YES&#34;              # start pflogd(8)
pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre></div></div><div class=paragraph><p>Αν πίσω από αυτό το firewall υπάρχει κάποιο τοπικό δίκτυο (LAN) προς το οποίο επιθυμείτε να προωθήσετε πακέτα, ή αν θέλετε να χρησιμοποιήσετε NAT, θα χρειαστείτε επίσης και την παρακάτω επιλογή:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre></div></div></div><div class=sect3><h4 id=_δημιουργία_κανόνων_φιλτραρίσματος>55.4.4. Δημιουργία Κανόνων Φιλτραρίσματος<a class=anchor href=#_δημιουργία_κανόνων_φιλτραρίσματος></a></h4><div class=paragraph><p>Το PF διαβάζει τις ρυθμίσεις του από το <a href="https://man.freebsd.org/cgi/man.cgi?query=pf.conf&amp;sektion=5&amp;format=html">pf.conf(5)</a> (η προεπιλεγμένη τοποθεσία είναι στο <span class=filename>/etc/pf.conf</span>) και τροποποιεί, απορρίπτει ή αποδέχεται πακέτα σύμφωνα με τους κανόνες και τους ορισμούς που περιέχονται σε αυτό. Η εγκατάσταση του FreeBSD περιλαμβάνει αρκετά υποδείγματα αρχείων ρύθμισης, στην τοποθεσία <span class=filename>/usr/shared/examples/pf/</span>. Παρακαλούμε να διαβάσετε το <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a> για πλήρη ανάλυση των κανόνων του PF.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Καθώς διαβάζετε το <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a>, να έχετε υπόψη σας ότι διαφορετικές εκδόσεις του FreeBSD περιέχουν διαφορετικές εκδόσεις του PF. Τη δεδομένη στιγμή, το FreeBSD 8.<em>X</em> και οι προηγούμενες εκδόσεις χρησιμοποιούν την ίδια έκδοση του PF που χρησιμοποιεί και το OpenBSD 4.1. Το FreeBSD 9.<em>X</em> και νεώτερες εκδόσεις χρησιμοποιούν την ίδια έκδοση του PF με το OpenBSD 4.5.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Η <a href=https://lists.FreeBSD.org/subscription/freebsd-pf>ηλεκτρονική λίστα του FreeBSD για το packet filter firewall</a> είναι ένα καλό μέρος για να κάνετε ερωτήσεις σχετικές με τη ρύθμιση και τη λειτουργία του PF firewall. Μη ξεχάσετε να ελέγξετε τα αρχεία της λίστας πριν ξεκινήσετε τις ερωτήσεις!</p></div></div><div class=sect3><h4 id=_δουλεύοντας_με_το_pf>55.4.5. Δουλεύοντας με το PF<a class=anchor href=#_δουλεύοντας_με_το_pf></a></h4><div class=paragraph><p>Χρησιμοποιήστε το <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> για να ελέγξετε το PF. Παρακάτω θα βρείτε κάποιες χρήσιμες εντολές (βεβαιωθείτε ότι έχετε διαβάσει τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> για να δείτε όλες τις διαθέσιμες επιλογές):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Εντολή</th><th class="tableblock halign-left valign-top">Σκοπός</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ενεργοποίηση του PF</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Απενεργοποίηση του PF</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -F all -f /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Διαγραφή όλων των κανόνων (nat, filter, state, table, κ.λ.π.) και εκ νέου ανάγνωση από το αρχείο <span class=filename>/etc/pf.conf</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -s [ rules | nat | state ]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Εκτύπωση αναφοράς σχετικά με τους κανόνες του φίλτρου, του NAT, ή του πίνακα κατάστασης</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -vnf /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ελέγχει το <span class=filename>/etc/pf.conf</span> για λάθη, αλλά δεν φορτώνει τους κανόνες</p></td></tr></tbody></table></div><div class=sect3><h4 id=_ενεργοποίηση_του_altq>55.4.6. Ενεργοποίηση του ALTQ<a class=anchor href=#_ενεργοποίηση_του_altq></a></h4><div class=paragraph><p>Το ALTQ διατίθεται μόνο αν μεταγλωττίσετε απευθείας την υποστήριξη του μέσα στον πυρήνα του FreeBSD. Το ALTQ δεν υποστηρίζεται από όλα τα προγράμματα οδήγησης καρτών δικτύου. Παρακαλούμε δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> για τη λίστα των οδηγών που υποστηρίζονται στην έκδοση του FreeBSD που διαθέτετε.</p></div><div class=paragraph><p>Οι παρακάτω επιλογές του πυρήνα ενεργοποιούν το ALTQ και παρέχουν επιπρόσθετες λειτουργίες:</p></div><div class="literalblock programlisting"><div class=content><pre>options         ALTQ
options         ALTQ_CBQ        # Class Bases Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)
options         ALTQ_NOPCC      # Required for SMP build</pre></div></div><div class=paragraph><p>Η γραμμή <code>options ALTQ</code> ενεργοποιεί το πλαίσιο λειτουργιών ALTQ.</p></div><div class=paragraph><p>Η γραμμή <code>options ALTQ_CBQ</code> ενεργοποιεί το <em>Class Based Queuing</em> (CBQ). Το CBQ σας επιτρέπει να χωρίσετε το εύρος ζώνης μιας σύνδεσης σε διαφορετικές κλάσεις ή ουρές, ώστε να δίνονται προτεραιότητες στην κίνηση ανάλογα με τους κανόνες του φίλτρου.</p></div><div class=paragraph><p>Η γραμμή <code>options ALTQ_RED</code> ενεργοποιεί το <em>Random Early Detection</em> (RED). Το RED χρησιμοποιείται για να αποφευχθεί η συμφόρηση του δικτύου. Για το σκοπό αυτό, το RED μετράει το μήκος της ουράς και το συγκρίνει με το μέγιστο και ελάχιστο όριο της. Αν η ουρά είναι πάνω από το μέγιστο, όλα τα νέα πακέτα θα απορρίπτονται. Σύμφωνα και με το όνομα του, το RED απορρίπτει πακέτα από διάφορες συνδέσεις με τυχαίο τρόπο.</p></div><div class=paragraph><p>Η γραμμή <code>options ALTQ_RIO</code> ενεργοποιεί το <em>Random Early Detection In and Out</em>.</p></div><div class=paragraph><p>Η γραμμή <code>options ALTQ_HFSC</code> ενεργοποιεί το <em>Hierarchical Fair Service Curve Packet Scheduler</em>. Για περισσότερες πληροφορίες σχετικά με το HFSC δείτε: <a href=http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html>http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a>.</p></div><div class=paragraph><p>Η γραμμή <code>options ALTQ_PRIQ</code> ενεργοποιεί το <em>Priority Queuing</em> (PRIQ). Το PRIQ πάντοτε περνάει πρώτα την κίνηση με τη μεγαλύτερη προτεραιότητα.</p></div><div class=paragraph><p>Η γραμμή <code>options ALTQ_NOPCC</code> ενεργοποιεί την υποστήριξη SMP για το ALTQ. Η επιλογή αυτή απαιτείται σε συστήματα SMP.</p></div></div></div><div class=sect2><h3 id=firewalls-ipf>55.5. Το IPFILTER (IPF) Firewall<a class=anchor href=#firewalls-ipf></a></h3><div class=paragraph><p>Ο συγγραφέας του IPFILTER είναι ο Darren Reed. Το IPFILTER δεν εξαρτάται από το λειτουργικό σύστημα: είναι μια εφαρμογή ανοικτού κώδικα που έχει μεταφερθεί στο FreeBSD, το NetBSD, το OpenBSD, το SunOS™, το HP/UX και το Solaris™. Το IPFILTER είναι υπό διαρκή και ενεργή ανάπτυξη και συντήρηση, και κυκλοφορούν τακτικά οι νέες εκδόσεις του.</p></div><div class=paragraph><p>Το IPFILTER είναι ένα firewall και μηχανισμός NAT που λειτουργεί στον πυρήνα και μπορεί να ελέγχεται και να παρακολουθείται από προγράμματα χρήστη. Οι κανόνες του firewall μπορούν να τίθενται σε ισχύ ή να διαγράφονται μέσω του βοηθητικού προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a>. Οι κανόνες για το NAT μπορούν να τίθενται σε ισχύ ή να διαγράφονται μέσω του βοηθητικού προγράμματος <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=1&amp;format=html">ipnat(1)</a>. Το βοηθητικό πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> μπορεί να εκτυπώσει στατιστικά εκτέλεσης για το τμήμα του IPFILTER που εκτελείται στον πυρήνα. Το πρόγραμμα <a href="https://man.freebsd.org/cgi/man.cgi?query=ipmon&amp;sektion=8&amp;format=html">ipmon(8)</a> μπορεί να καταγράψει τις ενέργειες του IPFILTER στο αρχεία καταγραφής συμβάντων του συστήματος.</p></div><div class=paragraph><p>Το IPF γράφηκε αρχικά χρησιμοποιώντας μια λογική επεξεργασίας κανόνων του τύπου "ο τελευταίο κανόνας που ταιριάζει, είναι και ο νικητής" και χρησιμοποιούσε μόνο κανόνες τύπου stateless. Με την πάροδο του χρόνου, το IPF βελτιώθηκε για να περιλαμβάνει την επιλογή "quick" και την επιλογή "keep state" για stateful κανόνες. Οι επιλογές αυτές εκσυγχρόνισαν δραματικά τη λογική επεξεργασίας των κανόνων. Η επίσημη τεκμηρίωση του IPF καλύπτει μόνο τις παλιές παραμέτρους ρύθμισης και επεξεργασίας των κανόνων. Οι σύγχρονες λειτουργίες καλύπτονται μόνο ως πρόσθετες επιλογές, και έτσι δεν τονίζονται αρκετά τα πλεονεκτήματα τους στη δημιουργία ενός πολύ καλύτερου και ασφαλέστερου firewall.</p></div><div class=paragraph><p>Οι οδηγίες που περιέχονται σε αυτή την ενότητα, βασίζονται στη χρήση κανόνων που περιέχουν την επιλογή "quick" καθώς και την stateful επιλογή "keep state". Αυτό είναι και το βασικό πλαίσιο λειτουργιών για την δημιουργία του σετ κανόνων ενός inclusive firewall.</p></div><div class=paragraph><p>Για λεπτομέρειες σχετικά με τον παλιότερο τρόπο επεξεργασίας των κανόνων, δείτε: <a href=http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1>http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1</a> και <a href=http://coombs.anu.edu.au/~avalon/ip-filter.html>http://coombs.anu.edu.au/~avalon/ip-filter.html</a>.</p></div><div class=paragraph><p>Μπορείτε να δείτε το IPF FAQ στην τοποθεσία <a href=http://www.phildev.net/ipf/index.html>http://www.phildev.net/ipf/index.html</a>.</p></div><div class=paragraph><p>Μπορείτε να βρείτε τις παλαιότερες δημοσιεύσεις τις λίστας ταχυδρομείου του IPFILTER στο <a href="http://marc.theaimsgroup.com/?l=ipfilter">http://marc.theaimsgroup.com/?l=ipfilter</a>. Παρέχεται δυνατότητα αναζήτησης.</p></div><div class=sect3><h4 id=_ενεργοποιώντας_το_ipf>55.5.1. Ενεργοποιώντας το IPF<a class=anchor href=#_ενεργοποιώντας_το_ipf></a></h4><div class=paragraph><p>Το IPF περιλαμβάνεται στη βασική εγκατάσταση του FreeBSD ως άρθρωμα το οποίο μπορεί να φορτωθεί χωριστά. Το σύστημα θα φορτώσει δυναμικά το άρθρωμα του IPF αν υπάρχει η καταχώριση <code>ipfilter_enable="YES"</code> στο αρχείο <span class=filename>/etc/rc.conf</span>. Το άρθρωμα έχει δημιουργηθεί με ενεργοποιημένη την δυνατότητα καταγραφής και με την επιλογή <code>default pass all</code>. Για να αλλάξετε αυτή την προεπιλογή σε <code>block all</code>, μπορείτε απλώς να προσθέσετε τον κανόνα απόρριψης (block all) στο τέλος των κανόνων σας. Δεν χρειάζεται να μεταγλωττίσετε την επιλογή IPF στο πυρήνα του FreeBSD για το σκοπό αυτό.</p></div></div><div class=sect3><h4 id=_επιλογές_για_τον_πυρήνα>55.5.2. Επιλογές για τον Πυρήνα<a class=anchor href=#_επιλογές_για_τον_πυρήνα></a></h4><div class=paragraph><p>Δεν είναι υποχρεωτικό να μεταγλωττίσετε τις παρακάτω επιλογές στον πυρήνα του FreeBSD για να ενεργοποιήσετε το IPF. Η παρουσίαση τους εδώ είναι καθαρά ενημερωτική. Αν μεταγλωττίσετε το IPF απευθείας στον πυρήνα, δεν θα χρησιμοποιηθεί ποτέ το αντίστοιχο άρθρωμα.</p></div><div class=paragraph><p>Στο αρχείο <span class=filename>/usr/src/sys/conf/NOTES</span> θα βρείτε παραδείγματα καταχωρίσεων IPF για το αρχείο ρύθμισης του πυρήνα. Οι επιλογές αυτές φαίνονται επίσης παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK</pre></div></div><div class=paragraph><p>Η επιλογή <code>options IPFILTER</code> ενεργοποιεί την υποστήριξη για το "IPFILTER" firewall.</p></div><div class=paragraph><p>Η επιλογή <code>options IPFILTER_LOG</code> ενεργοποιεί την υποστήριξη καταγραφής του IPF, η οποία γράφει στην ψευδο-συσκευή καταγραφής πακέτων <span class=filename>ipl</span> για κάθε κανόνα που περιλαμβάνει την επιλογή <code>log</code>.</p></div><div class=paragraph><p>Η επιλογή <code>options IPFILTER_DEFAULT_BLOCK</code> αλλάζει την προεπιλεγμένη συμπεριφορά, ώστε κάθε πακέτο που δεν ταιριάζει με κάποιο κανόνα <code>pass</code> του firewall, να απορρίπτεται αυτόματα.</p></div><div class=paragraph><p>Οι παραπάνω επιλογές θα ενεργοποιηθούν μόνο αφού μεταγλωττίσετε και εγκαταστήσετε ένα προσαρμοσμένο πυρήνα που να τις περιλαμβάνει.</p></div></div><div class=sect3><h4 id=_διαθέσιμες_επιλογές_για_το_rc_conf>55.5.3. Διαθέσιμες Επιλογές για το <span class=filename>rc.conf</span><a class=anchor href=#_διαθέσιμες_επιλογές_για_το_rc_conf></a></h4><div class=paragraph><p>Χρειάζεστε τις παρακάτω καταχωρίσεις στο <span class=filename>/etc/rc.conf</span> για να ενεργοποιήσετε το IPF κατά την εκκίνηση του υπολογιστή:</p></div><div class="literalblock programlisting"><div class=content><pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Αν πίσω από αυτό το firewall υπάρχει κάποιο LAN που χρησιμοποιεί δεσμευμένες ιδιωτικές διευθύνσεις, θα χρειαστεί να προσθέσετε τις παρακάτω καταχωρίσεις για να ενεργοποιήσετε τη λειτουργία NAT:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre></div></div></div><div class=sect3><h4 id=_ipf>55.5.4. IPF<a class=anchor href=#_ipf></a></h4><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> χρησιμοποιείται για να φορτώσει το αρχείο των κανόνων. Φυσιολογικά, θα δημιουργήσετε ένα αρχείο με τους δικούς σας προσαρμοσμένους κανόνες και θα αντικαταστήσετε με αυτό εξ’ολοκλήρου τους ενσωματωμένους κανόνες του firewall:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipf -Fa -f /etc/ipf.rules</span></code></pre></div></div><div class=paragraph><p>Η επιλογή <code>-Fa</code> αδειάζει τους κανόνες από τους εσωτερικούς πίνακες του firewall.</p></div><div class=paragraph><p>Η επιλογή <code>-f</code> καθορίζει το αρχείο των κανόνων που θα φορτωθεί.</p></div><div class=paragraph><p>Αυτό σας δίνει την δυνατότητα να αλλάξετε το αρχείο κανόνων σας, να εκτελέσετε την εντολή IPF που αναφέραμε παραπάνω, και να ανανεώσετε με αυτό τον τρόπο τους κανόνες στο firewall που εκτελείται ήδη με καινούργιους, χωρίς να χρειαστεί να επανεκκινήσετε το σύστημα σας. Η μέθοδος αυτή είναι πολύ βολική για να δοκιμάσετε νέους κανόνες, καθώς μπορεί να επαναληφθεί όσες φορές θέλετε.</p></div><div class=paragraph><p>Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> για λεπτομέρειες σχετικά με τις υπόλοιπες επιλογές που μπορείτε να χρησιμοποιήσετε με την εντολή αυτή.</p></div><div class=paragraph><p>Η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> αναμένει ένα απλό αρχείο κειμένου ως αρχείο κανόνων. Δεν θα δεχθεί αρχείο κανόνων γραμμένο ως script με συμβολικές αντικαταστάσεις.</p></div><div class=paragraph><p>Υπάρχει ωστόσο τρόπος να γράψετε κανόνες IPF που να χρησιμοποιούν την ισχύ των συμβολικών αντικαταστάσεων. Για περισσότερες πληροφορίες, δείτε το <a href=#firewalls-ipf-rules-script>Δημιουργία Script Κανόνων με Συμβολική Υποκατάσταση</a>.</p></div></div><div class=sect3><h4 id=_ipfstat>55.5.5. IPFSTAT<a class=anchor href=#_ipfstat></a></h4><div class=paragraph><p>Η προεπιλεγμένη συμπεριφορά του <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> είναι να ανακτά και να απεικονίζει το σύνολο των στατιστικών που συγκεντρώθηκαν ως αποτέλεσμα της εφαρμογής των κανόνων του χρήστη στα πακέτα που εισέρχονται και εξέρχονται από το firewall, από τη στιγμή της τελευταίας του εκκίνησης ή από τον τελευταίο τους μηδενισμό μέσω της εντολής <code>ipf -Z</code>.</p></div><div class=paragraph><p>Δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> για λεπτομέρειες.</p></div><div class=paragraph><p>Η προεπιλεγμένη έξοδος της εντολής <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> θα μοιάζει με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 0 lost 0
 fragment state<span class=o>(</span>out<span class=o>)</span>: kept 0 lost 0
 packet state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 169364 lost 0
 packet state<span class=o>(</span>out<span class=o>)</span>: kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 1215208 <span class=o>(</span>out<span class=o>)</span>: 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP <span class=nb>cksum </span>fails<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 0 <span class=o>(</span>out<span class=o>)</span>: 0
 Packet log flags <span class=nb>set</span>: <span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Όταν χρησιμοποιηθεί η επιλογή <code>-i</code> για τα εισερχόμενα ή η επιλογή <code>-o</code> για τα εξερχόμενα πακέτα, η εντολή θα ανακτήσει και θα απεικονίσει την αντίστοιχη λίστα κανόνων που είναι εγκατεστημένη και χρησιμοποιείται από τον πυρήνα τη δεδομένη στιγμή.</p></div><div class=paragraph><p>Η εντολή <code>ipfstat -in</code> δείχνει ένα αριθμημένο πίνακα κανόνων για εισερχόμενα πακέτα.</p></div><div class=paragraph><p>Η εντολή <code>ipfstat -on</code> δείχνει ένα αριθμημένο πίνακα κανόνων για εξερχόμενα πακέτα.</p></div><div class=paragraph><p>Η έξοδος θα μοιάζει με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Η εντολή <code>ipfstat -ih</code> δείχνει τον πίνακα κανόνων για τα εισερχόμενα πακέτα, τοποθετώντας μπροστά από τον κάθε κανόνα ένα αριθμό που δείχνει πόσες φορές έχει χρησιμοποιηθεί.</p></div><div class=paragraph><p>Η εντολή <code>ipfstat -oh</code> δείχνει τον πίνακα κανόνων για τα εξερχόμενα πακέτα, τοποθετώντας μπροστά από τον κάθε κανόνα ένα αριθμό που δείχνει πόσες φορές έχει χρησιμοποιηθεί.</p></div><div class=paragraph><p>Η έξοδος θα μοιάζει με την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Μια από τις πιο σημαντικές λειτουργίες της εντολής <code>ipfstat</code> είναι η επιλογή <code>-t</code> η οποία απεικονίζει τον πίνακα καταστάσεων, με τρόπο όμοιο με αυτό που χρησιμοποιεί η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> για να δείξει τον πίνακα διεργασιών που εκτελούνται στο FreeBSD. Όταν το firewall σας δέχεται επίθεση, η λειτουργία αυτή σας δίνει την δυνατότητα να αναγνωρίσετε και να εστιάσετε στα ίδια τα πακέτα που την αποτελούν. Οι προαιρετικές υπο-επιλογές σας δίνουν την δυνατότητα να επιλέξετε το IP αφετηρίας ή προορισμού, την θύρα, ή το πρωτόκολλο το οποίο θέλετε να παρακολουθήσετε σε πραγματικό χρόνο. Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> για περισσότερες λεπτομέρειες.</p></div></div><div class=sect3><h4 id=_ipmon>55.5.6. IPMON<a class=anchor href=#_ipmon></a></h4><div class=paragraph><p>Για να λειτουργήσει σωστά η εντολή <code>ipmon</code>, θα πρέπει να ενεργοποιηθεί η επιλογή <code>IPFILTER_LOG</code> στον πυρήνα. Η εντολή αυτή διαθέτει δύο διαφορετικούς τρόπους λειτουργίας. Ο προεπιλεγμένος κανονικός τρόπος λειτουργίας ενεργοποιείται όταν η εντολή χρησιμοποιείται χωρίς την επιλογή <code>-D</code>.</p></div><div class=paragraph><p>Η εντολή μπορεί να χρησιμοποιηθεί σε λειτουργία δαίμονα όταν επιθυμείτε να έχετε ένα συνεχόμενο αρχείο καταγραφής ώστε να μπορείτε να εξετάσετε τις προηγούμενες εγγραφές. Αυτός είναι και ο τρόπος με τον οποίο έχει ρυθμιστεί να συνεργάζεται το FreeBSD με το IPFILTER. Το FreeBSD έχει ενσωματωμένη δυνατότητα εναλλαγής αρχείων καταγραφής. Για αυτό το λόγο, είναι καλύτερο η καταγραφή να γίνεται μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> παρά σε ένα συνηθισμένο αρχείο. Από προεπιλογή, η ρύθμιση <code>ipmon_flags</code> στο αρχείο <span class=filename>rc.conf</span> χρησιμοποιεί τις επιλογές <code>-Ds</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Τα πλεονεκτήματα της καταγραφής είναι προφανή. Παρέχει την δυνατότητα επισκόπησης πληροφοριών όπως τα πακέτα που απορρίφθηκαν, τις διευθύνσεις από τις οποίες λήφθηκαν, και τον προορισμό τους. Έχετε έτσι ένα σημαντικό πλεονέκτημα όταν προσπαθείτε να αναγνωρίσετε ένα εισβολέα.</p></div><div class=paragraph><p>Ακόμα και όταν ενεργοποιήσετε την δυνατότητα καταγραφής, το IPF δεν θα καταγράψει τίποτα αν δεν έχει γίνει η αντίστοιχη ρύθμιση στους κανόνες. Ο διαχειριστής του firewall αποφασίζει για ποιους κανόνες του σετ θέλει να ενεργοποιήσει την καταγραφή, και προσθέτει σε αυτούς την λέξη log. Φυσιολογικά, η καταγραφή ενεργοποιείται μόνο σε κανόνες που απορρίπτουν πακέτα.</p></div><div class=paragraph><p>Είναι πολύ συνηθισμένο να περιλαμβάνεται ένας κανόνας στο τέλος του συνόλου, που να απορρίπτει από προεπιλογή όλα τα πακέτα που φτάνουν μέχρι εκεί (default deny). Με τον τρόπο αυτό μπορείτε να δείτε όλα τα πακέτα που δεν ταίριαξαν με κανένα κανόνα του σετ.</p></div></div><div class=sect3><h4 id=_καταγραφή_του_ipmon>55.5.7. Καταγραφή του IPMON<a class=anchor href=#_καταγραφή_του_ipmon></a></h4><div class=paragraph><p>Το syslogd χρησιμοποιεί τη δική του ειδική μέθοδο για το διαχωρισμό των δεδομένων καταγραφής. Διαθέτει ειδικές ομαδοποιήσεις που ονομάζονται "facility" και "level". Όταν το IPMON χρησιμοποιείται με την επιλογή <code>-Ds</code>, χρησιμοποιεί από προεπιλογή το <code>local0</code> ως όνομα "facility". Αν το επιθυμείτε, μπορείτε να χρησιμοποιήσετε τα παρακάτω επίπεδα για περαιτέρω διαχωρισμό των δεδομένων καταγραφής:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>LOG_INFO - packets logged using the <span class=s2>&#34;log&#34;</span> keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short</code></pre></div></div><div class=paragraph><p>Για να ρυθμίσετε το IPFILTER να καταγράφει όλα τα δεδομένα στο <span class=filename>/var/log/ipfilter.log</span>, θα χρειαστεί να δημιουργήσετε από πριν το αρχείο. Αυτό μπορεί να γίνει με την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/ipfilter.log</span></code></pre></div></div><div class=paragraph><p>Η λειτουργία του <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> μπορεί να ρυθμιστεί με καταχωρίσεις στο αρχείο <span class=filename>/etc/syslog.conf</span>. Το αρχείο <span class=filename>syslog.conf</span> προσφέρει σημαντική ευελιξία στον τρόπο με τον οποίο το syslog αντιμετωπίζει τα μηνύματα συστήματος που προέρχονται από εφαρμογές όπως το IPF.</p></div><div class=paragraph><p>Προσθέστε την παρακάτω καταχώριση στο αρχείο <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>local0.* /var/log/ipfilter.log</pre></div></div><div class=paragraph><p>Το <code>local0.*</code> σημαίνει ότι θα γίνεται καταγραφή όλων των μηνυμάτων αυτού του τύπου στην τοποθεσία που έχει οριστεί.</p></div><div class=paragraph><p>Για να ενεργοποιήσετε τις αλλαγές στο <span class=filename>/etc/syslog.conf</span> θα πρέπει να επανεκκινήσετε το μηχάνημα ή να αναγκάσετε το <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> να ξαναδιαβάσει το <span class=filename>/etc/syslog.conf</span>, εκτελώντας την εντολή <code>/etc/rc.d/syslogd reload</code></p></div><div class=paragraph><p>Μην ξεχάσετε να τροποποιήσετε το <span class=filename>/etc/newsyslog.conf</span> ώστε να εναλλάσσει το αρχείο καταγραφής που δημιουργήσατε παραπάνω.</p></div></div><div class=sect3><h4 id=_η_μορφή_των_μηνυμάτων_καταγραφής>55.5.8. Η Μορφή των Μηνυμάτων Καταγραφής<a class=anchor href=#_η_μορφή_των_μηνυμάτων_καταγραφής></a></h4><div class=paragraph><p>Τα μηνύματα που παράγονται από την <code>ipmon</code> αποτελούνται από πεδία δεδομένων που χωρίζονται από λευκό διάστημα. Τα πεδία που είναι κοινά σε όλα τα μηνύματα, είναι τα παρακάτω:</p></div><div class="olist arabic"><ol class=arabic><li><p>Η ημερομηνία παραλαβής του πακέτου</p></li><li><p>Η ώρα παραλαβής του πακέτου. Έχει την μορφή HH:MM:SS.F, η οποία υποδηλώνει ώρες, λεπτά, δευτερόλεπτα και κλάσματα δευτερολέπτου (τα οποία μπορεί να είναι πολλά δεκαδικά ψηφία).</p></li><li><p>Το όνομα της διεπαφής στην οποία έγινε η επεξεργασία του πακέτου π.χ. <span class=filename>dc0</span>.</p></li><li><p>Ο αριθμός ομάδας και ο αύξων αριθμός του κανόνα, π.χ. <code>@0:17</code>.</p></li></ol></div><div class=paragraph><p>Μπορείτε να δείτε τα παρακάτω με την εντολή <code>ipfstat -in</code>:</p></div><div class="olist arabic"><ol class=arabic><li><p>Το είδος της ενέργειας: p αν το πακέτο πέρασε, b αν το πακέτο απορρίφθηκε, S για σύντομο πακέτο, n αν δεν ταίριαξε με κανένα κανόνα, L για κανόνα με καταγραφή. Η σειρά προτεραιότητας στην απεικόνιση των παραπάνω, είναι S, p, b, n, L. Το κεφαλαίο P ή το B σημαίνουν ότι η καταγραφή του πακέτου έγινε λόγω κάποιας γενικής ρύθμισης καταγραφής και όχι εξαιτίας κάποιου κανόνα.</p></li><li><p>Οι διευθύνσεις. Πρόκειται στην πραγματικότητα για τρία πεδία: τη διεύθυνση και τη θύρα αφετηρίας (χωρίζονται με κόμμα), το σύμβολο → και την διεύθυνση και θύρα προορισμού, π.χ. <code>209.53.17.22,80 → 198.73.220.17,1722</code>.</p></li><li><p>Το <code>PR</code> ακολουθούμενο από το όνομα ή τον αριθμό του πρωτοκόλλου, π.χ. <code>PR tcp</code>.</p></li><li><p>Το <code>len</code> ακολουθούμενο από το μήκος της επικεφαλίδας και το συνολικό μήκος του πακέτου, π.χ. <code>len 20 40</code>.</p></li></ol></div><div class=paragraph><p>Αν πρόκειται για πακέτο TCP, θα υπάρχει ένα επιπλέον πεδίο το οποίο θα ξεκινάει με μια παύλα και θα ακολουθείται από γράμματα τα οποία αντιστοιχούν στις επιλογές (flags) που έχουν τεθεί. Δείτε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> για τη λίστα των γραμμάτων και των αντίστοιχων flags.</p></div><div class=paragraph><p>Αν πρόκειται για πακέτο ICMP, θα υπάρχουν δύο πεδία στο τέλος, το πρώτο θα είναι πάντα "ICMP" και το επόμενο θα είναι ο τύπος του μηνύματος και του υπό-μηνύματος ICMP, χωρισμένα με μια κάθετο, π.χ. ICMP 3/3 για ένα μήνυμα μη προσβάσιμης θύρας (port unreachable).</p></div></div><div class=sect3><h4 id=firewalls-ipf-rules-script>55.5.9. Δημιουργία Script Κανόνων με Συμβολική Υποκατάσταση<a class=anchor href=#firewalls-ipf-rules-script></a></h4><div class=paragraph><p>Ορισμένοι έμπειροι χρήστες του IPF δημιουργούν ένα αρχείο κανόνων το οποίο μπορεί να εκτελεστεί ως script με δυνατότητα συμβολικής υποκατάστασης. Το βασικό όφελος του παραπάνω, είναι ότι χρειάζεται να αλλάξετε μόνο την τιμή που σχετίζεται με το συμβολικό όνομα και όταν το script εκτελεστεί, η τιμή θα υποκατασταθεί σε όλους τους κανόνες που περιέχουν το όνομα αυτό. Καθώς πρόκειται για script, μπορείτε να χρησιμοποιήσετε συμβολική υποκατάσταση για να κωδικοποιήσετε συχνά χρησιμοποιούμενες τιμές και να τις υποκαθιστάτε σε πολλαπλούς κανόνες. Αυτό φαίνεται και στο παράδειγμα που ακολουθεί.</p></div><div class=paragraph><p>Η σύνταξη του script που χρησιμοποιείται εδώ, είναι συμβατή με τα κελύφη <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>, και <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>.</p></div><div class=paragraph><p>Τα πεδία στα οποία γίνεται συμβολική υποκατάσταση προσημειώνονται με το σήμα του δολαρίου: <code>$</code>.</p></div><div class=paragraph><p>Τα συμβολικά πεδία δεν έχουν την προσημείωση με το $.</p></div><div class=paragraph><p>Η τιμή που θα χρησιμοποιηθεί στο συμβολικό πεδίο, θα πρέπει να εσωκλείεται σε διπλά εισαγωγικά (<code>"</code>).</p></div><div class=paragraph><p>Ξεκινήστε το αρχείο των κανόνων σας με κάτι αντίστοιχο με το παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>############# Start of IPF rules script ########################

oif=&#34;dc0&#34;            # name of the outbound interface
odns=&#34;192.0.2.11&#34;    # ISP&#39;s DNS server IP address
myip=&#34;192.0.2.7&#34;     # my static IP address from ISP
ks=&#34;keep state&#34;
fks=&#34;flags S keep state&#34;

# You can choose between building /etc/ipf.rules file
# from this script or running this script &#34;as is&#34;.
#
# Uncomment only one line and comment out another.
#
# 1) This can be used for building /etc/ipf.rules:
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) This can be used to run script &#34;as is&#34;:
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Allow out access to my ISP&#39;s Domain name server.
pass out quick on $oif proto tcp from any to $odns port = 53 $fks
pass out quick on $oif proto udp from any to $odns port = 53 $ks

# Allow out non-secure standard www function
pass out quick on $oif proto tcp from $myip to any port = 80 $fks

# Allow out secure www function https over TLS SSL
pass out quick on $oif proto tcp from $myip to any port = 443 $fks
EOF
################## End of IPF rules script ########################</pre></div></div><div class=paragraph><p>Αυτό είναι όλο. Στο παραπάνω παράδειγμα δεν είναι σημαντικοί οι κανόνες, αλλά ο τρόπος με τον οποίο λειτουργούν και παίρνουν τιμές τα πεδία υποκατάστασης. Αν το παραπάνω παράδειγμα βρίσκονταν σε ένα αρχείο με το όνομα <span class=filename>/etc/ipf.rules.script</span>, θα μπορούσατε να επαναφορτώσετε αυτούς τους κανόνες με την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipf.rules.script</span></code></pre></div></div><div class=paragraph><p>Υπάρχει ένα πρόβλημα όταν χρησιμοποιούνται αρχεία κανόνων με ενσωματωμένους συμβολισμούς: Το IPF δεν καταλαβαίνει τη συμβολική υποκατάσταση, και δεν μπορεί να διαβάσει αυτά τα scripts άμεσα.</p></div><div class=paragraph><p>Ένα τέτοιο script μπορεί να χρησιμοποιηθεί με ένα από τους δύο παρακάτω τρόπους:</p></div><div class=ulist><ul><li><p>Αφαιρέστε το σχόλιο από τη γραμμή που ξεκινάει με <code>cat</code>, και μετατρέψτε σε σχόλιο τη γραμμή που ξεκινάει με <code>/sbin/ipf</code>. Τοποθετήστε το <code>ipfilter_enable="YES"</code> στο αρχείο <span class=filename>/etc/rc.conf</span> όπως συνήθως, και εκτελέστε το script μια φορά μετά από κάθε αλλαγή για να δημιουργήσετε ή να ενημερώσετε το <span class=filename>/etc/ipf.rules</span>.</p></li><li><p>Απενεργοποιήστε το IPFILTER στα scripts εκκίνησης του συστήματος, προσθέτοντας την καταχώριση <code>ipfilter_enable="NO"</code> (πρόκειται για την προεπιλεγμένη τιμή) στο αρχείο <span class=filename>/etc/rc.conf</span>.</p><div class=paragraph><p>Προσθέστε ένα script όπως το παρακάτω στον κατάλογο εκκίνησης <span class=filename>/usr/local/etc/rc.d/</span>. Το script θα πρέπει να έχει ένα προφανές όνομα, όπως <span class=filename>ipf.loadrules.sh</span>. Η επέκταση <span class=filename>.sh</span> είναι υποχρεωτική.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
sh /etc/ipf.rules.script</pre></div></div><div class=paragraph><p>Οι άδειες σε αυτό το αρχείο, θα πρέπει να επιτρέπουν ανάγνωση, εγγραφή και εκτέλεση για τον χρήστη <code>root</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</span></code></pre></div></div></li></ul></div><div class=paragraph><p>Οι κανόνες του IPF θα φορτώνονται πλέον κατά την εκκίνηση του συστήματος σας.</p></div></div><div class=sect3><h4 id=_το_σύνολο_κανόνων_του_ipf>55.5.10. Το Σύνολο Κανόνων του IPF<a class=anchor href=#_το_σύνολο_κανόνων_του_ipf></a></h4><div class=paragraph><p>Ως "σύνολο κανόνων" στο IPF, ορίζουμε μια ομάδα κανόνων που έχουν γραφεί για να επιτρέπουν ή να απορρίπτουν πακέτα ανάλογα με τις τιμές που περιέχονται σε αυτά. Η διπλής κατεύθυνσης ανταλλαγή πακέτων μεταξύ υπολογιστών αποτελεί μια συνεδρία. Το σύνολο κανόνων του firewall επεξεργάζεται τόσο τα πακέτα που έρχονται από το Internet, όσο και τα πακέτα που παράγονται από το σύστημα ως απάντηση σε αυτά. Κάθε υπηρεσία TCP/IP (π.χ. telnet, www, mail, κ.λ.π.) καθορίζεται από το πρωτόκολλο και την προνομιακή (privileged) θύρα που χρησιμοποιεί για να δέχεται αιτήματα εξυπηρέτησης. Τα πακέτα που προορίζονται για μια συγκεκριμένη υπηρεσία, ξεκινούν από τη διεύθυνση αφετηρίας χρησιμοποιώντας μια μη-προνομιακή θύρα και καταλήγουν στη συγκεκριμένη θύρα υπηρεσίας στον προορισμό. Όλες οι παραπάνω παράμετροι (θύρες και διευθύνσεις) μπορούν να χρησιμοποιηθούν ως κριτήρια επιλογής για την δημιουργία κανόνων που επιτρέπουν ή εμποδίζουν την πρόσβαση σε υπηρεσίες.</p></div><div class=paragraph><p>Το IPF γράφτηκε αρχικά χρησιμοποιώντας μια λογική επεξεργασίας κανόνων του τύπου "ο τελευταίος κανόνας που ταιριάζει, είναι ο νικητής" και χρησιμοποιούσε μόνο κανόνες stateless. Με την πάροδο του χρόνου, το IPF ενισχύθηκε με την επιλογή "quick" και με δυνατότητα αποθήκευσης κατάστασης μέσω της επιλογής "keep state". Με τον τρόπο αυτό, εκσυγχρονίστηκε δραματικά η λογική επεξεργασίας των κανόνων.</p></div><div class=paragraph><p>Οι οδηγίες που περιέχονται σε αυτή την ενότητα βασίζονται στη χρήση κανόνων που περιέχουν την επιλογή "quick" και την επιλογή "keep state" για τη διατήρηση της κατάστασης. Αυτές είναι και οι βασικές λειτουργίες για την κωδικοποίηση του συνόλου κανόνων ενός inclusive firewall.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Όταν δουλεύετε με τους κανόνες του firewall, θα πρέπει να είστε <em>πολύ προσεκτικοί</em>. Αν βάλετε λανθασμένες ρυθμίσεις, μπορεί να <em>κλειδωθείτε έξω</em> από τον εξυπηρετητή σας. Για να είστε ασφαλείς, είναι προτιμότερο να κάνετε τις αρχικές σας ρυθμίσεις από την τοπική κονσόλα, παρά μέσω απομακρυσμένης σύνδεσης (π.χ. μέσω ssh).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_συντακτικό_κανόνων>55.5.11. Συντακτικό Κανόνων<a class=anchor href=#_συντακτικό_κανόνων></a></h4><div class=paragraph><p>Το συντακτικό των κανόνων που παρουσιάζουμε εδώ, έχει απλοποιηθεί ώστε να απεικονίζει τη σύγχρονη stateful υλοποίηση και τη λογική του τύπου "ο πρώτος κανόνας που ταιριάζει είναι και ο νικητής". Για την περιγραφή του παλιότερου τρόπου λειτουργίας, διαβάστε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a>.</p></div><div class=paragraph><p>Ο χαρακτήρας <code>#</code> χρησιμοποιείται για να επισημάνει την αρχή ενός σχολίου, και μπορεί να εμφανίζεται στο τέλος μιας γραμμής κανόνα ή στη δική του γραμμή. Οι κενές γραμμές αγνοούνται.</p></div><div class=paragraph><p>Οι κανόνες περιέχουν λέξεις-κλειδιά. Οι λέξεις αυτές θα πρέπει να κωδικοποιηθούν με συγκεκριμένη σειρά από τα αριστερά προς τα δεξιά της γραμμής. Οι λέξεις-κλειδιά φαίνονται παρακάτω με έντονα γράμματα. Μερικές λέξεις έχουν υπο-επιλογές οι οποίες μπορεί να είναι επίσης λέξεις-κλειδιά και να περιλαμβάνουν επίσης περισσότερες υπο-επιλογές. Κάθε μια από τις επικεφαλίδες στο παράδειγμα που φαίνεται παρακάτω έχει μια κεφαλίδα με έντονα γράμματα η οποία επεξηγεί το περιεχόμενο της.</p></div><div class=paragraph><p><code><em>ACTION IN-OUT OPTIONS SELECTION STATEFUL PROTO SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG STATEFUL</em></code></p></div><div class=paragraph><p><code><em>ACTION</em></code> = block | pass</p></div><div class=paragraph><p><code><em>IN-OUT</em></code> = in | out</p></div><div class=paragraph><p><code><em>OPTIONS</em></code> = log | quick | on interface-name</p></div><div class=paragraph><p><code><em>SELECTION</em></code> = proto value | source/destination IP | port = number | flags flag-value</p></div><div class=paragraph><p><code><em>PROTO</em></code> = tcp/udp | udp | tcp | icmp</p></div><div class=paragraph><p><code><em>SRC_ADD,DST_ADDR</em></code> = all | from object to object</p></div><div class=paragraph><p><code><em>OBJECT</em></code> = IP address | any</p></div><div class=paragraph><p><code><em>PORT_NUM</em></code> = port number</p></div><div class=paragraph><p><code><em>TCP_FLAG</em></code> = S</p></div><div class=paragraph><p><code><em>STATEFUL</em></code> = keep state</p></div><div class=sect4><h5 id=_action>55.5.11.1. ACTION<a class=anchor href=#_action></a></h5><div class=paragraph><p>Η ενέργεια (action) δείχνει τι πρέπει να γίνει με το πακέτο αν ταιριάζει με τον κανόνα του φίλτρου. Κάθε κανόνας <em>πρέπει</em> να διαθέτει μια ενέργεια. Οι ενέργειες που αναγνωρίζονται, φαίνονται παρακάτω:</p></div><div class=paragraph><p>Το <code>block</code> δείχνει ότι το πακέτο θα πρέπει να απορριφθεί αν ταιριάζει με τις παραμέτρους επιλογής του κανόνα.</p></div><div class=paragraph><p>Το <code>pass</code> δείχνει ότι το πακέτο θα πρέπει να εξέλθει από το firewall, αν ταιριάζει με τις παραμέτρους επιλογής του κανόνα.</p></div></div><div class=sect4><h5 id=_in_out>55.5.11.2. IN-OUT<a class=anchor href=#_in_out></a></h5><div class=paragraph><p>Κάθε κανόνας του φίλτρου πρέπει υποχρεωτικά να διευκρινίζει με σαφήνεια αν αναφέρεται στην είσοδο ή την έξοδο πακέτων. Η επόμενη λέξη-κλειδί πρέπει να είναι <code>in</code> ή <code>out</code> και αν δεν υπάρχει, ο κανόνας θα αποτύχει κατά το συντακτικό έλεγχο.</p></div><div class=paragraph><p>Το <code>in</code> σημαίνει ότι ο κανόνας θα εφαρμοστεί σε ένα εισερχόμενο πακέτο το οποίο μόλις λήφθηκε στη διεπαφή που συνδέεται με το Διαδίκτυο.</p></div><div class=paragraph><p>Το <code>out</code> σημαίνει ότι ο κανόνας θα εφαρμοστεί σε ένα πακέτο που προορίζεται για έξοδο μέσω της διεπαφής που συνδέεται με το Διαδίκτυο.</p></div></div><div class=sect4><h5 id=_options>55.5.11.3. OPTIONS<a class=anchor href=#_options></a></h5><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Οι παρακάτω επιλογές πρέπει να χρησιμοποιηθούν με τη σειρά που φαίνονται εδώ.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το <code>log</code> δείχνει ότι η επικεφαλίδα του πακέτου θα γραφεί στο αρχείο καταγραφής του <span class=filename>ipl</span> (όπως περιγράφεται στην ενότητα LOGGING που ακολουθεί) αν οι παράμετροι της επιλογής ταιριάζουν με το πακέτο.</p></div><div class=paragraph><p>To <code>quick</code> δείχνει ότι αν οι παράμετροι της επιλογής ταιριάζουν με το πακέτο, ο συγκεκριμένος κανόνας θα είναι και ο τελευταίος κανόνας που θα ελεγχθεί. Η επιλογή αυτή είναι υποχρεωτική για τη σύγχρονη λογική επεξεργασίας πακέτων.</p></div><div class=paragraph><p>Το <code>on</code> δείχνει το όνομα της διεπαφής που θα ενσωματωθεί στις παραμέτρους επιλογής. Τα ονόματα των διεπαφών φαίνονται όταν εκτελείται η εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Χρησιμοποιώντας την επιλογή αυτή, ο κανόνας θα ελεγχθεί μόνο αν το πακέτο διέρχεται μέσω της συγκεκριμένης διεπαφής και προς τη συγκεκριμένη κατεύθυνση (εισερχόμενα/εξερχόμενα). Η επιλογή αυτή είναι υποχρεωτική για την σύγχρονη λογική επεξεργασίας των κανόνων.</p></div><div class=paragraph><p>Όταν γίνεται καταγραφή ενός πακέτου, οι επικεφαλίδες γράφονται στην ψευδο-συσκευή καταγραφής πακέτων IPL. Μετά την εντολή <code>log</code>, μπορούν να χρησιμοποιηθούν οι παρακάτω παράμετροι (με τη σειρά που φαίνονται):</p></div><div class=paragraph><p>Το <code>body</code> δείχνει ότι θα γίνει καταγραφή των πρώτων 128 bytes των περιεχομένων του πακέτου, που βρίσκονται αμέσως μετά την επικεφαλίδα.</p></div><div class=paragraph><p>Η επιλογή <code>first</code> συνίσταται να χρησιμοποιηθεί αν η επιλογή <code>log</code> χρησιμοποιείται σε συνδυασμό με την <code>keep state</code>. Με τον τρόπο αυτό γίνεται καταγραφή μόνο του πρώτου πακέτου (με το οποίο ξεκίνησε η επικοινωνία), και όχι όλων των υπολοίπων τα οποία ταιριάζουν με την πληροφορία "keep state".</p></div></div><div class=sect4><h5 id=_selection>55.5.11.4. SELECTION<a class=anchor href=#_selection></a></h5><div class=paragraph><p>Οι λέξεις κλειδιά που περιγράφονται σε αυτή την ενότητα, χρησιμοποιούνται για να περιγράψουν ποιες ιδιότητες του πακέτου θα διερευνηθούν για να καθοριστεί αν ταιριάζει ή όχι με τους κανόνες. Μια λέξη-κλειδί ορίζει το κεντρικό θέμα και ακολουθείται από άλλες λέξεις που ορίζουν τις ακριβείς επιλογές. Πρέπει πάντοτε να επιλέγεται μια από αυτές τις λέξεις. Παρέχονται οι παρακάτω ιδιότητες γενικής χρήσης οι οποίες πρέπει να χρησιμοποιηθούν με αυτή τη σειρά:</p></div></div><div class=sect4><h5 id=_proto>55.5.11.5. PROTO<a class=anchor href=#_proto></a></h5><div class=paragraph><p>Το <code>proto</code> είναι η βασική λέξη, και πρέπει να γράφεται μαζί με κάποια αντίστοιχη τιμή για περαιτέρω επιλογή. Η τιμή επιτρέπει το ταίριασμα με ένα συγκεκριμένο πρωτόκολλο. Είναι υποχρεωτικό να χρησιμοποιηθεί για να λειτουργεί η σύγχρονη λογική επεξεργασίας των κανόνων.</p></div><div class=paragraph><p>Τα ονόματα πρωτοκόλλων που αναγνωρίζονται και μπορούν να χρησιμοποιηθούν, είναι τα <code>tcp/udp | udp | tcp | icmp</code> ή οποιαδήποτε άλλα εμφανίζονται στο <span class=filename>/etc/protocols</span>. Μπορείτε να χρησιμοποιήσετε το ειδικό όνομα <code>tcp/udp</code> το οποίο ταιριάζει είτε με πακέτο TCP είτε με UDP. Η ειδική αυτή ονομασία προστέθηκε ώστε να αποφεύγονται διπλοί, αλλά κατά τα άλλα όμοιοι, κανόνες.</p></div></div><div class=sect4><h5 id=_src_addrdst_addr>55.5.11.6. SRC_ADDR/DST_ADDR<a class=anchor href=#_src_addrdst_addr></a></h5><div class=paragraph><p>Η λέξη <code>all</code> είναι ουσιαστικά συνώνυμη με την φράση "from any to any" χωρίς να υπάρχουν άλλες παράμετροι για το ταίριασμα.</p></div><div class=paragraph><p>Όταν χρησιμοποιείται το <code>from src to dst</code>, οι λέξεις <code>from</code> και <code>to</code> δηλώνουν διευθύνσεις IP που θα χρησιμοποιηθούν για το ταίριασμα. Οι κανόνες πρέπει να καθορίζουν τις παραμέτρους τόσο της αφετηρίας όσο και του προορισμού. Η λέξη <code>any</code> έχει την ειδική ιδιότητα να ταιριάζει με οποιαδήποτε διεύθυνση IP. Παραδείγματα χρήσης: <code>from any to any</code> ή <code>from 0.0.0.0/0 to any</code> ή <code>from any to 0.0.0.0/0</code> ή <code>from 0.0.0.0 to any</code> ή <code>from any to 0.0.0.0</code>.</p></div><div class=paragraph><p>Δεν υπάρχει τρόπος να περιγραφούν περιοχές IP διευθύνσεων που δεν μπορούν να εκφραστούν εύκολα με τη μορφή αριθμών χωρισμένων με τελείες / μάσκας υποδικτύου. Μπορείτε να χρησιμοποιήσετε το βοηθητικό πρόγραμμα <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> για διευκόλυνση σας στους υπολογισμούς. Δείτε την δικτυακή τοποθεσία του προγράμματος για περισσότερες πληροφορίες: <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div></div><div class=sect4><h5 id=_port>55.5.11.7. PORT<a class=anchor href=#_port></a></h5><div class=paragraph><p>Το ταίριασμα με κάποια συγκεκριμένη θύρα αφετηρίας ή/και προορισμού (αν υπάρχει) εφαρμόζεται μόνο σε πακέτα TCP και UDP. Κατά την δημιουργία συγκρίσεων με θύρες, μπορείτε είτε να χρησιμοποιήσετε τον αριθμό της θύρας, είτε το όνομα της αντίστοιχης υπηρεσίας από το αρχείο <span class=filename>/etc/services</span>. Όταν η θύρα εμφανίζεται ως τμήμα του αντικειμένου <code>from</code>, το ταίριασμα θα γίνει με την θύρα της αφετηρίας. Όταν εμφανίζεται ως τμήμα του αντικειμένου <code>to</code>, το ταίριασμα θα γίνει με τη θύρα προορισμού. Για να λειτουργεί η σύγχρονη λογική ταιριάσματος κανόνων, θα πρέπει οπωσδήποτε να υπάρχει η επιλογή θύρας στο αντικείμενο <code>to</code>. Παράδειγμα χρήσης: <code>from any to any port = 80</code></p></div><div class=paragraph><p>Οι συγκρίσεις που αναφέρονται σε μια μόνο θύρα, μπορούν να γίνουν με πολλούς διαφορετικούς τρόπους, χρησιμοποιώντας διαφορετικούς τελεστές σύγκρισης. Είναι επίσης δυνατόν να καθοριστούν ολόκληρες περιοχές από θύρες.</p></div><div class=paragraph><p>port "=" | "!=" | "&lt;" | ">" | "⇐" | ">=" | "eq" | "ne" | "lt" | "gt" | "le" | "ge".</p></div><div class=paragraph><p>Για να καθορίσετε περιοχές θυρών, χρησιμοποιήστε port "&lt;>" | ">&lt;"</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Μετά τις παραμέτρους για το ταίριασμα της αφετηρίας και του προορισμού, οι παρακάτω δύο παράμετροι είναι υποχρεωτικές για να λειτουργεί η σύγχρονη λογική επεξεργασίας των κανόνων.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_tcp_flag>55.5.11.8. TCP_FLAG<a class=anchor href=#_tcp_flag></a></h5><div class=paragraph><p>Τα flags είναι ενεργά μόνο στο φιλτράρισμα του πρωτοκόλλου TCP. Το κάθε γράμμα αντιπροσωπεύει ένα πιθανό flag το για το οποίο γίνεται ανίχνευση στην επικεφαλίδα του πακέτου TCP.</p></div><div class=paragraph><p>Η σύγχρονη λογική επεξεργασίας των κανόνων, χρησιμοποιεί την παράμετρο <code>flags S</code> για την αναγνώριση της έναρξης μια συνεδρίας tcp.</p></div></div><div class=sect4><h5 id=_stateful>55.5.11.9. STATEFUL<a class=anchor href=#_stateful></a></h5><div class=paragraph><p>Σε ένα κανόνα που επιτρέπει (pass) το πέρασμα των πακέτων, η επιλογή <code>keep state</code> δείχνει ότι θα πρέπει να ενεργοποιείται η λειτουργία stateful filtering όταν το πακέτο ταιριάζει με τα κριτήρια επιλογής.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η επιλογή αυτή είναι υποχρεωτική για τη λειτουργία της σύγχρονης λογικής επεξεργασίας κανόνων.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_φιλτράρισμα_με_διατήρηση_της_κατάστασης_stateful>55.5.12. Φιλτράρισμα με Διατήρηση της Κατάστασης (stateful)<a class=anchor href=#_φιλτράρισμα_με_διατήρηση_της_κατάστασης_stateful></a></h4><div class=paragraph><p>Το stateful φιλτράρισμα, αντιμετωπίζει την κίνηση του δικτύου ως μιας διπλής κατεύθυνσης ανταλλαγή πακέτων τα οποία δημιουργούν μια συνεδρία. Όταν ενεργοποιηθεί, η διατήρηση της κατάστασης (keep-state) δημιουργεί δυναμικά εσωτερικούς κανόνες για κάθε πακέτο το οποίο ανταλλάσσεται κατά τη διάρκεια αυτής της συνεδρίας. Έχει επίσης τη δυνατότητα να διερευνήσει αν ακολουθούνται οι έγκυροι κανόνες ανταλλαγής μηνυμάτων μεταξύ του αποστολέα και του παραλήπτη. Οποιαδήποτε πακέτα δεν ταιριάζουν με το πρότυπο αυτής της επικοινωνίας, απορρίπτονται ως ψεύτικα.</p></div><div class=paragraph><p>Η διατήρηση της κατάστασης επιτρέπει επίσης να περάσουν τα πακέτα ICMP που σχετίζονται με μια συνεδρία TCP ή UDP. Έτσι, αν ληφθούν πακέτα ICMP τύπου 3 code 4 ως απάντηση κατά τη διάρκεια της επίσκεψης σας σε μια ιστοσελίδα, (η οποία επιτρέπεται από τον αντίστοιχο κανόνα εξερχομένων), θα τους επιτραπεί η είσοδος. Οποιοδήποτε πακέτο για το οποίο το IPF είναι σίγουρο ότι πρόκειται για τμήμα μιας ενεργής συνεδρίας, θα περάσει ακόμα και αν είναι διαφορετικό πρωτόκολλο.</p></div><div class=paragraph><p>Αυτό που συμβαίνει είναι το παρακάτω:</p></div><div class=paragraph><p>Τα πακέτα που προορίζονται να εξέλθουν μέσω της διεπαφής που συνδέεται στο Internet, ελέγχονται αρχικά σύμφωνα με το δυναμικό πίνακα καταστάσεων. Αν το πακέτο ταιριάζει με το επόμενο που αναμένεται σε μια ενεργή συνεδρία, εξέρχεται από το firewall και ταυτόχρονα ενημερώνεται η κατάσταση της συγκεκριμένης συνεδρίας στον παραπάνω δυναμικό πίνακα. Τα υπόλοιπα πακέτα (που δεν ταιριάζουν με κάποια συνεδρία σε εξέλιξη) ελέγχονται σύμφωνα με το σύνολο κανόνων για τα εξερχόμενα πακέτα.</p></div><div class=paragraph><p>Τα πακέτα που έρχονται από τη διεπαφή που είναι συνδεμένη με το Internet, ελέγχονται αρχικά μέσω του δυναμικού πίνακα καταστάσεων. Αν το πακέτο ταιριάζει με το επόμενο που αναμένεται σε μια ενεργή συνεδρία, εξέρχεται από το firewall και ταυτόχρονα ενημερώνεται η κατάσταση της συγκεκριμένης συνεδρίας στον παραπάνω πίνακα. Τα υπόλοιπα πακέτα (που δεν ταιριάζουν με κάποια συνεδρία σε εξέλιξη) ελέγχονται σύμφωνα με το σύνολο κανόνων για τα εισερχόμενα πακέτα.</p></div><div class=paragraph><p>Όταν η επικοινωνία ολοκληρωθεί, διαγράφεται από τον δυναμικό πίνακα καταστάσεων.</p></div><div class=paragraph><p>Το stateful φιλτράρισμα επιτρέπει να εστιάσουμε την προσοχή μας στην αποδοχή ή απόρριψη των νέων συνδέσεων. Αν επιτραπεί μια νέα συνεδρία, όλα τα υπόλοιπα πακέτα της θα επιτρέπονται αυτόματα, ενώ τυχόν ψεύτικα πακέτα θα απορρίπτονται επίσης αυτόματα. Το stateful φιλτράρισμα διαθέτει μια σειρά από προχωρημένες ικανότητες διερεύνησης των πακέτων, με δυνατότητα να αμύνεται σε πολλές διαφορετικές μεθόδους που χρησιμοποιούν οι επιτιθέμενοι.</p></div></div><div class=sect3><h4 id=_παράδειγμα_συνόλου_κανόνων_για_ένα_inclusive_firewall>55.5.13. Παράδειγμα Συνόλου Κανόνων για ένα Inclusive Firewall<a class=anchor href=#_παράδειγμα_συνόλου_κανόνων_για_ένα_inclusive_firewall></a></h4><div class=paragraph><p>Το παρακάτω σύνολο κανόνων δίνεται ως παράδειγμα για να φτιάξετε ένα ιδιαίτερα ασφαλές inclusive firewall. Ένα inclusive firewall επιτρέπει το πέρασμα μόνο των υπηρεσιών που ταιριάζουν με τους κανόνες που έχει για αποδοχή πακέτων, και απορρίπτει όλα τα υπόλοιπα. Τα firewalls που προστατεύουν άλλα μηχανήματα (τα οποία καλούνται και "network firewalls") θα πρέπει να διαθέτουν τουλάχιστον δύο διεπαφές. Η μια διεπαφή συνδέεται με το τοπικό δίκτυο (LAN) το οποίο θεωρείται έμπιστο, και η άλλη με το δημόσιο Internet. Εναλλακτικά, ένα firewall μπορεί να προστατεύει μόνο το σύστημα στο οποίο εκτελείται-αυτό καλείται "host based firewall" και είναι κατάλληλο ιδιαίτερα για εξυπηρετητές που λειτουργούν σε μη έμπιστα δίκτυα.</p></div><div class=paragraph><p>Όλα τα συστήματα τύπου UNIX®, συμπεριλαμβανομένου και του FreeBSD, έχουν σχεδιαστεί να χρησιμοποιούν την διεπαφή <span class=filename>lo0</span> και την IP διεύθυνση <code>127.0.0.1</code> για εσωτερική επικοινωνία μέσα στο ίδιο το λειτουργικό σύστημα. Το firewall πρέπει να περιέχει κανόνες που να επιτρέπουν την ελεύθερη και χωρίς περιορισμούς κίνηση των ειδικών αυτών εσωτερικών πακέτων.</p></div><div class=paragraph><p>Οι κανόνες που εξουσιοδοτούν την πρόσβαση προς το Internet, ορίζονται στην διεπαφή του δικτύου που συνδέεται σε αυτό. Οι κανόνες αυτοί ελέγχουν τόσο την εισερχόμενη όσο και την εξερχόμενη κίνηση στο Internet. Η διεπαφή αυτή μπορεί να είναι η <span class=filename>tun0</span> που χρησιμοποιείται στο PPP χρήστη, ή ακόμα και η κάρτα δικτύου που συνδέεται σε ένα DSL router ή modem.</p></div><div class=paragraph><p>Σε περίπτωση που μια ή περισσότερες κάρτες δικτύου συνδέονται σε εσωτερικά ιδιωτικά δίκτυα πίσω από το firewall, θα πρέπει να υπάρχουν οι αντίστοιχοι κανόνες που να επιτρέπουν την ελεύθερη διακίνηση των πακέτων ανάμεσα στις διεπαφές αυτές ή/και στο Internet.</p></div><div class=paragraph><p>Οι κανόνες πρέπει να οργανώνονται σε τρεις κύριες ενότητες: αρχικά όλες οι διεπαφές στις οποίες επιτρέπεται η ελεύθερη διακίνηση δεδομένων, έπειτα η διεπαφή από την οποία εξέρχονται τα πακέτα προς το δημόσιο δίκτυο (Internet) και τέλος η διεπαφή από την οποία λαμβάνονται πακέτα από το Internet.</p></div><div class=paragraph><p>Σε κάθε μια από τις ενότητες των διεπαφών που συνδέονται στο Internet, πρέπει να τοποθετούνται πρώτοι οι κανόνες που ταιριάζουν συχνότερα με την αντίστοιχη κίνηση. Ο τελευταίος κανόνας της ενότητας θα πρέπει να απορρίπτει και να καταγράφει όλα τα πακέτα της συγκεκριμένης διεπαφής/κατεύθυνσης.</p></div><div class=paragraph><p>Η ενότητα των Εξερχομένων (Outbound) στο ακόλουθο σύνολο κανόνων, περιέχει μόνο κανόνες τύπου <code>pass</code> οι οποίοι επιτρέπουν (μέσω κατάλληλων τιμών στις παραμέτρους τους) σε συγκεκριμένες υπηρεσίες να αποκτήσουν πρόσβαση στο Internet. Όλοι οι κανόνες διαθέτουν τις επιλογές <code>quick</code>, <code>on</code>, <code>proto</code>, <code>port</code> και <code>keep state</code>. Οι κανόνες <code>proto tcp</code> περιλαμβάνουν την επιλογή <code>flag</code> ώστε να αναγνωρίζουν την αίτηση έναρξης της συνεδρίας και να ενεργοποιούν τη λειτουργία διατήρησης της κατάστασης (stateful).</p></div><div class=paragraph><p>Στην ενότητα των εισερχόμενων πακέτων (Inbound) που φαίνεται παρακάτω, πρώτοι εμφανίζονται οι κανόνες που χρησιμοποιούνται για την απόρριψη των ανεπιθύμητων πακέτων. Αυτό γίνεται για δύο διαφορετικούς λόγους. Ο πρώτος είναι ότι τα κακόβουλα πακέτα μπορεί εν μέρει να ταιριάζουν με κάποια χαρακτηριστικά της έγκυρης κίνησης. Τα πακέτα αυτά θα πρέπει να απορριφθούν, αντί να γίνουν δεκτά από κάποιο επόμενο κανόνα <code>allow</code>. Ο δεύτερος είναι ότι μπορείτε να απορρίψετε συγκεκριμένα πακέτα τα οποία γνωρίζετε ότι δεν είναι έγκυρα, αλλά σας είναι αδιάφορη η καταγραφή τους. Με τον τρόπο αυτό εμποδίζεται η λήψη και καταγραφή τους από τον τελευταίο κανόνα. Ο τελευταίος κανόνας τυπικά απορρίπτει και καταγράφει όλα τα πακέτα που έφτασαν μέχρι αυτόν. Ο κανόνας αυτός χρησιμοποιείται για την παροχή νομικών αποδείξεων σε περίπτωση που κινήσετε δικαστική διαδικασία κατά ατόμων που προέβησαν σε επιθέσεις στο σύστημα σας.</p></div><div class=paragraph><p>Θα πρέπει επίσης να εξασφαλίσετε ότι το σύστημα σας δεν θα δώσει καμιά απάντηση σε κανένα από τα ανεπιθύμητα πακέτα. Τα πακέτα αυτά θα πρέπει να απορριφθούν και να εξαφανιστούν. Με τον τρόπο αυτό, ο επιτιθέμενος δεν έχει καμιά γνώση αν τα πακέτα του έφτασαν μέχρι το σύστημα σας. Όσο λιγότερα μπορούν να μάθουν οι επιτιθέμενοι σχετικά με το σύστημα σας, τόσο περισσότερο χρόνο θα χρειαστεί να επενδύσουν για να καταφέρουν να σας βλάψουν στα αλήθεια. Οι κανόνες με την επιλογή <code>log first</code> καταγράφουν το συμβάν μόνο την πρώτη φορά που ενεργοποιούνται. Η επιλογή αυτή περιλαμβάνεται στον κανόνα <code>nmap OS fingerprint</code> στο παράδειγμα που φαίνεται παρακάτω. Το βοηθητικό πρόγραμμα <a class=package href=https://cgit.freebsd.org/ports/tree/security/nmap/>security/nmap</a> χρησιμοποιείται συχνά από κακόβουλα άτομα, που προσπαθούν με αυτό τον τρόπο να αναγνωρίσουν το λειτουργικό σύστημα του μηχανήματος σας.</p></div><div class=paragraph><p>Κάθε φορά που υπάρχει καταγραφή από κάποιο κανόνα με την επιλογή <code>log first</code>, θα πρέπει να εκτελέσετε την εντολή <code>ipfstat -hio</code> για να δείτε πόσες φορές έχει ενεργοποιηθεί αυτός ο κανόνας συνολικά. Έτσι θα ξέρετε αν π.χ. σας κάνουν επίθεση υπερχείλισης (flood).</p></div><div class=paragraph><p>Δείτε το αρχείο <span class=filename>/etc/services</span> για να βρείτε αριθμούς θυρών που δεν αναγνωρίζετε. Μπορείτε επίσης να επισκεφθείτε την τοποθεσία <a href=http://www.securitystats.com/tools/portsearch.php>http://www.securitystats.com/tools/portsearch.php</a> και να κάνετε αναζήτηση για τη συγκεκριμένη θύρα, ώστε να δείτε ποια υπηρεσία εξυπηρετεί.</p></div><div class=paragraph><p>Δείτε την επόμενη τοποθεσία για τις θύρες που χρησιμοποιούνται συνήθως από κακόβουλα προγράμματα (trojans): <a href=http://www.simovits.com/trojans/trojans.html>http://www.simovits.com/trojans/trojans.html</a>.</p></div><div class=paragraph><p>Το παρακάτω σύνολο κανόνων είναι αρκετά πλήρες και πολύ ασφαλές. Δημιουργεί firewall τύπου <code>inclusive</code>, και έχει δοκιμαστεί σε πραγματικές συνθήκες λειτουργίας. Μπορεί να εξυπηρετήσει το ίδιο καλά και το δικό σας σύστημα. Απλώς μετατρέψτε σε σχόλιο τους κανόνες για τις υπηρεσίες που δεν θέλετε να ενεργοποιήσετε.</p></div><div class=paragraph><p>Για να αποφύγετε την καταγραφή ανεπιθύμητων μηνυμάτων, απλώς προσθέστε ένα αντίστοιχο κανόνα απόρριψης (<code>block</code>) στην ενότητα των εισερχομένων (inbound).</p></div><div class=paragraph><p>Θα πρέπει να αλλάξετε το όνομα της διεπαφής <span class=filename>dc0</span> του παραδείγματος, με το πραγματικό όνομα της κάρτας δικτύου που συνδέει το σύστημα σας με το Internet. Για όσους χρησιμοποιούν το PPP χρήστη, το όνομα θα είναι <span class=filename>tun0</span>.</p></div><div class=paragraph><p>Προσθέστε τις ακόλουθες καταχωρίσεις στο αρχείο <span class=filename>/etc/ipf.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Match session start requests originating from behind the
# firewall on the private network
# or from this gateway server destined for the public Internet.
#################################################################

# Allow out access to my ISP&#39;s Domain name server.
# xxx must be the IP address of your ISP&#39;s DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP&#39;s DHCP server for cable or DSL networks.
# This rule is not needed for &#39;user ppp&#39; type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users&#39; non-secure FTP ( both passive &amp; active modes)
# This function uses the IPNAT built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out ssh/sftp/scp (telnet/rlogin/FTP replacements)
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out insecure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FreeBSD CVSup function
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois from LAN to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that&#39;s trying to get out.
# This rule implements the default block
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Match packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP&#39;s DHCP server. This rule must contain
# the IP address of your ISP&#39;s DHCP server as it&#39;s the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# &#39;user ppp&#39; type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence avoids filling up disk with Denial of Service logs.
# This rule implements the default block.
block in log first quick on dc0 all
################### End of rules file #####################################</pre></div></div></div><div class=sect3><h4 id=_nat>55.5.14. NAT<a class=anchor href=#_nat></a></h4><div class=paragraph><p>Το NAT είναι ακρωνύμιο των λέξεων <em>Network Address Translation</em> ή Μετάφραση Διευθύνσεων Δικτύου. Για όσους είναι εξοικειωμένοι με το Linux®, βασίζεται στην αρχή του IP Masquerading. Στην πραγματικότητα το NAT και το IP Masquerading είναι το ίδιο πράγμα. Μια από τις πολλές δυνατότητες που παρέχει η λειτουργία NAT του IPF, είναι και η δυνατότητα να έχουμε ένα ιδιωτικό τοπικό δίκτυο (LAN) πίσω από το firewall το οποίο να μοιράζεται μια μοναδική δημόσια διεύθυνση IP στο Internet.</p></div><div class=paragraph><p>Ίσως να αναρωτηθείτε γιατί να θέλει κάποιος να το κάνει αυτό. Οι ISPs συνήθως αποδίδουν δυναμικές διευθύνσεις σε μη εταιρικούς πελάτες. Αυτό ουσιαστικά σημαίνει ότι η διεύθυνση IP που αποδίδεται στο μηχάνημα σας, μπορεί να είναι διαφορετική κάθε φορά που κάνετε κλήση για να συνδεθείτε. Για τους χρήστες DSL modem και router, η αλλαγή διεύθυνσης πραγματοποιείται κάθε φορά που ενεργοποιείται το modem. Η διεύθυνση IP που σας αποδίδεται από τον ISP σας, είναι αυτή με την οποία φαίνεστε στο Internet.</p></div><div class=paragraph><p>Ας υποθέσουμε τώρα ότι έχετε πέντε PC στο σπίτι σας, και χρειάζεστε σε όλα σύνδεση Internet. Κανονικά, θα έπρεπε να πληρώσετε τον ISP σας χωριστό λογαριασμό για κάθε PC και να διαθέτετε πέντε γραμμές τηλεφώνου.</p></div><div class=paragraph><p>Με το NAT, χρειάζεστε μόνο ένα λογαριασμό με τον ISP σας. Μπορείτε απλώς να συνδέσετε τα τέσσερα PC σε ένα διανομέα ή switch στο οποίο θα συνδέσετε επίσης και το FreeBSD μηχάνημα σας. Το μηχάνημα αυτό θα ενεργεί ως πύλη του τοπικού σας δικτύου για το Internet. Το NAT θα μεταφράσει αυτόματα τις ιδιωτικές διευθύνσεις IP του κάθε μηχανήματος στην μοναδική δημόσια IP διεύθυνση που έχετε, καθώς το πακέτο φεύγει από το firewall και κατευθύνεται προς το Internet. Εκτελεί επίσης και την αντίστροφη μετάφραση για τα πακέτα που επιστρέφουν.</p></div><div class=paragraph><p>Υπάρχει μια ειδική περιοχή διευθύνσεων IP που έχουν παραχωρηθεί για χρήση σε τοπικά δίκτυα με NAT. Σύμφωνα με το RFC 1918, μπορείτε να χρησιμοποιήσετε για αυτό το σκοπό τις παρακάτω περιοχές, οι οποίες δεν δρομολογούνται ποτέ απευθείας στο δημόσιο Internet:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχικό IP <code>10.0.0.0</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τελικό IP <code>10.255.255.255</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχικό IP <code>172.16.0.0</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τελικό IP <code>172.31.255.255</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Αρχικό IP <code>192.168.0.0</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τελικό IP <code>192.168.255.255</code></p></td></tr></tbody></table></div><div class=sect3><h4 id=_ipnat>55.5.15. IPNAT<a class=anchor href=#_ipnat></a></h4><div class=paragraph><p>Οι κανόνες του NAT φορτώνονται με τη χρήση της εντολής <code>ipnat</code>. Τυπικά, οι κανόνες του NAT αποθηκεύονται στο αρχείο <span class=filename>/etc/ipnat.rules</span>. Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=1&amp;format=html">ipnat(1)</a> για λεπτομέρειες.</p></div><div class=paragraph><p>Για να αλλάξετε τους κανόνες του NAT καθώς αυτό εκτελείται, τροποποιήστε το αρχείο που τους περιέχει, και εκτελέστε την εντολή <code>ipnat</code> με την παράμετρο <code>-CF</code> για να διαγράψετε τους εσωτερικούς κανόνες του NAT και να αδειάσετε όλες τις ενεργές καταχωρίσεις του πίνακα μεταφράσεων.</p></div><div class=paragraph><p>Για να φορτώσετε τους κανόνες του NAT από την αρχή, εκτελέστε μια εντολή όπως την παρακάτω:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -CF -f /etc/ipnat.rules</span></code></pre></div></div><div class=paragraph><p>Για να δείτε κάποια στατιστικά σχετικά με το NAT, χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -s</span></code></pre></div></div><div class=paragraph><p>Για να δείτε μια λίστα με τις τρέχουσες καταχωρίσεις του πίνακα NAT, χρησιμοποιήστε την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -l</span></code></pre></div></div><div class=paragraph><p>Για να ενεργοποιήσετε την λεπτομερή απεικόνιση μηνυμάτων και να δείτε πληροφορίες που σχετίζονται με την επεξεργασία των κανόνων και τους ενεργούς κανόνες και καταχωρίσεις στον πίνακα, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -v</span></code></pre></div></div></div><div class=sect3><h4 id=_κανόνες_του_ipnat>55.5.16. Κανόνες του IPNAT<a class=anchor href=#_κανόνες_του_ipnat></a></h4><div class=paragraph><p>Οι κανόνες του NAT είναι αρκετά ευέλικτοι, και διαθέτουν πλήθος δυνατοτήτων ώστε να καλύπτουν τις ανάγκες των οικιακών αλλά και των επιχειρησιακών χρηστών.</p></div><div class=paragraph><p>Η σύνταξη των κανόνων που παρουσιάζεται εδώ, έχει απλοποιηθεί ώστε να συμβαδίζει με τη συνήθη χρήση σε μη-εμπορικά περιβάλλοντα. Για πιο πλήρη περιγραφή της σύνταξης, δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a>.</p></div><div class=paragraph><p>Η σύνταξη ενός κανόνα NAT μοιάζει με την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre></div></div><div class=paragraph><p>Ο κανόνας ξεκινάει με τη λέξη <code>map</code>.</p></div><div class=paragraph><p>Αντικαταστήστε το <em>IF</em> με την εξωτερική διεπαφή (τη κάρτα δικτύου που συνδέεται στο Internet).</p></div><div class=paragraph><p>Η παράμετρος <code><em>LAN_IP_RANGE</em></code> είναι η περιοχή διευθύνσεων που χρησιμοποιείται από το εσωτερικό σας δίκτυο. Στην πραγματικότητα θα μοιάζει με κάτι σαν το <code>192.168.1.0/24</code>.</p></div><div class=paragraph><p>Η παράμετρος <code><em>PUBLIC_ADDRESS</em></code> μπορεί να είναι είτε η εξωτερική IP διεύθυνση, είτε η ειδική λέξη <code>0/32</code>, η οποία σημαίνει ότι θα χρησιμοποιηθεί η IP διεύθυνση που έχει αποδοθεί στο <em>IF</em>.</p></div></div><div class=sect3><h4 id=_πως_λειτουργεί_το_nat>55.5.17. Πως Λειτουργεί το NAT<a class=anchor href=#_πως_λειτουργεί_το_nat></a></h4><div class=paragraph><p>Ένα πακέτο φτάνει στο firewall από το LAN με προορισμό το Internet. Περνάει διαμέσου των κανόνων φιλτραρίσματος εξερχομένων, όπου γίνεται η επεξεργασία του από το NAT. Οι κανόνες εφαρμόζονται από τον πρώτο και προς τα κάτω, και κερδίζει ο πρώτος που ταιριάζει. Ο έλεγχος γίνεται με βάση τη διεπαφή από την οποία λήφθηκε το πακέτο και τη διεύθυνση IP από την οποία προέρχεται. Όταν το όνομα της διεπαφής ενός πακέτου ταιριάζει με κάποιο κανόνα του NAT, η διεύθυνση IP της αφετηρίας (που προέρχεται από το ιδιωτικό δίκτυο) ελέγχεται για να εξακριβωθεί αν ταιριάζει με την περιοχή διευθύνσεων που καθορίζεται στην αριστερά πλευρά του συμβόλου (βέλος) του κανόνα NAT. Αν ταιριάζει, η διεύθυνση του πακέτου ξαναγράφεται, χρησιμοποιώντας τη δημόσια διεύθυνση IP η οποία παρέχεται από το <code>0/32</code>. Το NAT δημιουργεί μια καταχώριση στον εσωτερικό του πίνακα, έτσι ώστε όταν επιστρέψει η απάντηση από το Internet, να μπορεί να αντιστοιχηθεί ξανά στην αρχική ιδιωτική διεύθυνση IP και να περάσει έπειτα από τους κανόνες του φίλτρου για περαιτέρω επεξεργασία.</p></div></div><div class=sect3><h4 id=_ενεργοποιώντας_το_ipnat>55.5.18. Ενεργοποιώντας το IPNAT<a class=anchor href=#_ενεργοποιώντας_το_ipnat></a></h4><div class=paragraph><p>Για να ενεργοποιήσετε το IPNAT, προσθέστε τις παρακάτω γραμμές στο <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Για να επιτρέψετε στο μηχάνημα σας να δρομολογεί πακέτα μεταξύ διεπαφών δικτύου:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Για να ξεκινάει αυτόματα το IPNAT σε κάθε εκκίνηση:</p></div><div class="literalblock programlisting"><div class=content><pre>ipnat_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Για να καθορίσετε από που επιθυμείτε να φορτώνονται οι κανόνες του IPNAT:</p></div><div class="literalblock programlisting"><div class=content><pre>ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre></div></div></div><div class=sect3><h4 id=_το_nat_σε_ένα_μεγάλο_τοπικό_δίκτυο>55.5.19. Το NAT σε Ένα Μεγάλο Τοπικό Δίκτυο<a class=anchor href=#_το_nat_σε_ένα_μεγάλο_τοπικό_δίκτυο></a></h4><div class=paragraph><p>Για τοπικά δίκτυα με μεγάλο αριθμό υπολογιστών, ή για δίκτυα που διασυνδέουν περισσότερα από ένα LAN, η διαδικασία της μετατροπής όλων αυτών των ιδιωτικών διευθύνσεων σε μια μοναδική δημόσια διεύθυνση, δημιουργεί πρόβλημα κατανομής πόρων, καθώς χρησιμοποιούνται πολλές φορές οι ίδιοι αριθμοί θυρών, οδηγώντας τα PC του δικτύου σε συγκρούσεις. Υπάρχουν δύο τρόποι για να ελαττώσουμε αυτό το πρόβλημα.</p></div><div class=sect4><h5 id=_ανάθεση_των_θυρών_που_θα_χρησιμοποιηθούν>55.5.19.1. Ανάθεση των θυρών που θα Χρησιμοποιηθούν<a class=anchor href=#_ανάθεση_των_θυρών_που_θα_χρησιμοποιηθούν></a></h5><div class=paragraph><p>Ένα συνηθισμένος κανόνας NAT μοιάζει με τον παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32</pre></div></div><div class=paragraph><p>Στον παραπάνω κανόνα, η θύρα αφετηρίας του πακέτου παραμένει αναλλοίωτη καθώς το πακέτο διέρχεται μέσω του IPNAT. Αν προσθέσετε την λέξη-κλειδί <code>portmap</code>, μπορείτε να ρυθμίσετε το IPNAT να χρησιμοποιεί θύρες που ανήκουν σε μια καθορισμένη περιοχή. Για παράδειγμα, ο παρακάτω κανόνας θα οδηγήσει το NAT να τροποποιήσει την θύρα της αφετηρίας, ώστε να είναι μέσα στην περιοχή που φαίνεται:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre></div></div><div class=paragraph><p>Μπορούμε επίσης να απλοποιήσουμε ακόμα περισσότερο τη διαδικασία χρησιμοποιώντας τη λέξη <code>auto</code> ώστε το IPNAT να καθορίζει από μόνο του ποιες θύρες είναι διαθέσιμες για χρήση:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div></div></div><div class=sect4><h5 id=_χρησιμοποιώντας_ένα_απόθεμα_δυναμικών_διευθύνσεων>55.5.19.2. Χρησιμοποιώντας ένα Απόθεμα Δυναμικών Διευθύνσεων<a class=anchor href=#_χρησιμοποιώντας_ένα_απόθεμα_δυναμικών_διευθύνσεων></a></h5><div class=paragraph><p>Σε ένα πολύ μεγάλο τοπικό δίκτυο, αργά ή γρήγορα φτάνουμε στο σημείο που μια μοναδική δημόσια διεύθυνση δεν επαρκεί για να καλύψει τόσες πολλές ιδιωτικές. Αν υπάρχει διαθέσιμο ένα εύρος δημοσίων διευθύνσεων, μπορούν να χρησιμοποιηθούν ως "απόθεμα (pool)", επιτρέποντας στην IPNAT να επιλέξει μια από αυτές καθώς αντιστοιχεί τα πακέτα κατά την έξοδο τους προς το δημόσιο δίκτυο.</p></div><div class=paragraph><p>Για παράδειγμα, αντί να αντιστοιχούν όλα τα πακέτα μέσω μιας μοναδικής δημόσιας IP διεύθυνσης όπως παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.1</pre></div></div><div class=paragraph><p>μπορούμε να χρησιμοποιήσουμε ένα εύρος IP διευθύνσεων, είτε με τη χρήση μάσκας δικτύου:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</pre></div></div><div class=paragraph><p>είτε με συμβολισμό CIDR:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div></div></div><div class=sect3><h4 id=_ανακατεύθυνση_θυρών>55.5.20. Ανακατεύθυνση Θυρών<a class=anchor href=#_ανακατεύθυνση_θυρών></a></h4><div class=paragraph><p>Είναι κοινή πρακτική να εγκαθίστανται υπηρεσίες όπως ο εξυπηρετητής ιστοσελίδων, ταχυδρομείου, βάσης δεδομένων και DNS σε διαφορετικά PC στο τοπικό δίκτυο. Στην περίπτωση αυτή, η κίνηση πακέτων από αυτά τα μηχανήματα εξακολουθεί να χρειάζεται το NAT, αλλά χρειάζεται επίσης να υπάρχει κάποιος τρόπος να κατευθύνεται η εισερχόμενη κίνηση στα σωστά PC του δικτύου. Το IPNAT έχει τις κατάλληλες δυνατότητες για την επίλυση αυτού του προβλήματος. Για παράδειγμα, έστω ότι ένας εξυπηρετητής ιστοσελίδων βρίσκεται στην διεύθυνση LAN <code>10.0.10.25</code> και η μοναδική δημόσια IP είναι <code>20.20.20.5</code>. Ο κανόνας που θα γράφατε θα έμοιαζε με τον παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>ή:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>ή για ένα εξυπηρετητή DNS με διεύθυνση στο τοπικό δίκτυο <code>10.0.10.33</code> ο οποίος πρέπει να δέχεται αναζητήσεις από το δημόσιο δίκτυο:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</pre></div></div></div><div class=sect3><h4 id=_ftp_και_nat>55.5.21. FTP και NAT<a class=anchor href=#_ftp_και_nat></a></h4><div class=paragraph><p>Το FTP είναι ένας δεινόσαυρος που έχει απομείνει από την εποχή που το Internet ήταν στα αρχικά του στάδια, όπου τα ερευνητικά εργαστήρια των πανεπιστήμιων ήταν συνδεμένα μεταξύ τους με μισθωμένες γραμμές και οι ερευνητές το χρησιμοποιούσαν για να στέλνουν αρχεία ο ένας στον άλλο. Την εποχή εκείνη, δεν υπήρχαν ανησυχίες σχετικά με την ασφάλεια. Με το πέρασμα του χρόνου, το FTP θάφτηκε στο πίσω μέρος του ταχέως εξελισσόμενου Internet. Δεν εξελίχθηκε ποτέ ώστε να ξεπεράσει προβλήματα ασφάλειας, όπως π.χ. το γεγονός ότι στέλνει το όνομα και τον κωδικό του χρήστη ως απλό κείμενο. Το FTP έχει δυο καταστάσεις λειτουργίας, την ενεργή και την παθητική. Η διαφορά είναι στο πως γίνεται η ανάκτηση του καναλιού δεδομένων. Η παθητική λειτουργία είναι πιο ασφαλής, καθώς το κανάλι δεδομένων αποτελεί το κύριο κανάλι της συνεδρίας. Μπορείτε να βρείτε πολύ καλή περιγραφή του πρωτοκόλλου και των διαφορετικών τρόπων λειτουργίας του, στο <a href=http://www.slacksite.com/other/ftp.html>http://www.slacksite.com/other/ftp.html</a>.</p></div><div class=sect4><h5 id=_κανόνες_του_ipnat_2>55.5.21.1. Κανόνες του IPNAT<a class=anchor href=#_κανόνες_του_ipnat_2></a></h5><div class=paragraph><p>Το IPNAT διαθέτει μια ειδική επιλογή για διαμεσολάβηση FTP (proxy) η οποία μπορεί να καθοριστεί στον κατάλληλο κανόνα του NAT. Μπορεί να παρακολουθήσει όλα τα εξερχόμενα πακέτα για να ανιχνεύσει την έναρξη μιας ενεργής ή παθητικής συνεδρίας FTP, και να δημιουργήσει δυναμικά προσωρινούς κανόνες στο φίλτρο που να περιέχουν μόνο τον αριθμό της θύρας που χρησιμοποιείται από το κανάλι δεδομένων. Αυτό εξαλείφει το πρόβλημα ασφάλειας που δημιουργείται από το γεγονός ότι διαφορετικά θα χρειαζόταν να ανοιχθεί μια μεγάλη περιοχή θυρών (στην υψηλή περιοχή) στο firewall.</p></div><div class=paragraph><p>Ο παρακάτω κανόνας χειρίζεται όλα τα δεδομένα για το εσωτερικό δίκτυο (LAN):</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</pre></div></div><div class=paragraph><p>Ο παρακάτω κανόνας χειρίζεται την κίνηση FTP από την πύλη (gateway):</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</pre></div></div><div class=paragraph><p>Ο παρακάτω κανόνας χειρίζεται όλη την κίνηση από το εσωτερικό LAN που δεν ανήκει στο πρωτόκολλο FTP:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32</pre></div></div><div class=paragraph><p>Ο κανόνας χαρτογράφησης του FTP τοποθετείται πριν από τον κανονικό κανόνα χαρτογράφησης. Κάθε πακέτο ελέγχεται αρχικά από τον κανόνα που βρίσκεται στην κορυφή. Αν ταιριάζει στη διεπαφή και στην ιδιωτική διεύθυνση IP και πρόκειται για πακέτο FTP, ο διαμεσολαβητής FTP δημιουργεί προσωρινούς κανόνες στο φίλτρο οι οποίοι επιτρέπουν την εισερχόμενη και εξερχόμενη κίνηση FTP ενώ ταυτόχρονα εκτελούν και την απαραίτητη μετάφραση NAT. Όλα τα πακέτα που δεν ανήκουν σε μετάδοση FTP δεν ταιριάζουν με τον πρώτο κανόνα, έτσι κατευθύνονται στον τρίτο κανόνα, εξετάζονται όσο αφορά τη διεπαφή και το IP από το οποίο προέρχονται, και γίνεται η αντίστοιχη μετάφραση τους από το NAT.</p></div></div><div class=sect4><h5 id=_κανόνες_φίλτρου_για_το_ipnat>55.5.21.2. Κανόνες Φίλτρου για το IPNAT<a class=anchor href=#_κανόνες_φίλτρου_για_το_ipnat></a></h5><div class=paragraph><p>Όταν χρησιμοποιείται ο μεσολαβητής FTP, χρειάζεται μόνο ένας κανόνας για το NAT.</p></div><div class=paragraph><p>Χωρίς το μεσολαβητή FTP, χρειάζονται οι παρακάτω τρεις κανόνες:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div></div></div></div></div><div class=sect2><h3 id=firewalls-ipfw>55.6. IPFW<a class=anchor href=#firewalls-ipfw></a></h3><div class=paragraph><p>Το IPFIREWALL (IPFW) είναι λογισμικό που αναπτύχθηκε για το FreeBSD. Έχει γραφεί και συντηρείται από εθελοντές που ανήκουν στο Project. Χρησιμοποιεί τους κλασικούς κανόνες χωρίς διατήρηση της κατάστασης (stateless) καθώς και μια τεχνική κωδικοποίησης που επιτυγχάνει αυτό που αναφέρεται ως Απλή Stateful Λογική (Simple Stateful Logic).</p></div><div class=paragraph><p>Το υπόδειγμα κανόνων για το IPFW (στα αρχεία <span class=filename>/etc/rc.firewall</span> και <span class=filename>/etc/rc.firewall6</span>) της τυπικής εγκατάστασης του FreeBSD είναι μάλλον απλό και θα χρειαστεί να κάνετε κάποιες αλλαγές πριν το χρησιμοποιήσετε. Το παράδειγμα δεν χρησιμοποιεί φιλτράρισμα τύπου stateful. Η stateful λειτουργία είναι ευεργετική στις περισσότερες περιπτώσεις, έτσι δεν θα χρησιμοποιήσουμε αυτό το παράδειγμα ως βάση αυτής της ενότητας.</p></div><div class=paragraph><p>Η σύνταξη των κανόνων stateless του IPFW έχει ενισχυθεί με εξελιγμένες δυνατότητες επιλογής οι οποίες συνήθως ξεπερνάνε κατά πολύ τις τυπικές γνώσεις του ατόμου που καλείται να το ρυθμίσει. Το IPFW απευθύνεται στον επαγγελματία χρήστη ή τον τεχνικά προχωρημένο χομπίστα, ο οποίος έχει ανάγκη προχωρημένου φιλτραρίσματος πακέτων. Η πραγματική δύναμη των κανόνων του IPFW αποκαλύπτεται μόνο αν διαθέτετε προχωρημένες γνώσεις σχετικά με το πως διαφορετικά πρωτόκολλα δημιουργούν και χρησιμοποιούν την επικεφαλίδα των πακέτων τους. Τέτοιο επίπεδο επεξηγήσεων είναι πέρα από το σκοπό αυτής της ενότητας του Εγχειριδίου.</p></div><div class=paragraph><p>Το IPFW αποτελείται από επτά εξαρτήματα. Το βασικό εξάρτημα είναι ο επεξεργαστής κανόνων του firewall στον πυρήνα, με ενσωματωμένη τη δυνατότητα καταγραφής. Τα υπόλοιπα εξαρτήματα είναι το σύστημα καταγραφής (logging), ο κανόνας <code>divert</code> ο οποίος ενεργοποιεί τη λειτουργία NAT, καθώς και οι προχωρημένες δυνατότητες ειδικού σκοπού: το σύστημα διαμόρφωσης κίνησης (traffic shaper) dummynet, η δυνατότητα προώθησης μέσω του <code>fwd rule</code>, η δυνατότητα γεφύρωσης (bridge) καθώς και η δυνατότητα απόκρυψης (ipstealth). To IPFW υποστηρίζει τόσο το πρωτόκολλο IPv4 όσο και το IPv6.</p></div><div class=sect3><h4 id=firewalls-ipfw-enable>55.6.1. Ενεργοποιώντας το IPFW<a class=anchor href=#firewalls-ipfw-enable></a></h4><div class=paragraph><p>Το IPFW περιλαμβάνεται στην βασική εγκατάσταση του FreeBSD ως άρθρωμα του πυρήνα το οποίο μπορεί να φορτωθεί δυναμικά. Το σύστημα θα φορτώσει δυναμικά το άρθρωμα όταν βρει την καταχώριση <code>firewall_enable="YES"</code> στο αρχείο <span class=filename>/etc/rc.conf</span>. Δεν χρειάζεται να μεταγλωττίσετε το IPFW μέσα στον πυρήνα.</p></div><div class=paragraph><p>Αφού επανεκκινήσετε το σύστημα σας με την καταχώριση <code>firewall_enable="YES"</code> στο <span class=filename>rc.conf</span>, θα δείτε με άσπρα έντονα γράμματα το ακόλουθο μήνυμα κατά τη διαδικασία της εκκίνησης:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ipfw2 initialized, divert disabled, rule-based forwarding disabled, default to deny, logging disabled</code></pre></div></div><div class=paragraph><p>Το άρθρωμα έχει ενσωματωμένη τη δυνατότητα καταγραφής. Για να ενεργοποιήσετε την καταγραφή και να θέσετε το επίπεδο λεπτομέρειας, υπάρχουν κάποιες ρυθμίσεις που μπορείτε να θέσετε στο <span class=filename>/etc/sysctl.conf</span>. Προσθέτοντας τις παρακάτω καταχωρίσεις, θα ενεργοποιηθεί η καταγραφή στις επόμενες εκκινήσεις:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.verbose=1
net.inet.ip.fw.verbose_limit=5</pre></div></div></div><div class=sect3><h4 id=firewalls-ipfw-kernel>55.6.2. Επιλογές του Πυρήνα<a class=anchor href=#firewalls-ipfw-kernel></a></h4><div class=paragraph><p>Δεν είναι υποχρεωτικό να ενεργοποιήσετε το IPFW μεταγλωττίζοντας τις παρακάτω επιλογές στον πυρήνα του FreeBSD. Ο σκοπός αυτής της παρουσίασης είναι καθαρά ενημερωτικός.</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL</pre></div></div><div class=paragraph><p>Η επιλογή αυτή ενεργοποιεί το IPFW ως μέρος του πυρήνα.</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL_VERBOSE</pre></div></div><div class=paragraph><p>Ενεργοποιεί την καταγραφή των πακέτων που περνούν μέσω του IPFW και περιλαμβάνουν τη λέξη <code>log</code> στον κανόνα τους.</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL_VERBOSE_LIMIT=5</pre></div></div><div class=paragraph><p>Περιορίζει τον πλήθος των πακέτων που καταγράφονται μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> σε συγκεκριμένο αριθμό ανά καταχώριση. Η ρύθμιση είναι χρήσιμη σε εχθρικά περιβάλλοντα στα οποία είναι επιθυμητή η καταγραφή. Με αυτό τον τρόπο μπορεί να αποφευχθεί μια πιθανή επίθεση με στόχο την υπερχείλιση των αρχείων καταγραφής.</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL_DEFAULT_TO_ACCEPT</pre></div></div><div class=paragraph><p>Η επιλογή αυτή αφήνει τα πάντα να περνάνε μέσα από το firewall, το οποίο είναι καλή ιδέα την πρώτη φορά που ρυθμίζετε το firewall σας.</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPDIVERT</pre></div></div><div class=paragraph><p>Η επιλογή αυτή ενεργοποιεί τη λειτουργία NAT.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το firewall θα απορρίπτει όλα τα πακέτα που κατευθύνονται από και προς το μηχάνημα, αν δεν περιλάβετε την επιλογή <code>IPFIREWALL_DEFAULT_TO_ACCEPT</code> ή αν δεν ρυθμίσετε ένα κατάλληλο κανόνα που να επιτρέπει αυτές τις συνδέσεις.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=firewalls-ipfw-rc>55.6.3. Επιλογές στο <span class=filename>/etc/rc.conf</span><a class=anchor href=#firewalls-ipfw-rc></a></h4><div class=paragraph><p>Ενεργοποιήστε το firewall:</p></div><div class="literalblock programlisting"><div class=content><pre>firewall_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Για να επιλέξετε ένα από τους προεπιλεγμένους τύπους firewall που υποστηρίζονται από το FreeBSD, διαβάστε το αρχείο <span class=filename>/etc/rc.firewall</span> και δημιουργήστε μια εγγραφή όπως την παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>firewall_type=&#34;open&#34;</pre></div></div><div class=paragraph><p>Οι διαθέσιμες τιμές για αυτή τη ρύθμιση είναι:</p></div><div class=ulist><ul><li><p><code>open</code> - επιτρέπει τη διέλευση όλης της κίνησης.</p></li><li><p><code>client</code> - προστατεύει μόνο το συγκεκριμένο μηχάνημα.</p></li><li><p><code>simple</code> - προστατεύει ολόκληρο το δίκτυο.</p></li><li><p><code>closed</code> - απενεργοποιεί εντελώς την κίνηση πακέτων, εκτός από την εσωτερική διεπαφή (loopback).</p></li><li><p><code>UNKNOWN</code> - απενεργοποιεί την φόρτωση κανόνων του firewall.</p></li><li><p><span class=filename>filename</span> - το πλήρες μονοπάτι του αρχείου που περιέχει τους κανόνες του firewall.</p></li></ul></div><div class=paragraph><p>Μπορείτε να χρησιμοποιήσετε δύο διαφορετικούς τρόπους για να φορτώσετε προσαρμοσμένους κανόνες στο ipfw firewall. Ο ένας είναι θέτοντας τη μεταβλητή <code>firewall_type</code> στην απόλυτη διαδρομή του αρχείου που περιέχει τους <em>κανόνες του firewall</em>, χωρίς να δώσετε ορίσματα στην γραμμή εντολών για το ίδιο το <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Το αρχείο κανόνων που φαίνεται παρακάτω, απορρίπτει όλη την εισερχόμενη και εξερχόμενη κίνηση:</p></div><div class="literalblock programlisting"><div class=content><pre>add deny in
add deny out</pre></div></div><div class=paragraph><p>Από την άλλη μεριά, είναι επίσης δυνατό να θέσετε τη μεταβλητή <code>firewall_script</code> στην απόλυτη διαδρομή ενός εκτελέσιμου script που περιλαμβάνει μια σειρά από εντολές <code>ipfw</code> που θα εκτελεστούν κατά την εκκίνηση. Ένα έγκυρο τέτοιο script το οποίο είναι αντίστοιχο με το αρχείο κανόνων που δείξαμε παραπάνω, είναι το ακόλουθο:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

ipfw -q flush

ipfw add deny in
ipfw add deny out</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν θέσετε την τιμή του <code>firewall_type</code> είτε σε <code>client</code> είτε σε <code>simple</code>, θα πρέπει να ελέγξετε ότι οι προεπιλεγμένοι κανόνες που περιέχονται στο <span class=filename>/etc/rc.firewall</span> ταιριάζουν με τις ρυθμίσεις του συγκεκριμένου μηχανήματος. Παρατηρήστε επίσης ότι τα παραδείγματα που χρησιμοποιούνται σε αυτό το κεφάλαιο αναμένουν να να έχετε θέσει τη μεταβλητή <code>firewall_script</code> στην τιμή <span class=filename>/etc/ipfw.rules</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ενεργοποιήστε την καταγραφή:</p></div><div class="literalblock programlisting"><div class=content><pre>firewall_logging=&#34;YES&#34;</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Το μόνο πράγμα που κάνει η μεταβλητή <code>firewall_logging</code> είναι να θέσει την τιμή της μεταβλητής sysctl <code>net.inet.ip.fw.verbose</code> στην τιμή <code>1</code> (δείτε το <a href=#firewalls-ipfw-enable>Ενεργοποιώντας το IPFW</a>). Δεν υπάρχει μεταβλητή του <span class=filename>rc.conf</span> που να ορίζει περιορισμούς στην καταγραφή, αλλά αυτό μπορεί να ρυθμιστεί μέσω της παραπάνω μεταβλητής sysctl είτε χειροκίνητα, είτε μέσω του αρχείου <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.verbose_limit=5</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Αν το μηχάνημα σας λειτουργεί ως πύλη (gateway), δηλαδή παρέχει υπηρεσία μετάφρασης διευθύνσεων δικτύου (Network Address Translation, NAT) μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, παρακαλούμε να διαβάσετε το <a href=./#network-natd>Network Address Translation</a> για πληροφορίες σχετικά με τις ρυθμίσεις που απαιτούνται στο αρχείο <span class=filename>/etc/rc.conf</span>.</p></div></div><div class=sect3><h4 id=firewalls-ipfw-cmd>55.6.4. Η Εντολή IPFW<a class=anchor href=#firewalls-ipfw-cmd></a></h4><div class=paragraph><p>Η εντολή <code>ipfw</code> είναι ο συνήθης τρόπος για την προσθήκη η διαγραφή κανόνων στους εσωτερικούς ενεργούς κανόνες του firewall, καθώς αυτό εκτελείται. Το πρόβλημα με τη χρήση αυτής της μεθόδου είναι ότι οι αλλαγές χάνονται με τον τερματισμό λειτουργίας του μηχανήματος. Μπορείτε να γράψετε όλους τους κανόνες σας σε ένα αρχείο και να το χρησιμοποιείτε για να τους φορτώνετε στην εκκίνηση. Μπορείτε να χρησιμοποιήσετε το ίδιο αρχείο για να αντικαταστήσετε τους τρέχοντες κανόνες του firewall, την ώρα που αυτό εκτελείται. Αυτός είναι και ο συνιστώμενος τρόπος που χρησιμοποιούμε στα παραδείγματα μας.</p></div><div class=paragraph><p>Η εντολή <code>ipfw</code> είναι επίσης χρήσιμη για να απεικονίζει τους τρέχοντες κανόνες στη κονσόλα σας. Το σύστημα καταγραφής χρήσης της IPFW δημιουργεί αυτόματα ένα μετρητή για κάθε κανόνα, ο οποίος μετράει πόσα πακέτα ταίριαξαν με αυτόν. Κατά τη διάρκεια των δοκιμών, η δυνατότητα να ελέγξετε την τιμή του μετρητή είναι ένας τρόπος για να διαπιστώσετε αν ο κανόνας λειτουργεί κανονικά.</p></div><div class=paragraph><p>Για να δείτε όλους τους κανόνες με τη σειρά:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw list</span></code></pre></div></div><div class=paragraph><p>Για να δείτε μια λίστα όλων των κανόνων, μαζί με την ώρα που ενεργοποιήθηκε τελευταία φορά ο κάθε κανόνας, γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -t list</span></code></pre></div></div><div class=paragraph><p>Το επόμενο παράδειγμα δείχνει τον αριθμό των πακέτων που ταίριαξαν μαζί με τον αντίστοιχο κανόνα. Η πρώτη στήλη δείχνει τον αριθμό του κανόνα, ακολουθείται από τον αριθμό πακέτων που ταίριαξαν (πρώτα τα εξερχόμενα και μετά τα εισερχόμενα) και τέλος από τον ίδιο τον κανόνα.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -a list</span></code></pre></div></div><div class=paragraph><p>Για να δείτε μια λίστα που να περιλαμβάνει τόσο τους δυναμικούς όσο και τους στατικούς κανόνες:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d list</span></code></pre></div></div><div class=paragraph><p>Για να δείτε και τους δυναμικούς κανόνες που έχουν λήξει:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d -e list</span></code></pre></div></div><div class=paragraph><p>Για να μηδενίσετε τους μετρητές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero</span></code></pre></div></div><div class=paragraph><p>Για να μηδενίσετε τους μετρητές μόνο για τον κανόνα με τον αριθμό <em>NUM</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero NUM</span></code></pre></div></div></div><div class=sect3><h4 id=firewalls-ipfw-rules>55.6.5. Το Σύνολο Κανόνων του IPFW<a class=anchor href=#firewalls-ipfw-rules></a></h4><div class=paragraph><p>Ως "σύνολο κανόνων" στο IPFW, ορίζουμε μια ομάδα κανόνων που έχουν γραφεί για να επιτρέπουν ή να απορρίπτουν πακέτα ανάλογα με τις τιμές που περιέχονται σε αυτά. Η διπλής κατεύθυνσης ανταλλαγή πακέτων μεταξύ υπολογιστών αποτελεί μια συνεδρία. Το σύνολο κανόνων του firewall επεξεργάζεται τόσο τα πακέτα που έρχονται από το Internet, όσο και τα πακέτα που παράγονται από το σύστημα ως απάντηση σε αυτά. Κάθε υπηρεσία TCP/IP (π.χ. telnet, www, mail, κ.λ.π.) καθορίζεται από το πρωτόκολλο και την προνομιακή (privileged) θύρα που χρησιμοποιεί για να δέχεται αιτήματα εξυπηρέτησης. Τα πακέτα που προορίζονται για μια συγκεκριμένη υπηρεσία, ξεκινούν από τη διεύθυνση αφετηρίας χρησιμοποιώντας μια μη-προνομιακή θύρα και καταλήγουν στη συγκεκριμένη θύρα υπηρεσίας στον προορισμό. Όλες οι παραπάνω παράμετροι (θύρες και διευθύνσεις) μπορούν να χρησιμοποιηθούν ως κριτήρια επιλογής για την δημιουργία κανόνων που επιτρέπουν ή εμποδίζουν την πρόσβαση σε υπηρεσίες.</p></div><div class=paragraph><p>Όταν ένα πακέτο εισέρχεται στο firewall, συγκρίνεται με βάση τον πρώτο κανόνα. Η σύγκριση συνεχίζεται διαδοχικά με τους υπόλοιπους κανόνες, από τον πρώτο προς τον τελευταίο, με βάση τον αύξοντα αριθμό τους. Όταν το πακέτο ταιριάξει με τις παραμέτρους επιλογής κάποιου κανόνα, εκτελείται η οδηγία που αναφέρεται στο πεδίο ενεργειών του κανόνα αυτού και η αναζήτηση κανόνων για το συγκεκριμένο πακέτο τερματίζεται. Σε αυτή τη μέθοδο αναζήτησης, "ο πρώτος κανόνας που ταιριάζει, είναι ο νικητής". Αν το πακέτο δεν ταιριάζει με κανένα από τους κανόνες, θα ληφθεί από τον υποχρεωτικό προεπιλεγμένο κανόνα του IPFW, με αριθμό 65535, ο οποίος εμποδίζει τη διέλευση όλων των πακέτων, και τα απορρίπτει χωρίς να στείλει καμιά απάντηση στον αρχικό αποστολέα τους.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η αναζήτηση συνεχίζεται μετά από κανόνες τύπου <code>count</code>, <code>skipto</code> και <code>tee</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Οι οδηγίες που φαίνονται εδώ, βασίζονται στη χρήση κανόνων που περιέχουν τις οδηγίες <code>keep state</code>, <code>limit</code>, <code>in</code>, <code>out</code> και <code>via</code>. Αυτές είναι και οι βασικές λειτουργίες για την δόμηση ενός firewall τύπου inclusive με stateful λειτουργία.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Να δίνετε μεγάλη προσοχή όταν δουλεύετε με τους κανόνες ενός firewall. Μπορεί άθελα σας να κλειδωθείτε έξω από το σύστημα σας.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=firewalls-ipfw-rules-syntax>55.6.5.1. Σύνταξη Κανόνων<a class=anchor href=#firewalls-ipfw-rules-syntax></a></h5><div class=paragraph><p>Στην ενότητα αυτή, θα παρουσιάσουμε μια απλοποιημένη σύνταξη κανόνων. Δείχνουμε μόνο ότι χρειάζεται για να δημιουργηθεί ένα τυποποιημένο σύνολο κανόνων για ένα inclusive firewall. Για πλήρη περιγραφή, δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=paragraph><p>Οι κανόνες περιέχουν λέξεις-κλειδιά. Οι λέξεις αυτές θα πρέπει να κωδικοποιηθούν με συγκεκριμένη σειρά από τα αριστερά προς τα δεξιά της γραμμής. Οι λέξεις-κλειδιά φαίνονται παρακάτω με έντονα γράμματα. Μερικές λέξεις έχουν υπο-επιλογές οι οποίες μπορεί να είναι επίσης λέξεις-κλειδιά και να περιλαμβάνουν επίσης ακόμα περισσότερες υπο-επιλογές.</p></div><div class=paragraph><p>Η αρχή ενός σχολίου, σηματοδοτείται με το σύμβολο <code>#</code>, το οποίο μπορεί να εμφανίζεται στο τέλος μιας γραμμής κανόνα, ή και σε μια δική του γραμμή. Οι κενές γραμμές αγνοούνται.</p></div><div class=paragraph><p><code><em>CMD RULE_NUMBER ACTION LOGGING SELECTION STATEFUL</em></code></p></div><div class=sect5><h6 id=_cmd>55.6.5.1.1. CMD<a class=anchor href=#_cmd></a></h6><div class=paragraph><p>Για να γίνει η προσθήκη ενός νέου κανόνα στον εσωτερικό πίνακα, τοποθετείται μπροστά από αυτόν η παράμετρος <span class=parameter>add</span>.</p></div></div><div class=sect5><h6 id=_rule_number>55.6.5.1.2. RULE_NUMBER<a class=anchor href=#_rule_number></a></h6><div class=paragraph><p>Κάθε κανόνας σχετίζεται με ένα αριθμό κανόνα (rule_number) στην περιοχή 1..65535.</p></div></div><div class=sect5><h6 id=_action_2>55.6.5.1.3. ACTION<a class=anchor href=#_action_2></a></h6><div class=paragraph><p>Ένας κανόνας μπορεί να σχετίζεται με μια ή περισσότερες ενέργειες, οι οποίες εκτελούνται όταν το πακέτο ταιριάζει με τα κριτήρια επιλογής αυτού του κανόνα.</p></div><div class=paragraph><p><span class=parameter>allow | accept | pass | permit</span></p></div><div class=paragraph><p>Όλα τα παραπάνω έχουν το ίδιο αποτέλεσμα: το πακέτο εξέρχεται από την σύστημα του firewall. Η αναζήτηση για το συγκεκριμένο πακέτο τερματίζεται σε αυτό τον κανόνα.</p></div><div class=paragraph><p><span class=parameter>check-state</span></p></div><div class=paragraph><p>Ελέγχει το πακέτο με βάση το δυναμικό πίνακα κανόνων. Αν βρεθεί κανόνας που να ταιριάζει, θα εκτελεστεί η ενέργεια του κανόνα ο οποίος δημιούργησε τον συγκεκριμένο δυναμικό κανόνα. Διαφορετικά, η αναζήτηση συνεχίζεται με τον επόμενο κανόνα. Ένας κανόνας check-state δεν έχει κριτήρια επιλογής. Αν δεν υπάρχει κανόνας check-state στο σύνολο κανόνων, ο έλεγχος του πίνακα δυναμικών κανόνων ξεκινάει από τον πρώτο κανόνα τύπου keep-state ή limit.</p></div><div class=paragraph><p><span class=parameter>deny | drop</span></p></div><div class=paragraph><p>Και οι δύο λέξεις σημαίνουν το ίδιο πράγμα: τα πακέτα που ταιριάζουν με αυτό τον κανόνα απορρίπτονται. Η αναζήτηση τερματίζεται.</p></div></div><div class=sect5><h6 id=_καταγραφή>55.6.5.1.4. Καταγραφή<a class=anchor href=#_καταγραφή></a></h6><div class=paragraph><p><span class=parameter>log</span> ή <span class=parameter>logamount</span></p></div><div class=paragraph><p>Όταν ένα πακέτο ταιριάζει με ένα κανόνα που περιέχει τη λέξη <code>log</code>, γίνεται καταγραφή του μηνύματος μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> στη δυνατότητα SECURITY. Η καταγραφή συμβαίνει μόνο αν ο αριθμός των πακέτων που έχει καταγραφεί μέχρι στιγμής δεν υπερβαίνει την παράμετρο <code>logamount</code>. Αν η παράμετρος αυτή δεν έχει καθοριστεί, το όριο ρυθμίζεται με βάση την τιμή της μεταβλητής sysctl <code>net.inet.ip.fw.verbose_limit</code>. Και στις δύο περιπτώσεις, μια μηδενική τιμή σημαίνει ότι δεν θα υπάρχει όριο στην καταγραφή. Μόλις η καταγραφή φτάσει στο όριο, μπορεί να γίνει επανενεργοποίηση της με το μηδενισμό του μετρητή καταγραφής, ή του μετρητή για το συγκεκριμένο κανόνα. Δείτε την εντολή <code>ipfw reset log</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η καταγραφή γίνεται μόνο αφού επαληθευθούν όλες οι άλλες συνθήκες ταιριάσματος του πακέτου, και πριν την τελική αποδοχή ή απόρριψη του. Είναι στη δική σας ευχέρεια να αποφασίσετε σε ποιους κανόνες θα ενεργοποιήσετε την καταγραφή.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_επιλογή>55.6.5.1.5. Επιλογή<a class=anchor href=#_επιλογή></a></h6><div class=paragraph><p>Οι λέξεις-κλειδιά που περιγράφονται σε αυτή την ενότητα, χρησιμοποιούνται για να περιγράψουν χαρακτηριστικά του πακέτου που θα πρέπει να διερευνηθούν για να καθοριστεί αν το πακέτο ταιριάζει ή όχι με τον κανόνα. Η επιλογή μπορεί να γίνει με βάση τα παρακάτω γενικής φύσεως χαρακτηριστικά, τα οποία και θα πρέπει να χρησιμοποιηθούν με τη σειρά που φαίνονται:</p></div><div class=paragraph><p><span class=parameter>udp | tcp | icmp</span></p></div><div class=paragraph><p>Μπορούν επίσης να χρησιμοποιηθούν τα πρωτόκολλα που περιέχονται στο αρχείο <span class=filename>/etc/protocols</span>. Η τιμή που καθορίζεται χρησιμοποιείται για το ταίριασμα του πρωτοκόλλου. Πρόκειται για υποχρεωτική παράμετρο.</p></div><div class=paragraph><p><span class=parameter>from src to dst</span></p></div><div class=paragraph><p>Οι λέξεις <code>from</code> και <code>to</code> χρησιμοποιούνται για το ταίριασμα IP διευθύνσεων. Οι κανόνες πρέπει να καθορίζουν <em>τόσο</em> την πηγή όσο και τον προορισμό. Η λέξη <code>any</code> μπορεί να χρησιμοποιηθεί για ταίριασμα με οποιαδήποτε διεύθυνση. Η λέξη <code>me</code> έχει επίσης ειδική σημασία. Ταιριάζει με οποιαδήποτε διεύθυνση που έχει ρυθμιστεί σε κάποια διεπαφή του συστήματος σας, αντιπροσωπεύοντας έτσι το PC στο οποίο εκτελείται το firewall. Μπορούν έτσι να γραφούν κανόνες του τύπου <code>from me to any</code> ή <code>from any to me</code> ή <code>from any to 0.0.0.0/0</code> ή <code>from 0.0.0.0/0 to me</code> ή <code>from any to 0.0.0.0</code> ή <code>from me to 0.0.0.0</code>. Οι διευθύνσεις IP καθορίζονται ως αριθμητικές οκτάδες χωρισμένες με τελείες και ακολουθούνται από το μήκος της μάσκας υποδικτύου. Μια IP διεύθυνση μπορεί να καθορίζεται με αριθμούς που χωρίζονται με τελείες. Μπορεί επίσης να ακολουθείται από το μέγεθος της μάσκας υποδικτύου (μορφή CIDR). Πρόκειται για υποχρεωτική παράμετρο. Μπορείτε να χρησιμοποιήσετε το βοηθητικό πρόγραμμα <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> για διευκόλυνση σας στους υπολογισμούς. Δείτε την δικτυακή τοποθεσία του προγράμματος για περισσότερες πληροφορίες: <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div><div class=paragraph><p><span class=parameter>port number</span></p></div><div class=paragraph><p>Χρησιμοποιείται σε πρωτόκολλα που υποστηρίζουν αριθμούς θυρών (όπως είναι τα TCP και UDP). Είναι υποχρεωτικό να δίνεται ο αριθμός θύρας της υπηρεσίας που θέλετε να ταιριάξετε. Μπορείτε να χρησιμοποιήσετε τα ονόματα των υπηρεσιών (μπορείτε να τα βρείτε στο αρχείο <span class=filename>/etc/services</span>) αντί για τους κανονικούς αριθμούς θυρών.</p></div><div class=paragraph><p><span class=parameter>in | out</span></p></div><div class=paragraph><p>Με το παραπάνω μπορεί να καθοριστεί αν το ταίριασμα θα γίνεται σε εισερχόμενα ή σε εξερχόμενα πακέτα αντίστοιχα. Είναι υποχρεωτικό να έχετε ως μέρος των κριτηρίων του κανόνα σας, είτε τη λέξη <code>in</code> είτε τη λέξη <code>out</code>.</p></div><div class=paragraph><p><span class=parameter>via IF</span></p></div><div class=paragraph><p>Ταιριάζει τα πακέτα τα οποία διέρχονται μέσω της διεπαφής με το όνομα που καθορίζεται. Η λέξη <code>via</code> εξασφαλίζει ότι το όνομα της διεπαφής θα είναι πάντα μέρος των κριτηρίων κατά τη διαδικασία ταιριάσματος.</p></div><div class=paragraph><p><span class=parameter>setup</span></p></div><div class=paragraph><p>Πρόκειται για υποχρεωτική παράμετρο που αναγνωρίζει την αίτηση έναρξης μιας συνεδρίας για πακέτα TCP.</p></div><div class=paragraph><p><span class=parameter>keep-state</span></p></div><div class=paragraph><p>Πρόκειται για υποχρεωτική παράμετρο. Μόλις υπάρξει ταίριασμα, το firewall θα δημιουργήσει ένα δυναμικό κανόνα, του οποίου η προεπιλεγμένη συμπεριφορά είναι να ταιριάζει επικοινωνία διπλής κατεύθυνσης μεταξύ της διεύθυνσης IP και της θύρας αφετηρίας και προορισμού, χρησιμοποιώντας το ίδιο πρωτόκολλο.</p></div><div class=paragraph><p><span class=parameter>limit {src-addr | src-port | dst-addr | dst-port}</span></p></div><div class=paragraph><p>Το firewall θα επιτρέψει μόνο <em>N</em> πλήθος συνδέσεων με τις παραμέτρους που περιγράφονται σε αυτό τον κανόνα. Μπορούν να καθοριστούν περισσότερες από μια διευθύνσεις και πόρτες αφετηρίας και προορισμού. Δεν μπορούν να χρησιμοποιηθούν στον ίδιο κανόνα οι παράμετροι <code>limit</code> και <code>keep-state</code>. Η επιλογή <code>limit</code> παρέχει την ίδια λειτουργία stateful με την <code>keep-state</code>, καθώς και επιπρόσθετες δικές της λειτουργίες.</p></div></div></div><div class=sect4><h5 id=_επιλογή_για_stateful_κανόνες>55.6.5.2. Επιλογή για Stateful Κανόνες<a class=anchor href=#_επιλογή_για_stateful_κανόνες></a></h5><div class=paragraph><p>Το stateful φιλτράρισμα, αντιμετωπίζει την κίνηση του δικτύου ως διπλής κατεύθυνσης ανταλλαγή πακέτων τα οποία δημιουργούν μια συνεδρία. Έχει επίσης τη δυνατότητα να διερευνήσει αν τηρούνται οι έγκυροι κανόνες ανταλλαγής μηνυμάτων μεταξύ του αποστολέα και του παραλήπτη. Οποιαδήποτε πακέτα δεν ταιριάζουν με το πρότυπο αυτής της επικοινωνίας, απορρίπτονται ως ψεύτικα.</p></div><div class=paragraph><p>Η επιλογή <code>check-state</code> χρησιμοποιείται για να αναγνωριστεί σε ποιο σημείο του συνόλου κανόνων του IPFW θα ελεγχθεί το πακέτο με βάση τη δυνατότητα των δυναμικών κανόνων. Σε περίπτωση ταιριάσματος, το πακέτο εξέρχεται από το firewall και συνεχίζει την πορεία του, ενώ την ίδια στιγμή δημιουργείται ένας νέος δυναμικός κανόνας για το επόμενο πακέτο που αναμένεται να έρθει με βάση τη συγκεκριμένη διπλής κατεύθυνσης επικοινωνία. Σε περίπτωση που το πακέτο δεν ταιριάζει με το δυναμικό κανόνα, θα προχωρήσει για να ελεγχθεί από τον επόμενο κανόνα του firewall.</p></div><div class=paragraph><p>Η δυνατότητα δυναμικών κανόνων είναι ευάλωτη σε εξάντληση πόρων σε περίπτωση επίθεσης υπερχείλισης (flood) SYN. Η επίθεση αυτή μπορεί να δημιουργήσει πολύ μεγάλο πλήθος δυναμικών κανόνων. Για την αντιμετώπιση μιας τέτοιας επίθεσης, το FreeBSD χρησιμοποιεί μια ακόμα επιλογή που ονομάζεται <code>limit</code>. Η επιλογή αυτή μπορεί να περιορίσει τον αριθμό των ταυτόχρονων συνεδριών, εξετάζοντας τα πεδία αφετηρίας και προορισμού των κανόνων. Ανιχνεύει με αυτό τον τρόπο το πλήθος των δυναμικών κανόνων και πόσες φορές έχει χρησιμοποιηθεί ο καθένας από τη συγκεκριμένη IP διεύθυνση. Αν ο αριθμός αυτός ξεπερνάει το όριο που έχει τεθεί με την επιλογή <code>limit</code>, το πακέτο απορρίπτεται.</p></div></div><div class=sect4><h5 id=_καταγραφή_μηνυμάτων_του_firewall>55.6.5.3. Καταγραφή Μηνυμάτων του Firewall<a class=anchor href=#_καταγραφή_μηνυμάτων_του_firewall></a></h5><div class=paragraph><p>Τα πλεονεκτήματα της καταγραφής συμβάντων του firewall, είναι προφανή: παρέχουν τη δυνατότητα να δείτε για ποιο λόγο ενεργοποιήθηκαν οι κανόνες στους οποίους έχετε ενεργοποιήσει την καταγραφή. Οι πληροφορίες περιλαμβάνουν τα πακέτα που απορρίφθηκαν, τις διευθύνσεις από τις οποίες προήλθαν και που κατευθύνονταν. Με αυτό τον τρόπο, έχετε ένα σημαντικό πλεονέκτημα στην ανίχνευση των εισβολέων.</p></div><div class=paragraph><p>Ακόμα και αν ενεργοποιήσετε τη λειτουργία καταγραφής, το IPFW δεν θα αρχίσει από μόνο του την καταγραφή για κανένα κανόνα. Ο διαχειριστής του firewall θα αποφασίσει σε ποιους από όλους τους κανόνες θα ενεργοποιήσει την καταγραφή, και θα προσθέσει την λέξη <code>log</code> στην αντίστοιχη καταχώριση. Φυσιολογικά, γίνεται καταγραφή μόνο για κανόνες που απορρίπτουν πακέτα (κανόνες <code>deny</code>), όπως για παράδειγμα ο κανόνας απόρριψης των εισερχόμενων ICMP pings. Είναι κοινή πρακτική, να αντιγράφεται στο τέλος των κανόνων ο κανόνας "ipfw default deny everything" και να προστίθεται σε αυτόν η επιλογή <code>log</code>. Με τον τρόπο αυτό, μπορείτε να δείτε όλα τα πακέτα που δεν ταίριαξαν με κανένα κανόνα του συνόλου.</p></div><div class=paragraph><p>Η καταγραφή συμβάντων είναι δίκοπο μαχαίρι. Αν δεν είστε προσεκτικός, θα χαθείτε μέσα στο πλήθος των δεδομένων της καταγραφής και θα γεμίσετε το δίσκο σας με άχρηστα αρχεία. Οι πιο παλιές και κοινές επιθέσεις τύπου άρνησης υπηρεσίας (DoS), είναι αυτές που προσπαθούν να γεμίσουν τους δίσκους σας. Τα μηνύματα αυτά όχι μόνο καταγράφονται στο syslogd, αλλά εμφανίζονται και στην κονσόλα του συστήματος σας, και σύντομα γίνονται πολύ ενοχλητικά.</p></div><div class=paragraph><p>Η επιλογή <code>IPFIREWALL_VERBOSE_LIMIT=5</code> στον πυρήνα, περιορίζει τον αριθμό των συνεχόμενων όμοιων μηνυμάτων που στέλνονται στον καταγραφέα συστήματος <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> σχετικά με το ταίριασμα πακέτων ενός συγκεκριμένου κανόνα. Όταν ενεργοποιείται αυτή η επιλογή στον πυρήνα, ο αριθμός των συνεχόμενων μηνυμάτων ενός συγκεκριμένου κανόνα, σταματάει μετά τον αριθμό που καθορίζεται. Δεν υπάρχει κανένα όφελος από 200 συνεχόμενα μηνύματα με το ίδιο ακριβώς περιεχόμενο. Για παράδειγμα, πέντε συνεχόμενα μηνύματα για ένα συγκεκριμένο κανόνα θα καταγράφονταν κανονικά στο syslogd. Τα υπόλοιπα όμοια μηνύματα θα καταμετρηθούν και θα καταγραφούν όπως φαίνεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>last message repeated 45 times</pre></div></div><div class=paragraph><p>Όλα τα μηνύματα καταγραφής των πακέτων, γράφονται από προεπιλογή στο αρχείο <span class=filename>/var/log/security</span> το οποίο καθορίζεται στο αρχείο <span class=filename>/etc/syslog.conf</span>.</p></div></div><div class=sect4><h5 id=firewalls-ipfw-rules-script>55.6.5.4. Δημιουργία Ενός Script Κανόνων<a class=anchor href=#firewalls-ipfw-rules-script></a></h5><div class=paragraph><p>Οι περισσότεροι έμπειροι χρήστες του IPFW, δημιουργούν ένα αρχείο που περιέχει τους κανόνες και το γράφουν με τέτοιο τρόπο ώστε να να μπορεί να εκτελεστεί ως script. Το βασικό πλεονέκτημα του παραπάνω τρόπου, είναι ότι οι κανόνες του firewall μπορούν να ανανεωθούν χωρίς την ανάγκη να επανεκκινήσει το σύστημα για να φορτωθούν οι νέοι. Η μέθοδος αυτή είναι πολύ βολική για την δοκιμή νέων κανόνων, καθώς η διαδικασία μπορεί να επαναληφθεί όσες φορές χρειάζεται. Καθώς πρόκειται για κανονικό script, μπορείτε να χρησιμοποιήσετε συμβολική υποκατάσταση για να κωδικοποιήσετε και να υποκαταστήσετε συχνά χρησιμοποιούμενες τιμές σε πολλαπλούς κανόνες. Αυτό φαίνεται στο παρακάτω παράδειγμα.</p></div><div class=paragraph><p>Η σύνταξη που χρησιμοποιείται εδώ, είναι συμβατή με τα κελύφη <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> και <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>. Μπροστά από τα πεδία της συμβολικής υποκατάστασης, υπάρχει το σήμα του δολαρίου, $. Το σύμβολο αυτό δεν υπάρχει μπροστά από τα συμβολικά πεδία. Η τιμή που θα αποδοθεί στο συμβολικό πεδίο, πρέπει να εσωκλείεται σε διπλά εισαγωγικά.</p></div><div class=paragraph><p>Ξεκινήστε το αρχείο των κανόνων σας όπως φαίνεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre></div></div><div class=paragraph><p>Αυτό είναι όλο. Στο παράδειγμα αυτό δεν είναι σημαντικοί οι κανόνες, αλλά ο τρόπος με τον οποίο λειτουργούν και παίρνουν τιμές τα πεδία συμβολικής υποκατάστασης.</p></div><div class=paragraph><p>Αν το παραπάνω παράδειγμα ήταν στο αρχείο <span class=filename>/etc/ipfw.rules</span> θα μπορούσατε να φορτώσετε αυτούς τους κανόνες, γράφοντας την παρακάτω εντολή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipfw.rules</span></code></pre></div></div><div class=paragraph><p>Το αρχείο <span class=filename>/etc/ipfw.rules</span> μπορεί να βρίσκεται σε όποιο κατάλογο θέλετε, και να ονομάζεται επίσης όπως θέλετε.</p></div><div class=paragraph><p>Θα μπορούσατε να επιτύχετε το ίδιο πράγμα, εκτελώντας τις παρακάτω εντολές χειροκίνητα:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -q -f flush</span>
<span class=c># ipfw -q add check-state</span>
<span class=c># ipfw -q add deny all from any to any frag</span>
<span class=c># ipfw -q add deny tcp from any to any established</span>
<span class=c># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre></div></div></div><div class=sect4><h5 id=_σύνολο_κανόνων_stateful>55.6.5.5. Σύνολο Κανόνων Stateful<a class=anchor href=#_σύνολο_κανόνων_stateful></a></h5><div class=paragraph><p>Το παρακάτω σύνολο κανόνων (που δεν περιέχει κανόνες για NAT) είναι ένα παράδειγμα γραφής ενός inclusive firewall. Ένα inclusive firewall επιτρέπει την είσοδο μόνο των πακέτων που ταιριάζουν με τους κανόνες αποδοχής (pass) και απορρίπτει από προεπιλογή όλα τα άλλα. Τα firewalls που έχουν σχεδιαστεί να προστατεύουν ολόκληρα δίκτυα, διαθέτουν το λιγότερο δύο διεπαφές, στις οποίες πρέπει να υπάρχουν κανόνες ώστε το firewall να λειτουργεί.</p></div><div class=paragraph><p>Όλα τα λειτουργικά συστήματα τύπου UNIX®, συμπεριλαμβανομένου και του FreeBSD, έχουν σχεδιαστεί να χρησιμοποιούν τη διεπαφή <span class=filename>lo0</span> και τη διεύθυνση IP <code>127.0.0.1</code> για εσωτερική επικοινωνία με το λειτουργικό σύστημα. Το firewall πρέπει να περιέχει κανόνες που να επιτρέπουν την απρόσκοπτη κίνηση αυτών των ειδικών, για εσωτερική χρήση, πακέτων.</p></div><div class=paragraph><p>Οι κανόνες που ορίζουν την πρόσβαση εισερχόμενων και εξερχόμενων πακέτων, γράφονται για τη διεπαφή που συνδέεται στο δημόσιο Internet. Η διεπαφή αυτή μπορεί να είναι για παράδειγμα η <span class=filename>tun0</span> (σε περίπτωση που χρησιμοποιείτε το PPP χρήστη), ή η κάρτα δικτύου που συνδέεται στο καλωδιακό ή DSL modem σας.</p></div><div class=paragraph><p>Σε περίπτωση που μια ή περισσότερες κάρτες δικτύου συνδέονται σε εσωτερικά ιδιωτικά δίκτυα πίσω από το firewall, θα πρέπει να υπάρχουν οι αντίστοιχοι κανόνες που να επιτρέπουν την ελεύθερη διακίνηση των πακέτων ανάμεσα στις διεπαφές αυτές ή/και στο Internet.</p></div><div class=paragraph><p>Οι κανόνες πρέπει να οργανώνονται σε τρεις κύριες ενότητες: αρχικά όλες οι διεπαφές στις οποίες επιτρέπεται η ελεύθερη διακίνηση δεδομένων, έπειτα η διεπαφή από την οποία εξέρχονται τα πακέτα προς το δημόσιο δίκτυο (Internet) και τέλος η διεπαφή από την οποία λαμβάνονται πακέτα από το Internet.</p></div><div class=paragraph><p>Σε κάθε μια από τις ενότητες των διεπαφών που συνδέονται στο Internet, πρέπει να τοποθετούνται πρώτοι οι κανόνες που ταιριάζουν συχνότερα με την αντίστοιχη κίνηση. Ο τελευταίος κανόνας της ενότητας θα πρέπει να απορρίπτει και να καταγράφει όλα τα πακέτα της συγκεκριμένης διεπαφής/κατεύθυνσης.</p></div><div class=paragraph><p>Η ενότητα εξερχομένων (Outbound) στο σύνολο κανόνων που φαίνεται παρακάτω, περιέχει μόνο κανόνες τύπου <code>allow</code>. Οι κανόνες αυτοί περιέχουν συγκεκριμένες επιλεγμένες τιμές, με τις οποίες αναγνωρίζεται με μοναδικό τρόπο η υπηρεσία στην οποία επιτρέπεται η πρόσβαση από το δημόσιο Internet. Όλοι οι κανόνες έχουν τις επιλογές <code>proto</code>, <code>port</code>, <code>in/out</code> και <code>keep-state</code>. Οι κανόνες τύπου <code>proto tcp</code> περιέχουν την επιλογή <code>setup</code> για την αναγνώριση του πακέτου έναρξης της συνεδρίας, ώστε να γίνει η καταχώριση της στον πίνακα συνδέσεων (stateful).</p></div><div class=paragraph><p>Στην ενότητα των εισερχόμενων πακέτων (Inbound) που φαίνεται παρακάτω, εμφανίζονται πρώτοι οι κανόνες που χρησιμοποιούνται για την απόρριψη των ανεπιθύμητων πακέτων. Αυτό γίνεται για δύο διαφορετικούς λόγους. Ο πρώτος είναι ότι τα κακόβουλα πακέτα μπορεί εν μέρει να ταιριάζουν με κάποια χαρακτηριστικά της έγκυρης κίνησης. Τα πακέτα αυτά θα πρέπει να απορριφθούν, αντί να γίνουν δεκτά από κάποιο επόμενο κανόνα <code>allow</code>. Ο δεύτερος είναι ότι μπορείτε να απορρίψετε συγκεκριμένα πακέτα τα οποία γνωρίζετε ότι δεν είναι έγκυρα, αλλά σας είναι αδιάφορη η καταγραφή τους. Με τον τρόπο αυτό εμποδίζεται η λήψη και καταγραφή τους από τον τελευταίο κανόνα. Ο τελευταίος κανόνας τυπικά απορρίπτει και καταγράφει όλα τα πακέτα που έφτασαν μέχρι αυτόν. Ο κανόνας αυτός χρησιμοποιείται για την παροχή νομικών αποδείξεων σε περίπτωση που κινήσετε νομική διαδικασία κατά ατόμων που προέβησαν σε επιθέσεις στο σύστημα σας.</p></div><div class=paragraph><p>Θα πρέπει επίσης να εξασφαλίσετε ότι το σύστημα σας δεν θα δώσει καμιά απάντηση σε κανένα από τα ανεπιθύμητα πακέτα. Τα πακέτα αυτά θα πρέπει να απορριφθούν και να εξαφανιστούν. Με τον τρόπο αυτό, ο επιτιθέμενος δεν έχει καμιά γνώση αν τα πακέτα του έφτασαν μέχρι το σύστημα σας. Όσο λιγότερα μπορούν να μάθουν οι επιτιθέμενοι σχετικά με το σύστημα σας, τόσο πιο ασφαλές είναι. Όταν εκτελείτε καταγραφή πακέτων με αριθμούς θυρών που δεν αναγνωρίζετε, κοιτάξτε στο αρχείο <span class=filename>/etc/services/</span> ή δείτε το <a href=http://www.securitystats.com/tools/portsearch.php>http://www.securitystats.com/tools/portsearch.php</a> και αναζητήστε τον αριθμό της θύρας για να δείτε ποιος είναι ο σκοπός της. Ελέγξτε την παρακάτω τοποθεσία για τους αριθμούς θυρών που χρησιμοποιούνται συχνά από κακόβουλα προγράμματα (Trojans): <a href=http://www.simovits.com/trojans/trojans.html>http://www.simovits.com/trojans/trojans.html</a>.</p></div></div><div class=sect4><h5 id=_ένα_υπόδειγμα_συνόλου_κανόνων_inclusive>55.6.5.6. Ένα Υπόδειγμα Συνόλου Κανόνων Inclusive<a class=anchor href=#_ένα_υπόδειγμα_συνόλου_κανόνων_inclusive></a></h5><div class=paragraph><p>Το παρακάτω σύνολο κανόνων (στο οποίο δεν υλοποιείται λειτουργία NAT) είναι αρκετά πλήρες και πολύ ασφαλές. Δημιουργεί firewall τύπου inclusive, και έχει δοκιμαστεί σε πραγματικές συνθήκες λειτουργίας. Μπορεί να εξυπηρετήσει το ίδιο καλά και το δικό σας σύστημα. Απλώς μετατρέψτε σε σχόλιο τους κανόνες <code>pass</code> για τις υπηρεσίες που δεν θέλετε να ενεργοποιήσετε. Για να αποφύγετε την καταγραφή ανεπιθύμητων μηνυμάτων, απλώς προσθέστε ένα κανόνα τύπου <code>deny</code> στην ενότητα των εισερχομένων. Σε όλους τους κανόνες, Θα πρέπει να αλλάξετε το όνομα της διεπαφής από <span class=filename>dc0</span> στο πραγματικό όνομα της διεπαφής που συνδέεται στο δημόσιο Internet. Σε περίπτωση που χρησιμοποιείτε το PPP χρήστη, το όνομα της διεπαφής θα είναι <span class=filename>tun0</span>.</p></div><div class=paragraph><p>Θα διαπιστώσετε ότι υπάρχει μια συγκεκριμένη λογική στη χρήση αυτών των κανόνων.</p></div><div class=ulist><ul><li><p>Όλοι οι κανόνες που αποτελούν αίτηση για έναρξη μιας νέας συνεδρίας με το δημόσιο Internet, χρησιμοποιούν την επιλογή <code>keep-state</code>.</p></li><li><p>Όλες οι διαπιστευμένες υπηρεσίες που προέρχονται από το δημόσιο Internet, διαθέτουν την επιλογή <code>limit</code>, για την αποφυγή επιθέσεων υπερχείλισης (flooding).</p></li><li><p>Όλοι οι κανόνες χρησιμοποιούν τις επιλογές <code>in</code> ή <code>out</code> για να διευκρινίζουν την κατεύθυνση της επικοινωνίας.</p></li><li><p>Όλοι οι κανόνες χρησιμοποιούν την επιλογή <code>via όνομα-διεπαφής</code> για να καθορίσουν τη διεπαφή από την οποία διέρχεται το πακέτο.</p></li></ul></div><div class=paragraph><p>Οι κανόνες που φαίνονται παρακάτω, θα πρέπει να γραφούν στο <span class=filename>/etc/ipfw.rules</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN.
# Change xl0 to your LAN NIC interface name
#################################################################
#$cmd 00005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
$cmd 00010 allow all from any to any via lo0

#################################################################
# Allow the packet through if it has previous been added to the
# the &#34;dynamic&#34; rules table by a allow keep-state statement.
#################################################################
$cmd 00015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Check session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP&#39;s Domain name server.
# x.x.x.x must be the IP address of your ISP.s DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow out access to my ISP&#39;s DHCP server for cable/DSL configurations.
# This rule is not needed for .user ppp. connection to the public Internet.
# so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow out non-secure standard www function
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state

# Allow out secure www function https over TLS SSL
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow out send &amp; get email function
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow out FBSD (make install &amp; CVSUP) functions
# Basically give user root &#34;GOD&#34; privileges.
$cmd 00240 allow tcp from me to any out via $pif setup keep-state uid root

# Allow out ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow out Time
$cmd 00260 allow tcp from any to any 37 out via $pif setup keep-state

# Allow out nntp news (i.e. news groups)
$cmd 00270 allow tcp from any to any 119 out via $pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# Allow out whois
$cmd 00290 allow tcp from any to any 43 out via $pif setup keep-state

# deny and log everything else that.s trying to get out.
# This rule enforces the block all by default logic.
$cmd 00299 deny log all from any to any out via $pif

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif  #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif     #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif          #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif            #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif   #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif  #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif         #Class D &amp; E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny any late arriving packets
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic in from ISP&#39;s DHCP server. This rule must contain
# the IP address of your ISP.s DHCP server as it.s the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for .user ppp. type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow in standard www function because I have apache server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
$cmd 00420 allow tcp from any to me 23 in via $pif setup limit src-addr 2

# Reject &amp; Log all incoming connections from the outside
$cmd 00499 deny log all from any to any in via $pif

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
$cmd 00999 deny log all from any to any
################ End of IPFW rules file ###############################</pre></div></div></div><div class=sect4><h5 id=_ένα_υπόδειγμα_nat_με_stateful_σύνολο_κανόνων>55.6.5.7. Ένα Υπόδειγμα NAT με Stateful Σύνολο Κανόνων<a class=anchor href=#_ένα_υπόδειγμα_nat_με_stateful_σύνολο_κανόνων></a></h5><div class=paragraph><p>Για να ενεργοποιηθεί η λειτουργία NAT στο IPFW, χρειάζονται κάποιες επιπλέον ρυθμίσεις. Θα πρέπει να προσθέσετε την επιλογή <code>option IPDIVERT</code> μαζί με τις υπόλοιπες επιλογές για το IPFIREWALL στο αρχείο ρυθμίσεων του πυρήνα. Θα πρέπει έπειτα να μεταγλωττίσετε και να εγκαταστήσετε το νέο σας προσαρμοσμένο πυρήνα.</p></div><div class=paragraph><p>Εκτός από τις συνηθισμένες επιλογές για το IPFW, θα πρέπει να προσθέσετε και τις παρακάτω στο αρχείο <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;                   # Enable NATD function
natd_interface=&#34;rl0&#34;                # interface name of public Internet NIC
natd_flags=&#34;-dynamic -m&#34;            # -m = preserve port numbers if possible</pre></div></div><div class=paragraph><p>Η χρήση κανόνων stateful μαζί με τον κανόνα <code>divert natd</code> (NAT), περιπλέκει πολύ την λογική συγγραφής των κανόνων. Η θέση εμφάνισης των κανόνων <code>check-state</code> και <code>divert natd</code> μέσα στο σύνολο κανόνων γίνεται πολύ κρίσιμη. Δεν πρόκειται πλέον για απλή λογική περάσματος από τον ένα κανόνα στον επόμενο. Χρησιμοποιείται ένα νέο είδος ενέργειας που ονομάζεται <code>skipto</code>. Για να χρησιμοποιηθεί η εντολή <code>skipto</code>, είναι υποχρεωτικό να έχετε αριθμήσει τους κανόνες, ώστε να ξέρετε σε ποιο κανόνα θα καταλήξει το άλμα που θα εκτελεστεί από την εντολή αυτή.</p></div><div class=paragraph><p>Παρακάτω θα βρείτε ένα υπόδειγμα (χωρίς πρόσθετα σχόλια) μιας μεθόδου συγγραφής που επιλέξαμε εδώ για να εξηγήσουμε την ακολουθία ροής του πακέτου μέσα στο σύνολο κανόνων.</p></div><div class=paragraph><p>Η ροή της επεξεργασίας ξεκινάει με τον πρώτο από την κορυφή κανόνα και συνεχίζει ένα κανόνα κάθε φορά προς τα κάτω, είτε μέχρι να φτάσει τον τελευταίο, ή μέχρι το πακέτο να ταιριάξει με τα κριτήρια επιλογής κάποιου κανόνα και να ελευθερωθεί από το firewall. Είναι σημαντικό να παρατηρήσουμε τη θέση των κανόνων με αριθμούς 100, 101, 450, 500 και 510. Οι κανόνες αυτοί ελέγχουν την μετάφραση των εξερχόμενων και εισερχόμενων πακέτων, ώστε οι καταχωρήσεις τους στο δυναμικό πίνακα καταστάσεων να περιέχουν πάντα την ιδιωτική IP διεύθυνση του τοπικού δικτύου. Παρατηρήστε επίσης ότι όλοι οι κανόνες allow και deny καθορίζουν την κατεύθυνση κίνησης του πακέτου καθώς και την διεπαφή. Επίσης, όλες οι εξερχόμενες αιτήσεις για νέες συνεδρίες μεταφέρονται απευθείας (μέσω του <code>skipto rule 500</code>) στον κανόνα 500 για να γίνει η μετάφραση διευθύνσεων δικτύου (NAT).</p></div><div class=paragraph><p>Ας υποθέσουμε ότι ένα χρήστης του τοπικού δικτύου χρησιμοποιεί τον φυλλομετρητή του για να δει μια ιστοσελίδα. Οι ιστοσελίδες χρησιμοποιούν την πόρτα 80 για την επικοινωνία. Το πακέτο εισέρχεται στο firewall. Δεν ταιριάζει με τον κανόνα 100 γιατί είναι εξερχόμενο και όχι εισερχόμενο. Περνάει τον κανόνα 101 γιατί πρόκειται για νέα επικοινωνία και έτσι δεν υπάρχει ακόμα στον δυναμικό πίνακα καταστάσεων. Το πακέτο τελικά φτάνει στον κανόνα 125 με τον οποίο και ταιριάζει. Εξέρχεται μέσω της κάρτας δικτύου που συνδέεται στο δημόσιο Internet. Το πακέτο έχει ακόμα ως IP αφετηρίας την ιδιωτική διεύθυνση του τοπικού δικτύου. Το ταίριασμα με αυτό τον κανόνα προκαλεί δύο ενέργειες. Η επιλογή <code>keep-state</code> θα δημιουργήσει ένα νέο δυναμικό κανόνα, θα τον καταχωρήσει στον πίνακα, και θα εκτελέσει την αντίστοιχη ενέργεια. Η ενέργεια αυτή είναι μέρος της πληροφορίας που γράφεται στον δυναμικό πίνακα. Στην περίπτωση αυτή είναι η "skipto rule 500". Ο κανόνας 500 μεταφράζει μέσω NAT τη διεύθυνση IP του πακέτου, πριν αυτό εξέλθει προς το Internet. Αυτό είναι ιδιαίτερα σημαντικό. Το πακέτο κατευθύνεται προς τον προορισμό του, όπου δημιουργείται και αποστέλλεται ένα νέο πακέτο ως απάντηση. Το νέο αυτό πακέτο εισέρχεται ξανά στο firewall, στον κανόνα που είναι στην κορυφή της λίστας. Αυτή τη φορά ταιριάζει με τον κανόνα 100 και η διεύθυνση προορισμού του αλλάζει ξανά στην αρχική του τοπικού δικτύου. Έπειτα, γίνεται η επεξεργασία του από τον κανόνα <code>check-state</code> ο οποίος ανακαλύπτει ότι πρόκειται για πακέτο συνεδρίας σε εξέλιξη και το απελευθερώνει στο τοπικό δίκτυο. Κατευθύνεται προς τον υπολογιστή του τοπικού δικτύου που το έστειλε, ο οποίος στέλνει ένα νέο πακέτο ζητώντας περισσότερα δεδομένα από τον απομακρυσμένο εξυπηρετητή. Το πακέτο αυτό ελέγχεται από τον κανόνα <code>check-state</code>, ο οποίος βρίσκει την καταχώριση του στα εξερχόμενα και εκτελεί την αντίστοιχη ενέργεια που σε αυτή την περίπτωση είναι "skipto 500". Το πακέτο προωθείται στον κανόνα 500, γίνεται η μετάφραση της διεύθυνσης του μέσω NAT και απελευθερώνεται στο Internet.</p></div><div class=paragraph><p>Από την μεριά των εισερχόμενων, όποιο πακέτο αναγνωρίζεται ως μέρος μιας υπάρχουσας συνεδρίας, ελέγχεται αυτόματα από τον κανόνα <code>check-state</code> και τους αντίστοιχους κανόνες <code>divert natd</code>. Το μόνο που χρειάζεται να αντιμετωπίσουμε είναι η απόρριψη όλων των προβληματικών πακέτων και η έγκριση μόνο των πακέτων που προορίζονται για εγκεκριμένες υπηρεσίες. Ας υποθέσουμε ότι έχουμε ένα εξυπηρετητή apache ο οποίος εκτελείται στο μηχάνημα με το firewall, και επιθυμούμε το τοπικό site να είναι προσβάσιμο από το δημόσιο Internet. Η εισερχόμενη αίτηση νέας συνεδρίας ταιριάζει με τον κανόνα 100 και η IP διεύθυνση της αντιστοιχίζεται στο τοπικό IP του μηχανήματος με το firewall. Το πακέτο έπειτα ελέγχεται για οποιοδήποτε πρόβλημα μπορεί να έχει σύμφωνα με τους κανόνες που χρησιμοποιούμε, και τελικά ταιριάζει με τον κανόνα 425. Στην περίπτωση αυτή συμβαίνουν δύο πράγματα. Ο κανόνας για το πακέτο γράφεται στο δυναμικό πίνακα καταστάσεων, αλλά αυτή τη φορά περιορίζεται ο αριθμός αιτήσεων νέας συνεδρίας από το συγκεκριμένο IP σε 2. Με αυτό τον τρόπο μπορούμε να αμυνθούμε σε επιθέσεις τύπου άρνησης υπηρεσίας (DoS) όσο αφορά τη συγκεκριμένη θύρα επικοινωνίας. Η ενέργεια του κανόνα είναι το <code>allow</code>, και έτσι το πακέτο απελευθερώνεται στο τοπικό δίκτυο. Το πακέτο που παράγεται ως απάντηση, ελέγχεται από τον κανόνα <code>check-state</code>, ο οποίος αναγνωρίζει ότι ανήκει σε μια ήδη ενεργή συνεδρία, και αποστέλλεται στον κανόνα 500 όπου γίνεται η μετάφραση της διεύθυνσης του μέσω NAT. Το πακέτο τελικά απελευθερώνεται μέσω της διεπαφής εξερχομένων.</p></div><div class=paragraph><p>Υπόδειγμα Κανόνων #1:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 500&#34;
pif=rl0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,43,53,80,443,110,119&#34;

ipfw -q -f flush

$cmd 002 allow all from any to any via xl0  # exclude LAN traffic
$cmd 003 allow all from any to any via lo0  # exclude loopback traffic

$cmd 100 divert natd ip from any to any in via $pif
$cmd 101 check-state

# Authorized outbound packets
$cmd 120 $skip udp from any to xx.168.240.2 53 out via $pif $ks
$cmd 121 $skip udp from any to xx.168.240.5 53 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks
$cmd 135 $skip udp from any to any 123 out via $pif $ks

# Deny all inbound traffic from non-routable reserved address spaces
$cmd 300 deny all from 192.168.0.0/16  to any in via $pif  #RFC 1918 private IP
$cmd 301 deny all from 172.16.0.0/12   to any in via $pif  #RFC 1918 private IP
$cmd 302 deny all from 10.0.0.0/8      to any in via $pif  #RFC 1918 private IP
$cmd 303 deny all from 127.0.0.0/8     to any in via $pif  #loopback
$cmd 304 deny all from 0.0.0.0/8       to any in via $pif  #loopback
$cmd 305 deny all from 169.254.0.0/16  to any in via $pif  #DHCP auto-config
$cmd 306 deny all from 192.0.2.0/24    to any in via $pif  #reserved for docs
$cmd 307 deny all from 204.152.64.0/23 to any in via $pif  #Sun cluster
$cmd 308 deny all from 224.0.0.0/3     to any in via $pif  #Class D &amp; E multicast

# Authorized inbound packets
$cmd 400 allow udp from xx.70.207.54 to any 68 in $ks
$cmd 420 allow tcp from any to me 80 in via $pif setup limit src-addr 1

$cmd 450 deny log ip from any to any

# This is skipto location for outbound stateful rules
$cmd 500 divert natd ip from any to any out via $pif
$cmd 510 allow ip from any to any

######################## end of rules  ##################</pre></div></div><div class=paragraph><p>Οι παρακάτω κανόνες είναι σχεδόν ίδιοι με τους παραπάνω, αλλά περιέχουν περισσότερα σχόλια για να βοηθήσουν τον αρχάριο χρήστη του IPFW να καταλάβει καλύτερα πως λειτουργούν.</p></div><div class=paragraph><p>Υπόδειγμα Κανόνων #2:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 800&#34;
pif=&#34;rl0&#34;     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Change xl0 to your LAN NIC interface name
#################################################################
$cmd 005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
$cmd 010 allow all from any to any via lo0

#################################################################
# check if packet is inbound and nat address if it is
#################################################################
$cmd 014 divert natd ip from any to any in via $pif

#################################################################
# Allow the packet through if it has previous been added to the
# the &#34;dynamic&#34; rules table by a allow keep-state statement.
#################################################################
$cmd 015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Check session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP&#39;s Domain name server.
# x.x.x.x must be the IP address of your ISP&#39;s DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
$cmd 020 $skip tcp from any to x.x.x.x 53 out via $pif setup keep-state

# Allow out access to my ISP&#39;s DHCP server for cable/DSL configurations.
$cmd 030 $skip udp from any to x.x.x.x 67 out via $pif keep-state

# Allow out non-secure standard www function
$cmd 040 $skip tcp from any to any 80 out via $pif setup keep-state

# Allow out secure www function https over TLS SSL
$cmd 050 $skip tcp from any to any 443 out via $pif setup keep-state

# Allow out send &amp; get email function
$cmd 060 $skip tcp from any to any 25 out via $pif setup keep-state
$cmd 061 $skip tcp from any to any 110 out via $pif setup keep-state

# Allow out FreeBSD (make install &amp; CVSUP) functions
# Basically give user root &#34;GOD&#34; privileges.
$cmd 070 $skip tcp from me to any out via $pif setup keep-state uid root

# Allow out ping
$cmd 080 $skip icmp from any to any out via $pif keep-state

# Allow out Time
$cmd 090 $skip tcp from any to any 37 out via $pif setup keep-state

# Allow out nntp news (i.e. news groups)
$cmd 100 $skip tcp from any to any 119 out via $pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
$cmd 110 $skip tcp from any to any 22 out via $pif setup keep-state

# Allow out whois
$cmd 120 $skip tcp from any to any 43 out via $pif setup keep-state

# Allow ntp time server
$cmd 130 $skip udp from any to any 123 out via $pif keep-state

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
$cmd 300 deny all from 192.168.0.0/16  to any in via $pif  #RFC 1918 private IP
$cmd 301 deny all from 172.16.0.0/12   to any in via $pif  #RFC 1918 private IP
$cmd 302 deny all from 10.0.0.0/8      to any in via $pif  #RFC 1918 private IP
$cmd 303 deny all from 127.0.0.0/8     to any in via $pif  #loopback
$cmd 304 deny all from 0.0.0.0/8       to any in via $pif  #loopback
$cmd 305 deny all from 169.254.0.0/16  to any in via $pif  #DHCP auto-config
$cmd 306 deny all from 192.0.2.0/24    to any in via $pif  #reserved for docs
$cmd 307 deny all from 204.152.64.0/23 to any in via $pif  #Sun cluster
$cmd 308 deny all from 224.0.0.0/3     to any in via $pif  #Class D &amp; E multicast

# Deny ident
$cmd 315 deny tcp from any to any 113 in via $pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
$cmd 320 deny tcp from any to any 137 in via $pif
$cmd 321 deny tcp from any to any 138 in via $pif
$cmd 322 deny tcp from any to any 139 in via $pif
$cmd 323 deny tcp from any to any 81  in via $pif

# Deny any late arriving packets
$cmd 330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 332 deny tcp from any to any established in via $pif

# Allow traffic in from ISP&#39;s DHCP server. This rule must contain
# the IP address of your ISP&#39;s DHCP server as it&#39;s the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for &#39;user ppp&#39; type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
$cmd 360 allow udp from x.x.x.x to any 68 in via $pif keep-state

# Allow in standard www function because I have Apache server
$cmd 370 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
$cmd 380 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
$cmd 390 allow tcp from any to me 23 in via $pif setup limit src-addr 2

# Reject &amp; Log all unauthorized incoming connections from the public Internet
$cmd 400 deny log all from any to any in via $pif

# Reject &amp; Log all unauthorized out going connections to the public Internet
$cmd 450 deny log all from any to any out via $pif

# This is skipto location for outbound stateful rules
$cmd 800 divert natd ip from any to any out via $pif
$cmd 801 allow ip from any to any

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
$cmd 999 deny log all from any to any
################ End of IPFW rules file ###############################</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=advanced-networking>Chapter 56. Προχωρημένα Θέματα Δικτύωσης<a class=anchor href=#advanced-networking></a></h2><div class=sectionbody><div class=sect2><h3 id=advanced-networking-synopsis>56.1. Σύνοψη<a class=anchor href=#advanced-networking-synopsis></a></h3><div class=paragraph><p>Το κεφάλαιο αυτό καλύπτει προχωρημένα θέματα δικτύωσης.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Τα βασικά των πυλών (gateways) και των δρομολογήσεων (routes).</p></li><li><p>Πως να ρυθμίσετε συσκευές IEEE 802.11 και Bluetooth®.</p></li><li><p>Πως να κάνετε το FreeBSD να δρα ως γέφυρα (bridge).</p></li><li><p>Πως να ρυθμίσετε εκκίνηση από το δίκτυο σε ένα μηχάνημα χωρίς σκληρό δίσκο.</p></li><li><p>Πως να ρυθμίσετε μετάφραση δικτυακών διευθύνσεων (NAT).</p></li><li><p>Πως να συνδέσετε δύο υπολογιστές μέσω PLIP.</p></li><li><p>Πως να ρυθμίσετε το IPv6 σε ένα μηχάνημα FreeBSD.</p></li><li><p>Πως να ρυθμίσετε το ATM.</p></li><li><p>Πως να ρυθμίσετε και να χρησιμοποιήσετε τις δυνατότητες του CARP (Common Access Redundancy Protocol) στο FreeBSD.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε τις βασικές έννοιες των αρχείων script <span class=filename>/etc/rc</span>.</p></li><li><p>Να είστε εξοικειωμένος με τη βασική ορολογία των δικτύων.</p></li><li><p>Να γνωρίζετε πως να ρυθμίσετε και να εγκαταστήσετε ένα νέο πυρήνα στο FreeBSD (<a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></li><li><p>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (<a href=./#ports>Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-routing>56.2. Gateways and Routes<a class=anchor href=#network-routing></a></h3><div class=paragraph><p>For one machine to be able to find another over a network, there must be a mechanism in place to describe how to get from one to the other. This is called <em>routing</em>. A "route" is a defined pair of addresses: a "destination" and a "gateway". The pair indicates that if you are trying to get to this <em>destination</em>, communicate through this <em>gateway</em>. There are three types of destinations: individual hosts, subnets, and "default". The "default route" is used if none of the other routes apply. We will talk a little bit more about default routes later on. There are also three types of gateways: individual hosts, interfaces (also called "links"), and Ethernet hardware addresses (MAC addresses).</p></div><div class=sect3><h4 id=_an_example>56.2.1. An Example<a class=anchor href=#_an_example></a></h4><div class=paragraph><p>To illustrate different aspects of routing, we will use the following example from <code>netstat</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1             UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>The first two lines specify the default route (which we will cover in the <a href=#network-routing-default>next section</a>) and the <code>localhost</code> route.</p></div><div class=paragraph><p>The interface (<code>Netif</code> column) that this routing table specifies to use for <code>localhost</code> is <span class=filename>lo0</span>, also known as the loopback device. This says to keep all traffic for this destination internal, rather than sending it out over the LAN, since it will only end up back where it started.</p></div><div class=paragraph><p>The next thing that stands out are the addresses beginning with <code>0:e0:</code>. These are Ethernet hardware addresses, which are also known as MAC addresses. FreeBSD will automatically identify any hosts (<code>test0</code> in the example) on the local Ethernet and add a route for that host, directly to it over the Ethernet interface, <span class=filename>ed0</span>. There is also a timeout (<code>Expire</code> column) associated with this type of route, which is used if we fail to hear from the host in a specific amount of time. When this happens, the route to this host will be automatically deleted. These hosts are identified using a mechanism known as RIP (Routing Information Protocol), which figures out routes to local hosts based upon a shortest path determination.</p></div><div class=paragraph><p>FreeBSD will also add subnet routes for the local subnet (<code>10.20.30.255</code> is the broadcast address for the subnet <code>10.20.30</code>, and <code>example.com</code> is the domain name associated with that subnet). The designation <code>link#1</code> refers to the first Ethernet card in the machine. You will notice no additional interface is specified for those.</p></div><div class=paragraph><p>Both of these groups (local network hosts and local subnets) have their routes automatically configured by a daemon called routed. If this is not run, then only routes which are statically defined (i.e. entered explicitly) will exist.</p></div><div class=paragraph><p>The <code>host1</code> line refers to our host, which it knows by Ethernet address. Since we are the sending host, FreeBSD knows to use the loopback interface (<span class=filename>lo0</span>) rather than sending it out over the Ethernet interface.</p></div><div class=paragraph><p>The two <code>host2</code> lines are an example of what happens when we use an <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> alias (see the section on Ethernet for reasons why we would do this). The <code>⇒</code> symbol after the <span class=filename>lo0</span> interface says that not only are we using the loopback (since this address also refers to the local host), but specifically it is an alias. Such routes only show up on the host that supports the alias; all other hosts on the local network will simply have a <code>link#1</code> line for such routes.</p></div><div class=paragraph><p>The final line (destination subnet <code>224</code>) deals with multicasting, which will be covered in another section.</p></div><div class=paragraph><p>Finally, various attributes of each route can be seen in the <code>Flags</code> column. Below is a short table of some of these flags and their meanings:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Up: The route is active.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Host: The route destination is a single host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gateway: Send anything for this destination on to this remote system, which will figure out from there where to send it.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Static: This route was configured manually, not automatically generated by the system.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clone: Generates a new route based upon this route for machines we connect to. This type of route is normally used for local networks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>WasCloned: Indicated a route that was auto-configured based upon a local area network (Clone) route.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Link: Route involves references to Ethernet hardware.</p></td></tr></tbody></table></div><div class=sect3><h4 id=network-routing-default>56.2.2. Default Routes<a class=anchor href=#network-routing-default></a></h4><div class=paragraph><p>When the local system needs to make a connection to a remote host, it checks the routing table to determine if a known path exists. If the remote host falls into a subnet that we know how to reach (Cloned routes), then the system checks to see if it can connect along that interface.</p></div><div class=paragraph><p>If all known paths fail, the system has one last option: the "default" route. This route is a special type of gateway route (usually the only one present in the system), and is always marked with a <code>c</code> in the flags field. For hosts on a local area network, this gateway is set to whatever machine has a direct connection to the outside world (whether via PPP link, DSL, cable modem, T1, or another network interface).</p></div><div class=paragraph><p>If you are configuring the default route for a machine which itself is functioning as the gateway to the outside world, then the default route will be the gateway machine at your Internet Service Provider’s (ISP) site.</p></div><div class=paragraph><p>Let us look at an example of default routes. This is a common configuration:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/net-routing.png alt="net routing"></div></div><div class=paragraph><p>The hosts <code>Local1</code> and <code>Local2</code> are at your site. <code>Local1</code> is connected to an ISP via a dial up PPP connection. This PPP server computer is connected through a local area network to another gateway computer through an external interface to the ISPs Internet feed.</p></div><div class=paragraph><p>The default routes for each of your machines will be:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Host</th><th class="tableblock halign-left valign-top">Default Gateway</th><th class="tableblock halign-left valign-top">Interface</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ethernet</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PPP</p></td></tr></tbody></table><div class=paragraph><p>A common question is "Why (or how) would we set the <code>T1-GW</code> to be the default gateway for <code>Local1</code>, rather than the ISP server it is connected to?".</p></div><div class=paragraph><p>Remember, since the PPP interface is using an address on the ISP’s local network for your side of the connection, routes for any other machines on the ISP’s local network will be automatically generated. Hence, you will already know how to reach the <code>T1-GW</code> machine, so there is no need for the intermediate step of sending traffic to the ISP server.</p></div><div class=paragraph><p>It is common to use the address <code>X.X.X.1</code> as the gateway address for your local network. So (using the same example), if your local class-C address space was <code>10.20.30</code> and your ISP was using <code>10.9.9</code> then the default routes would be:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Host</th><th class="tableblock halign-left valign-top">Default Route</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2 (10.20.30.2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1, 10.9.9.30)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW (10.9.9.1)</p></td></tr></tbody></table><div class=paragraph><p>You can easily define the default route via the <span class=filename>/etc/rc.conf</span> file. In our example, on the <code>Local2</code> machine, we added the following line in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>It is also possible to do it directly from the command line with the <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>For more information on manual manipulation of network routing tables, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> manual page.</p></div></div><div class=sect3><h4 id=_dual_homed_hosts>56.2.3. Dual Homed Hosts<a class=anchor href=#_dual_homed_hosts></a></h4><div class=paragraph><p>There is one other type of configuration that we should cover, and that is a host that sits on two different networks. Technically, any machine functioning as a gateway (in the example above, using a PPP connection) counts as a dual-homed host. But the term is really only used to refer to a machine that sits on two local-area networks.</p></div><div class=paragraph><p>In one case, the machine has two Ethernet cards, each having an address on the separate subnets. Alternately, the machine may only have one Ethernet card, and be using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aliasing. The former is used if two physically separate Ethernet networks are in use, the latter if there is one physical network segment, but two logically separate subnets.</p></div><div class=paragraph><p>Either way, routing tables are set up so that each subnet knows that this machine is the defined gateway (inbound route) to the other subnet. This configuration, with the machine acting as a router between the two subnets, is often used when we need to implement packet filtering or firewall security in either or both directions.</p></div><div class=paragraph><p>If you want this machine to actually forward packets between the two interfaces, you need to tell FreeBSD to enable this ability. See the next section for more details on how to do this.</p></div></div><div class=sect3><h4 id=network-dedicated-router>56.2.4. Building a Router<a class=anchor href=#network-dedicated-router></a></h4><div class=paragraph><p>A network router is simply a system that forwards packets from one interface to another. Internet standards and good engineering practice prevent the FreeBSD Project from enabling this by default in FreeBSD. You can enable this feature by changing the following variable to <code>YES</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>This option will set the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>net.inet.ip.forwarding</code> to <code>1</code>. If you should need to stop routing temporarily, you can reset this to <code>0</code> temporarily.</p></div><div class=paragraph><p>Your new router will need routes to know where to send the traffic. If your network is simple enough you can use static routes. FreeBSD also comes with the standard BSD routing daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, which speaks RIP (both version 1 and version 2) and IRDP. Support for BGP v4, OSPF v2, and other sophisticated routing protocols is available with the <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> package. Commercial products such as GateD® are also available for more complex network routing solutions.</p></div></div><div class=sect3><h4 id=_setting_up_static_routes>56.2.5. Setting Up Static Routes<a class=anchor href=#_setting_up_static_routes></a></h4><div class=sect4><h5 id=_manual_configuration>56.2.5.1. Manual Configuration<a class=anchor href=#_manual_configuration></a></h5><div class=paragraph><p>Let us assume we have a network as follows:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>In this scenario, <code>RouterA</code> is our FreeBSD machine that is acting as a router to the rest of the Internet. It has a default route set to <code>10.0.0.1</code> which allows it to connect with the outside world. We will assume that <code>RouterB</code> is already configured properly and knows how to get wherever it needs to go. (This is simple in this picture. Just add a default route on <code>RouterB</code> using <code>192.168.1.1</code> as the gateway.)</p></div><div class=paragraph><p>If we look at the routing table for <code>RouterA</code> we would see something like the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>With the current routing table <code>RouterA</code> will not be able to reach our Internal Net 2. It does not have a route for <code>192.168.2.0/24</code>. One way to alleviate this is to manually add the route. The following command would add the Internal Net 2 network to <code>RouterA</code>'s routing table using <code>192.168.1.2</code> as the next hop:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Now <code>RouterA</code> can reach any hosts on the <code>192.168.2.0/24</code> network.</p></div></div><div class=sect4><h5 id=_persistent_configuration>56.2.5.2. Persistent Configuration<a class=anchor href=#_persistent_configuration></a></h5><div class=paragraph><p>The above example is perfect for configuring a static route on a running system. However, one problem is that the routing information will not persist if you reboot your FreeBSD machine. The way to handle the addition of a static route is to put it in your <span class=filename>/etc/rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>The <code>static_routes</code> configuration variable is a list of strings separated by a space. Each string references to a route name. In our above example we only have one string in <code>static_routes</code>. This string is <em>internalnet2</em>. We then add a configuration variable called <code>route_internalnet2</code> where we put all of the configuration parameters we would give to the <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> command. For our example above we would have used the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>so we need <code>"-net 192.168.2.0/24 192.168.1.2"</code>.</p></div><div class=paragraph><p>As said above, we can have more than one string in <code>static_routes</code>. This allows us to create multiple static routes. The following lines shows an example of adding static routes for the <code>192.168.0.0/24</code> and <code>192.168.1.0/24</code> networks on an imaginary router:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div></div><div class=sect3><h4 id=_routing_propagation>56.2.6. Routing Propagation<a class=anchor href=#_routing_propagation></a></h4><div class=paragraph><p>We have already talked about how we define our routes to the outside world, but not about how the outside world finds us.</p></div><div class=paragraph><p>We already know that routing tables can be set up so that all traffic for a particular address space (in our examples, a class-C subnet) can be sent to a particular host on that network, which will forward the packets inbound.</p></div><div class=paragraph><p>When you get an address space assigned to your site, your service provider will set up their routing tables so that all traffic for your subnet will be sent down your PPP link to your site. But how do sites across the country know to send to your ISP?</p></div><div class=paragraph><p>There is a system (much like the distributed DNS information) that keeps track of all assigned address-spaces, and defines their point of connection to the Internet Backbone. The "Backbone" are the main trunk lines that carry Internet traffic across the country, and around the world. Each backbone machine has a copy of a master set of tables, which direct traffic for a particular network to a specific backbone carrier, and from there down the chain of service providers until it reaches your network.</p></div><div class=paragraph><p>It is the task of your service provider to advertise to the backbone sites that they are the point of connection (and thus the path inward) for your site. This is known as route propagation.</p></div></div><div class=sect3><h4 id=_troubleshooting_2>56.2.7. Troubleshooting<a class=anchor href=#_troubleshooting_2></a></h4><div class=paragraph><p>Sometimes, there is a problem with routing propagation, and some sites are unable to connect to you. Perhaps the most useful command for trying to figure out where routing is breaking down is the <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> command. It is equally useful if you cannot seem to make a connection to a remote machine (i.e. <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> fails).</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> command is run with the name of the remote host you are trying to connect to. It will show the gateway hosts along the path of the attempt, eventually either reaching the target host, or terminating because of a lack of connection.</p></div><div class=paragraph><p>For more information, see the manual page for <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect3><h4 id=_multicast_routing>56.2.8. Multicast Routing<a class=anchor href=#_multicast_routing></a></h4><div class=paragraph><p>FreeBSD supports both multicast applications and multicast routing natively. Multicast applications do not require any special configuration of FreeBSD; applications will generally run out of the box. Multicast routing requires that support be compiled into the kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>In addition, the multicast routing daemon, <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> must be configured to set up tunnels and DVMRP via <span class=filename>/etc/mrouted.conf</span>. More details on multicast configuration may be found in the manual page for <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a>.</p></div></div></div><div class=sect2><h3 id=network-wireless>56.3. Wireless Networking<a class=anchor href=#network-wireless></a></h3><div class=sect3><h4 id=_wireless_networking_basics>56.3.1. Wireless Networking Basics<a class=anchor href=#_wireless_networking_basics></a></h4><div class=paragraph><p>Most wireless networks are based on the IEEE 802.11 standards. A basic wireless network consists of multiple stations communicating with radios that broadcast in either the 2.4GHz or 5GHz band (though this varies according to the locale and is also changing to enable communication in the 2.3GHz and 4.9GHz ranges).</p></div><div class=paragraph><p>802.11 networks are organized in two ways: in <em>infrastructure mode</em> one station acts as a master with all the other stations associating to it; the network is known as a BSS and the master station is termed an access point (AP). In a BSS all communication passes through the AP; even when one station wants to communicate with another wireless station messages must go through the AP. In the second form of network there is no master and stations communicate directly. This form of network is termed an IBSS and is commonly known as an <em>ad-hoc network</em>.</p></div><div class=paragraph><p>802.11 networks were first deployed in the 2.4GHz band using protocols defined by the IEEE 802.11 and 802.11b standard. These specifications include the operating frequencies, MAC layer characteristics including framing and transmission rates (communication can be done at various rates). Later the 802.11a standard defined operation in the 5GHz band, including different signalling mechanisms and higher transmission rates. Still later the 802.11g standard was defined to enable use of 802.11a signalling and transmission mechanisms in the 2.4GHz band in such a way as to be backwards compatible with 802.11b networks.</p></div><div class=paragraph><p>Separate from the underlying transmission techniques 802.11 networks have a variety of security mechanisms. The original 802.11 specifications defined a simple security protocol called WEP. This protocol uses a fixed pre-shared key and the RC4 cryptographic cipher to encode data transmitted on a network. Stations must all agree on the fixed key in order to communicate. This scheme was shown to be easily broken and is now rarely used except to discourage transient users from joining networks. Current security practice is given by the IEEE 802.11i specification that defines new cryptographic ciphers and an additional protocol to authenticate stations to an access point and exchange keys for doing data communication. Further, cryptographic keys are periodically refreshed and there are mechanisms for detecting intrusion attempts (and for countering intrusion attempts). Another security protocol specification commonly used in wireless networks is termed WPA. This was a precursor to 802.11i defined by an industry group as an interim measure while waiting for 802.11i to be ratified. WPA specifies a subset of the requirements found in 802.11i and is designed for implementation on legacy hardware. Specifically WPA requires only the TKIP cipher that is derived from the original WEP cipher. 802.11i permits use of TKIP but also requires support for a stronger cipher, AES-CCM, for encrypting data. (The AES cipher was not required in WPA because it was deemed too computationally costly to be implemented on legacy hardware.)</p></div><div class=paragraph><p>Other than the above protocol standards the other important standard to be aware of is 802.11e. This defines protocols for deploying multi-media applications such as streaming video and voice over IP (VoIP) in an 802.11 network. Like 802.11i, 802.11e also has a precursor specification termed WME (later renamed WMM) that has been defined by an industry group as a subset of 802.11e that can be deployed now to enable multi-media applications while waiting for the final ratification of 802.11e. The most important thing to know about 802.11e and WME/WMM is that it enables prioritized traffic use of a wireless network through Quality of Service (QoS) protocols and enhanced media access protocols. Proper implementation of these protocols enable high speed bursting of data and prioritized traffic flow.</p></div><div class=paragraph><p>Since the 6.0 version, FreeBSD supports networks that operate using 802.11a, 802.11b, and 802.11g. The WPA and 802.11i security protocols are likewise supported (in conjunction with any of 11a, 11b, and 11g) and QoS and traffic prioritization required by the WME/WMM protocols are supported for a limited set of wireless devices.</p></div></div><div class=sect3><h4 id=network-wireless-basic>56.3.2. Basic Setup<a class=anchor href=#network-wireless-basic></a></h4><div class=sect4><h5 id=_kernel_configuration>56.3.2.1. Kernel Configuration<a class=anchor href=#_kernel_configuration></a></h5><div class=paragraph><p>To use wireless networking you need a wireless networking card and to configure the kernel with the appropriate wireless networking support. The latter is separated into multiple modules so that you only need to configure the software you are actually going to use.</p></div><div class=paragraph><p>The first thing you need is a wireless device. The most commonly used devices are those that use parts made by Atheros. These devices are supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> driver and require the following line to be added to the <span class=filename>/boot/loader.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The Atheros driver is split up into three separate pieces: the driver proper (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), the hardware support layer that handles chip-specific functions (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>), and an algorithm for selecting which of several possible rates for transmitting frames (ath_rate_sample here). When you load this support as modules these dependencies are automatically handled for you. If instead of an Atheros device you had another device you would select the module for that device; e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>for devices based on the Intersil Prism parts (<a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> driver).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In the rest of this document, we will use an <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> device, the device name in the examples must be changed according to your configuration. A list of available wireless drivers can be found at the beginning of the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> manual page. If a native FreeBSD driver for your wireless device does not exist, it may be possible to directly use the Windows® driver with the help of the <a href=./#config-network-ndis>NDIS</a> driver wrapper.</p></div></td></tr></tbody></table></div><div class=paragraph><p>With a device driver configured you need to also bring in the 802.11 networking support required by the driver. For the <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> driver this is at least the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> module; this module is automatically loaded with the wireless device driver. With that you will need the modules that implement cryptographic support for the security protocols you intend to use. These are intended to be dynamically loaded on demand by the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> module but for now they must be manually configured. The following modules are available: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. Both <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> drivers are only needed if you intend to use the WPA and/or 802.11i security protocols. If your network is to run totally open (i.e., with no encryption) then you do not even need the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a> support. To load these modules at boot time, add the following lines to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>With this information in the system bootstrap configuration file (i.e., <span class=filename>/boot/loader.conf</span>), you have to reboot your FreeBSD box. If you do not want to reboot your machine for the moment, you can just load the modules by hand using <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you do not want to use modules, it is possible to compile these drivers into the kernel by adding the following lines to your kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device ath               # Atheros IEEE 802.11 wireless network driver
device ath_hal           # Atheros Hardware Access Layer
device ath_rate_sample   # John Bicket&#39;s SampleRate control algorithm.
device wlan              # 802.11 support (Required)
device wlan_wep          # WEP crypto support for 802.11 devices
device wlan_ccmp         # AES-CCMP crypto support for 802.11 devices
device wlan_tkip         # TKIP and Michael crypto support for 802.11 devices</pre></div></div><div class=paragraph><p>With this information in the kernel configuration file, recompile the kernel and reboot your FreeBSD machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When the system is up, we could find some information about the wireless device in the boot messages, like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0xff9f0000-0xff9fffff irq 17 at device 2.0 on pci2
ath0: Ethernet address: 00:11:95:d5:43:62
ath0: mac 7.9 phy 4.5 radio 5.6</code></pre></div></div></div></div><div class=sect3><h4 id=_infrastructure_mode>56.3.3. Infrastructure Mode<a class=anchor href=#_infrastructure_mode></a></h4><div class=paragraph><p>The infrastructure mode or BSS mode is the mode that is typically used. In this mode, a number of wireless access points are connected to a wired network. Each wireless network has its own name, this name is called the SSID of the network. Wireless clients connect to the wireless access points.</p></div><div class=sect4><h5 id=_freebsd_clients>56.3.3.1. FreeBSD Clients<a class=anchor href=#_freebsd_clients></a></h5><div class=sect5><h6 id=_how_to_find_access_points>56.3.3.1.1. How to Find Access Points<a class=anchor href=#_how_to_find_access_points></a></h6><div class=paragraph><p>To scan for networks, use the <code>ifconfig</code> command. This request may take a few moments to complete as it requires that the system switches to each available wireless frequency and probes for available access points. Only the super-user can initiate such a scan:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
dlinkap         00:13:46:49:41:76    6   54M 29:0   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M 22:0   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>You must mark the interface <code>up</code> before you can scan. Subsequent scan requests do not require you to mark the interface up again.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The output of a scan request lists each BSS/IBSS network found. Beside the name of the network, <code>SSID</code>, we find the <code>BSSID</code> which is the MAC address of the access point. The <code>CAPS</code> field identifies the type of each network and the capabilities of the stations operating there:</p></div><div class=dlist><dl><dt class=hdlist1><code>E</code></dt><dd><p>Extended Service Set (ESS). Indicates that the station is part of an infrastructure network (in contrast to an IBSS/ad-hoc network).</p></dd><dt class=hdlist1><code>I</code></dt><dd><p>IBSS/ad-hoc network. Indicates that the station is part of an ad-hoc network (in contrast to an ESS network).</p></dd><dt class=hdlist1><code>P</code></dt><dd><p>Privacy. Data confidentiality is required for all data frames exchanged within the BSS. This means that this BSS requires the station to use cryptographic means such as WEP, TKIP or AES-CCMP to encrypt/decrypt data frames being exchanged with others.</p></dd><dt class=hdlist1><code>S</code></dt><dd><p>Short Preamble. Indicates that the network is using short preambles (defined in 802.11b High Rate/DSSS PHY, short preamble utilizes a 56 bit sync field in contrast to a 128 bit field used in long preamble mode).</p></dd><dt class=hdlist1><code>s</code></dt><dd><p>Short slot time. Indicates that the 802.11g network is using a short slot time because there are no legacy (802.11b) stations present.</p></dd></dl></div><div class=paragraph><p>One can also display the current list of known networks with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 list scan</span></code></pre></div></div><div class=paragraph><p>This information may be updated automatically by the adapter or manually with a <code>scan</code> request. Old data is automatically removed from the cache, so over time this list may shrink unless more scans are done.</p></div></div><div class=sect5><h6 id=_basic_settings>56.3.3.1.2. Basic Settings<a class=anchor href=#_basic_settings></a></h6><div class=paragraph><p>This section provides a simple example of how to make the wireless network adapter work in FreeBSD without encryption. After you are familiar with these concepts, we strongly recommend using <a href=#network-wireless-wpa>WPA</a> to set up your wireless network.</p></div><div class=paragraph><p>There are three basic steps to configure a wireless network: selecting an access point, authenticating your station, and configuring an IP address. The following sections discuss each step.</p></div><div class=sect6><h7 id=_selecting_an_access_point>56.3.3.1.2.1. Selecting an Access Point<a class=anchor href=#_selecting_an_access_point></a></h7><div class=paragraph><p>Most of time it is sufficient to let the system choose an access point using the builtin heuristics. This is the default behaviour when you mark an interface up or otherwise configure an interface by listing it in <span class=filename>/etc/rc.conf</span>, e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>If there are multiple access points and you want to select a specific one, you can select it by its SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>In an environment where there are multiple access points with the same SSID (often done to simplify roaming) it may be necessary to associate to one specific device. In this case you can also specify the BSSID of the access point (you can also leave off the SSID):</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>There are other ways to constrain the choice of an access point such as limiting the set of frequencies the system will scan on. This may be useful if you have a multi-band wireless card as scanning all the possible channels can be time-consuming. To limit operation to a specific band you can use the <code>mode</code> parameter; e.g.:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;mode 11g ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>will force the card to operate in 802.11g which is defined only for 2.4GHz frequencies so any 5GHz channels will not be considered. Other ways to do this are the <code>channel</code> parameter, to lock operation to one specific frequency, and the <code>chanlist</code> parameter, to specify a list of channels for scanning. More information about these parameters can be found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> manual page.</p></div></div><div class=sect6><h7 id=_authentication>56.3.3.1.2.2. Authentication<a class=anchor href=#_authentication></a></h7><div class=paragraph><p>Once you have selected an access point your station needs to authenticate before it can pass data. Authentication can happen in several ways. The most common scheme used is termed open authentication and allows any station to join the network and communicate. This is the authentication you should use for test purpose the first time you set up a wireless network. Other schemes require cryptographic handshakes be completed before data traffic can flow; either using pre-shared keys or secrets, or more complex schemes that involve backend services such as RADIUS. Most users will use open authentication which is the default setting. Next most common setup is WPA-PSK, also known as WPA Personal, which is described <a href=#network-wireless-wpa-wpa-psk>below</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you have an Apple® AirPort® Extreme base station for an access point you may need to configure shared-key authentication together with a WEP key. This can be done in the <span class=filename>/etc/rc.conf</span> file or using the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> program. If you have a single AirPort® base station you can setup access with something like:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>In general shared key authentication is to be avoided because it uses the WEP key material in a highly-constrained manner making it even easier to crack the key. If WEP must be used (e.g., for compatibility with legacy devices) it is better to use WEP with <code>open</code> authentication. More information regarding WEP can be found in the <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect6><h7 id=_getting_an_ip_address_with_dhcp>56.3.3.1.2.3. Getting an IP Address with DHCP<a class=anchor href=#_getting_an_ip_address_with_dhcp></a></h7><div class=paragraph><p>Once you have selected an access point and set the authentication parameters, you will have to get an IP address to communicate. Most of time you will obtain your wireless IP address via DHCP. To achieve that, simply edit <span class=filename>/etc/rc.conf</span> and add <code>DHCP</code> to the configuration for your device as shown in various examples above:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>At this point, you are ready to bring up the wireless interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span></code></pre></div></div><div class=paragraph><p>Once the interface is running, use <code>ifconfig</code> to see the status of the interface <span class=filename>ath0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0</span>
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:11:95:d5:43:62
        media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/54Mbps<span class=o>)</span>
        status: associated
        ssid dlinkap channel 6 bssid 00:13:46:49:41:76
        authmode OPEN privacy OFF txpowmax 36 protmode CTS bintval 100</code></pre></div></div><div class=paragraph><p>The <code>status: associated</code> means you are connected to the wireless network (to the <code>dlinkap</code> network in our case). The <code>bssid 00:13:46:49:41:76</code> part is the MAC address of your access point; the <code>authmode</code> line informs you that the communication is not encrypted (<code>OPEN</code>).</p></div></div><div class=sect6><h7 id=_static_ip_address>56.3.3.1.2.4. Static IP Address<a class=anchor href=#_static_ip_address></a></h7><div class=paragraph><p>In the case you cannot obtain an IP address from a DHCP server, you can set a fixed IP address. Replace the <code>DHCP</code> keyword shown above with the address information. Be sure to retain any other parameters you have set up for selecting an access point:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wpa>56.3.3.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h6><div class=paragraph><p>WPA (Wi-Fi Protected Access) is a security protocol used together with 802.11 networks to address the lack of proper authentication and the weakness of <a href=#network-wireless-wep>WEP</a>. WPA leverages the 802.1X authentication protocol and uses one of several ciphers instead of WEP for data integrity. The only cipher required by WPA is TKIP (Temporary Key Integrity Protocol) which is a cipher that extends the basic RC4 cipher used by WEP by adding integrity checking, tamper detection, and measures for responding to any detected intrusions. TKIP is designed to work on legacy hardware with only software modification; it represents a compromise that improves security but is still not entirely immune to attack. WPA also specifies the AES-CCMP cipher as an alternative to TKIP and that is preferred when possible; for this specification the term WPA2 (or RSN) is commonly used.</p></div><div class=paragraph><p>WPA defines authentication and encryption protocols. Authentication is most commonly done using one of two techniques: by 802.1X and a backend authentication service such as RADIUS, or by a minimal handshake between the station and the access point using a pre-shared secret. The former is commonly termed WPA Enterprise with the latter known as WPA Personal. Since most people will not set up a RADIUS backend server for wireless network, WPA-PSK is by far the most commonly encountered configuration for WPA.</p></div><div class=paragraph><p>The control of the wireless connection and the authentication (key negotiation or authentication with a server) is done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> utility. This program requires a configuration file, <span class=filename>/etc/wpa_supplicant.conf</span>, to run. More information regarding this file can be found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a> manual page.</p></div><div class=sect6><h7 id=network-wireless-wpa-wpa-psk>56.3.3.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h7><div class=paragraph><p>WPA-PSK also known as WPA-Personal is based on a pre-shared key (PSK) generated from a given password and that will be used as the master key in the wireless network. This means every wireless user will share the same key. WPA-PSK is intended for small networks where the use of an authentication server is not possible or desired.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Always use strong passwords that are sufficiently long and made from a rich alphabet so they will not be guessed and/or attacked.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The first step is the configuration of the <span class=filename>/etc/wpa_supplicant.conf</span> file with the SSID and the pre-shared key of your network:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Then, in <span class=filename>/etc/rc.conf</span>, we indicate that the wireless device configuration will be done with WPA and the IP address will be obtained with DHCP:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, we can bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on ath0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on ath0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/36Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA privacy ON deftxkey UNDEF TKIP 2:128-bit txpowmax 36
      protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class=paragraph><p>Or you can try to configure it manually using the same <span class=filename>/etc/wpa_supplicant.conf</span> <a href=#network-wireless-wpa-wpa-psk>above</a>, and run:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i ath0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>TKIP <span class=nv>GTK</span><span class=o>=</span>TKIP]</code></pre></div></div><div class=paragraph><p>The next operation is the launch of the <code>dhclient</code> command to get the IP address from the DHCP server:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient ath0</span>
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig ath0</span>
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/48Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA privacy ON deftxkey UNDEF TKIP 2:128-bit txpowmax 36
      protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the <span class=filename>/etc/rc.conf</span> is set up with the line <code>ifconfig_ath0="DHCP"</code> then it is no need to run the <code>dhclient</code> command manually, <code>dhclient</code> will be launched after <code>wpa_supplicant</code> plumbs the keys.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In the case where the use of DHCP is not possible, you can set a static IP address after <code>wpa_supplicant</code> has authenticated the station:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig ath0</span>
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>OFDM/36Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA privacy ON deftxkey UNDEF TKIP 2:128-bit txpowmax 36
      protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class=paragraph><p>When DHCP is not used, you also have to manually set up the default gateway and the nameserver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-tls>56.3.3.1.3.2. WPA with EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h7><div class=paragraph><p>The second way to use WPA is with an 802.1X backend authentication server, in this case WPA is called WPA-Enterprise to make difference with the less secure WPA-Personal with its pre-shared key. The authentication in WPA-Enterprise is based on EAP (Extensible Authentication Protocol).</p></div><div class=paragraph><p>EAP does not come with an encryption method, it was decided to embed EAP inside an encrypted tunnel. Many types of EAP authentication methods have been designed, the most common methods are EAP-TLS, EAP-TTLS and EAP-PEAP.</p></div><div class=paragraph><p>EAP-TLS (EAP with Transport Layer Security) is a very well-supported authentication protocol in the wireless world since it was the first EAP method to be certified by the <a href=http://www.wi-fi.org/>Wi-Fi alliance</a>. EAP-TLS will require three certificates to run: the CA certificate (installed on all machines), the server certificate for your authentication server, and one client certificate for each wireless client. In this EAP method, both authentication server and wireless client authenticate each other in presenting their respective certificates, and they verify that these certificates were signed by your organization’s certificate authority (CA).</p></div><div class=paragraph><p>As previously, the configuration is done via <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field indicates the network name (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Here, we use RSN (IEEE 802.11i) protocol, i.e., WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>key_mgmt</code> line refers to the key management protocol we use. In our case it is WPA using EAP authentication: <code>WPA-EAP</code>.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>In this field, we mention the EAP method for our connection.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The <code>identity</code> field contains the identity string for EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificat.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>The <code>client_cert</code> line gives the pathname to the client certificate file. This certificate is unique to each wireless client of the network.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The <code>private_key</code> field is the pathname to the client certificate private key file.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>The <code>private_key_passwd</code> field contains the passphrase for the private key.</td></tr></tbody></table></div><div class=paragraph><p>Then add the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface with the help of the <span class=filename>rc.d</span> facility:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/11Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy ON deftxkey UNDEF TKIP 2:128-bit
      txpowmax 36 protmode CTS roaming MANUAL bintval 100</code></pre></div></div><div class=paragraph><p>As previously shown, it is also possible to bring up the interface manually with both <code>wpa_supplicant</code> and <code>ifconfig</code> commands.</p></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-ttls>56.3.3.1.3.3. WPA with EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h7><div class=paragraph><p>With EAP-TLS both the authentication server and the client need a certificate, with EAP-TTLS (EAP-Tunneled Transport Layer Security) a client certificate is optional. This method is close to what some secure web sites do , where the web server can create a secure SSL tunnel even if the visitors do not have client-side certificates. EAP-TTLS will use the encrypted TLS tunnel for safe transport of the authentication data.</p></div><div class=paragraph><p>The configuration is done via the <span class=filename>/etc/wpa_supplicant.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>In this field, we mention the EAP method for our connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificat.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>In this field, we mention the authentication method used in the encrypted TLS tunnel. In our case, EAP with MD5-Challenge has been used. The "inner authentication" phase is often called "phase2".</td></tr></tbody></table></div><div class=paragraph><p>You also have to add the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/11Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy ON deftxkey UNDEF TKIP 2:128-bit
      txpowmax 36 protmode CTS roaming MANUAL bintval 100</code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-peap>56.3.3.1.3.4. WPA with EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h7><div class=paragraph><p>PEAP (Protected EAP) has been designed as an alternative to EAP-TTLS. There are two types of PEAP methods, the most common one is PEAPv0/EAP-MSCHAPv2. In the rest of this document, we will use the PEAP term to refer to that EAP method. PEAP is the most used EAP standard after EAP-TLS, in other words if you have a network with mixed OSes, PEAP should be the most supported standard after EAP-TLS.</p></div><div class=paragraph><p>PEAP is similar to EAP-TTLS: it uses a server-side certificate to authenticate clients by creating an encrypted TLS tunnel between the client and the authentication server, which protects the ensuing exchange of authentication information. In term of security the difference between EAP-TTLS and PEAP is that PEAP authentication broadcasts the username in clear, only the password is sent in the encrypted TLS tunnel. EAP-TTLS will use the TLS tunnel for both username and password.</p></div><div class=paragraph><p>We have to edit the <span class=filename>/etc/wpa_supplicant.conf</span> file and add the EAP-PEAP related settings:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>In this field, we mention the EAP method for our connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificat.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>This field contains the parameters for the first phase of the authentication (the TLS tunnel). According to the authentication server used, you will have to specify a specific label for the authentication. Most of time, the label will be "client EAP encryption" which is set by using <code>peaplabel=0</code>. More information can be found in the <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a> manual page.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>In this field, we mention the authentication protocol used in the encrypted TLS tunnel. In the case of PEAP, it is <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>The following must be added to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, we can bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPREQUEST on ath0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      ether 00:11:95:d5:43:62
      media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/11Mbps<span class=o>)</span>
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy ON deftxkey UNDEF TKIP 2:128-bit
      txpowmax 36 protmode CTS roaming MANUAL bintval 100</code></pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wep>56.3.3.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h6><div class=paragraph><p>WEP (Wired Equivalent Privacy) is part of the original 802.11 standard. There is no authentication mechanism, only a weak form of access control, and it is easily to be cracked.</p></div><div class=paragraph><p>WEP can be set up with <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.1.100 netmask 255.255.255.0 ssid my_net \</span>
	    wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p>The <code>weptxkey</code> means which WEP key will be used in the transmission. Here we used the third key. This must match the setting in the access point.</p></li><li><p>The <code>wepkey</code> means setting the selected WEP key. It should in the format <em>index:key</em>, if the index is not given, key <code>1</code> is set. That is to say we need to set the index if we use keys other than the first key.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>You must replace the <code>0x3456789012</code> with the key configured for use on the access point.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>You are encouraged to read <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> manual page for further information.</p></div><div class=paragraph><p>The <code>wpa_supplicant</code> facility also can be used to configure your wireless interface with WEP. The example above can be set up by adding the following lines to <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Then:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i ath0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect3><h4 id=_ad_hoc_mode>56.3.4. Ad-hoc Mode<a class=anchor href=#_ad_hoc_mode></a></h4><div class=paragraph><p>IBSS mode, also called ad-hoc mode, is designed for point to point connections. For example, to establish an ad-hoc network between the machine <code>A</code> and the machine <code>B</code> we will just need to choose two IP adresses and a SSID.</p></div><div class=paragraph><p>On the box <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mediaopt adhoc</span>
<span class=c># ifconfig ath0</span>
  ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect &lt;adhoc&gt; <span class=o>(</span>autoselect &lt;adhoc&gt;<span class=o>)</span>
	  status: associated
	  ssid freebsdap channel 2 bssid 02:11:95:c3:0d:ac
	  authmode OPEN privacy OFF txpowmax 36 protmode CTS bintval 100</code></pre></div></div><div class=paragraph><p>The <code>adhoc</code> parameter indicates the interface is running in the IBSS mode.</p></div><div class=paragraph><p>On <code>B</code>, we should be able to detect <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 up scan</span>
  SSID            BSSID              CHAN RATE  S:N   INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M 19:0   100 IS</code></pre></div></div><div class=paragraph><p>The <code>I</code> in the output confirms the machine <code>A</code> is in ad-hoc mode. We just have to configure <code>B</code> with a different IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ath0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap mediaopt adhoc</span>
<span class=c># ifconfig ath0</span>
  ath0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	  inet6 fe80::211:95ff:fed5:4362%ath0 prefixlen 64 scopeid 0x1
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  ether 00:11:95:d5:43:62
	  media: IEEE 802.11 Wireless Ethernet autoselect &lt;adhoc&gt; <span class=o>(</span>autoselect &lt;adhoc&gt;<span class=o>)</span>
	  status: associated
	  ssid freebsdap channel 2 bssid 02:11:95:c3:0d:ac
	  authmode OPEN privacy OFF txpowmax 36 protmode CTS bintval 100</code></pre></div></div><div class=paragraph><p>Both <code>A</code> and <code>B</code> are now ready to exchange informations.</p></div></div><div class=sect3><h4 id=_troubleshooting_3>56.3.5. Troubleshooting<a class=anchor href=#_troubleshooting_3></a></h4><div class=paragraph><p>If you are having trouble with wireless networking, there are a number of steps you can take to help troubleshoot the problem.</p></div><div class=ulist><ul><li><p>If you do not see the access point listed when scanning be sure you have not configured your wireless device to a limited set of channels.</p></li><li><p>If you cannot associate to an access point verify the configuration of your station matches the one of the access point. This includes the authentication scheme and any security protocols. Simplify your configuration as much as possible. If you are using a security protocol such as WPA or WEP configure the access point for open authentication and no security to see if you can get traffic to pass.</p></li><li><p>Once you can associate to the access point diagnose any security configuration using simple tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p><div class=paragraph><p>The <code>wpa_supplicant</code> has much debugging support; try running it manually with the <code>-dd</code> option and look at the system logs.</p></div></li><li><p>There are also many lower-level debugging tools. You can enable debugging messages in the 802.11 protocol support layer using the <code>wlandebug</code> program found in <span class=filename>/usr/src/tools/tools/net80211</span>. For example:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i ath0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>can be used to enable console messages related to scanning for access points and doing the 802.11 protocol handshakes required to arrange communication.</p></div><div class=paragraph><p>There are also many useful statistics maintained by the 802.11 layer; the <code>wlanstats</code> tool will dump these informations. These statistics should identify all errors identified by the 802.11 layer. Beware however that some errors are identified in the device drivers that lie below the 802.11 layer so they may not show up. To diagnose device-specific problems you need to refer to the drivers' documentation.</p></div></li></ul></div><div class=paragraph><p>If the above information does not help to clarify the problem, please submit a problem report and include output from the above tools.</p></div></div></div><div class=sect2><h3 id=network-bluetooth>56.4. Bluetooth<a class=anchor href=#network-bluetooth></a></h3><div class=sect3><h4 id=_introduction_3>56.4.1. Introduction<a class=anchor href=#_introduction_3></a></h4><div class=paragraph><p>Bluetooth is a wireless technology for creating personal networks operating in the 2.4 GHz unlicensed band, with a range of 10 meters. Networks are usually formed ad-hoc from portable devices such as cellular phones, handhelds and laptops. Unlike the other popular wireless technology, Wi-Fi, Bluetooth offers higher level service profiles, e.g. FTP-like file servers, file pushing, voice transport, serial line emulation, and more.</p></div><div class=paragraph><p>The Bluetooth stack in FreeBSD is implemented using the Netgraph framework (see <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>). A broad variety of Bluetooth USB dongles is supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> driver. The Broadcom BCM2033 chip based Bluetooth devices are supported via the <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> drivers. The 3Com Bluetooth PC Card 3CRWB60-A is supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a> driver. Serial and UART based Bluetooth devices are supported via <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>. This section describes the use of the USB Bluetooth dongle.</p></div></div><div class=sect3><h4 id=_plugging_in_the_device>56.4.2. Plugging in the Device<a class=anchor href=#_plugging_in_the_device></a></h4><div class=paragraph><p>By default Bluetooth device drivers are available as kernel modules. Before attaching a device, you will need to load the driver into the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>If the Bluetooth device is present in the system during system startup, load the module from <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Plug in your USB dongle. The output similar to the following will appear on the console (or in syslog):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The Bluetooth stack has to be started manually on FreeBSD 6.0, and on FreeBSD 5.X before 5.5. It is done automatically from <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> on FreeBSD 5.5, 6.1 and newer.</p></div><div class=paragraph><p>Copy <span class=filename>/usr/shared/examples/netgraph/bluetooth/rc.bluetooth</span> into some convenient place, like <span class=filename>/etc/rc.bluetooth</span>. This script is used to start and stop the Bluetooth stack. It is a good idea to stop the stack before unplugging the device, but it is not (usually) fatal. When starting the stack, you will receive output similar to the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_host_controller_interface_hci>56.4.3. Host Controller Interface (HCI)<a class=anchor href=#_host_controller_interface_hci></a></h4><div class=paragraph><p>Host Controller Interface (HCI) provides a command interface to the baseband controller and link manager, and access to hardware status and control registers. This interface provides a uniform method of accessing the Bluetooth baseband capabilities. HCI layer on the Host exchanges data and commands with the HCI firmware on the Bluetooth hardware. The Host Controller Transport Layer (i.e. physical bus) driver provides both HCI layers with the ability to exchange information with each other.</p></div><div class=paragraph><p>A single Netgraph node of type <em>hci</em> is created for a single Bluetooth device. The HCI node is normally connected to the Bluetooth device driver node (downstream) and the L2CAP node (upstream). All HCI operations must be performed on the HCI node and not on the device driver node. Default name for the HCI node is "devicehci". For more details refer to the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a> manual page.</p></div><div class=paragraph><p>One of the most common tasks is discovery of Bluetooth devices in RF proximity. This operation is called <em>inquiry</em>. Inquiry and other HCI related operations are done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a> utility. The example below shows how to find out which Bluetooth devices are in range. You should receive the list of devices in a few seconds. Note that a remote device will only answer the inquiry if it put into <em>discoverable</em> mode.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> is unique address of a Bluetooth device, similar to MAC addresses of a network card. This address is needed for further communication with a device. It is possible to assign human readable name to a BD_ADDR. The <span class=filename>/etc/bluetooth/hosts</span> file contains information regarding the known Bluetooth hosts. The following example shows how to obtain human readable name that was assigned to the remote device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>If you perform an inquiry on a remote Bluetooth device, it will find your computer as "your.host.name (ubt0)". The name assigned to the local device can be changed at any time.</p></div><div class=paragraph><p>The Bluetooth system provides a point-to-point connection (only two Bluetooth units involved), or a point-to-multipoint connection. In the point-to-multipoint connection the connection is shared among several Bluetooth devices. The following example shows how to obtain the list of active baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>A <em>connection handle</em> is useful when termination of the baseband connection is required. Note, that it is normally not required to do it by hand. The stack will automatically terminate inactive baseband connections.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Refer to <code>hccontrol help</code> for a complete listing of available HCI commands. Most of the HCI commands do not require superuser privileges.</p></div></div><div class=sect3><h4 id=_logical_link_control_and_adaptation_protocol_l2cap>56.4.4. Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_logical_link_control_and_adaptation_protocol_l2cap></a></h4><div class=paragraph><p>Logical Link Control and Adaptation Protocol (L2CAP) provides connection-oriented and connectionless data services to upper layer protocols with protocol multiplexing capability and segmentation and reassembly operation. L2CAP permits higher level protocols and applications to transmit and receive L2CAP data packets up to 64 kilobytes in length.</p></div><div class=paragraph><p>L2CAP is based around the concept of <em>channels</em>. Channel is a logical connection on top of baseband connection. Each channel is bound to a single protocol in a many-to-one fashion. Multiple channels can be bound to the same protocol, but a channel cannot be bound to multiple protocols. Each L2CAP packet received on a channel is directed to the appropriate higher level protocol. Multiple channels can share the same baseband connection.</p></div><div class=paragraph><p>A single Netgraph node of type <em>l2cap</em> is created for a single Bluetooth device. The L2CAP node is normally connected to the Bluetooth HCI node (downstream) and Bluetooth sockets nodes (upstream). Default name for the L2CAP node is "devicel2cap". For more details refer to the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a> manual page.</p></div><div class=paragraph><p>A useful command is <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, which can be used to ping other devices. Some Bluetooth implementations might not return all of the data sent to them, so <code>0 bytes</code> in the following example is normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> utility is used to perform various operations on L2CAP nodes. This example shows how to obtain the list of logical connections (channels) and the list of baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Another diagnostic tool is <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. It does a job similar to as <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> does, but for Bluetooth network-related data structures. The example below shows the same logical connection as <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> above.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect3><h4 id=_rfcomm_protocol>56.4.5. RFCOMM Protocol<a class=anchor href=#_rfcomm_protocol></a></h4><div class=paragraph><p>The RFCOMM protocol provides emulation of serial ports over the L2CAP protocol. The protocol is based on the ETSI standard TS 07.10. RFCOMM is a simple transport protocol, with additional provisions for emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports. The RFCOMM protocol supports up to 60 simultaneous connections (RFCOMM channels) between two Bluetooth devices.</p></div><div class=paragraph><p>For the purposes of RFCOMM, a complete communication path involves two applications running on different devices (the communication endpoints) with a communication segment between them. RFCOMM is intended to cover applications that make use of the serial ports of the devices in which they reside. The communication segment is a Bluetooth link from one device to another (direct connect).</p></div><div class=paragraph><p>RFCOMM is only concerned with the connection between the devices in the direct connect case, or between the device and a modem in the network case. RFCOMM can support other configurations, such as modules that communicate via Bluetooth wireless technology on one side and provide a wired interface on the other side.</p></div><div class=paragraph><p>In FreeBSD the RFCOMM protocol is implemented at the Bluetooth sockets layer.</p></div></div><div class=sect3><h4 id=_pairing_of_devices>56.4.6. Pairing of Devices<a class=anchor href=#_pairing_of_devices></a></h4><div class=paragraph><p>By default, Bluetooth communication is not authenticated, and any device can talk to any other device. A Bluetooth device (for example, cellular phone) may choose to require authentication to provide a particular service (for example, Dial-Up service). Bluetooth authentication is normally done with <em>PIN codes</em>. A PIN code is an ASCII string up to 16 characters in length. User is required to enter the same PIN code on both devices. Once user has entered the PIN code, both devices will generate a <em>link key</em>. After that the link key can be stored either in the devices themselves or in a persistent storage. Next time both devices will use previously generated link key. The described above procedure is called <em>pairing</em>. Note that if the link key is lost by any device then pairing must be repeated.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon is responsible for handling of all Bluetooth authentication requests. The default configuration file is <span class=filename>/etc/bluetooth/hcsecd.conf</span>. An example section for a cellular phone with the PIN code arbitrarily set to "1234" is shown below:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>There is no limitation on PIN codes (except length). Some devices (for example Bluetooth headsets) may have a fixed PIN code built in. The <code>-d</code> switch forces the <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon to stay in the foreground, so it is easy to see what is happening. Set the remote device to receive pairing and initiate the Bluetooth connection to the remote device. The remote device should say that pairing was accepted, and request the PIN code. Enter the same PIN code as you have in <span class=filename>hcsecd.conf</span>. Now your PC and the remote device are paired. Alternatively, you can initiate pairing on the remote device.</p></div><div class=paragraph><p>On FreeBSD 5.5, 6.1 and newer, the following line can be added to the <span class=filename>/etc/rc.conf</span> file to have hcsecd started automatically on system start:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The following is a sample of the hcsecd daemon output:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect3><h4 id=_service_discovery_protocol_sdp>56.4.7. Service Discovery Protocol (SDP)<a class=anchor href=#_service_discovery_protocol_sdp></a></h4><div class=paragraph><p>The Service Discovery Protocol (SDP) provides the means for client applications to discover the existence of services provided by server applications as well as the attributes of those services. The attributes of a service include the type or class of service offered and the mechanism or protocol information needed to utilize the service.</p></div><div class=paragraph><p>SDP involves communication between a SDP server and a SDP client. The server maintains a list of service records that describe the characteristics of services associated with the server. Each service record contains information about a single service. A client may retrieve information from a service record maintained by the SDP server by issuing a SDP request. If the client, or an application associated with the client, decides to use a service, it must open a separate connection to the service provider in order to utilize the service. SDP provides a mechanism for discovering services and their attributes, but it does not provide a mechanism for utilizing those services.</p></div><div class=paragraph><p>Normally, a SDP client searches for services based on some desired characteristics of the services. However, there are times when it is desirable to discover which types of services are described by an SDP server’s service records without any a priori information about the services. This process of looking for any offered services is called <em>browsing</em>.</p></div><div class=paragraph><p>The Bluetooth SDP server <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> and command line client <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> are included in the standard FreeBSD installation. The following example shows how to perform a SDP browse query.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>and so on. Note that each service has a list of attributes (RFCOMM channel for example). Depending on the service you might need to make a note of some of the attributes. Some Bluetooth implementations do not support service browsing and may return an empty list. In this case it is possible to search for the specific service. The example below shows how to search for the OBEX Object Push (OPUSH) service:</p></li></ol></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Offering services on FreeBSD to Bluetooth clients is done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server. On FreeBSD 5.5, 6.1 and newer, the following line can be added to the <span class=filename>/etc/rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then the sdpd daemon can be started with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sdpd start</span></code></pre></div></div><div class=paragraph><p>On FreeBSD 6.0, and on FreeBSD 5.X before 5.5, sdpd is not integrated into the system startup scripts. It has to be started manually with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpd</span></code></pre></div></div><div class=paragraph><p>The local server application that wants to provide Bluetooth service to the remote clients will register service with the local SDP daemon. The example of such application is <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Once started it will register Bluetooth LAN service with the local SDP daemon.</p></div><div class=paragraph><p>The list of services registered with the local SDP server can be obtained by issuing SDP browse query via local control channel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect3><h4 id=_dial_up_networking_dun_and_network_access_with_ppp_lan_profiles>56.4.8. Dial-Up Networking (DUN) and Network Access with PPP (LAN) Profiles<a class=anchor href=#_dial_up_networking_dun_and_network_access_with_ppp_lan_profiles></a></h4><div class=paragraph><p>The Dial-Up Networking (DUN) profile is mostly used with modems and cellular phones. The scenarios covered by this profile are the following:</p></div><div class=ulist><ul><li><p>use of a cellular phone or modem by a computer as a wireless modem for connecting to a dial-up Internet access server, or using other dial-up services;</p></li><li><p>use of a cellular phone or modem by a computer to receive data calls.</p></li></ul></div><div class=paragraph><p>Network Access with PPP (LAN) profile can be used in the following situations:</p></div><div class=ulist><ul><li><p>LAN access for a single Bluetooth device;</p></li><li><p>LAN access for multiple Bluetooth devices;</p></li><li><p>PC to PC (using PPP networking over serial cable emulation).</p></li></ul></div><div class=paragraph><p>In FreeBSD both profiles are implemented with <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> - a wrapper that converts RFCOMM Bluetooth connection into something PPP can operate with. Before any profile can be used, a new PPP label in the <span class=filename>/etc/ppp/ppp.conf</span> must be created. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> manual page for examples.</p></div><div class=paragraph><p>In the following example <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> will be used to open RFCOMM connection to remote device with BD_ADDR 00:80:37:29:19:a4 on DUN RFCOMM channel. The actual RFCOMM channel number will be obtained from the remote device via SDP. It is possible to specify RFCOMM channel by hand, and in this case <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> will not perform SDP query. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> to find out RFCOMM channel on the remote device.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>In order to provide Network Access with PPP (LAN) service the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server must be running. A new entry for LAN clients must be created in the <span class=filename>/etc/ppp/ppp.conf</span> file. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> manual page for examples. Finally, start RFCOMM PPP server on valid RFCOMM channel number. The RFCOMM PPP server will automatically register Bluetooth LAN service with the local SDP daemon. The example below shows how to start RFCOMM PPP server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect3><h4 id=_obex_object_push_opush_profile>56.4.9. OBEX Object Push (OPUSH) Profile<a class=anchor href=#_obex_object_push_opush_profile></a></h4><div class=paragraph><p>OBEX is a widely used protocol for simple file transfers between mobile devices. Its main use is in infrared communication, where it is used for generic file transfers between notebooks or PDAs, and for sending business cards or calendar entries between cellular phones and other devices with PIM applications.</p></div><div class=paragraph><p>The OBEX server and client are implemented as a third-party package obexapp, which is available as <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a> port.</p></div><div class=paragraph><p>OBEX client is used to push and/or pull objects from the OBEX server. An object can, for example, be a business card or an appointment. The OBEX client can obtain RFCOMM channel number from the remote device via SDP. This can be done by specifying service name instead of RFCOMM channel number. Supported service names are: IrMC, FTRN and OPUSH. It is possible to specify RFCOMM channel as a number. Below is an example of an OBEX session, where device information object is pulled from the cellular phone, and a new object (business card) is pushed into the phone’s directory.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In order to provide OBEX Object Push service, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server must be running. A root folder, where all incoming objects will be stored, must be created. The default path to the root folder is <span class=filename>/var/spool/obex</span>. Finally, start OBEX server on valid RFCOMM channel number. The OBEX server will automatically register OBEX Object Push service with the local SDP daemon. The example below shows how to start OBEX server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect3><h4 id=_serial_port_profile_spp>56.4.10. Serial Port Profile (SPP)<a class=anchor href=#_serial_port_profile_spp></a></h4><div class=paragraph><p>The Serial Port Profile (SPP) allows Bluetooth devices to perform RS232 (or similar) serial cable emulation. The scenario covered by this profile deals with legacy applications using Bluetooth as a cable replacement, through a virtual serial port abstraction.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> utility implements the Serial Port profile. A pseudo tty is used as a virtual serial port abstraction. The example below shows how to connect to a remote device Serial Port service. Note that you do not have to specify a RFCOMM channel - <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> can obtain it from the remote device via SDP. If you would like to override this, specify a RFCOMM channel on the command line.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</span>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</code></pre></div></div><div class=paragraph><p>Once connected, the pseudo tty can be used as serial port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l ttyp6</span></code></pre></div></div></div><div class=sect3><h4 id=_troubleshooting_4>56.4.11. Troubleshooting<a class=anchor href=#_troubleshooting_4></a></h4><div class=sect4><h5 id=_a_remote_device_cannot_connect>56.4.11.1. A remote device cannot connect<a class=anchor href=#_a_remote_device_cannot_connect></a></h5><div class=paragraph><p>Some older Bluetooth devices do not support role switching. By default, when FreeBSD is accepting a new connection, it tries to perform a role switch and become master. Devices, which do not support this will not be able to connect. Note that role switching is performed when a new connection is being established, so it is not possible to ask the remote device if it does support role switching. There is a HCI option to disable role switching on the local side:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div></div><div class=sect4><h5 id=_something_is_going_wrong_can_i_see_what_exactly_is_happening>56.4.11.2. Something is going wrong, can I see what exactly is happening?<a class=anchor href=#_something_is_going_wrong_can_i_see_what_exactly_is_happening></a></h5><div class=paragraph><p>Yes, you can. Use the third-party package hcidump, which is available as <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> port. The hcidump utility is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. It can be used to display the content of the Bluetooth packets on the terminal and to dump the Bluetooth packets to a file.</p></div></div></div></div><div class=sect2><h3 id=network-bridging>56.5. Bridging<a class=anchor href=#network-bridging></a></h3><div class=sect3><h4 id=_introduction_4>56.5.1. Introduction<a class=anchor href=#_introduction_4></a></h4><div class=paragraph><p>It is sometimes useful to divide one physical network (such as an Ethernet segment) into two separate network segments without having to create IP subnets and use a router to connect the segments together. A device that connects two networks together in this fashion is called a "bridge". A FreeBSD system with two network interface cards can act as a bridge.</p></div><div class=paragraph><p>The bridge works by learning the MAC layer addresses (Ethernet addresses) of the devices on each of its network interfaces. It forwards traffic between two networks only when its source and destination are on different networks.</p></div><div class=paragraph><p>In many respects, a bridge is like an Ethernet switch with very few ports.</p></div></div><div class=sect3><h4 id=_situations_where_bridging_is_appropriate>56.5.2. Situations Where Bridging Is Appropriate<a class=anchor href=#_situations_where_bridging_is_appropriate></a></h4><div class=paragraph><p>There are two common situations in which a bridge is used today.</p></div><div class=sect4><h5 id=_high_traffic_on_a_segment>56.5.2.1. High Traffic on a Segment<a class=anchor href=#_high_traffic_on_a_segment></a></h5><div class=paragraph><p>Situation one is where your physical network segment is overloaded with traffic, but you do not want for whatever reason to subnet the network and interconnect the subnets with a router.</p></div><div class=paragraph><p>Let us consider an example of a newspaper where the Editorial and Production departments are on the same subnetwork. The Editorial users all use server <code>A</code> for file service, and the Production users are on server <code>B</code>. An Ethernet network is used to connect all users together, and high loads on the network are slowing things down.</p></div><div class=paragraph><p>If the Editorial users could be segregated on one network segment and the Production users on another, the two network segments could be connected with a bridge. Only the network traffic destined for interfaces on the "other" side of the bridge would be sent to the other network, reducing congestion on each network segment.</p></div></div><div class=sect4><h5 id=_filteringtraffic_shaping_firewall>56.5.2.2. Filtering/Traffic Shaping Firewall<a class=anchor href=#_filteringtraffic_shaping_firewall></a></h5><div class=paragraph><p>The second common situation is where firewall functionality is needed without network address translation (NAT).</p></div><div class=paragraph><p>An example is a small company that is connected via DSL or ISDN to their ISP. They have a 13 globally-accessible IP addresses from their ISP and have 10 PCs on their network. In this situation, using a router-based firewall is difficult because of subnetting issues.</p></div><div class=paragraph><p>A bridge-based firewall can be configured and dropped into the path just downstream of their DSL/ISDN router without any IP numbering issues.</p></div></div></div><div class=sect3><h4 id=_configuring_a_bridge>56.5.3. Configuring a Bridge<a class=anchor href=#_configuring_a_bridge></a></h4><div class=sect4><h5 id=_network_interface_card_selection>56.5.3.1. Network Interface Card Selection<a class=anchor href=#_network_interface_card_selection></a></h5><div class=paragraph><p>A bridge requires at least two network cards to function. Unfortunately, not all network interface cards support bridging. Read <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> for details on the cards that are supported.</p></div><div class=paragraph><p>Install and test the two network cards before continuing.</p></div></div><div class=sect4><h5 id=_kernel_configuration_changes>56.5.3.2. Kernel Configuration Changes<a class=anchor href=#_kernel_configuration_changes></a></h5><div class=paragraph><p>To enable kernel support for bridging, add the:</p></div><div class="literalblock programlisting"><div class=content><pre>options BRIDGE</pre></div></div><div class=paragraph><p>statement to your kernel configuration file, and rebuild your kernel.</p></div></div><div class=sect4><h5 id=_firewall_support>56.5.3.3. Firewall Support<a class=anchor href=#_firewall_support></a></h5><div class=paragraph><p>If you are planning to use the bridge as a firewall, you will need to add the <code>IPFIREWALL</code> option as well. Read <a href=./#firewalls>Firewalls</a> for general information on configuring the bridge as a firewall.</p></div><div class=paragraph><p>If you need to allow non-IP packets (such as ARP) to flow through the bridge, there are three options available. The first is to add the following option to the kernel and rebuild:</p></div><div class="literalblock programlisting"><div class=content><pre>option	IPFIREWALL_DEFAULT_TO_ACCEPT</pre></div></div><div class=paragraph><p>The second is to set the firewall type to “open” in the <span class=filename>rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>firewall_type=&#34;open&#34;</pre></div></div><div class=paragraph><p>Note that these options will make the firewall seem completely transparent; any packet or connection will be permitted by default. This may require significant changes to the firewall ruleset.</p></div><div class=paragraph><p>The third option is to apply the following <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> rule:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw add allow mac-type arp layer2</span></code></pre></div></div><div class=paragraph><p>Or add it to the current firewall ruleset. This rule effectively allows <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> packets through, so it must be be applied near the beginning of the ruleset for early evaluation.</p></div></div><div class=sect4><h5 id=_traffic_shaping_support>56.5.3.4. Traffic Shaping Support<a class=anchor href=#_traffic_shaping_support></a></h5><div class=paragraph><p>If you want to use the bridge as a traffic shaper, you will need to add the <code>DUMMYNET</code> option to your kernel configuration. Read <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> for further information.</p></div></div></div><div class=sect3><h4 id=_enabling_the_bridge>56.5.4. Enabling the Bridge<a class=anchor href=#_enabling_the_bridge></a></h4><div class=paragraph><p>Add the line:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.enable=1</pre></div></div><div class=paragraph><p>to <span class=filename>/etc/sysctl.conf</span> to enable the bridge at runtime, and the line:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.config=if1,if2</pre></div></div><div class=paragraph><p>to enable bridging on the specified interfaces (replace <em>if1</em> and <em>if2</em> with the names of your two network interfaces). If you want the bridged packets to be filtered by <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, you should add:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.ipfw=1</pre></div></div><div class=paragraph><p>as well.</p></div><div class=paragraph><p>For versions prior to FreeBSD 5.2-RELEASE, use instead the following lines:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge=1
net.link.ether.bridge_cfg=if1,if2
net.link.ether.bridge_ipfw=1</pre></div></div></div><div class=sect3><h4 id=_other_information>56.5.5. Other Information<a class=anchor href=#_other_information></a></h4><div class=paragraph><p>If you want to be able to <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> into the bridge from the network, it is correct to assign one of the network cards an IP address. The consensus is that assigning both cards an address is a bad idea.</p></div><div class=paragraph><p>If you have multiple bridges on your network, there cannot be more than one path between any two workstations. Technically, this means that there is no support for spanning tree link management.</p></div><div class=paragraph><p>A bridge can add latency to your <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> times, especially for traffic from one segment to another.</p></div></div></div><div class=sect2><h3 id=network-diskless>56.6. Diskless Operation<a class=anchor href=#network-diskless></a></h3><div class=paragraph><p>A FreeBSD machine can boot over the network and operate without a local disk, using file systems mounted from an NFS server. No system modification is necessary, beyond standard configuration files. Such a system is relatively easy to set up because all the necessary elements are readily available:</p></div><div class=ulist><ul><li><p>There are at least two possible methods to load the kernel over the network:</p><div class=ulist><ul><li><p>PXE: The Intel® Preboot eXecution Environment system is a form of smart boot ROM built into some networking cards or motherboards. See <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> for more details.</p></li><li><p>The Etherboot port (<a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a>) produces ROM-able code to boot kernels over the network. The code can be either burnt into a boot PROM on a network card, or loaded from a local floppy (or hard) disk drive, or from a running MS-DOS® system. Many network cards are supported.</p></li></ul></div></li><li><p>A sample script (<span class=filename>/usr/shared/examples/diskless/clone_root</span>) eases the creation and maintenance of the workstation’s root file system on the server. The script will probably require a little customization but it will get you started very quickly.</p></li><li><p>Standard system startup files exist in <span class=filename>/etc</span> to detect and support a diskless system startup.</p></li><li><p>Swapping, if needed, can be done either to an NFS file or to a local disk.</p></li></ul></div><div class=paragraph><p>There are many ways to set up diskless workstations. Many elements are involved, and most can be customized to suit local taste. The following will describe variations on the setup of a complete system, emphasizing simplicity and compatibility with the standard FreeBSD startup scripts. The system described has the following characteristics:</p></div><div class=ulist><ul><li><p>The diskless workstations use a shared read-only <span class=filename>/</span> file system, and a shared read-only <span class=filename>/usr</span>.</p><div class=paragraph><p>The root file system is a copy of a standard FreeBSD root (typically the server’s), with some configuration files overridden by ones specific to diskless operation or, possibly, to the workstation they belong to.</p></div><div class=paragraph><p>The parts of the root which have to be writable are overlaid with <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> file systems. Any changes will be lost when the system reboots.</p></div></li><li><p>The kernel is transferred and loaded either with Etherboot or PXE as some situations may mandate the use of either method.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>As described, this system is insecure. It should live in a protected area of a network, and be untrusted by other hosts.</p></div></td></tr></tbody></table></div><div class=paragraph><p>All the information in this section has been tested using FreeBSD 5.2.1-RELEASE.</p></div><div class=sect3><h4 id=_background_information>56.6.1. Background Information<a class=anchor href=#_background_information></a></h4><div class=paragraph><p>Setting up diskless workstations is both relatively straightforward and prone to errors. These are sometimes difficult to diagnose for a number of reasons. For example:</p></div><div class=ulist><ul><li><p>Compile time options may determine different behaviors at runtime.</p></li><li><p>Error messages are often cryptic or totally absent.</p></li></ul></div><div class=paragraph><p>In this context, having some knowledge of the background mechanisms involved is very useful to solve the problems that may arise.</p></div><div class=paragraph><p>Several operations need to be performed for a successful bootstrap:</p></div><div class=ulist><ul><li><p>The machine needs to obtain initial parameters such as its IP address, executable filename, server name, root path. This is done using the DHCP or BOOTP protocols. DHCP is a compatible extension of BOOTP, and uses the same port numbers and basic packet format.</p><div class=paragraph><p>It is possible to configure a system to use only BOOTP. The <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> server program is included in the base FreeBSD system.</p></div><div class=paragraph><p>However, DHCP has a number of advantages over BOOTP (nicer configuration files, possibility of using PXE, plus many others not directly related to diskless operation), and we will describe mainly a DHCP configuration, with equivalent examples using <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> when possible. The sample configuration will use the ISC DHCP software package (release 3.0.1.r12 was installed on the test server).</p></div></li><li><p>The machine needs to transfer one or several programs to local memory. Either TFTP or NFS are used. The choice between TFTP and NFS is a compile time option in several places. A common source of error is to specify filenames for the wrong protocol: TFTP typically transfers all files from a single directory on the server, and would expect filenames relative to this directory. NFS needs absolute file paths.</p></li><li><p>The possible intermediate bootstrap programs and the kernel need to be initialized and executed. There are several important variations in this area:</p><div class=ulist><ul><li><p>PXE will load <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a>, which is a modified version of the FreeBSD third stage loader. The <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> will obtain most parameters necessary to system startup, and leave them in the kernel environment before transferring control. It is possible to use a <span class=filename>GENERIC</span> kernel in this case.</p></li><li><p>Etherboot, will directly load the kernel, with less preparation. You will need to build a kernel with specific options.</p><div class=paragraph><p>PXE and Etherboot work equally well; however, because kernels normally let the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> do more work for them, PXE is the preferred method.</p></div><div class=paragraph><p>If your BIOS and network cards support PXE, you should probably use it.</p></div></li></ul></div></li><li><p>Finally, the machine needs to access its file systems. NFS is used in all cases.</p></li></ul></div><div class=paragraph><p>See also <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> manual page.</p></div></div><div class=sect3><h4 id=_setup_instructions>56.6.2. Setup Instructions<a class=anchor href=#_setup_instructions></a></h4><div class=sect4><h5 id=_configuration_using_isc_dhcp>56.6.2.1. Configuration Using ISC DHCP<a class=anchor href=#_configuration_using_isc_dhcp></a></h5><div class=paragraph><p>The ISC DHCP server can answer both BOOTP and DHCP requests.</p></div><div class=paragraph><p>ISC DHCP 3.0 is not part of the base system. You will first need to install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port or the corresponding package.</p></div><div class=paragraph><p>Once ISC DHCP is installed, it needs a configuration file to run (normally named <span class=filename>/usr/local/etc/dhcpd.conf</span>). Here follows a commented example, where host <code>margaux</code> uses Etherboot and host <code>corbieres</code> uses PXE:</p></div><div class="literalblock programlisting"><div class=content><pre>default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name &#34;example.com&#34;;
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <i class=conum data-value=1></i><b>(1)</b>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <i class=conum data-value=2></i><b>(2)</b>
    filename &#34;/data/misc/kernel.diskless&#34;; <i class=conum data-value=3></i><b>(3)</b>
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;; <i class=conum data-value=4></i><b>(4)</b>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename &#34;pxeboot&#34;;
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;;
  }
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This option tells dhcpd to send the value in the <code>host</code> declarations as the hostname for the diskless host. An alternate way would be to add an <code>option host-name margaux</code> inside the <code>host</code> declarations.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>next-server</code> directive designates the TFTP or NFS server to use for loading loader or kernel file (the default is to use the same host as the DHCP server).</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>filename</code> directive defines the file that Etherboot or PXE will load for the next execution step. It must be specified according to the transfer method used. Etherboot can be compiled to use NFS or TFTP. The FreeBSD port configures NFS by default. PXE uses TFTP, which is why a relative filename is used here (this may depend on the TFTP server configuration, but would be fairly typical). Also, PXE loads <span class=filename>pxeboot</span>, not the kernel. There are other interesting possibilities, like loading <span class=filename>pxeboot</span> from a FreeBSD CD-ROM <span class=filename>/boot</span> directory (as <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> can load a <span class=filename>GENERIC</span> kernel, this makes it possible to use PXE to boot from a remote CD-ROM).</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>root-path</code> option defines the path to the root file system, in usual NFS notation. When using PXE, it is possible to leave off the host’s IP as long as you do not enable the kernel option BOOTP. The NFS server will then be the same as the TFTP one.</td></tr></tbody></table></div></div><div class=sect4><h5 id=_configuration_using_bootp>56.6.2.2. Configuration Using BOOTP<a class=anchor href=#_configuration_using_bootp></a></h5><div class=paragraph><p>Here follows an equivalent bootpd configuration (reduced to one client). This would be found in <span class=filename>/etc/bootptab</span>.</p></div><div class=paragraph><p>Please note that Etherboot must be compiled with the non-default option <code>NO_DHCP_SUPPORT</code> in order to use BOOTP, and that PXE_needs_DHCP. The only obvious advantage of bootpd is that it exists in the base system.</p></div><div class="literalblock programlisting"><div class=content><pre>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd=&#34;/tftpboot&#34;:\
  :bf=&#34;/kernel.diskless&#34;:\
  :rp=&#34;192.168.4.4:/data/misc/diskless&#34;:

margaux:ha=0123456789ab:tc=.def100</pre></div></div></div><div class=sect4><h5 id=_preparing_a_boot_program_with_etherboot>56.6.2.3. Preparing a Boot Program with Etherboot<a class=anchor href=#_preparing_a_boot_program_with_etherboot></a></h5><div class=paragraph><p><a href=http://etherboot.sourceforge.net>Etherboot’s Web site</a> contains <a href=http://etherboot.sourceforge.net/doc/html/userman/t1.html>extensive documentation</a> mainly intended for Linux systems, but nonetheless containing useful information. The following will just outline how you would use Etherboot on a FreeBSD system.</p></div><div class=paragraph><p>You must first install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a> package or port.</p></div><div class=paragraph><p>You can change the Etherboot configuration (i.e. to use TFTP instead of NFS) by editing the <span class=filename>Config</span> file in the Etherboot source directory.</p></div><div class=paragraph><p>For our setup, we shall use a boot floppy. For other methods (PROM, or MS-DOS® program), please refer to the Etherboot documentation.</p></div><div class=paragraph><p>To make a boot floppy, insert a floppy in the drive on the machine where you installed Etherboot, then change your current directory to the <span class=filename>src</span> directory in the Etherboot tree and type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmake bin32/devicetype.fd0</span></code></pre></div></div><div class=paragraph><p><em>devicetype</em> depends on the type of the Ethernet card in the diskless workstation. Refer to the <span class=filename>NIC</span> file in the same directory to determine the right <em>devicetype</em>.</p></div></div><div class=sect4><h5 id=_booting_with_pxe>56.6.2.4. Booting with PXE<a class=anchor href=#_booting_with_pxe></a></h5><div class=paragraph><p>By default, the <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> loader loads the kernel via NFS. It can be compiled to use TFTP instead by specifying the <code>LOADER_TFTP_SUPPORT</code> option in <span class=filename>/etc/make.conf</span>. See the comments in <span class=filename>/usr/shared/examples/etc/make.conf</span> for instructions.</p></div><div class=paragraph><p>There are two other <span class=filename>make.conf</span> options which may be useful for setting up a serial console diskless machine: <code>BOOT_PXELDR_PROBE_KEYBOARD</code>, and <code>BOOT_PXELDR_ALWAYS_SERIAL</code>.</p></div><div class=paragraph><p>To use PXE when the machine starts, you will usually need to select the <code>Boot from network</code> option in your BIOS setup, or type a function key during the PC initialization.</p></div></div><div class=sect4><h5 id=_configuring_the_tftp_and_nfs_servers>56.6.2.5. Configuring the TFTP and NFS Servers<a class=anchor href=#_configuring_the_tftp_and_nfs_servers></a></h5><div class=paragraph><p>If you are using PXE or Etherboot configured to use TFTP, you need to enable tftpd on the file server:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Create a directory from which tftpd will serve the files, e.g. <span class=filename>/tftpboot</span>.</p></li><li><p>Add this line to your <span class=filename>/etc/inetd.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It appears that at least some PXE versions want the TCP version of TFTP. In this case, add a second line, replacing <code>dgram udp</code> with <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Tell inetd to reread its configuration file. The <code>inetd_enable="YES"</code> must be in the <span class=filename>/etc/rc.conf</span> file for this command to execute correctly:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/inetd restart</span></code></pre></div></div></li></ol></div><div class=paragraph><p>You can place the <span class=filename>tftpboot</span> directory anywhere on the server. Make sure that the location is set in both <span class=filename>inetd.conf</span> and <span class=filename>dhcpd.conf</span>.</p></div><div class=paragraph><p>In all cases, you also need to enable NFS and export the appropriate file system on the NFS server.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Add this to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Export the file system where the diskless root directory is located by adding the following to <span class=filename>/etc/exports</span> (adjust the volume mount point and replace <em>margaux corbieres</em> with the names of the diskless workstations):</p><div class="literalblock programlisting"><div class=content><pre>/data/misc -alldirs -ro margaux corbieres</pre></div></div></li><li><p>Tell mountd to reread its configuration file. If you actually needed to enable NFS in <span class=filename>/etc/rc.conf</span> at the first step, you probably want to reboot instead.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/mountd restart</span></code></pre></div></div></li></ol></div></div><div class=sect4><h5 id=_building_a_diskless_kernel>56.6.2.6. Building a Diskless Kernel<a class=anchor href=#_building_a_diskless_kernel></a></h5><div class=paragraph><p>If using Etherboot, you need to create a kernel configuration file for the diskless client with the following options (in addition to the usual ones):</p></div><div class="literalblock programlisting"><div class=content><pre>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</pre></div></div><div class=paragraph><p>You may also want to use <code>BOOTP_NFSV3</code>, <code>BOOT_COMPAT</code> and <code>BOOTP_WIRED_TO</code> (refer to <span class=filename>NOTES</span>).</p></div><div class=paragraph><p>These option names are historical and slightly misleading as they actually enable indifferent use of DHCP and BOOTP inside the kernel (it is also possible to force strict BOOTP or DHCP use).</p></div><div class=paragraph><p>Build the kernel (see <a href=./#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>), and copy it to the place specified in <span class=filename>dhcpd.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When using PXE, building a kernel with the above options is not strictly necessary (though suggested). Enabling them will cause more DHCP requests to be issued during kernel startup, with a small risk of inconsistency between the new values and those retrieved by <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> in some special cases. The advantage of using them is that the host name will be set as a side effect. Otherwise you will need to set the host name by another method, for example in a client-specific <span class=filename>rc.conf</span> file.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to be loadable with Etherboot, a kernel needs to have the device hints compiled in. You would typically set the following option in the configuration file (see the <span class=filename>NOTES</span> configuration comments file):</p></div><div class="literalblock programlisting"><div class=content><pre>hints		&#34;GENERIC.hints&#34;</pre></div></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_preparing_the_root_filesystem>56.6.2.7. Preparing the Root Filesystem<a class=anchor href=#_preparing_the_root_filesystem></a></h5><div class=paragraph><p>You need to create a root file system for the diskless workstations, in the location listed as <code>root-path</code> in <span class=filename>dhcpd.conf</span>.</p></div><div class=sect5><h6 id=_using_make_world_to_populate_root>56.6.2.7.1. Using <code>make world</code> to populate root<a class=anchor href=#_using_make_world_to_populate_root></a></h6><div class=paragraph><p>This method is quick and will install a complete virgin system (not only the root file system) into <code>DESTDIR</code>. All you have to do is simply execute the following script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
cd /usr/src/etc; make distribution</pre></div></div><div class=paragraph><p>Once done, you may need to customize your <span class=filename>/etc/rc.conf</span> and <span class=filename>/etc/fstab</span> placed into <code>DESTDIR</code> according to your needs.</p></div></div></div><div class=sect4><h5 id=_configuring_swap>56.6.2.8. Configuring Swap<a class=anchor href=#_configuring_swap></a></h5><div class=paragraph><p>If needed, a swap file located on the server can be accessed via NFS.</p></div><div class=sect5><h6 id=_nfs_swap>56.6.2.8.1. NFS Swap<a class=anchor href=#_nfs_swap></a></h6><div class=paragraph><p>The kernel does not support enabling NFS swap at boot time. Swap must be enabled by the startup scripts, by mounting a writable file system and creating and enabling a swap file. To create a swap file of appropriate size, you can do like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</span></code></pre></div></div><div class=paragraph><p>To enable it you have to add the following line to your <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>swapfile=/path/to/swapfile</pre></div></div></div></div><div class=sect4><h5 id=_miscellaneous_issues>56.6.2.9. Miscellaneous Issues<a class=anchor href=#_miscellaneous_issues></a></h5><div class=sect5><h6 id=_running_with_a_read_only_usr>56.6.2.9.1. Running with a Read-only <span class=filename>/usr</span><a class=anchor href=#_running_with_a_read_only_usr></a></h6><div class=paragraph><p>If the diskless workstation is configured to run X, you will have to adjust the XDM configuration file, which puts the error log on <span class=filename>/usr</span> by default.</p></div></div><div class=sect5><h6 id=_using_a_non_freebsd_server>56.6.2.9.2. Using a Non-FreeBSD Server<a class=anchor href=#_using_a_non_freebsd_server></a></h6><div class=paragraph><p>When the server for the root file system is not running FreeBSD, you will have to create the root file system on a FreeBSD machine, then copy it to its destination, using <code>tar</code> or <code>cpio</code>.</p></div><div class=paragraph><p>In this situation, there are sometimes problems with the special files in <span class=filename>/dev</span>, due to differing major/minor integer sizes. A solution to this problem is to export a directory from the non-FreeBSD server, mount this directory onto a FreeBSD machine, and use <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> to allocate device nodes transparently for the user.</p></div></div></div></div></div><div class=sect2><h3 id=network-isdn>56.7. ISDN<a class=anchor href=#network-isdn></a></h3><div class=paragraph><p>A good resource for information on ISDN technology and hardware is <a href=http://www.alumni.caltech.edu/~dank/isdn/>Dan Kegel’s ISDN Page</a>.</p></div><div class=paragraph><p>A quick simple road map to ISDN follows:</p></div><div class=ulist><ul><li><p>If you live in Europe you might want to investigate the ISDN card section.</p></li><li><p>If you are planning to use ISDN primarily to connect to the Internet with an Internet Provider on a dial-up non-dedicated basis, you might look into Terminal Adapters. This will give you the most flexibility, with the fewest problems, if you change providers.</p></li><li><p>If you are connecting two LANs together, or connecting to the Internet with a dedicated ISDN connection, you might consider the stand alone router/bridge option.</p></li></ul></div><div class=paragraph><p>Cost is a significant factor in determining what solution you will choose. The following options are listed from least expensive to most expensive.</p></div><div class=sect3><h4 id=network-isdn-cards>56.7.1. ISDN Cards<a class=anchor href=#network-isdn-cards></a></h4><div class=paragraph><p>FreeBSD’s ISDN implementation supports only the DSS1/Q.931 (or Euro-ISDN) standard using passive cards. Some active cards are supported where the firmware also supports other signaling protocols; this also includes the first supported Primary Rate (PRI) ISDN card.</p></div><div class=paragraph><p>The isdn4bsd software allows you to connect to other ISDN routers using either IP over raw HDLC or by using synchronous PPP: either by using kernel PPP with <code>isppp</code>, a modified <a href="https://man.freebsd.org/cgi/man.cgi?query=sppp&amp;sektion=4&amp;format=html">sppp(4)</a> driver, or by using userland <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>. By using userland <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>, channel bonding of two or more ISDN B-channels is possible. A telephone answering machine application is also available as well as many utilities such as a software 300 Baud modem.</p></div><div class=paragraph><p>Some growing number of PC ISDN cards are supported under FreeBSD and the reports show that it is successfully used all over Europe and in many other parts of the world.</p></div><div class=paragraph><p>The passive ISDN cards supported are mostly the ones with the Infineon (formerly Siemens) ISAC/HSCX/IPAC ISDN chipsets, but also ISDN cards with chips from Cologne Chip (ISA bus only), PCI cards with Winbond W6692 chips, some cards with the Tiger300/320/ISAC chipset combinations and some vendor specific chipset based cards such as the AVM Fritz!Card PCI V.1.0 and the AVM Fritz!Card PnP.</p></div><div class=paragraph><p>Currently the active supported ISDN cards are the AVM B1 (ISA and PCI) BRI cards and the AVM T1 PCI PRI cards.</p></div><div class=paragraph><p>For documentation on isdn4bsd, have a look at <span class=filename>/usr/shared/examples/isdn/</span> directory on your FreeBSD system or at the <a href=http://www.freebsd-support.de/i4b/>homepage of isdn4bsd</a> which also has pointers to hints, erratas and much more documentation such as the <a href=http://people.FreeBSD.org/~hm/>isdn4bsd handbook</a>.</p></div><div class=paragraph><p>In case you are interested in adding support for a different ISDN protocol, a currently unsupported ISDN PC card or otherwise enhancing isdn4bsd, please get in touch with Hellmuth Michaelis &lt;<a href=mailto:hm@FreeBSD.org>hm@FreeBSD.org</a>>.</p></div><div class=paragraph><p>For questions regarding the installation, configuration and troubleshooting isdn4bsd, a <a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a> mailing list is available.</p></div></div><div class=sect3><h4 id=_isdn_terminal_adapters>56.7.2. ISDN Terminal Adapters<a class=anchor href=#_isdn_terminal_adapters></a></h4><div class=paragraph><p>Terminal adapters (TA), are to ISDN what modems are to regular phone lines.</p></div><div class=paragraph><p>Most TA’s use the standard Hayes modem AT command set, and can be used as a drop in replacement for a modem.</p></div><div class=paragraph><p>A TA will operate basically the same as a modem except connection and throughput speeds will be much faster than your old modem. You will need to configure <a href=./#ppp>PPP</a> exactly the same as for a modem setup. Make sure you set your serial speed as high as possible.</p></div><div class=paragraph><p>The main advantage of using a TA to connect to an Internet Provider is that you can do Dynamic PPP. As IP address space becomes more and more scarce, most providers are not willing to provide you with a static IP anymore. Most stand-alone routers are not able to accommodate dynamic IP allocation.</p></div><div class=paragraph><p>TA’s completely rely on the PPP daemon that you are running for their features and stability of connection. This allows you to upgrade easily from using a modem to ISDN on a FreeBSD machine, if you already have PPP set up. However, at the same time any problems you experienced with the PPP program and are going to persist.</p></div><div class=paragraph><p>If you want maximum stability, use the kernel <a href=./#ppp>PPP</a> option, not the <a href=./#userppp>userland PPP</a>.</p></div><div class=paragraph><p>The following TA’s are known to work with FreeBSD:</p></div><div class=ulist><ul><li><p>Motorola BitSurfer and Bitsurfer Pro</p></li><li><p>Adtran</p></li></ul></div><div class=paragraph><p>Most other TA’s will probably work as well, TA vendors try to make sure their product can accept most of the standard modem AT command set.</p></div><div class=paragraph><p>The real problem with external TA’s is that, like modems, you need a good serial card in your computer.</p></div><div class=paragraph><p>You should read the <a href=https://docs.freebsd.org/en/articles/serial-uart/>FreeBSD Serial Hardware</a> tutorial for a detailed understanding of serial devices, and the differences between asynchronous and synchronous serial ports.</p></div><div class=paragraph><p>A TA running off a standard PC serial port (asynchronous) limits you to 115.2 Kbs, even though you have a 128 Kbs connection. To fully utilize the 128 Kbs that ISDN is capable of, you must move the TA to a synchronous serial card.</p></div><div class=paragraph><p>Do not be fooled into buying an internal TA and thinking you have avoided the synchronous/asynchronous issue. Internal TA’s simply have a standard PC serial port chip built into them. All this will do is save you having to buy another serial cable and find another empty electrical socket.</p></div><div class=paragraph><p>A synchronous card with a TA is at least as fast as a stand-alone router, and with a simple 386 FreeBSD box driving it, probably more flexible.</p></div><div class=paragraph><p>The choice of synchronous card/TA v.s. stand-alone router is largely a religious issue. There has been some discussion of this in the mailing lists. We suggest you search the <a href=https://www.FreeBSD.org/search/>archives</a> for the complete discussion.</p></div></div><div class=sect3><h4 id=_stand_alone_isdn_bridgesrouters>56.7.3. Stand-alone ISDN Bridges/Routers<a class=anchor href=#_stand_alone_isdn_bridgesrouters></a></h4><div class=paragraph><p>ISDN bridges or routers are not at all specific to FreeBSD or any other operating system. For a more complete description of routing and bridging technology, please refer to a networking reference book.</p></div><div class=paragraph><p>In the context of this section, the terms router and bridge will be used interchangeably.</p></div><div class=paragraph><p>As the cost of low end ISDN routers/bridges comes down, it will likely become a more and more popular choice. An ISDN router is a small box that plugs directly into your local Ethernet network, and manages its own connection to the other bridge/router. It has built in software to communicate via PPP and other popular protocols.</p></div><div class=paragraph><p>A router will allow you much faster throughput than a standard TA, since it will be using a full synchronous ISDN connection.</p></div><div class=paragraph><p>The main problem with ISDN routers and bridges is that interoperability between manufacturers can still be a problem. If you are planning to connect to an Internet provider, you should discuss your needs with them.</p></div><div class=paragraph><p>If you are planning to connect two LAN segments together, such as your home LAN to the office LAN, this is the simplest lowest maintenance solution. Since you are buying the equipment for both sides of the connection you can be assured that the link will work.</p></div><div class=paragraph><p>For example to connect a home computer or branch office network to a head office network the following setup could be used:</p></div><div class=exampleblock><div class=title>Παράδειγμα 26. Branch Office or Home Network</div><div class=content><div class=paragraph><p>Network uses a bus based topology with 10 base 2 Ethernet ("thinnet"). Connect router to network cable with AUI/10BT transceiver, if necessary.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-bus.png alt="10 Base 2 Ethernet"></div></div><div class=paragraph><p>If your home/branch office is only one computer you can use a twisted pair crossover cable to connect to the stand-alone router directly.</p></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 27. Head Office or Other LAN</div><div class=content><div class=paragraph><p>Network uses a star topology with 10 base T Ethernet ("Twisted Pair").</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-twisted-pair.png alt="ISDN Network Diagram"></div></div></div></div><div class=paragraph><p>One large advantage of most routers/bridges is that they allow you to have 2 <em>separate independent</em> PPP connections to 2 separate sites at the <em>same</em> time. This is not supported on most TA’s, except for specific (usually expensive) models that have two serial ports. Do not confuse this with channel bonding, MPP, etc.</p></div><div class=paragraph><p>This can be a very useful feature if, for example, you have an dedicated ISDN connection at your office and would like to tap into it, but do not want to get another ISDN line at work. A router at the office location can manage a dedicated B channel connection (64 Kbps) to the Internet and use the other B channel for a separate data connection. The second B channel can be used for dial-in, dial-out or dynamically bonding (MPP, etc.) with the first B channel for more bandwidth.</p></div><div class=paragraph><p>An Ethernet bridge will also allow you to transmit more than just IP traffic. You can also send IPX/SPX or whatever other protocols you use.</p></div></div></div><div class=sect2><h3 id=network-natd>56.8. Network Address Translation<a class=anchor href=#network-natd></a></h3><div class=sect3><h4 id=network-natoverview>56.8.1. Overview<a class=anchor href=#network-natoverview></a></h4><div class=paragraph><p>FreeBSD’s Network Address Translation daemon, commonly known as <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> is a daemon that accepts incoming raw IP packets, changes the source to the local machine and re-injects these packets back into the outgoing IP packet stream. <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> does this by changing the source IP address and port such that when data is received back, it is able to determine the original location of the data and forward it back to its original requester.</p></div><div class=paragraph><p>The most common use of NAT is to perform what is commonly known as Internet Connection Sharing.</p></div></div><div class=sect3><h4 id=network-natsetup>56.8.2. Setup<a class=anchor href=#network-natsetup></a></h4><div class=paragraph><p>Due to the diminishing IP space in IPv4, and the increased number of users on high-speed consumer lines such as cable or DSL, people are increasingly in need of an Internet Connection Sharing solution. The ability to connect several computers online through one connection and IP address makes <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> a reasonable choice.</p></div><div class=paragraph><p>Most commonly, a user has a machine connected to a cable or DSL line with one IP address and wishes to use this one connected computer to provide Internet access to several more over a LAN.</p></div><div class=paragraph><p>To do this, the FreeBSD machine on the Internet must act as a gateway. This gateway machine must have two NICs-one for connecting to the Internet router, the other connecting to a LAN. All the machines on the LAN are connected through a hub or switch.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>There are many ways to get a LAN connected to the Internet through a FreeBSD gateway. This example will only cover a gateway with at least two NICs.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/natd.png alt="Network Layout"></div></div><div class=paragraph><p>A setup like this is commonly used to share an Internet connection. One of the LAN machines is connected to the Internet. The rest of the machines access the Internet through that "gateway" machine.</p></div></div><div class=sect3><h4 id=network-natdkernconfiguration>56.8.3. Configuration<a class=anchor href=#network-natdkernconfiguration></a></h4><div class=paragraph><p>The following options must be in the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL
options IPDIVERT</pre></div></div><div class=paragraph><p>Additionally, at choice, the following may also be suitable:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</pre></div></div><div class=paragraph><p>The following must be in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34; <i class=conum data-value=1></i><b>(1)</b>
firewall_enable=&#34;YES&#34; <i class=conum data-value=2></i><b>(2)</b>
firewall_type=&#34;OPEN&#34; <i class=conum data-value=3></i><b>(3)</b>
natd_enable=&#34;YES&#34;
natd_interface=&#34;fxp0&#34; <i class=conum data-value=4></i><b>(4)</b>
natd_flags=&#34;&#34; <i class=conum data-value=5></i><b>(5)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Sets up the machine to act as a gateway. Running <code>sysctl net.inet.ip.forwarding=1</code> would have the same effect.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Enables the firewall rules in <span class=filename>/etc/rc.firewall</span> at boot.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>This specifies a predefined firewall ruleset that allows anything in. See <span class=filename>/etc/rc.firewall</span> for additional types.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Indicates which interface to forward packets through (the interface connected to the Internet).</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Any additional configuration options passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> on boot.</td></tr></tbody></table></div><div class=paragraph><p>Having the previous options defined in <span class=filename>/etc/rc.conf</span> would run <code>natd -interface fxp0</code> at boot. This can also be run manually.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is also possible to use a configuration file for <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> when there are too many options to pass. In this case, the configuration file must be defined by adding the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class=paragraph><p>The <span class=filename>/etc/natd.conf</span> file will contain a list of configuration options, one per line. For example the next section case would use the following file:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>For more information about the configuration file, consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> manual page about the <code>-f</code> option.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Each machine and interface behind the LAN should be assigned IP address numbers in the private network space as defined by <a href=ftp://ftp.isi.edu/in-notes/rfc1918.txt>RFC 1918</a> and have a default gateway of the natd machine’s internal IP address.</p></div><div class=paragraph><p>For example, client <code>A</code> and <code>B</code> behind the LAN have IP addresses of <code>192.168.0.2</code> and <code>192.168.0.3</code>, while the natd machine’s LAN interface has an IP address of <code>192.168.0.1</code>. Client <code>A</code> and <code>B</code>'s default gateway must be set to that of the natd machine, <code>192.168.0.1</code>. The natd machine’s external, or Internet interface does not require any special modification for <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> to work.</p></div></div><div class=sect3><h4 id=network-natdport-redirection>56.8.4. Port Redirection<a class=anchor href=#network-natdport-redirection></a></h4><div class=paragraph><p>The drawback with <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> is that the LAN clients are not accessible from the Internet. Clients on the LAN can make outgoing connections to the world but cannot receive incoming ones. This presents a problem if trying to run Internet services on one of the LAN client machines. A simple way around this is to redirect selected Internet ports on the natd machine to a LAN client.</p></div><div class=paragraph><p>For example, an IRC server runs on client <code>A</code>, and a web server runs on client <code>B</code>. For this to work properly, connections received on ports 6667 (IRC) and 80 (web) must be redirected to the respective machines.</p></div><div class=paragraph><p>The <code>-redirect_port</code> must be passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> with the proper options. The syntax is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>In the above example, the argument should be:</p></div><div class="literalblock programlisting"><div class=content><pre>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=literalblock><div class=content><pre>This will redirect the proper _tcp_ ports to the LAN client machines.</pre></div></div><div class=paragraph><p>The <code>-redirect_port</code> argument can be used to indicate port ranges over individual ports. For example, <em>tcp 192.168.0.2:2000-3000 2000-3000</em> would redirect all connections received on ports 2000 to 3000 to ports 2000 to 3000 on client <code>A</code>.</p></div><div class=paragraph><p>These options can be used when directly running <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, placed within the <code>natd_flags=""</code> option in <span class=filename>/etc/rc.conf</span>, or passed via a configuration file.</p></div><div class=paragraph><p>For further configuration options, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a></p></div></div><div class=sect3><h4 id=network-natdaddress-redirection>56.8.5. Address Redirection<a class=anchor href=#network-natdaddress-redirection></a></h4><div class=paragraph><p>Address redirection is useful if several IP addresses are available, yet they must be on one machine. With this, <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> can assign each LAN client its own external IP address. <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> then rewrites outgoing packets from the LAN clients with the proper external IP address and redirects all traffic incoming on that particular IP address back to the specific LAN client. This is also known as static NAT. For example, the IP addresses <code>128.1.1.1</code>, <code>128.1.1.2</code>, and <code>128.1.1.3</code> belong to the natd gateway machine. <code>128.1.1.1</code> can be used as the natd gateway machine’s external IP address, while <code>128.1.1.2</code> and <code>128.1.1.3</code> are forwarded back to LAN clients <code>A</code> and <code>B</code>.</p></div><div class=paragraph><p>The <code>-redirect_address</code> syntax is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address localIP publicIP</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>localIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The internal IP address of the LAN client.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>publicIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The external IP address corresponding to the LAN client.</p></td></tr></tbody></table><div class=paragraph><p>In the example, this argument would read:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Like <code>-redirect_port</code>, these arguments are also placed within the <code>natd_flags=""</code> option of <span class=filename>/etc/rc.conf</span>, or passed via a configuration file. With address redirection, there is no need for port redirection since all data received on a particular IP address is redirected.</p></div><div class=paragraph><p>The external IP addresses on the natd machine must be active and aliased to the external interface. Look at <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> to do so.</p></div></div></div><div class=sect2><h3 id=network-plip>56.9. Parallel Line IP (PLIP)<a class=anchor href=#network-plip></a></h3><div class=paragraph><p>PLIP lets us run TCP/IP between parallel ports. It is useful on machines without network cards, or to install on laptops. In this section, we will discuss:</p></div><div class=ulist><ul><li><p>Creating a parallel (laplink) cable.</p></li><li><p>Connecting two computers with PLIP.</p></li></ul></div><div class=sect3><h4 id=network-create-parallel-cable>56.9.1. Creating a Parallel Cable<a class=anchor href=#network-create-parallel-cable></a></h4><div class=paragraph><p>You can purchase a parallel cable at most computer supply stores. If you cannot do that, or you just want to know how it is done, the following table shows how to make one out of a normal parallel printer cable.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 8. Wiring a Parallel Cable for Networking</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">A-name</th><th class="tableblock halign-left valign-top">A-End</th><th class="tableblock halign-left valign-top">B-End</th><th class="tableblock halign-left valign-top">Descr.</th><th class="tableblock halign-left valign-top">Post/Bit</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA0
-ERROR
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
2
15
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
15
2
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x01
1/0x08
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA1
+SLCT
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
3
13
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
13
3
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x02
1/0x10
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA2
+PE
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
4
12
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
12
4
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x04
1/0x20
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA3
-ACK
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
5
10
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
10
5
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Strobe</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x08
1/0x40
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA4
BUSY
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
6
11
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
11
6
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x10
1/0x80
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>GND</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>GND</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>-</pre></div></td></tr></tbody></table></div><div class=sect3><h4 id=network-plip-setup>56.9.2. Setting Up PLIP<a class=anchor href=#network-plip-setup></a></h4><div class=paragraph><p>First, you have to get a laplink cable. Then, confirm that both computers have a kernel with <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> driver support:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep lp /var/run/dmesg.boot</span>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</code></pre></div></div><div class=paragraph><p>The parallel port must be an interrupt driven port, you should have lines similar to the following in your in the <span class=filename>/boot/device.hints</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.at=&#34;isa&#34;
hint.ppc.0.irq=&#34;7&#34;</pre></div></div><div class=paragraph><p>Then check if the kernel configuration file has a <code>device plip</code> line or if the <span class=filename>plip.ko</span> kernel module is loaded. In both cases the parallel networking interface should appear when you use the <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> command to display it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>Plug the laplink cable into the parallel interface on both computers.</p></div><div class=paragraph><p>Configure the network interface parameters on both sites as <code>root</code>. For example, if you want to connect the host <code>host1</code> with another machine <code>host2</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</pre></div></div><div class=paragraph><p>Configure the interface on <code>host1</code> by doing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.1 10.0.0.2</span></code></pre></div></div><div class=paragraph><p>Configure the interface on <code>host2</code> by doing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.2 10.0.0.1</span></code></pre></div></div><div class=paragraph><p>You now should have a working connection. Please read the manual pages <a href="https://man.freebsd.org/cgi/man.cgi?query=lp&amp;sektion=4&amp;format=html">lp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> for more details.</p></div><div class=paragraph><p>You should also add both hosts to <span class=filename>/etc/hosts</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</pre></div></div><div class=paragraph><p>To confirm the connection works, go to each host and ping the other. For example, on <code>host1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class=nt>--</span><span class=o>&gt;</span> 10.0.0.2 netmask 0xff000000
<span class=c># netstat -r</span>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1            UH          0       0       plip0
<span class=c># ping -c 4 host2</span>
PING host2 <span class=o>(</span>10.0.0.2<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.774 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.530 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.556 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.714 ms

<span class=nt>---</span> host2 ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 2.530/2.643/2.774/0.103 ms</code></pre></div></div></div></div><div class=sect2><h3 id=network-ipv6>56.10. IPv6<a class=anchor href=#network-ipv6></a></h3><div class=paragraph><p>IPv6 (also known as IPng "IP next generation") is the new version of the well known IP protocol (also known as IPv4). Like the other current *BSD systems, FreeBSD includes the KAME IPv6 reference implementation. So your FreeBSD system comes with all you will need to experiment with IPv6. This section focuses on getting IPv6 configured and running.</p></div><div class=paragraph><p>In the early 1990s, people became aware of the rapidly diminishing address space of IPv4. Given the expansion rate of the Internet there were two major concerns:</p></div><div class=ulist><ul><li><p>Running out of addresses. Today this is not so much of a concern anymore since RFC1918 private address space (<code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, and <code>192.168.0.0/16</code>) and Network Address Translation (NAT) are being employed.</p></li><li><p>Router table entries were getting too large. This is still a concern today.</p></li></ul></div><div class=paragraph><p>IPv6 deals with these and many other issues:</p></div><div class=ulist><ul><li><p>128 bit address space. In other words theoretically there are 340,282,366,920,938,463,463,374,607,431,768,211,456 addresses available. This means there are approximately 6.67 * 10^27 IPv6 addresses per square meter on our planet.</p></li><li><p>Routers will only store network aggregation addresses in their routing tables thus reducing the average space of a routing table to 8192 entries.</p></li></ul></div><div class=paragraph><p>There are also lots of other useful features of IPv6 such as:</p></div><div class=ulist><ul><li><p>Address autoconfiguration (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>)</p></li><li><p>Anycast addresses ("one-out-of many")</p></li><li><p>Mandatory multicast addresses</p></li><li><p>IPsec (IP security)</p></li><li><p>Simplified header structure</p></li><li><p>Mobile IP</p></li><li><p>IPv6-to-IPv4 transition mechanisms</p></li></ul></div><div class=paragraph><p>For more information see:</p></div><div class=ulist><ul><li><p>IPv6 overview at <a href=http://playground.sun.com/pub/ipng/html/ipng-main.html>playground.sun.com</a></p></li><li><p><a href=http://www.kame.net>KAME.net</a></p></li></ul></div><div class=sect3><h4 id=_background_on_ipv6_addresses>56.10.1. Background on IPv6 Addresses<a class=anchor href=#_background_on_ipv6_addresses></a></h4><div class=paragraph><p>There are different types of IPv6 addresses: Unicast, Anycast and Multicast.</p></div><div class=paragraph><p>Unicast addresses are the well known addresses. A packet sent to a unicast address arrives exactly at the interface belonging to the address.</p></div><div class=paragraph><p>Anycast addresses are syntactically indistinguishable from unicast addresses but they address a group of interfaces. The packet destined for an anycast address will arrive at the nearest (in router metric) interface. Anycast addresses may only be used by routers.</p></div><div class=paragraph><p>Multicast addresses identify a group of interfaces. A packet destined for a multicast address will arrive at all interfaces belonging to the multicast group.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The IPv4 broadcast address (usually <code>xxx.xxx.xxx.255</code>) is expressed by multicast addresses in IPv6.</p></div></td></tr></tbody></table></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Πίνακας 9. Reserved IPv6 addresses</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6 address</th><th class="tableblock halign-left valign-top">Prefixlength (Bits)</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Notes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unspecified</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>cf. <code>0.0.0.0</code> in IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>loopback address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>cf. <code>127.0.0.1</code> in IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>embedded IPv4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the IPv4 address. Also called "IPv4 compatible IPv6 address"</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 mapped IPv6 address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the IPv4 address. For hosts which do not support IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::</code> - <code>feb::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>cf. loopback address in IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fec0::</code> - <code>fef::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>site-local</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>001</code> (base 2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>global unicast</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All global unicast addresses are assigned from this pool. The first 3 bits are "001".</p></td></tr></tbody></table></div><div class=sect3><h4 id=_reading_ipv6_addresses>56.10.2. Reading IPv6 Addresses<a class=anchor href=#_reading_ipv6_addresses></a></h4><div class=paragraph><p>The canonical form is represented as: <code>x:x:x:x:x:x:x:x</code>, each "x" being a 16 Bit hex value. For example <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code></p></div><div class=paragraph><p>Often an address will have long substrings of all zeros therefore one such substring per address can be abbreviated by "::". Also up to three leading "0"s per hexquad can be omitted. For example <code>fe80::1</code> corresponds to the canonical form <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>A third form is to write the last 32 Bit part in the well known (decimal) IPv4 style with dots "." as separators. For example <code>2002::10.0.0.1</code> corresponds to the (hexadecimal) canonical representation <code>2002:0000:0000:0000:0000:0000:0a00:0001</code> which in turn is equivalent to writing <code>2002::a00:1</code>.</p></div><div class=paragraph><p>By now the reader should be able to understand the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p><code>fe80::200:21ff:fe03:8e1%rl0</code> is an auto configured link-local address. It is generated from the MAC address as part of the auto configuration.</p></div><div class=paragraph><p>For further information on the structure of IPv6 addresses see <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect3><h4 id=_getting_connected>56.10.3. Getting Connected<a class=anchor href=#_getting_connected></a></h4><div class=paragraph><p>Currently there are four ways to connect to other IPv6 hosts and networks:</p></div><div class=ulist><ul><li><p>Getting an IPv6 network from your upstream provider. Talk to your Internet provider for instructions.</p></li><li><p>Tunnel via 6-to-4 (<a href=http://www.ietf.org/rfc/rfc3068.txt>RFC3068</a>)</p></li><li><p>Use the <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> port if you are on a dial-up connection.</p></li></ul></div></div><div class=sect3><h4 id=_dns_in_the_ipv6_world>56.10.4. DNS in the IPv6 World<a class=anchor href=#_dns_in_the_ipv6_world></a></h4><div class=paragraph><p>There used to be two types of DNS records for IPv6. The IETF has declared A6 records obsolete. AAAA records are the standard now.</p></div><div class=paragraph><p>Using AAAA records is straightforward. Assign your hostname to the new IPv6 address you just received by adding:</p></div><div class="literalblock programlisting"><div class=content><pre>MYHOSTNAME           AAAA    MYIPv6ADDR</pre></div></div><div class=paragraph><p>To your primary zone DNS file. In case you do not serve your own DNS zones ask your DNS provider. Current versions of bind (version 8.3 and 9) and <a class=package href=https://cgit.freebsd.org/ports/tree/dns/djbdns/>dns/djbdns</a> (with the IPv6 patch) support AAAA records.</p></div></div><div class=sect3><h4 id=_applying_the_needed_changes_to_etcrc_conf>56.10.5. Applying the needed changes to <span class=filename>/etc/rc.conf</span><a class=anchor href=#_applying_the_needed_changes_to_etcrc_conf></a></h4><div class=sect4><h5 id=_ipv6_client_settings>56.10.5.1. IPv6 Client Settings<a class=anchor href=#_ipv6_client_settings></a></h5><div class=paragraph><p>These settings will help you configure a machine that will be on your LAN and act as a client, not a router. To have <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a> autoconfigure your interface on boot all you need to add is:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To statically assign an IP address such as <code>2001:471:1f11:251:290:27ff:fee0:2093</code>, to your <span class=filename>fxp0</span> interface, add:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_fxp0=&#34;2001:471:1f11:251:290:27ff:fee0:2093&#34;</pre></div></div><div class=paragraph><p>To assign a default router of <code>2001:471:1f11:251::1</code> add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:471:1f11:251::1&#34;</pre></div></div></div><div class=sect4><h5 id=_ipv6_routergateway_settings>56.10.5.2. IPv6 Router/Gateway Settings<a class=anchor href=#_ipv6_routergateway_settings></a></h5><div class=paragraph><p>This will help you take the directions that your tunnel provider has given you and convert it into settings that will persist through reboots. To restore your tunnel on startup use something like the following in <span class=filename>/etc/rc.conf</span>:</p></div><div class=paragraph><p>List the Generic Tunneling interfaces that will be configured, for example <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gif_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>To configure the interface with a local endpoint of <em>MY_IPv4_ADDR</em> to a remote endpoint of <em>REMOTE_IPv4_ADDR</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig_gif0=&#34;MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>To apply the IPv6 address you have been assigned for use as your IPv6 tunnel endpoint, add:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_gif0=&#34;MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Then all you have to do is set the default route for IPv6. This is the other side of the IPv6 tunnel:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div></div><div class=sect4><h5 id=_ipv6_tunnel_settings>56.10.5.3. IPv6 Tunnel Settings<a class=anchor href=#_ipv6_tunnel_settings></a></h5><div class=paragraph><p>If the server is to route IPv6 between the rest of your network and the world, the following <span class=filename>/etc/rc.conf</span> setting will also be needed:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div></div><div class=sect3><h4 id=_router_advertisement_and_host_auto_configuration>56.10.6. Router Advertisement and Host Auto Configuration<a class=anchor href=#_router_advertisement_and_host_auto_configuration></a></h4><div class=paragraph><p>This section will help you setup <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to advertise the IPv6 default route.</p></div><div class=paragraph><p>To enable <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> you will need the following in your <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>It is important that you specify the interface on which to do IPv6 router solicitation. For example to tell <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to use <span class=filename>fxp0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;fxp0&#34;</pre></div></div><div class=paragraph><p>Now we must create the configuration file, <span class=filename>/etc/rtadvd.conf</span>. Here is an example:</p></div><div class="literalblock programlisting"><div class=content><pre>fxp0:\
	:addrs#1:addr=&#34;2001:471:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Replace <span class=filename>fxp0</span> with the interface you are going to be using.</p></div><div class=paragraph><p>Next, replace <code>2001:471:1f11:246::</code> with the prefix of your allocation.</p></div><div class=paragraph><p>If you are dedicated a <code>/64</code> subnet you will not need to change anything else. Otherwise, you will need to change the <code>prefixlen#</code> to the correct value.</p></div></div></div><div class=sect2><h3 id=network-atm>56.11. Asynchronous Transfer Mode (ATM)<a class=anchor href=#network-atm></a></h3><div class=sect3><h4 id=_configuring_classical_ip_over_atm_pvcs>56.11.1. Configuring classical IP over ATM (PVCs)<a class=anchor href=#_configuring_classical_ip_over_atm_pvcs></a></h4><div class=paragraph><p>Classical IP over ATM (CLIP) is the simplest method to use Asynchronous Transfer Mode (ATM) with IP. It can be used with switched connections (SVCs) and with permanent connections (PVCs). This section describes how to set up a network based on PVCs.</p></div><div class=sect4><h5 id=_fully_meshed_configurations>56.11.1.1. Fully meshed configurations<a class=anchor href=#_fully_meshed_configurations></a></h5><div class=paragraph><p>The first method to set up a CLIP with PVCs is to connect each machine to each other machine in the network via a dedicated PVC. While this is simple to configure it tends to become impractical for a larger number of machines. The example supposes that we have four machines in the network, each connected to the ATM network with an ATM adapter card. The first step is the planning of the IP addresses and the ATM connections between the machines. We use the following:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Host</th><th class="tableblock halign-left valign-top">IP Address</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.3</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.4</code></p></td></tr></tbody></table><div class=paragraph><p>To build a fully meshed net we need one ATM connection between each pair of machines:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machines</th><th class="tableblock halign-left valign-top">VPI.VCI couple</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.100</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.101</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.102</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.103</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.104</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.105</p></td></tr></tbody></table><div class=paragraph><p>The VPI and VCI values at each end of the connection may of course differ, but for simplicity we assume that they are the same. Next we need to configure the ATM interfaces on each host:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# ifconfig hatm0 192.168.173.1 up
hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up
hostD# ifconfig hatm0 192.168.173.4 up</code></pre></div></div><div class=paragraph><p>assuming that the ATM interface is <span class=filename>hatm0</span> on all hosts. Now the PVCs need to be configured on <code>hostA</code> (we assume that they are already configured on the ATM switches, you need to consult the manual for the switch on how to do this).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA# atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA# atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB# atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB# atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB# atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC# atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD# atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD# atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD# atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</code></pre></div></div><div class=paragraph><p>Of course other traffic contracts than UBR can be used given the ATM adapter supports those. In this case the name of the traffic contract is followed by the parameters of the traffic. Help for the <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a> tool can be obtained with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atmconfig help natm add</span></code></pre></div></div><div class=paragraph><p>or in the <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a> manual page.</p></div><div class=paragraph><p>The same configuration can also be done via <span class=filename>/etc/rc.conf</span>. For <code>hostA</code> this would look like:</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 hatm0&#34;
ifconfig_hatm0=&#34;inet 192.168.173.1 up&#34;
natm_static_routes=&#34;hostB hostC hostD&#34;
route_hostB=&#34;192.168.173.2 hatm0 0 100 llc/snap ubr&#34;
route_hostC=&#34;192.168.173.3 hatm0 0 101 llc/snap ubr&#34;
route_hostD=&#34;192.168.173.4 hatm0 0 102 llc/snap ubr&#34;</pre></div></div><div class=paragraph><p>The current state of all CLIP routes can be obtained with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm show</code></pre></div></div></div></div></div><div class=sect2><h3 id=carp>56.12. Common Access Redundancy Protocol (CARP)<a class=anchor href=#carp></a></h3><div class=paragraph><p>The Common Access Redundancy Protocol, or CARP allows multiple hosts to share the same IP address. In some configurations, this may be used for availability or load balancing. Hosts may use separate IP addresses as well, as in the example provided here.</p></div><div class=paragraph><p>To enable support for CARP, the FreeBSD kernel must be rebuilt with the following option:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>CARP functionality should now be available and may be tuned via several <code>sysctl</code> OIDs. Devices themselves may be loaded via the <code>ifconfig</code> command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>In a real environment, these interfaces will need unique identification numbers known as a VHID. This VHID or Virtual Host Identification will be used to distinguish the host on the network.</p></div><div class=sect3><h4 id=_using_carp_for_server_availability_carp>56.12.1. Using CARP For Server Availability (CARP)<a class=anchor href=#_using_carp_for_server_availability_carp></a></h4><div class=paragraph><p>One use of CARP, as noted above, is for server availability. This example will provide failover support for three hosts, all with unique IP addresses and providing the same web content. These machines will act in conjunction with a Round Robin DNS configuration. The failover machine will have two additional CARP interfaces, one for each of the content server’s IPs. When a failure occurs, the failover server should pick up the failed machine’s IP address. This means the failure should go completely unnoticed to the user. The failover server requires identical content and services as the other content servers it is expected to pick up load for.</p></div><div class=paragraph><p>The two machines should be configured identically other than their issued hostnames and VHIDs. This example calls these machines <code>hosta.example.org</code> and <code>hostb.example.org</code> respectively. First, the required lines for a CARP configuration have to be added to <span class=filename>rc.conf</span>. For <code>hosta.example.org</code>, the <span class=filename>rc.conf</span> file should contain the following lines:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpast 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>On <code>hostb.example.org</code> the following lines should be in <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is very important that the passwords, specified by the <code>pass</code> option to <code>ifconfig</code>, are identical. The <span class=filename>carp</span> devices will only listen to and accept advertisements from machines with the correct password. The VHID must also be different for each machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The third machine, <code>provider.example.org</code>, should be prepared so that it may handle failover from either host. This machine will require two <span class=filename>carp</span> devices, one to handle each host. The appropriate <span class=filename>rc.conf</span> configuration lines will be similar to the following:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;provider.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>Having the two <span class=filename>carp</span> devices will allow <code>provider.example.org</code> to notice and pick up the IP address of either machine should it stop responding.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The default FreeBSD kernel <em>may</em> have preemption enabled. If so, <code>provider.example.org</code> may not relinquish the IP address back to the original content server. In this case, an administrator may "nudge" the interface. The following command should be issued on <code>provider.example.org</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>This should be done on the <span class=filename>carp</span> interface which corresponds to the correct host.</p></div></td></tr></tbody></table></div><div class=paragraph><p>At this point, CARP should be completely enabled and available for testing. For testing, either networking has to be restarted or the machines need to be rebooted.</p></div><div class=paragraph><p>More information is always available in the <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> manual page.</p></div><div class=paragraph><p>path: "/books/handbook/partv/"
---
:sectnums!:
:leveloffset: +1</p></div></div></div></div></div><div class=sect1><h2 id=mirrors>Appendix A: Που θα Βρείτε το FreeBSD<a class=anchor href=#mirrors></a></h2><div class=sectionbody></div></div><div class=sect1><h2 id=mirrors-cdrom>Chapter 57. Εκδόσεις σε CDROM και DVD<a class=anchor href=#mirrors-cdrom></a></h2><div class=sectionbody><div class=sect2><h3 id=_retail_εκδόσεις>57.1. Retail Εκδόσεις<a class=anchor href=#_retail_εκδόσεις></a></h3><div class=paragraph><p>Το FreeBSD είναι διαθέσιμο ως εμπορικό προϊόν (FreeBSD CD, επιπρόσθετο λογισμικό, και τυπωμένη τεκμηρίωση) από διάφορους προμηθευτές:</p></div><div class=ulist><ul><li><p>Frys Electronics<br>WWW: <a href=http://www.frys.com/ class=bare>http://www.frys.com/</a></p></li></ul></div></div><div class=sect2><h3 id=_cd_και_dvd_διανομές>57.2. CD και DVD διανομές<a class=anchor href=#_cd_και_dvd_διανομές></a></h3><div class=paragraph><p>Το FreeBSD είναι διαθέσιμο σε CD και DVD για αγορά μέσω διαδικτύου από τους παρακάτω προμηθευτές:</p></div><div class=ulist><ul><li><p>FreeBSD Mall, Inc.<br>1164 Claremont Dr<br>Brentwood, CA<br>94513<br>USA<br>Τηλέφωνο: +1 925 240-6652<br>Fax: +1 925 674-0821<br>Email: <a href=mailto:info@freebsdmall.com>info@freebsdmall.com</a><br>WWW: <a href=https://www.freebsdmall.com class=bare>https://www.freebsdmall.com</a></p></li><li><p>Getlinux<br>WWW: <a href=https://www.getlinux.fr/ class=bare>https://www.getlinux.fr/</a></p></li><li><p>Dr. Hinner EDV<br>Schäftlarnstr. 10 // 4. Stock<br>D-81371 München<br>Germany<br>Τηλέφωνο: +49 171 417 544 6<br>Email: <a href=mailto:infow@hinner.de>infow@hinner.de</a><br>WWW: <a href=http://www.hinner.de/linux/freebsd.html class=bare>http://www.hinner.de/linux/freebsd.html</a></p></li><li><p>JMC Software<br>Ireland<br>Τηλέφωνο: 353 1 6291282<br>WWW: <a href=http://www.thelinuxmall.com class=bare>http://www.thelinuxmall.com</a></p></li><li><p>Linux Distro UK<br>42 Wharfedale Road<br>Margate<br>CT9 2TB<br>United Kingdom<br>WWW: <a href=https://linux-distro.co.uk/ class=bare>https://linux-distro.co.uk/</a></p></li><li><p>The Linux Emporium<br>Hilliard House, Lester Way<br>Wallingford<br>OX10 9TA<br>United Kingdom<br>Τηλέφωνο: +44 1491 837010<br>Fax: +44 1491 837016<br>WWW: <a href=http://www.linuxemporium.co.uk/products/bsd/ class=bare>http://www.linuxemporium.co.uk/products/bsd/</a></p></li><li><p>Linux+ DVD Magazine<br>Lewartowskiego 6<br>Warsaw<br>00-190<br>Poland<br>Τηλέφωνο: +48 22 860 18 18<br>Email: &lt;<a href=mailto:editors@lpmagazine.org>editors@lpmagazine.org</a>><br>WWW: <a href=http://www.lpmagazine.org/ class=bare>http://www.lpmagazine.org/</a></p></li><li><p>Linux System Labs Australia<br>21 Ray Drive<br>Balwyn North<br>VIC - 3104<br>Australia<br>Τηλέφωνο: +61 3 9857 5918<br>Fax: +61 3 9857 8974<br>WWW: <a href=http://www.lsl.com.au class=bare>http://www.lsl.com.au</a></p></li><li><p>LinuxCenter.Ru<br>Galernaya Street, 55<br>Saint-Petersburg<br>190000<br>Russia<br>Τηλέφωνο: +7-812-3125208<br>Email: &lt;<a href=mailto:info@linuxcenter.ru>info@linuxcenter.ru</a>><br>WWW: <a href=http://linuxcenter.ru/shop/freebsd class=bare>http://linuxcenter.ru/shop/freebsd</a></p></li></ul></div></div><div class=sect2><h3 id=_διανομείς>57.3. Διανομείς<a class=anchor href=#_διανομείς></a></h3><div class=paragraph><p>Αν είστε μεταπωλητής και μπορείτε να διανείμετε σε CD-ROM προϊόντα βασισμένα στο FreeBSD, παρακαλούμε επικοινωνήστε με κάποιον από τους διανομείς:</p></div><div class=ulist><ul><li><p>Ingram Micro<br>1600 E. St. Andrew Place<br>Santa Ana, CA 92705-4926<br>USA<br>Τηλέφωνο: 1 (800) 456-8000<br>WWW: <a href=http://www.ingrammicro.com/ class=bare>http://www.ingrammicro.com/</a></p></li><li><p>Kudzu, LLC<br>7375 Washington Ave. S.<br>Edina, MN 55439<br>USA<br>Τηλέφωνο: +1 952 947-0822<br>Fax: +1 952 947-0876<br>Email: &lt;<a href=mailto:sales@kudzuenterprises.com>sales@kudzuenterprises.com</a>></p></li><li><p>LinuxCenter.Ru<br>Galernaya Street, 55<br>Saint-Petersburg<br>190000<br>Russia<br>Τηλέφωνο: +7-812-3125208<br>Email: &lt;<a href=mailto:info@linuxcenter.ru>info@linuxcenter.ru</a>><br>WWW: <a href=http://linuxcenter.ru/freebsd class=bare>http://linuxcenter.ru/freebsd</a></p></li></ul></div></div></div></div><div class=sect1><h2 id=mirrors-ftp>Chapter 58. Εξυπηρετητές FTP<a class=anchor href=#mirrors-ftp></a></h2><div class=sectionbody><div class=paragraph><p>Οι επίσημες εκδόσεις του FreeBSD είναι διαθέσιμες μέσω ανώνυμης FTP σύνδεσης από διάφορους εξυπηρετητές FTP σε όλο τον κόσμο. Ο κεντρικός εξυπηρετητής <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> έχει πολύ καλή σύνδεση με τον υπόλοιπο κόσμο, και επιτρέπει ένα μεγάλο αριθμό ταυτόχρονων συνδέσεων. Ακόμα κι έτσι όμως, είναι μάλλον καλή ιδέα να βρείτε κάποιο εξυπηρετητή FTP που είναι πιο "κοντά" σας (ειδικά αν θέλετε να στήσετε κάποιο τοπικό mirror site).</p></div><div class=paragraph><p>Το FreeBSD είναι επίσης διαθέσιμο μέσω σύνδεσης ανώνυμου FTP από τα παρακάτω mirror sites. Αν επιλέξετε να κατεβάσετε το FreeBSD μέσω ανώνυμου FTP, σας παρακαλούμε να διαλέξετε κάποιο εξυπηρετητή ο οποίος είναι κοντά σας. Τα mirror sites που αναφέρονται ως "Κύρια Mirror Sites" έχουν συνήθως την πλήρη συλλογή αρχείων του FreeBSD (όλες τις διαθέσιμες εκδόσεις, για κάθε διαθέσιμη αρχιτεκτονική συστήματος), αλλά είναι πιθανόν να πετύχετε καλύτερες ταχύτητες εξυπηρέτησης με κάποιο εξυπηρετητή που είναι στη δική σας χώρα ή περιοχή. Τα τοπικά sites έχουν συνήθως τις πιο πρόσφατες εκδόσεις για τις πιο δημοφιλείς αρχιτεκτονικές συστήματος, οπότε μπορεί να μην έχουν όλες τις πιθανές εκδόσεις του FreeBSD. Όλα τα sites δέχονται συνδέσεις μέσω ανώνυμου FTP. Μερικά από αυτά μπορεί να υποστηρίζουν και άλλης μορφής συνδέσεις. Οι εναλλακτικές μορφές σύνδεσης αναφέρονται ξεχωριστά για κάθε site παρακάτω:</p></div><div class=paragraph><p><a href=#central>Central Servers</a>, <a href=#primary>Primary Mirror Sites</a>, <a href=#armenia>Armenia</a>, <a href=#australia>Australia</a>, <a href=#austria>Austria</a>, <a href=#brazil>Brazil</a>, <a href=#czech-republic>Czech Republic</a>, <a href=#denmark>Denmark</a>, <a href=#estonia>Estonia</a>, <a href=#finland>Finland</a>, <a href=#france>France</a>, <a href=#germany>Germany</a>, <a href=#greece>Greece</a>, <a href=#hong-kong>Hong Kong</a>, <a href=#ireland>Ireland</a>, <a href=#japan>Japan</a>, <a href=#korea>Korea</a>, <a href=#latvia>Latvia</a>, <a href=#lithuania>Lithuania</a>, <a href=#netherlands>Netherlands</a>, <a href=#new-zealand>New Zealand</a>, <a href=#norway>Norway</a>, <a href=#poland>Poland</a>, <a href=#russia>Russia</a>, <a href=#saudi-arabia>Saudi Arabia</a>, <a href=#slovenia>Slovenia</a>, <a href=#south-africa>South Africa</a>, <a href=#spain>Spain</a>, <a href=#sweden>Sweden</a>, <a href=#switzerland>Switzerland</a>, <a href=#taiwan>Taiwan</a>, <a href=#ukraine>Ukraine</a>, <a href=#uk>United Kingdom</a>, <a href=#usa>United States of America</a>.</p></div><div class=paragraph><p>(as of UTC)</p></div><div id=central class=paragraph><p><strong>Central Servers</strong></p></div><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a>)</p></div><div id=primary class=paragraph><p><strong>Primary Mirror Sites</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:mirror-admin@FreeBSD.org>mirror-admin@FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp11.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=armenia class=paragraph><p><strong>Armenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@am.FreeBSD.org>hostmaster@am.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li></ul></div><div id=australia class=paragraph><p><strong>Australia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@au.FreeBSD.org>hostmaster@au.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=austria class=paragraph><p><strong>Austria</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@at.FreeBSD.org>hostmaster@at.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.at.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=brazil class=paragraph><p><strong>Brazil</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@br.FreeBSD.org>hostmaster@br.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp2.br.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp2.br.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp2.br.FreeBSD.org/ class=bare>http://ftp2.br.FreeBSD.org/</a>)</p></li><li><p><a href=ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=czech-republic class=paragraph><p><strong>Czech Republic</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@cz.FreeBSD.org>hostmaster@cz.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=denmark class=paragraph><p><strong>Denmark</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:staff@dotsrc.org>staff@dotsrc.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=estonia class=paragraph><p><strong>Estonia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ee.FreeBSD.org>hostmaster@ee.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=finland class=paragraph><p><strong>Finland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fi.FreeBSD.org>hostmaster@fi.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=france class=paragraph><p><strong>France</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fr.FreeBSD.org>hostmaster@fr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=germany class=paragraph><p><strong>Germany</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:de-bsd-hubs@de.FreeBSD.org>de-bsd-hubs@de.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.de.FreeBSD.org/freebsd/ class=bare>ftp://ftp1.de.FreeBSD.org/freebsd/</a> (ftp / <a href=http://www1.de.FreeBSD.org/freebsd/ class=bare>http://www1.de.FreeBSD.org/freebsd/</a> / rsync://rsync3.de.FreeBSD.org/freebsd/)</p></li><li><p><a href=ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp4.de.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp4.de.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp4.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp7.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=greece class=paragraph><p><strong>Greece</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@gr.FreeBSD.org>hostmaster@gr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=hong-kong class=paragraph><p><strong>Hong Kong</strong></p></div><div class=paragraph><p><a href=ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></div><div id=ireland class=paragraph><p><strong>Ireland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ie.FreeBSD.org>hostmaster@ie.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=japan class=paragraph><p><strong>Japan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@jp.FreeBSD.org>hostmaster@jp.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=korea class=paragraph><p><strong>Korea</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@kr.FreeBSD.org>hostmaster@kr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=latvia class=paragraph><p><strong>Latvia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lv.FreeBSD.org>hostmaster@lv.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lv.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=lithuania class=paragraph><p><strong>Lithuania</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lt.FreeBSD.org>hostmaster@lt.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lt.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=netherlands class=paragraph><p><strong>Netherlands</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@nl.FreeBSD.org>hostmaster@nl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nl.FreeBSD.org/os/FreeBSD/ class=bare>http://ftp.nl.FreeBSD.org/os/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=new-zealand class=paragraph><p><strong>New Zealand</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.nz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=norway class=paragraph><p><strong>Norway</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@no.FreeBSD.org>hostmaster@no.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.no.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.no.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=poland class=paragraph><p><strong>Poland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@pl.FreeBSD.org>hostmaster@pl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p>ftp2.pl.FreeBSD.org</p></li></ul></div><div id=russia class=paragraph><p><strong>Russia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ru.FreeBSD.org>hostmaster@ru.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ru.FreeBSD.org/FreeBSD/ class=bare>http://ftp.ru.FreeBSD.org/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=saudi-arabia class=paragraph><p><strong>Saudi Arabia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:ftpadmin@isu.net.sa>ftpadmin@isu.net.sa</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.isu.net.sa/pub/ftp.freebsd.org class=bare>ftp://ftp.isu.net.sa/pub/ftp.freebsd.org</a> (ftp)</p></li></ul></div><div id=slovenia class=paragraph><p><strong>Slovenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@si.FreeBSD.org>hostmaster@si.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.si.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.si.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=south-africa class=paragraph><p><strong>South Africa</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@za.FreeBSD.org>hostmaster@za.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=spain class=paragraph><p><strong>Spain</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@es.FreeBSD.org>hostmaster@es.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.es.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.es.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=sweden class=paragraph><p><strong>Sweden</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@se.FreeBSD.org>hostmaster@se.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.se.FreeBSD.org/)</p></li><li><p><a href=ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/ / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp6.se.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=switzerland class=paragraph><p><strong>Switzerland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ch.FreeBSD.org>hostmaster@ch.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ch.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=taiwan class=paragraph><p><strong>Taiwan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@tw.FreeBSD.org>hostmaster@tw.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.tw.FreeBSD.org/ class=bare>http://ftp6.tw.FreeBSD.org/</a> / rsync)</p></li><li><p><a href=ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp11.tw.FreeBSD.org/FreeBSD/ class=bare>http://ftp11.tw.FreeBSD.org/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=ukraine class=paragraph><p><strong>Ukraine</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ua.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.ua.FreeBSD.org/pub/FreeBSD class=bare>http://ftp6.ua.FreeBSD.org/pub/FreeBSD</a> / rsync://ftp6.ua.FreeBSD.org/FreeBSD/)</p></li><li><p><a href=ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=uk class=paragraph><p><strong>United Kingdom</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@uk.FreeBSD.org>hostmaster@uk.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.uk.FreeBSD.org/ftp.freebsd.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=usa class=paragraph><p><strong>United States of America</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@us.FreeBSD.org>hostmaster@us.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div></div></div><div class=sect1><h2 id=anoncvs>Chapter 59. Ανώνυμο CVS<a class=anchor href=#anoncvs></a></h2><div class=sectionbody><div class=sect2><h3 id=anoncvs-intro>59.1. Εισαγωγή<a class=anchor href=#anoncvs-intro></a></h3><div class=paragraph><p>Η σύνδεση ανώνυμου CVS (ή <em>anoncvs</em> όπως λέγεται μερικές φορές) υποστηρίζεται από τα εργαλεία CVS που διανέμονται με το ίδιο το FreeBSD για συγχρονισμό τοπικών αρχείων με ένα απομακρυσμένο repository. Ένα από τα χαρακτηριστικά του CVS είναι ότι επιτρέπει στους χρήστες του FreeBSD να συγχρονίζουν, χωρίς ιδιαίτερα δικαιώματα χρήστη, τα τοπικά αντίγραφα πηγαίου κώδικα που έχουν με τους κεντρικούς, επίσημους εξυπηρετητές CVS του FreeBSD project. Για να χρησιμοποιήσει κανείς το CVS αρκεί: (α) να ορίσει την τιμή της μεταβλητής περιβάλλοντος <code>CVSROOT</code> έτσι ώστε να δείχνει προς έναν από τους επίσημους εξυπηρετητές, και (β) να δώσει τον κωδικό "anoncvs" στην προτροπή της εντολής <code>cvs login</code>. Τότε μπορεί να χρησιμοποιήσει το εργαλείο <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> για να προσπελάσει το απομακρυσμένο CVS repository του FreeBSD σαν ένα οποιοδήποτε τοπικό repository.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η εντολή <code>cvs login</code> αποθηκεύει τους κωδικούς που χρησιμοποιούνται για πιστοποίησης της ταυτότητάς σας στον εξυπηρετητή CVS σε ένα αρχείο με όνομα <span class=filename>.cvspass</span> στον <code>HOME</code> κατάλογο του τοπικού σας λογαριασμού. Αν αυτό το αρχείο δεν υπάρχει ήδη, μπορεί να αποτύχει η εντολή <code>cvs login</code> την πρώτη φορά. Μπορείτε απλά να δημιουργήσετε ένα άδειο αρχείο <span class=filename>.cvspass</span> και να ξανατρέξετε την εντολή <code>cvs login</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Μπορεί να πει κανείς ότι το <a href=#cvsup>CVSup</a> και το <em>anoncvs</em> είναι ουσιαστικά παρόμοιοι τρόποι συγχρονισμού αρχείων και υποστηρίζουν την ίδια λειτουργικότητα, αλλά υπάρχουν κάποιες διαφορές οι οποίες μπορεί να παίξουν σημαντικό ρόλο στην επιλογή μεταξύ αυτών των δύο μεθόδων. Γενικά, το CVSup κάνει πολύ πιο αποδοτική χρήση της σύνδεσης που έχετε και χρησιμοποιεί ένα πολύ πιο έξυπνο πρωτόκολλο επικοινωνίας, αλλά υπάρχει και το αντίστοιχο τίμημα. Για να χρησιμοποιήσετε το CVSup πρέπει να εγκαταστήσετε και να ρυθμίσετε ένα ειδικό πρόγραμμα πελάτη, και τότε μπορείτε να συγχρονίσετε μόνο μεγάλες συλλογές αρχείων - τις οποίες το CVSup αποκαλεί "συλλογές" (collections).</p></div><div class=paragraph><p>Το anoncvs, από την άλλη, μπορεί να χρησιμοποιηθεί για να εξετάσει κανείς τις αλλαγές ενός και μόνο αρχείου ή ενός μόνο προγράμματος και των συνοδευτικών του αρχείων (π.χ. τον πηγαίο κώδικα της εντολής <code>ls</code> ή της <code>grep</code>), με χρήση του ονόματος του κατάλληλου module. Το anoncvs είναι πιο βολικό για εργασίες που απαιτούν βέβαια μόνο ανάγνωση. Οπότε, αν θέλετε να υποστηρίξετε την ανάπτυξη προγραμμάτων τοπικά, το CVSup είναι μάλλον μονόδρομος.</p></div></div><div class=sect2><h3 id=anoncvs-usage>59.2. Χρησιμοποιώντας Ανώνυμο CVS<a class=anchor href=#anoncvs-usage></a></h3><div class=paragraph><p>Η ρύθμιση του <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> ώστε να χρησιμοποιεί ένα ανώνυμο CVS repository γίνεται απλώς ρυθμίζοντας την μεταβλητή περιβάλλοντος <code>CVSROOT</code> ώστε να δείχνει σε έναν από τους <em>anoncvs</em> εξυπηρετητές του FreeBSD project. Την ώρα που γράφονται αυτές οι γραμμές, είναι διαθέσιμοι οι ακόλουθοι εξυπηρετητές:</p></div><div class=ulist><ul><li><p><em>Γαλλία</em>: :pserver:anoncvs@anoncvs.fr.FreeBSD.org:/home/ncvs (Για pserver χρησιμοποιήστε την εντολή <code>cvs login</code> και δώστε τον κωδικό "anoncvs" όταν σας ζητηθεί. Το ssh δεν απαιτεί τη χρήση κωδικού.)</p></li><li><p><em>Ταΐβάν</em>: :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs (Για pserver χρησιμοποιήστε την εντολή <code>cvs login</code> και δώστε οτιδήποτε για κωδικό όταν σας ζητηθεί, Το ssh δεν απαιτεί τη χρήση κωδικού.)</p><div class="literalblock programlisting"><div class=content><pre>SSH2 HostKey: 1024 02:ed:1b:17:d6:97:2b:58:5e:5c:e2:da:3b:89:88:26 /etc/ssh/ssh_host_rsa_key.pub
SSH2 HostKey: 1024 e8:3b:29:7b:ca:9f:ac:e9:45:cb:c8:17:ae:9b:eb:55 /etc/ssh/ssh_host_dsa_key.pub</pre></div></div></li></ul></div><div class=paragraph><p>Καθώς το CVS σας επιτρέπει να κάνετε "check out" ουσιαστικά οποιαδήποτε έκδοση του πηγαίου κώδικα του FreeBSD υπήρξε ποτέ (και σε ορισμένες περιπτώσεις ακόμα και εκδόσεις που δεν έχουν κυκλοφορήσει ακόμα), θα πρέπει να είστε εξοικειωμένος με την επιλογή του <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> με την οποία επιλέγεται το revision (πρόκειται για την <code>-r</code>) και ποιες είναι οι επιτρεπτές τιμές της για το repository του FreeBSD project.</p></div><div class=paragraph><p>Υπάρχουν δύο είδη tags (ετικετών), τα revision tags (ετικέτες έκδοσης) και τα branch tags. Ένα revision tag αναφέρεται σε μια συγκεκριμένη έκδοση. Η έννοια του παραμένει σταθερή μέρα με τη μέρα. Από την άλλη, ένα branch tag δείχνει την τελευταία έκδοση μιας συγκεκριμένης πορείας ανάπτυξης, σε κάθε χρονική στιγμή. Καθώς το branch tag δεν αναφέρεται σε κάποια συγκεκριμένη έκδοση, μπορεί αύριο να σημαίνει κάτι διαφορετικό από ότι σημαίνει σήμερα.</p></div><div class=paragraph><p>Το <a href=#cvs-tags>Ετικέτες (Tags) για το CVS</a> περιέχει revision tags τα οποία μπορεί να ενδιαφέρουν τους χρήστες. Υπενθυμίζουμε ότι κανένα από αυτά δεν είναι έγκυρο για την Συλλογή των Ports, καθώς αυτή δεν έχει πολλαπλές εκδόσεις (revisions).</p></div><div class=paragraph><p>Όταν καθορίζετε κάποιο branch tag, φυσιολογικά λαμβάνετε τις τελευταίες εκδόσεις των αρχείων που υπάρχουν σε αυτή τη γραμμή ανάπτυξης. Αν θέλετε να λάβετε κάποια παλιότερη έκδοση, μπορείτε χρησιμοποιώντας την ημερομηνία σε συνδυασμό με την επιλογή <code>-D date</code>. Δείτε τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> για περισσότερες λεπτομέρειες.</p></div></div><div class=sect2><h3 id=_παραδείγματα>59.3. Παραδείγματα<a class=anchor href=#_παραδείγματα></a></h3><div class=paragraph><p>Αν και πραγματικά συνίσταται να διαβάσετε προσεκτικά τη σελίδα manual του <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> πριν κάνετε οτιδήποτε, παρακάτω σας δίνουμε κάποια γρήγορα παραδείγματα τα οποία ουσιαστικά θα σας δείξουν πως να χρησιμοποιήσετε το Ανώνυμο CVS:</p></div><div class=exampleblock><div class=title>Παράδειγμα 28. Λήψη (Check out) Κάποιου Αρχείου από το -CURRENT (<a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>):</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
Στην προτροπή, δώστε οποιαδήποτε λέξη για «password».
% cvs co <span class=nb>ls</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 29. Χρήση SSH για Λήψη (check out) του Δέντρου <span class=filename>src/</span>:</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cvs <span class=nt>-d</span> anoncvs@anoncvs1.FreeBSD.org:/home/ncvs co src
The authenticity of host <span class=s1>&#39;anoncvs1.freebsd.org (216.87.78.137)&#39;</span> can<span class=s1>&#39;t be established.
DSA key fingerprint is 53:1f:15:a3:72:5c:43:f6:44:0e:6a:e9:bb:f8:01:62.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;</span>anoncvs1.freebsd.org<span class=s1>&#39; (DSA) to the list of known hosts.</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 30. Λήψη της Έκδοσης του Αρχείου <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> από το 8-STABLE Branch:</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
Στην προτροπή, δώστε οποιαδήποτε λέξη για «password».
% cvs co <span class=nt>-rRELENG_8</span> <span class=nb>ls</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 31. Δημιουργία μιας Λίστας Αλλαγών (ως Unified Diffs) της <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>:</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
Στην προτροπή, δώστε οποιαδήποτε λέξη για «password».
% cvs rdiff <span class=nt>-u</span> <span class=nt>-rRELENG_8_0_0_RELEASE</span> <span class=nt>-rRELENG_8_1_0_RELEASE</span> <span class=nb>ls</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Παράδειγμα 32. Βρίσκοντας Ποια Άλλα Ονόματα Modules μπορούν να Χρησιμοποιηθούν:</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
Στην προτροπή, δώστε οποιαδήποτε λέξη για «password».
% cvs co modules
% more modules/modules</code></pre></div></div></div></div></div><div class=sect2><h3 id=_άλλες_πηγές_πληροφοριών>59.4. Άλλες Πηγές Πληροφοριών<a class=anchor href=#_άλλες_πηγές_πληροφοριών></a></h3><div class=paragraph><p>Οι παρακάτω πηγές πληροφοριών ίσως σας φανούν χρήσιμες για να μάθετε το CVS:</p></div><div class=ulist><ul><li><p><a href=http://users.csc.calpoly.edu/~gfisher/classes/308/handouts/cvs-basics.html>CVS Tutorial</a> από το California Polytechnic State University.</p></li><li><p><a href=http://www.nongnu.org/cvs/>CVS Home</a>, η ομάδα ανάπτυξης και υποστήριξης του CVS.</p></li><li><p><a href=http://www.FreeBSD.org/cgi/cvsweb.cgi>CVSweb</a> Διεπαφή Web για το CVS του FreeBSD Project.</p></li></ul></div></div></div></div><div class=sect1><h2 id=ctm>Chapter 60. Χρησιμοποιώντας το CTM<a class=anchor href=#ctm></a></h2><div class=sectionbody><div class=paragraph><p>Το CTM είναι μια μέθοδος να διατηρούμε σε συγχρονισμό ένα απομακρυσμένο κατάλογο με ένα κεντρικό. Αναπτύχθηκε για χρήση με το δέντρο πηγαίου κώδικα του FreeBSD, αν και άλλοι άνθρωποι μπορεί να το βρουν χρήσιμο και για διαφορετικούς σκοπούς καθώς περνάει ο καιρός. Τη δεδομένη στιγμή υπάρχει ελάχιστη ως ανύπαρκτη τεκμηρίωση για την διαδικασία δημιουργίας αρχείων διαφορών (deltas), και αν χρειάζεστε περισσότερες πληροφορίες, επικοινωνήστε με τη λίστα ταχυδρομείου <a href=https://lists.FreeBSD.org/subscription/ctm-users>ctm-users-desc</a> ειδικά αν θέλετε να χρησιμοποιήσετε το CTM για άλλες εφαρμογές.</p></div><div class=sect2><h3 id=_γιατί_πρέπει_να_χρησιμοποιήσω_το_ctm>60.1. Γιατί Πρέπει να Χρησιμοποιήσω το CTM;<a class=anchor href=#_γιατί_πρέπει_να_χρησιμοποιήσω_το_ctm></a></h3><div class=paragraph><p>Το CTM θα σας δώσει ένα τοπικό αντίγραφο του δέντρου πηγαίου κώδικα του FreeBSD. Υπάρχει διαθέσιμος ένας αριθμός από "γεύσεις" του δέντρου. Το CTM μπορεί να σας παρέχει τις πληροφορίες που χρειάζεστε, είτε αποφασίσετε να παρακολουθείτε ολόκληρο το δέντρο, είτε κάποιο από τα παρακλάδια του. Αν ανήκετε στα ενεργά μέλη ανάπτυξης του FreeBSD αλλά έχετε κακής ποιότητας (ή καθόλου) TCP/IP συνδεσιμότητα, ή απλά θέλετε οι αλλαγές να σας έρχονται αυτόματα, το CTM έχει φτιαχτεί για σας. Θα χρειαστεί να παίρνετε ως τρία deltas την ημέρα για τα κλαδιά του δέντρου που έχουν την πιο ενεργή ανάπτυξη. Θα πρέπει ωστόσο να θεωρήσετε ως καλύτερη λύση την αυτόματη αποστολή τους μέσω email. Τα μεγέθη των ανανεώσεων κρατούνται πάντα όσο το δυνατόν πιο μικρά. Συνήθως είναι μικρότερα από 5Κ, περιστασιακά (ένα στα δέκα) είναι από 10-50Κ και ορισμένες φορές εμφανίζονται και κάποια που είναι 100Κ ή και μεγαλύτερα.</p></div><div class=paragraph><p>Θα πρέπει επίσης να εξοικειωθείτε με τις διάφορες παγίδες που σχετίζονται με την απευθείας εργασία στον υπό ανάπτυξη πηγαίο κώδικα σε σχέση με μια έτοιμη, προκατασκευασμένη έκδοση. Αυτό ισχύει ακόμα περισσότερο αν επιλέξετε να χρησιμοποιήσετε τον πηγαίο κώδικα από το "current". Σας συνιστούμε να διαβάσετε πως να <a href=./#current>χρησιμοποιήσετε το current στο FreeBSD</a>.</p></div></div><div class=sect2><h3 id=_τι_χρειάζομαι_για_να_χρησιμοποιήσω_το_ctm>60.2. Τι Χρειάζομαι για να Χρησιμοποιήσω το CTM;<a class=anchor href=#_τι_χρειάζομαι_για_να_χρησιμοποιήσω_το_ctm></a></h3><div class=paragraph><p>Θα χρειαστείτε δύο πράγματα: Την εφαρμογή CTM και τις αρχικές αλλαγές (deltas) για να τις εισάγετε σε αυτήν (ώστε να φτάσετε στο επίπεδο του "current").</p></div><div class=paragraph><p>Το CTM είναι μέρος του FreeBSD από την έκδοση 2.0, και βρίσκεται στον κατάλογο <span class=filename>/usr/src/usr.sbin/ctm</span> εφόσον έχετε εγκατεστημένο τον πηγαίο κώδικα.</p></div><div class=paragraph><p>Τα "deltas" με τα οποία τροφοδοτείτε το CTM μπορείτε να τα αποκτήσετε με δύο τρόπους, μέσω FTP ή μέσω email. Αν έχετε γενική FTP πρόσβαση στο Internet, θα βρείτε υποστήριξη για το CTM στις ακόλουθες τοποθεσίες FTP:</p></div><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/CTM/>ftp://ftp.FreeBSD.org/pub/FreeBSD/CTM/</a></p></div><div class=paragraph><p>ή δείτε το τμήμα <a href=#mirrors-ctm>mirrors</a>.</p></div><div class=paragraph><p>Κάντε FTP στο σχετικό κατάλογο και διαβάστε το αρχείο <span class=filename>README</span> για να ξεκινήσετε.</p></div><div class=paragraph><p>Αν θέλετε να λαμβάνετε τα deltas μέσω email:</p></div><div class=paragraph><p>Γραφτείτε συνδρομητής σε μια από τις λίστες διανομής του CTM. Η λίστα <a href=https://lists.FreeBSD.org/subscription/ctm-cvs-cur>ctm-cvs-cur-desc</a> υποστηρίζει ολόκληρο το δέντρο του CVS. Η λίστα <a href=https://lists.FreeBSD.org/subscription/ctm-src-cur>ctm-src-cur-desc</a> υποστηρίζει την κεφαλή (head) του κλάδου ανάπτυξης (development branch). Η λίστα <a href=https://lists.FreeBSD.org/subscription/ctm-src-7>ctm-src-7-desc</a> υποστηρίζει την έκδοση 7.X κ.ο.κ. Αν δεν γνωρίζετε πως να εγγραφείτε σε μια λίστα, κάντε κλικ στο όνομα της λίστας που εμφανίζεται παραπάνω ή πηγαίνετε στο <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> και κάντε κλικ στη λίστα που θέλετε να εγγραφείτε. Η σελίδα της λίστας θα πρέπει να περιέχει όλες τις απαραίτητες πληροφορίες σχετικά με τις συνδρομές.</p></div><div class=paragraph><p>Όταν αρχίσετε να λαμβάνετε ανανεώσεις CTM μέσω mail, μπορείτε να χρησιμοποιήσετε το πρόγραμμα <code>ctm_rmail</code> για να τις αποσυμπιέσετε και να τις εφαρμόσετε. Μπορείτε στην πραγματικότητα να χρησιμοποιήσετε το πρόγραμμα <code>ctm_rmail</code> απευθείας μέσω μιας εγγραφής στο <span class=filename>/etc/aliases</span> αν θέλετε η διαδικασία να εκτελείται αυτοματοποιημένα. Δείτε τη σελίδα manual του <code>ctm_rmail</code> για περισσότερες λεπτομέρειες.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Άσχετα με τη μέθοδο που θα χρησιμοποιήσετε για να λάβετε τα deltas του CTM θα πρέπει να εγγραφείτε στη λίστα <a href=https://lists.FreeBSD.org/subscription/ctm-announce>ctm-announce-desc</a>. Στο μέλλον, αυτό θα είναι και το μόνο μέρος στο οποίο θα δημοσιεύονται πληροφορίες σχετικά με τις λειτουργίες του συστήματος CTM. Κάντε κλικ στο όνομα της παραπάνω λίστας, και ακολουθείστε τις οδηγίες για να εγγραφείτε.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_χρησιμοποιώντας_το_ctm_για_πρώτη_φορά>60.3. Χρησιμοποιώντας το CTM για Πρώτη Φορά<a class=anchor href=#_χρησιμοποιώντας_το_ctm_για_πρώτη_φορά></a></h3><div class=paragraph><p>Πριν αρχίσετε να χρησιμοποιείτε CTM deltas, θα πρέπει να έχετε ένα σημείο εκκίνησης για τα delta που έχουν δημιουργηθεί μετά από αυτό.</p></div><div class=paragraph><p>Θα πρέπει πρώτα να καθορίσετε τι έχετε ήδη. Οποιοσδήποτε μπορεί να αρχίσει από ένα "άδειο" κατάλογο. Θα πρέπει να ξεκινήσετε με ένα αρχικό "Κενό" delta για να αρχίσετε με το CTM δέντρο σας. Από κάποιο σημείο θεωρούμε ότι ένα από αυτά τα "αρχικά" deltas θα διανέμονται σε CD για τη δική σας διευκόλυνση, ωστόσο αυτό δεν συμβαίνει τη δεδομένη στιγμή.</p></div><div class=paragraph><p>Καθώς τα δέντρα είναι αρκετές δεκάδες megabytes, είναι προτιμότερο να ξεκινήσετε από κάτι που έχετε ήδη. Αν έχετε CD κάποιας διανομής (RELEASE), μπορείτε να αντιγράψετε ή να αποσυμπιέσετε από εκεί τον αρχικό πηγαίο κώδικα. Έτσι θα γλυτώσετε σημαντικό μέρος της μεταφοράς δεδομένων.</p></div><div class=paragraph><p>Μπορείτε να αναγνωρίσετε αυτά τα "αρχικά" deltas από το <code>X</code> που ακολουθεί τον αριθμό τους (για παράδειγμα <span class=filename>src-cur.3210XEmpty.gz</span>). Ο χαρακτηρισμός μετά το <code>X</code> αντιστοιχεί στην πηγή του αρχικού σας "seed". Το <span class=filename>Empty</span> είναι ένας άδειος κατάλογος. Κατά κανόνα δημιουργείται μια μετάβαση από το <code>Empty</code> κάθε 100 deltas. Επίσης τα αρχεία αυτά είναι μεγάλα! Συνηθισμένο μέγεθος για <span class=filename>XEmpty</span> deltas είναι τα 70 ως 80 MB συμπιεσμένων με <code>gzip</code> δεδομένων.</p></div><div class=paragraph><p>Μόλις επιλέξετε ένα βασικό delta για να ξεκινήσετε, θα χρειαστείτε επίσης όλα τα deltas με μεγαλύτερους από αυτό αριθμούς.</p></div></div><div class=sect2><h3 id=_χρησιμοποιώντας_το_ctm_στην_καθημερινή_σας_ζωή>60.4. Χρησιμοποιώντας το CTM στην Καθημερινή σας Ζωή<a class=anchor href=#_χρησιμοποιώντας_το_ctm_στην_καθημερινή_σας_ζωή></a></h3><div class=paragraph><p>Για να εφαρμόσετε τα deltas, απλώς γράψτε:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /where/ever/you/want/the/stuff</span>
<span class=c># ctm -v -v /where/you/store/your/deltas/src-xxx.*</span></code></pre></div></div><div class=paragraph><p>Το CTM αντιλαμβάνεται deltas τα οποία έχουν συμπιεστεί μέσω <code>gzip</code>, και έτσι δεν χρειάζεται να χρησιμοποιήσετε την <code>gunzip</code>, γλυτώνοντας με αυτό τον τρόπο χώρο στο δίσκο.</p></div><div class=paragraph><p>Το CTM δεν πρόκειται να πειράξει τα αρχεία σας αν δεν είναι απόλυτα σίγουρο για τη διαδικασία ανανέωσης. Για να επαληθεύσετε ένα delta μπορείτε επίσης να χρησιμοποιήσετε την επιλογή <code>-c</code> και το CTM δεν θα πειράξει τίποτα, απλώς θα επαληθεύσει την ακεραιότητα του delta και θα δει αν μπορεί να το εφαρμόσει χωρίς προβλήματα στο τρέχον δέντρο.</p></div><div class=paragraph><p>Υπάρχουν και άλλες επιλογές στο CTM, δείτε τις αντίστοιχες σελίδες manual ή κοιτάξτε τον πηγαίο κώδικα για περισσότερες πληροφορίες.</p></div><div class=paragraph><p>Αυτό είναι όλο στην πραγματικότητα. Κάθε φορά που λαμβάνετε ένα νέο delta, απλώς περάστε το στο CTM ώστε να έχετε πάντοτε ανανεωμένο τον πηγαίο σας κώδικα.</p></div><div class=paragraph><p>Μην σβήνετε τα deltas αν είναι δύσκολο να τα κατεβάσετε ξανά. Ίσως θέλετε να τα φυλάξετε για την περίπτωση που κάτι πάει στραβά. Ακόμα και αν το μόνο μέσο που έχετε είναι δισκέτες, κάντε αντίγραφο χρησιμοποιώντας την <code>fdwrite</code>.</p></div></div><div class=sect2><h3 id=_κρατώντας_τις_τοπικές_σας_αλλαγές>60.5. Κρατώντας τις Τοπικές σας Αλλαγές<a class=anchor href=#_κρατώντας_τις_τοπικές_σας_αλλαγές></a></h3><div class=paragraph><p>Ως προγραμματιστής, θα θέλετε να πειραματιστείτε και να αλλάξετε αρχεία στο δέντρο του πηγαίου κώδικα. Το CTM υποστηρίζει περιορισμένου τύπου τοπικές αλλαγές: πριν ελέγξει για την παρουσία ενός αρχείου <span class=filename>foo</span>, ελέγχει πρώτα για το <span class=filename>foo.ctm</span>. Αν το αρχείο αυτό υπάρχει, το CTM θα χρησιμοποιήσει αυτό αντί για το <span class=filename>foo</span>.</p></div><div class=paragraph><p>Η συμπεριφορά αυτή μας παρέχει ένα απλό τρόπο να διατηρήσουμε τοπικές αλλαγές: απλώς αντιγράψτε τα αρχεία που σκοπεύετε να αλλάξετε σε αντίστοιχα αρχεία με κατάληξη <span class=filename>.ctm</span>. Μπορείτε κατόπιν να κάνετε ότι αλλαγές θέλετε στον κώδικα ενώ το CTM θα διατηρεί ανανεωμένο το αρχείο <span class=filename>.ctm</span>.</p></div></div><div class=sect2><h3 id=_άλλες_ενδιαφέρουσες_επιλογές_του_ctm>60.6. Άλλες Ενδιαφέρουσες Επιλογές του CTM<a class=anchor href=#_άλλες_ενδιαφέρουσες_επιλογές_του_ctm></a></h3><div class=sect3><h4 id=_βρίσκοντας_τι_ακριβώς_θα_αλλάξει_σε_μια_ανανέωση>60.6.1. Βρίσκοντας τι Ακριβώς θα Αλλάξει σε μια Ανανέωση<a class=anchor href=#_βρίσκοντας_τι_ακριβώς_θα_αλλάξει_σε_μια_ανανέωση></a></h4><div class=paragraph><p>Μπορείτε να προσδιορίσετε τις αλλαγές που θα προκαλέσει το CTM στο repository του πηγαίου σας κώδικα, χρησιμοποιώντας την επιλογή <code>-l</code>.</p></div><div class=paragraph><p>Αυτό θα είναι χρήσιμο αν θέλετε να κρατήσετε ημερολόγιο των αλλαγών, αν θέλετε να επεξεργαστείτε τα τροποποιημένα αρχεία πριν ή μετά την τροποποίηση τους, ή αν απλώς αισθάνεστε ελαφρώς παρανοϊκός.</p></div></div><div class=sect3><h4 id=_δημιουργώντας_αντίγραφα_ασφαλείας_πριν_την_ανανέωση>60.6.2. Δημιουργώντας Αντίγραφα Ασφαλείας πριν την Ανανέωση<a class=anchor href=#_δημιουργώντας_αντίγραφα_ασφαλείας_πριν_την_ανανέωση></a></h4><div class=paragraph><p>Μερικές φορές θα θέλετε να κρατήσετε αντίγραφο ασφαλείας όλων των αρχείων που πρόκειται να αλλαχθούν από μια ανανέωση μέσω CTM.</p></div><div class=paragraph><p>Δίνοντας την επιλογή <code>-B backup-file</code> το CTM θα δημιουργήσει αντίγραφο ασφαλείας όλων των αρχείων που πρόκειται να αλλαχθούν από κάποιο συγκεκριμένο delta στο αρχείο <span class=filename>backup-file</span>.</p></div></div><div class=sect3><h4 id=_περιορίζοντας_τα_αρχεία_που_θα_αλλαχθούν_από_κάποια_ανανέωση>60.6.3. Περιορίζοντας τα Αρχεία που θα Αλλαχθούν από Κάποια Ανανέωση<a class=anchor href=#_περιορίζοντας_τα_αρχεία_που_θα_αλλαχθούν_από_κάποια_ανανέωση></a></h4><div class=paragraph><p>Μερικές φορές ίσως να ενδιαφέρεστε να περιορίσετε την περιοχή δράσης μιας συγκεκριμένης ανανέωσης μέσω CTM ή ίσως σας ενδιαφέρει να πάρετε μόνο λίγα αρχεία από κάποια σειρά από deltas.</p></div><div class=paragraph><p>Μπορείτε να ελέγξετε τη λίστα των αρχείων στα οποία θα λειτουργήσει το CTM χρησιμοποιώντας ως φίλτρα, regular expressions με τις επιλογές <code>-e</code> και <code>-x</code>.</p></div><div class=paragraph><p>Για παράδειγμα, για να εξάγετε ένα ανανεωμένο αντίγραφο του αρχείου <span class=filename>lib/libc/Makefile</span> από την συλλογή σας των αποθηκευμένων CTM deltas, εκτελέστε τις εντολές:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /where/ever/you/want/to/extract/it/</span>
<span class=c># ctm -e &#39;^lib/libc/Makefile&#39; ~ctm/src-xxx.*</span></code></pre></div></div><div class=paragraph><p>Για κάθε αρχείο που καθορίζεται σε ένα CTM delta, οι επιλογές <code>-e</code> και <code>-x</code> εφαρμόζονται με τη σειρά που εμφανίζονται στη γραμμή εντολών. Στο αρχείο γίνεται επεξεργασία από το CTM, μόνο αν μαρκαριστεί ως έγκυρο προς ανανέωση μετά την εφαρμογή όλων των επιλογών <code>-e</code> και <code>-x</code>.</p></div></div></div><div class=sect2><h3 id=_μελλοντικά_σχέδια_για_το_ctm>60.7. Μελλοντικά Σχέδια για το CTM<a class=anchor href=#_μελλοντικά_σχέδια_για_το_ctm></a></h3><div class=paragraph><p>Είναι πάρα πολλά:</p></div><div class=ulist><ul><li><p>Χρήση κάποιου είδους πιστοποίησης στο σύστημα CTM ώστε να αναγνωρίζονται τυχόν ψεύτικες ανανεώσεις.</p></li><li><p>Ξεκαθάρισμα των επιλογών του CTM, καθώς προκαλούν σύγχυση και δεν είναι προφανείς.</p></li></ul></div></div><div class=sect2><h3 id=_διάφορα_2>60.8. Διάφορα<a class=anchor href=#_διάφορα_2></a></h3><div class=paragraph><p>Υπάρχει επίσης και μια σειρά από deltas για την συλλογή των <code>ports</code>, αλλά δεν έχει εκδηλωθεί ακόμα αρκετό ενδιαφέρον για αυτή.</p></div></div><div class=sect2><h3 id=mirrors-ctm>60.9. CTM Mirrors<a class=anchor href=#mirrors-ctm></a></h3><div class=paragraph><p>Το <a href=#ctm>CTM</a>/FreeBSD διατίθεται μέσω ανώνυμου FTP από τα ακόλουθα mirrors. Αν επιλέξετε να κατεβάσετε το CTM μέσω ανώνυμου FTP, σας παρακαλούμε προσπαθήστε να επιλέξετε μια τοποθεσία κοντά σε σας.</p></div><div class=paragraph><p>Σε περίπτωση προβλημάτων, παρακαλούμε επικοινωνήστε με τη λίστα <a href=https://lists.FreeBSD.org/subscription/ctm-users>ctm-users-desc</a>.</p></div><div class=dlist><dl><dt class=hdlist1>Καλιφόρνια, Bay Area, επίσημη πηγή</dt><dd><div class=ulist><ul><li><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li></ul></div></dd><dt class=hdlist1>Νότια Αφρική, αντίγραφα ασφαλείας για παλιά deltas</dt><dd><div class=ulist><ul><li><p><a href=ftp://ftp.za.FreeBSD.org/pub/FreeBSD/CTM/>ftp://ftp.za.FreeBSD.org/pub/FreeBSD/CTM/</a></p></li></ul></div></dd><dt class=hdlist1>Ταϊβάν/R.O.C.</dt><dd><div class=ulist><ul><li><p><a href=ftp://ctm.tw.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ctm.tw.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li><li><p><a href=ftp://ctm2.tw.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ctm2.tw.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li><li><p><a href=ftp://ctm3.tw.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ctm3.tw.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li></ul></div></dd></dl></div><div class=paragraph><p>Αν δεν βρήκατε κάποιο mirror στην περιοχή σας, ή αν το mirror δεν είναι πλήρες, προσπαθήστε να χρησιμοποιήσετε μια μηχανή αναζήτησης όπως η <a href=http://www.alltheweb.com/>alltheweb</a>.</p></div></div></div></div><div class=sect1><h2 id=cvsup>Chapter 61. Χρησιμοποιώντας το CVSup<a class=anchor href=#cvsup></a></h2><div class=sectionbody><div class=sect2><h3 id=cvsup-intro>61.1. Εισαγωγή<a class=anchor href=#cvsup-intro></a></h3><div class=paragraph><p>Το CVSup είναι ένα λογισμικό για την διανομή και ανανέωση δέντρων πηγαίου κώδικα από ένα κεντρικό (master) CVS repository το οποίο βρίσκεται σε κάποιο απομακρυσμένο υπολογιστή. Το repository του FreeBSD βρίσκεται σε ένα κεντρικό μηχάνημα στην Καλιφόρνια. Με το CVSup, οι χρήστες του FreeBSD μπορούν εύκολα να διατηρήσουν ανανεωμένα τα αντίγραφα του πηγαίου τους κώδικα.</p></div><div class=paragraph><p>Το CVSup χρησιμοποιεί ένα μοντέλο ανανέωσης γνωστό ως <em>pull</em>. Στο μοντέλο αυτό, κάθε πελάτης ζητά τις ανανεώσεις από τον εξυπηρετητή, όταν και αν τις επιθυμεί. Ο εξυπηρετητής περιμένει, παθητικά, τις απαιτήσεις από τους πελάτες. Με τον τρόπο αυτό, κάθε ανανέωση ξεκινάει κατόπιν απαίτησης του πελάτη. Ο εξυπηρετητής ποτέ δεν στέλνει ανανεώσεις που δεν έχουν ζητηθεί. Οι χρήστες θα πρέπει είτε να εκτελέσουν το CVSup χειροκίνητα για να λάβουν μια ανανέωση, είτε θα πρέπει να ρυθμίσουν κατάλληλα το <code>cron</code> ώστε να το εκτελεί αυτόματα κατά τακτά χρονικά διαστήματα.</p></div><div class=paragraph><p>Ο όρος CVSup, γραμμένος με κεφαλαία και μικρά όπως φαίνεται, αναφέρεται σε ολόκληρο το πακέτο λογισμικού. Τα βασικά του τμήματα είναι η εντολή πελάτη <code>cvsup</code> η οποία εκτελείται στο μηχάνημα του κάθε χρήστη, και το πρόγραμμα του εξυπηρετητή <code>cvsupd</code> το οποίο εκτελείται σε κάθε ένα από τα mirror sites του FreeBSD.</p></div><div class=paragraph><p>Καθώς διαβάζετε την τεκμηρίωση και τις λίστες ταχυδρομείου του FreeBSD, μπορεί να βρείτε αναφορές στην εφαρμογή sup. Το sup ήταν ο πρόγονος του CVSup, και εξυπηρετούσε παρόμοιο σκοπό. Το CVSup χρησιμοποιείται με αρκετά όμοιο τρόπο με το sup, και στην πραγματικότητα, χρησιμοποιεί αρχεία ρυθμίσεων τα οποία έχουν πίσω συμβατότητα με αυτά του <code>sup</code>. Το sup δεν χρησιμοποιείται πλέον στο FreeBSD Project, επειδή το CVSup είναι ταχύτερο και προσφέρει μεγαλύτερη ευελιξία.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Το πρόγραμμα csup είναι το CVSup ξαναγραμμένο σε γλώσσα C. Το μεγαλύτερο του πλεονέκτημα είναι ότι είναι ταχύτερο, και δεν εξαρτάται από την γλώσσα προγραμματισμού Modula-3, την οποία και δεν χρειάζεται πλέον να εγκαταστήσετε. Επίσης μπορείτε να το χρησιμοποιήσετε άμεσα, καθώς περιλαμβάνεται στο βασικό σύστημα. Αν αποφασίσετε να χρησιμοποιήσετε το csup, απλώς παραλείψτε τα βήματα για την εγκατάσταση του CVSup και αντικαταστήστε κάθε αναφορά στο CVSup σε αυτό το άρθρο, με csup.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=cvsup-install>61.2. Εγκατάσταση<a class=anchor href=#cvsup-install></a></h3><div class=paragraph><p>Ο ευκολότερος τρόπος για να εγκαταστήσετε το CVSup είναι μέσω του έτοιμου πακέτου <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a> από την <a href=./#ports>συλλογή πακέτων</a> του FreeBSD. Αν προτιμάτε να μεταγλωττίσετε το CVSup από τον πηγαίο κώδικα, μπορείτε να χρησιμοποιήσετε το port <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a>. Σας προειδοποιούμε ωστόσο ότι το port <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a> εξαρτάται από την Modula-3, η οποία χρειάζεται αρκετό χρόνο και χώρο στο δίσκο για να κατέβει και να μεταγλωττιστεί.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Αν πρόκειται να χρησιμοποιήσετε το CVSup σε ένα μηχάνημα το οποίο δεν θα διαθέτει γραφικό περιβάλλον μέσω του Xorg, όπως π.χ. σε ένα εξυπηρετητή, βεβαιωθείτε ότι εγκαθιστάτε το αντίστοιχο port το οποίο δεν περιλαμβάνει γραφικό περιβάλλον, δηλαδή το <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup-without-gui/>net/cvsup-without-gui</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=cvsup-config>61.3. Ρύθμιση του CVSup<a class=anchor href=#cvsup-config></a></h3><div class=paragraph><p>Η λειτουργία του CVSup ελέγχεται από ένα αρχείο ρυθμίσεων που καλείται <span class=filename>supfile</span>. Υπάρχουν κάποια υποδείγματα από <span class=filename>supfiles</span> στον κατάλογο <a href=file://localhost/usr/shared/examples/cvsup/>/usr/shared/examples/cvsup/</a>.</p></div><div class=paragraph><p>Οι πληροφορίες στο <span class=filename>supfile</span> απαντούν τις ακόλουθες ερωτήσεις για το CVSup:</p></div><div class=ulist><ul><li><p><a href=#cvsup-config-files>Ποια αρχεία θέλετε να λάβετε;</a></p></li><li><p><a href=#cvsup-config-vers>Ποιες εκδόσεις των αρχείων θέλετε;</a></p></li><li><p><a href=#cvsup-config-where>Από που θέλετε να τα λάβετε;</a></p></li><li><p><a href=#cvsup-config-dest>Που θέλετε να τα αποθηκεύσετε στο μηχάνημα σας;</a></p></li><li><p><a href=#cvsup-config-status>Που θέλετε να αποθηκεύσετε τα αρχεία κατάστασης;</a></p></li></ul></div><div class=paragraph><p>Στα επόμενα τμήματα, θα δημιουργήσουμε ένα τυπικό <span class=filename>supfile</span> απαντώντας κάθε μια από τις ερωτήσεις αυτές με τη σειρά. Πρώτα, θα περιγράψουμε τη συνολική δομή ενός <span class=filename>supfile</span>.</p></div><div class=paragraph><p>Ένα <span class=filename>supfile</span> είναι ένα αρχείο κειμένου. Τα σχόλια ξεκινάνε με <code>#</code> και επεκτείνονται ως το τέλος της γραμμής. Οι κενές γραμμές, καθώς και αυτές που περιέχουν μόνο σχόλια, αγνοούνται.</p></div><div class=paragraph><p>Κάθε γραμμή από τις υπόλοιπες περιγράφει ένα σετ αρχείων τα οποία επιθυμεί να λάβει ο χρήστης. Η γραμμή ξεκινάει με το όνομα μιας "συλλογής", ενός λογικού γκρουπ από αρχεία που ορίζεται από τον εξυπηρετητή. Το όνομα της συλλογής δηλώνει στον εξυπηρετητή ποια αρχεία επιθυμείτε. Μετά το όνομα της συλλογής, μπορεί να υπάρχουν από μηδέν ως κάποια πεδία, τα οποία χωρίζονται μεταξύ τους με κενά διαστήματα. Τα πεδία αυτά απαντούν τις ερωτήσεις που τέθηκαν παραπάνω. Υπάρχουν δύο τύποι πεδίων: πεδία σήμανσης (flags) και πεδία τιμών. Ένα πεδίο σήμανσης αποτελείται από μια μόνο λέξη κλειδί π.χ. <code>delete</code> ή <code>compress</code>. Ένα πεδίο τιμής ξεκινάει επίσης με μια λέξη κλειδί, αλλά αυτή ακολουθείτε χωρίς την παρεμβολή κενού διαστήματος από <code>=</code> και μια δεύτερη λέξη. Για παράδειγμα το <code>release=cvs</code> αποτελεί ένα πεδίο τιμής.</p></div><div class=paragraph><p>Ένα <span class=filename>supfile</span> τυπικά καθορίζει προς λήψη περισσότερες από μία συλλογές. Ένα τρόπος για να δομήσετε ένα <span class=filename>supfile</span> είναι να καθορίσετε όλα τα σχετικά πεδία χωριστά για κάθε συλλογή. Με τον τρόπο αυτό ωστόσο το <span class=filename>supfile</span> θα καταλάβει αρκετές γραμμές και θα είναι άβολο, επειδή τα περισσότερα πεδία είναι ίδια για όλες τις συλλογές που περιέχονται σε αυτό. Το CVSup παρέχει ένα μηχανισμό χρήσης προεπιλεγμένων τιμών, ώστε να αποφεύγονται αυτά τα προβλήματα. Οι γραμμές που ξεκινάνε με το ειδικό όνομα ψευτό-συλλογής <code>*default</code> μπορούν να χρησιμοποιηθούν για να θέσουν πεδία σήμανσης και τιμών τα οποία θα χρησιμοποιηθούν ως προεπιλογές για τις συλλογές του <span class=filename>supfile</span> που βρίσκονται μετά από αυτά. Μια προεπιλεγμένη τιμή μπορεί να αλλάξει αν καθοριστεί ξανά με νέα τιμή μέσα στην ίδια τη συλλογή. Οι προεπιλογές μπορούν επίσης να αλλάξουν, ή να προστεθούν νέες, βάζοντας πρόσθετα <code>*default</code> σε οποιοδήποτε σημείο μέσα στο <span class=filename>supfile</span>.</p></div><div class=paragraph><p>Γνωρίζοντας τα παραπάνω, θα προχωρήσουμε τώρα στη δόμηση ενός <span class=filename>supfile</span> για λήψη και ανανέωση του κυρίως δέντρου πηγαίου κώδικα για το <a href=./#current>FreeBSD-CURRENT</a>.</p></div><div class=ulist><ul><li><p><a id=cvsup-config-files></a>Ποια αρχεία θέλετε να λάβετε;</p><div class=paragraph><p>Τα αρχεία που είναι διαθέσιμα μέσω της CVSup είναι οργανωμένα σε γκρουπ που ονομάζονται "συλλογές". Περιγραφή των διαθέσιμων συλλογών θα βρείτε στο <a href=#cvsup-collec>ακόλουθο τμήμα</a>. Στο παράδειγμα μας, θέλουμε να λάβουμε το πλήρες δέντρο πηγαίου κώδικα του FreeBSD συστήματος. Υπάρχει μια μεγάλη συλλογή <code>src-all</code> η οποία θα μας την δώσει όλη. Σαν πρώτο βήμα για την δόμηση του <span class=filename>supfile</span>, απλώς γράφουμε τις συλλογές, μία σε κάθε γραμμή (στην περίπτωση μας έχουμε μόνο μια γραμμή):</p></div><div class="literalblock programlisting"><div class=content><pre>src-all</pre></div></div></li><li><p><a id=cvsup-config-vers></a>Ποιες εκδόσεις των αρχείων θέλετε να λάβετε;</p><div class=paragraph><p>Με το CVSup, μπορείτε ουσιαστικά να λάβετε οποιαδήποτε έκδοση του πηγαίου κώδικα υπήρξε ποτέ. Αυτό είναι δυνατόν επειδή ο εξυπηρετητής cvsupd λειτουργεί απευθείας από το CVS repository, το οποίο περιέχει όλες τις εκδόσεις. Δηλώνετε ποια από αυτές θέλετε χρησιμοποιώντας τα πεδία τιμών <code>tag=</code> και <code>date=</code>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Θα πρέπει να δώσετε ιδιαίτερη προσοχή στον καθορισμό των πεδίων <code>tag=</code> ώστε να είναι σωστά. Κάποια tags είναι έγκυρα μόνο για συγκεκριμένες συλλογές αρχείων. Αν καθορίσετε λανθασμένο tag (ή κάνετε ορθογραφικό λάθος) το CVSup θα σβήσει αρχεία τα οποία πιθανώς δεν θέλετε να σβηστούν. Ειδικότερα, για την συλλογή των <code>ports-*</code>, χρησιμοποιήστε _ μόνο το_ <code>tag=.</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Το πεδίο <code>tag=</code> δείχνει προς ένα συμβολικό tag στο repository. Υπάρχουν δύο είδη tags, τα tags εκδόσεων (revision tags) και τα tags κλάδων (branch tags). Ένα revision tag αναφέρεται σε μια συγκεκριμένη έκδοση. Η σημασία του διατηρείται ίδια από τη μια μέρα στην άλλη. Από την άλλη, ένα branch tag, αναφέρεται στην τελευταία έκδοση μια συγκεκριμένης γραμμής ανάπτυξης, σε κάθε χρονική στιγμή. Επειδή ένα branch tag δεν αναφέρεται σε κάποια συγκεκριμένη έκδοση, μπορεί αύριο να σημαίνει κάτι διαφορετικό από ότι σημαίνει σήμερα.</p></div><div class=paragraph><p>Στο <a href=#cvs-tags>Ετικέτες (Tags) για το CVS</a> θα βρείτε branch tags τα οποία μπορεί να σας ενδιαφέρουν. Όταν καθορίζετε ένα tag στο αρχείο ρυθμίσεων του CVSup, θα πρέπει πριν από αυτό να βάζετε τη λέξη κλειδί <code>tag=</code> (δηλ. το <code>RELENG_8</code> θα γίνει <code>tag=RELENG_8</code>). Να έχετε υπόψιν σας ότι για την συλλογή των Ports, το <code>tag=.</code> είναι το μόνο έγκυρο.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Να είστε ιδιαίτερα προσεκτικός, ώστε να γράψετε το tag ακριβώς όπως φαίνεται. Το CVSup δεν μπορεί να διαχωρίσει μεταξύ έγκυρων και μη-έγκυρων tags. Αν γράψετε λάθος το tag, το CVSup θα συμπεριφερθεί σαν να έχετε δώσει ένα έγκυρο tag το οποίο δεν αναφέρεται σε κανένα αρχείο. Στην περίπτωση αυτή θα διαγράψει τα υπάρχοντα αρχεία σας πηγαίου κώδικα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Όταν καθορίσετε κάποιο branch tag, φυσιολογικά θα λάβετε τις τελευταίες εκδόσεις των αρχείων που υπάρχουν σε αυτή τη γραμμή ανάπτυξης. Αν θέλετε να λάβετε κάποιες παλιότερες εκδόσεις, μπορείτε να το κάνετε καθορίζοντας μια ημερομηνία μέσω του πεδίου τιμών <code>date=</code>. Η σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> εξηγεί πως μπορείτε να το κάνετε.</p></div><div class=paragraph><p>Στο παράδειγμα μας, επιθυμούμε να λάβουμε το FreeBSD-CURRENT. Προσθέτουμε τη γραμμή αυτή στην αρχή του <span class=filename>supfile</span> αρχείου μας:</p></div><div class="literalblock programlisting"><div class=content><pre>*default tag=.</pre></div></div><div class=paragraph><p>Υπάρχει μια σημαντική ειδική περίπτωση όταν δεν καθορίσετε ούτε πεδίο <code>tag=</code> ούτε πεδίο <code>date=</code>. Στην περίπτωση αυτή θα λάβετε τα κανονικά αρχεία RCS απευθείας από το CVS repository του εξυπηρετητή, αντί για να λάβετε κάποια συγκεκριμένη έκδοση. Οι προγραμματιστές γενικά προτιμούν αυτό τον τρόπο λειτουργίας. Διατηρώντας πλήρες αντίγραφο του CVS repository στα συστήματα τους έχουν την ικανότητα να βλέπουν το ιστορικό αλλαγών κάθε έκδοσης και να εξετάζουν παλιότερες εκδόσεις των αρχείων. Τα παραπάνω πλεονεκτήματα ωστόσο έχουν το κόστος της μεγαλύτερης χρήσης χώρου στο σκληρό δίσκο.</p></div></li><li><p><a id=cvsup-config-where></a>Από που θέλετε να τα λάβετε;</p><div class=paragraph><p>Χρησιμοποιούμε το πεδίο <code>host=</code> για να πούμε στο <code>cvsup</code> από που να λάβει τις ανανεώσεις του. Οποιοδήποτε από τα <a href=#cvsup-mirrors>CVSup mirror sites</a> είναι κατάλληλο, αν και θα πρέπει να προσπαθήσετε να επιλέξετε κάποιο το οποίο να βρίσκεται κοντά σας. Στο παράδειγμα μας, θα χρησιμοποιήσουμε μια φανταστική τοποθεσία διανομής του FreeBSD, το <code>cvsup99.FreeBSD.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>*default host=cvsup99.FreeBSD.org</pre></div></div><div class=paragraph><p>Θα πρέπει να αλλάξετε το host σε κάποιο που πραγματικά υπάρχει πριν εκτελέσετε το CVSup. Κάθε φορά που εκτελείτε το <code>cvsup</code>, έχετε την δυνατότητα να ανατρέπετε αυτή τη ρύθμιση μέσω της γραμμής εντολών με την επιλογή <code>-h <em>hostname</em></code>.</p></div></li><li><p><a id=cvsup-config-dest></a>Που θέλετε να τα αποθηκεύσετε στο μηχάνημα σας;</p><div class=paragraph><p>Το πεδίο <code>prefix=</code> δηλώνει στην <code>cvsup</code> που να αποθηκεύσει τα αρχεία που λαμβάνει. Στο παράδειγμα μας, θα βάλουμε τα αρχεία του πηγαίου κώδικα, απευθείας στο κύριο δέντρο πηγαίου κώδικα, <span class=filename>/usr/src</span>. Ο κατάλογος <span class=filename>src</span> θεωρείται δεδομένος για τις συλλογές που έχουμε επιλέξει να λάβουμε, και έτσι ο σωστός προσδιορισμός είναι αυτός που φαίνεται παρακάτω:</p></div><div class="literalblock programlisting"><div class=content><pre>*default prefix=/usr</pre></div></div></li><li><p><a id=cvsup-config-status></a>Που θα αποθηκεύσει το <code>cvsup</code> τα αρχεία κατάστασης του;</p><div class=paragraph><p>Ο πελάτης CVSup διατηρεί κάποια αρχεία κατάστασης (status files) σε αυτό που αποκαλείται κατάλογος "base". Τα αρχεία αυτά βοηθούν το CVSup να λειτουργεί πιο αποδοτικά κρατώντας λογαριασμό των ανανεώσεων που έχετε ήδη λάβει. Θα χρησιμοποιήσουμε τον προεπιλεγμένο κατάλογο base, <span class=filename>/var/db</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>*default base=/var/db</pre></div></div><div class=paragraph><p>Αν ο base κατάλογος σας δεν υπάρχει ήδη, τώρα είναι μια καλή στιγμή να τον δημιουργήσετε. O πελάτης <code>cvsup</code> δεν θα εκτελείται αν ο base κατάλογος δεν υπάρχει.</p></div></li><li><p>Διάφορες ρυθμίσεις για το <span class=filename>supfile</span>:</p><div class=paragraph><p>Υπάρχει ακόμα μια κοινή γραμμή ρυθμίσεων, η οποία τυπικά υπάρχει στο <span class=filename>supfile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>*default release=cvs delete use-rel-suffix compress</pre></div></div><div class=paragraph><p>Το <code>release=cvs</code> δείχνει ότι ο εξυπηρετητής θα πρέπει να λάβει τις πληροφορίες του μέσω του κύριου CVS repository του FreeBSD. Αυτό ισχύει σχεδόν πάντα, αλλά υπάρχουν και άλλες πιθανότητες που ξεφεύγουν από το σκοπό αυτής της συζήτησης.</p></div><div class=paragraph><p>Η λέξη <code>delete</code> δίνει δικαιώματα στο CVSup να διαγράφει αρχεία. Θα πρέπει πάντοτε να έχετε την επιλογή αυτή, ώστε το CVSup να μπορεί να κρατήσει το δέντρο του πηγαίου σας κώδικα πλήρως ανανεωμένο. Το CVSup είναι αρκετά προσεκτικό ώστε να σβήνει μόνο τα αρχεία που βρίσκονται υπό την ευθύνη του. Αν τυχόν βάλετε έξτρα αρχεία στον ίδιο κατάλογο, δεν θα τα αγγίξει.</p></div><div class=paragraph><p>Η επιλογή <code>use-rel-suffix</code> είναι…​ αρχαιολογική. Αν πραγματικά θέλετε να μάθετε σχετικά με αυτήν, διαβάστε τη σελίδα manual <a href="https://man.freebsd.org/cgi/man.cgi?query=cvsup&amp;sektion=1&amp;format=html">cvsup(1)</a>. Αλλιώς, απλώς χρησιμοποιήστε την, και μην ανησυχείτε ιδιαίτερα για αυτή.</p></div><div class=paragraph><p>Η επιλογή <code>compress</code> ενεργοποιεί τη χρήση συμπίεσης τύπου gzip στο κανάλι επικοινωνίας. Αν έχετε σύνδεση δικτύου τύπου T1 ή και πιο γρήγορη, μάλλον δεν θα πρέπει να χρησιμοποιήσετε συμπίεση. Σε διαφορετική περίπτωση, θα βοηθήσει εξαιρετικά.</p></div></li><li><p>Όλες οι επιλογές μαζί:</p><div class=paragraph><p>Εδώ είναι το πλήρες <span class=filename>supfile</span> για το παράδειγμα μας:</p></div><div class="literalblock programlisting"><div class=content><pre>*default tag=.
*default host=cvsup99.FreeBSD.org
*default prefix=/usr
*default base=/var/db
*default release=cvs delete use-rel-suffix compress

src-all</pre></div></div></li></ul></div><div class=sect3><h4 id=cvsup-refuse-file>61.3.1. Το Αρχείο <span class=filename>refuse</span><a class=anchor href=#cvsup-refuse-file></a></h4><div class=paragraph><p>Όπως αναφέραμε παραπάνω, το CVSup χρησιμοποιεί <em>μέθοδο pull</em>. Βασικά αυτό σημαίνει ότι συνδέεστε στον εξυπηρετητή CVSup, αυτός λέει "Αυτά είναι τα αρχεία που μπορείτε να κατεβάσετε από μένα..", και το δικό σας πρόγραμμα απαντάει "Εντάξει, θα πάρω αυτό, αυτό, αυτό, και αυτό." Στην προεπιλεγμένη ρύθμιση, ο πελάτης CVSup θα πάρει κάθε αρχείο που συνδέεται με την συλλογή και το tag που έχετε καθορίσει στο αρχείο ρυθμίσεων. Ωστόσο μπορεί να μην το επιθυμείτε αυτό πάντα, ειδικά αν συγχρονίζετε τα δέντρα <span class=filename>doc</span>, <span class=filename>ports</span> ή <span class=filename>www</span> - οι περισσότεροι άνθρωποι δεν μπορούν να διαβάσουν τέσσερις ή πέντε γλώσσες και έτσι δεν χρειάζεται να κατεβάσουν αρχεία που αναφέρονται ειδικά σε αυτές. Αν χρησιμοποιείτε το CVSup για την συλλογή των Ports, μπορείτε να ξεπεράσετε αυτή τη συμπεριφορά καθορίζοντας συγκεκριμένες συλλογές (π.χ. <em>ports-astrology</em>, <em>ports-biology</em> αντί για <em>ports-all</em>). Ωστόσο, επειδή τα δέντρα <span class=filename>doc</span> και <span class=filename>www</span> δεν διαθέτουν συλλογές χωρισμένες ανά γλώσσα, μπορείτε να χρησιμοποιήσετε ένα από τα βολικά χαρακτηριστικά του CVSup: το αρχείο <span class=filename>refuse</span>.</p></div><div class=paragraph><p>Το αρχείο <span class=filename>refuse</span> ουσιαστικά λέει στο CVSup ότι δεν πρέπει να πάρει κάθε αρχείο από μια συλλογή. Με άλλα λόγια, λέει στον πελάτη να <em>αρνηθεί</em> συγκεκριμένα αρχεία που προσφέρει ο εξυπηρετητής. Το αρχείο <span class=filename>refuse</span> μπορεί να βρεθεί (ή να δημιουργηθεί αν δεν έχετε ήδη) στο <span class=filename>base/sup/</span>. Το <em>base</em> καθορίζεται στο <span class=filename>supfile</span>. Το δικό μας <em>base</em> είναι στο <span class=filename>/var/db</span>, το οποίο σημαίνει ότι το προεπιλεγμένο αρχείο <span class=filename>refuse</span> θα είναι το <span class=filename>/var/db/sup/refuse</span>.</p></div><div class=paragraph><p>Το αρχείο <span class=filename>refuse</span> έχει ιδιαίτερα απλή μορφή. Απλώς περιέχει τα ονόματα των αρχείων και καταλόγων τα οποία δεν επιθυμείτε να κατεβάσετε. Για παράδειγμα, αν δεν μιλάτε γλώσσες εκτός από Αγγλικά και λίγα Γερμανικά, και δεν αισθάνεστε την ανάγκη να διαβάσετε την Γερμανική μετάφραση της τεκμηρίωσης, μπορείτε να βάλετε τα ακόλουθα στο δικό σας αρχείο <span class=filename>refuse</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>doc/bn_<span class=k>*</span>
doc/da_<span class=k>*</span>
doc/de_<span class=k>*</span>
doc/el_<span class=k>*</span>
doc/es_<span class=k>*</span>
doc/fr_<span class=k>*</span>
doc/it_<span class=k>*</span>
doc/ja_<span class=k>*</span>
doc/nl_<span class=k>*</span>
doc/no_<span class=k>*</span>
doc/pl_<span class=k>*</span>
doc/pt_<span class=k>*</span>
doc/ru_<span class=k>*</span>
doc/sr_<span class=k>*</span>
doc/tr_<span class=k>*</span>
doc/zh_<span class=k>*</span></code></pre></div></div><div class=paragraph><p>κ.ο.κ. για τις υπόλοιπες γλώσσες (μπορείτε να βρείτε την πλήρη λίστα στο <a href=http://www.FreeBSD.org/cgi/cvsweb.cgi/>FreeBSD CVS repository</a>).</p></div><div class=paragraph><p>Με αυτή τη χρήσιμη δυνατότητα, οι χρήστες που έχουν αργή σύνδεση ή πληρώνουν το Internet με χρονοχρέωση ανά λεπτό, θα μπορέσουν να εξοικονομήσουν πολύτιμο χρόνο καθώς δεν θα χρειάζεται πλέον να κατεβάσουν αρχεία που δεν πρόκειται να χρησιμοποιήσουν ποτέ. Για περισσότερες πληροφορίες σχετικά με τα αρχεία <span class=filename>refuse</span> και άλλα χρήσιμα χαρακτηριστικά του CVSup, παρακαλούμε διαβάστε την αντίστοιχη σελίδα του manual.</p></div></div></div><div class=sect2><h3 id=_εκτελώντας_το_cvsup>61.4. Εκτελώντας το CVSup<a class=anchor href=#_εκτελώντας_το_cvsup></a></h3><div class=paragraph><p>Είστε τώρα έτοιμοι να δοκιμάσετε μια ανανέωση. Η γραμμή εντολής για το σκοπό αυτό είναι ιδιαίτερα απλή:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cvsup supfile</span></code></pre></div></div><div class=paragraph><p>όπου το <span class=filename>supfile</span> είναι φυσικά το όνομα του αρχείου <span class=filename>supfile</span> που μόλις δημιουργήσατε. Υποθέτοντας ότι χρησιμοποιείτε τα X11, η εντολή <code>cvsup</code> θα σας εμφανίσει ένα γραφικό παράθυρο με κάποια πλήκτρα συνηθισμένων λειτουργιών. Πιέστε το πλήκτρο btn[go], και παρακολουθήστε την εκτέλεση.</p></div><div class=paragraph><p>Καθώς στην περίπτωση μας ανανεώνεται το πραγματικό δέντρο <span class=filename>/usr/src</span>, θα χρειαστεί να εκτελέσετε το πρόγραμμα ως <code>root</code> ώστε η <code>cvsup</code> να έχει τα δικαιώματα που χρειάζεται για να ανανεώσει τα αρχεία σας. Καθώς μόλις έχετε δημιουργήσει το αρχείο ρυθμίσεων, και δεν έχετε ποτέ πριν χρησιμοποιήσει το πρόγραμμα, ίσως αισθάνεστε λίγο άβολα. Υπάρχει εύκολος τρόπος να κάνετε δοκιμαστική εκτέλεση χωρίς να πειράξετε τα πολύτιμα αρχεία σας. Απλώς δημιουργήστε ένα άδειο κατάλογο σε ένα βολικό μέρος, και δώστε το σαν έξτρα παράμετρο στην γραμμή εντολών:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/dest</span>
<span class=c># cvsup supfile /var/tmp/dest</span></code></pre></div></div><div class=paragraph><p>Ο κατάλογος που καθορίσατε θα χρησιμοποιηθεί ως προορισμός για όλες τις ανανεώσεις αρχείων. Το CVSup θα εξετάσει τα κανονικά αρχεία σας στο <span class=filename>/usr/src</span>, αλλά δεν θα τροποποιήσει ούτε θα διαγράψει κανένα από αυτά. Κάθε ανανέωση αρχείου θα γίνει στον κατάλογο <span class=filename>/var/tmp/dest/usr/src</span>. Το CVSup όταν εκτελείται με αυτό τον τρόπο αφήνει επίσης ανέπαφα τα αρχεία κατάστασης του στον κατάλογο base. Οι νέες εκδόσεις των αρχείων αυτών θα γραφούν στον καθορισμένο κατάλογο. Αν έχετε απλώς πρόσβαση ανάγνωσης στο <span class=filename>/usr/src</span>, δεν χρειάζεστε να είστε καν <code>root</code> για να κάνετε αυτή τη δοκιμαστική εκτέλεση.</p></div><div class=paragraph><p>Αν δεν εκτελείτε τα X11 ή απλώς δεν σας αρέσουν τα γραφικά περιβάλλοντα, μπορείτε να δώσετε κάποιες επιλογές στην γραμμή εντολών όταν εκτελείτε την <code>cvsup</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cvsup -g -L 2 supfile</span></code></pre></div></div><div class=paragraph><p>Η επιλογή <code>-g</code> λέει στο CVSup να μη χρησιμοποιήσει το γραφικό του περιβάλλον. Αυτό γίνεται αυτόματα αν δεν εκτελούνται τα X11, αλλά διαφορετικά θα πρέπει να το καθορίσετε.</p></div><div class=paragraph><p>Η επιλογή <code>-L 2</code> λέει στο CVSup να εμφανίσει όλες τις λεπτομέρειες για όλες τις ανανεώσεις αρχείων που εκτελεί. Υπάρχουν τρία επίπεδα περιγραφής, από το <code>-L 0</code> ως το <code>-L 2</code>. Η προεπιλογή είναι το 0, που σημαίνει απόλυτη σιωπή εκτός από μηνύματα λάθους.</p></div><div class=paragraph><p>Υπάρχουν διαθέσιμες αρκετές ακόμα επιλογές. Για μια περιληπτική λίστα, γράψτε <code>cvsup -H</code>. Για περισσότερο λεπτομερείς περιγραφές, δείτε τη σελίδα του manual.</p></div><div class=paragraph><p>Όταν μείνετε ικανοποιημένος από τον τρόπο που γίνονται οι ανανεώσεις, μπορείτε να κανονίσετε την σε τακτά διαστήματα εκτέλεση του CVSup με την χρήση του <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. Προφανώς δεν θα πρέπει να αφήσετε το CVSup να χρησιμοποιεί το γραφικό του περιβάλλον όταν το εκτελείτε μέσω του <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>.</p></div></div><div class=sect2><h3 id=cvsup-collec>61.5. Συλλογές Αρχείων τουCVSup<a class=anchor href=#cvsup-collec></a></h3><div class=paragraph><p>Οι συλλογές αρχείων που διατίθενται μέσω του CVSup είναι οργανωμένες ιεραρχικά. Υπάρχουν λίγες μεγάλες συλλογές, και αυτές χωρίζονται σε μικρότερες υπο-συλλογές. Η λήψη μιας μεγάλης συλλογής, ισοδυναμεί με την λήψη κάθε μιας από τις υπο-συλλογές τις. Οι ιεραρχικές σχέσεις μεταξύ των συλλογών, αντικατοπτρίζονται παρακάτω με την χρήση των εσοχών.</p></div><div class=paragraph><p>Οι πιο συχνά χρησιμοποιούμενες συλλογές είναι η <code>src-all</code>, και η <code>ports-all</code>. Οι άλλες συλλογές χρησιμοποιούνται μόνο από μικρές ομάδες ανθρώπων για ειδικούς σκοπούς, και κάποια mirror sites μπορεί να μην τις έχουν καθόλου.</p></div><div class=dlist><dl><dt class=hdlist1><code>cvs-all release=cvs</code></dt><dd><p>Το κύριο CVS repository του FreeBSD, που περιλαμβάνει και τον κώδικα κρυπτογραφίας.</p><div class=dlist><dl><dt class=hdlist1><code>distrib release=cvs</code></dt><dd><p>Αρχεία που αναφέρονται στην διανομή και το mirroring του FreeBSD.</p></dd><dt class=hdlist1><code>doc-all release=cvs</code></dt><dd><p>Πηγαίος κώδικας για το FreeBSD Handbook και την υπόλοιπη τεκμηρίωση. Δεν περιλαμβάνει αρχεία για το web site του FreeBSD.</p></dd><dt class=hdlist1><code>ports-all release=cvs</code></dt><dd><p>Η συλλογή Ports του FreeBSD.</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Αν δεν θέλετε να ανανεώσετε όλο το <code>ports-all</code> (το πλήρες δέντρο των ports), αλλά να χρησιμοποιήσετε μια από τις υποσυλλογές που φαίνονται παρακάτω, βεβαιωθείτε ότι <em>πάντα</em> ανανεώνετε την υποσυλλογή <code>ports-base</code>! Όταν κάτι αλλάζει στο σύστημα μεταγλώττισης των ports που αντιπροσωπεύεται από το <code>ports-base</code>, είναι πρακτικά βέβαιο ότι οι αλλαγές αυτές πολύ σύντομα θα χρησιμοποιηθούν από "πραγματικά" ports. Έτσι, αν ανανεώνετε μόνο τα "πραγματικά" ports και αυτά χρησιμοποιούν κάποιες από τις νέες δυνατότητες, υπάρχει μεγάλη πιθανότητα η μεταγλώττιση τους να αποτύχει με κάποιο μυστηριώδες μήνυμα λάθους. Το <em>πρώτο</em> πράγμα που πρέπει να κάνετε σε αυτή την περίπτωση είναι να βεβαιωθείτε ότι είναι ενημερωμένη η συλλογή σας <code>ports-base</code>.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Αν σκοπεύετε να δημιουργήσετε το δικό σας τοπικό αντίγραφο του <span class=filename>ports/INDEX</span>, θα <em>πρέπει</em> να δεχτείτε τη συλλογή <code>ports-all</code> (ολόκληρο το δέντρο των ports). H δημιουργία του <span class=filename>ports/INDEX</span> από μη-πλήρες δέντρο δεν υποστηρίζεται. Δείτε το <a href=https://docs.freebsd.org/el/books/faq/#MAKE-INDEX>FAQ</a>.</p></div></td></tr></tbody></table></div><div class=dlist><dl><dt class=hdlist1><code>ports-accessibility release=cvs</code></dt><dd><p>Λογισμικό για την βοήθεια χρηστών με αναπηρίες.</p></dd><dt class=hdlist1><code>ports-arabic release=cvs</code></dt><dd><p>Υποστήριξη Αραβικής Γλώσσας.</p></dd><dt class=hdlist1><code>ports-archivers release=cvs</code></dt><dd><p>Εργαλεία αποθήκευσης και συμπίεσης.</p></dd><dt class=hdlist1><code>ports-astro release=cvs</code></dt><dd><p>Ports σχετικά με αστρονομία.</p></dd><dt class=hdlist1><code>ports-audio release=cvs</code></dt><dd><p>Υποστήριξη ήχου.</p></dd><dt class=hdlist1><code>ports-base release=cvs</code></dt><dd><p>Βασικά αρχεία των ports για υποστήριξη του συστήματος μεταγλώττισης. Διάφορα αρχεία που βρίσκονται στους υποκαταλόγους <span class=filename>Mk/</span> και <span class=filename>Tools/</span> του <span class=filename>/usr/ports</span>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Παρακαλούμε δείτε την <a href=#cvsup-collec-pbase-warn>σημαντική προειδοποίηση παραπάνω</a>: θα πρέπει <em>πάντοτε</em> να ενημερώνετε αυτή την υποσυλλογή, όταν ενημερώνετε οποιοδήποτε τμήμα της συλλογής Ports του FreeBSD.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><code>ports-benchmarks release=cvs</code></dt><dd><p>Προγράμματα μέτρησης απόδοσης (Benchmarks).</p></dd><dt class=hdlist1><code>ports-biology release=cvs</code></dt><dd><p>Βιολογία.</p></dd><dt class=hdlist1><code>ports-cad release=cvs</code></dt><dd><p>Εργαλεία σχεδίασης με τη βοήθεια υπολογιστή.</p></dd><dt class=hdlist1><code>ports-chinese release=cvs</code></dt><dd><p>Υποστήριξη Κινεζικής Γλώσσας.</p></dd><dt class=hdlist1><code>ports-comms release=cvs</code></dt><dd><p>Λογισμικό επικοινωνιών.</p></dd><dt class=hdlist1><code>ports-converters release=cvs</code></dt><dd><p>Μετατροπείς χαρακτήρων.</p></dd><dt class=hdlist1><code>ports-databases release=cvs</code></dt><dd><p>Βάσεις Δεδομένων.</p></dd><dt class=hdlist1><code>ports-deskutils release=cvs</code></dt><dd><p>Αντικείμενα που βρίσκονταν συνήθως σε ένα γραφείο πριν την εφεύρεση των υπολογιστών.</p></dd><dt class=hdlist1><code>ports-devel release=cvs</code></dt><dd><p>Βοηθητικά προγράμματα για την ανάπτυξη λογισμικού.</p></dd><dt class=hdlist1><code>ports-dns release=cvs</code></dt><dd><p>Λογισμικό σχετικό με DNS.</p></dd><dt class=hdlist1><code>ports-editors release=cvs</code></dt><dd><p>Συντάκτες κειμένου.</p></dd><dt class=hdlist1><code>ports-emulators release=cvs</code></dt><dd><p>Εξομοιωτές άλλων λειτουργικών συστημάτων.</p></dd><dt class=hdlist1><code>ports-finance release=cvs</code></dt><dd><p>Χρηματοοικονομικά προγράμματα.</p></dd><dt class=hdlist1><code>ports-ftp release=cvs</code></dt><dd><p>Προγράμματα FTP (πελάτες και εξυπηρετητές).</p></dd><dt class=hdlist1><code>ports-games release=cvs</code></dt><dd><p>Παιχνίδια.</p></dd><dt class=hdlist1><code>ports-german release=cvs</code></dt><dd><p>Υποστήριξη Γερμανικής γλώσσας.</p></dd><dt class=hdlist1><code>ports-graphics release=cvs</code></dt><dd><p>Εργαλεία γραφικών.</p></dd><dt class=hdlist1><code>ports-hebrew release=cvs</code></dt><dd><p>Υποστήριξη εβραϊκής γλώσσας.</p></dd><dt class=hdlist1><code>ports-hungarian release=cvs</code></dt><dd><p>Υποστήριξη Ουγγαρέζικης γλώσσας.</p></dd><dt class=hdlist1><code>ports-irc release=cvs</code></dt><dd><p>Προγράμματα για το IRC.</p></dd><dt class=hdlist1><code>ports-japanese release=cvs</code></dt><dd><p>Υποστήριξη Ιαπωνικής γλώσσας.</p></dd><dt class=hdlist1><code>ports-java release=cvs</code></dt><dd><p>Εργαλεία για την Java™.</p></dd><dt class=hdlist1><code>ports-korean release=cvs</code></dt><dd><p>Υποστήριξη Κορεατικής γλώσσας.</p></dd><dt class=hdlist1><code>ports-lang release=cvs</code></dt><dd><p>Γλώσσες προγραμματισμού.</p></dd><dt class=hdlist1><code>ports-mail release=cvs</code></dt><dd><p>Προγράμματα ηλεκτρονικού ταχυδρομείου.</p></dd><dt class=hdlist1><code>ports-math release=cvs</code></dt><dd><p>Λογισμικό μαθηματικών υπολογισμών.</p></dd><dt class=hdlist1><code>ports-misc release=cvs</code></dt><dd><p>Διάφορα βοηθητικά προγράμματα.</p></dd><dt class=hdlist1><code>ports-multimedia release=cvs</code></dt><dd><p>Λογισμικό πολυμέσων.</p></dd><dt class=hdlist1><code>ports-net release=cvs</code></dt><dd><p>Λογισμικό δικτύων.</p></dd><dt class=hdlist1><code>ports-net-im release=cvs</code></dt><dd><p>Λογισμικό άμεσων μηνυμάτων (instant messaging).</p></dd><dt class=hdlist1><code>ports-net-mgmt release=cvs</code></dt><dd><p>Λογισμικό διαχείρισης δικτύων.</p></dd><dt class=hdlist1><code>ports-net-p2p release=cvs</code></dt><dd><p>Δικτύωση peer-to-peer.</p></dd><dt class=hdlist1><code>ports-news release=cvs</code></dt><dd><p>Λογισμικό για το USENET.</p></dd><dt class=hdlist1><code>ports-palm release=cvs</code></dt><dd><p>Λογισμικό για την υποστήριξη συσκευών τύπου Palm™.</p></dd><dt class=hdlist1><code>ports-polish release=cvs</code></dt><dd><p>Υποστήριξη Πολωνικής γλώσσας.</p></dd><dt class=hdlist1><code>ports-ports-mgmt release=cvs</code></dt><dd><p>Εργαλεία για τη διαχείριση πακέτων και ports.</p></dd><dt class=hdlist1><code>ports-portuguese release=cvs</code></dt><dd><p>Υποστήριξη Πορτογαλικής γλώσσας.</p></dd><dt class=hdlist1><code>ports-print release=cvs</code></dt><dd><p>Λογισμικό εκτυπώσεων.</p></dd><dt class=hdlist1><code>ports-russian release=cvs</code></dt><dd><p>Υποστήριξη Ρωσικής γλώσσας.</p></dd><dt class=hdlist1><code>ports-science release=cvs</code></dt><dd><p>Επιστημονικά προγράμματα.</p></dd><dt class=hdlist1><code>ports-security release=cvs</code></dt><dd><p>Εργαλεία ασφαλείας.</p></dd><dt class=hdlist1><code>ports-shells release=cvs</code></dt><dd><p>Shells για την γραμμή εντολών.</p></dd><dt class=hdlist1><code>ports-sysutils release=cvs</code></dt><dd><p>Βοηθητικά προγράμματα συστήματος.</p></dd><dt class=hdlist1><code>ports-textproc release=cvs</code></dt><dd><p>Εργαλεία επεξεργασίας κειμένου (δεν περιλαμβάνει επιτραπέζια τυπογραφία).</p></dd><dt class=hdlist1><code>ports-ukrainian release=cvs</code></dt><dd><p>Υποστήριξη Ουκρανικής γλώσσας.</p></dd><dt class=hdlist1><code>ports-vietnamese release=cvs</code></dt><dd><p>Υποστήριξη Βιετναμέζικης γλώσσας.</p></dd><dt class=hdlist1><code>ports-www release=cvs</code></dt><dd><p>Λογισμικό που σχετίζεται με τον παγκόσμιο ιστό (World Wide Web).</p></dd><dt class=hdlist1><code>ports-x11 release=cvs</code></dt><dd><p>Ports για υποστήριξη του συστήματος X Windows.</p></dd><dt class=hdlist1><code>ports-x11-clocks release=cvs</code></dt><dd><p>Ρολόγια για το X11.</p></dd><dt class=hdlist1><code>ports-x11-drivers release=cvs</code></dt><dd><p>Προγράμματα οδήγησης για τα X11.</p></dd><dt class=hdlist1><code>ports-x11-fm release=cvs</code></dt><dd><p>Διαχειριστές αρχείων για τα X11.</p></dd><dt class=hdlist1><code>ports-x11-fonts release=cvs</code></dt><dd><p>Γραμματοσειρές και εργαλεία γραμματοσειρών για X11.</p></dd><dt class=hdlist1><code>ports-x11-toolkits release=cvs</code></dt><dd><p>Εργαλειοθήκες X11.</p></dd><dt class=hdlist1><code>ports-x11-servers release=cvs</code></dt><dd><p>Εξυπηρετητές X11.</p></dd><dt class=hdlist1><code>ports-x11-themes release=cvs</code></dt><dd><p>Θέματα για X11.</p></dd><dt class=hdlist1><code>ports-x11-wm release=cvs</code></dt><dd><p>Διαχειριστές παραθύρων (window managers) για X11.</p></dd></dl></div></dd><dt class=hdlist1><code>projects-all release=cvs</code></dt><dd><p>Πηγαίος κώδικας για το projects repository του FreeBSD.</p></dd><dt class=hdlist1><code>src-all release=cvs</code></dt><dd><p>Ο βασικός πηγαίος κώδικα του FreeBSD, συμπεριλαμβανομένου του κώδικα κρυπτογραφίας.</p><div class=dlist><dl><dt class=hdlist1><code>src-base release=cvs</code></dt><dd><p>Διάφορα αρχεία στην κορυφή του <span class=filename>/usr/src</span>.</p></dd><dt class=hdlist1><code>src-bin release=cvs</code></dt><dd><p>Εργαλεία που πιθανόν να απαιτούνται σε κατάσταση λειτουργίας ενός χρήστη (single-user) (<span class=filename>/usr/src/bin</span>).</p></dd><dt class=hdlist1><code>src-cddl release=cvs</code></dt><dd><p>Εργαλεία και βιβλιοθήκες που καλύπτονται από την άδεια χρήσης CDDL (<span class=filename>/usr/src/cddl</span>).</p></dd><dt class=hdlist1><code>src-contrib release=cvs</code></dt><dd><p>Εργαλεία και βιβλιοθήκες που δεν ανήκουν στο FreeBSD Project, και τα οποία χρησιμοποιούνται ουσιαστικά αναλλοίωτα (<span class=filename>/usr/src/contrib</span>).</p></dd><dt class=hdlist1><code>src-crypto release=cvs</code></dt><dd><p>Εργαλεία και βιβλιοθήκες κρυπτογράφησης που δεν ανήκουν στο FreeBSD project και τα οποία χρησιμοποιούνται ουσιαστικά αναλλοίωτα (<span class=filename>/usr/src/crypto</span>).</p></dd><dt class=hdlist1><code>src-eBones release=cvs</code></dt><dd><p>Kerberos και DES (<span class=filename>/usr/src/eBones</span>). Δεν χρησιμοποιούνται στις τρέχουσες εκδόσεις του FreeBSD.</p></dd><dt class=hdlist1><code>src-etc release=cvs</code></dt><dd><p>Αρχεία ρυθμίσεων του συστήματος (<span class=filename>/usr/src/etc</span>).</p></dd><dt class=hdlist1><code>src-games release=cvs</code></dt><dd><p>Παιχνίδια (<span class=filename>/usr/src/games</span>).</p></dd><dt class=hdlist1><code>src-gnu release=cvs</code></dt><dd><p>Εργαλεία που καλύπτονται από την άδεια χρήσης GNU Public License (<span class=filename>/usr/src/gnu</span>).</p></dd><dt class=hdlist1><code>src-include release=cvs</code></dt><dd><p>Αρχεία επικεφαλίδων (<span class=filename>/usr/src/include</span>).</p></dd><dt class=hdlist1><code>src-kerberos5 release=cvs</code></dt><dd><p>Πακέτο ασφαλείας Kerberos5 (<span class=filename>/usr/src/kerberos5</span>).</p></dd><dt class=hdlist1><code>src-kerberosIV release=cvs</code></dt><dd><p>Πακέτο ασφαλείας KerberosIV (<span class=filename>/usr/src/kerberosIV</span>).</p></dd><dt class=hdlist1><code>src-lib release=cvs</code></dt><dd><p>Βιβλιοθήκες (<span class=filename>/usr/src/lib</span>).</p></dd><dt class=hdlist1><code>src-libexec release=cvs</code></dt><dd><p>Προγράμματα συστήματος τα οποία φυσιολογικά εκτελούνται από άλλα προγράμματα (<span class=filename>/usr/src/libexec</span>).</p></dd><dt class=hdlist1><code>src-release release=cvs</code></dt><dd><p>Αρχεία που απαιτούνται για την παραγωγή μιας έκδοσης του FreeBSD (<span class=filename>/usr/src/release</span>).</p></dd><dt class=hdlist1><code>src-rescue release=cvs</code></dt><dd><p>Προγράμματα με στατική μεταγλώττιση για χρήση σε έκτακτες περιπτώσεις επαναφοράς του συστήματος. Δείτε το <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a> (<span class=filename>/usr/src/rescue</span>).</p></dd><dt class=hdlist1><code>src-sbin release=cvs</code></dt><dd><p>Εργαλεία συστήματος για λειτουργία σε κατάσταση ενός χρήστη (single user mode) (<span class=filename>/usr/src/sbin</span>).</p></dd><dt class=hdlist1><code>src-secure release=cvs</code></dt><dd><p>Βιβλιοθήκες και εντολές κρυπτογράφησης (<span class=filename>/usr/src/secure</span>).</p></dd><dt class=hdlist1><code>src-share release=cvs</code></dt><dd><p>Αρχεία τα οποία μπορεί να είναι κοινά ανάμεσα σε πολλαπλά συστήματα (<span class=filename>/usr/src/share</span>).</p></dd><dt class=hdlist1><code>src-sys release=cvs</code></dt><dd><p>Ο πυρήνας (<span class=filename>/usr/src/sys</span>).</p></dd><dt class=hdlist1><code>src-sys-crypto release=cvs</code></dt><dd><p>Κώδικας κρυπτογραφίας του πυρήνα (<span class=filename>/usr/src/sys/crypto</span>).</p></dd><dt class=hdlist1><code>src-tools release=cvs</code></dt><dd><p>Διάφορα εργαλεία για τη συντήρηση του FreeBSD (<span class=filename>/usr/src/tools</span>).</p></dd><dt class=hdlist1><code>src-usrbin release=cvs</code></dt><dd><p>Εργαλεία χρήστη (<span class=filename>/usr/src/usr.bin</span>).</p></dd><dt class=hdlist1><code>src-usrsbin release=cvs</code></dt><dd><p>Εργαλεία συστήματος (<span class=filename>/usr/src/usr.sbin</span>).</p></dd></dl></div></dd><dt class=hdlist1><code>www release=cvs</code></dt><dd><p>Ο πηγαίος κώδικας για την τοποθεσία WWW του FreeBSD.</p></dd></dl></div></dd><dt class=hdlist1><code>distrib release=self</code></dt><dd><p>Τα αρχεία ρυθμίσεων του ίδιου του εξυπηρετητή CVSup. Χρησιμοποιείται από CVSup mirror sites.</p></dd><dt class=hdlist1><code>gnats release=current</code></dt><dd><p>H βάση δεδομένων του συστήματος παρακολούθησης προβλημάτων GNATS.</p></dd><dt class=hdlist1><code>mail-archive release=current</code></dt><dd><p>Τα αρχεία της λίστας ταχυδρομείου του FreeBSD.</p></dd><dt class=hdlist1><code>www release=current</code></dt><dd><p>Προ-επεξεργασμένα αρχεία της δικτυακής τοποθεσίας (WWW) του FreeBSD (όχι ο πηγαίος κώδικας). Χρησιμοποιείται από WWW mirror sites.</p></dd></dl></div></div><div class=sect2><h3 id=_για_περισσότερες_πληροφορίες>61.6. Για Περισσότερες Πληροφορίες<a class=anchor href=#_για_περισσότερες_πληροφορίες></a></h3><div class=paragraph><p>Για το FAQ του CVSup και άλλες πληροφορίες σχετικά με αυτό, δείτε τη <a href=http://www.cvsup.org>Σελίδα του CVSup</a>.</p></div><div class=paragraph><p>Συζητήσεις σχετικά με τη χρήση του CVSup στο FreeBSD λαμβάνουν χώρα στην <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>ηλεκτρονική λίστα τεχνικών συζητήσεων του FreeBSD</a>. Στη λίστα αυτή, καθώς και στην <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>ηλεκτρονική λίστα ανακοινώσεων του FreeBSD</a> ανακοινώνονται και οι νέες εκδόσεις του προγράμματος.</p></div><div class=paragraph><p>Για ερωτήσεις ή αναφορές σφαλμάτων σχετικά με το CVSup ρίξτε μια ματιά στο <a href=http://www.cvsup.org/faq.html#bugreports>CVSup FAQ</a>.</p></div></div><div class=sect2><h3 id=cvsup-mirrors>61.7. Τοποθεσίες CVSup<a class=anchor href=#cvsup-mirrors></a></h3><div class=paragraph><p>Μπορείτε να βρείτε εξυπηρετητές <a href=#cvsup>CVSup</a> για το FreeBSD στις ακόλουθες τοποθεσίες:</p></div></div></div></div><div class=sect1><h2 id=cvs-tags>Chapter 62. Ετικέτες (Tags) για το CVS<a class=anchor href=#cvs-tags></a></h2><div class=sectionbody><div class=paragraph><p>Όταν κατεβάζετε ή ανανεώνετε τον πηγαίο κώδικα μέσω της cvs η της CVSup, θα πρέπει να καθορίσετε μια ετικέτα έκδοσης (revision tag). Ένα revision tag αναφέρεται είτε σε μια συγκεκριμένη πορεία ανάπτυξης του FreeBSD, είτε σε ένα συγκεκριμένο χρονικό σημείο. Ο πρώτος τύπος ονομάζεται "ετικέτα κλάδου (branch tag)", και ο δεύτερος ονομάζεται "ετικέτα έκδοσης (release tag)".</p></div><div class=sect2><h3 id=_ετικέτες_κλάδων_branch_tags>62.1. Ετικέτες Κλάδων (Branch Tags)<a class=anchor href=#_ετικέτες_κλάδων_branch_tags></a></h3><div class=paragraph><p>Όλες αυτές, με την εξαίρεση του <code>HEAD</code> (το οποίο είναι πάντα έγκυρη ετικέτα), ισχύουν μόνο για το δέντρο <span class=filename>src/</span>. Τα δέντρα <span class=filename>ports/</span>, <span class=filename>doc/</span>, και <span class=filename>www/</span> δεν έχουν κλάδους.</p></div><div class=dlist><dl><dt class=hdlist1>HEAD</dt><dd><p>Πρόκειται για το συμβολικό όνομα της κύριας γραμμής ανάπτυξης, ή FreeBSD-CURRENT. Είναι επίσης το προεπιλεγμένο tag αν δεν καθοριστεί κάποιο συγκεκριμένο revision.</p><div class=paragraph><p>Στο CVSup, το tag αυτό αντιπροσωπεύεται από μια <code>.</code> (δεν πρόκειται για σημείο στίξης της πρότασης, αλλά για τον πραγματικό χαρακτήρα <code>.</code>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Στο CVS, αυτή είναι και η προεπιλογή αν δεν καθοριστεί revision tag. Συνήθως <em>δεν</em> είναι καλή ιδέα να κάνετε checkout και ανανέωση στον πηγαίο κώδικα του CURRENT σε ένα μηχάνημα STABLE, εκτός αν αυτή είναι πραγματικά η πρόθεση σας.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>RELENG_9</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-9.X, γνωστή επίσης και ως FreeBSD 9-STABLE</p></dd><dt class=hdlist1>RELENG_9_0</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-9.0, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_8</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-8.X, γνωστή επίσης και ως FreeBSD 8-STABLE</p></dd><dt class=hdlist1>RELENG_8_3</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-8.3, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_8_2</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-8.2, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_8_1</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-8.1, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_8_0</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-8.0, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_7</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-7.X, γνωστή επίσης και ως FreeBSD 7-STABLE</p></dd><dt class=hdlist1>RELENG_7_4</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-7.4, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_7_3</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-7.3, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_7_2</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-7.2, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_7_1</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-7.1, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_7_0</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-7.0, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_6</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-6.X, γνωστή επίσης και ως FreeBSD 6-STABLE</p></dd><dt class=hdlist1>RELENG_6_4</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-6.4, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_6_3</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-6.3, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_6_2</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-6.2, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_6_1</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-6.1, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_6_0</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-6.0, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_5</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-5.X, γνωστή επίσης ως FreeBSD 5-STABLE.</p></dd><dt class=hdlist1>RELENG_5_5</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-5.5, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_5_4</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-5.4, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_5_3</dt><dd><p>Η γραμμή έκδοσης του FreeBSD-5.3, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_5_2</dt><dd><p>Η γραμμή έκδοσης FreeBSD-5.2 και FreeBSD-5.2.1, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_5_1</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-5.1, χρησιμοποιείται μόνο για για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_5_0</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-5.0, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-4.X, γνωστή επίσης και ως FreeBSD 4-STABLE.</p></dd><dt class=hdlist1>RELENG_4_11</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.11, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_10</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.10, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_9</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.9, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_8</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.8, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_7</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.7, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_6</dt><dd><p>Η γραμμή έκδοσης για τα FreeBSD-4.6 και FreeBSD-4.6.2, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_5</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.5, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_4</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.4, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_4_3</dt><dd><p>Η γραμμή έκδοσης για το FreeBSD-4.3, χρησιμοποιείται μόνο για ενημερώσεις ασφαλείας και άλλες κρίσιμες διορθώσεις.</p></dd><dt class=hdlist1>RELENG_3</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-3.X, γνωστή επίσης και ως 3.X-STABLE.</p></dd><dt class=hdlist1>RELENG_2_2</dt><dd><p>Η γραμμή ανάπτυξης για το FreeBSD-2.2.X, γνωστή επίσης και ως 2.2-STABLE. Η γραμμή αυτή θεωρείται ουσιαστικά παρωχημένη.</p></dd></dl></div></div><div class=sect2><h3 id=_ετικέτες_εκδόσεων_release_tags>62.2. Ετικέτες Εκδόσεων (Release Tags)<a class=anchor href=#_ετικέτες_εκδόσεων_release_tags></a></h3><div class=paragraph><p>Οι ετικέτες αυτές αναφέρονται σε μια συγκεκριμένη χρονική στιγμή κατά την οποία έγινε μια κανονική έκδοση (release) του FreeBSD. Η διαδικασία της έκδοσης τεκμηριώνεται με περισσότερες λεπτομέρειες στα έγγραφα <a href=https://www.FreeBSD.org/releng/>Πληροφορίες Διαδικασίας Έκδοσης</a> και <a href=https://docs.freebsd.org/el/articles/releng/#release-proc>Διαδικασία Έκδοσης</a>. Το δέντρο <span class=filename>src</span> χρησιμοποιεί ονόματα ετικετών που ξεκινούν με τη λέξη <code>RELENG_</code>. Τα δέντρα <span class=filename>ports</span> και <span class=filename>doc</span> χρησιμοποιούν ετικέτες που ξεκινούν με τη λέξη <code>RELEASE</code>. Τέλος, στο δέντρο <span class=filename>www</span> δεν δίνεται κάποια ειδική ετικέτα που να έχει σχέση με τις εκδόσεις.</p></div><div class=dlist><dl><dt class=hdlist1>RELENG_9_0_0_RELEASE</dt><dd><p>FreeBSD 9.0</p></dd><dt class=hdlist1>RELENG_8_3_0_RELEASE</dt><dd><p>FreeBSD 8.3</p></dd><dt class=hdlist1>RELENG_8_2_0_RELEASE</dt><dd><p>FreeBSD 8.2</p></dd><dt class=hdlist1>RELENG_8_1_0_RELEASE</dt><dd><p>FreeBSD 8.1</p></dd><dt class=hdlist1>RELENG_8_0_0_RELEASE</dt><dd><p>FreeBSD 8.0</p></dd><dt class=hdlist1>RELENG_7_4_0_RELEASE</dt><dd><p>FreeBSD 7.4</p></dd><dt class=hdlist1>RELENG_7_3_0_RELEASE</dt><dd><p>FreeBSD 7.3</p></dd><dt class=hdlist1>RELENG_7_2_0_RELEASE</dt><dd><p>FreeBSD 7.2</p></dd><dt class=hdlist1>RELENG_7_1_0_RELEASE</dt><dd><p>FreeBSD 7.1</p></dd><dt class=hdlist1>RELENG_7_0_0_RELEASE</dt><dd><p>FreeBSD 7.0</p></dd><dt class=hdlist1>RELENG_6_4_0_RELEASE</dt><dd><p>FreeBSD 6.4</p></dd><dt class=hdlist1>RELENG_6_3_0_RELEASE</dt><dd><p>FreeBSD 6.3</p></dd><dt class=hdlist1>RELENG_6_2_0_RELEASE</dt><dd><p>FreeBSD 6.2</p></dd><dt class=hdlist1>RELENG_6_1_0_RELEASE</dt><dd><p>FreeBSD 6.1</p></dd><dt class=hdlist1>RELENG_6_0_0_RELEASE</dt><dd><p>FreeBSD 6.0</p></dd><dt class=hdlist1>RELENG_5_5_0_RELEASE</dt><dd><p>FreeBSD 5.5</p></dd><dt class=hdlist1>RELENG_5_4_0_RELEASE</dt><dd><p>FreeBSD 5.4</p></dd><dt class=hdlist1>RELENG_4_11_0_RELEASE</dt><dd><p>FreeBSD 4.11</p></dd><dt class=hdlist1>RELENG_5_3_0_RELEASE</dt><dd><p>FreeBSD 5.3</p></dd><dt class=hdlist1>RELENG_4_10_0_RELEASE</dt><dd><p>FreeBSD 4.10</p></dd><dt class=hdlist1>RELENG_5_2_1_RELEASE</dt><dd><p>FreeBSD 5.2.1</p></dd><dt class=hdlist1>RELENG_5_2_0_RELEASE</dt><dd><p>FreeBSD 5.2</p></dd><dt class=hdlist1>RELENG_4_9_0_RELEASE</dt><dd><p>FreeBSD 4.9</p></dd><dt class=hdlist1>RELENG_5_1_0_RELEASE</dt><dd><p>FreeBSD 5.1</p></dd><dt class=hdlist1>RELENG_4_8_0_RELEASE</dt><dd><p>FreeBSD 4.8</p></dd><dt class=hdlist1>RELENG_5_0_0_RELEASE</dt><dd><p>FreeBSD 5.0</p></dd><dt class=hdlist1>RELENG_4_7_0_RELEASE</dt><dd><p>FreeBSD 4.7</p></dd><dt class=hdlist1>RELENG_4_6_2_RELEASE</dt><dd><p>FreeBSD 4.6.2</p></dd><dt class=hdlist1>RELENG_4_6_1_RELEASE</dt><dd><p>FreeBSD 4.6.1</p></dd><dt class=hdlist1>RELENG_4_6_0_RELEASE</dt><dd><p>FreeBSD 4.6</p></dd><dt class=hdlist1>RELENG_4_5_0_RELEASE</dt><dd><p>FreeBSD 4.5</p></dd><dt class=hdlist1>RELENG_4_4_0_RELEASE</dt><dd><p>FreeBSD 4.4</p></dd><dt class=hdlist1>RELENG_4_3_0_RELEASE</dt><dd><p>FreeBSD 4.3</p></dd><dt class=hdlist1>RELENG_4_2_0_RELEASE</dt><dd><p>FreeBSD 4.2</p></dd><dt class=hdlist1>RELENG_4_1_1_RELEASE</dt><dd><p>FreeBSD 4.1.1</p></dd><dt class=hdlist1>RELENG_4_1_0_RELEASE</dt><dd><p>FreeBSD 4.1</p></dd><dt class=hdlist1>RELENG_4_0_0_RELEASE</dt><dd><p>FreeBSD 4.0</p></dd><dt class=hdlist1>RELENG_3_5_0_RELEASE</dt><dd><p>FreeBSD-3.5</p></dd><dt class=hdlist1>RELENG_3_4_0_RELEASE</dt><dd><p>FreeBSD-3.4</p></dd><dt class=hdlist1>RELENG_3_3_0_RELEASE</dt><dd><p>FreeBSD-3.3</p></dd><dt class=hdlist1>RELENG_3_2_0_RELEASE</dt><dd><p>FreeBSD-3.2</p></dd><dt class=hdlist1>RELENG_3_1_0_RELEASE</dt><dd><p>FreeBSD-3.1</p></dd><dt class=hdlist1>RELENG_3_0_0_RELEASE</dt><dd><p>FreeBSD-3.0</p></dd><dt class=hdlist1>RELENG_2_2_8_RELEASE</dt><dd><p>FreeBSD-2.2.8</p></dd><dt class=hdlist1>RELENG_2_2_7_RELEASE</dt><dd><p>FreeBSD-2.2.7</p></dd><dt class=hdlist1>RELENG_2_2_6_RELEASE</dt><dd><p>FreeBSD-2.2.6</p></dd><dt class=hdlist1>RELENG_2_2_5_RELEASE</dt><dd><p>FreeBSD-2.2.5</p></dd><dt class=hdlist1>RELENG_2_2_2_RELEASE</dt><dd><p>FreeBSD-2.2.2</p></dd><dt class=hdlist1>RELENG_2_2_1_RELEASE</dt><dd><p>FreeBSD-2.2.1</p></dd><dt class=hdlist1>RELENG_2_2_0_RELEASE</dt><dd><p>FreeBSD-2.2.0</p></dd></dl></div></div></div></div><div class=sect1><h2 id=mirrors-afs>Chapter 63. Τοποθεσίες AFS<a class=anchor href=#mirrors-afs></a></h2><div class=sectionbody><div class=paragraph><p>Εξυπηρετητές AFS για το FreeBSD θα βρείτε στις ακόλουθες τοποθεσίες:</p></div><div class=dlist><dl><dt class=hdlist1>Σουηδία</dt><dd><p>Η διαδρομή για τα αρχεία είναι: <span class=filename>/afs/stacken.kth.se/ftp/pub/FreeBSD/</span></p><div class="literalblock programlisting"><div class=content><pre>stacken.kth.se         # Stacken Computer Club, KTH, Sweden
130.237.234.43         #hot.stacken.kth.se
130.237.237.230        #fishburger.stacken.kth.se
130.237.234.3          #milko.stacken.kth.se</pre></div></div><div class=paragraph><p>Υπεύθυνος Συντήρησης: <a href=mailto:ftp@stacken.kth.se>ftp@stacken.kth.se</a></p></div></dd></dl></div></div></div><div class=sect1><h2 id=mirrors-rsync>Chapter 64. Τοποθεσίες rsync<a class=anchor href=#mirrors-rsync></a></h2><div class=sectionbody><div class=paragraph><p>Το FreeBSD είναι διαθέσιμο μέσω του πρωτοκόλλου rsync στις ακόλουθες τοποθεσίες. Το βοηθητικό πρόγραμμα rsync λειτουργεί με περίπου τον ίδιο τρόπο με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, αλλά έχει περισσότερες επιλογές και χρησιμοποιεί το πρωτόκολλο απομακρυσμένης ανανέωσης το οποίο μεταφέρει μόνο τις διαφορές μεταξύ δύο σετ αρχείων, επιταχύνοντας έτσι ιδιαίτερα το συγχρονισμό μέσω του δικτύου. Αυτό είναι περισσότερο χρήσιμο αν διατηρείτε mirror του διακομιστή FTP ή του CVS Repository του FreeBSD. Η συλλογή εφαρμογών rsync διατίθεται για πολλά λειτουργικά συστήματα, στο FreeBSD δείτε το port <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> ή χρησιμοποιήστε το αντίστοιχο πακέτο.</p></div><div class=dlist><dl><dt class=hdlist1>Δημοκρατία της Τσεχίας</dt><dd><p>rsync://ftp.cz.FreeBSD.org/</p><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div><div class=ulist><ul><li><p>ftp: Μερικό mirror του διακομιστή FTP του FreeBSD.</p></li><li><p>FreeBSD: Πλήρες mirror του διακομιστή FTP του FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Ολλανδία</dt><dd><p>rsync://ftp.nl.FreeBSD.org/</p><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div><div class=ulist><ul><li><p>FreeBSD: Πλήρες mirror του διακομιστή FTP του FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Ρωσία</dt><dd><p>rsync://ftp.mtu.ru/</p><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div><div class=ulist><ul><li><p>FreeBSD: Πλήρες mirror του διακομιστή FTP του FreeBSD.</p></li><li><p>FreeBSD-gnats: Η βάση δεδομένων του συστήματος παρακολούθησης σφαλμάτων GNATS.</p></li><li><p>FreeBSD-Archive: Mirror του διακομιστή FTP παλαιότερων εκδόσεων (archive) του FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Σουηδία</dt><dd><p>rsync://ftp4.se.freebsd.org/</p><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div><div class=ulist><ul><li><p>FreeBSD: Πλήρες mirror του διακομιστή FTP του FreeBSD</p></li></ul></div></dd><dt class=hdlist1>Ταΐβάν</dt><dd><p>rsync://ftp.tw.FreeBSD.org/</p><div class=paragraph><p>rsync://ftp2.tw.FreeBSD.org/</p></div><div class=paragraph><p>rsync://ftp6.tw.FreeBSD.org/</p></div><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div><div class=ulist><ul><li><p>FreeBSD: Πλήρες mirror του διακομιστή FTP του FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Ηνωμένο Βασίλειο</dt><dd><p>rsync://rsync.mirrorservice.org/</p><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div><div class=ulist><ul><li><p>sites/ftp.freebsd.org: Πλήρες mirror του διακομιστή FTP του FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Ηνωμένες Πολιτείες Αμερικής</dt><dd><p>rsync://ftp-master.FreeBSD.org/</p><div class=paragraph><p>Ο διακομιστής αυτός μπορεί να χρησιμοποιηθεί μόνο από κύρια mirror sites του FreeBSD.</p></div><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div><div class=ulist><ul><li><p>FreeBSD: To κύριο (master) σύστημα αρχείων του διακομιστή FTP του FreeBSD.</p></li><li><p>acl: Η κύρια λίστα ACL του FreeBSD.</p><div class=paragraph><p>rsync://ftp13.FreeBSD.org/</p></div><div class=paragraph><p>Διαθέσιμες Συλλογές:</p></div></li><li><p>FreeBSD: Πλήρες mirror του διακομιστή FTP του FreeBSD.</p></li></ul></div></dd></dl></div></div></div><div class=sect1><h2 id=bibliography>Appendix B: Βιβλιογραφία<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>Αν και τα manual pages παρέχουν μία επίσημη αναφορά για τα διάφορα τμήματα του λειτουργικού συστήματος FreeBSD, δεν εξηγούν πως όλα αυτά ενώνονται μεταξύ τους ώστε το λειτουργικό σύστημα να λειτουργεί ομαλά. Για αυτές τις πληροφορίες, θα πρέπει να συμβουλευτείτε ένα καλό βιβλίο διαχείρισης συστημάτων UNIX® και ένα καλό εγχειρίδιο χρήστη.</p></div><div class=sect2><h3 id=bibliography-freebsd>B.1. Βιβλία & Περιοδικά σχετικά με το FreeBSD<a class=anchor href=#bibliography-freebsd></a></h3><div class=paragraph><p><em>Διεθνή βιβλία & περιοδικά:</em></p></div><div class=ulist><ul><li><p><a href=http://jdli.tw.FreeBSD.org/publication/book/freebsd2/index.htm>Using FreeBSD</a> (σε Παραδοσιακά Κινέζικα).</p></li><li><p>FreeBSD Unleashed (Μετάφραση σε Απλοποιημένα Κινέζικα), εκδόθηκε από την <a href=http://www.hzbook.com/>China Machine Press</a>. ISBN 7-111-10201-0.</p></li><li><p>FreeBSD From Scratch Second Edition (σε Απλοποιημένα Κινέζικα), εκδόθηκε από την China Machine Press. ISBN 7-111-10286-X.</p></li><li><p>FreeBSD Handbook Second Edition (Μετάφραση σε Απλοποιημένα Κινέζικα), εκδόθηκε από την <a href=http://www.ptpress.com.cn/>Posts & Telecom Press</a>. ISBN 7-115-10541-3.</p></li><li><p>FreeBSD & Windows (σε Απλοποιημένα Κινέζικα), εκδόθηκε από την <a href=http://www.tdpress.com/>China Railway Publishing House</a>. ISBN 7-113-03845-X</p></li><li><p>FreeBSD Internet Services HOWTO (σε Απλοποιημένα Κινέζικα), εκδόθηκε από την China Railway Publishing House. ISBN 7-113-03423-3</p></li><li><p>FreeBSD (στα Γιαπωνέζικα), εκδόθηκε από την CUTT. ISBN 4-906391-22-2 C3055 P2400E.</p></li><li><p><a href="http://www.shoeisha.com/book/Detail.asp?bid=650">Complete Introduction to FreeBSD</a> (στα Γιαπωνέζικα), εκδόθηκε από την <a href=http://www.shoeisha.co.jp/>Shoeisha Co., Ltd</a>. ISBN 4-88135-473-6 P3600E.</p></li><li><p><a href=http://www.ascii.co.jp/pb/book1/shinkan/detail/1322785.html>Personal UNIX Starter Kit FreeBSD</a> (στα Γιαπωνέζικα), εκδόθηκε από την <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1733-3 P3000E.</p></li><li><p>FreeBSD Handbook (Γιαπωνέζικη μετάφραση), εκδόθηκε από την <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1580-2 P3800E.</p></li><li><p>FreeBSD mit Methode (στα Γερμανικά), εκδόθηκε από την <a href=http://www.cul.de>Computer und Literatur Verlag</a>/Vertrieb Hanser, 1998. ISBN 3-932311-31-0.</p></li><li><p><a href=http://www.mitp.de/vmi/mitp/detail/pWert/1343/>FreeBSD de Luxe</a> (στα Γερμανικά), εκδόθηκε από την <a href=http://www.mitp.de>Verlag Modere Industrie</a>, 2003. ISBN 3-8266-1343-0.</p></li><li><p><a href=http://www.pc.mycom.co.jp/FreeBSD/install-manual.html>FreeBSD Install and Utilization Manual</a> (στα Γιαπωνέζικα), εκδόθηκε από την <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>.</p></li><li><p>Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo <em><a href=http://maxwell.itb.ac.id/>Building Internet Server with FreeBSD</a></em> (στην Ινδονησιακή γλώσσα), εκδόθηκε από την <a href=http://www.elexmedia.co.id/>Elex Media Komputindo</a>.</p></li><li><p>Absolute BSD: The Ultimate Guide to FreeBSD (Μετάφραση σε Παραδοσιακά Κινέζικα), εκδόθηκε από την <a href=http://www.grandtech.com.tw/>GrandTech Press</a>, 2003. ISBN 986-7944-92-5.</p></li><li><p><a href=http://www.twbsd.org/cht/book/>The FreeBSD 6.0 Book</a> (σε Παραδοσιακά Κινέζικα), εκδόθηκε από την Drmaster, 2006. ISBN 9-575-27878-X.</p></li></ul></div><div class=paragraph><p><em>Βιβλία & περιοδικά στην Αγγλική γλώσσα:</em></p></div><div class=ulist><ul><li><p><a href=http://www.absoluteFreeBSD.com/>Absolute FreeBSD, 2nd Edition: The Complete Guide to FreeBSD</a>, εκδόθηκε από την <a href=http://www.nostarch.com/>No Starch Press</a>, 2007. ISBN: 978-1-59327-151-0</p></li><li><p><a href=http://www.freebsdmall.com/cgi-bin/fm/bsdcomp>The Complete FreeBSD</a>, εκδόθηκε από την <a href=http://www.oreilly.com/>O’Reilly</a>, 2003. ISBN: 0596005164</p></li><li><p><a href=http://www.freebsd-corp-net-guide.com/>The FreeBSD Corporate Networker’s Guide</a>, εκδόθηκε από την <a href=http://www.awl.com/aw/>Addison-Wesley</a>, 2000. ISBN: 0201704811</p></li><li><p><a href=http://andrsn.stanford.edu/FreeBSD/introbook/>FreeBSD: An Open-Source Operating System for Your Personal Computer</a>, εκδόθηκε από την The Bit Tree Press, 2001. ISBN: 0971204500</p></li><li><p>Teach Yourself FreeBSD in 24 Hours, εκδόθηκε από την <a href=http://www.samspublishing.com/>Sams</a>, 2002. ISBN: 0672324245</p></li><li><p>FreeBSD 6 Unleashed, εκδόθηκε από την <a href=http://www.samspublishing.com/>Sams</a>, 2006. ISBN: 0672328755</p></li><li><p>FreeBSD: The Complete Reference, εκδόθηκε από την <a href=http://books.mcgraw-hill.com>McGrawHill</a>, 2003. ISBN: 0072224096</p></li><li><p><a href=http://www.bsdmag.org>BSD Magazine</a>, εκδίδεται από την Software Press Sp. z o.o. SK. ISSN 1898-9144</p></li></ul></div></div><div class=sect2><h3 id=bibliography-userguides>B.2. Οδηγοί χρήστη<a class=anchor href=#bibliography-userguides></a></h3><div class=ulist><ul><li><p>Το Ohio State University έγραψε τα <a href=http://www.cs.duke.edu/csl/docs/unix_course/>Εισαγωγικά μαθήματα UNIX</a> που διατίθενται σε HTML και PostScript.</p><div class=paragraph><p>Μια Ιταλική <a href=https://www.FreeBSD.org/doc/it_IT.ISO8859-15/books/unix-introduction/index.html>μετάφραση</a> αυτού του κειμένου διατίθεται ως μέρος του FreeBSD Italian Documentation Project.</p></div></li><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/urm.html>FreeBSD User’s Reference Manual</a> (Japanese translation). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0088-4 P3800E.</p></li><li><p>Το <a href=http://www.ed.ac.uk/>Edinburgh University</a> έγραψε ένα <a href=http://unixhelp.ed.ac.uk/>Online οδηγό</a> για νέους στο περιβάλλον του UNIX.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-adminguides>B.3. Οδηγοί διαχειριστή<a class=anchor href=#bibliography-adminguides></a></h3><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/sam.html>FreeBSD System Administrator’s Manual</a> (Γιαπωνέζικη μετάφραση). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0109-0 P3300E.</p></li><li><p>Dreyfus, Emmanuel. <a href=http://www.eyrolles.com/Informatique/Livre/9782212114638/>Cahiers de l’Admin: BSD</a> 2nd Ed. (στα Γαλλικά), Eyrolles, 2004. ISBN 2-212-11463-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-programmers>B.4. Οδηγοί προγραμματιστών<a class=anchor href=#bibliography-programmers></a></h3><div class=ulist><ul><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Reference Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-078-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Supplementary Documents</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-079-1</p></li><li><p>Harbison, Samuel P. and Steele, Guy L. Jr. <em>C: A Reference Manual</em>. 4th ed. Prentice Hall, 1995. ISBN 0-13-326224-3</p></li><li><p>Kernighan, Brian and Dennis M. Ritchie. <em>The C Programming Language</em>. 2nd Ed. PTR Prentice Hall, 1988. ISBN 0-13-110362-8</p></li><li><p>Lehey, Greg. <em>Porting UNIX Software</em>. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-126-7</p></li><li><p>Plauger, P. J. <em>The Standard C Library</em>. Prentice Hall, 1992. ISBN 0-13-131509-9</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codereading/>Code Reading: The Open Source Perspective</a>. Addison-Wesley, 2003. ISBN 0-201-79940-5</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codequality/>Code Quality: The Open Source Perspective</a>. Addison-Wesley, 2006. ISBN 0-321-16607-8</p></li><li><p>Stevens, W. Richard and Stephen A. Rago. <em>Advanced Programming in the UNIX Environment</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN 0-201-43307-9</p></li><li><p>Stevens, W. Richard. <em>UNIX Network Programming</em>. 2nd Ed, PTR Prentice Hall, 1998. ISBN 0-13-490012-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-osinternals>B.5. Το εσωτερικό του λειτουργικού συστήματος<a class=anchor href=#bibliography-osinternals></a></h3><div class=ulist><ul><li><p>Andleigh, Prabhat K. <em>UNIX System Architecture</em>. Prentice-Hall, Inc., 1990. ISBN 0-13-949843-5</p></li><li><p>Jolitz, William. "Porting UNIX to the 386". <em>Dr. Dobb’s Journal</em>. January 1991-July 1992.</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John Quarterman <em>The Design and Implementation of the 4.3BSD UNIX Operating System</em>. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, <em>The Design and Implementation of the 4.3BSD UNIX Operating System: Answer Book</em>. Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9</p></li><li><p>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John Quarterman. <em>The Design and Implementation of the 4.4BSD Operating System</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4</p><div class=paragraph><p>(Το κεφάλαιο 2 από αυτό το βιβλίο διατίθεται <a href=https://docs.freebsd.org/en/books/design-44bsd/>online</a> ως μέρος του FreeBSD Documentation Project.)</p></div></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil <em>The Design and Implementation of the FreeBSD Operating System</em>. Boston, Mass. : Addison-Wesley, 2004. ISBN 0-201-70245-2</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 1: The Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9</p></li><li><p>Schimmel, Curt. <em>Unix Systems for Modern Architectures</em>. Reading, Mass. : Addison-Wesley, 1994. ISBN 0-201-63338-8</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63495-3</p></li><li><p>Vahalia, Uresh. <em>UNIX Internals — The New Frontiers</em>. Prentice Hall, 1996. ISBN 0-13-101908-2</p></li><li><p>Wright, Gary R. and W. Richard Stevens. <em>TCP/IP Illustrated, Volume 2: The Implementation</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-security>B.6. Αναφορές ασφαλείας<a class=anchor href=#bibliography-security></a></h3><div class=ulist><ul><li><p>Cheswick, William R. and Steven M. Bellovin. <em>Firewalls and Internet Security: Repelling the Wily Hacker</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63357-4</p></li><li><p>Garfinkel, Simson. <em>PGP Pretty Good Privacy</em> O’Reilly & Associates, Inc., 1995. ISBN 1-56592-098-8</p></li></ul></div></div><div class=sect2><h3 id=bibliography-hardware>B.7. Αναφορές υλικού<a class=anchor href=#bibliography-hardware></a></h3><div class=ulist><ul><li><p>Anderson, Don and Tom Shanley. <em>Pentium Processor System Architecture</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5</p></li><li><p>Ferraro, Richard F. <em>Programmer’s Guide to the EGA, VGA, and Super VGA Cards</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7</p></li><li><p>Η Intel Corporation δημοσιεύει τεκμηρίωση για τις CPUs, τα chipsets και πρότυπα στο <a href=http://developer.intel.com/>developer web site</a>, συνήθως ως αρχεία PDF.</p></li><li><p>Shanley, Tom. <em>80486 System Architecture</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40994-1</p></li><li><p>Shanley, Tom. <em>ISA System Architecture</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40996-8</p></li><li><p>Shanley, Tom. <em>PCI System Architecture</em>. 4th ed. Reading, Mass. : Addison-Wesley, 1999. ISBN 0-201-30974-2</p></li><li><p>Van Gilluwe, Frank. <em>The Undocumented PC</em>, 2nd Ed. Reading, Mass: Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8</p></li><li><p>Messmer, Hans-Peter. <em>The Indispensable PC Hardware Book</em>, 4th Ed. Reading, Mass: Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4</p></li></ul></div></div><div class=sect2><h3 id=bibliography-history>B.8. Ιστορία του UNIX®<a class=anchor href=#bibliography-history></a></h3><div class=ulist><ul><li><p>Lion, John <em>Lion’s Commentary on UNIX, 6th Ed. With Source Code</em>. ITP Media Group, 1996. ISBN 1573980137</p></li><li><p>Raymond, Eric S. <em>The New Hacker’s Dictionary, 3rd edition</em>. MIT Press, 1996. ISBN 0-262-68092-0. Γνωστό και ως το <a href=http://www.catb.org/~esr/jargon/html/index.html>Jargon File</a></p></li><li><p>Salus, Peter H. <em>A quarter century of UNIX</em>. Addison-Wesley Publishing Company, Inc., 1994. ISBN 0-201-54777-5</p></li><li><p>Simon Garfinkel, Daniel Weise, Steven Strassmann. <em>The UNIX-HATERS Handbook</em>. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. Εκτός κυκλοφορίας, αλλά διατίθεται <a href=http://www.simson.net/ref/ugh.pdf>online</a>.</p></li><li><p>Don Libes, Sandy Ressler <em>Life with UNIX</em> - special edition. Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7</p></li><li><p><em>The BSD family tree</em>. <a href=http://www.FreeBSD.org/cgi/cvsweb.cgi/src/shared/misc/bsd-family-tree>http://www.FreeBSD.org/cgi/cvsweb.cgi/src/shared/misc/bsd-family-tree</a> η το <a href=file://localhost/usr/shared/misc/bsd-family-tree>/usr/shared/misc/bsd-family-tree</a> σε ένα FreeBSD μηχάνημα.</p></li><li><p><em>Networked Computer Science Technical Reports Library</em>. <a href=http://www.ncstrl.org/>http://www.ncstrl.org/</a></p></li><li><p><em>Παλαιές BSD εκδόσεις από το Computer Systems Research group (CSRG)</em>. <a href=http://www.mckusick.com/csrg/>http://www.mckusick.com/csrg/</a>: Το 4CD set έχει όλες τις BSD εκδόσεις από την 1BSD μέχρι την 4.4BSD και την 4.4BSD-Lite2 (αλλά όχι την 2.11BSD, δυστυχώς). Το τελευταίο δισκάκι περιέχει επίσης τον τελικό πηγαίο κώδικα συν τα αρχεία SCCS.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-journals>B.9. Περιοδικά και εφημερίδες<a class=anchor href=#bibliography-journals></a></h3><div class=ulist><ul><li><p><em>The C/C++ Users Journal</em>. R&amp;D Publications Inc. ISSN 1075-2838</p></li><li><p><em>Sys Admin - The Journal for UNIX System Administrators</em> Miller Freeman, Inc., ISSN 1061-2688</p></li><li><p><em>freeX - Das Magazin für Linux - BSD - UNIX</em> (στα Γερμανικά) Computer- und Literaturverlag GmbH, ISSN 1436-7033</p></li></ul></div></div></div></div><div class=sect1><h2 id=eresources>Appendix C: Πηγές Πληροφόρησης στο Διαδίκτυο<a class=anchor href=#eresources></a></h2><div class=sectionbody><div class=paragraph><p>Η ραγδαία εξέλιξη του FreeBSD καθιστά τα έντυπα μέσα ανίκανα να ακολουθήσουν τις τελευταίες εξελίξεις. Οι ηλεκτρονικές πηγές είναι ο καλύτερος (αν όχι ο μόνος) τρόπος για να παραμείνετε ενήμερος για τις τελευταίες εξελίξεις. Καθώς το FreeBSD είναι μια εθελοντική προσπάθεια, η κοινότητα των χρηστών λειτουργεί και ως "τμήμα τεχνικής υποστήριξης", με το ηλεκτρονικό ταχυδρομείο, τα web forums, και τα USENET news να είναι οι πλέον αποτελεσματικοί τρόποι για να έλθετε σε επαφή με αυτή την κοινότητα.</p></div><div class=paragraph><p>Στις παρακάτω ενότητες, θα βρείτε τα σημαντικότερα σημεία επικοινωνίας με την κοινότητα χρηστών του FreeBSD. Αν γνωρίζετε και άλλες πηγές, οι οποίες δεν αναφέρονται εδώ, παρακαλούμε να τις στείλετε στην <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>ηλεκτρονική λίστα ομάδας τεκμηρίωσης του FreeBSD</a> ώστε να ενταχθούν και αυτές.</p></div><div class=sect2><h3 id=eresources-mail>C.1. Λίστες Ηλεκτρονικού Ταχυδρομείου<a class=anchor href=#eresources-mail></a></h3><div class=paragraph><p>Οι λίστες ηλεκτρονικού ταχυδρομείου είναι ο πιο άμεσος τρόπος για να απευθύνετε τις ερωτήσεις σας ή να ανοίξετε μια τεχνική συζήτηση που να απευθύνεται σε κοινό ειδικευμένο στο FreeBSD. Υπάρχει μεγάλη ποικιλία από λίστες, οι οποίες καλύπτουν ευρύ φάσμα θεμάτων του FreeBSD. Κατευθύνοντας τις ερωτήσεις σας στη σωστή λίστα, θα εξασφαλίσετε ταχύτερη και ακριβέστερη απόκριση.</p></div><div class=paragraph><p>Στο τέλος αυτού του κειμένου θα βρείτε ένα πίνακα με τη θεματολογία της κάθε λίστας. <em>Παρακαλούμε να τον διαβάσετε πριν αρχίσετε να συμμετέχετε ή να στέλνετε μηνύματα σε οποιαδήποτε λίστα</em>. Οι περισσότεροι από τους συνδρομητές μας δέχονται καθημερινά εκατοντάδες μηνύματα σχετικά με το FreeBSD. Οι κανόνες που έχουμε καθιερώσει, βοηθάνε να γίνεται σωστή χρήση και να διατηρείται σε υψηλό επίπεδο η αναλογία σήματος προς θόρυβο της κάθε λίστας. Εάν ήμασταν πιο χαλαροί, οι λίστες μας θα έχαναν την αποτελεσματικότητα τους ως μέσο επικοινωνίας για το Project.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Αν θέλετε να δοκιμάσετε την ικανότητα σας να στέλνετε μηνύματα στις λίστες του FreeBSD, στείλτε ένα δοκιμαστικό μήνυμα στην λίστα <a href=https://lists.FreeBSD.org/subscription/freebsd-test>ηλεκτρονική λίστα του FreeBSD για δοκιμαστικά μηνύματα</a>.</em> Παρακαλούμε μη στέλνετε δοκιμαστικά μηνύματα σε οποιαδήποτε άλλη λίστα.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Αν βρίσκεστε σε δίλημμα σχετικά με το ποια λίστα να στείλετε μια ερώτηση, δείτε το <a href=https://docs.freebsd.org/el/articles/freebsd-questions/>Πως να χρησιμοποιείτε με επιτυχία την λίστα ηλεκτρονικού ταχυδρομείου FreeBSD-questions</a>.</p></div><div class=paragraph><p>Πριν στείλετε κάτι σε οποιαδήποτε λίστα, μάθετε πως να χρησιμοποιείτε καλύτερα τις λίστες ηλεκτρονικού ταχυδρομείου. Για παράδειγμα, δείτε πως μπορείτε να βοηθήσετε ώστε να αποφεύγονται συχνά επαναλαμβανόμενες συζητήσεις, διαβάζοντας το κείμενο <a href=https://docs.freebsd.org/el/articles/mailing-list-faq/>Συχνές Ερωτήσεις Σχετικά με τις Λίστες Ταχυδρομείου</a> (FAQ).</p></div><div class=paragraph><p>Για όλες τις λίστες ηλεκτρονικού ταχυδρομείου διατηρείται αρχείο με τις παλιές δημοσιεύσεις, στο οποίο μπορεί να γίνει αναζήτηση χρησιμοποιώντας την <a href=https://www.FreeBSD.org/search/>Δικτυακή Τοποθεσία του FreeBSD</a>. Είναι δυνατή η αναζήτηση στο αρχείο μέσω λέξεων-κλειδιών, το οποίο αποτελεί ένα άριστο τρόπο για να βρείτε απαντήσεις σε συχνές ερωτήσεις. Πριν στείλετε μια ερώτηση, καλό θα είναι να πραγματοποιήσετε μια τέτοια αναζήτηση. Σημειώστε επίσης ότι τα μηνύματα που στέλνονται σε αυτές τις λίστες αποθηκεύονται για πάντα. Αν σας προβληματίζει η προστασία των προσωπικών σας δεδομένων, σας συνιστούμε να χρησιμοποιήσετε μια δευτερεύουσα διεύθυνση email, και να μην γράφετε ποτέ προσωπικές σας πληροφορίες.</p></div><div class=sect3><h4 id=eresources-summary>C.1.1. Σύνοψη Λιστών<a class=anchor href=#eresources-summary></a></h4><div class=paragraph><p><em>Γενικές λίστες:</em> Οι ακόλουθες είναι γενικές λίστες όπου ο καθένας είναι ελεύθερος (και ενθαρρύνεται) να συμμετέχει:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Λίστα</th><th class="tableblock halign-left valign-top">Σκοπός</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-advocacy>freebsd-advocacy</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Διαφήμιση και προώθηση του FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>ηλεκτρονική λίστα ανακοινώσεων του FreeBSD</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Σημαντικά γεγονότα και ανακοινώσεις</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις αρχιτεκτονικής και σχεδιασμού</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις που αναφέρονται στην συντήρηση της βάσης δεδομένων αναφοράς προβλημάτων του FreeBSD, και των σχετικών εργαλείων της</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Αναφορές σφαλμάτων</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μη-τεχνικά θέματα που σχετίζονται με την κοινότητα του FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-chromium>freebsd-chromium</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Θέματα σχετικά με το Chromium στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις που σχετίζονται με τη χρήση FreeBSD-CURRENT</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Θέματα για Παροχείς Υπηρεσιών Διαδικτύου που χρησιμοποιούν το FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συμβουλευτικές υπηρεσίες και θέσεις εργασίας σχετικές με FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Απορίες χρηστών και τεχνική υποστήριξη</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>ηλεκτρονική λίστα Ανακοινώσεων για Θέματα Ασφάλειας του FreeBSD</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ειδοποιήσεις ασφαλείας</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>ηλεκτρονική λίστα του FreeBSD-STABLE;</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις που σχετίζονται με την χρήση του FreeBSD-STABLE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-test>ηλεκτρονική λίστα του FreeBSD για δοκιμαστικά μηνύματα</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Στείλτε εδώ τα δοκιμαστικά σας μηνύματα αντί για μια από τις πραγματικές λίστες</p></td></tr></tbody></table><div class=paragraph><p><em>Τεχνικές λίστες:</em> Οι ακόλουθες λίστες είναι για τεχνικές συζητήσεις. Πριν αρχίσετε να συμμετέχετε και να στέλνετε μηνύματα σε αυτές, θα πρέπει να διαβάσετε προσεκτικά την περιγραφή τους. Υπάρχουν αυστηρές οδηγίες για τη χρήση και το περιεχόμενο τους.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Λίστα</th><th class="tableblock halign-left valign-top">Σκοπός</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>ηλεκτρονική λίστα για ACPI του FreeBSD</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάπτυξη της διαχείρισης ενέργειας και του ACPI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-afs>freebsd-afs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του AFS στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/aic7xxx>freebsd-aic7xxx</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάπτυξη οδηγών για κάρτες Adaptec® AIC 7xxx</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-amd64>freebsd-amd64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του FreeBSD σε συστήματα AMD64</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-apache>freebsd-apache</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για ports σχετικά με τον Apache</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arm>freebsd-arm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του FreeBSD σε επεξεργαστές ARM®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-atm>freebsd-atm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Χρήση δικτύωσης ATM στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-binup>freebsd-binup</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Σχεδίαση και ανάπτυξη του συστήματος έτοιμων ενημερώσεων (binary updates)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Χρήση της τεχνολογίας Bluetooth® στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cluster>freebsd-cluster</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Χρήση του FreeBSD σε παράλληλα συστήματα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cvsweb>freebsd-cvsweb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συντήρηση του CVSweb</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-database>freebsd-database</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για την χρήση και ανάπτυξη βάσεων δεδομένων στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δημιουργία τεκμηρίωσης για το FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-desktop>freebsd-desktop</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Χρήση και βελτίωση του FreeBSD ως desktop</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Δημιουργία οδηγών συσκευών για το FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για τη χρήση του Eclipse IDE, των εργαλείων του, καθώς και rich client εφαρμογών και ports στο FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Χρήση του FreeBSD σε embedded εφαρμογές</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-eol>freebsd-eol</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ομότιμη υποστήριξη για λογισμικό σχετικό με FreeBSD, που δεν υποστηρίζεται πλέον από το FreeBSD Project.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Εξομοίωση άλλων συστημάτων, όπως είναι τα Linux/MS-DOS®/Windows®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τεχνική συζήτηση για FreeBSD FireWire® (iLink, IEEE 1394)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συστήματα αρχείων</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-gecko>freebsd-gecko</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση σχετικά με το Gecko Rendering Engine</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις σχετικές με το GEOM και τις υλοποιήσεις του</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του GNOME και των εφαρμογών του</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Γενικές τεχνικές συζητήσεις</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Γενική συζήτηση για συμβατότητα υλικού με το FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-i18n>freebsd-i18n</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Διεθνοποίηση του FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ia32>freebsd-ia32</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το FreeBSD στην αρχιτεκτονική IA-32 (Intel® x86)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ia64>freebsd-ia64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του FreeBSD στα νέα συστήματα IA64 της Intel®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τεχνική συζήτηση που επικεντρώνεται στον επανασχεδιασμό του κώδικα IP του firewall</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ομάδα ανάπτυξης του ISDN</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-jail>freebsd-jail</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση σχετικά με τις δυνατότητες του <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ομάδα ανάπτυξης Java™ και άτομα που μεταφέρουν τα JDK™s στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://freebsd.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του KDE και των εφαρμογών του</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-lfs>freebsd-lfs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του LFS στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mips>freebsd-mips</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του FreeBSD σε επεξεργαστές MIPS®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mobile>freebsd-mobile</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις σχετικές με φορητά υπολογιστικά συστήματα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mono>freebsd-mono</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Εφαρμογές Mono και C# στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mozilla>freebsd-mozilla</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του Mozilla στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>ηλεκτρονική λίστα του FreeBSD για τα πολυμέσα</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Εφαρμογές πολυμέσων</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-new-bus>freebsd-new-bus</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τεχνικές συζητήσεις σχετικές με την αρχιτεκτονική διαύλων</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-net>freebsd-net</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις δικτύωσης και πηγαίος κώδικας TCP/IP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-numerics>freebsd-numerics</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζητήσεις για υλοποίηση υψηλής ποιότητας συναρτήσεων της βιβλιοθήκης libm</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-office>freebsd-office</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Εφαρμογές γραφείου στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ερωτήσεις σχετικές με βελτιστοποίηση απόδοσης για εγκαταστάσεις υψηλής απόδοσης και μεγάλου φορτίου</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-perl>freebsd-perl</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Υποστήριξη ενός αριθμού από ports σχετικά με Perl</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση και ερωτήσεις σχετικές με το σύστημα packet filter firewall</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για μεταφορά σε μη-Intel® αρχιτεκτονικές</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για την Συλλογή των Ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-announce>freebsd-ports-announce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Σημαντικές ειδήσεις και οδηγίες σχετικές με την Συλλογή των Ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>freebsd-ports-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για σφάλματα και αναφορές σφαλμάτων (PRs) που αφορούν ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ppc>freebsd-ppc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του FreeBSD στο PowerPC®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Τεχνική συζήτηση για χρήση του FreeBSD σε διακομιστές HP ProLiant</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Θέματα σχετικά με Python στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-rc>freebsd-rc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση σχετικά με το σύστημα <span class=filename>rc.d</span> και την ανάπτυξή του</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-realtime>freebsd-realtime</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ανάπτυξη επεκτάσεων πραγματικού χρόνου του FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ruby>freebsd-ruby</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση σχετικά με τη Ruby στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Το υποσύστημα SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security>ηλεκτρονική λίστα του FreeBSD για θέματα ασφάλειας</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Θέματα ασφαλείας που επηρεάζουν το FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-small>freebsd-small</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Χρήση του FreeBSD σε embedded συστήματα (Δεν χρησιμοποιείται πλέον: αντί για αυτή τη λίστα, χρησιμοποιήστε την <a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sparc64>freebsd-sparc64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του FreeBSD σε SPARC® συστήματα</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συμμόρφωση του FreeBSD με τα πρότυπα C99 και POSIX®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sysinstall>freebsd-sysinstall</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για την ανάπτυξη του <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-threads>freebsd-threads</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Πολυνηματική επεξεργασία στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tilera>freebsd-tilera</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μεταφορά του FreeBSD στην οικογένεια CPU Tilera</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tokenring>freebsd-tokenring</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Υποστήριξη του Token Ring στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-toolchain>freebsd-toolchain</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συντήρηση των εργαλείων του FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση υποστήριξης του USB στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-virtualization>freebsd-virtualization</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση σχετικά με διάφορες τεχνικές εικονικοποίησης που υποστηρίζονται από το FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-vuxml>freebsd-vuxml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για την υποδομή VuXML</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-x11>freebsd-x11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συντήρηση και υποστήριξη του X11 στο FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-xen>freebsd-xen</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση για τη μεταφορά του FreeBSD στο Xen™ - υλοποίηση και χρήση</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-xfce>freebsd-xfce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>XFCE στο FreeBSD - Μεταφορά και συντήρηση</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-zope>freebsd-zope</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zope στο FreeBSD - Μεταφορά και συντήρηση</p></td></tr></tbody></table><div class=paragraph><p><em>Περιορισμένες λίστες:</em> Οι ακόλουθες λίστες είναι για πιο ειδικό (και απαιτητικό) κοινό και πιθανώς δεν ενδιαφέρουν το γενικό κοινό. Πριν αρχίσετε να συμμετέχετε σε κάποια από αυτές, καλό θα είναι να έχετε παρακολουθήσει τις τεχνικές λίστες, ώστε να αντιλαμβάνεστε τον κώδικα επικοινωνίας και συμπεριφοράς που ισχύει σε αυτές.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Λίστα</th><th class="tableblock halign-left valign-top">Σκοπός</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Άτομα που διατηρούν mirror sites (υποστήριξη υποδομών)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Οργάνωση των συλλόγων χρηστών</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-vendors>freebsd-vendors</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Οργάνωση μεταπωλητών πριν από επίσημες εκδόσεις</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-wip-status>freebsd-wip-status</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Κατάσταση εργασιών του FreeBSD που βρίσκονται σε εξέλιξη (Work-in-Progress).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-wireless>freebsd-wireless</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συζήτηση σχετικά με τη στοίβα 802.11, τα εργαλεία ασύρματου δικτύου και την ανάπτυξη προγραμμάτων οδήγησης.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-www>freebsd-www</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Συντηρητές του <a href=https://www.FreeBSD.org>www.FreeBSD.org</a></p></td></tr></tbody></table><div class=paragraph><p><em>Λίστες digest:</em> Όλες οι παραπάνω λίστες διατίθενται και σε μορφή digest (περίληψης). Μόλις εγγραφείτε σε μία λίστα, μπορείτε να αλλάξετε τις επιλογές digest στο τμήμα ρυθμίσεων του λογαριασμού σας.</p></div><div class=paragraph><p><em>Λίστες SVN:</em> Οι ακόλουθες λίστες είναι για όσους ενδιαφέρονται να βλέπουν τα μηνύματα (log) που δείχνουν τις αλλαγές σε διάφορες περιοχές του πηγαίου κώδικα. Είναι λίστες <em>μόνο για ανάγνωση</em> και δεν πρέπει να στέλνετε μηνύματα σε αυτές.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Λίστα</th><th class="tableblock halign-left valign-top">Περιοχή πηγαίου κώδικα</th><th class="tableblock halign-left valign-top">Περιγραφή περιοχής (κώδικας για)</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-all>svn-doc-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στο δέντρο doc του Subversion (εκτός από τις περιοχές <span class=filename>user</span>, <span class=filename>projects</span> και <span class=filename>translations</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-head>svn-doc-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στoν κλάδο "head" του doc Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-projects>svn-doc-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στην περιοχή "projects" του doc Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-svnadmin>svn-doc-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στα scripts διαχείρισης, hooks και άλλα δεδομένα ρυθμίσεων του doc Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-ports-all>svn-ports-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στo ports Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-ports-head>svn-ports-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στον κλάδο "head" του ports Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-ports-svnadmin>svn-ports-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στα scripts διαχείρισης, hooks και άλλα δεδομένα ρυθμίσεων του ports Subversion repository.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-all>ηλεκτρονική λίστα μηνυμάτων SVN commit πηγαίου κώδικα του FreeBSD (εξαιρούνται τα δέντρα "user" και "projects")</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στο src Subversion repository (εκτός από τις περιοχές <span class=filename>user</span> και <span class=filename>projects</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-head>ηλεκτρονική λίστα μηνυμάτων SVN commit πηγαίου κώδικα για τον κλάδο head/-current</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στον κλάδο "head" του src Subversion repository (πρόκειται για τον κλάδο FreeBSD-CURRENT)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-projects>svn-src-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στην περιοχή πηγαίου κώδικα <span class=filename>projects</span> του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-release>svn-src-release</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στην περιοχή πηγαίου κώδικα <span class=filename>releases</span> του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-releng>svn-src-releng</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές σε όλους τους κλάδους πηγαίου κώδικα <span class=filename>releng</span> του Subversion repository (πρόκειται για τους κλάδους security / release engineering)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable>svn-src-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές σε όλους τους κλάδους πηγαίου κώδικα stable του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-6>svn-src-stable-6</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στον κλάδο πηγαίου κώδικα <span class=filename>stable/6</span> του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-7>svn-src-stable-7</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στον κλάδο πηγαίου κώδικα <span class=filename>stable/7</span> του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-8>svn-src-stable-8</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στον κλάδο πηγαίου κώδικα <span class=filename>stable/8</span> του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-9>ηλεκτρονική λίστα μηνυμάτων SVN commit μόνο για το δέντρο πηγαίου κώδικα 9-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στον κλάδο πηγαίου κώδικα <span class=filename>stable/9</span> του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-other>svn-src-stable-other</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στους παλιούς <span class=filename>stable</span> κλάδους πηγαίου κώδικα του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-svnadmin>svn-src-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στα scripts διαχείρισης, τα hooks, και άλλα δεδομένα που αφορούν τις ρυθμίσεις του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-user>svn-src-user</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στην πειραματική περιοχή πηγαίου κώδικα <span class=filename>user</span> του Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-vendor>svn-src-vendor</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Όλες οι αλλαγές στην περιοχή εργασίας πηγαίου κώδικα vendor του Subversion repository</p></td></tr></tbody></table></div><div class=sect3><h4 id=eresources-subscribe>C.1.2. Πως να Εγγραφείτε<a class=anchor href=#eresources-subscribe></a></h4><div class=paragraph><p>Για να εγγραφείτε σε μία λίστα, επιλέξτε το όνομα της από τους παραπάνω δεσμούς ή πηγαίνετε στο <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> και επιλέξτε την λίστα για την οποία ενδιαφέρεστε. Η σελίδα της λίστας πρέπει να περιέχει όλες τις απαραίτητες πληροφορίες εγγραφής.</p></div><div class=paragraph><p>Για να γράψετε σε μια λίστα, στείλτε το μήνυμα σας στο <a href=mailto:όνομα-λίστας@FreeBSD.org>όνομα-λίστας@FreeBSD.org</a>. Το μήνυμα σας θα διανεμηθεί σε όλα τα μέλη της λίστας, σε οποιοδήποτε σημείο του κόσμου και αν βρίσκονται.</p></div><div class=paragraph><p>Για να διαγραφείτε από μια λίστα, επιλέξτε το URL που βρίσκεται στο τέλος κάθε μηνύματος που λαμβάνετε από την λίστα. Μπορείτε επίσης να στείλετε ένα μήνυμα στο <a href=mailto:όνομα-λίστας-unsubscribe@FreeBSD.org>όνομα-λίστας-unsubscribe@FreeBSD.org</a> για να διαγραφείτε μόνος σας.</p></div><div class=paragraph><p>Για ακόμα μια φορά, θα θέλαμε να σας ζητήσουμε να διατηρήσετε τη συζήτηση των τεχνικών λιστών στα αντίστοιχα τεχνικά θέματα. Αν ενδιαφέρεστε μόνο για σημαντικές ανακοινώσεις, τότε προτείνουμε να εγγραφείτε στην <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>ηλεκτρονική λίστα ανακοινώσεων του FreeBSD</a>, η οποία έχει μικρή κίνηση.</p></div></div><div class=sect3><h4 id=eresources-charters>C.1.3. Πίνακες Λιστών<a class=anchor href=#eresources-charters></a></h4><div class=paragraph><p><em>Όλες</em> οι FreeBSD λίστες έχουν συγκεκριμένους βασικούς κανόνες οι οποίοι πρέπει να ακολουθούνται από οποιονδήποτε τις χρησιμοποιεί. Όποιος αποτύχει να ακολουθήσει αυτούς τους κανόνες θα λάβει δύο (2) γραπτές προειδοποιήσεις από τον FreeBSD Postmaster <a href=mailto:postmaster@FreeBSD.org>postmaster@FreeBSD.org</a>. Σε περίπτωση τρίτης παραβίασης, το άτομο αυτό θα απομακρυνθεί από όλες τις λίστες του FreeBSD και τα μηνύματα του προς αυτές θα φιλτράρονται. Λυπόμαστε που χρειάζεται να επιβάλλουμε αυτούς τους κανόνες και μέτρα, αλλά το σημερινό Διαδίκτυο είναι καθώς φαίνεται ένα πολύ σκληρό περιβάλλον, και πολλοί δεν εκτιμούν πόσο εύθραυστοι είναι μερικοί μηχανισμοί του.</p></div><div class=paragraph><p>Κανόνες:</p></div><div class=ulist><ul><li><p>Το θέμα κάθε μηνύματος πρέπει να είναι σχετικό με τον βασικό σκοπό της λίστας που στάλθηκε, π.χ. αν η λίστα σχετίζεται με τεχνικά θέματα τότε το μήνυμα σας πρέπει να περιέχει τεχνικό περιεχόμενο. Η άσχετη φλυαρία ή το flaming μειώνει την αξία της λίστας για όλους που την παρακολουθούν και δεν μπορούμε να ανεχτούμε αυτή τη συμπεριφορά. Για ελεύθερες συζητήσεις χωρίς κάποιο συγκεκριμένο θέμα, διατίθεται η <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>ηλεκτρονική λίστα γενικών συζητήσεων του FreeBSD</a> την οποία και θα πρέπει να χρησιμοποιείτε.</p></li><li><p>Κανένα μήνυμα δεν θα πρέπει να σταλεί σε περισσότερες από 2 λίστες, και σε 2 μόνο όταν υπάρχει ξεκάθαρος και προφανής λόγος για κάτι τέτοιο. Πολλοί συνδρομητές είναι έτσι και αλλιώς γραμμένοι σε περισσότερες από μία λίστες. Έτσι, αν δεν πρόκειται να κάνετε κάποιο περίεργο συνδυασμό (π.χ. "-stable & -scsi"), δεν υπάρχει λόγος να στείλετε μήνυμα σε περισσότερες από μία λίστα κάθε φορά. Αν λάβετε κάποιο μήνυμα στο οποίο φαίνονται πολλαπλές λίστες στην γραμμή <code>Cc</code>, καλό θα είναι να περικόψετε κάποιες από αυτές πριν στείλετε απάντηση. <em>Θεωρείστε υπεύθυνος για τα δικά σας cross-postings, ανεξάρτητα ποιος είναι ο δημιουργός τους.</em></p></li><li><p>Προσωπικές επιθέσεις και ασέβεια (στο περιεχόμενο μιας αντιπαράθεσης) δεν επιτρέπονται, και αυτό αφορά τόσο τους χρήστες όσο και τους developers. Μεγάλες παραβάσεις των κανόνων (netiquette), όπως χρήση τμημάτων ή ολόκληρων προσωπικών μηνυμάτων όταν δεν έχει δοθεί άδεια για να γίνει αυτό και δεν ήταν αναμενόμενο, αποδοκιμάζονται αλλά δεν απαγορεύονται ρητά. <em>Όμως</em>, υπάρχουν μερικές περιπτώσεις όπου τέτοιο περιεχόμενο εμπίπτει στους κανονισμούς κάποιας λίστας και μπορεί να οδηγήσει σε προειδοποίηση (ή ακόμα και αποκλεισμό) από αυτήν.</p></li><li><p>Διαφήμιση προϊόντων ή υπηρεσιών που δεν σχετίζονται με το FreeBSD απαγορεύεται αυστηρά και θα οδηγήσει σε άμεσο αποκλεισμό αν είναι φανερό ότι ο πταίστης διαφημίζεται με spam.</p></li></ul></div><div class=paragraph><p><em>Ατομικοί πίνακες λιστών:</em></p></div><div class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>ηλεκτρονική λίστα για ACPI του FreeBSD</a></dt><dd><p><em>Ανάπτυξη της διαχείρισης ενέργειας και του ACPI</em></p></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-afs>freebsd-afs</a></dt><dd><p><em>Andrew File System</em></p><div class=paragraph><p>Αυτή η λίστα είναι για συζήτηση της μεταφοράς και της χρήσης του AFS από το CMU/Transarc</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>ηλεκτρονική λίστα ανακοινώσεων του FreeBSD</a></dt><dd><p><em>Σημαντικά γεγονότα και ανακοινώσεις</em></p><div class=paragraph><p>Αυτή η λίστα είναι για άτομα που ενδιαφέρονται μόνο για περιστασιακές ανακοινώσεις σημαντικών γεγονότων του FreeBSD. Περιλαμβάνει ανακοινώσεις σχετικά με snapshots και άλλα releases. Επίσης δημοσιεύονται σε αυτήν ανακοινώσεις για νέες ικανότητες του FreeBSD. Μπορεί να περιέχει εκκλήσεις για εθελοντές κτλ. Πρόκειται για μία λίστα με μικρή κίνηση, και οι δημοσιεύσεις ελέγχονται αυστηρά.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></dt><dd><p><em>Συζητήσεις αρχιτεκτονικής και σχεδιασμού</em></p><div class=paragraph><p>Σε αυτή την λίστα συζητείται η αρχιτεκτονική του FreeBSD. Τα μηνύματα είναι κατά κύριο λόγο αρκετά τεχνικά. Παραδείγματα σχετικών θεμάτων είναι:</p></div><div class=ulist><ul><li><p>Πως να επανασχεδιαστεί το σύστημα μεταγλώττισης ώστε να εκτελεί ταυτόχρονα πολλές προσαρμοσμένες μεταγλωττίσεις.</p></li><li><p>Τι πρέπει να επισκευαστεί στο VFS ώστε να λειτουργούν τα Heidemann layers.</p></li><li><p>Πώς πρέπει να μετατρέψουμε τη διεπαφή (interface) των οδηγών συσκευών ώστε να μπορούμε να χρησιμοποιήσουμε τα ίδια προγράμματα οδήγησης σε πολλούς διαύλους και αρχιτεκτονικές.</p></li><li><p>Πως να γράψετε ένα οδηγό δικτύου.</p></li></ul></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-binup>freebsd-binup</a></dt><dd><p><em>Project αναβάθμισης του FreeBSD μέσω έτοιμων (δυαδικών) αρχείων</em></p><div class=paragraph><p>Σε αυτή την λίστα συζητείται το σύστημα αναβάθμισης μέσω έτοιμων (binary) αρχείων, ή binup. Σε αυτή τη λίστα ανήκουν θέματα σχεδιασμού, λεπτομέρειες υλοποίησης, "patches", αναφορές σφαλμάτων, αναφορές κατάστασης, αιτήσεις για πρόσθετα χαρακτηριστικά, commit logs, και ότι άλλο σχετίζεται με το binup.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></dt><dd><p><em>Χρήση της τεχνολογίας Bluetooth® στο FreeBSD</em></p><div class=paragraph><p>Σε αυτή τη λίστα συναθροίζονται οι χρήστες του Bluetooth® στο FreeBSD. Η λίστα ασχολείται με θέματα σχεδιασμού, λεπτομέρειες υλοποίησης, "patches", αναφορές σφαλμάτων, αναφορές κατάστασης, αιτήσεις για πρόσθετα χαρακτηριστικά, και ότι άλλο σχετίζεται με το Bluetooth®.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></dt><dd><p><em>Προσπάθεια οργάνωσης του χειρισμού των αναφορών προβλημάτων</em></p><div class=paragraph><p>Σκοπός αυτής της λίστας είναι να λειτουργεί ως χώρος οργάνωσης και συζήτησης για τον Bugmeister, τους Bugbusters, και όσους άλλους ενδιαφέρονται για την βάση δεδομένων PR. Αυτή ή λίστα δεν είναι για συζητήσεις σχετικά με ιδιαίτερα σφάλματα, "patches" ή PRs.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></dt><dd><p><em>Αναφορές σφαλμάτων</em></p><div class=paragraph><p>Αυτή η λίστα είναι για αναφορές σφαλμάτων του FreeBSD. Όποτε είναι δυνατό, τα σφάλματα πρέπει να στέλνονται με την εντολή <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> ή μέσω της αντίστοιχης <a href=https://www.FreeBSD.org/send-pr/>διεπαφή WEB</a>.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></dt><dd><p><em>Μη τεχνικά θέματα που σχετίζονται με την κοινότητα του FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα περιέχει κοινωνικές συζητήσεις, και γενικότερα ότι δεν σχετίζεται με τεχνικές πληροφορίες με τις οποίες ασχολούνται οι υπόλοιπες λίστες. Περιέχει συζητήσεις για το αν ο Jordan μοιάζει με μικρό κουνάβι ή όχι, για το αν πρέπει ή όχι να γράφουμε με κεφαλαία, ποιος πίνει πολύ καφέ, που φτιάχνεται η καλύτερη μπύρα, ποιος φτιάχνει μπύρα στο υπόγειο του, και άλλα. Περιστασιακές ανακοινώσεις σημαντικών γεγονότων (όπως πάρτυ, γάμοι, γεννήσεις, καινούργιες δουλειές κλπ) μπορούν να γίνουν στις τεχνικές λίστες, αλλά οι απαντήσεις τους πρέπει να στέλνονται στην λίστα -chat.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-chromium>freebsd-chromium</a></dt><dd><p><em>Θέματα σχετικά με το Chromium στο FreeBSD</em></p><div class=paragraph><p>Λίστα συζητήσεων για την υποστήριξη του Chromium στο FreeBSD. Πρόκειται για τεχνική λίστα σχετική με την ανάπτυξη και εγκατάσταση του Chromium.
::
<em>Ομάδα core του FreeBSD</em></p></div><div class=paragraph><p>Αυτή είναι μία εσωτερική λίστα για χρήση από τα μέλη του core. Σε αυτή τη λίστα μπορείτε να στείλετε μηνύματα, όταν προκύψει κάποιο θέμα σχετικό με το FreeBSD το οποίο απαιτεί διαιτησία ή λεπτομερή εξέταση.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-current>ηλεκτρονική λίστα της έκδοσης FreeBSD-CURRENT</a></dt><dd><p><em>Συζητήσεις σχετικά με την χρήση του FreeBSD-CURRENT</em></p><div class=paragraph><p>Αυτή η λίστα είναι για χρήστες του FreeBSD-CURRENT. Περιέχει προειδοποιήσεις για νέα χαρακτηριστικά που πρόκειται να προστεθούν στο -CURRENT και τα οποία θα επηρεάσουν τους χρήστες, και οδηγίες για τις κινήσεις που πρέπει να γίνουν ώστε να παραμείνετε στο -CURRENT. Όποιος εκτελεί το "CURRENT" πρέπει να εγγραφεί σε αυτήν την λίστα. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-cvsweb>freebsd-cvsweb</a></dt><dd><p><em>FreeBSD CVSweb Project</em></p><div class=paragraph><p>Τεχνικές συζητήσεις για την χρήση, την ανάπτυξη και την συντήρηση του FreeBSD-CVSweb.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-desktop>freebsd-desktop</a></dt><dd><p><em>Χρήση και βελτίωση του FreeBSD ως desktop</em></p><div class=paragraph><p>Ή λίστα αυτή προορίζεται για συζητήσεις σχετικές με τη χρήση του FreeBSD ως desktop. Απευθύνεται κυρίως σε χρήστες και προγραμματιστές που επιθυμούν να συζητήσουν τα προβλήματα που παρουσιάζει το FreeBSD σε desktop εφαρμογές, καθώς και αντίστοιχες βελτιώσεις.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></dt><dd><p><em>Project τεκμηρίωσης του FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα είναι για συζήτηση θεμάτων και projects που σχετίζονται με την δημιουργία τεκμηρίωσης για το FreeBSD. Τα μέλη αυτής της λίστας αποκαλούνται συνολικά ως "The FreeBSD Documentation Project". Είναι μια ανοικτή λίστα και είστε ελεύθερος να συμμετέχετε και να συνεισφέρετε!</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></dt><dd><p><em>Δημιουργία οδηγών συσκευών για το FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα προορίζεται για τεχνικές συζητήσεις σχετικές με οδηγούς συσκευών στο FreeBSD. Χρησιμοποιείται κυρίως από τους δημιουργούς οδηγών συσκευών για ερωτήσεις σχετικές με τη συγγραφή οδηγών, χρησιμοποιώντας τα APIs που παρέχει ο πυρήνας του FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></dt><dd><p><em>FreeBSD χρήστες του Eclipse IDE, των εργαλείων του, rich client εφαρμογών, και ports.</em></p><div class=paragraph><p>Πρόθεση της λίστας αυτής είναι να προσφέρει αμοιβαία υποστήριξη για ότι έχει να κάνει με την επιλογή, εγκατάσταση, χρήση, ανάπτυξη και συντήρηση του Eclipse IDE, των εργαλείων του, εφαρμογών rich client στην πλατφόρμα του FreeBSD και για βοήθεια σχετικά με την μεταφορά του Eclipse IDE και των πρόσθετων του στο περιβάλλον του FreeBSD.</p></div><div class=paragraph><p>Πρόθεση της είναι επίσης να διευκολύνει την ανταλλαγή πληροφοριών ανάμεσα στην κοινότητα του Eclipse και στην κοινότητα του FreeBSD, προς όφελος και των δύο.</p></div><div class=paragraph><p>Αν και η λίστα επικεντρώνεται κυρίως στις ανάγκες των χρηστών του Eclipse, προσφέρει επίσης ένα χώρο συζήτησης για όσους θέλουν να αναπτύξουν εφαρμογές σχετικές με το FreeBSD χρησιμοποιώντας το Eclipse.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></dt><dd><p><em>Χρήση του FreeBSD σε embedded εφαρμογές</em></p><div class=paragraph><p>Η λίστα συζητά θέματα σχετικά με την χρήση του FreeBSD σε embedded συστήματα. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα. Για τον σκοπό της λίστας αυτής, ορίζουμε ως embedded συστήματα τις υπολογιστικές συσκευές που δεν προορίζονται για desktop εφαρμογές, και που συνήθως καλύπτουν μια μόνο ανάγκη, αντίθετα με τα γενικά υπολογιστικά περιβάλλοντα. Συμπεριλαμβάνονται, εκτός των άλλων, όλα τα τηλέφωνα, δικτυακός εξοπλισμός όπως routers, switches και PBXs, εξοπλισμός μετρήσεων από απόσταση, PDAs, συστήματα Point Of Sale, και πάει λέγοντας.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></dt><dd><p><em>Εξομοίωση άλλων συστημάτων όπως είναι τα Linux/MS-DOS®/Windows®</em></p><div class=paragraph><p>Είναι μια λίστα για τεχνικές συζητήσεις, σχετικές με την εκτέλεση στο FreeBSD προγραμμάτων που δημιουργήθηκαν για άλλα λειτουργικά.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-eol>freebsd-eol</a></dt><dd><p><em>Ομότιμη υποστήριξη για λογισμικό σχετικό με το FreeBSD που δεν υποστηρίζεται πλέον από το FreeBSD Project.</em></p><div class=paragraph><p>Αυτή η λίστα είναι για όσους ενδιαφέρονται να παρέχουν ή να χρησιμοποιήσουν την ομότιμη υποστήριξη για λογισμικό σχετικό με το FreeBSD που δεν υποστηρίζεται πλέον από το FreeBSD Project (π.χ., με την μορφή "patches" και ανακοινώσεων ασφαλείας).</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></dt><dd><p><em>FireWire® (iLink, IEEE 1394)</em></p><div class=paragraph><p>Αυτή η λίστα είναι για την συζήτηση της σχεδίασης και υλοποίησης ενός υποσυστήματος FireWire® (γνωστό και ως IEEE 1394 ή iLink) για το FreeBSD. Σχετικά θέματα είναι τα πρότυπα, οι συσκευές διαύλου και τα πρωτόκολλά τους, κάρτες, προσαρμογείς και chipsets, και η αρχιτεκτονική και η υλοποίηση του κώδικα για την σωστή υποστήριξη τους.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></dt><dd><p><em>Συστήματα αρχείων</em></p><div class=paragraph><p>Συζητήσεις σχετικές με τα συστήματα αρχείων του FreeBSD. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-gecko>freebsd-gecko</a></dt><dd><p><em>Gecko Rendering Engine</em></p><div class=paragraph><p>Συζητήσεις σχετικές με εφαρμογές που χρησιμοποιούν την μηχανή Gecko στο FreeBSD.</p></div><div class=paragraph><p>Η συζήτηση επικεντρώνεται σε εφαρμογές της Συλλογής των Ports που χρησιμοποιούν τη μηχανή Gecko, και ειδικότερα την εγκατάσταση, ανάπτυξη και υποστήριξη τους στο FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></dt><dd><p><em>GEOM</em></p><div class=paragraph><p>Συζητήσεις σχετικές με το GEOM και παρόμοιες υλοποιήσεις. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></dt><dd><p><em>GNOME</em></p><div class=paragraph><p>Συζητήσεις σχετικές με το περιβάλλον GNOME για συστήματα FreeBSD. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></dt><dd><p><em>IP Firewall</em></p><div class=paragraph><p>Αυτή η λίστα είναι για τεχνικές συζητήσεις που αφορούν τον επανασχεδιασμό του κώδικα IP firewall στο FreeBSD. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ia64>freebsd-ia64</a></dt><dd><p><em>Μεταφορά του FreeBSD στην αρχιτεκτονική IA64</em></p><div class=paragraph><p>Πρόκειται για μια τεχνική λίστα, για άτομα που δουλεύουν ενεργά στην μεταφορά του FreeBSD στην πλατφόρμα IA-64 της Intel®, για να αναφέρουν προβλήματα ή να συζητήσουν εναλλακτικές λύσεις. Άτομα που ενδιαφέρονται να παρακολουθήσουν την τεχνική συζήτηση είναι επίσης ευπρόσδεκτα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></dt><dd><p><em>Ανάπτυξη του ISDN</em></p><div class=paragraph><p>Αυτή η λίστα είναι για άτομα που συζητούν την ανάπτυξη της υποστήριξης ISDN στο FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></dt><dd><p><em>Ανάπτυξη της Java™</em></p><div class=paragraph><p>Αυτή η λίστα είναι για άτομα που συζητούν την ανάπτυξη σημαντικών εφαρμογών Java™ για το FreeBSD και την μεταφορά και συντήρηση των JDK™s.</p></div></dd></dl></div><div id=eresources-charters-jobs class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></dt><dd><p><em>Ζήτηση και προσφορά εργασίας</em></p><div class=paragraph><p>Αυτός είναι ένας χώρος για δημοσίευση ανακοινώσεων για προσφορά και ζήτηση εργασίας που σχετίζεται με το FreeBSD, καθώς και βιογραφικών σχετικών με το FreeBSD. Αν για παράδειγμα αναζητάτε εργασία σχετική με το FreeBSD, ή προσφέρετε μια θέση εργασίας σχετική με το FreeBSD, αυτό είναι το σωστό μέρος για να τη διαφημίσετε. Η λίστα αυτή <em>δεν</em> είναι για γενικά θέματα εργασίας, για τα οποία υπάρχει πληθώρα από άλλες λίστες στο Διαδίκτυο.</p></div><div class=paragraph><p>Αυτή η λίστα, όπως και οι υπόλοιπες λίστες του <code>FreeBSD.org</code>, διανέμονται παγκόσμια. Έτσι, πρέπει να είστε σαφής για την τοποθεσία και την δυνατότητα τηλεργασίας ή βοήθειας στην μετοίκηση.</p></div><div class=paragraph><p>Το μήνυμα σας θα πρέπει να χρησιμοποιεί μόνο ανοιχτά πρότυπα - κατά προτίμηση απλό κείμενο, αν και βασικής μορφής Portable Document Format (PDF), HTML, και μερικά άλλα είναι αποδεκτά από πολλούς χρήστες. Κλειστά πρότυπα όπως το Microsoft® Word (<span class=filename>.doc</span>) θα απορριφθούν από τον διακομιστή της λίστας.</p></div></dd><dt class=hdlist1><a href=http://freebsd.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></dt><dd><p><em>KDE</em></p><div class=paragraph><p>Συζητήσεις που αφορούν το KDE σε συστήματα FreeBSD. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></dt><dd><p><em>Τεχνικές συζητήσεις</em></p><div class=paragraph><p>Είναι ένας χώρος για τεχνικές συζητήσεις σχετικές με το FreeBSD. Αυτή είναι η κύρια τεχνική λίστα. Είναι για άτομα που αναπτύσσουν ενεργά το FreeBSD, για να αναφέρουν προβλήματα ή να συζητήσουν εναλλακτικές λύσεις. Άτομα που ενδιαφέρονται να παρακολουθήσουν την τεχνική συζήτηση είναι ευπρόσδεκτα. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></dt><dd><p><em>Γενική συζήτηση για υλικό κι εξαρτήματα υπολογιστών στο FreeBSD</em></p><div class=paragraph><p>Γενικές συζητήσεις για τύπους υλικού που λειτουργούν στο FreeBSD, διάφορα προβλήματα και προτάσεις σχετικά με το τι να αγοράσετε ή να αποφύγετε.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></dt><dd><p><em>Mirror sites</em></p><div class=paragraph><p>Ανακοινώσεις και συζητήσεις για άτομα που συντηρούν mirror sites του FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></dt><dd><p><em>Θέματα για Παροχείς Υπηρεσιών Διαδικτύου</em></p><div class=paragraph><p>Αυτή η λίστα είναι για συζήτηση θεμάτων σχετικών με Παροχείς Υπηρεσιών Διαδικτύου (ISPs) που χρησιμοποιούν FreeBSD. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-mono>freebsd-mono</a></dt><dd><p><em>Εφαρμογές Mono και C# στο FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα είναι για συζήτηση θεμάτων σχετικών με το σύστημα ανάπτυξης εφαρμογών Mono στο FreeBSD. Πρόκειται για μια τεχνική λίστα. Προορίζεται για οποιονδήποτε ασχολείται ενεργά με την ανάπτυξη ή τη μεταφορά εφαρμογών Mono ή C# στο FreeBSD. Η συζήτηση αφορά την επίλυση προβλημάτων η την εύρεση εναλλακτικών λύσεων. Άτομα που ενδιαφέρονται να παρακολουθήσουν την τεχνική συζήτηση είναι επίσης ευπρόσδεκτα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-office>freebsd-office</a></dt><dd><p><em>Εφαρμογές γραφείου στο FreeBSD</em></p><div class=paragraph><p>Συζητήσεις σχετικές με την εγκατάσταση, ανάπτυξη και υποστήριξη εφαρμογών γραφείου στο FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></dt><dd><p><em>Συζητήσεις για την ρύθμιση και την βελτιστοποίηση του FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα υπάρχει για να παρέχει ένα μέρος όπου οι hackers, οι διαχειριστές, και όσοι άλλοι ενδιαφέρονται, να συζητούν θέματα σχετικά με την απόδοση του FreeBSD. Αποδεκτά θέματα είναι οι συζητήσεις που αναφέρονται σε εγκαταστάσεις FreeBSD που υπόκεινται σε μεγάλο φόρτο, έχουν προβλήματα απόδοσης, ή φτάνουν το FreeBSD στα όρια του. Συνιστούμε ανεπιφύλακτα να γραφούν στη λίστα όσοι ενδιαφέρονται να βελτιώσουν την απόδοση του FreeBSD. Είναι μία τεχνική λίστα που απευθύνεται σε έμπειρους χρήστες του FreeBSD, hackers, ή διαχειριστές που ενδιαφέρονται να κάνουν το FreeBSD γρήγορο και αξιόπιστο. Δεν πρόκειται για μια λίστα ερωτήσεων και απαντήσεων που μπορεί να αντικαταστήσει την μελέτη της τεκμηρίωσης, αλλά ένα μέρος για συνεισφορές ή για απαντήσεις σε αναπάντητα θέματα σχετικά με την απόδοση.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></dt><dd><p><em>Συζητήσεις και ερωτήσεις για το σύστημα packet filter firewall</em></p><div class=paragraph><p>Συζητήσεις σχετικές με το packet filter (pf) firewall system στο FreeBSD. Τεχνικές συζητήσεις και ερωτήσεις χρηστών είναι ευπρόσδεκτες. Η λίστα είναι επίσης ένα μέρος για συζήτηση του ALTQ QoS framework.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></dt><dd><p><em>Μεταφορά του FreeBSD σε μη-Intel® πλατφόρμες</em></p><div class=paragraph><p>Προβλήματα του FreeBSD που εμφανίζονται σε περισσότερες από μία πλατφόρμες, καθώς και γενικές συζητήσεις και προτάσεις για μεταφορά του FreeBSD σε μη-Intel® πλατφόρμες. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></dt><dd><p><em>Συζήτηση για τα "ports"</em></p><div class=paragraph><p>Συζητήσεις σχετικές με την "Συλλογή των Ports" του FreeBSD (<span class=filename>/usr/ports</span>), την υποδομή των ports, και γενικά τις προσπάθειες συντονισμού των ports. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-announce>freebsd-ports-announce</a></dt><dd><p><em>Σημαντικές ειδήσεις και οδηγίες σχετικές με την "Συλλογή των Ports" του FreeBSD.</em></p><div class=paragraph><p>Σημαντικές ειδήσεις σχετικές με την "Συλλογή των Ports" (<span class=filename>/usr/ports</span>) που απευθυνόνται σε όσους αναπτύσσουν ή μεταφέρουν λογισμικό στο FreeBSD αλλά και στους τελικούς χρήστες. Περιλαμβάνονται ειδήσεις σχετικές με αλλαγές στην αρχιτεκτονική και την υποδομή, νέες δυνατότητες αλλά και σημαντικές πληροφορίες αναβάθμισης και νέων εκδόσεων. Πρόκειται για λίστα με μικρή κίνηση που προορίζεται για ανακοινώσεις.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>freebsd-ports-bugs</a></dt><dd><p><em>Συζήτηση για τα σφάλματα των "ports"</em></p><div class=paragraph><p>Συζητήσεις που σχετίζονται με τις αναφορές προβλημάτων της "Συλλογής των Ports" (<span class=filename>/usr/ports</span>) του FreeBSD, προτάσεις για νέα ports ή για αλλαγές σε υπάρχοντα ports. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></dt><dd><p><em>Τεχνική συζήτηση για το FreeBSD σε διακομιστές HP ProLiant</em></p><div class=paragraph><p>Αυτή η λίστα είναι για τεχνικές συζητήσεις σχετικά με την χρήση του FreeBSD σε διακομιστές HP ProLiant. Η συζήτηση περιλαμβάνει θέματα προγραμμάτων οδήγησης για ProLiant, λογισμικό διαχείρισης, εργαλεία ρυθμίσεων, και ανανεώσεις του BIOS. Η λίστα αυτή είναι το καταλληλότερο μέρος για συζήτηση σχετικά με τα αρθρώματα hpasmd, hpasmcli, και hpacucli.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></dt><dd><p><em>Η Python στο FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα είναι για συζητήσεις σχετικές με την βελτιστοποίηση της υποστήριξης της Python στο FreeBSD. Είναι μια τεχνική λίστα. Προορίζεται για άτομα που ασχολούνται με την μεταφορά της Python, των αρθρωμάτων της (modules) και του Zope στο FreeBSD. Όσοι ενδιαφέρονται να παρακολουθήσουν την τεχνική συζήτηση, είναι ευπρόσδεκτοι.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></dt><dd><p><em>Ερωτήσεις χρηστών</em></p><div class=paragraph><p>Αυτή η λίστα είναι για ερωτήσεις σχετικές με το FreeBSD. Δεν πρέπει να στέλνετε ερωτήσεις τύπου "how to" σε τεχνικές λίστες εκτός αν πιστεύετε ότι η ερώτηση σας είναι πολύ εξειδικευμένη.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ruby>freebsd-ruby</a></dt><dd><p><em>Συζήτηση σχετικά με τη Ruby στο FreeBSD</em></p><div class=paragraph><p>Η λίστα αυτή είναι για συζητήσεις που σχετίζονται με την υποστήριξη της Ruby στο FreeBSD. Πρόκειται για μια λίστα τεχνικών ερωτήσεων. Απευθύνεται σε άτομα που δουλεύουν σε Ports της Ruby, σε βιβλιοθήκες τρίτων κατασκευαστών, και σε άλλα πλαίσια λειτουργιών.</p></div><div class=paragraph><p>Είναι επίσης ευπρόσδεκτοι όσοι ενδιαφέρονται για αυτού του είδους την τεχνική συζήτηση.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></dt><dd><p><em>Το υποσύστημα SCSI</em></p><div class=paragraph><p>Αυτή η λίστα είναι για άτομα που εργάζονται στο SCSI υποσύστημα του FreeBSD. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security>ηλεκτρονική λίστα του FreeBSD για θέματα ασφάλειας</a></dt><dd><p><em>Θέματα ασφαλείας</em></p><div class=paragraph><p>Αφορά θέματα ασφαλείας υπολογιστών που εκτελούν FreeBSD (DES, Kerberos, γνωστά θέματα ασφαλείας και διορθώσεις, κτλ). Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα. Σημειώστε ότι δεν πρόκειται για λίστα ερωτήσεων και απαντήσεων, αλλά η συνεισφορά (τόσο ερωτήσεων όσο ΚΑΙ απαντήσεων) στο FAQ είναι ευπρόσδεκτη.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>ηλεκτρονική λίστα Ανακοινώσεων για Θέματα Ασφάλειας του FreeBSD</a></dt><dd><p><em>Ειδοποιήσεις ασφαλείας</em></p><div class=paragraph><p>Ειδοποιήσεις για προβλήματα ασφαλείας και διορθώσεις στο FreeBSD. Δεν πρόκειται για λίστα συζητήσεων. Η λίστα συζητήσεων είναι η FreeBSD-security.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-small>freebsd-small</a></dt><dd><p><em>Χρήση του FreeBSD σε embedded εφαρμογές</em></p><div class=paragraph><p>Αυτή η λίστα συζητά θέματα σχετικά με ασυνήθιστα μικρές και embedded εγκαταστάσεις του FreeBSD. Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Η λίστα αυτή έχει αντικατασταθεί από την <a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a>.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>ηλεκτρονική λίστα του FreeBSD-STABLE;</a></dt><dd><p><em>Συζητήσεις σχετικές με την χρήση του FreeBSD-STABLE</em></p><div class=paragraph><p>Αυτή η λίστα είναι για τους χρήστες του FreeBSD-STABLE. Περιέχει προειδοποιήσεις για νέα χαρακτηριστικά που πρόκειται να ενσωματωθούν στο -STABLE και τα οποία ενδεχομένως να επηρεάσουν τους χρήστες του. Επίσης περιέχει οδηγίες για τα βήματα που πρέπει να ακολουθήσετε ώστε να παραμείνετε στο -STABLE. Θα πρέπει να εγγραφείτε σε αυτή τη λίστα, αν ακολουθείτε το "STABLE". Είναι μια τεχνική λίστα και συζητούνται μόνο αυστηρά τεχνικά θέματα.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></dt><dd><p><em>Συμμόρφωση με τα πρότυπα C99 POSIX</em></p><div class=paragraph><p>Αυτή η λίστα είναι για τεχνικές συζητήσεις σχετικά με την συμμόρφωση του FreeBSD με τα πρότυπα C99 και POSIX.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-toolchain>freebsd-toolchain</a></dt><dd><p><em>Συντήρηση των ενσωματωμένων εργαλείων του FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα είναι για συζητήσεις που σχετίζονται με την σειρά εργαλείων (toolchain) που έρχονται με το FreeBSD. Η συζήτηση μπορεί να περιλαμβάνει θέματα σχετικά με την κατάσταση του Clang και του GCC, αλλά και θέματα σχετικά με προγράμματα όπως μεταγλωττιστές, assemblers, linkers και debuggers.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></dt><dd><p><em>Συζήτηση για την υποστήριξη του διαύλου USB στο FreeBSD</em></p><div class=paragraph><p>Αυτή η λίστα είναι για τεχνικές συζητήσεις σχετικά με την υποστήριξη του διαύλου USB στο FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></dt><dd><p><em>Οργάνωση των συλλόγων χρηστών</em></p><div class=paragraph><p>Αυτή η λίστα είναι για τους συντονιστές των επιμέρους τοπικών συλλόγων χρηστών για συζήτηση θεμάτων μεταξύ τους και με κάποιο μέλος της ομάδας Core. Αυτή η λίστα θα πρέπει να αναφέρει μόνο τις συναντήσεις και την οργάνωση projects που αναφέρονται σε περισσότερους από ένα συλλόγους χρηστών.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-vendors>freebsd-vendors</a></dt><dd><p><em>Πωλητές</em></p><div class=paragraph><p>Οργάνωση συζητήσεων μεταξύ του FreeBSD Project και των πωλητών λογισμικού και υλικού σχετικού με το FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-virtualization>freebsd-virtualization</a></dt><dd><p><em>Συζήτηση διάφορων τεχνικών εικονικοποίησης που υποστηρίζονται από το FreeBSD.</em></p><div class=paragraph><p>Μια λίστα για τη συζήτηση των διάφορων τεχνικών εικονικοποίησης που υποστηρίζονται από το FreeBSD. Από τη μια μεριά εστιάζει στην υλοποίηση των βασικών λειτουργιών αλλά και την προσθήκη νέων δυνατοτήτων. Από την άλλη, οι χρήστες θα έχουν μια ομάδα συζητήσεων όπου μπορούν να ζητούν βοήθεια σε περίπτωση προβλημάτων, ή να συζητούν τις δικές τους χρήσεις.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-wip-status>freebsd-wip-status</a></dt><dd><p><em>Κατάσταση εργασιών σε εξέλιξη στο FreeBSD</em></p><div class=paragraph><p>Στη λίστα αυτή μπορείτε να ανακοινώσετε την έναρξη και την πρόοδο κάποιας εργασίας σας που σχετίζεται με το FreeBSD. Τα μηνύματα σε αυτή τη λίστα ελέγχονται. Συνίσταται να στείλετε το μήνυμα σας με παραλήπτη μια πιο τοπική σας λίστα του FreeBSD, και απλώς να κοινοποιήσετε το μήνυμα σας σε αυτή τη λίστα. Με τον τρόπο αυτό, μπορείτε επίσης να συζητήσετε για την εργασία σας στην τοπική λίστα, καθώς η συζήτηση σε αυτή τη λίστα δεν επιτρέπεται.</p></div><div class=paragraph><p>Δείτε τα αρχεία της λίστας για να πάρετε μια ιδέα της μορφής των μηνυμάτων που μπορείτε να στείλετε.</p></div><div class=paragraph><p>Μια περίληψη των περιεχομένων της λίστας ενδέχεται να δημοσιεύεται κατά τακτά διαστήματα στη δικτυακή τοποθεσία του FreeBSD, ως μέρος των Αναφορών Κατάστασης (Status Reports) . Στην ίδια τοποθεσία, μπορείτε επίσης να βρείτε περισσότερα παραδείγματα και προηγούμενες αναφορές.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-wireless>freebsd-wireless</a></dt><dd><p><em>Συζήτηση σχετικά με τη στοίβα 802.11, τα εργαλεία ασύρματου δικτύου και την ανάπτυξη προγραμμάτων οδήγησης</em></p><div class=paragraph><p>H λίστα αυτή εστιάζει στη στοίβα δικτύου 802.11 (sys/net80211), την ανάπτυξη προγραμμάτων οδήγησης και εργαλείων. Περιλαμβάνει αναφορές προβλημάτων, νέα χαρακτηριστικά και πληροφορίες συντήρησης.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-xen>freebsd-xen</a></dt><dd><p><em>Συζήτηση για τη μεταφορά του FreeBSD στο Xen™ - υλοποίηση και χρήση</em></p><div class=paragraph><p>Πρόκειται για μια λίστα που εστιάζει στην μεταφορά του FreeBSD στο Xen™. Η κίνηση σε αυτή τη λίστα αναμένεται να είναι μικρή, και έτσι θα χρησιμοποιηθεί τόσο για τεχνικές συζητήσεις σχετικά με το σχεδιασμό και την υλοποίηση, όσο και με προβλήματα εγκατάστασης και διαχείρισης.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-xfce>freebsd-xfce</a></dt><dd><p><em>XFCE</em></p><div class=paragraph><p>Συζήτηση για τη μεταφορά του XFCE στο FreeBSD. Πρόκειται για μια λίστα τεχνικών συζητήσεων. Προορίζεται για όσους ασχολούνται ενεργά με τη μεταφορά του XFCE στο FreeBSD ώστε να συζητούν προβλήματα και εναλλακτικές λύσεις. Η λίστα είναι επίσης ανοικτή σε όσους ενδιαφέρονται για τεχνική συζήτηση αυτού του είδους.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-zope>freebsd-zope</a></dt><dd><p><em>Zope</em></p><div class=paragraph><p>Μια λίστα συζητήσεων σχετικών με τη μεταφορά του περιβάλλοντος Zope στο FreeBSD. Πρόκειται για λίστα τεχνικών συζητήσεων. Απευθύνεται κυρίως σε άτομα που συμμετέχουν ενεργά στη μεταφορά του Zope στο FreeBSD και συζητούνται προβλήματα και εναλλακτικές λύσεις. Η λίστα είναι επίσης ανοικτή σε όσους ενδιαφέρονται για τεχνική συζήτηση αυτού του είδους.</p></div></dd></dl></div></div><div class=sect3><h4 id=eresources-mailfiltering>C.1.4. Φιλτράρισμα στις Λίστες Ηλεκτρονικού Ταχυδρομείου<a class=anchor href=#eresources-mailfiltering></a></h4><div class=paragraph><p>Οι λίστες ηλεκτρονικού ταχυδρομείου του FreeBSD φιλτράρονται με πολλαπλούς τρόπους για να αποφύγουμε την διανομή spam, ιών, και άλλων ανεπιθύμητων μηνυμάτων. Το φιλτράρισμα που περιγράφεται σε αυτή την ενότητα, αποτελεί ένα μόνο μέρος των συνολικών μέτρων που λαμβάνουμε για την προστασία των λιστών ηλεκτρονικού ταχυδρομείου.</p></div><div class=paragraph><p>Στις λίστες επιτρέπονται μόνο συγκεκριμένοι τύποι συνημμένων αρχείων. Όλα τα συνημμένα αρχεία με τύπο MIME που δεν βρίσκεται στην παρακάτω λίστα, διαγράφονται πριν διανεμηθεί το μήνυμα στις λίστες.</p></div><div class=ulist><ul><li><p>application/octet-stream</p></li><li><p>application/pdf</p></li><li><p>application/pgp-signature</p></li><li><p>application/x-pkcs7-signature</p></li><li><p>message/rfc822</p></li><li><p>multipart/alternative</p></li><li><p>multipart/related</p></li><li><p>multipart/signed</p></li><li><p>text/html</p></li><li><p>text/plain</p></li><li><p>text/x-diff</p></li><li><p>text/x-patch</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Μερικές λίστες μπορεί να επιτρέπουν συνημμένα αρχεία και άλλων τύπων MIME, αλλά οι παραπάνω τύποι ισχύουν στις περισσότερες λίστες.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Εάν το κείμενο ενός μηνύματος περιέχεται τόσο σε μορφή HTML όσο και απλού κειμένου, το τμήμα HTML θα αφαιρεθεί. Εάν ένα μήνυμα περιέχει μόνο HTML, θα μετατραπεί σε απλό κείμενο.</p></div></div></div><div class=sect2><h3 id=eresources-news>C.2. Usenet Newsgroups<a class=anchor href=#eresources-news></a></h3><div class=paragraph><p>Εκτός από δύο newsgroups που ασχολούνται με το FreeBSD, υπάρχουν πολλά ακόμα στα οποία γίνεται συζήτηση για το FreeBSD ή άλλα θέματα που ενδεχομένως ενδιαφέρουν τους χρήστες του.</p></div><div class=sect3><h4 id=_newsgroups_σχετικά_με_το_bsd>C.2.1. Newsgroups Σχετικά με το BSD<a class=anchor href=#_newsgroups_σχετικά_με_το_bsd></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a></p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li><li><p><a href=news:de.comp.os.unix.bsd>de.comp.os.unix.bsd</a> (Στα Γερμανικά)</p></li><li><p><a href=news:fr.comp.os.bsd>fr.comp.os.bsd</a> (Στα Γαλλικά)</p></li><li><p><a href=news:it.comp.os.freebsd>it.comp.os.freebsd</a> (Στα Ιταλικά)</p></li><li><p><a href=news:tw.bbs.comp.386bsd>tw.bbs.comp.386bsd</a> (Σε Παραδοσιακά Κινέζικα)</p></li></ul></div></div><div class=sect3><h4 id=_άλλα_ενδιαφέροντα_unix_newsgroups>C.2.2. Άλλα Ενδιαφέροντα UNIX® Newsgroups<a class=anchor href=#_άλλα_ενδιαφέροντα_unix_newsgroups></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix>comp.unix</a></p></li><li><p><a href=news:comp.unix.questions>comp.unix.questions</a></p></li><li><p><a href=news:comp.unix.admin>comp.unix.admin</a></p></li><li><p><a href=news:comp.unix.programmer>comp.unix.programmer</a></p></li><li><p><a href=news:comp.unix.shell>comp.unix.shell</a></p></li><li><p><a href=news:comp.unix.user-friendly>comp.unix.user-friendly</a></p></li><li><p><a href=news:comp.security.unix>comp.security.unix</a></p></li><li><p><a href=news:comp.sources.unix>comp.sources.unix</a></p></li><li><p><a href=news:comp.unix.advocacy>comp.unix.advocacy</a></p></li><li><p><a href=news:comp.unix.misc>comp.unix.misc</a></p></li><li><p><a href=news:comp.bugs.4bsd>comp.bugs.4bsd</a></p></li><li><p><a href=news:comp.bugs.4bsd.ucb-fixes>comp.bugs.4bsd.ucb-fixes</a></p></li><li><p><a href=news:comp.unix.bsd>comp.unix.bsd</a></p></li></ul></div></div><div class=sect3><h4 id=_σύστημα_x_window>C.2.3. Σύστημα X Window<a class=anchor href=#_σύστημα_x_window></a></h4><div class=ulist><ul><li><p><a href=news:comp.windows.x.i386unix>comp.windows.x.i386unix</a></p></li><li><p><a href=news:comp.windows.x>comp.windows.x</a></p></li><li><p><a href=news:comp.windows.x.apps>comp.windows.x.apps</a></p></li><li><p><a href=news:comp.windows.x.announce>comp.windows.x.announce</a></p></li><li><p><a href=news:comp.windows.x.intrinsics>comp.windows.x.intrinsics</a></p></li><li><p><a href=news:comp.windows.x.motif>comp.windows.x.motif</a></p></li><li><p><a href=news:comp.windows.x.pex>comp.windows.x.pex</a></p></li><li><p><a href=news:comp.emulators.ms-windows.wine>comp.emulators.ms-windows.wine</a></p></li></ul></div></div></div><div class=sect2><h3 id=eresources-web>C.3. Διακομιστές Ιστοσελίδων<a class=anchor href=#eresources-web></a></h3><div class=paragraph><p><a href=#central-mirrors>Central Servers</a>, <a href=#armenia-mirrors>Armenia</a>, <a href=#australia-mirrors>Australia</a>, <a href=#austria-mirrors>Austria</a>, <a href=#czech-republic-mirrors>Czech Republic</a>, <a href=#denmark-mirrors>Denmark</a>, <a href=#finland-mirrors>Finland</a>, <a href=#france-mirrors>France</a>, <a href=#germany-mirrors>Germany</a>, <a href=#hong-kong-mirrors>Hong Kong</a>, <a href=#ireland-mirrors>Ireland</a>, <a href=#japan-mirrors>Japan</a>, <a href=#latvia-mirrors>Latvia</a>, <a href=#lithuania-mirrors>Lithuania</a>, <a href=#netherlands-mirrors>Netherlands</a>, <a href=#norway-mirrors>Norway</a>, <a href=#russia-mirrors>Russia</a>, <a href=#slovenia-mirrors>Slovenia</a>, <a href=#south-africa-mirrors>South Africa</a>, <a href=#spain-mirrors>Spain</a>, <a href=#sweden-mirrors>Sweden</a>, <a href=#switzerland-mirrors>Switzerland</a>, <a href=#taiwan-mirrors>Taiwan</a>, <a href=#uk-mirrors>United Kingdom</a>, <a href=#usa-mirrors>United States of America</a>.</p></div><div class=paragraph><p>(as of UTC)</p></div><div id=central-mirrors class=paragraph><p><strong>Central Servers</strong></p></div><div class=ulist><ul><li><p><a href=https://www.FreeBSD.org/ class=bare>https://www.FreeBSD.org/</a></p></li></ul></div><div id=armenia-mirrors class=paragraph><p><strong>Armenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=australia-mirrors class=paragraph><p><strong>Australia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.au.FreeBSD.org/ class=bare>http://www.au.FreeBSD.org/</a></p></li><li><p><a href=http://www2.au.FreeBSD.org/ class=bare>http://www2.au.FreeBSD.org/</a></p></li></ul></div><div id=austria-mirrors class=paragraph><p><strong>Austria</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=czech-republic-mirrors class=paragraph><p><strong>Czech Republic</strong></p></div><div class=ulist><ul><li><p><a href=http://www.cz.FreeBSD.org/ class=bare>http://www.cz.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=denmark-mirrors class=paragraph><p><strong>Denmark</strong></p></div><div class=ulist><ul><li><p><a href=http://www.dk.FreeBSD.org/ class=bare>http://www.dk.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=finland-mirrors class=paragraph><p><strong>Finland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.fi.FreeBSD.org/ class=bare>http://www.fi.FreeBSD.org/</a></p></li></ul></div><div id=france-mirrors class=paragraph><p><strong>France</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.fr.FreeBSD.org/ class=bare>http://www1.fr.FreeBSD.org/</a></p></li></ul></div><div id=germany-mirrors class=paragraph><p><strong>Germany</strong></p></div><div class=ulist><ul><li><p><a href=http://www.de.FreeBSD.org/ class=bare>http://www.de.FreeBSD.org/</a></p></li></ul></div><div id=hong-kong-mirrors class=paragraph><p><strong>Hong Kong</strong></p></div><div class=ulist><ul><li><p><a href=http://www.hk.FreeBSD.org/ class=bare>http://www.hk.FreeBSD.org/</a></p></li></ul></div><div id=ireland-mirrors class=paragraph><p><strong>Ireland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ie.FreeBSD.org/ class=bare>http://www.ie.FreeBSD.org/</a></p></li></ul></div><div id=japan-mirrors class=paragraph><p><strong>Japan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/www.FreeBSD.org/ class=bare>http://www.jp.FreeBSD.org/www.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=latvia-mirrors class=paragraph><p><strong>Latvia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lv.FreeBSD.org/ class=bare>http://www.lv.FreeBSD.org/</a></p></li></ul></div><div id=lithuania-mirrors class=paragraph><p><strong>Lithuania</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lt.FreeBSD.org/ class=bare>http://www.lt.FreeBSD.org/</a></p></li></ul></div><div id=netherlands-mirrors class=paragraph><p><strong>Netherlands</strong></p></div><div class=ulist><ul><li><p><a href=http://www.nl.FreeBSD.org/ class=bare>http://www.nl.FreeBSD.org/</a></p></li></ul></div><div id=norway-mirrors class=paragraph><p><strong>Norway</strong></p></div><div class=ulist><ul><li><p><a href=http://www.no.FreeBSD.org/ class=bare>http://www.no.FreeBSD.org/</a></p></li></ul></div><div id=russia-mirrors class=paragraph><p><strong>Russia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ru.FreeBSD.org/ class=bare>http://www.ru.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=slovenia-mirrors class=paragraph><p><strong>Slovenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.si.FreeBSD.org/ class=bare>http://www.si.FreeBSD.org/</a></p></li></ul></div><div id=south-africa-mirrors class=paragraph><p><strong>South Africa</strong></p></div><div class=ulist><ul><li><p><a href=http://www.za.FreeBSD.org/ class=bare>http://www.za.FreeBSD.org/</a></p></li></ul></div><div id=spain-mirrors class=paragraph><p><strong>Spain</strong></p></div><div class=ulist><ul><li><p><a href=http://www.es.FreeBSD.org/ class=bare>http://www.es.FreeBSD.org/</a></p></li><li><p><a href=http://www2.es.FreeBSD.org/ class=bare>http://www2.es.FreeBSD.org/</a></p></li></ul></div><div id=sweden-mirrors class=paragraph><p><strong>Sweden</strong></p></div><div class=ulist><ul><li><p><a href=http://www.se.FreeBSD.org/ class=bare>http://www.se.FreeBSD.org/</a></p></li></ul></div><div id=switzerland-mirrors class=paragraph><p><strong>Switzerland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ch.FreeBSD.org/ class=bare>http://www.ch.FreeBSD.org/</a> (IPv6)</p></li><li><p><a href=http://www2.ch.FreeBSD.org/ class=bare>http://www2.ch.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=taiwan-mirrors class=paragraph><p><strong>Taiwan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.tw.FreeBSD.org/ class=bare>http://www.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www2.tw.FreeBSD.org/ class=bare>http://www2.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www4.tw.FreeBSD.org/ class=bare>http://www4.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www5.tw.FreeBSD.org/ class=bare>http://www5.tw.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=uk-mirrors class=paragraph><p><strong>United Kingdom</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.uk.FreeBSD.org class=bare>http://www1.uk.FreeBSD.org</a></p></li><li><p><a href=http://www3.uk.FreeBSD.org/ class=bare>http://www3.uk.FreeBSD.org/</a></p></li></ul></div><div id=usa-mirrors class=paragraph><p><strong>United States of America</strong></p></div><div class=ulist><ul><li><p><a href=http://www5.us.FreeBSD.org/ class=bare>http://www5.us.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div class=sect3><h4 id=eresources-web-social>C.3.1. Forums, Blogs, και Κοινωνικά Δίκτυα<a class=anchor href=#eresources-web-social></a></h4><div class=ulist><ul><li><p><a href=http://forums.freebsd.org/>Τα Forums του FreeBSD</a> βασίζονται σε διεπαφή web και είναι κατάλληλα για τεχνικές συζητήσεις και ερωτήσεις που αφορούν το FreeBSD.</p></li><li><p><a href=http://planet.freebsdish.org/>Το Planet FreeBSD</a> συγκεντρώνει σε ένα σημείο τις ροές από δεκάδες ιστολόγια μελών της ομάδας ανάπτυξης του FreeBSD. Πολλά από τα μέλη, χρησιμοποιούν αυτή τη δυνατότητα για να γνωστοποιήσουν την εργασία που κάνουν τη δεδομένη στιγμή, τυχόν νέες διορθώσεις, καθώς και τα μελλοντικά τους σχέδια.</p></li><li><p><a href=http://www.youtube.com/bsdconferences>Το κανάλι BSDConferences στο Youtube</a> παρέχει μια συλλογή βίντεο υψηλής ποιότητας, από διάφορα BSD συνέδρια σε όλο τον κόσμο. Πρόκειται για ένα θαυμάσιο τρόπο να παρακολουθήσετε σημαντικά μέλη της ομάδας ανάπτυξης να παρουσιάζουν τη νέα τους δουλειά στο FreeBSD.</p></li></ul></div></div><div class=sect3><h4 id=eresources-web-mirrors>C.3.2. Επίσημα Mirrors<a class=anchor href=#eresources-web-mirrors></a></h4></div></div><div class=sect2><h3 id=eresources-email>C.4. Διευθύνσεις Ηλεκτρονικού Ταχυδρομείου<a class=anchor href=#eresources-email></a></h3><div class=paragraph><p>Οι ακόλουθες ενώσεις χρηστών παρέχουν στα μέλη τους διευθύνσεις ηλεκτρονικού ταχυδρομείου που σχετίζονται με το FreeBSD. Ο διαχειριστής που αναφέρεται παρακάτω, διατηρεί το δικαίωμα να ανακαλέσει την διεύθυνση, αν γίνει κατάχρηση της με οποιοδήποτε τρόπο.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Τομέας</th><th class="tableblock halign-left valign-top">Υπηρεσίες</th><th class="tableblock halign-left valign-top">Ένωση Χρηστών</th><th class="tableblock halign-left valign-top">Διαχειριστής</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ukug.uk.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Μόνο προώθηση</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=mailto:ukfreebsd@uk.FreeBSD.org>ukfreebsd@uk.FreeBSD.org</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lee Johnston <a href=mailto:lee@uk.FreeBSD.org>lee@uk.FreeBSD.org</a></p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=pgpkeys>Appendix D: Κλειδιά PGP<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p>Στο παράρτημα αυτό, θα βρείτε τα δημόσια PGP κλειδιά των officers και των μελών της ομάδας ανάπτυξης του FreeBSD. Μπορείτε να τα χρησιμοποιήσετε για να ελέγξετε μια ψηφιακή υπογραφή ή για να στείλετε κρυπτογραφημένο email σε κάποιο μέλος της ομάδας. Μπορείτε να κατεβάσετε την πλήρη λίστα από κλειδιά χρηστών του <code>FreeBSD.org</code>, από την τοποθεσία <a href=https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt>pgpkeyring.txt</a>.</p></div><div class=sect2><h3 id=pgpkeys-officers>D.1. Officers<a class=anchor href=#pgpkeys-officers></a></h3><div class=sect3><h4 id=_ομάδα_ασφάλειας_security_officerfreebsd_org>D.1.1. Ομάδα Ασφάλειας <code>&lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code><a class=anchor href=#_ομάδα_ασφάλειας_security_officerfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2025-01-15]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2025-01-15]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31IkEcgQYAQoAJgIbAhYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJlhctvBQkD8n2mAkDBdCAEGQEKAB0WIQS2FSd+
gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBuWN6QHwAa77gbEADpUBT14cesITuM
sOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMPXih9G1tDo9ExIWT8jNjSSA+w0Viu
a/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJWy944YegHF/5ytntwZ/L4BMYc3Mzt
yZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37bbUVw62xHQIn2zafSmMQ4oMXZTm9
EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1G9jqkwlaRYWjcLD0qxwc5m9LNrF6
OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDClTTH+dAx3b6J1KFB0UiHP3FeTalF
h8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2RAo/o2X5r40qk/lhydQRZTSTFsiu
H3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7re0jj8XMIO7G5yjQKQCnYuPdXbx++
bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17MEPIton1+NRfsU0peEVggQXlwdTc
ZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpKa9qfIqBX/monjy7w5IHmhvLwAYI6
IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69PxMbOJbMpWSg8L7xW3LXKR1VwXgg
UC1+b3y67E5Ggi1hf0lfTnTMpL2ClAkQ2a0qGAV0dMsjqhAAorQ725G342raJ+os
6+E/EFNsr4SR5H+AeinlQ2ymNSeO/ODsV6dmyYD3hed0mAXvIJt2B46fFC4eAP9f
VOIbMMhPMpnJuZyLPDi8gXcZLgWSRhJ88R98KIsmKlh+/fdZM4RI1JLjICi7kyNR
4jtKCzLj0DYVBzp1mn0lTwtFzv7SC9djpqFLnO5YoGPWfQHHhY02Trh2posRwAHO
oacXSFvsoQv6k6XNlStJ4lnrkH6t+Od4kU3/TJ0eQXs7Zd2WEVnMe1IhbihsGcAY
mzZzZlLOhskHCeVE2taHiXC6h4tC3/69I16N8ICauxGY41clPhiNmVaAzmkunOPz
ry5utl6HkpZ5/3UMVHI1JIvsfJW+vSMUhdcQILAv6DbRWWHeax3ZZ6iAVGCtJS7U
glwZM1Xor0okGtIS+aJ/Cw7tZ8Nm18lutcrf2MVW+BWpzMQKnWFQYTn1NEWjzYnx
9Na22+E8AvW02TdS0NSiP0sG/0q7lBNEck9vH4WEbbEXktj51Dg4ISUhQyW8BWwW
X+kSiNeqtcaikUb8SFj5vpTDotTSzikfT/jisvR5goTMNFCVHFZdXCdsbUZd8Iub
egAOh6Db/06y3mFYDEfcGJipab400OY03a2xw9Vz+YxrKfELCTBo2tZv+3K8kXgq
XFcbyJnkXmjnYM/sw5kKqtzuc7i5Ag0EY5V3BwEQAMpFVczZo9ZPNsgW791UW5o6
wnrnd1nIO+S4rc37q2TEz8KGHCuxo5NwffZ2t6Ln04BI54pbapg17b7a0hPka37H
FkL28n4VyMdx0CsAm3QEfUsdK6xwKV2SucYeVcrV1upcN4PdXD7su1I7/A4CWXFJ
G047zJ0Z89lJZiQEiAq7ghvEoinC0sm+0a6ao/ocqCgWCKM1yCPOyzJXleRrv29S
RnYziMR+q2U0x9xg9Xl6GMwUmFwbJc9nORVvLH7fbU6/du8EgoAYrglFOFZG/TSo
lSGWRSMiavz0JSD/i+rEN4aIT4WfBe+L9Wy1AmrNxiAO+zKmzHQu3JSxDncr+y+h
cd+W0gqw10FoI9jWLcL7kR+6a0iOjuJSXSopq2l3DafiPxtCFmr4CGQhzBHM6e4/
v/NNd3F0XpVbJ6RQph7lkfvfz8q2lvUlHhezJ0p1xXmhff9CHjdVMhmAmz5+imBA
Xk2mottNfKb0pFEen1xY3K/UPA4g+oPsSj495MsvIg9eIMCcC3/z0SEUMWH/styy
JzPqfpyfGwZeTcIj9vg2o+RnGvmcLVYA/EGToPk905kv/cK73oy8bZyOB0zMg7T9
PaWgLUO0sqjqo0Mw3knFySg3oRXlcilPQvfPdX0JvwLpc9DWlr1+1GkCXJ08lWug
Jc96CJQupKRb1IbC0oUXABEBAAGJAjwEGAEKACYWIQQL4zJ110yVPHn4EQfZrSoY
BXR0ywUCY5V3BwIbDAUJAgIpAAAKCRDZrSoYBXR0ywwtD/wIDmEcHdFlyFRTomUB
jbeK2uzcZIhkkgL58lc63UPle5iJ2FBvmYS+0rQS53sVEsccn5KfkOwTryKllvWb
l0IzuiqfawxALcfWpfZJHzTMSnDHfgXvOOyFMQruqRDAHAr7PNC0CnbT0sEF2ZFz
ad8M9fLqtkXUx4mgECNGJ4CVqg75KY8uUzv/BmRwEf587FT5/iAIed5MjFB2VFDX
9GABcvTTbHxCZIxnxl3cs15SxT0lAofZ2ueU6kWYWZSXFeaEM/4ymPJws2mmV0Ak
bJghLXCn9Mx3nX6NTZZ9Harbru+RzW3/Hg3DZd0J9vko8PafP0l1NWtgyX74CqvT
gjzTxXTnqrRXzcczK7fhcC2u4i0prPtXXcyyi7SwpoLikaZCLFFhUmOx+mS5Tjtg
FyFZBNxnO7iAwkzfcTcC9sPoWaFmiQf6q5EIYzG+WQpncj80mxl3HWOP6oFj/hZJ
RYseKeMkvJzLTo87rFdM6CsMrLwETR6e+aWM0btPFil1rXVACNOjsy0bxTV8OJEf
yxnYmyjvnBvB0kdiaVEDdVhxgSqzLAX4mgXa49/V6M/uzMr+n3/A1Jdk4V6fVm8S
5cFIXxoUat3cB4xGaT9OWD3o1NPr6eS9Vo0EsJlRl81SG68fS+Qtk2fX27T68YG4
Aa3zMfZxUsVuFLtTuQbRC+fJpIkCPAQYAQoAJgIbDBYhBAvjMnXXTJU8efgRB9mt
KhgFdHTLBQJlhcuqBQkD8n1oAAoJENmtKhgFdHTLoO0QAJsTE9fkleb7YzPEuP9G
J3jx8PGdWm7n+8UNdr24kS6gOXVUfPZrWa5So21hcIwZb4PZDqHSVSQnRciKhSnG
7gplYPNGZ4+FWbLr/mBRYarjkVFLUuCPexSIjxV1KSGJnWs9YTVAKZAz75GpCML6
jD6biCOQCQ86wqOdWvZIZR8YvurrxR64ABB0rjbsaG8cNOUX1cwAfdLwthf64dS+
2m3lqNGDHkP5eNL0RIxC5gXYEp0lvmlMH3ZuO5WrfH73PTDg89bxXeuhrFmSEwf4
xWm603oi8/2qQvR9/7jb0o+t71NQuWrWIFONZWWgZBUGso+uyT3XgY4YqKGR3z2Q
zKHYnJ6M7SvSYpqS7RtcxcCXF0HGNfES8cAgtKVpFtbtSwXXp8O8oLyjmVIO/NjU
pbLOGdFIsarsezLFV9f2fqZ63J34hyUSg8LrYVV1fA5DJUpebbX4hLpdk0MMtgG4
3BwKIGlJTpL5RkQ/uQU3YW2kairy7o+1imDD0TRzQxtdjVOI5vnlTNcfJZIIfLx4
drABA12OvpX3dfPV62R+8BAlJFT430CG6AISJIBqJRFvuikmnZGUvEHmOUs/FLbb
aXTPkKc7tR2WIwljRvMV+Qk84cWcX6YchMslMuiDM1mtlQZig34WHGSE+zCWnXAs
lIHlSwox7qfdO0Kz2XncSbIA
=QvUh
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_γραμματέας_της_ομάδας_core_core_secretaryfreebsd_org>D.1.2. Γραμματέας της Ομάδας Core <code>&lt;<a href=mailto:core-secretary@FreeBSD.org>core-secretary@FreeBSD.org</a>></code><a class=anchor href=#_γραμματέας_της_ομάδας_core_core_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/4D632518C3546B05 2024-02-17 [SC] [expires: 2025-02-16]
      Key fingerprint = 1A23 6A92 528D 00DD 7965  76FE 4D63 2518 C354 6B05
uid                            FreeBSD Core Team Secretary &lt;core-secretary@FreeBSD.org&gt;
sub   rsa4096/CABFDE12CA516ED2 2024-02-17 [E] [expires: 2025-02-16]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGXQ1o8BEAC+Rcg8cmVxuP17Vu+q5KgCx/XiulQuqKXAqqBlYCH2jqk6DINP
yFrREGBhzd/qNmlAYEahQ4Zgl0bUZNTrZVDyzicOvPP0jH+KSTQwRs7NOawEdlVO
cyHrwDCPEqf5ZzD4NhfTriEOw+j0pEH/onitUGvoQRtx15xWyaJQxDEBMTYMLewE
86D1bltwnTNczE3UZb7oQLJXkAX5hcLtou70XJGgZITvJkK+kp/xot2eFjnqRz/u
WeXnKhYAmC07EKwZ1uw047eHKwMMRBYqzApLwoQtfE430Kxf2q8de64x8zDbi6YM
1J4r8OAxOtHVyfJ0j7Q23DEZz0VVb4b1Tx5OG2Re/KSNvqI0awJO4TcRmOR88OyY
dzyXgnX6Sa7GVQY1FXvn7vtFuDAt7egZOzeomSHL9bdX07LTQ4UtM88EV9wm3q4q
smoatV9jsvPQ1zxCU3aQD/5eWTJH2/kz1LIuBL/Qi5XQpJn91lBtUWJrCgkHWPGu
f//rnnXmsG7DAChW+yZ7cFO8lfNa8sFhPqSxCYphWmJTrvadyQtDngB8JakWdnmK
pfGS6y5lel+181vw38ZZKt04AKM+nDY8051lBM7Q9Q6kTLI33UZeImndx5xYukVD
kV6aQ31HYfEark15c7iEz+OAcwFnM2ntXMt7kKGd40CqzusiPcQkPqPbAQARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QEZy
ZWVCU0Qub3JnPokCVwQTAQoAQRYhBBojapJSjQDdeWV2/k1jJRjDVGsFBQJl0NaP
AhsDBQkB4TOACAsJDQgMBwsDBRUKCQgLBRYDAgEAAh4FAheAAAoJEE1jJRjDVGsF
nacP/3PSg8JPmWoBfWrgT287NZ7OAU16/uGpDxlBUoVeEtkEDqZVW8yBFzrMhbwj
bJs3CZ+L85HMUDLZoxSwVnPM8PLVRzHTybYV7agYYzMox5C/jp2aeAgy9KYVd0Tk
07GMTYrSh4fhHWpxXz7IBOxk0RXvQxTHlg1u0DASkibYb2UTDcUNG5Q9kP/8jaIZ
kVDX8a5LDdOCgWaYdKPg4blv/UMjkegJz+Ayp7gXTcux6koW5F6ysSw9sgLBWb2D
b/KNIi4MBMe46xyXB/dqGAR4ibrUXTcQ4OAZNq1L6uWG1A49XuSgykdIwr00MzQw
wfVpKT31ww4ayVHLgj7NuqPlab9S5/fPfJ4MAvGE4GqWQFgsPKgKImUMgnnxTGpv
l7Dqk2MnWqn+wEi0bRES0PVBG96G+sZJQeaxBhoB+HwUSFqoZQg166AJIl//4t2w
bx0a1aWQSS0DZt3wsQW3NW9AE6L+FnFfIc2pQVoLjmvcGalDuvnemRmEOgotiZmt
32bi2aWxg0/Qio2rjLS2LpV+fhwDSN3Agvtnu53yUdD1TFFjTSMloM4SKhiXoPbI
XgfCLiBLNMsZL0AvO7wQfSePzPYxDLyEcwsfPJ8be+eGG1L62RUyad+MdfyXMH/S
m0sgqW/MW6Nv10RyPQOq3Jbgmp2laRMzKTOvQt5WwQf2FEl9uQINBGXQ1o8BEAC9
1cBYn6Z0QmM0OFWdXQI6fMOeNokaa6ngPgt7bzW5NjryqTdwyHOPZdm4DWf1SO/0
+fJRCqxbICyuMAFrb9fDle8bodALjm5ZquTL3D61HpZD4+RwOzOjYP6wLm7h38HT
/yIyK882Ovlw4Xz/TeSiL/VUSWE9twW7yz3oreCeLUBAfzacS9y+syO+aquEd0/x
JBz+mPQbrqfS64rCZXMZEivgsjkQoE6RM+n1rF4kw4Eu3E2kPevVwsoAaY+MEUM8
JAXaJMaNcLIhbeMy7dO/z6z2I3h5bUw5KxfVwzYSzSeRpYh53dNaB4NY+f5/vTrL
4dZmqBcLgcV0zZ02dj/u0SiwWlUFUpFGuSiW16DN7+2zG1zOWi7Nl44JawM62Tlf
mO8zruVGEHaV3e8fFwBLRKM0Sc7e3aLECISsfYeC5ZbRRbpQ1KX+VQr3FBKAMzG4
l9Go7vZ+UcLKpQx2rVPTJt1vDnRV49X6CF2Q/lV9iafQ4MTy6ACdAloT1yfH/lhU
iWQo1qDyRCSlmNBDsYl8gLrwMp4gGQAv3imZHxnJF5ru3nUYGG0U08D5mf2sWv5P
Wh7By8Jm8bmaP8cUF86lO9BJXh2d9QN5jqrAtXqYzenZ+ABSoL1XrD/yv3270rH7
H4gAUtgP+vJ3uMyRu9055OC+ie/b613NojCW5nYN2QARAQABiQI8BBgBCgAmFiEE
GiNqklKNAN15ZXb+TWMlGMNUawUFAmXQ1o8CGwwFCQHhM4AACgkQTWMlGMNUawXh
7w/+KjbEWTwAhjm2HJ3w4tXtPC5URg+A+BzYYVH/q0+956c1QeD0LYafHBw4LEMI
lhRvHQnmzwjtY8v/DgmLOVDMiMWVHo0Q2iQyMvOT1WyEPcgOTJLhvyVzDqRZx7AS
B4G8uNVkKAdBZ7OSXAP27lR/2SEoG05esw8b7Y39pVtucC3aeiua+19PLJWadBjj
XuvXuSCho0km+nk4IgadYmxIDyiMeyKZ8wCl7CJkzECm83q2OtNsMe3k8lgEXybt
KlQxnYApZmhqLMV5ob8WOk3AgAVsif1m332CiEIb1Sfx6wt3nXy/410CXdDDucuj
ndJVfJ6Un33tn0irZ5scPA2HmzK1PGMfgOGtkM8B3LE/x8kEKeWKb3l9boB32Unm
iTfKgEna+JISEab3bzOPWdCQFB8LyGXuWlhtvqmRoX8GtiMRy/F4mzh+l3lYHjj3
4EvPVyippO5zwU+S9HElJ2G37K6zrOmd5cGBrw4aBDoO70QVrMN4O86uvC9kChDb
qyFF5UgXg29QxJjiSCv98ksDMqpJ5AFYrmrsBtwU64OANrxxJ4AZLQ1apYmG9RWD
VHZgfeI60FNBLfKwix9UffFT7piQ/MLrjSde8gPH5S6ezBMrYpfGEopaI9A5qXe3
LnHz88gfdmaBM77YDZM/p23nmCrUxlE3kkbgjTY8NRjYyF8=
=MkAH
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_γραμματέας_ομάδας_διαχείρισης_των_ports_portmgr_secretaryfreebsd_org>D.1.3. Γραμματέας Ομάδας Διαχείρισης των Ports <code>&lt;<a href=mailto:portmgr-secretary@FreeBSD.org>portmgr-secretary@FreeBSD.org</a>></code><a class=anchor href=#_γραμματέας_ομάδας_διαχείρισης_των_ports_portmgr_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_doceng_secretaryfreebsd_org>D.1.4. <code>&lt;<a href=mailto:doceng-secretary@FreeBSD.org>doceng-secretary@FreeBSD.org</a>></code><a class=anchor href=#_doceng_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Τελευταία τροποποίηση</strong>: 11 Δεκεμβρίου 2021 από <a href="https://cgit.freebsd.org/doc/commit/?id=2b027dd017" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Αρχική></i><div class=container><a href=../ class=direction>Αρχική</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Πίνακας περιεχομένων</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Πρόλογος</a><ul><li><a href=#preface-audience>Σε Ποιους Απευθύνεται Αυτό το Βιβλίο</a></li><li><a href=#preface-changes-from3>Αλλαγές από την Τρίτη Έκδοση</a></li><li><a href=#preface-changes-from2>Αλλαγές από τη Δεύτερη Έκδοση (2004)</a></li><li><a href=#preface-changes>Αλλαγές από την Πρώτη Έκδοση (2001)</a></li><li><a href=#preface-overview>Οργάνωση Αυτού του Βιβλίου</a></li><li><a href=#preface-conv>Συμβάσεις που χρησιμοποιούνται σε αυτό το βιβλίο</a></li><li><a href=#preface-acknowledgements>Ευχαριστίες</a></li></ul></li><li><a href=#introduction>Part I: Εισαγωγή</a><ul><li><a href=#introduction-synopsis>Chapter 1. Σύνοψη</a></li><li><a href=#nutshell>Chapter 2. Καλώς ήλθατε στο FreeBSD!</a></li><li><a href=#history>Chapter 3. Πληροφορίες για το FreeBSD Project</a></li><li><a href=#bsdinstall>Chapter 4. Εγκατάσταση του FreeBSD 9.x και Μεταγενέστερων Εκδόσεων</a></li><li><a href=#basics>Chapter 5. Βασικές Έννοιες στο UNIX®</a></li><li><a href=#ports>Chapter 6. Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a></li><li><a href=#x11>Chapter 7. Το Σύστημα X Window</a></li></ul></li><li><a href=#desktop>Part II: Desktop Εφαρμογές</a><ul><li><a href=#desktop-synopsis>Chapter 8. Σύνοψη</a></li><li><a href=#desktop-browsers>Chapter 9. Φυλλομετρητές (Browsers)</a></li><li><a href=#desktop-productivity>Chapter 10. Εφαρμογές Γραφείου</a></li><li><a href=#desktop-viewers>Chapter 11. Προγράμματα Προβολής Εγγράφων</a></li><li><a href=#desktop-finance>Chapter 12. Χρηματοοικονομικές Εφαρμογές</a></li><li><a href=#desktop-summary>Chapter 13. Περίληψη</a></li><li><a href=#multimedia>Chapter 14. Πολυμέσα</a></li><li><a href=#kernelconfig>Chapter 15. Ρυθμίζοντας τον Πυρήνα του FreeBSD</a></li><li><a href=#printing>Chapter 16. Εκτυπώσεις</a></li><li><a href=#linuxemu>Chapter 17. Συμβατότητα με Εκτελέσιμα του Linux</a></li></ul></li><li><a href=#config-tuning>Part III: Ρύθμιση και Βελτιστοποίηση</a><ul><li><a href=#config-synopsis>Chapter 18. Σύνοψη</a></li><li><a href=#configtuning-initial>Chapter 19. Αρχική Ρύθμιση</a></li><li><a href=#configtuning-core-configuration>Chapter 20. Κύρια Ρύθμιση</a></li><li><a href=#configtuning-appconfig>Chapter 21. Ρύθμιση Εφαρμογών</a></li><li><a href=#configtuning-starting-services>Chapter 22. Eκκινώντας Υπηρεσίες</a></li><li><a href=#configtuning-cron>Chapter 23. Ρυθμίζοντας Το Πρόγραμμα <code>cron</code></a></li><li><a href=#configtuning-rcd>Chapter 24. Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD</a></li><li><a href=#config-network-setup>Chapter 25. Ρυθμίζοντας Τις Κάρτες Δικτύου</a></li><li><a href=#configtuning-virtual-hosts>Chapter 26. Εικονικά Hosts</a></li><li><a href=#configtuning-configfiles>Chapter 27. Αρχεία Ρυθμίσεων</a></li><li><a href=#configtuning-sysctl>Chapter 28. Tuning with sysctl</a></li><li><a href=#configtuning-disk>Chapter 29. Tuning Disks</a></li><li><a href=#configtuning-kernel-limits>Chapter 30. Tuning Kernel Limits</a></li><li><a href=#adding-swap-space>Chapter 31. Adding Swap Space</a></li><li><a href=#acpi-overview>Chapter 32. Power and Resource Management</a></li><li><a href=#ACPI-debug>Chapter 33. Using and Debugging FreeBSD ACPI</a></li><li><a href=#boot>Chapter 34. Η Διαδικασία Εκκίνησης του FreeBSD</a></li><li><a href=#security>Chapter 35. Ασφάλεια</a></li><li><a href=#jails>Chapter 36. Jails</a></li><li><a href=#mac>Chapter 37. Υποχρεωτικός Έλεγχος Πρόσβασης</a></li><li><a href=#audit>Chapter 38. Έλεγχος Συμβάντων Ασφαλείας</a></li><li><a href=#disks>Chapter 39. Αποθηκευτικά Μέσα</a></li><li><a href=#geom>Chapter 40. GEOM: Διαχείριση Συστοιχιών Δίσκων</a></li><li><a href=#filesystems>Chapter 41. Υποστήριξη Συστημάτων Αρχείων</a></li><li><a href=#virtualization>Chapter 42. Εικονικοποίηση</a></li><li><a href=#l10n>Chapter 43. Τοπικές Ρυθμίσεις - Χρήση και ρύθμιση I18N/L10N</a></li><li><a href=#updating-upgrading>Chapter 44. Ενημέρωση και Αναβάθμιση του FreeBSD</a></li><li><a href=#dtrace>Chapter 45. DTrace</a></li></ul></li><li><a href=#serialcomms>Part IV: Serial Communications</a><ul><li><a href=#serial-synopsis>Chapter 46. Σύνοψη</a></li><li><a href=#serial>Chapter 47. Εισαγωγή</a></li><li><a href=#term>Chapter 48. Τερματικά</a></li><li><a href=#dialup>Chapter 49. Υπηρεσία Εισόδου μέσω Επιλογικής Σύνδεσης (dial-in)</a></li><li><a href=#dialout>Chapter 50. Υπηρεσία Επιλογικής Σύνδεσης</a></li><li><a href=#serialconsole-setup>Chapter 51. Ρύθμιση της Σειριακής Κονσόλας</a></li><li><a href=#ppp-and-slip>Chapter 52. PPP</a></li><li><a href=#mail>Chapter 53. Ηλεκτρονικό Ταχυδρομείο</a></li><li><a href=#network-servers>Chapter 54. Εξυπηρετητές Δικτύου</a></li><li><a href=#firewalls>Chapter 55. Firewalls</a></li><li><a href=#advanced-networking>Chapter 56. Προχωρημένα Θέματα Δικτύωσης</a></li></ul></li><li><a href=#mirrors>Appendix A: Που θα Βρείτε το FreeBSD</a></li><li><a href=#mirrors-cdrom>Chapter 57. Εκδόσεις σε CDROM και DVD</a><ul><li><a href=#_retail_εκδόσεις>57.1. Retail Εκδόσεις</a></li><li><a href=#_cd_και_dvd_διανομές>57.2. CD και DVD διανομές</a></li><li><a href=#_διανομείς>57.3. Διανομείς</a></li></ul></li><li><a href=#mirrors-ftp>Chapter 58. Εξυπηρετητές FTP</a></li><li><a href=#anoncvs>Chapter 59. Ανώνυμο CVS</a><ul><li><a href=#anoncvs-intro>59.1. Εισαγωγή</a></li><li><a href=#anoncvs-usage>59.2. Χρησιμοποιώντας Ανώνυμο CVS</a></li><li><a href=#_παραδείγματα>59.3. Παραδείγματα</a></li><li><a href=#_άλλες_πηγές_πληροφοριών>59.4. Άλλες Πηγές Πληροφοριών</a></li></ul></li><li><a href=#ctm>Chapter 60. Χρησιμοποιώντας το CTM</a><ul><li><a href=#_γιατί_πρέπει_να_χρησιμοποιήσω_το_ctm>60.1. Γιατί Πρέπει να Χρησιμοποιήσω το CTM;</a></li><li><a href=#_τι_χρειάζομαι_για_να_χρησιμοποιήσω_το_ctm>60.2. Τι Χρειάζομαι για να Χρησιμοποιήσω το CTM;</a></li><li><a href=#_χρησιμοποιώντας_το_ctm_για_πρώτη_φορά>60.3. Χρησιμοποιώντας το CTM για Πρώτη Φορά</a></li><li><a href=#_χρησιμοποιώντας_το_ctm_στην_καθημερινή_σας_ζωή>60.4. Χρησιμοποιώντας το CTM στην Καθημερινή σας Ζωή</a></li><li><a href=#_κρατώντας_τις_τοπικές_σας_αλλαγές>60.5. Κρατώντας τις Τοπικές σας Αλλαγές</a></li><li><a href=#_άλλες_ενδιαφέρουσες_επιλογές_του_ctm>60.6. Άλλες Ενδιαφέρουσες Επιλογές του CTM</a></li><li><a href=#_μελλοντικά_σχέδια_για_το_ctm>60.7. Μελλοντικά Σχέδια για το CTM</a></li><li><a href=#_διάφορα_2>60.8. Διάφορα</a></li><li><a href=#mirrors-ctm>60.9. CTM Mirrors</a></li></ul></li><li><a href=#cvsup>Chapter 61. Χρησιμοποιώντας το CVSup</a><ul><li><a href=#cvsup-intro>61.1. Εισαγωγή</a></li><li><a href=#cvsup-install>61.2. Εγκατάσταση</a></li><li><a href=#cvsup-config>61.3. Ρύθμιση του CVSup</a></li><li><a href=#_εκτελώντας_το_cvsup>61.4. Εκτελώντας το CVSup</a></li><li><a href=#cvsup-collec>61.5. Συλλογές Αρχείων τουCVSup</a></li><li><a href=#_για_περισσότερες_πληροφορίες>61.6. Για Περισσότερες Πληροφορίες</a></li><li><a href=#cvsup-mirrors>61.7. Τοποθεσίες CVSup</a></li></ul></li><li><a href=#cvs-tags>Chapter 62. Ετικέτες (Tags) για το CVS</a><ul><li><a href=#_ετικέτες_κλάδων_branch_tags>62.1. Ετικέτες Κλάδων (Branch Tags)</a></li><li><a href=#_ετικέτες_εκδόσεων_release_tags>62.2. Ετικέτες Εκδόσεων (Release Tags)</a></li></ul></li><li><a href=#mirrors-afs>Chapter 63. Τοποθεσίες AFS</a></li><li><a href=#mirrors-rsync>Chapter 64. Τοποθεσίες rsync</a></li><li><a href=#bibliography>Appendix B: Βιβλιογραφία</a><ul><li><a href=#bibliography-freebsd>B.1. Βιβλία & Περιοδικά σχετικά με το FreeBSD</a></li><li><a href=#bibliography-userguides>B.2. Οδηγοί χρήστη</a></li><li><a href=#bibliography-adminguides>B.3. Οδηγοί διαχειριστή</a></li><li><a href=#bibliography-programmers>B.4. Οδηγοί προγραμματιστών</a></li><li><a href=#bibliography-osinternals>B.5. Το εσωτερικό του λειτουργικού συστήματος</a></li><li><a href=#bibliography-security>B.6. Αναφορές ασφαλείας</a></li><li><a href=#bibliography-hardware>B.7. Αναφορές υλικού</a></li><li><a href=#bibliography-history>B.8. Ιστορία του UNIX®</a></li><li><a href=#bibliography-journals>B.9. Περιοδικά και εφημερίδες</a></li></ul></li><li><a href=#eresources>Appendix C: Πηγές Πληροφόρησης στο Διαδίκτυο</a><ul><li><a href=#eresources-mail>C.1. Λίστες Ηλεκτρονικού Ταχυδρομείου</a></li><li><a href=#eresources-news>C.2. Usenet Newsgroups</a></li><li><a href=#eresources-web>C.3. Διακομιστές Ιστοσελίδων</a></li><li><a href=#eresources-email>C.4. Διευθύνσεις Ηλεκτρονικού Ταχυδρομείου</a></li></ul></li><li><a href=#pgpkeys>Appendix D: Κλειδιά PGP</a><ul><li><a href=#pgpkeys-officers>D.1. Officers</a></li></ul></li></ul></nav><hr><div class=resources><h3>Πηγές</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Λήψη PDF"></i><a href=https://download.freebsd.org/doc/el/books/handbook/handbook_el.pdf>Λήψη PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Τροποποίηση αυτής της σελίδας"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/el/book target=_blank>Τροποποίηση αυτής της σελίδας</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/el/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Επιλογή γλώσσας">
<span>Greek</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>Σύστημα</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Υψηλή αντίθεση</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/el class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/el/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>