<!doctype html><html class=theme-light lang=el><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/el/books/handbook/security/><title>Κεφάλαιο 15. Ασφάλεια | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Κεφάλαιο 15. Ασφάλεια"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="el"><meta property="og:url" content="http://172.16.201.134:1313/el/books/handbook/security/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/el\/books\/handbook\/security\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/el>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/el/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/el/books>Books</a></li><li><a href=http://172.16.201.134:1313/el/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/el/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=el>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Αναζήτηση aria-label=Αναζήτηση maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/preface/>Πρόλογος</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/preface/#preface-audience>Σε Ποιους Απευθύνεται Αυτό το Βιβλίο</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/preface/#preface-changes-from3>Αλλαγές από την Τρίτη Έκδοση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/preface/#preface-changes-from2>Αλλαγές από τη Δεύτερη Έκδοση (2004)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/preface/#preface-changes>Αλλαγές από την Πρώτη Έκδοση (2001)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/preface/#preface-overview>Οργάνωση Αυτού του Βιβλίου</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/preface/#preface-conv>Συμβάσεις που χρησιμοποιούνται σε αυτό το βιβλίο</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/preface/#preface-acknowledgements>Ευχαριστίες</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/parti/>Μέρος I. Ξεκινώντας με το FreeBSD</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/introduction/>Κεφάλαιο 1. Εισαγωγή</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/introduction/#introduction-synopsis>1.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/introduction/#nutshell>1.2. Καλώς ήλθατε στο FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/introduction/#history>1.3. Πληροφορίες για το FreeBSD Project</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/>Κεφάλαιο 2. Εγκατάσταση του FreeBSD 9.x και Μεταγενέστερων Εκδόσεων</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Απαιτήσεις Υλικού</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Εργασίες πριν την Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-start>2.4. Ξεκινώντας την Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#using-bsdinstall>2.5. Εισαγωγή στο bsdinstall</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-netinstall>2.6. Εγκατάσταση από το Δίκτυο</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-partitioning>2.7. Εκχώρηση Χώρου στο Δίσκο</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-final-warning>2.8. Επιβεβαίωση της Εγκατάστασης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-post>2.9. Μετά την Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Αντιμετώπιση Προβλημάτων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bsdinstall/#using-live-cd>2.11. Χρησιμοποιώντας τη Λειτουργία Live CD</a></li></ul></li><li><input type=checkbox id=chapter-6aaec170775233b7c45f6cdcfb70d466 class=toggle>
<label class="icon cursor" for=chapter-6aaec170775233b7c45f6cdcfb70d466><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/install/>Κεφάλαιο 3. Εγκατάσταση του FreeBSD 8.x και Προγενέστερων Εκδόσεων</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-synopsis>3.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-hardware>3.2. Απαιτήσεις Υλικού</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-pre>3.3. Εργασίες πριν την Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-start>3.4. Ξεκινώντας την Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#using-sysinstall>3.5. Εισαγωγή στο Sysinstall</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-steps>3.6. Εκχώρηση Χώρου στο Δίσκο</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-choosing>3.7. Επιλέγοντας τι θα Εγκαταστήσετε</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-media>3.8. Επιλέγοντας το Μέσο Εγκατάστασης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-final-warning>3.9. Επιβεβαίωση της Εγκατάστασης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-post>3.10. Μετά την Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-trouble>3.11. Αντιμετώπιση Προβλημάτων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-advanced>3.12. Οδηγός Εγκατάστασης για Προχωρημένους</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/install/#install-diff-media>3.13. Προετοιμάζοντας τα Δικά σας Μέσα Εγκατάστασης</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/basics/>Κεφάλαιο 4. Βασικές Έννοιες στο UNIX®</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#basics-synopsis>4.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#consoles>4.2. Εικονικές Κονσόλες και Τερματικά</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#permissions>4.3. Άδειες (Permissions)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#dirstructure>4.4. Δομή Καταλόγου</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#disk-organization>4.5. Οργάνωση Δίσκου</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#mount-unmount>4.6. Προσάρτηση και Αποπροσάρτηση Συστημάτων Αρχείων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#basics-processes>4.7. Διεργασίες</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#basics-daemons>4.8. Δαίμονες, Σήματα, και Τερματισμός Διεργασιών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#shells>4.9. Κελύφη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#editors>4.10. Κειμενογράφοι</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#basics-devices>4.11. Συσκευές και Αρχεία συσκευών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#binary-formats>4.12. Τύποι Εκτελέσιμων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/basics/#basics-more-information>4.13. Για Περισσότερες Πληροφορίες</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/ports/>Κεφάλαιο 5. Εγκατάσταση Εφαρμογών: Πακέτα και Ports</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/ports/#ports-synopsis>5.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ports/#ports-overview>5.2. Επισκόπησή της εγκατάστασης λογισμικού</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ports/#ports-finding-applications>5.3. Βρίσκοντας την Εφαρμογή σας</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ports/#packages-using>5.4. Χρησιμοποιώντας το Σύστημα των Πακέτων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ports/#ports-using>5.5. Χρησιμοποιώντας την Συλλογή των Ports</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ports/#ports-nextsteps>5.6. Ενέργειες μετά την Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ports/#ports-broken>5.7. Αντιμετωπίζοντας Χαλασμένα Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/x11/>Κεφάλαιο 6. Το Σύστημα X Window</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/x11/#x11-synopsis>6.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/x11/#x-understanding>6.2. Κατανόηση του περιβάλλοντος X11</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/x11/#x-install>6.3. Εγκατάσταση του X11</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/x11/#x-config>6.4. Ρύθμιση του X11</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/x11/#x-fonts>6.5. Χρήση Γραμματοσειρών στο X11</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/x11/#x-xdm>6.6. Ο X Display Manager</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/x11/#x11-wm>6.7. Γραφικά Περιβάλλοντα</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/partii/>Μέρος II. Βασικές Εργασίες</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/desktop/>Κεφάλαιο 7. Desktop Εφαρμογές</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/desktop/#desktop-synopsis>7.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/desktop/#desktop-browsers>7.2. Φυλλομετρητές (Browsers)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/desktop/#desktop-productivity>7.3. Εφαρμογές Γραφείου</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/desktop/#desktop-viewers>7.4. Προγράμματα Προβολής Εγγράφων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/desktop/#desktop-finance>7.5. Χρηματοοικονομικές Εφαρμογές</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/desktop/#desktop-summary>7.6. Περίληψη</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/>Κεφάλαιο 8. Πολυμέσα</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/#multimedia-synopsis>8.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/#sound-setup>8.2. Ρύθμιση της Κάρτας Ήχου</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/#sound-mp3>8.3. Ήχος MP3</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/#video-playback>8.4. Αναπαραγωγή Video</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/#tvcard>8.5. Ρύθμιση Κάρτας Τηλεόρασης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/#mythtv>8.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/multimedia/#scanners>8.7. Σαρωτές Εικόνας</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/>Κεφάλαιο 9. Ρυθμίζοντας τον Πυρήνα του FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/#kernelconfig-synopsis>9.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/#kernelconfig-custom-kernel>9.2. Γιατί να Φτιάξετε Προσαρμοσμένο Πυρήνα;</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/#kernelconfig-devices>9.3. Ανακαλύπτοντας τις Συσκευές του Συστήματος σας</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/#kernelconfig-modules>9.4. Προγράμματα Οδήγησης, Υποσυστήματα και Αρθρώματα (modules)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/#kernelconfig-building>9.5. Δημιουργία και Εγκατάσταση Προσαρμοσμένου Πυρήνα</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/#kernelconfig-config>9.6. Το Αρχείο Ρυθμίσεων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/kernelconfig/#kernelconfig-trouble>9.7. Αν Κάτι Πάει Λάθος</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/printing/>Κεφάλαιο 10. Εκτυπώσεις</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/printing/#printing-synopsis>10.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/printing/#printing-intro-spooler>10.2. Εισαγωγή</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/printing/#printing-intro-setup>10.3. Βασική Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/printing/#printing-advanced>10.4. Ρυθμίσεις Εκτυπωτών για Προχωρημένους</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/printing/#printing-using>10.5. Χρήση Εκτυπωτών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/printing/#printing-lpd-alternatives>10.6. Εναλλακτικές Λύσεις για τον Στάνταρ Spooler</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/printing/#printing-troubleshooting>10.7. Εντοπισμός Βλαβών</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/>Κεφάλαιο 11. Συμβατότητα με Εκτελέσιμα του Linux</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/#linuxemu-synopsis>11.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/#linuxemu-lbc-install>11.2. Εγκατάσταση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/#linuxemu-mathematica>11.3. Εγκαθιστώντας το Mathematica®</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/#linuxemu-maple>11.4. Εγκαθιστώντας το Maple™</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/#linuxemu-matlab>11.5. Εγκαθιστώντας το MATLAB®</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/#linuxemu-oracle>11.6. Εγκατάσταση της Oracle®</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/linuxemu/#linuxemu-advanced>11.7. Προχωρημένα Θέματα</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/partiii/>Μέρος III. Διαχείριση Συστήματος</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/config/>Κεφάλαιο 12. Ρύθμιση και Βελτιστοποίηση</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#config-synopsis>12.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-initial>12.2. Αρχική Ρύθμιση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-core-configuration>12.3. Κύρια Ρύθμιση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-appconfig>12.4. Ρύθμιση Εφαρμογών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-starting-services>12.5. Eκκινώντας Υπηρεσίες</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-cron>12.6. Ρυθμίζοντας Το Πρόγραμμα <code>cron</code></a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-rcd>12.7. Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#config-network-setup>12.8. Ρυθμίζοντας Τις Κάρτες Δικτύου</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-virtual-hosts>12.9. Εικονικά Hosts</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-configfiles>12.10. Αρχεία Ρυθμίσεων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-sysctl>12.11. Tuning with sysctl</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-disk>12.12. Tuning Disks</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#configtuning-kernel-limits>12.13. Tuning Kernel Limits</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#adding-swap-space>12.14. Adding Swap Space</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#acpi-overview>12.15. Power and Resource Management</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/config/#ACPI-debug>12.16. Using and Debugging FreeBSD ACPI</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/boot/>Κεφάλαιο 13. Η Διαδικασία Εκκίνησης του FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/boot/#boot-synopsis>13.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/boot/#boot-introduction>13.2. Το Πρόβλημα της Εκκίνησης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/boot/#boot-blocks>13.3. Ο Διαχειριστής Εκκίνησης και τα Στάδια Εκκίνησης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/boot/#boot-kernel>13.4. Αλληλεπίδραση με τον Πυρήνα κατά την Εκκίνηση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/boot/#device-hints>13.5. Device Hints</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/boot/#boot-init>13.6. Init: Αρχικοποίηση Ελέγχου Διαδικασιών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/boot/#boot-shutdown>13.7. Ακολουθία Τερματισμού</a></li></ul></li><li><input type=checkbox id=chapter-d251c21b963b5ab783e5aec225e02b5a class=toggle>
<label class="icon cursor" for=chapter-d251c21b963b5ab783e5aec225e02b5a><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/users/>Κεφάλαιο 14. Χρήστες και Βασική Διαχείριση Λογαριασμών</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-synopsis>14.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-introduction>14.2. Εισαγωγή</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-superuser>14.3. Ο Λογαριασμός Υπερχρήστη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-system>14.4. Λογαριασμοί Συστήματος</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-user>14.5. Λογαριασμοί Χρηστών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-modifying>14.6. Τροποποιώντας Λογαριασμούς</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-limiting>14.7. Περιορίζοντας Χρήστες</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/users/#users-groups>14.8. Ομάδες</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle checked>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/security/>Κεφάλαιο 15. Ασφάλεια</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#security-synopsis>15.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#security-intro>15.2. Introduction</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#securing-freebsd>15.3. Securing FreeBSD</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#crypt>15.4. DES, MD5, and Crypt</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#one-time-passwords>15.5. One-time Passwords</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#tcpwrappers>15.6. TCP Wrappers</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#kerberosIV>15.7. KerberosIV</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#kerberos5>15.8. Kerberos5</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#openssl>15.9. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#ipsec>15.10. VPN over IPsec</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#openssh>15.11. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#fs-acl>15.12. File System Access Control Lists</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#security-portaudit>15.13. Monitoring Third Party Security Issues</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#security-advisories>15.14. FreeBSD Security Advisories</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/security/#security-accounting>15.15. Process Accounting</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/jails/>Κεφάλαιο 16. Jails</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/jails/#jails-synopsis>16.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/jails/#jails-terms>16.2. Όροι των Jails</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/jails/#jails-intro>16.3. Εισαγωγή</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/jails/#jails-build>16.4. Δημιουργώντας και Ελέγχοντας Jails</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/jails/#jails-tuning>16.5. Λεπτομερής Ρύθμιση και Διαχείριση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/jails/#jails-application>16.6. Εφαρμογή των Jails</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/mac/>Κεφάλαιο 17. Υποχρεωτικός Έλεγχος Πρόσβασης</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-synopsis>17.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-inline-glossary>17.2. Key Terms in this Chapter</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-initial>17.3. Explanation of MAC</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-understandlabel>17.4. Understanding MAC Labels</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-planning>17.5. Planning the Security Configuration</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-modules>17.6. Module Configuration</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-bsdextended>17.7. The MAC bsdextended Module</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-ifoff>17.8. The MAC ifoff Module</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-portacl>17.9. The MAC portacl Module</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-partition>17.10. The MAC partition Module</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-mls>17.11. The MAC Multi-Level Security Module</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-biba>17.12. The MAC Biba Module</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-lomac>17.13. The MAC LOMAC Module</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-implementing>17.14. Nagios in a MAC Jail</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-userlocked>17.15. User Lock Down</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mac/#mac-troubleshoot>17.16. Troubleshooting the MAC Framework</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/audit/>Κεφάλαιο 18. Έλεγχος Συμβάντων Ασφαλείας</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/audit/#audit-synopsis>31.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/audit/#audit-inline-glossary>31.2. Key Terms in this Chapter</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/audit/#audit-install>31.3. Installing Audit Support</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/audit/#audit-config>31.4. Audit Configuration</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/audit/#audit-administration>31.5. Administering the Audit Subsystem</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/disks/>Κεφάλαιο 19. Αποθηκευτικά Μέσα</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#disks-synopsis>19.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#disks-naming>19.2. Device Names</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#disks-adding>19.3. Adding Disks</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#usb-disks>19.4. USB Storage Devices</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#creating-cds>19.5. Creating and Using CD Media</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#creating-dvds>19.6. Creating and Using DVD Media</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#floppies>19.7. Creating and Using Floppy Disks</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#backups-tapebackups>19.8. Creating and Using Data Tapes</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#backup-strategies>19.9. Backup Strategies</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#backup-basics>19.10. Backup Basics</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#disks-virtual>19.11. Network, Memory, and File-Backed File Systems</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#snapshots>19.12. File System Snapshots</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#quotas>19.13. File System Quotas</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#disks-encrypting>19.14. Encrypting Disk Partitions</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#swap-encrypting>19.15. Encrypting Swap Space</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/disks/#disks-hast>19.16. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/geom/>Κεφάλαιο 20. GEOM: Διαχείριση Συστοιχιών Δίσκων</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#GEOM-synopsis>20.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#GEOM-intro>20.2. Εισαγωγή στο GEOM</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#GEOM-striping>20.3. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#GEOM-mirror>20.4. RAID1 - Mirroring</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#GEOM-raid3>20.5. RAID3 - Striping σε Επίπεδο Byte με Αφοσιωμένο Parity</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#geom-ggate>20.6. Δικτυακές Συσκευές μέσω GEOM Gate</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#geom-glabel>20.7. Δημιουργώντας Ετικέτες (Labels) στις Συσκευές Δίσκων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/geom/#geom-gjournal>20.8. UFS Journaling Μέσω GEOM</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/filesystems/>Κεφάλαιο 21. Υποστήριξη Συστημάτων Αρχείων</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/filesystems/#filesystems-synopsis>21.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/filesystems/#filesystems-zfs>21.2. Το Σύστημα Αρχείων Z (ZFS)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/filesystems/#filesystems-linux>21.3. Συστήματα Αρχείων Linux®</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/virtualization/>Κεφάλαιο 22. Εικονικοποίηση</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/virtualization/#virtualization-synopsis>22.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/virtualization/#virtualization-guest>22.2. Το FreeBSD ως φιλοξενούμενο λειτουργικό</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/virtualization/#virtualization-host>22.3. Το FreeBSD ως Ξενιστής (Host)</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/l10n/>Κεφάλαιο 23. Τοπικές Ρυθμίσεις - Χρήση και ρύθμιση I18N/L10N</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/l10n/#l10n-synopsis>23.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/l10n/#l10n-basics>23.2. Βασικές Γνώσεις</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/l10n/#using-localization>23.3. Χρήση των Τοπικών Ρυθμίσεων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/l10n/#l10n-compiling>23.4. Μεταγλώττιση Προγραμμάτων I18N</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/l10n/#lang-setup>23.5. Τοπικές Ρυθμίσεις για Συγκεκριμένες Γλώσσες</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/>Κεφάλαιο 24. Ενημέρωση και Αναβάθμιση του FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#updating-upgrading-synopsis>24.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>24.2. Ενημερώνοντας το FreeBSD</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#updating-upgrading-portsnap>24.3. Portsnap: Ένα Εργαλείο Ενημέρωσης της Συλλογής των Ports</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#updating-upgrading-documentation>24.4. Ενημερώνοντας την Τεκμηρίωση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#current-stable>24.5. Παρακολούθηση Ενός Κλάδου Ανάπτυξης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#synching>24.6. Συγχρονίζοντας τον Πηγαίο σας Κώδικα</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#makeworld>24.7. Μεταγλωττίζοντας το Βασικό Σύστημα ("world")</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#make-delete-old>24.8. Διαγραφή Παρωχημένων Αρχείων, Καταλόγων και Βιβλιοθηκών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/cutting-edge/#small-lan>24.9. Διαδικασία για Πολλαπλά Μηχανήματα</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/dtrace/>Κεφάλαιο 25. DTrace</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/dtrace/#dtrace-synopsis>25.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/dtrace/#dtrace-implementation>25.2. Διαφορές στην Υλοποίηση</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/dtrace/#dtrace-enable>25.3. Ενεργοποίηση της Υποστήριξης DTrace</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/dtrace/#dtrace-using>25.4. Χρησιμοποιώντας το DTrace</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/dtrace/#dtrace-language>25.5. Η Γλώσσα D</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/partiv/>Μέρος IV. Δικτυακές Επικοινωνίες</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/serialcomms/>Κεφάλαιο 26. Σειριακές Επικοινωνίες</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/serialcomms/#serial-synopsis>26.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/serialcomms/#serial>26.2. Εισαγωγή</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/serialcomms/#term>26.3. Τερματικά</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/serialcomms/#dialup>26.4. Υπηρεσία Εισόδου μέσω Επιλογικής Σύνδεσης (dial-in)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/serialcomms/#dialout>26.5. Υπηρεσία Επιλογικής Σύνδεσης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/serialcomms/#serialconsole-setup>26.6. Ρύθμιση της Σειριακής Κονσόλας</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/>Κεφάλαιο 27. PPP και SLIP</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/#userppp>27.2. Χρησιμοποιώντας το PPP Χρήστη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/#ppp>27.3. Χρησιμοποιώντας το PPP του Πυρήνα</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.4. Αντιμετώπιση Προβλημάτων σε Συνδέσεις PPP</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/#pppoe>27.5. Χρησιμοποιώντας PPP μέσω Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/#pppoa>27.6. Χρησιμοποιώντας PPP μέσω ATM (PPPoA)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/ppp-and-slip/#slip>27.7. Χρησιμοποιώντας το SLIP</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/mail/>Κεφάλαιο 28. Ηλεκτρονικό Ταχυδρομείο</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-synopsis>28.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-using>28.2. Χρησιμοποιώντας το Ηλεκτρονικό Ταχυδρομείο</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#sendmail>28.3. Ρύθμιση του sendmail</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-changingmta>28.4. Αλλάζοντας τον Αντιπρόσωπο Μεταφοράς Ταχυδρομείου (MTA)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-trouble>28.5. Αντιμετώπιση Προβλημάτων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-advanced>28.6. Προχωρημένα Θέματα</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#SMTP-UUCP>28.7. SMTP με UUCP</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#outgoing-only>28.8. Ρύθμιση Εξυπηρετητή Μόνο για Αποστολή</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#SMTP-dialup>28.9. Χρησιμοποιώντας το Mail Μέσω Επιλογικής (Dialup) Σύνδεσης</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#SMTP-Auth>28.10. Πιστοποίηση Αυθεντικότητας στο SMTP</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-agents>28.11. Προγράμματα Ταχυδρομείου για τον Χρήστη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-fetchmail>28.12. Χρησιμοποιώντας το fetchmail</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mail/#mail-procmail>28.13. Χρησιμοποιώντας το procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/>Κεφάλαιο 29. Εξυπηρετητές Δικτύου</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-servers-synopsis>29.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-inetd>29.2. The inetd"Super-Server"</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-nis>29.4. Network Information System (NIS/YP)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-dhcp>29.5. Automatic Network Configuration (DHCP)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-dns>29.6. Domain Name System (DNS)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-apache>29.7. Ο εξυπηρετητής HTTP Apache</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-ftp>29.8. Πρωτόκολο Μεταφοράς Αρχείων (FTP)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-samba>29.9. File and Print Services for Microsoft® Windows® clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/network-servers/#network-ntp>29.10. Συγχρονισμός Ρολογιού Συστήματος με NTP</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/firewalls/>Κεφάλαιο 30. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/firewalls/#firewalls-intro>30.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/firewalls/#firewalls-concepts>30.2. Βασικές Έννοιες των Firewalls</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/firewalls/#firewalls-apps>30.3. Προγράμματα Firewall</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/firewalls/#firewalls-pf>30.4. Το Packet Filter (PF) και το ALTQ του OpenBSD</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/firewalls/#firewalls-ipf>30.5. Το IPFILTER (IPF) Firewall</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/firewalls/#firewalls-ipfw>30.6. IPFW</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/>Κεφάλαιο 31. Προχωρημένα Θέματα Δικτύωσης</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Σύνοψη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-routing>31.2. Gateways and Routes</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-wireless>31.3. Wireless Networking</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-bluetooth>31.4. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-bridging>31.5. Bridging</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-diskless>31.6. Diskless Operation</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-isdn>31.7. ISDN</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-natd>31.8. Network Address Translation</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-plip>31.9. Parallel Line IP (PLIP)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-ipv6>31.10. IPv6</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#network-atm>31.11. Asynchronous Transfer Mode (ATM)</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/advanced-networking/#carp>31.12. Common Access Redundancy Protocol (CARP)</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/partv/>Μέρος V. Παραρτήματα</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/>Παράρτημα A. Που θα Βρείτε το FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#mirrors-cdrom>A.1. Εκδόσεις σε CDROM και DVD</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#mirrors-ftp>A.2. Εξυπηρετητές FTP</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#anoncvs>A.3. Ανώνυμο CVS</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#ctm>A.4. Χρησιμοποιώντας το CTM</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#cvsup>A.5. Χρησιμοποιώντας το CVSup</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#cvs-tags>A.6. Ετικέτες (Tags) για το CVS</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#mirrors-afs>A.7. Τοποθεσίες AFS</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/mirrors/#mirrors-rsync>A.8. Τοποθεσίες rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/>Παράρτημα B. Βιβλιογραφία</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-freebsd>B.1. Βιβλία & Περιοδικά σχετικά με το FreeBSD</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-userguides>B.2. Οδηγοί χρήστη</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-adminguides>B.3. Οδηγοί διαχειριστή</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-programmers>B.4. Οδηγοί προγραμματιστών</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-osinternals>B.5. Το εσωτερικό του λειτουργικού συστήματος</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-security>B.6. Αναφορές ασφαλείας</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-hardware>B.7. Αναφορές υλικού</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-history>B.8. Ιστορία του UNIX®</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/bibliography/#bibliography-journals>B.9. Περιοδικά και εφημερίδες</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/eresources/>Παράρτημα C. Πηγές Πληροφόρησης στο Διαδίκτυο</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/eresources/#eresources-mail>C.1. Λίστες Ηλεκτρονικού Ταχυδρομείου</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/eresources/#eresources-news>C.2. Usenet Newsgroups</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/eresources/#eresources-web>C.3. Διακομιστές Ιστοσελίδων</a></li><li><a href=http://172.16.201.134:1313/el/books/handbook/eresources/#eresources-email>C.4. Διευθύνσεις Ηλεκτρονικού Ταχυδρομείου</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/el/books/handbook/pgpkeys/>Παράρτημα D. Κλειδιά PGP</a><ul><li><a href=http://172.16.201.134:1313/el/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Κεφάλαιο 15. Ασφάλεια</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Πίνακας περιεχομένων</h3><nav id=TableOfContents><ul><li><a href=#security-synopsis>15.1. Σύνοψη</a></li><li><a href=#security-intro>15.2. Introduction</a></li><li><a href=#securing-freebsd>15.3. Securing FreeBSD</a></li><li><a href=#crypt>15.4. DES, MD5, and Crypt</a></li><li><a href=#one-time-passwords>15.5. One-time Passwords</a></li><li><a href=#tcpwrappers>15.6. TCP Wrappers</a></li><li><a href=#kerberosIV>15.7. KerberosIV</a></li><li><a href=#kerberos5>15.8. Kerberos5</a></li><li><a href=#openssl>15.9. OpenSSL</a></li><li><a href=#ipsec>15.10. VPN over IPsec</a></li><li><a href=#openssh>15.11. OpenSSH</a></li><li><a href=#fs-acl>15.12. File System Access Control Lists</a></li><li><a href=#security-portaudit>15.13. Monitoring Third Party Security Issues</a></li><li><a href=#security-advisories>15.14. FreeBSD Security Advisories</a></li><li><a href=#security-accounting>15.15. Process Accounting</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=security-synopsis>15.1. Σύνοψη<a class=anchor href=#security-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Το κεφάλαιο αυτό παρέχει μια βασική εισαγωγή στις έννοιες της ασφάλειας συστήματος, κάποιους γενικά καλούς κανόνες, και ορισμένα προχωρημένα θέματα σχετικά με το FreeBSD. Αρκετά από τα θέματα που καλύπτονται εδώ, μπορούν να εφαρμοστούν το ίδιο καλά τόσο στο ίδιο το σύστημα, όσο και για ασφάλεια μέσω Internet. Το Internet δεν είναι πλέον ένα "φιλικό" μέρος στο οποίο καθένας θέλει να είναι ο ευγενικός σας γείτονας. Η ανάγκη ασφάλισης του συστήματος σας είναι επιτακτική για να προστατέψετε τα δεδομένα σας,την πνευματική σας ιδιοκτησία, το χρόνο σας, και πολλά περισσότερα από τα χέρια των χάκερς και των ομοίων τους.</p></div><div class=paragraph><p>Το FreeBSD παρέχει μια σειρά από βοηθητικά προγράμματα και μηχανισμούς για να εξασφαλίσει την ακεραιότητα και την ασφάλεια του συστήματος σας και του δικτύου.</p></div><div class=paragraph><p>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</p></div><div class=ulist><ul><li><p>Βασικές έννοιες για την ασφάλεια, σε σχέση με το FreeBSD.</p></li><li><p>Στοιχεία σχετικά με τους διάφορους μηχανισμούς κρυπτογράφησης που είναι διαθέσιμοι στο FreeBSD, όπως το DES και το MD5.</p></li><li><p>Πως να ρυθμίσετε το σύστημα σας για κωδικούς μιας χρήσης.</p></li><li><p>Πως να ρυθμίσετε TCP Wrappers για χρήση με την <code>inetd</code>.</p></li><li><p>Πως να ρυθμίσετε τον KerberosIV σε FreeBSD εκδόσεις πριν τη 5.0.</p></li><li><p>Πως να ρυθμίσετε τον Kerberos5 στο FreeBSD.</p></li><li><p>Πως να ρυθμίσετε το IPsec και να δημιουργήσετε ένα VPN μεταξύ μηχανημάτων FreeBSD/Windows®.</p></li><li><p>Πως να ρυθμίσετε και να χρησιμοποιήσετε την κατά FreeBSD υλοποίηση SSH του OpenSSH</p></li><li><p>Τι είναι τα ACLs στο σύστημα αρχείων και πως να τα χρησιμοποιήσετε.</p></li><li><p>Πως να χρησιμοποιήσετε το βοηθητικό πρόγραμμα Portaudit για να ελέγξετε λογισμικό τρίτου κατασκευαστή που έχει εγκατασταθεί μέσω της συλλογής Ports.</p></li><li><p>Πως να χρησιμοποιήσετε τις δημοσιεύσεις security advisories του FreeBSD.</p></li><li><p>Θα έχετε μια ιδέα για το τι είναι το Process Accounting και πως να το ενεργοποιήσετε στο FreeBSD.</p></li></ul></div><div class=paragraph><p>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</p></div><div class=ulist><ul><li><p>Να κατανοείτε βασικές έννοιες του FreeBSD και του Internet.</p></li></ul></div><div class=paragraph><p>Πρόσθετα θέματα σχετικά με την ασφάλεια καλύπτονται σε ολόκληρο το βιβλίο. Για παράδειγμα, ο Υποχρεωτικός Έλεγχος Πρόσβασης συζητείται στο <a href=../mac/#mac>Υποχρεωτικός Έλεγχος Πρόσβασης</a> και τα Internet Firewalls συζητούνται στο <a href=../firewalls/#firewalls>Firewalls</a>.</p></div></div></div><div class=sect1><h2 id=security-intro>15.2. Introduction<a class=anchor href=#security-intro></a></h2><div class=sectionbody><div class=paragraph><p>Security is a function that begins and ends with the system administrator. While all BSD UNIX® multi-user systems have some inherent security, the job of building and maintaining additional security mechanisms to keep those users "honest" is probably one of the single largest undertakings of the sysadmin. Machines are only as secure as you make them, and security concerns are ever competing with the human necessity for convenience. UNIX® systems, in general, are capable of running a huge number of simultaneous processes and many of these processes operate as servers - meaning that external entities can connect and talk to them. As yesterday’s mini-computers and mainframes become today’s desktops, and as computers become networked and inter-networked, security becomes an even bigger issue.</p></div><div class=paragraph><p>System security also pertains to dealing with various forms of attack, including attacks that attempt to crash, or otherwise make a system unusable, but do not attempt to compromise the <code>root</code> account ("break root"). Security concerns can be split up into several categories:</p></div><div class="olist arabic"><ol class=arabic><li><p>Denial of service attacks.</p></li><li><p>User account compromises.</p></li><li><p>Root compromise through accessible servers.</p></li><li><p>Root compromise via user accounts.</p></li><li><p>Backdoor creation.</p></li></ol></div><div class=paragraph><p>A denial of service attack is an action that deprives the machine of needed resources. Typically, DoS attacks are brute-force mechanisms that attempt to crash or otherwise make a machine unusable by overwhelming its servers or network stack. Some DoS attacks try to take advantage of bugs in the networking stack to crash a machine with a single packet. The latter can only be fixed by applying a bug fix to the kernel. Attacks on servers can often be fixed by properly specifying options to limit the load the servers incur on the system under adverse conditions. Brute-force network attacks are harder to deal with. A spoofed-packet attack, for example, is nearly impossible to stop, short of cutting your system off from the Internet. It may not be able to take your machine down, but it can saturate your Internet connection.</p></div><div class=paragraph><p>A user account compromise is even more common than a DoS attack. Many sysadmins still run standard telnetd, rlogind, rshd, and ftpd servers on their machines. These servers, by default, do not operate over encrypted connections. The result is that if you have any moderate-sized user base, one or more of your users logging into your system from a remote location (which is the most common and convenient way to login to a system) will have his or her password sniffed. The attentive system admin will analyze his remote access logs looking for suspicious source addresses even for successful logins.</p></div><div class=paragraph><p>One must always assume that once an attacker has access to a user account, the attacker can break <code>root</code>. However, the reality is that in a well secured and maintained system, access to a user account does not necessarily give the attacker access to <code>root</code>. The distinction is important because without access to <code>root</code> the attacker cannot generally hide his tracks and may, at best, be able to do nothing more than mess with the user’s files, or crash the machine. User account compromises are very common because users tend not to take the precautions that sysadmins take.</p></div><div class=paragraph><p>System administrators must keep in mind that there are potentially many ways to break <code>root</code> on a machine. The attacker may know the <code>root</code> password, the attacker may find a bug in a root-run server and be able to break <code>root</code> over a network connection to that server, or the attacker may know of a bug in a suid-root program that allows the attacker to break <code>root</code> once he has broken into a user’s account. If an attacker has found a way to break <code>root</code> on a machine, the attacker may not have a need to install a backdoor. Many of the <code>root</code> holes found and closed to date involve a considerable amount of work by the attacker to cleanup after himself, so most attackers install backdoors. A backdoor provides the attacker with a way to easily regain <code>root</code> access to the system, but it also gives the smart system administrator a convenient way to detect the intrusion. Making it impossible for an attacker to install a backdoor may actually be detrimental to your security, because it will not close off the hole the attacker found to break in the first place.</p></div><div class=paragraph><p>Security remedies should always be implemented with a multi-layered "onion peel" approach and can be categorized as follows:</p></div><div class="olist arabic"><ol class=arabic><li><p>Securing <code>root</code> and staff accounts.</p></li><li><p>Securing <code>root</code>-run servers and suid/sgid binaries.</p></li><li><p>Securing user accounts.</p></li><li><p>Securing the password file.</p></li><li><p>Securing the kernel core, raw devices, and file systems.</p></li><li><p>Quick detection of inappropriate changes made to the system.</p></li><li><p>Paranoia.</p></li></ol></div><div class=paragraph><p>The next section of this chapter will cover the above bullet items in greater depth.</p></div></div></div><div class=sect1><h2 id=securing-freebsd>15.3. Securing FreeBSD<a class=anchor href=#securing-freebsd></a></h2><div class=sectionbody><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Command vs. Protocol</div><div class=paragraph><p>Throughout this document, we will use bold text to refer to an application, and a <code>monospaced</code> font to refer to specific commands. Protocols will use a normal font. This typographical distinction is useful for instances such as ssh, since it is a protocol as well as command.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The sections that follow will cover the methods of securing your FreeBSD system that were mentioned in the <a href=../mac/#security-intro>last section</a> of this chapter.</p></div><div class=sect2><h3 id=securing-root-and-staff>15.3.1. Securing the <code>root</code> Account and Staff Accounts<a class=anchor href=#securing-root-and-staff></a></h3><div class=paragraph><p>First off, do not bother securing staff accounts if you have not secured the <code>root</code> account. Most systems have a password assigned to the <code>root</code> account. The first thing you do is assume that the password is <em>always</em> compromised. This does not mean that you should remove the password. The password is almost always necessary for console access to the machine. What it does mean is that you should not make it possible to use the password outside of the console or possibly even with the <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> command. For example, make sure that your ptys are specified as being insecure in the <span class=filename>/etc/ttys</span> file so that direct <code>root</code> logins via <code>telnet</code> or <code>rlogin</code> are disallowed. If using other login services such as sshd, make sure that direct <code>root</code> logins are disabled there as well. You can do this by editing your <span class=filename>/etc/ssh/sshd_config</span> file, and making sure that <code>PermitRootLogin</code> is set to <code>NO</code>. Consider every access method - services such as FTP often fall through the cracks. Direct <code>root</code> logins should only be allowed via the system console.</p></div><div class=paragraph><p>Of course, as a sysadmin you have to be able to get to <code>root</code>, so we open up a few holes. But we make sure these holes require additional password verification to operate. One way to make <code>root</code> accessible is to add appropriate staff accounts to the <code>wheel</code> group (in <span class=filename>/etc/group</span>). The staff members placed in the <code>wheel</code> group are allowed to <code>su</code> to <code>root</code>. You should never give staff members native <code>wheel</code> access by putting them in the <code>wheel</code> group in their password entry. Staff accounts should be placed in a <code>staff</code> group, and then added to the <code>wheel</code> group via the <span class=filename>/etc/group</span> file. Only those staff members who actually need to have <code>root</code> access should be placed in the <code>wheel</code> group. It is also possible, when using an authentication method such as Kerberos, to use Kerberos' <span class=filename>.k5login</span> file in the <code>root</code> account to allow a <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> to <code>root</code> without having to place anyone at all in the <code>wheel</code> group. This may be the better solution since the <code>wheel</code> mechanism still allows an intruder to break <code>root</code> if the intruder has gotten hold of your password file and can break into a staff account. While having the <code>wheel</code> mechanism is better than having nothing at all, it is not necessarily the safest option.</p></div><div class=paragraph><p>An indirect way to secure staff accounts, and ultimately <code>root</code> access is to use an alternative login access method and do what is known as "starring" out the encrypted password for the staff accounts. Using the <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> command, one can replace each instance of an encrypted password with a single “*” character. This command will update the <span class=filename>/etc/master.passwd</span> file and user/password database to disable password-authenticated logins.</p></div><div class=paragraph><p>A staff account entry such as:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>Should be changed to this:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>This change will prevent normal logins from occurring, since the encrypted password will never match “*”. With this done, staff members must use another mechanism to authenticate themselves such as <a href="https://man.freebsd.org/cgi/man.cgi?query=kerberos&amp;sektion=1&amp;format=html">kerberos(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> using a public/private key pair. When using something like Kerberos, one generally must secure the machines which run the Kerberos servers and your desktop workstation. When using a public/private key pair with ssh, one must generally secure the machine used to login <em>from</em> (typically one’s workstation). An additional layer of protection can be added to the key pair by password protecting the key pair when creating it with <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>. Being able to "star" out the passwords for staff accounts also guarantees that staff members can only login through secure access methods that you have set up. This forces all staff members to use secure, encrypted connections for all of their sessions, which closes an important hole used by many intruders: sniffing the network from an unrelated, less secure machine.</p></div><div class=paragraph><p>The more indirect security mechanisms also assume that you are logging in from a more restrictive server to a less restrictive server. For example, if your main box is running all sorts of servers, your workstation should not be running any. In order for your workstation to be reasonably secure you should run as few servers as possible, up to and including no servers at all, and you should run a password-protected screen blanker. Of course, given physical access to a workstation an attacker can break any sort of security you put on it. This is definitely a problem that you should consider, but you should also consider the fact that the vast majority of break-ins occur remotely, over a network, from people who do not have physical access to your workstation or servers.</p></div><div class=paragraph><p>Using something like Kerberos also gives you the ability to disable or change the password for a staff account in one place, and have it immediately affect all the machines on which the staff member may have an account. If a staff member’s account gets compromised, the ability to instantly change his password on all machines should not be underrated. With discrete passwords, changing a password on N machines can be a mess. You can also impose re-passwording restrictions with Kerberos: not only can a Kerberos ticket be made to timeout after a while, but the Kerberos system can require that the user choose a new password after a certain period of time (say, once a month).</p></div></div><div class=sect2><h3 id=_securing_root_run_servers_and_suidsgid_binaries>15.3.2. Securing Root-run Servers and SUID/SGID Binaries<a class=anchor href=#_securing_root_run_servers_and_suidsgid_binaries></a></h3><div class=paragraph><p>The prudent sysadmin only runs the servers he needs to, no more, no less. Be aware that third party servers are often the most bug-prone. For example, running an old version of imapd or popper is like giving a universal <code>root</code> ticket out to the entire world. Never run a server that you have not checked out carefully. Many servers do not need to be run as <code>root</code>. For example, the ntalk, comsat, and finger daemons can be run in special user <em>sandboxes</em>. A sandbox is not perfect, unless you go through a large amount of trouble, but the onion approach to security still stands: If someone is able to break in through a server running in a sandbox, they still have to break out of the sandbox. The more layers the attacker must break through, the lower the likelihood of his success. Root holes have historically been found in virtually every server ever run as <code>root</code>, including basic system servers. If you are running a machine through which people only login via sshd and never login via telnetd or rshd or rlogind, then turn off those services!</p></div><div class=paragraph><p>FreeBSD now defaults to running ntalkd, comsat, and finger in a sandbox. Another program which may be a candidate for running in a sandbox is <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. <span class=filename>/etc/defaults/rc.conf</span> includes the arguments necessary to run named in a sandbox in a commented-out form. Depending on whether you are installing a new system or upgrading an existing system, the special user accounts used by these sandboxes may not be installed. The prudent sysadmin would research and implement sandboxes for servers whenever possible.</p></div><div class=paragraph><p>There are a number of other servers that typically do not run in sandboxes: sendmail, popper, imapd, ftpd, and others. There are alternatives to some of these, but installing them may require more work than you are willing to perform (the convenience factor strikes again). You may have to run these servers as <code>root</code> and rely on other mechanisms to detect break-ins that might occur through them.</p></div><div class=paragraph><p>The other big potential <code>root</code> holes in a system are the suid-root and sgid binaries installed on the system. Most of these binaries, such as rlogin, reside in <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span>, or <span class=filename>/usr/sbin</span>. While nothing is 100% safe, the system-default suid and sgid binaries can be considered reasonably safe. Still, <code>root</code> holes are occasionally found in these binaries. A <code>root</code> hole was found in <code>Xlib</code> in 1998 that made xterm (which is typically suid) vulnerable. It is better to be safe than sorry and the prudent sysadmin will restrict suid binaries, that only staff should run, to a special group that only staff can access, and get rid of (<code>chmod 000</code>) any suid binaries that nobody uses. A server with no display generally does not need an xterm binary. Sgid binaries can be almost as dangerous. If an intruder can break an sgid-kmem binary, the intruder might be able to read <span class=filename>/dev/kmem</span> and thus read the encrypted password file, potentially compromising any passworded account. Alternatively an intruder who breaks group <code>kmem</code> can monitor keystrokes sent through ptys, including ptys used by users who login through secure methods. An intruder that breaks the <code>tty</code> group can write to almost any user’s tty. If a user is running a terminal program or emulator with a keyboard-simulation feature, the intruder can potentially generate a data stream that causes the user’s terminal to echo a command, which is then run as that user.</p></div></div><div class=sect2><h3 id=secure-users>15.3.3. Securing User Accounts<a class=anchor href=#secure-users></a></h3><div class=paragraph><p>User accounts are usually the most difficult to secure. While you can impose draconian access restrictions on your staff and "star" out their passwords, you may not be able to do so with any general user accounts you might have. If you do have sufficient control, then you may win out and be able to secure the user accounts properly. If not, you simply have to be more vigilant in your monitoring of those accounts. Use of ssh and Kerberos for user accounts is more problematic, due to the extra administration and technical support required, but still a very good solution compared to a encrypted password file.</p></div></div><div class=sect2><h3 id=_securing_the_password_file>15.3.4. Securing the Password File<a class=anchor href=#_securing_the_password_file></a></h3><div class=paragraph><p>The only sure fire way is to star out as many passwords as you can and use ssh or Kerberos for access to those accounts. Even though the encrypted password file (<span class=filename>/etc/spwd.db</span>) can only be read by <code>root</code>, it may be possible for an intruder to obtain read access to that file even if the attacker cannot obtain root-write access.</p></div><div class=paragraph><p>Your security scripts should always check for and report changes to the password file (see the <a href=#security-integrity>Checking file integrity</a> section below).</p></div></div><div class=sect2><h3 id=_securing_the_kernel_core_raw_devices_and_file_systems>15.3.5. Securing the Kernel Core, Raw Devices, and File systems<a class=anchor href=#_securing_the_kernel_core_raw_devices_and_file_systems></a></h3><div class=paragraph><p>If an attacker breaks <code>root</code> he can do just about anything, but there are certain conveniences. For example, most modern kernels have a packet sniffing device driver built in. Under FreeBSD it is called the <span class=filename>bpf</span> device. An intruder will commonly attempt to run a packet sniffer on a compromised machine. You do not need to give the intruder the capability and most systems do not have the need for the <span class=filename>bpf</span> device compiled in.</p></div><div class=paragraph><p>But even if you turn off the <span class=filename>bpf</span> device, you still have <span class=filename>/dev/mem</span> and <span class=filename>/dev/kmem</span> to worry about. For that matter, the intruder can still write to raw disk devices. Also, there is another kernel feature called the module loader, <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. An enterprising intruder can use a KLD module to install his own <span class=filename>bpf</span> device, or other sniffing device, on a running kernel. To avoid these problems you have to run the kernel at a higher secure level, at least securelevel 1. The securelevel can be set with a <code>sysctl</code> on the <code>kern.securelevel</code> variable. Once you have set the securelevel to 1, write access to raw devices will be denied and special <code>chflags</code> flags, such as <code>schg</code>, will be enforced. You must also ensure that the <code>schg</code> flag is set on critical startup binaries, directories, and script files - everything that gets run up to the point where the securelevel is set. This might be overdoing it, and upgrading the system is much more difficult when you operate at a higher secure level. You may compromise and run the system at a higher secure level but not set the <code>schg</code> flag for every system file and directory under the sun. Another possibility is to simply mount <span class=filename>/</span> and <span class=filename>/usr</span> read-only. It should be noted that being too draconian in what you attempt to protect may prevent the all-important detection of an intrusion.</p></div></div><div class=sect2><h3 id=security-integrity>15.3.6. Checking File Integrity: Binaries, Configuration Files, Etc.<a class=anchor href=#security-integrity></a></h3><div class=paragraph><p>When it comes right down to it, you can only protect your core system configuration and control files so much before the convenience factor rears its ugly head. For example, using <code>chflags</code> to set the <code>schg</code> bit on most of the files in <span class=filename>/</span> and <span class=filename>/usr</span> is probably counterproductive, because while it may protect the files, it also closes a detection window. The last layer of your security onion is perhaps the most important - detection. The rest of your security is pretty much useless (or, worse, presents you with a false sense of security) if you cannot detect potential intrusions. Half the job of the onion is to slow down the attacker, rather than stop him, in order to be able to catch him in the act.</p></div><div class=paragraph><p>The best way to detect an intrusion is to look for modified, missing, or unexpected files. The best way to look for modified files is from another (often centralized) limited-access system. Writing your security scripts on the extra-secure limited-access system makes them mostly invisible to potential attackers, and this is important. In order to take maximum advantage you generally have to give the limited-access box significant access to the other machines in the business, usually either by doing a read-only NFS export of the other machines to the limited-access box, or by setting up ssh key-pairs to allow the limited-access box to ssh to the other machines. Except for its network traffic, NFS is the least visible method - allowing you to monitor the file systems on each client box virtually undetected. If your limited-access server is connected to the client boxes through a switch, the NFS method is often the better choice. If your limited-access server is connected to the client boxes through a hub, or through several layers of routing, the NFS method may be too insecure (network-wise) and using ssh may be the better choice even with the audit-trail tracks that ssh lays.</p></div><div class=paragraph><p>Once you have given a limited-access box at least read access to the client systems it is supposed to monitor, you must write scripts to do the actual monitoring. Given an NFS mount, you can write scripts out of simple system utilities such as <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=md5&amp;sektion=1&amp;format=html">md5(1)</a>. It is best to physically md5 the client-box files at least once a day, and to test control files such as those found in <span class=filename>/etc</span> and <span class=filename>/usr/local/etc</span> even more often. When mismatches are found, relative to the base md5 information the limited-access machine knows is valid, it should scream at a sysadmin to go check it out. A good security script will also check for inappropriate suid binaries and for new or deleted files on system partitions such as <span class=filename>/</span> and <span class=filename>/usr</span>.</p></div><div class=paragraph><p>When using ssh rather than NFS, writing the security script is much more difficult. You essentially have to <code>scp</code> the scripts to the client box in order to run them, making them visible, and for safety you also need to <code>scp</code> the binaries (such as find) that those scripts use. The ssh client on the client box may already be compromised. All in all, using ssh may be necessary when running over insecure links, but it is also a lot harder to deal with.</p></div><div class=paragraph><p>A good security script will also check for changes to user and staff members access configuration files: <span class=filename>.rhosts</span>, <span class=filename>.shosts</span>, <span class=filename>.ssh/authorized_keys</span> and so forth, files that might fall outside the purview of the <code>MD5</code> check.</p></div><div class=paragraph><p>If you have a huge amount of user disk space, it may take too long to run through every file on those partitions. In this case, setting mount flags to disallow suid binaries and devices on those partitions is a good idea. The <code>nodev</code> and <code>nosuid</code> options (see <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>) are what you want to look into. You should probably scan them anyway, at least once a week, since the object of this layer is to detect a break-in attempt, whether or not the attempt succeeds.</p></div><div class=paragraph><p>Process accounting (see <a href="https://man.freebsd.org/cgi/man.cgi?query=accton&amp;sektion=8&amp;format=html">accton(8)</a>) is a relatively low-overhead feature of the operating system which might help as a post-break-in evaluation mechanism. It is especially useful in tracking down how an intruder has actually broken into a system, assuming the file is still intact after the break-in has occurred.</p></div><div class=paragraph><p>Finally, security scripts should process the log files, and the logs themselves should be generated in as secure a manner as possible - remote syslog can be very useful. An intruder will try to cover his tracks, and log files are critical to the sysadmin trying to track down the time and method of the initial break-in. One way to keep a permanent record of the log files is to run the system console to a serial port and collect the information to a secure machine monitoring the consoles.</p></div></div><div class=sect2><h3 id=_paranoia>15.3.7. Paranoia<a class=anchor href=#_paranoia></a></h3><div class=paragraph><p>A little paranoia never hurts. As a rule, a sysadmin can add any number of security features, as long as they do not affect convenience, and can add security features that <em>do</em> affect convenience with some added thought. Even more importantly, a security administrator should mix it up a bit - if you use recommendations such as those given by this document verbatim, you give away your methodologies to the prospective attacker who also has access to this document.</p></div></div><div class=sect2><h3 id=_denial_of_service_attacks>15.3.8. Denial of Service Attacks<a class=anchor href=#_denial_of_service_attacks></a></h3><div class=paragraph><p>This section covers Denial of Service attacks. A DoS attack is typically a packet attack. While there is not much you can do about modern spoofed packet attacks that saturate your network, you can generally limit the damage by ensuring that the attacks cannot take down your servers by:</p></div><div class="olist arabic"><ol class=arabic><li><p>Limiting server forks.</p></li><li><p>Limiting springboard attacks (ICMP response attacks, ping broadcast, etc.).</p></li><li><p>Overloading the Kernel Route Cache.</p></li></ol></div><div class=paragraph><p>A common DoS attack scenario is attacking a forking server and making it spawning so many child processes that the host system eventually runs out of memory, file descriptors, etc. and then grinds to a halt. inetd (see <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>) has several options to limit this sort of attack. It should be noted that while it is possible to prevent a machine from going down, it is not generally possible to prevent a service from being disrupted by the attack. Read the inetd manual page carefully and pay specific attention to the <code>-c</code>, <code>-C</code>, and <code>-R</code> options. Note that spoofed-IP attacks will circumvent the <code>-C</code> option to inetd, so typically a combination of options must be used. Some standalone servers have self-fork-limitation parameters.</p></div><div class=paragraph><p>Sendmail has its <code>-OMaxDaemonChildren</code> option, which tends to work much better than trying to use Sendmail’s load limiting options due to the load lag. You should specify a <code>MaxDaemonChildren</code> parameter, when you start sendmail; high enough to handle your expected load, but not so high that the computer cannot handle that number of Sendmail instances without falling on its face. It is also prudent to run Sendmail in queued mode (<code>-ODeliveryMode=queued</code>) and to run the daemon (<code>sendmail -bd</code>) separate from the queue-runs (<code>sendmail -q15m</code>). If you still want real-time delivery you can run the queue at a much lower interval, such as <code>-q1m</code>, but be sure to specify a reasonable <code>MaxDaemonChildren</code> option for <em>that</em> Sendmail to prevent cascade failures.</p></div><div class=paragraph><p>Syslogd can be attacked directly and it is strongly recommended that you use the <code>-s</code> option whenever possible, and the <code>-a</code> option otherwise.</p></div><div class=paragraph><p>You should also be fairly careful with connect-back services such as TCP Wrapper’s reverse-identd, which can be attacked directly. You generally do not want to use the reverse-ident feature of TCP Wrapper for this reason.</p></div><div class=paragraph><p>It is a very good idea to protect internal services from external access by firewalling them off at your border routers. The idea here is to prevent saturation attacks from outside your LAN, not so much to protect internal services from network-based <code>root</code> compromise. Always configure an exclusive firewall, i.e., "firewall everything <em>except</em> ports A, B, C, D, and M-Z". This way you can firewall off all of your low ports except for certain specific services such as named (if you are primary for a zone), ntalkd, sendmail, and other Internet-accessible services. If you try to configure the firewall the other way - as an inclusive or permissive firewall, there is a good chance that you will forget to "close" a couple of services, or that you will add a new internal service and forget to update the firewall. You can still open up the high-numbered port range on the firewall, to allow permissive-like operation, without compromising your low ports. Also take note that FreeBSD allows you to control the range of port numbers used for dynamic binding, via the various <code>net.inet.ip.portrange sysctl</code>'s (<code>sysctl -a | fgrep portrange</code>), which can also ease the complexity of your firewall’s configuration. For example, you might use a normal first/last range of 4000 to 5000, and a hiport range of 49152 to 65535, then block off everything under 4000 in your firewall (except for certain specific Internet-accessible ports, of course).</p></div><div class=paragraph><p>Another common DoS attack is called a springboard attack - to attack a server in a manner that causes the server to generate responses which overloads the server, the local network, or some other machine. The most common attack of this nature is the <em>ICMP ping broadcast attack</em>. The attacker spoofs ping packets sent to your LAN’s broadcast address with the source IP address set to the actual machine they wish to attack. If your border routers are not configured to stomp on ping packets to broadcast addresses, your LAN winds up generating sufficient responses to the spoofed source address to saturate the victim, especially when the attacker uses the same trick on several dozen broadcast addresses over several dozen different networks at once. Broadcast attacks of over a hundred and twenty megabits have been measured. A second common springboard attack is against the ICMP error reporting system. By constructing packets that generate ICMP error responses, an attacker can saturate a server’s incoming network and cause the server to saturate its outgoing network with ICMP responses. This type of attack can also crash the server by running it out of memory, especially if the server cannot drain the ICMP responses it generates fast enough. Use the sysctl variable <code>net.inet.icmp.icmplim</code> to limit these attacks. The last major class of springboard attacks is related to certain internal inetd services such as the udp echo service. An attacker simply spoofs a UDP packet with the source address being server A’s echo port, and the destination address being server B’s echo port, where server A and B are both on your LAN. The two servers then bounce this one packet back and forth between each other. The attacker can overload both servers and their LANs simply by injecting a few packets in this manner. Similar problems exist with the internal chargen port. A competent sysadmin will turn off all of these inetd-internal test services.</p></div><div class=paragraph><p>Spoofed packet attacks may also be used to overload the kernel route cache. Refer to the <code>net.inet.ip.rtexpire</code>, <code>rtminexpire</code>, and <code>rtmaxcache sysctl</code> parameters. A spoofed packet attack that uses a random source IP will cause the kernel to generate a temporary cached route in the route table, viewable with <code>netstat -rna | fgrep W3</code>. These routes typically timeout in 1600 seconds or so. If the kernel detects that the cached route table has gotten too big it will dynamically reduce the <code>rtexpire</code> but will never decrease it to less than <code>rtminexpire</code>. There are two problems:</p></div><div class="olist arabic"><ol class=arabic><li><p>The kernel does not react quickly enough when a lightly loaded server is suddenly attacked.</p></li><li><p>The <code>rtminexpire</code> is not low enough for the kernel to survive a sustained attack.</p></li></ol></div><div class=paragraph><p>If your servers are connected to the Internet via a T3 or better, it may be prudent to manually override both <code>rtexpire</code> and <code>rtminexpire</code> via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Never set either parameter to zero (unless you want to crash the machine). Setting both parameters to 2 seconds should be sufficient to protect the route table from attack.</p></div></div><div class=sect2><h3 id=_access_issues_with_kerberos_and_ssh>15.3.9. Access Issues with Kerberos and SSH<a class=anchor href=#_access_issues_with_kerberos_and_ssh></a></h3><div class=paragraph><p>There are a few issues with both Kerberos and ssh that need to be addressed if you intend to use them. Kerberos 5 is an excellent authentication protocol, but there are bugs in the kerberized telnet and rlogin applications that make them unsuitable for dealing with binary streams. Also, by default Kerberos does not encrypt a session unless you use the <code>-x</code> option. ssh encrypts everything by default.</p></div><div class=paragraph><p>Ssh works quite well in every respect except that it forwards encryption keys by default. What this means is that if you have a secure workstation holding keys that give you access to the rest of the system, and you ssh to an insecure machine, your keys are usable. The actual keys themselves are not exposed, but ssh installs a forwarding port for the duration of your login, and if an attacker has broken <code>root</code> on the insecure machine he can utilize that port to use your keys to gain access to any other machine that your keys unlock.</p></div><div class=paragraph><p>We recommend that you use ssh in combination with Kerberos whenever possible for staff logins. Ssh can be compiled with Kerberos support. This reduces your reliance on potentially exposed ssh keys while at the same time protecting passwords via Kerberos. Ssh keys should only be used for automated tasks from secure machines (something that Kerberos is unsuited to do). We also recommend that you either turn off key-forwarding in the ssh configuration, or that you make use of the <code>from=IP/DOMAIN</code> option that ssh allows in its <span class=filename>authorized_keys</span> file to make the key only usable to entities logging in from specific machines.</p></div></div></div></div><div class=sect1><h2 id=crypt>15.4. DES, MD5, and Crypt<a class=anchor href=#crypt></a></h2><div class=sectionbody><div class=paragraph><p>Every user on a UNIX® system has a password associated with their account. It seems obvious that these passwords need to be known only to the user and the actual operating system. In order to keep these passwords secret, they are encrypted with what is known as a "one-way hash", that is, they can only be easily encrypted but not decrypted. In other words, what we told you a moment ago was obvious is not even true: the operating system itself does not <em>really</em> know the password. It only knows the <em>encrypted</em> form of the password. The only way to get the "plain-text" password is by a brute force search of the space of possible passwords.</p></div><div class=paragraph><p>Unfortunately the only secure way to encrypt passwords when UNIX® came into being was based on DES, the Data Encryption Standard. This was not such a problem for users resident in the US, but since the source code for DES could not be exported outside the US, FreeBSD had to find a way to both comply with US law and retain compatibility with all the other UNIX® variants that still used DES.</p></div><div class=paragraph><p>The solution was to divide up the encryption libraries so that US users could install the DES libraries and use DES but international users still had an encryption method that could be exported abroad. This is how FreeBSD came to use MD5 as its default encryption method. MD5 is believed to be more secure than DES, so installing DES is offered primarily for compatibility reasons.</p></div><div class=sect2><h3 id=_recognizing_your_crypt_mechanism>15.4.1. Recognizing Your Crypt Mechanism<a class=anchor href=#_recognizing_your_crypt_mechanism></a></h3><div class=paragraph><p>Currently the library supports DES, MD5 and Blowfish hash functions. By default FreeBSD uses MD5 to encrypt passwords.</p></div><div class=paragraph><p>It is pretty easy to identify which encryption method FreeBSD is set up to use. Examining the encrypted passwords in the <span class=filename>/etc/master.passwd</span> file is one way. Passwords encrypted with the MD5 hash are longer than those encrypted with the DES hash and also begin with the characters <code>$1$</code>. Passwords starting with <code>$2a$</code> are encrypted with the Blowfish hash function. DES password strings do not have any particular identifying characteristics, but they are shorter than MD5 passwords, and are coded in a 64-character alphabet which does not include the <code>$</code> character, so a relatively short string which does not begin with a dollar sign is very likely a DES password.</p></div><div class=paragraph><p>The password format used for new passwords is controlled by the <code>passwd_format</code> login capability in <span class=filename>/etc/login.conf</span>, which takes values of <code>des</code>, <code>md5</code> or <code>blf</code>. See the <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> manual page for more information about login capabilities.</p></div></div></div></div><div class=sect1><h2 id=one-time-passwords>15.5. One-time Passwords<a class=anchor href=#one-time-passwords></a></h2><div class=sectionbody><div class=paragraph><p>By default, FreeBSD includes support for OPIE (One-time Passwords In Everything), which uses the MD5 hash by default.</p></div><div class=paragraph><p>There are three different sorts of passwords which we will discuss below. The first is your usual UNIX® style or Kerberos password; we will call this a "UNIX® password". The second sort is the one-time password which is generated by the OPIE <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> program and accepted by the <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> program and the login prompt; we will call this a "one-time password". The final sort of password is the secret password which you give to the <code>opiekey</code> program (and sometimes the <code>opiepasswd</code> programs) which it uses to generate one-time passwords; we will call it a "secret password" or just unqualified "password".</p></div><div class=paragraph><p>The secret password does not have anything to do with your UNIX® password; they can be the same but this is not recommended. OPIE secret passwords are not limited to 8 characters like old UNIX® passwords, they can be as long as you like. Passwords of six or seven word long phrases are fairly common. For the most part, the OPIE system operates completely independently of the UNIX® password system.</p></div><div class=paragraph><p>Besides the password, there are two other pieces of data that are important to OPIE. One is what is known as the "seed" or "key", consisting of two letters and five digits. The other is what is called the "iteration count", a number between 1 and 100. OPIE creates the one-time password by concatenating the seed and the secret password, then applying the MD5 hash as many times as specified by the iteration count and turning the result into six short English words. These six English words are your one-time password. The authentication system (primarily PAM) keeps track of the last one-time password used, and the user is authenticated if the hash of the user-provided password is equal to the previous password. Because a one-way hash is used it is impossible to generate future one-time passwords if a successfully used password is captured; the iteration count is decremented after each successful login to keep the user and the login program in sync. When the iteration count gets down to 1, OPIE must be reinitialized.</p></div><div class=paragraph><p>There are a few programs involved in each system which we will discuss below. The <code>opiekey</code> program accepts an iteration count, a seed, and a secret password, and generates a one-time password or a consecutive list of one-time passwords. The <code>opiepasswd</code> program is used to initialize OPIE, and to change passwords, iteration counts, or seeds; it takes either a secret passphrase, or an iteration count, seed, and a one-time password. The <code>opieinfo</code> program will examine the relevant credentials files (<span class=filename>/etc/opiekeys</span>) and print out the invoking user’s current iteration count and seed.</p></div><div class=paragraph><p>There are four different sorts of operations we will cover. The first is using <code>opiepasswd</code> over a secure connection to set up one-time-passwords for the first time, or to change your password or seed. The second operation is using <code>opiepasswd</code> over an insecure connection, in conjunction with <code>opiekey</code> over a secure connection, to do the same. The third is using <code>opiekey</code> to log in over an insecure connection. The fourth is using <code>opiekey</code> to generate a number of keys which can be written down or printed out to carry with you when going to some location without secure connections to anywhere.</p></div><div class=sect2><h3 id=_secure_connection_initialization>15.5.1. Secure Connection Initialization<a class=anchor href=#_secure_connection_initialization></a></h3><div class=paragraph><p>To initialize OPIE for the first time, execute the <code>opiepasswd</code> command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>At the <code>Enter new secret pass phrase:</code> or <code>Enter secret password:</code> prompts, you should enter a password or phrase. Remember, this is not the password that you will use to login with, this is used to generate your one-time login keys. The "ID" line gives the parameters of your particular instance: your login name, the iteration count, and seed. When logging in the system will remember these parameters and present them back to you so you do not have to remember them. The last line gives the particular one-time password which corresponds to those parameters and your secret password; if you were to re-login immediately, this one-time password is the one you would use.</p></div></div><div class=sect2><h3 id=_insecure_connection_initialization>15.5.2. Insecure Connection Initialization<a class=anchor href=#_insecure_connection_initialization></a></h3><div class=paragraph><p>To initialize or change your secret password over an insecure connection, you will need to already have a secure connection to some place where you can run <code>opiekey</code>; this might be in the form of a shell prompt on a machine you trust. You will also need to make up an iteration count (100 is probably a good value), and you may make up your own seed or use a randomly-generated one. Over on the insecure connection (to the machine you are initializing), use <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>To accept the default seed press <kbd>Return</kbd>. Then before entering an access password, move over to your secure connection and give it the same parameters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</span></code></pre></div></div><div class=paragraph><p>Now switch back over to the insecure connection, and copy the one-time password generated over to the relevant program.</p></div></div><div class=sect2><h3 id=_generating_a_single_one_time_password>15.5.3. Generating a Single One-time Password<a class=anchor href=#_generating_a_single_one_time_password></a></h3><div class=paragraph><p>Once you have initialized OPIE and login, you will be presented with a prompt like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>As a side note, the OPIE prompts have a useful feature (not shown here): if you press <kbd>Return</kbd> at the password prompt, the prompter will turn echo on, so you can see what you are typing. This can be extremely useful if you are attempting to type in a password by hand, such as from a printout.</p></div><div class=paragraph><p>At this point you need to generate your one-time password to answer this login prompt. This must be done on a trusted system that you can run <code>opiekey</code> on. (There are versions of these for DOS, Windows® and Mac OS® as well.) They need the iteration count and the seed as command line options. You can cut-and-paste these right from the login prompt on the machine that you are logging in to.</p></div><div class=paragraph><p>On the trusted system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Now that you have your one-time password you can continue logging in.</p></div></div><div class=sect2><h3 id=_generating_multiple_one_time_passwords>15.5.4. Generating Multiple One-time Passwords<a class=anchor href=#_generating_multiple_one_time_passwords></a></h3><div class=paragraph><p>Sometimes you have to go places where you do not have access to a trusted machine or secure connection. In this case, it is possible to use the <code>opiekey</code> command to generate a number of one-time passwords beforehand to be printed out and taken with you. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</span></code></pre></div></div><div class=paragraph><p>The <code>-n 5</code> requests five keys in sequence, the <code>30</code> specifies what the last iteration number should be. Note that these are printed out in <em>reverse</em> order of eventual use. If you are really paranoid, you might want to write the results down by hand; otherwise you can cut-and-paste into <code>lpr</code>. Note that each line shows both the iteration count and the one-time password; you may still find it handy to scratch off passwords as you use them.</p></div></div><div class=sect2><h3 id=_restricting_use_of_unix_passwords>15.5.5. Restricting Use of UNIX® Passwords<a class=anchor href=#_restricting_use_of_unix_passwords></a></h3><div class=paragraph><p>OPIE can restrict the use of UNIX® passwords based on the IP address of a login session. The relevant file is <span class=filename>/etc/opieaccess</span>, which is present by default. Please check <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> for more information on this file and which security considerations you should be aware of when using it.</p></div><div class=paragraph><p>Here is a sample <span class=filename>opieaccess</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>This line allows users whose IP source address (which is vulnerable to spoofing) matches the specified value and mask, to use UNIX® passwords at any time.</p></div><div class=paragraph><p>If no rules in <span class=filename>opieaccess</span> are matched, the default is to deny non-OPIE logins.</p></div></div></div></div><div class=sect1><h2 id=tcpwrappers>15.6. TCP Wrappers<a class=anchor href=#tcpwrappers></a></h2><div class=sectionbody><div class=paragraph><p>Anyone familiar with <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> has probably heard of TCP Wrappers at some point. But few individuals seem to fully comprehend its usefulness in a network environment. It seems that everyone wants to install a firewall to handle network connections. While a firewall has a wide variety of uses, there are some things that a firewall not handle such as sending text back to the connection originator. The TCP software does this and much more. In the next few sections many of the TCP Wrappers features will be discussed, and, when applicable, example configuration lines will be provided.</p></div><div class=paragraph><p>The TCP Wrappers software extends the abilities of <code>inetd</code> to provide support for every server daemon under its control. Using this method it is possible to provide logging support, return messages to connections, permit a daemon to only accept internal connections, etc. While some of these features can be provided by implementing a firewall, this will add not only an extra layer of protection but go beyond the amount of control a firewall can provide.</p></div><div class=paragraph><p>The added functionality of TCP Wrappers should not be considered a replacement for a good firewall. TCP Wrappers can be used in conjunction with a firewall or other security enhancements though and it can serve nicely as an extra layer of protection for the system.</p></div><div class=paragraph><p>Since this is an extension to the configuration of <code>inetd</code>, the reader is expected have read the <a href=../network-servers/#network-inetd>inetd configuration</a> section.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While programs run by <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> are not exactly "daemons", they have traditionally been called daemons. This is the term we will use in this section too.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_initial_configuration>15.6.1. Initial Configuration<a class=anchor href=#_initial_configuration></a></h3><div class=paragraph><p>The only requirement of using TCP Wrappers in FreeBSD is to ensure the <code>inetd</code> server is started from <span class=filename>rc.conf</span> with the <code>-Ww</code> option; this is the default setting. Of course, proper configuration of <span class=filename>/etc/hosts.allow</span> is also expected, but <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> will throw messages in the system logs in these cases.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Unlike other implementations of TCP Wrappers, the use of <span class=filename>hosts.deny</span> has been deprecated. All configuration options should be placed in <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In the simplest configuration, daemon connection policies are set to either be permitted or blocked depending on the options in <span class=filename>/etc/hosts.allow</span>. The default configuration in FreeBSD is to allow a connection to every daemon started with <code>inetd</code>. Changing this will be discussed only after the basic configuration is covered.</p></div><div class=paragraph><p>Basic configuration usually takes the form of <code>daemon : address : action</code>. Where <code>daemon</code> is the daemon name which <code>inetd</code> started. The <code>address</code> can be a valid hostname, an IP address or an IPv6 address enclosed in brackets ([ ]). The action field can be either allow or deny to grant or deny access appropriately. Keep in mind that configuration works off a first rule match semantic, meaning that the configuration file is scanned in ascending order for a matching rule. When a match is found the rule is applied and the search process will halt.</p></div><div class=paragraph><p>Several other options exist but they will be explained in a later section. A simple configuration line may easily be constructed from that information alone. For example, to allow POP3 connections via the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a> daemon, the following lines should be appended to <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>After adding this line, <code>inetd</code> will need restarted. This can be accomplished by use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> command, or with the <span class=parameter>restart</span> parameter with <span class=filename>/etc/rc.d/inetd</span>.</p></div></div><div class=sect2><h3 id=_advanced_configuration>15.6.2. Advanced Configuration<a class=anchor href=#_advanced_configuration></a></h3><div class=paragraph><p>TCP Wrappers has advanced options too; they will allow for more control over the way connections are handled. In some cases it may be a good idea to return a comment to certain hosts or daemon connections. In other cases, perhaps a log file should be recorded or an email sent to the administrator. Other situations may require the use of a service for local connections only. This is all possible through the use of configuration options known as <code>wildcards</code>, expansion characters and external command execution. The next two sections are written to cover these situations.</p></div><div class=sect3><h4 id=_external_commands>15.6.2.1. External Commands<a class=anchor href=#_external_commands></a></h4><div class=paragraph><p>Suppose that a situation occurs where a connection should be denied yet a reason should be sent to the individual who attempted to establish that connection. How could it be done? That action can be made possible by using the <code>twist</code> option. When a connection attempt is made, <code>twist</code> will be called to execute a shell command or script. An example already exists in the <span class=filename>hosts.allow</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>This example shows that the message, "You are not allowed to use <code>daemon</code> from <code>hostname</code>." will be returned for any daemon not previously configured in the access file. This is extremely useful for sending a reply back to the connection initiator right after the established connection is dropped. Note that any message returned <em>must</em> be wrapped in quote <code>"</code> characters; there are no exceptions to this rule.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>It may be possible to launch a denial of service attack on the server if an attacker, or group of attackers could flood these daemons with connection requests.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Another possibility is to use the <code>spawn</code> option in these cases. Like <code>twist</code>, the <code>spawn</code> implicitly denies the connection and may be used to run external shell commands or scripts. Unlike <code>twist</code>, <code>spawn</code> will not send a reply back to the individual who established the connection. For an example, consider the following configuration line:</p></div><div class="literalblock programlisting"><div class=content><pre># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>This will deny all connection attempts from the <code>*.example.com</code> domain; simultaneously logging the hostname, IP address and the daemon which they attempted to access in the <span class=filename>/var/log/connections.log</span> file.</p></div><div class=paragraph><p>Aside from the already explained substitution characters above, e.g. %a, a few others exist. See the <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> manual page for the complete list.</p></div></div><div class=sect3><h4 id=_wildcard_options>15.6.2.2. Wildcard Options<a class=anchor href=#_wildcard_options></a></h4><div class=paragraph><p>Thus far the <code>ALL</code> example has been used continuously throughout the examples. Other options exist which could extend the functionality a bit further. For instance, <code>ALL</code> may be used to match every instance of either a daemon, domain or an IP address. Another wildcard available is <code>PARANOID</code> which may be used to match any host which provides an IP address that may be forged. In other words, <code>paranoid</code> may be used to define an action to be taken whenever a connection is made from an IP address that differs from its hostname. The following example may shed some more light on this discussion:</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class=paragraph><p>In that example all connection requests to <code>sendmail</code> which have an IP address that varies from its hostname will be denied.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Using the <code>PARANOID</code> may severely cripple servers if the client or server has a broken DNS setup. Administrator discretion is advised.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To learn more about wildcards and their associated functionality, see the <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> manual page.</p></div><div class=paragraph><p>Before any of the specific configuration lines above will work, the first configuration line should be commented out in <span class=filename>hosts.allow</span>. This was noted at the beginning of this section.</p></div></div></div></div></div><div class=sect1><h2 id=kerberosIV>15.7. KerberosIV<a class=anchor href=#kerberosIV></a></h2><div class=sectionbody><div class=paragraph><p>Kerberos is a network add-on system/protocol that allows users to authenticate themselves through the services of a secure server. Services such as remote login, remote copy, secure inter-system file copying and other high-risk tasks are made considerably safer and more controllable.</p></div><div class=paragraph><p>The following instructions can be used as a guide on how to set up Kerberos as distributed for FreeBSD. However, you should refer to the relevant manual pages for a complete description.</p></div><div class=sect2><h3 id=_installing_kerberosiv>15.7.1. Installing KerberosIV<a class=anchor href=#_installing_kerberosiv></a></h3><div class=paragraph><p>Kerberos is an optional component of FreeBSD. The easiest way to install this software is by selecting the <code>krb4</code> or <code>krb5</code> distribution in sysinstall during the initial installation of FreeBSD. This will install the "eBones" (KerberosIV) or "Heimdal" (Kerberos5) implementation of Kerberos. These implementations are included because they are developed outside the USA/Canada and were thus available to system owners outside those countries during the era of restrictive export controls on cryptographic code from the USA.</p></div><div class=paragraph><p>Alternatively, the MIT implementation of Kerberos is available from the Ports Collection as <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>.</p></div></div><div class=sect2><h3 id=_creating_the_initial_database>15.7.2. Creating the Initial Database<a class=anchor href=#_creating_the_initial_database></a></h3><div class=paragraph><p>This is done on the Kerberos server only. First make sure that you do not have any old Kerberos databases around. You should change to the directory <span class=filename>/etc/kerberosIV</span> and check that only the following files are present:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>d /etc/kerberosIV
<span class=c># ls</span>
README		krb.conf        krb.realms</code></pre></div></div><div class=paragraph><p>If any additional files (such as <span class=filename>principal.*</span> or <span class=filename>master_key</span>) exist, then use the <code>kdb_destroy</code> command to destroy the old Kerberos database, or if Kerberos is not running, simply delete the extra files.</p></div><div class=paragraph><p>You should now edit the <span class=filename>krb.conf</span> and <span class=filename>krb.realms</span> files to define your Kerberos realm. In this case the realm will be <code>EXAMPLE.COM</code> and the server is <code>grunt.example.com</code>. We edit or create the <span class=filename>krb.conf</span> file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.conf</span>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</code></pre></div></div><div class=paragraph><p>In this case, the other realms do not need to be there. They are here as an example of how a machine may be made aware of multiple realms. You may wish to not include them for simplicity.</p></div><div class=paragraph><p>The first line names the realm in which this system works. The other lines contain realm/host entries. The first item on a line is a realm, and the second is a host in that realm that is acting as a "key distribution center". The words <code>admin server</code> following a host’s name means that host also provides an administrative database server. For further explanation of these terms, please consult the Kerberos manual pages.</p></div><div class=paragraph><p>Now we have to add <code>grunt.example.com</code> to the <code>EXAMPLE.COM</code> realm and also add an entry to put all hosts in the <code>.example.com</code> domain in the <code>EXAMPLE.COM</code> realm. The <span class=filename>krb.realms</span> file would be updated as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.realms</span>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</code></pre></div></div><div class=paragraph><p>Again, the other realms do not need to be there. They are here as an example of how a machine may be made aware of multiple realms. You may wish to remove them to simplify things.</p></div><div class=paragraph><p>The first line puts the <em>specific</em> system into the named realm. The rest of the lines show how to default systems of a particular subdomain to a named realm.</p></div><div class=paragraph><p>Now we are ready to create the database. This only needs to run on the Kerberos server (or Key Distribution Center). Issue the <code>kdb_init</code> command to do this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_init</span>
Realm name <span class=o>[</span>default  ATHENA.MIT.EDU <span class=o>]</span>: EXAMPLE.COM
You will be prompted <span class=k>for </span>the database Master Password.
It is important that you NOT FORGET this password.

Enter Kerberos master key:</code></pre></div></div><div class=paragraph><p>Now we have to save the key so that servers on the local machine can pick it up. Use the <code>kstash</code> command to do this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!</code></pre></div></div><div class=paragraph><p>This saves the encrypted master password in <span class=filename>/etc/kerberosIV/master_key</span>.</p></div></div><div class=sect2><h3 id=_making_it_all_run>15.7.3. Making It All Run<a class=anchor href=#_making_it_all_run></a></h3><div class=paragraph><p>Two principals need to be added to the database for <em>each</em> system that will be secured with Kerberos. Their names are <code>kpasswd</code> and <code>rcmd</code>. These two principals are made for each system, with the instance being the name of the individual system.</p></div><div class=paragraph><p>These daemons, kpasswd and rcmd allow other systems to change Kerberos passwords and run commands like <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>.</p></div><div class=paragraph><p>Now let us add these entries:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: passwd
Instance: grunt

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: passwd, Instance: grunt, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> enter RANDOM here
Verifying password

New Password: &lt;<span class=nt>----</span> enter RANDOM here

Random password <span class=o>[</span>y] ? y

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name: rcmd
Instance: grunt

&lt;Not found&gt;, Create [y] ?

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
New Password:		&lt;---- enter RANDOM here
Verifying password

New Password:           &lt;---- enter RANDOM here

Random password [y] ?

Principal&#39;</span>s new key version <span class=o>=</span> 1
Expiration <span class=nb>date</span> <span class=o>(</span>enter yyyy-mm-dd<span class=o>)</span> <span class=o>[</span> 2000-01-01 <span class=o>]</span> ?
Max ticket lifetime <span class=o>(</span><span class=k>*</span>5 minutes<span class=o>)</span> <span class=o>[</span> 255 <span class=o>]</span> ?
Attributes <span class=o>[</span> 0 <span class=o>]</span> ?
Edit O.K.
Principal name:         &lt;<span class=nt>----</span> null entry here will cause an <span class=nb>exit</span></code></pre></div></div></div><div class=sect2><h3 id=_creating_the_server_file>15.7.4. Creating the Server File<a class=anchor href=#_creating_the_server_file></a></h3><div class=paragraph><p>We now have to extract all the instances which define the services on each machine. For this we use the <code>ext_srvtab</code> command. This will create a file which must be copied or moved <em>by secure means</em> to each Kerberos client’s <span class=filename>/etc</span> directory. This file must be present on each server and client, and is crucial to the operation of Kerberos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ext_srvtab grunt</span>
Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating <span class=s1>&#39;grunt-new-srvtab&#39;</span>....</code></pre></div></div><div class=paragraph><p>Now, this command only generates a temporary file which must be renamed to <span class=filename>srvtab</span> so that all the servers can pick it up. Use the <a href="https://man.freebsd.org/cgi/man.cgi?query=mv&amp;sektion=1&amp;format=html">mv(1)</a> command to move it into place on the original system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grunt-new-srvtab srvtab</span></code></pre></div></div><div class=paragraph><p>If the file is for a client system, and the network is not deemed safe, then copy the <span class=filename>client-new-srvtab</span> to removable media and transport it by secure physical means. Be sure to rename it to <span class=filename>srvtab</span> in the client’s <span class=filename>/etc</span> directory, and make sure it is mode 600:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grumble-new-srvtab srvtab</span>
<span class=c># chmod 600 srvtab</span></code></pre></div></div></div><div class=sect2><h3 id=_populating_the_database>15.7.5. Populating the Database<a class=anchor href=#_populating_the_database></a></h3><div class=paragraph><p>We now have to add some user entries into the database. First let us create an entry for the user <code>jane</code>. Use the <code>kdb_edit</code> command to do this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance:

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: , kdc_key_ver: 1
New Password:                &lt;<span class=nt>----</span> enter a secure password here
Verifying password

New Password:                &lt;<span class=nt>----</span> re-enter the password here
Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:		   &lt;---- null entry here will cause an exit</span></code></pre></div></div></div><div class=sect2><h3 id=_testing_it_all_out>15.7.6. Testing It All Out<a class=anchor href=#_testing_it_all_out></a></h3><div class=paragraph><p>First we have to start the Kerberos daemons. Note that if you have correctly edited your <span class=filename>/etc/rc.conf</span> then this will happen automatically when you reboot. This is only necessary on the Kerberos server. Kerberos clients will automatically get what they need from the <span class=filename>/etc/kerberosIV</span> directory.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kerberos &amp;</span>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
<span class=c># kadmind -n &amp;</span>
KADM Server KADM0.0A initializing
Please <span class=k>do </span>not use <span class=s1>&#39;kill -9&#39;</span> to <span class=nb>kill </span>this job, use a
regular <span class=nb>kill </span>instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</code></pre></div></div><div class=paragraph><p>Now we can try using the <code>kinit</code> command to get a ticket for the ID <code>jane</code> that we created above:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Try listing the tokens using <code>klist</code> to see if we really have them:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Now try changing the password using <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> to check if the kpasswd daemon can get authorization to the Kerberos database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
realm EXAMPLE.COM
Old password <span class=k>for </span>jane:
New Password <span class=k>for </span>jane:
Verifying password
New Password <span class=k>for </span>jane:
Password changed.</code></pre></div></div></div><div class=sect2><h3 id=_adding_su_privileges>15.7.7. Adding <code>su</code> Privileges<a class=anchor href=#_adding_su_privileges></a></h3><div class=paragraph><p>Kerberos allows us to give <em>each</em> user who needs <code>root</code> privileges their own <em>separate</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> password. We could now add an ID which is authorized to <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> to <code>root</code>. This is controlled by having an instance of <code>root</code> associated with a principal. Using <code>kdb_edit</code> we can create the entry <code>jane.root</code> in the Kerberos database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance: root

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> enter a SECURE password here
Verifying password

New Password:    	 	 &lt;<span class=nt>----</span> re-enter the password here

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ? 12 &lt;--- Keep this short!
Attributes [ 0 ] ?
Edit O.K.
Principal name:		         &lt;---- null entry here will cause an exit</span></code></pre></div></div><div class=paragraph><p>Now try getting tokens for it to make sure it works:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kinit jane.root</span>
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane.root&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Now we need to add the user to <code>root</code>'s <span class=filename>.klogin</span> file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Now try doing the <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:</code></pre></div></div><div class=paragraph><p>and take a look at what tokens we have:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># klist</span>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div></div><div class=sect2><h3 id=_using_other_commands>15.7.8. Using Other Commands<a class=anchor href=#_using_other_commands></a></h3><div class=paragraph><p>In an earlier example, we created a principal called <code>jane</code> with an instance <code>root</code>. This was based on a user with the same name as the principal, and this is a Kerberos default; that a <code>&lt;principal>.&lt;instance></code> of the form <code>&lt;username>. root</code> will allow that <code>&lt;username></code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> to <code>root</code> if the necessary entries are in the <span class=filename>.klogin</span> file in <code>root</code>'s home directory:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Likewise, if a user has in their own home directory lines of the form:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat</span> ~/.klogin
jane@EXAMPLE.COM
jack@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>This allows anyone in the <code>EXAMPLE.COM</code> realm who has authenticated themselves as <code>jane</code> or <code>jack</code> (via <code>kinit</code>, see above) to access to <code>jane</code>'s account or files on this system (<code>grunt</code>) via <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>.</p></div><div class=paragraph><p>For example, <code>jane</code> now logs into another system using Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
% rlogin grunt
Last login: Mon May  1 21:14:47 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div><div class=paragraph><p>Or <code>jack</code> logs into <code>jane</code>'s account on the same machine (<code>jane</code> having set up the <span class=filename>.klogin</span> file as above, and the person in charge of Kerberos having set up principal <em>jack</em> with a null instance):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
% rlogin grunt <span class=nt>-l</span> jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
Last login: Mon May  1 21:16:55 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=kerberos5>15.8. Kerberos5<a class=anchor href=#kerberos5></a></h2><div class=sectionbody><div class=paragraph><p>Every FreeBSD release beyond FreeBSD-5.1 includes support only for Kerberos5. Hence Kerberos5 is the only version included, and its configuration is similar in many aspects to that of KerberosIV. The following information only applies to Kerberos5 in post FreeBSD-5.0 releases. Users who wish to use the KerberosIV package may install the <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb4/>security/krb4</a> port.</p></div><div class=paragraph><p>Kerberos is a network add-on system/protocol that allows users to authenticate themselves through the services of a secure server. Services such as remote login, remote copy, secure inter-system file copying and other high-risk tasks are made considerably safer and more controllable.</p></div><div class=paragraph><p>Kerberos can be described as an identity-verifying proxy system. It can also be described as a trusted third-party authentication system. Kerberos provides only one function - the secure authentication of users on the network. It does not provide authorization functions (what users are allowed to do) or auditing functions (what those users did). After a client and server have used Kerberos to prove their identity, they can also encrypt all of their communications to assure privacy and data integrity as they go about their business.</p></div><div class=paragraph><p>Therefore it is highly recommended that Kerberos be used with other security methods which provide authorization and audit services.</p></div><div class=paragraph><p>The following instructions can be used as a guide on how to set up Kerberos as distributed for FreeBSD. However, you should refer to the relevant manual pages for a complete description.</p></div><div class=paragraph><p>For purposes of demonstrating a Kerberos installation, the various name spaces will be handled as follows:</p></div><div class=ulist><ul><li><p>The DNS domain ("zone") will be example.org.</p></li><li><p>The Kerberos realm will be EXAMPLE.ORG.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Please use real domain names when setting up Kerberos even if you intend to run it internally. This avoids DNS problems and assures inter-operation with other Kerberos realms.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_history>15.8.1. History<a class=anchor href=#_history></a></h3><div class=paragraph><p>Kerberos was created by MIT as a solution to network security problems. The Kerberos protocol uses strong cryptography so that a client can prove its identity to a server (and vice versa) across an insecure network connection.</p></div><div class=paragraph><p>Kerberos is both the name of a network authentication protocol and an adjective to describe programs that implement the program (Kerberos telnet, for example). The current version of the protocol is version 5, described in RFC 1510.</p></div><div class=paragraph><p>Several free implementations of this protocol are available, covering a wide range of operating systems. The Massachusetts Institute of Technology (MIT), where Kerberos was originally developed, continues to develop their Kerberos package. It is commonly used in the US as a cryptography product, as such it has historically been affected by US export regulations. The MITKerberos is available as a port (<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>). Heimdal Kerberos is another version 5 implementation, and was explicitly developed outside of the US to avoid export regulations (and is thus often included in non-commercial UNIX® variants). The Heimdal Kerberos distribution is available as a port (<a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a>), and a minimal installation of it is included in the base FreeBSD install.</p></div><div class=paragraph><p>In order to reach the widest audience, these instructions assume the use of the Heimdal distribution included in FreeBSD.</p></div></div><div class=sect2><h3 id=_setting_up_a_heimdal_kdc>15.8.2. Setting up a Heimdal KDC<a class=anchor href=#_setting_up_a_heimdal_kdc></a></h3><div class=paragraph><p>The Key Distribution Center (KDC) is the centralized authentication service that Kerberos provides - it is the computer that issues Kerberos tickets. The KDC is considered "trusted" by all other computers in the Kerberos realm, and thus has heightened security concerns.</p></div><div class=paragraph><p>Note that while running the Kerberos server requires very few computing resources, a dedicated machine acting only as a KDC is recommended for security reasons.</p></div><div class=paragraph><p>To begin setting up a KDC, ensure that your <span class=filename>/etc/rc.conf</span> file contains the correct settings to act as a KDC (you may need to adjust paths to reflect your own system):</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Next we will set up your Kerberos config file, <span class=filename>/etc/krb5.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Note that this <span class=filename>/etc/krb5.conf</span> file implies that your KDC will have the fully-qualified hostname of <code>kerberos.example.org</code>. You will need to add a CNAME (alias) entry to your zone file to accomplish this if your KDC has a different hostname.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For large networks with a properly configured BINDDNS server, the above example could be trimmed to:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>With the following lines being appended to the <code>example.org</code> zonefile:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For clients to be able to find the Kerberos services, you <em>must</em> have either a fully configured <span class=filename>/etc/krb5.conf</span> or a minimally configured <span class=filename>/etc/krb5.conf</span><em>and</em> a properly configured DNS server.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next we will create the Kerberos database. This database contains the keys of all principals encrypted with a master password. You are not required to remember this password, it will be stored in a file (<span class=filename>/var/heimdal/m-key</span>). To create the master key, run <code>kstash</code> and enter a password.</p></div><div class=paragraph><p>Once the master key has been created, you can initialize the database using the <code>kadmin</code> program with the <code>-l</code> option (standing for "local"). This option instructs <code>kadmin</code> to modify the database files directly rather than going through the <code>kadmind</code> network service. This handles the chicken-and-egg problem of trying to connect to the database before it is created. Once you have the <code>kadmin</code> prompt, use the <code>init</code> command to create your realms initial database.</p></div><div class=paragraph><p>Lastly, while still in <code>kadmin</code>, create your first principal using the <code>add</code> command. Stick to the defaults options for the principal for now, you can always change them later with the <code>modify</code> command. Note that you can use the <code>?</code> command at any prompt to see the available options.</p></div><div class=paragraph><p>A sample database creation session is shown below:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

<span class=c># kadmin -l</span>
kadmin&gt; init EXAMPLE.ORG
Realm max ticket life <span class=o>[</span>unlimited]:
kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Now it is time to start up the KDC services. Run <code>/etc/rc.d/kerberos start</code> and <code>/etc/rc.d/kadmind start</code> to bring up the services. Note that you will not have any kerberized daemons running at this point but you should be able to confirm the that the KDC is functioning by obtaining and listing a ticket for the principal (user) that you just created from the command-line of the KDC itself:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit tillman
tillman@EXAMPLE.ORG<span class=s1>&#39;s Password:

% klist
Credentials cache: FILE:/tmp/krb5cc_500
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</span></code></pre></div></div><div class=paragraph><p>The ticket can then be revoked when you have finished:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% k5destroy</code></pre></div></div></div><div class=sect2><h3 id=_kerberos_enabling_a_server_with_heimdal_services>15.8.3. Kerberos enabling a server with Heimdal services<a class=anchor href=#_kerberos_enabling_a_server_with_heimdal_services></a></h3><div class=paragraph><p>First, we need a copy of the Kerberos configuration file, <span class=filename>/etc/krb5.conf</span>. To do so, simply copy it over to the client computer from the KDC in a secure fashion (using network utilities, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, or physically via a floppy disk).</p></div><div class=paragraph><p>Next you need a <span class=filename>/etc/krb5.keytab</span> file. This is the major difference between a server providing Kerberos enabled daemons and a workstation - the server must have a <span class=filename>keytab</span> file. This file contains the server’s host key, which allows it and the KDC to verify each others identity. It must be transmitted to the server in a secure fashion, as the security of the server can be broken if the key is made public. This explicitly means that transferring it via a clear text channel, such as FTP, is a very bad idea.</p></div><div class=paragraph><p>Typically, you transfer to the <span class=filename>keytab</span> to the server using the <code>kadmin</code> program. This is handy because you also need to create the host principal (the KDC end of the <span class=filename>krb5.keytab</span>) using <code>kadmin</code>.</p></div><div class=paragraph><p>Note that you must have already obtained a ticket and that this ticket must be allowed to use the <code>kadmin</code> interface in the <span class=filename>kadmind.acl</span>. See the section titled "Remote administration" in the Heimdal info pages (<code>info heimdal</code>) for details on designing access control lists. If you do not want to enable remote <code>kadmin</code> access, you can simply securely connect to the KDC (via local console, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> or Kerberos <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>) and perform administration locally using <code>kadmin -l</code>.</p></div><div class=paragraph><p>After installing the <span class=filename>/etc/krb5.conf</span> file, you can use <code>kadmin</code> from the Kerberos server. The <code>add --random-key</code> command will let you add the server’s host principal, and the <code>ext</code> command will allow you to extract the server’s host principal to its own keytab. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.example.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Note that the <code>ext</code> command (short for "extract") stores the extracted key in <span class=filename>/etc/krb5.keytab</span> by default.</p></div><div class=paragraph><p>If you do not have <code>kadmind</code> running on the KDC (possibly for security reasons) and thus do not have access to <code>kadmin</code> remotely, you can add the host principal (<code>host/myserver.EXAMPLE.ORG</code>) directly on the KDC and then extract it to a temporary file (to avoid over-writing the <span class=filename>/etc/krb5.keytab</span> on the KDC) using something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext <span class=nt>--keytab</span><span class=o>=</span>/tmp/example.keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>You can then securely copy the keytab to the server computer (using <code>scp</code> or a floppy, for example). Be sure to specify a non-default keytab name to avoid over-writing the keytab on the KDC.</p></div><div class=paragraph><p>At this point your server can communicate with the KDC (due to its <span class=filename>krb5.conf</span> file) and it can prove its own identity (due to the <span class=filename>krb5.keytab</span> file). It is now ready for you to enable some Kerberos services. For this example we will enable the <code>telnet</code> service by putting a line like this into your <span class=filename>/etc/inetd.conf</span> and then restarting the <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> service with <code>/etc/rc.d/inetd restart</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</pre></div></div><div class=paragraph><p>The critical bit is that the <code>-a</code> (for authentication) type is set to user. Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> manual page for more details.</p></div></div><div class=sect2><h3 id=_kerberos_enabling_a_client_with_heimdal>15.8.4. Kerberos enabling a client with Heimdal<a class=anchor href=#_kerberos_enabling_a_client_with_heimdal></a></h3><div class=paragraph><p>Setting up a client computer is almost trivially easy. As far as Kerberos configuration goes, you only need the Kerberos configuration file, located at <span class=filename>/etc/krb5.conf</span>. Simply securely copy it over to the client computer from the KDC.</p></div><div class=paragraph><p>Test your client computer by attempting to use <code>kinit</code>, <code>klist</code>, and <code>kdestroy</code> from the client to obtain, show, and then delete a ticket for the principal you created above. You should also be able to use Kerberos applications to connect to Kerberos enabled servers, though if that does not work and obtaining a ticket does the problem is likely with the server and not with the client or the KDC.</p></div><div class=paragraph><p>When testing an application like <code>telnet</code>, try using a packet sniffer (such as <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>) to confirm that your password is not sent in the clear. Try using <code>telnet</code> with the <code>-x</code> option, which encrypts the entire data stream (similar to <code>ssh</code>).</p></div><div class=paragraph><p>Various non-core Kerberos client applications are also installed by default. This is where the "minimal" nature of the base Heimdal installation is felt: <code>telnet</code> is the only Kerberos enabled service.</p></div><div class=paragraph><p>The Heimdal port adds some of the missing client applications: Kerberos enabled versions of <code>ftp</code>, <code>rsh</code>, <code>rcp</code>, <code>rlogin</code>, and a few other less common programs. The MIT port also contains a full suite of Kerberos client applications.</p></div></div><div class=sect2><h3 id=_user_configuration_files_k5login_and_k5users>15.8.5. User configuration files: <span class=filename>.k5login</span> and <span class=filename>.k5users</span><a class=anchor href=#_user_configuration_files_k5login_and_k5users></a></h3><div class=paragraph><p>Users within a realm typically have their Kerberos principal (such as <code>tillman@EXAMPLE.ORG</code>) mapped to a local user account (such as a local account named <code>tillman</code>). Client applications such as <code>telnet</code> usually do not require a user name or a principal.</p></div><div class=paragraph><p>Occasionally, however, you want to grant access to a local user account to someone who does not have a matching Kerberos principal. For example, <code>tillman@EXAMPLE.ORG</code> may need access to the local user account <code>webdevelopers</code>. Other principals may also need access to that local account.</p></div><div class=paragraph><p>The <span class=filename>.k5login</span> and <span class=filename>.k5users</span> files, placed in a users home directory, can be used similar to a powerful combination of <span class=filename>.hosts</span> and <span class=filename>.rhosts</span>, solving this problem. For example, if a <span class=filename>.k5login</span> with the following contents:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>tillman@example.org
jdoe@example.org</code></pre></div></div><div class=paragraph><p>Were to be placed into the home directory of the local user <code>webdevelopers</code> then both principals listed would have access to that account without requiring a shared password.</p></div><div class=paragraph><p>Reading the manual pages for these commands is recommended. Note that the <code>ksu</code> manual page covers <span class=filename>.k5users</span>.</p></div></div><div class=sect2><h3 id=_kerberos_tips_tricks_and_troubleshooting>15.8.6. Kerberos Tips, Tricks, and Troubleshooting<a class=anchor href=#_kerberos_tips_tricks_and_troubleshooting></a></h3><div class=ulist><ul><li><p>When using either the Heimdal or MITKerberos ports ensure that your <code>PATH</code> environment variable lists the Kerberos versions of the client applications before the system versions.</p></li><li><p>Do all the computers in your realm have synchronized time settings? If not, authentication may fail. <a href=../network-servers/#network-ntp>Συγχρονισμός Ρολογιού Συστήματος με NTP</a> describes how to synchronize clocks using NTP.</p></li><li><p>MIT and Heimdal inter-operate nicely. Except for <code>kadmin</code>, the protocol for which is not standardized.</p></li><li><p>If you change your hostname, you also need to change your <code>host/</code> principal and update your keytab. This also applies to special keytab entries like the <code>www/</code> principal used for Apache’s <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a>.</p></li><li><p>All hosts in your realm must be resolvable (both forwards and reverse) in DNS (or <span class=filename>/etc/hosts</span> as a minimum). CNAMEs will work, but the A and PTR records must be correct and in place. The error message is not very intuitive: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Some operating systems that may being acting as clients to your KDC do not set the permissions for <code>ksu</code> to be setuid <code>root</code>. This means that <code>ksu</code> does not work, which is a good security idea but annoying. This is not a KDC error.</p></li><li><p>With MITKerberos, if you want to allow a principal to have a ticket life longer than the default ten hours, you must use <code>modify_principal</code> in <code>kadmin</code> to change the maxlife of both the principal in question and the <code>krbtgt</code> principal. Then the principal can use the <code>-l</code> option with <code>kinit</code> to request a ticket with a longer lifetime.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you run a packet sniffer on your KDC to add in troubleshooting and then run <code>kinit</code> from a workstation, you will notice that your TGT is sent immediately upon running <code>kinit</code> - even before you type your password! The explanation is that the Kerberos server freely transmits a TGT (Ticket Granting Ticket) to any unauthorized request; however, every TGT is encrypted in a key derived from the user’s password. Therefore, when a user types their password it is not being sent to the KDC, it is being used to decrypt the TGT that <code>kinit</code> already obtained. If the decryption process results in a valid ticket with a valid time stamp, the user has valid Kerberos credentials. These credentials include a session key for establishing secure communications with the Kerberos server in the future, as well as the actual ticket-granting ticket, which is actually encrypted with the Kerberos server’s own key. This second layer of encryption is unknown to the user, but it is what allows the Kerberos server to verify the authenticity of each TGT.</p></div></td></tr></tbody></table></div><div class=ulist><ul><li><p>If you want to use long ticket lifetimes (a week, for example) and you are using OpenSSH to connect to the machine where your ticket is stored, make sure that Kerberos <code>TicketCleanup</code> is set to <code>no</code> in your <span class=filename>sshd_config</span> or else your tickets will be deleted when you log out.</p></li><li><p>Remember that host principals can have a longer ticket lifetime as well. If your user principal has a lifetime of a week but the host you are connecting to has a lifetime of nine hours, you will have an expired host principal in your cache and the ticket cache will not work as expected.</p></li><li><p>When setting up a <span class=filename>krb5.dict</span> file to prevent specific bad passwords from being used (the manual page for <code>kadmind</code> covers this briefly), remember that it only applies to principals that have a password policy assigned to them. The <span class=filename>krb5.dict</span> files format is simple: one string per line. Creating a symbolic link to <span class=filename>/usr/shared/dict/words</span> might be useful.</p></li></ul></div></div><div class=sect2><h3 id=_differences_with_the_mit_port>15.8.7. Differences with the MIT port<a class=anchor href=#_differences_with_the_mit_port></a></h3><div class=paragraph><p>The major difference between the MIT and Heimdal installs relates to the <code>kadmin</code> program which has a different (but equivalent) set of commands and uses a different protocol. This has a large implications if your KDC is MIT as you will not be able to use the Heimdal <code>kadmin</code> program to administer your KDC remotely (or vice versa, for that matter).</p></div><div class=paragraph><p>The client applications may also take slightly different command line options to accomplish the same tasks. Following the instructions on the MITKerberos web site (<a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a>) is recommended. Be careful of path issues: the MIT port installs into <span class=filename>/usr/local/</span> by default, and the "normal" system applications may be run instead of MIT if your <code>PATH</code> environment variable lists the system directories first.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>With the MIT<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> port that is provided by FreeBSD, be sure to read the <span class=filename>/usr/local/shared/doc/krb5/README.FreeBSD</span> file installed by the port if you want to understand why logins via <code>telnetd</code> and <code>klogind</code> behave somewhat oddly. Most importantly, correcting the "incorrect permissions on cache file" behavior requires that the <code>login.krb5</code> binary be used for authentication so that it can properly change ownership for the forwarded credentials.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The <span class=filename>rc.conf</span> must also be modified to contain the following configuration:</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server=&#34;/usr/local/sbin/krb5kdc&#34;
kadmind5_server=&#34;/usr/local/sbin/kadmind&#34;
kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>This is done because the applications for MIT kerberos installs binaries in the <span class=filename>/usr/local</span> hierarchy.</p></div></div><div class=sect2><h3 id=_mitigating_limitations_found_in_kerberos>15.8.8. Mitigating limitations found in Kerberos<a class=anchor href=#_mitigating_limitations_found_in_kerberos></a></h3><div class=sect3><h4 id=_kerberos_is_an_all_or_nothing_approach>15.8.8.1. Kerberos is an all-or-nothing approach<a class=anchor href=#_kerberos_is_an_all_or_nothing_approach></a></h4><div class=paragraph><p>Every service enabled on the network must be modified to work with Kerberos (or be otherwise secured against network attacks) or else the users credentials could be stolen and re-used. An example of this would be Kerberos enabling all remote shells (via <code>rsh</code> and <code>telnet</code>, for example) but not converting the POP3 mail server which sends passwords in plain text.</p></div></div><div class=sect3><h4 id=_kerberos_is_intended_for_single_user_workstations>15.8.8.2. Kerberos is intended for single-user workstations<a class=anchor href=#_kerberos_is_intended_for_single_user_workstations></a></h4><div class=paragraph><p>In a multi-user environment, Kerberos is less secure. This is because it stores the tickets in the <span class=filename>/tmp</span> directory, which is readable by all users. If a user is sharing a computer with several other people simultaneously (i.e. multi-user), it is possible that the user’s tickets can be stolen (copied) by another user.</p></div><div class=paragraph><p>This can be overcome with the <code>-c</code> filename command-line option or (preferably) the <code>KRB5CCNAME</code> environment variable, but this is rarely done. In principal, storing the ticket in the users home directory and using simple file permissions can mitigate this problem.</p></div></div><div class=sect3><h4 id=_the_kdc_is_a_single_point_of_failure>15.8.8.3. The KDC is a single point of failure<a class=anchor href=#_the_kdc_is_a_single_point_of_failure></a></h4><div class=paragraph><p>By design, the KDC must be as secure as the master password database is contained on it. The KDC should have absolutely no other services running on it and should be physically secured. The danger is high because Kerberos stores all passwords encrypted with the same key (the "master" key), which in turn is stored as a file on the KDC.</p></div><div class=paragraph><p>As a side note, a compromised master key is not quite as bad as one might normally fear. The master key is only used to encrypt the Kerberos database and as a seed for the random number generator. As long as access to your KDC is secure, an attacker cannot do much with the master key.</p></div><div class=paragraph><p>Additionally, if the KDC is unavailable (perhaps due to a denial of service attack or network problems) the network services are unusable as authentication can not be performed, a recipe for a denial-of-service attack. This can alleviated with multiple KDCs (a single master and one or more slaves) and with careful implementation of secondary or fall-back authentication (PAM is excellent for this).</p></div></div><div class=sect3><h4 id=_kerberos_shortcomings>15.8.8.4. Kerberos Shortcomings<a class=anchor href=#_kerberos_shortcomings></a></h4><div class=paragraph><p>Kerberos allows users, hosts and services to authenticate between themselves. It does not have a mechanism to authenticate the KDC to the users, hosts or services. This means that a trojanned <code>kinit</code> (for example) could record all user names and passwords. Something like <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> or other file system integrity checking tools can alleviate this.</p></div></div></div><div class=sect2><h3 id=_resources_and_further_information>15.8.9. Resources and further information<a class=anchor href=#_resources_and_further_information></a></h3><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>The Kerberos FAQ</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Designing an Authentication System: a Dialog in Four Scenes</a></p></li><li><p><a href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510, The Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>MIT Kerberos home page</a></p></li><li><p><a href=http://www.pdc.kth.se/heimdal/>Heimdal Kerberos home page</a></p></li></ul></div></div></div></div><div class=sect1><h2 id=openssl>15.9. OpenSSL<a class=anchor href=#openssl></a></h2><div class=sectionbody><div class=paragraph><p>One feature that many users overlook is the OpenSSL toolkit included in FreeBSD. OpenSSL provides an encryption transport layer on top of the normal communications layer; thus allowing it to be intertwined with many network applications and services.</p></div><div class=paragraph><p>Some uses of OpenSSL may include encrypted authentication of mail clients, web based transactions such as credit card payments and more. Many ports such as <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-ssl/>www/apache13-ssl</a>, and <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a> will offer compilation support for building with OpenSSL.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In most cases the Ports Collection will attempt to build the <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> port unless the <code>WITH_OPENSSL_BASE</code> make variable is explicitly set to "yes".</p></div></td></tr></tbody></table></div><div class=paragraph><p>The version of OpenSSL included in FreeBSD supports Secure Sockets Layer v2/v3 (SSLv2/SSLv3), Transport Layer Security v1 (TLSv1) network security protocols and can be used as a general cryptographic library.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While OpenSSL supports the IDEA algorithm, it is disabled by default due to United States patents. To use it, the license should be reviewed and, if the restrictions are acceptable, the <code>MAKE_IDEA</code> variable must be set in <span class=filename>make.conf</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>One of the most common uses of OpenSSL is to provide certificates for use with software applications. These certificates ensure that the credentials of the company or individual are valid and not fraudulent. If the certificate in question has not been verified by one of the several "Certificate Authorities", or CAs, a warning is usually produced. A Certificate Authority is a company, such as <a href=http://www.verisign.com>VeriSign</a>, which will sign certificates in order to validate credentials of individuals or companies. This process has a cost associated with it and is definitely not a requirement for using certificates; however, it can put some of the more paranoid users at ease.</p></div><div class=sect2><h3 id=_generating_certificates>15.9.1. Generating Certificates<a class=anchor href=#_generating_certificates></a></h3><div class=paragraph><p>To generate a certificate, the following command is available:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.pem</span>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to <span class=s1>&#39;cert.pem&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:SOME PASSWORD
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>Notice the response directly after the "Common Name" prompt shows a domain name. This prompt requires a server name to be entered for verification purposes; placing anything but a domain name would yield a useless certificate. Other options, for instance expire time, alternate encryption algorithms, etc. are available. A complete list may be obtained by viewing the <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a> manual page.</p></div><div class=paragraph><p>Two files should now exist in the directory in which the aforementioned command was issued. The certificate request, <span class=filename>req.pem</span>, may be sent to a certificate authority who will validate the credentials that you entered, sign the request and return the certificate to you. The second file created will be named <span class=filename>cert.pem</span> and is the private key for the certificate and should be protected at all costs; if this falls in the hands of others it can be used to impersonate you (or your server).</p></div><div class=paragraph><p>In cases where a signature from a CA is not required, a self signed certificate can be created. First, generate the RSA key:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl dsaparam -rand -genkey -out myRSA.key 1024</span></code></pre></div></div><div class=paragraph><p>Next, generate the CA key:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl gendsa -des3 -out myca.key myRSA.key</span></code></pre></div></div><div class=paragraph><p>Use this key to create the certificate:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key myca.key -out new.crt</span></code></pre></div></div><div class=paragraph><p>Two new files should appear in the directory: a certificate authority signature file, <span class=filename>myca.key</span> and the certificate itself, <span class=filename>new.crt</span>. These should be placed in a directory, preferably under <span class=filename>/etc</span>, which is readable only by <code>root</code>. Permissions of 0700 should be fine for this and they can be set with the <code>chmod</code> utility.</p></div></div><div class=sect2><h3 id=_using_certificates_an_example>15.9.2. Using Certificates, an Example<a class=anchor href=#_using_certificates_an_example></a></h3><div class=paragraph><p>So what can these files do? A good use would be to encrypt connections to the SendmailMTA. This would dissolve the use of clear text authentication for users who send mail via the local MTA.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This is not the best use in the world as some MUAs will present the user with an error if they have not installed the certificate locally. Refer to the documentation included with the software for more information on certificate installation.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The following lines should be placed inside the local <span class=filename>.mc</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>dnl SSL Options
define(`confCACERT_PATH&#39;,`/etc/certs&#39;)dnl
define(`confCACERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_CERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_KEY&#39;,`/etc/certs/myca.key&#39;)dnl
define(`confTLS_SRV_OPTIONS&#39;, `V&#39;)dnl</pre></div></div><div class=paragraph><p>Where <span class=filename>/etc/certs/</span> is the directory to be used for storing the certificate and key files locally. The last few requirements are a rebuild of the local <span class=filename>.cf</span> file. This is easily achieved by typing <code>make</code><span class=parameter>install</span> within the <span class=filename>/etc/mail</span> directory. Follow that up with <code>make</code><span class=parameter>restart</span> which should start the Sendmail daemon.</p></div><div class=paragraph><p>If all went well there will be no error messages in the <span class=filename>/var/log/maillog</span> file and Sendmail will show up in the process list.</p></div><div class=paragraph><p>For a simple test, simply connect to the mail server using the <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> utility:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to example.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.12.10/8.12.10<span class=p>;</span> Tue, 31 Aug 2004 03:41:22 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>If the "STARTTLS" line appears in the output then everything is working correctly.</p></div></div></div></div><div class=sect1><h2 id=ipsec>15.10. VPN over IPsec<a class=anchor href=#ipsec></a></h2><div class=sectionbody><div class=paragraph><p>Creating a VPN between two networks, separated by the Internet, using FreeBSD gateways.</p></div><div class=sect2><h3 id=_understanding_ipsec>15.10.1. Understanding IPsec<a class=anchor href=#_understanding_ipsec></a></h3><div class=paragraph><p>This section will guide you through the process of setting up IPsec, and to use it in an environment which consists of FreeBSD and Microsoft® Windows® 2000/XP machines, to make them communicate securely. In order to set up IPsec, it is necessary that you are familiar with the concepts of building a custom kernel (see <a href=../kernelconfig/#kernelconfig>Ρυθμίζοντας τον Πυρήνα του FreeBSD</a>).</p></div><div class=paragraph><p><em>IPsec</em> is a protocol which sits on top of the Internet Protocol (IP) layer. It allows two or more hosts to communicate in a secure manner (hence the name). The FreeBSD IPsec "network stack" is based on the <a href=http://www.kame.net/>KAME</a> implementation, which has support for both protocol families, IPv4 and IPv6.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD contains a "hardware accelerated" IPsec stack, known as "Fast IPsec", that was obtained from OpenBSD. It employs cryptographic hardware (whenever possible) via the <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=4&amp;format=html">crypto(4)</a> subsystem to optimize the performance of IPsec. This subsystem is new, and does not support all the features that are available in the KAME version of IPsec. However, in order to enable hardware-accelerated IPsec, the following kernel option has to be added to your kernel configuration file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options	  FAST_IPSEC  <span class=c># new IPsec (cannot define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Note, that it is not currently possible to use the "Fast IPsec" subsystem in lieu of the KAME implementation of IPsec. Consult the manual page for more information.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>To let firewalls properly track state for <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> tunnels too, you have to enable the <code>IPSEC_FILTERGIF</code> in your kernel configuration:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_FILTERGIF  <span class=c>#filter ipsec packets from a tunnel</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>IPsec consists of two sub-protocols:</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>, protects the IP packet data from third party interference, by encrypting the contents using symmetric cryptography algorithms (like Blowfish, 3DES).</p></li><li><p><em>Authentication Header (AH)</em>, protects the IP packet header from third party interference and spoofing, by computing a cryptographic checksum and hashing the IP packet header fields with a secure hashing function. This is then followed by an additional header that contains the hash, to allow the information in the packet to be authenticated.</p></li></ul></div><div class=paragraph><p>ESP and AH can either be used together or separately, depending on the environment.</p></div><div class=paragraph><p>IPsec can either be used to directly encrypt the traffic between two hosts (known as <em>Transport Mode</em>); or to build "virtual tunnels" between two subnets, which could be used for secure communication between two corporate networks (known as <em>Tunnel Mode</em>). The latter is more commonly known as a <em>Virtual Private Network (VPN)</em>. The <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> manual page should be consulted for detailed information on the IPsec subsystem in FreeBSD.</p></div><div class=paragraph><p>To add IPsec support to your kernel, add the following options to your kernel configuration file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        <span class=c>#IP security</span>
options   IPSEC_ESP    <span class=c>#IP security (crypto; define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>If IPsec debugging support is desired, the following kernel option should also be added:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  <span class=c>#debug for IP security</span></code></pre></div></div></div><div class=sect2><h3 id=_the_problem>15.10.2. The Problem<a class=anchor href=#_the_problem></a></h3><div class=paragraph><p>There is no standard for what constitutes a VPN. VPNs can be implemented using a number of different technologies, each of which have their own strengths and weaknesses. This section presents a scenario, and the strategies used for implementing a VPN for this scenario.</p></div></div><div class=sect2><h3 id=_the_scenario_two_networks_connected_to_the_internet_to_behave_as_one>15.10.3. The Scenario: Two networks, connected to the Internet, to behave as one<a class=anchor href=#_the_scenario_two_networks_connected_to_the_internet_to_behave_as_one></a></h3><div class=paragraph><p>The premise is as follows:</p></div><div class=ulist><ul><li><p>You have at least two sites</p></li><li><p>Both sites are using IP internally</p></li><li><p>Both sites are connected to the Internet, through a gateway that is running FreeBSD.</p></li><li><p>The gateway on each network has at least one public IP address.</p></li><li><p>The internal addresses of the two networks can be public or private IP addresses, it does not matter. You can be running NAT on the gateway machine if necessary.</p></li><li><p>The internal IP addresses of the two networks <em>do not collide</em>. While I expect it is theoretically possible to use a combination of VPN technology and NAT to get this to work, I expect it to be a configuration nightmare.</p></li></ul></div><div class=paragraph><p>If you find that you are trying to connect two networks, both of which, internally, use the same private IP address range (e.g. both of them use <code>192.168.1.x</code>), then one of the networks will have to be renumbered.</p></div><div class=paragraph><p>The network topology might look something like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-network.png alt="ipsec network"></div></div><div class=paragraph><p>Notice the two public IP addresses. I will use the letters to refer to them in the rest of this article. Anywhere you see those letters in this article, replace them with your own public IP addresses. Note also that internally, the two gateway machines have .1 IP addresses, and that the two networks have different private IP addresses (<code>192.168.1.x</code> and <code>192.168.2.x</code> respectively). All the machines on the private networks have been configured to use the <code>.1</code> machine as their default gateway.</p></div><div class=paragraph><p>The intention is that, from a network point of view, each network should view the machines on the other network as though they were directly attached the same router — albeit a slightly slow router with an occasional tendency to drop packets.</p></div><div class=paragraph><p>This means that (for example), machine <code>192.168.1.20</code> should be able to run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.34</pre></div></div><div class=paragraph><p>and have it work, transparently. Windows® machines should be able to see the machines on the other network, browse file shares, and so on, in exactly the same way that they can browse machines on the local network.</p></div><div class=paragraph><p>And the whole thing has to be secure. This means that traffic between the two networks has to be encrypted.</p></div><div class=paragraph><p>Creating a VPN between these two networks is a multi-step process. The stages are as follows:</p></div><div class="olist arabic"><ol class=arabic><li><p>Create a "virtual" network link between the two networks, across the Internet. Test it, using tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, to make sure it works.</p></li><li><p>Apply security policies to ensure that traffic between the two networks is transparently encrypted and decrypted as necessary. Test this, using tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>, to ensure that traffic is encrypted.</p></li><li><p>Configure additional software on the FreeBSD gateways, to allow Windows® machines to see one another across the VPN.</p></li></ol></div><div class=sect3><h4 id=_step_1_creating_and_testing_a_virtual_network_link>15.10.3.1. Step 1: Creating and testing a "virtual" network link<a class=anchor href=#_step_1_creating_and_testing_a_virtual_network_link></a></h4><div class=paragraph><p>Suppose that you were logged in to the gateway machine on network #1 (with public IP address <code>A.B.C.D</code>, private IP address <code>192.168.1.1</code>), and you ran <code>ping 192.168.2.1</code>, which is the private address of the machine with IP address <code>W.X.Y.Z</code>. What needs to happen in order for this to work?</p></div><div class="olist arabic"><ol class=arabic><li><p>The gateway machine needs to know how to reach <code>192.168.2.1</code>. In other words, it needs to have a route to <code>192.168.2.1</code>.</p></li><li><p>Private IP addresses, such as those in the <code>192.168.x</code> range are not supposed to appear on the Internet at large. Instead, each packet you send to <code>192.168.2.1</code> will need to be wrapped up inside another packet. This packet will need to appear to be from <code>A.B.C.D</code>, and it will have to be sent to <code>W.X.Y.Z</code>. This process is called <em>encapsulation</em>.</p></li><li><p>Once this packet arrives at <code>W.X.Y.Z</code> it will need to "unencapsulated", and delivered to <code>192.168.2.1</code>.</p></li></ol></div><div class=paragraph><p>You can think of this as requiring a "tunnel" between the two networks. The two "tunnel mouths" are the IP addresses <code>A.B.C.D</code> and <code>W.X.Y.Z</code>, and the tunnel must be told the addresses of the private IP addresses that will be allowed to pass through it. The tunnel is used to transfer traffic with private IP addresses across the public Internet.</p></div><div class=paragraph><p>This tunnel is created by using the generic interface, or <span class=filename>gif</span> devices on FreeBSD. As you can imagine, the <span class=filename>gif</span> interface on each gateway host must be configured with four IP addresses; two for the public IP addresses, and two for the private IP addresses.</p></div><div class=paragraph><p>Support for the gif device must be compiled in to the FreeBSD kernel on both machines. You can do this by adding the line:</p></div><div class="literalblock programlisting"><div class=content><pre>device gif</pre></div></div><div class=paragraph><p>to the kernel configuration files on both machines, and then compile, install, and reboot as normal.</p></div><div class=paragraph><p>Configuring the tunnel is a two step process. First the tunnel must be told what the outside (or public) IP addresses are, using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Then the private IP addresses must be configured using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=paragraph><p>On the gateway machine on network #1 you would run the following commands to configure the tunnel.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0 tunnel A.B.C.D W.X.Y.Z</span>
<span class=c># ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff</span></code></pre></div></div><div class=paragraph><p>On the other gateway machine you run the same commands, but with the order of the IP addresses reversed.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0 tunnel W.X.Y.Z A.B.C.D</span>
<span class=c># ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff</span></code></pre></div></div><div class=paragraph><p>You can then run:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig gif0</pre></div></div><div class=paragraph><p>to see the configuration. For example, on the network #1 gateway, you would see this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1280
        tunnel inet A.B.C.D <span class=nt>--</span><span class=o>&gt;</span> W.X.Y.Z
        inet 192.168.1.1 <span class=nt>--</span><span class=o>&gt;</span> 192.168.2.1 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>As you can see, a tunnel has been created between the physical addresses <code>A.B.C.D</code> and <code>W.X.Y.Z</code>, and the traffic allowed through the tunnel is that between <code>192.168.1.1</code> and <code>192.168.2.1</code>.</p></div><div class=paragraph><p>This will also have added an entry to the routing table on both machines, which you can examine with the command <code>netstat -rn</code>. This output is from the gateway host on network #1.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -rn</span>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...</code></pre></div></div><div class=paragraph><p>As the "Flags" value indicates, this is a host route, which means that each gateway knows how to reach the other gateway, but they do not know how to reach the rest of their respective networks. That problem will be fixed shortly.</p></div><div class=paragraph><p>It is likely that you are running a firewall on both machines. This will need to be circumvented for your VPN traffic. You might want to allow all traffic between both networks, or you might want to include firewall rules that protect both ends of the VPN from one another.</p></div><div class=paragraph><p>It greatly simplifies testing if you configure the firewall to allow all traffic through the VPN. You can always tighten things up later. If you are using <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> on the gateway machines then a command like</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div><div class=paragraph><p>will allow all traffic between the two end points of the VPN, without affecting your other firewall rules. Obviously you will need to run this command on both gateway hosts.</p></div><div class=paragraph><p>This is sufficient to allow each gateway machine to ping the other. On <code>192.168.1.1</code>, you should be able to run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>and get a response, and you should be able to do the same thing on the other gateway machine.</p></div><div class=paragraph><p>However, you will not be able to reach internal machines on either network yet. This is because of the routing — although the gateway machines know how to reach one another, they do not know how to reach the network behind each one.</p></div><div class=paragraph><p>To solve this problem you must add a static route on each gateway machine. The command to do this on the first gateway would be:</p></div><div class="literalblock programlisting"><div class=content><pre>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00</pre></div></div><div class=paragraph><p>This says "In order to reach the hosts on the network <code>192.168.2.0</code>, send the packets to the host <code>192.168.2.1</code>". You will need to run a similar command on the other gateway, but with the <code>192.168.1.x</code> addresses instead.</p></div><div class=paragraph><p>IP traffic from hosts on one network will now be able to reach hosts on the other network.</p></div><div class=paragraph><p>That has now created two thirds of a VPN between the two networks, in as much as it is "virtual" and it is a "network". It is not private yet. You can test this using <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. Log in to the gateway host and run</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>In another log in session on the same host run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>You will see output that looks something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>16:10:24.018080 192.168.1.1  192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1  192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1  192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1  192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1  192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1  192.168.2.1: icmp: echo reply</pre></div></div><div class=paragraph><p>As you can see, the ICMP messages are going back and forth unencrypted. If you had used the <code>-s</code> parameter to <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> to grab more bytes of data from the packets you would see more information.</p></div><div class=paragraph><p>Obviously this is unacceptable. The next section will discuss securing the link between the two networks so that all traffic is automatically encrypted.</p></div><div class=ulist><div class=title>Summary:</div><ul><li><p>Configure both kernels with "device gif".</p></li><li><p>Edit <span class=filename>/etc/rc.conf</span> on gateway host #1 and add the following lines (replacing IP addresses as necessary).</p><div class="literalblock programlisting"><div class=content><pre>gif_interfaces=&#34;gif0&#34;
gifconfig_gif0=&#34;A.B.C.D W.X.Y.Z&#34;
ifconfig_gif0=&#34;inet 192.168.1.1 192.168.2.1 netmask 0xffffffff&#34;
static_routes=&#34;vpn&#34;
route_vpn=&#34;192.168.2.0 192.168.2.1 netmask 0xffffff00&#34;</pre></div></div></li><li><p>Edit your firewall script (<span class=filename>/etc/rc.firewall</span>, or similar) on both hosts, and add</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div></li><li><p>Make similar changes to <span class=filename>/etc/rc.conf</span> on gateway host #2, reversing the order of IP addresses.</p></li></ul></div></div><div class=sect3><h4 id=_step_2_securing_the_link>15.10.3.2. Step 2: Securing the link<a class=anchor href=#_step_2_securing_the_link></a></h4><div class=paragraph><p>To secure the link we will be using IPsec. IPsec provides a mechanism for two hosts to agree on an encryption key, and to then use this key in order to encrypt data between the two hosts.</p></div><div class=paragraph><p>The are two areas of configuration to be considered here.</p></div><div class="olist arabic"><ol class=arabic><li><p>There must be a mechanism for two hosts to agree on the encryption mechanism to use. Once two hosts have agreed on this mechanism there is said to be a "security association" between them.</p></li><li><p>There must be a mechanism for specifying which traffic should be encrypted. Obviously, you do not want to encrypt all your outgoing traffic — you only want to encrypt the traffic that is part of the VPN. The rules that you put in place to determine what traffic will be encrypted are called "security policies".</p></li></ol></div><div class=paragraph><p>Security associations and security policies are both maintained by the kernel, and can be modified by userland programs. However, before you can do this you must configure the kernel to support IPsec and the Encapsulated Security Payload (ESP) protocol. This is done by configuring a kernel with:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div><div class=paragraph><p>and recompiling, reinstalling, and rebooting. As before you will need to do this to the kernels on both of the gateway hosts.</p></div><div class=paragraph><p>You have two choices when it comes to setting up security associations. You can configure them by hand between two hosts, which entails choosing the encryption algorithm, encryption keys, and so forth, or you can use daemons that implement the Internet Key Exchange protocol (IKE) to do this for you.</p></div><div class=paragraph><p>I recommend the latter. Apart from anything else, it is easier to set up.</p></div><div class=paragraph><p>Editing and displaying security policies is carried out using <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. By analogy, <code>setkey</code> is to the kernel’s security policy tables as <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> is to the kernel’s routing tables. <code>setkey</code> can also display the current security associations, and to continue the analogy further, is akin to <code>netstat -r</code> in that respect.</p></div><div class=paragraph><p>There are a number of choices for daemons to manage security associations with FreeBSD. This article will describe how to use one of these, racoon - which is available from <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a> in the FreeBSD Ports collection.</p></div><div class=paragraph><p>The racoon software must be run on both gateway hosts. On each host it is configured with the IP address of the other end of the VPN, and a secret key (which you choose, and must be the same on both gateways).</p></div><div class=paragraph><p>The two daemons then contact one another, confirm that they are who they say they are (by using the secret key that you configured). The daemons then generate a new secret key, and use this to encrypt the traffic over the VPN. They periodically change this secret, so that even if an attacker were to crack one of the keys (which is as theoretically close to unfeasible as it gets) it will not do them much good — by the time they have cracked the key the two daemons have chosen another one.</p></div><div class=paragraph><p>The configuration file for racoon is stored in <span class=filename>${PREFIX}/etc/racoon</span>. You should find a configuration file there, which should not need to be changed too much. The other component of racoon’s configuration, which you will need to change, is the "pre-shared key".</p></div><div class=paragraph><p>The default racoon configuration expects to find this in the file <span class=filename>${PREFIX}/etc/racoon/psk.txt</span>. It is important to note that the pre-shared key is <em>not</em> the key that will be used to encrypt your traffic across the VPN link, it is simply a token that allows the key management daemons to trust one another.</p></div><div class=paragraph><p><span class=filename>psk.txt</span> contains a line for each remote site you are dealing with. In this example, where there are two sites, each <span class=filename>psk.txt</span> file will contain one line (because each end of the VPN is only dealing with one other end).</p></div><div class=paragraph><p>On gateway host #1 this line should look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>W.X.Y.Z            secret</pre></div></div><div class=paragraph><p>That is, the <em>public</em> IP address of the remote end, whitespace, and a text string that provides the secret. Obviously, you should not use "secret" as your key — the normal rules for choosing a password apply.</p></div><div class=paragraph><p>On gateway host #2 the line would look like this</p></div><div class="literalblock programlisting"><div class=content><pre>A.B.C.D            secret</pre></div></div><div class=paragraph><p>That is, the public IP address of the remote end, and the same secret key. <span class=filename>psk.txt</span> must be mode <code>0600</code> (i.e., only read/write to <code>root</code>) before racoon will run.</p></div><div class=paragraph><p>You must run racoon on both gateway machines. You will also need to add some firewall rules to allow the IKE traffic, which is carried over UDP to the ISAKMP (Internet Security Association Key Management Protocol) port. Again, this should be fairly early in your firewall ruleset.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp</pre></div></div><div class=paragraph><p>Once racoon is running you can try pinging one gateway host from the other. The connection is still not encrypted, but racoon will then set up the security associations between the two hosts — this might take a moment, and you may see this as a short delay before the ping commands start responding.</p></div><div class=paragraph><p>Once the security association has been set up you can view it using <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Run</p></div><div class="literalblock programlisting"><div class=content><pre>setkey -D</pre></div></div><div class=paragraph><p>on either host to view the security association information.</p></div><div class=paragraph><p>That’s one half of the problem. The other half is setting your security policies.</p></div><div class=paragraph><p>To create a sensible security policy, let’s review what’s been set up so far. This discussions hold for both ends of the link.</p></div><div class=paragraph><p>Each IP packet that you send out has a header that contains data about the packet. The header includes the IP addresses of both the source and destination. As we already know, private IP addresses, such as the <code>192.168.x.y</code> range are not supposed to appear on the public Internet. Instead, they must first be encapsulated inside another packet. This packet must have the public source and destination IP addresses substituted for the private addresses.</p></div><div class=paragraph><p>So if your outgoing packet started looking like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-out-pkt.png alt="ipsec out pkt"></div></div><div class=paragraph><p>Then it will be encapsulated inside another packet, looking something like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-encap-pkt.png alt="ipsec encap pkt"></div></div><div class=paragraph><p>This encapsulation is carried out by the <span class=filename>gif</span> device. As you can see, the packet now has real IP addresses on the outside, and our original packet has been wrapped up as data inside the packet that will be put out on the Internet.</p></div><div class=paragraph><p>Obviously, we want all traffic between the VPNs to be encrypted. You might try putting this in to words, as:</p></div><div class=paragraph><p>"If a packet leaves from <code>A.B.C.D</code>, and it is destined for <code>W.X.Y.Z</code>, then encrypt it, using the necessary security associations."</p></div><div class=paragraph><p>"If a packet arrives from <code>W.X.Y.Z</code>, and it is destined for <code>A.B.C.D</code>, then decrypt it, using the necessary security associations."</p></div><div class=paragraph><p>That’s close, but not quite right. If you did this, all traffic to and from <code>W.X.Y.Z</code>, even traffic that was not part of the VPN, would be encrypted. That’s not quite what you want. The correct policy is as follows</p></div><div class=paragraph><p>"If a packet leaves from <code>A.B.C.D</code>, and that packet is encapsulating another packet, and it is destined for <code>W.X.Y.Z</code>, then encrypt it, using the necessary security associations."</p></div><div class=paragraph><p>"If a packet arrives from <code>W.X.Y.Z</code>, and that packet is encapsulating another packet, and it is destined for <code>A.B.C.D</code>, then decrypt it, using the necessary security associations."</p></div><div class=paragraph><p>A subtle change, but a necessary one.</p></div><div class=paragraph><p>Security policies are also set using <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> features a configuration language for defining the policy. You can either enter configuration instructions via stdin, or you can use the <code>-f</code> option to specify a filename that contains configuration instructions.</p></div><div class=paragraph><p>The configuration on gateway host #1 (which has the public IP address <code>A.B.C.D</code>) to force all outbound traffic to <code>W.X.Y.Z</code> to be encrypted is:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Put these commands in a file (e.g. <span class=filename>/etc/ipsec.conf</span>) and then run</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -f /etc/ipsec.conf</span></code></pre></div></div><div class=paragraph><p><code>spdadd</code> tells <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> that we want to add a rule to the secure policy database. The rest of this line specifies which packets will match this policy. <code>A.B.C.D/32</code> and <code>W.X.Y.Z/32</code> are the IP addresses and netmasks that identify the network or hosts that this policy will apply to. In this case, we want it to apply to traffic between these two hosts. <code>ipencap</code> tells the kernel that this policy should only apply to packets that encapsulate other packets. <code>-P out</code> says that this policy applies to outgoing packets, and <code>ipsec</code> says that the packet will be secured.</p></div><div class=paragraph><p>The second line specifies how this packet will be encrypted. <code>esp</code> is the protocol that will be used, while <code>tunnel</code> indicates that the packet will be further encapsulated in an IPsec packet. The repeated use of <code>A.B.C.D</code> and <code>W.X.Y.Z</code> is used to select the security association to use, and the final <code>require</code> mandates that packets must be encrypted if they match this rule.</p></div><div class=paragraph><p>This rule only matches outgoing packets. You will need a similar rule to match incoming packets.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>Note the <code>in</code> instead of <code>out</code> in this case, and the necessary reversal of the IP addresses.</p></div><div class=paragraph><p>The other gateway host (which has the public IP address <code>W.X.Y.Z</code>) will need similar rules.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Finally, you need to add firewall rules to allow ESP and IPENCAP packets back and forth. These rules will need to be added to both hosts.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div><div class=paragraph><p>Because the rules are symmetric you can use the same rules on each gateway host.</p></div><div class=paragraph><p>Outgoing packets will now look something like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-crypt-pkt.png alt="ipsec crypt pkt"></div></div><div class=paragraph><p>When they are received by the far end of the VPN they will first be decrypted (using the security associations that have been negotiated by racoon). Then they will enter the <span class=filename>gif</span> interface, which will unwrap the second layer, until you are left with the innermost packet, which can then travel in to the inner network.</p></div><div class=paragraph><p>You can check the security using the same <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> test from earlier. First, log in to the <code>A.B.C.D</code> gateway machine, and run:</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>In another log in session on the same host run</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>This time you should see output like the following:</p></div><div class="literalblock programlisting"><div class=content><pre>XXX tcpdump output</pre></div></div><div class=paragraph><p>Now, as you can see, <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> shows the ESP packets. If you try to examine them with the <code>-s</code> option you will see (apparently) gibberish, because of the encryption.</p></div><div class=paragraph><p>Congratulations. You have just set up a VPN between two remote sites.</p></div><div class=ulist><div class=title>Summary</div><ul><li><p>Configure both kernels with:</p><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div></li><li><p>Install <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a>. Edit <span class=filename>${PREFIX}/etc/racoon/psk.txt</span> on both gateway hosts, adding an entry for the remote host’s IP address and a secret key that they both know. Make sure this file is mode 0600.</p></li><li><p>Add the following lines to <span class=filename>/etc/rc.conf</span> on each host:</p><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_file=&#34;/etc/ipsec.conf&#34;</pre></div></div></li><li><p>Create an <span class=filename>/etc/ipsec.conf</span> on each host that contains the necessary spdadd lines. On gateway host #1 this would be:</p><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>On gateway host #2 this would be:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div></li><li><p>Add firewall rules to allow IKE, ESP, and IPENCAP traffic to both hosts:</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div></li></ul></div><div class=paragraph><p>The previous two steps should suffice to get the VPN up and running. Machines on each network will be able to refer to one another using IP addresses, and all traffic across the link will be automatically and securely encrypted.</p></div></div></div></div></div><div class=sect1><h2 id=openssh>15.11. OpenSSH<a class=anchor href=#openssh></a></h2><div class=sectionbody><div class=paragraph><p>OpenSSH is a set of network connectivity tools used to access remote machines securely. It can be used as a direct replacement for <code>rlogin</code>, <code>rsh</code>, <code>rcp</code>, and <code>telnet</code>. Additionally, TCP/IP connections can be tunneled/forwarded securely through SSH. OpenSSH encrypts all traffic to effectively eliminate eavesdropping, connection hijacking, and other network-level attacks.</p></div><div class=paragraph><p>OpenSSH is maintained by the OpenBSD project, and is based upon SSH v1.2.12 with all the recent bug fixes and updates. It is compatible with both SSH protocols 1 and 2.</p></div><div class=sect2><h3 id=_advantages_of_using_openssh>15.11.1. Advantages of Using OpenSSH<a class=anchor href=#_advantages_of_using_openssh></a></h3><div class=paragraph><p>Normally, when using <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, data is sent over the network in an clear, un-encrypted form. Network sniffers anywhere in between the client and server can steal your user/password information or data transferred in your session. OpenSSH offers a variety of authentication and encryption methods to prevent this from happening.</p></div></div><div class=sect2><h3 id=_enabling_sshd>15.11.2. Enabling sshd<a class=anchor href=#_enabling_sshd></a></h3><div class=paragraph><p>The sshd is an option presented during a <code>Standard</code> install of FreeBSD. To see if sshd is enabled, check the <span class=filename>rc.conf</span> file for:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>This will load <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, the daemon program for OpenSSH, the next time your system initializes. Alternatively, it is possible to use <span class=filename>/etc/rc.d/sshd</span> <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> script to start OpenSSH:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/rc.d/sshd start</pre></div></div></div><div class=sect2><h3 id=_ssh_client>15.11.3. SSH Client<a class=anchor href=#_ssh_client></a></h3><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> utility works similarly to <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
Host key not found from the list of known hosts.
Are you sure you want to <span class=k>continue </span>connecting <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>? <span class=nb>yes
</span>Host <span class=s1>&#39;example.com&#39;</span> added to the list of known hosts.
user@example.com<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>The login will continue just as it would have if a session was created using <code>rlogin</code> or <code>telnet</code>. SSH utilizes a key fingerprint system for verifying the authenticity of the server when the client connects. The user is prompted to enter <code>yes</code> only when connecting for the first time. Future attempts to login are all verified against the saved fingerprint key. The SSH client will alert you if the saved fingerprint differs from the received fingerprint on future login attempts. The fingerprints are saved in <span class=filename>~/.ssh/known_hosts</span>, or <span class=filename>~/.ssh/known_hosts2</span> for SSH v2 fingerprints.</p></div><div class=paragraph><p>By default, recent versions of the OpenSSH servers only accept SSH v2 connections. The client will use version 2 if possible and will fall back to version 1. The client can also be forced to use one or the other by passing it the <code>-1</code> or <code>-2</code> for version 1 or version 2, respectively. The version 1 compatibility is maintained in the client for backwards compatibility with older versions.</p></div></div><div class=sect2><h3 id=_secure_copy>15.11.4. Secure Copy<a class=anchor href=#_secure_copy></a></h3><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> command works similarly to <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>; it copies a file to or from a remote machine, except in a secure fashion.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp user@example.com:/COPYRIGHT COPYRIGHT</span>
user@example.com<span class=s1>&#39;s password: *******
COPYRIGHT            100% |*****************************|  4735
00:00
#</span></code></pre></div></div><div class=paragraph><p>Since the fingerprint was already saved for this host in the previous example, it is verified when using <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> here.</p></div><div class=paragraph><p>The arguments passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> are similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a>, with the file or files in the first argument, and the destination in the second. Since the file is fetched over the network, through SSH, one or more of the file arguments takes on the form <code>user@host:path_to_remote_file</code>.</p></div></div><div class=sect2><h3 id=_configuration>15.11.5. Configuration<a class=anchor href=#_configuration></a></h3><div class=paragraph><p>The system-wide configuration files for both the OpenSSH daemon and client reside within the <span class=filename>/etc/ssh</span> directory.</p></div><div class=paragraph><p><span class=filename>ssh_config</span> configures the client settings, while <span class=filename>sshd_config</span> configures the daemon.</p></div><div class=paragraph><p>Additionally, the <code>sshd_program</code> (<span class=filename>/usr/sbin/sshd</span> by default), and <code>sshd_flags</code><span class=filename>rc.conf</span> options can provide more levels of configuration.</p></div></div><div class=sect2><h3 id=security-ssh-keygen>15.11.6. ssh-keygen<a class=anchor href=#security-ssh-keygen></a></h3><div class=paragraph><p>Instead of using passwords, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> can be used to generate DSA or RSA keys to authenticate a user:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> dsa
Generating public/private dsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>:
Created directory <span class=s1>&#39;/home/user/.ssh&#39;</span><span class=nb>.</span>
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:
Enter same passphrase again:
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> will create a public and private key pair for use in authentication. The private key is stored in <span class=filename>~/.ssh/id_dsa</span> or <span class=filename>~/.ssh/id_rsa</span>, whereas the public key is stored in <span class=filename>~/.ssh/id_dsa.pub</span> or <span class=filename>~/.ssh/id_rsa.pub</span>, respectively for DSA and RSA key types. The public key must be placed in <span class=filename>~/.ssh/authorized_keys</span> of the remote machine in order for the setup to work. Similarly, RSA version 1 public keys should be placed in <span class=filename>~/.ssh/authorized_keys</span>.</p></div><div class=paragraph><p>This will allow connection to the remote machine based upon SSH keys instead of passwords.</p></div><div class=paragraph><p>If a passphrase is used in <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>, the user will be prompted for a password each time in order to use the private key. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> can alleviate the strain of repeatedly entering long passphrases, and is explored in the <a href=#security-ssh-agent>ssh-agent and ssh-add</a> section below.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>The various options and files can be different according to the OpenSSH version you have on your system; to avoid problems you should consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> manual page.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=security-ssh-agent>15.11.7. ssh-agent and ssh-add<a class=anchor href=#security-ssh-agent></a></h3><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> utilities provide methods for SSH keys to be loaded into memory for use, without needing to type the passphrase each time.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> utility will handle the authentication using the private key(s) that are loaded into it. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> should be used to launch another application. At the most basic level, it could spawn a shell or at a more advanced level, a window manager.</p></div><div class=paragraph><p>To use <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> in a shell, first it will need to be spawned with a shell as an argument. Secondly, the identity needs to be added by running <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> and providing it the passphrase for the private key. Once these steps have been completed the user will be able to <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> to any host that has the corresponding public key installed. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for</span> /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>
%</code></pre></div></div><div class=paragraph><p>To use <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> in X11, a call to <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> will need to be placed in <span class=filename>~/.xinitrc</span>. This will provide the <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> services to all programs launched in X11. An example <span class=filename>~/.xinitrc</span> file might look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>This would launch <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, which would in turn launch XFCE, every time X11 starts. Then once that is done and X11 has been restarted so that the changes can take effect, simply run <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> to load all of your SSH keys.</p></div></div><div class=sect2><h3 id=security-ssh-tunneling>15.11.8. SSH Tunneling<a class=anchor href=#security-ssh-tunneling></a></h3><div class=paragraph><p>OpenSSH has the ability to create a tunnel to encapsulate another protocol in an encrypted session.</p></div><div class=paragraph><p>The following command tells <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> to create a tunnel for telnet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>The <code>ssh</code> command is used with the following options:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Forces <code>ssh</code> to use version 2 of the protocol. (Do not use if you are working with older SSH servers)</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>Indicates no command, or tunnel only. If omitted, <code>ssh</code> would initiate a normal session.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Forces <code>ssh</code> to run in the background.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Indicates a local tunnel in <em>localport:remotehost:remoteport</em> fashion.</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>The remote SSH server.</p></dd></dl></div><div class=paragraph><p>An SSH tunnel works by creating a listen socket on <code>localhost</code> on the specified port. It then forwards any connection received on the local host/port via the SSH connection to the specified remote host and port.</p></div><div class=paragraph><p>In the example, port <em>5023</em> on <code>localhost</code> is being forwarded to port <em>23</em> on <code>localhost</code> of the remote machine. Since <em>23</em> is telnet, this would create a secure telnet session through an SSH tunnel.</p></div><div class=paragraph><p>This can be used to wrap any number of insecure TCP protocols such as SMTP, POP3, FTP, etc.</p></div><div class=exampleblock><div class=title>Παράδειγμα 1. Using SSH to Create a Secure Tunnel for SMTP</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p>This can be used in conjunction with an <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> and additional user accounts to create a more seamless/hassle-free SSH tunneling environment. Keys can be used in place of typing a password, and the tunnels can be run as a separate user.</p></div></div></div><div class=sect3><h4 id=_practical_ssh_tunneling_examples>15.11.8.1. Practical SSH Tunneling Examples<a class=anchor href=#_practical_ssh_tunneling_examples></a></h4><div class=sect4><h5 id=_secure_access_of_a_pop3_server>15.11.8.1.1. Secure Access of a POP3 Server<a class=anchor href=#_secure_access_of_a_pop3_server></a></h5><div class=paragraph><p>At work, there is an SSH server that accepts connections from the outside. On the same office network resides a mail server running a POP3 server. The network, or network path between your home and office may or may not be completely trustable. Because of this, you need to check your e-mail in a secure manner. The solution is to create an SSH connection to your office’s SSH server, and tunnel through to the mail server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>When the tunnel is up and running, you can point your mail client to send POP3 requests to <code>localhost</code> port 2110. A connection here will be forwarded securely across the tunnel to <code>mail.example.com</code>.</p></div></div><div class=sect4><h5 id=_bypassing_a_draconian_firewall>15.11.8.1.2. Bypassing a Draconian Firewall<a class=anchor href=#_bypassing_a_draconian_firewall></a></h5><div class=paragraph><p>Some network administrators impose extremely draconian firewall rules, filtering not only incoming connections, but outgoing connections. You may be only given access to contact remote machines on ports 22 and 80 for SSH and web surfing.</p></div><div class=paragraph><p>You may wish to access another (perhaps non-work related) service, such as an Ogg Vorbis server to stream music. If this Ogg Vorbis server is streaming on some other port than 22 or 80, you will not be able to access it.</p></div><div class=paragraph><p>The solution is to create an SSH connection to a machine outside of your network’s firewall, and use it to tunnel to the Ogg Vorbis server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Your streaming client can now be pointed to <code>localhost</code> port 8888, which will be forwarded over to <code>music.example.com</code> port 8000, successfully evading the firewall.</p></div></div></div></div><div class=sect2><h3 id=_the_allowusers_users_option>15.11.9. The <code>AllowUsers</code> Users Option<a class=anchor href=#_the_allowusers_users_option></a></h3><div class=paragraph><p>It is often a good idea to limit which users can log in and from where. The <code>AllowUsers</code> option is a good way to accomplish this. For example, to only allow the <code>root</code> user to log in from <code>192.168.1.32</code>, something like this would be appropriate in the <span class=filename>/etc/ssh/sshd_config</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>To allow the user <code>admin</code> to log in from anywhere, just list the username by itself:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>Multiple users should be listed on the same line, like so:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is important that you list each user that needs to log in to this machine; otherwise they will be locked out.</p></div></td></tr></tbody></table></div><div class=paragraph><p>After making changes to <span class=filename>/etc/ssh/sshd_config</span> you must tell <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> to reload its config files, by running:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd reload</span></code></pre></div></div></div><div class=sect2><h3 id=_further_reading>15.11.10. Further Reading<a class=anchor href=#_further_reading></a></h3><div class=paragraph><p><a href=http://www.openssh.com/>OpenSSH</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp-server&amp;sektion=8&amp;format=html">sftp-server(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a></p></div></div></div></div><div class=sect1><h2 id=fs-acl>15.12. File System Access Control Lists<a class=anchor href=#fs-acl></a></h2><div class=sectionbody><div class=paragraph><p>In conjunction with file system enhancements like snapshots, FreeBSD 5.0 and later offers the security of File System Access Control Lists (ACLs).</p></div><div class=paragraph><p>Access Control Lists extend the standard UNIX® permission model in a highly compatible (POSIX®.1e) way. This feature permits an administrator to make use of and take advantage of a more sophisticated security model.</p></div><div class=paragraph><p>To enable ACL support for UFS file systems, the following:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>must be compiled into the kernel. If this option has not been compiled in, a warning message will be displayed when attempting to mount a file system supporting ACLs. This option is included in the <span class=filename>GENERIC</span> kernel. ACLs rely on extended attributes being enabled on the file system. Extended attributes are natively supported in the next generation UNIX® file system, UFS2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A higher level of administrative overhead is required to configure extended attributes on UFS1 than on UFS2. The performance of extended attributes on UFS2 is also substantially higher. As a result, UFS2 is generally recommended in preference to UFS1 for use with access control lists.</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACLs are enabled by the mount-time administrative flag, <code>acls</code>, which may be added to <span class=filename>/etc/fstab</span>. The mount-time flag can also be automatically set in a persistent manner using <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> to modify a superblock ACLs flag in the file system header. In general, it is preferred to use the superblock flag for several reasons:</p></div><div class=ulist><ul><li><p>The mount-time ACLs flag cannot be changed by a remount (<a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <code>-u</code>), only by means of a complete <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> and fresh <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. This means that ACLs cannot be enabled on the root file system after boot. It also means that you cannot change the disposition of a file system once it is in use.</p></li><li><p>Setting the superblock flag will cause the file system to always be mounted with ACLs enabled even if there is not an <span class=filename>fstab</span> entry or if the devices re-order. This prevents accidental mounting of the file system without ACLs enabled, which can result in ACLs being improperly enforced, and hence security problems.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>We may change the ACLs behavior to allow the flag to be enabled without a complete fresh <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, but we consider it desirable to discourage accidental mounting without ACLs enabled, because you can shoot your feet quite nastily if you enable ACLs, then disable them, then re-enable them without flushing the extended attributes. In general, once you have enabled ACLs on a file system, they should not be disabled, as the resulting file protections may not be compatible with those intended by the users of the system, and re-enabling ACLs may re-attach the previous ACLs to files that have since had their permissions changed, resulting in other unpredictable behavior.</p></div></td></tr></tbody></table></div><div class=paragraph><p>File systems with ACLs enabled will show a <code>+</code> (plus) sign in their permission settings when viewed. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>Here we see that the <span class=filename>directory1</span>, <span class=filename>directory2</span>, and <span class=filename>directory3</span> directories are all taking advantage of ACLs. The <span class=filename>public_html</span> directory is not.</p></div><div class=sect2><h3 id=_making_use_of_acls>15.12.1. Making Use of ACLs<a class=anchor href=#_making_use_of_acls></a></h3><div class=paragraph><p>The file system ACLs can be viewed by the <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> utility. For instance, to view the ACL settings on the <span class=filename>test</span> file, one would use the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>To change the ACL settings on this file, invoke the <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> utility. Observe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>The <code>-k</code> flag will remove all of the currently defined ACLs from a file or file system. The more preferable method would be to use <code>-b</code> as it leaves the basic fields required for ACLs to work.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>In the aforementioned command, the <code>-m</code> option was used to modify the default ACL entries. Since there were no pre-defined entries, as they were removed by the previous command, this will restore the default options and assign the options listed. Take care to notice that if you add a user or group which does not exist on the system, an <code>Invalid argument</code> error will be printed to <span class=filename>stdout</span>.</p></div></div></div></div><div class=sect1><h2 id=security-portaudit>15.13. Monitoring Third Party Security Issues<a class=anchor href=#security-portaudit></a></h2><div class=sectionbody><div class=paragraph><p>In recent years, the security world has made many improvements to how vulnerability assessment is handled. The threat of system intrusion increases as third party utilities are installed and configured for virtually any operating system available today.</p></div><div class=paragraph><p>Vulnerability assessment is a key factor in security, and while FreeBSD releases advisories for the base system, doing so for every third party utility is beyond the FreeBSD Project’s capability. There is a way to mitigate third party vulnerabilities and warn administrators of known security issues. A FreeBSD add on utility known as Portaudit exists solely for this purpose.</p></div><div class=paragraph><p>The <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portaudit/>ports-mgmt/portaudit</a> port polls a database, updated and maintained by the FreeBSD Security Team and ports developers, for known security issues.</p></div><div class=paragraph><p>To begin using Portaudit, one must install it from the Ports Collection:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portaudit  make install clean</span></code></pre></div></div><div class=paragraph><p>During the install process, the configuration files for <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> will be updated, permitting Portaudit output in the daily security runs. Ensure the daily security run emails, which are sent to <code>root</code>'s email account, are being read. No more configuration will be required here.</p></div><div class=paragraph><p>After installation, an administrator can update the database and view known vulnerabilities in installed packages by invoking the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -Fda</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The database will automatically be updated during the <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> run; thus, the previous command is completely optional. It is only required for the following examples.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To audit the third party utilities installed as part of the Ports Collection at anytime, an administrator need only run the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -a</span></code></pre></div></div><div class=paragraph><p>Portaudit will produce something like this for vulnerable packages:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>By pointing a web browser to the URL shown, an administrator may obtain more information about the vulnerability in question. This will include versions affected, by FreeBSD Port version, along with other web sites which may contain security advisories.</p></div><div class=paragraph><p>In short, Portaudit is a powerful utility and extremely useful when coupled with the Portupgrade port.</p></div></div></div><div class=sect1><h2 id=security-advisories>15.14. FreeBSD Security Advisories<a class=anchor href=#security-advisories></a></h2><div class=sectionbody><div class=paragraph><p>Like many production quality operating systems, FreeBSD publishes "Security Advisories". These advisories are usually mailed to the security lists and noted in the Errata only after the appropriate releases have been patched. This section will work to explain what an advisory is, how to understand it, and what measures to take in order to patch a system.</p></div><div class=sect2><h3 id=_what_does_an_advisory_look_like>15.14.1. What does an advisory look like?<a class=anchor href=#_what_does_an_advisory_look_like></a></h3><div class=paragraph><p>The FreeBSD security advisories look similar to the one below, taken from the <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>ηλεκτρονική λίστα Ανακοινώσεων για Θέματα Ασφάλειας του FreeBSD</a> mailing list.</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem <i class=conum data-value=1></i><b>(1)</b>

Category:       core <i class=conum data-value=2></i><b>(2)</b>
Module:         sys <i class=conum data-value=3></i><b>(3)</b>
Announced:      2003-09-23 <i class=conum data-value=4></i><b>(4)</b>
Credits:        Person@EMAIL-ADDRESS <i class=conum data-value=5></i><b>(5)</b>
Affects:        All releases of FreeBSD <i class=conum data-value=6></i><b>(6)</b>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39) <i class=conum data-value=7></i><b>(7)</b>
CVE Name:	CVE-XXXX-XXXX <i class=conum data-value=8></i><b>(8)</b>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background <i class=conum data-value=9></i><b>(9)</b>

II.  Problem Description <i class=conum data-value=10></i><b>(10)</b>

III. Impact <i class=conum data-value=11></i><b>(11)</b>

IV.  Workaround <i class=conum data-value=12></i><b>(12)</b>

V.   Solution <i class=conum data-value=13></i><b>(13)</b>

VI.  Correction details <i class=conum data-value=14></i><b>(14)</b>

VII. References <i class=conum data-value=15></i><b>(15)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The <code>Topic</code> field indicates exactly what the problem is. It is basically an introduction to the current security advisory and notes the utility with the vulnerability.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>Category</code> refers to the affected part of the system which may be one of <code>core</code>, <code>contrib</code>, or <code>ports</code>. The <code>core</code> category means that the vulnerability affects a core component of the FreeBSD operating system. The <code>contrib</code> category means that the vulnerability affects software contributed to the FreeBSD Project, such as sendmail. Finally the <code>ports</code> category indicates that the vulnerability affects add on software available as part of the Ports Collection.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>Module</code> field refers to the component location, for instance <code>sys</code>. In this example, we see that the module, <code>sys</code>, is affected; therefore, this vulnerability affects a component used within the kernel.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>Announced</code> field reflects the date said security advisory was published, or announced to the world. This means that the security team has verified that the problem does exist and that a patch has been committed to the FreeBSD source code repository.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The <code>Credits</code> field gives credit to the individual or organization who noticed the vulnerability and reported it.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>The <code>Affects</code> field explains which releases of FreeBSD are affected by this vulnerability. For the kernel, a quick look over the output from <code>ident</code> on the affected files will help in determining the revision. For ports, the version number is listed after the port name in <span class=filename>/var/db/pkg</span>. If the system does not sync with the FreeBSD CVS repository and rebuild daily, chances are that it is affected.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>The <code>Corrected</code> field indicates the date, time, time offset, and release that was corrected.
Reserved for the identification information used to look up vulnerabilities in the Common Vulnerabilities Database system.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The <code>Background</code> field gives information on exactly what the affected utility is. Most of the time this is why the utility exists in FreeBSD, what it is used for, and a bit of information on how the utility came to be.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>The <code>Problem Description</code> field explains the security hole in depth. This can include information on flawed code, or even how the utility could be maliciously used to open a security hole.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>The <code>Impact</code> field describes what type of impact the problem could have on a system. For example, this could be anything from a denial of service attack, to extra privileges available to users, or even giving the attacker superuser access.</td></tr><tr><td><i class=conum data-value=11></i><b>11</b></td><td>The <code>Workaround</code> field offers a feasible workaround to system administrators who may be incapable of upgrading the system. This may be due to time constraints, network availability, or a slew of other reasons. Regardless, security should not be taken lightly, and an affected system should either be patched or the security hole workaround should be implemented.</td></tr><tr><td><i class=conum data-value=12></i><b>12</b></td><td>The <code>Solution</code> field offers instructions on patching the affected system. This is a step by step tested and verified method for getting a system patched and working securely.</td></tr><tr><td><i class=conum data-value=13></i><b>13</b></td><td>The <code>Correction Details</code> field displays the CVS branch or release name with the periods changed to underscore characters. It also shows the revision number of the affected files within each branch.</td></tr><tr><td><i class=conum data-value=14></i><b>14</b></td><td>The <code>References</code> field usually offers sources of other information. This can include web URLs, books, mailing lists, and newsgroups.</td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security-accounting>15.15. Process Accounting<a class=anchor href=#security-accounting></a></h2><div class=sectionbody><div class=paragraph><p>Process accounting is a security method in which an administrator may keep track of system resources used, their allocation among users, provide for system monitoring, and minimally track a user’s commands.</p></div><div class=paragraph><p>This indeed has its own positive and negative points. One of the positives is that an intrusion may be narrowed down to the point of entry. A negative is the amount of logs generated by process accounting, and the disk space they may require. This section will walk an administrator through the basics of process accounting.</p></div><div class=sect2><h3 id=_enable_and_utilizing_process_accounting>15.15.1. Enable and Utilizing Process Accounting<a class=anchor href=#_enable_and_utilizing_process_accounting></a></h3><div class=paragraph><p>Before making use of process accounting, it must be enabled. To do this, execute the following commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/account/acct</span>

<span class=c># accton /var/account/acct</span>

<span class=c># echo &#39;accounting_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Once enabled, accounting will begin to track CPU stats, commands, etc. All accounting logs are in a non-human readable format and may be viewed using the <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> utility. If issued without any options, <code>sa</code> will print information relating to the number of per user calls, the total elapsed time in minutes, total CPU and user time in minutes, average number of I/O operations, etc.</p></div><div class=paragraph><p>To view information about commands being issued, one would use the <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a> utility. The <code>lastcomm</code> may be used to print out commands issued by users on specific <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>, for example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls</span>
	trhodes ttyp1</code></pre></div></div><div class=paragraph><p>Would print out all known usage of the <code>ls</code> by <code>trhodes</code> on the ttyp1 terminal.</p></div><div class=paragraph><p>Many other useful options exist and are explained in the <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> manual pages.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Τελευταία τροποποίηση</strong>: 9 Μαρτίου 2024 από <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Προηγούμενη></i><div class=container><a href=http://172.16.201.134:1313/el/books/handbook/users class=direction>Προηγούμενη</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Αρχική></i><div class=container><a href=../ class=direction>Αρχική</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/el/books/handbook/jails class=direction>Επόμενη</a></div><i class="fa fa-angle-right" aria-hidden=true title=Επόμενη></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Πίνακας περιεχομένων</h3><nav id=TableOfContents><ul><li><a href=#security-synopsis>15.1. Σύνοψη</a></li><li><a href=#security-intro>15.2. Introduction</a></li><li><a href=#securing-freebsd>15.3. Securing FreeBSD</a></li><li><a href=#crypt>15.4. DES, MD5, and Crypt</a></li><li><a href=#one-time-passwords>15.5. One-time Passwords</a></li><li><a href=#tcpwrappers>15.6. TCP Wrappers</a></li><li><a href=#kerberosIV>15.7. KerberosIV</a></li><li><a href=#kerberos5>15.8. Kerberos5</a></li><li><a href=#openssl>15.9. OpenSSL</a></li><li><a href=#ipsec>15.10. VPN over IPsec</a></li><li><a href=#openssh>15.11. OpenSSH</a></li><li><a href=#fs-acl>15.12. File System Access Control Lists</a></li><li><a href=#security-portaudit>15.13. Monitoring Third Party Security Issues</a></li><li><a href=#security-advisories>15.14. FreeBSD Security Advisories</a></li><li><a href=#security-accounting>15.15. Process Accounting</a></li></ul></nav><hr><div class=resources><h3>Πηγές</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Λήψη PDF"></i><a href=https://download.freebsd.org/doc/el/books/handbook/handbook_el.pdf>Λήψη PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Τροποποίηση αυτής της σελίδας"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/el/_index target=_blank>Τροποποίηση αυτής της σελίδας</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/el/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Επιλογή γλώσσας">
<span>Greek</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>Σύστημα</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Υψηλή αντίθεση</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/el class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/el/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>