<!doctype html><html class=theme-light lang=zh-cn><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/><title>第 1 章 引导过程与内核初始化 | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="第 1 章 引导过程与内核初始化"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-cn"><meta property="og:url" content="http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/zh-cn\/books\/arch-handbook\/boot\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-cn>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books>Books</a></li><li><a href=http://172.16.201.134:1313/zh-cn/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/zh-cn/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-cn>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-6dcd22d99f78db2a9aacae23be13866e class=toggle>
<label for=chapter-6dcd22d99f78db2a9aacae23be13866e><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/parti/>Part I. 内核</a></li><li><input type=checkbox id=chapter-9cc61bc35df69063dc03a5911e1ad9c9 class=toggle checked>
<label class="icon cursor" for=chapter-9cc61bc35df69063dc03a5911e1ad9c9><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/>第 1 章 引导过程与内核初始化</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/#boot-synopsis>1.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/#boot-overview>1.2. 总览</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/#boot-bios>1.3. BIOS POST</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/#boot-boot0>1.4. <code>boot0</code>阶段</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/#boot-boot2>1.5. <code>boot2</code>阶段</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/#boot-loader>1.6. loader阶段</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/boot/#boot-kernel>1.7. 内核初始化</a></li></ul></li><li><input type=checkbox id=chapter-3a651b0a4b9f6238336624d3c0fa5187 class=toggle>
<label class="icon cursor" for=chapter-3a651b0a4b9f6238336624d3c0fa5187><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/locking/>第 2 章 内核中的锁</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/locking/#locking-mutexes>2.1. Mutex</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/locking/#locking-sx>2.2. 共享互斥锁</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/locking/#locking-atomic>2.3. 原子保护变量</a></li></ul></li><li><input type=checkbox id=chapter-bf0b823c107a80f3035dfd6fae09d023 class=toggle>
<label class="icon cursor" for=chapter-bf0b823c107a80f3035dfd6fae09d023><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/kobj/>第 3 章 内核对象</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/kobj/#kernel-objects-term>3.1. 术语</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/kobj/#kernel-objects-operation>3.2. Kobj的工作流程</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/kobj/#kernel-objects-using>3.3. 使用Kobj</a></li></ul></li><li><input type=checkbox id=chapter-41dab1afed6cf3ffa54628db4227e196 class=toggle>
<label class="icon cursor" for=chapter-41dab1afed6cf3ffa54628db4227e196><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/jail/>第 4 章 Jail子系统</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/jail/#jail-arch>4.1. Jail的系统结构</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/jail/#jail-restrictions>4.2. 系统对被囚禁程序的限制</a></li></ul></li><li><input type=checkbox id=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8 class=toggle>
<label class="icon cursor" for=chapter-e7d9ebcb448b0045179ebe22f8e2e9d8><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sysinit/>第 5 章 SYSINIT框架</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sysinit/#sysinit-term>5.1. 术语</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sysinit/#sysinit-operation>5.2. SYSINIT操作</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sysinit/#sysinit-using>5.3. 使用SYSINIT</a></li></ul></li><li><input type=checkbox id=chapter-8b57b16ba53538421a8fb2152b25976f class=toggle>
<label class="icon cursor" for=chapter-8b57b16ba53538421a8fb2152b25976f><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/>第 6 章 TrustedBSD MAC 框架</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-copyright>6.1. MAC 文档版权声明</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-synopsis>6.2. 术语解析</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-introduction>6.3. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-background>6.4. 安全策略背景知识</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-framework-kernel-arch>6.5. MAC 框架的内核体系结构</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-policy-architecture>6.6. MAC策略模块体系结构</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-entry-point-reference>6.7. MAC策略入口函数参考</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-userland-arch>6.8. 应用层体系结构</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/mac/#mac-conclusion>6.9. 小结</a></li></ul></li><li><input type=checkbox id=chapter-28609916419208e3a19d240cf7593906 class=toggle>
<label class="icon cursor" for=chapter-28609916419208e3a19d240cf7593906><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/vm/>第 7 章 虚拟内存系统</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/vm/#vm-physmem>7.1. 物理内存的管理-<code>vm_page_t</code></a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/vm/#vm-cache>7.2. 统一的缓存信息结构体-<code>vm_object_t</code></a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/vm/#vm-fileio>7.3. 文件系统输入/输出-<code>buf</code>结构体</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/vm/#vm-pagetables>7.4. 映射页表-<code>vm_map_t, vm_entry_t</code></a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/vm/#vm-kvm>7.5. KVM存储映射</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/vm/#vm-tuning>7.6. 调整FreeBSD的虚拟内存系统</a></li></ul></li><li><input type=checkbox id=chapter-716edd44e8ad22ea57cdf273d2578872 class=toggle>
<label class="icon cursor" for=chapter-716edd44e8ad22ea57cdf273d2578872><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/>第 8 章 SMPng 设计文档</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/#smp-intro>8.1. 绪论</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/#smp-lock-fundamentals>8.2. 基本工具与上锁的基础知识</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/#smp-design>8.3. 架构与设计概览</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/#smp-lock-strategies>8.4. 特定数据的锁策略</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/#smp-implementation-notes>8.5. 实现说明</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/#smp-misc>8.6. 其它话题</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/smp/#smp-glossary>术语表</a></li></ul></li><li><input type=checkbox id=chapter-448f803e40f97b1ff8336db9ba637745 class=toggle>
<label for=chapter-448f803e40f97b1ff8336db9ba637745><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/partii/>Part II. 设备驱动程序</a></li><li><input type=checkbox id=chapter-6971d35b0bbe2a0bdb005a02546cd580 class=toggle>
<label class="icon cursor" for=chapter-6971d35b0bbe2a0bdb005a02546cd580><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/driverbasics/>第 9 章 编写 FreeBSD 设备驱动程序</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/driverbasics/#driverbasics-intro>9.1. 简介</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/driverbasics/#driverbasics-kld>9.2. 动态内核链接工具-KLD</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/driverbasics/#driverbasics-access>9.3. 访问设备驱动程序</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/driverbasics/#driverbasics-char>9.4. 字符设备</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/driverbasics/#driverbasics-block>9.5. 块设备(消亡中)</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/driverbasics/#driverbasics-net>9.6. 网络设备驱动程序</a></li></ul></li><li><input type=checkbox id=chapter-9cc7968be065b256e57086439d93e9a4 class=toggle>
<label class="icon cursor" for=chapter-9cc7968be065b256e57086439d93e9a4><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/>第 10 章 ISA设备驱动程序</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-synopsis>10.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-basics>10.2. 基本信息</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-device-t>10.3. Device_t指针</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-config>10.4. 配置文件与自动配置期间识别和探测的顺序</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-resources>10.5. 资源</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-busmem>10.6. 总线内存映射</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-dma>10.7. DMA</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-probe>10.8. xxx_isa_probe</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-attach>10.9. xxx_isa_attach</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-detach>10.10. xxx_isa_detach</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-shutdown>10.11. xxx_isa_shutdown</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/isa/#isa-driver-intr>10.12. xxx_intr</a></li></ul></li><li><input type=checkbox id=chapter-0b427d421e89aa3107f62d5b70f6a0f2 class=toggle>
<label class="icon cursor" for=chapter-0b427d421e89aa3107f62d5b70f6a0f2><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/pci/>第 11 章 PCI设备</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/pci/#pci-probe>11.1. 探测与连接</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/pci/#pci-bus>11.2. 总线资源</a></li></ul></li><li><input type=checkbox id=chapter-0b7eb8d45a0ea6bc9c2882e903b93959 class=toggle>
<label class="icon cursor" for=chapter-0b7eb8d45a0ea6bc9c2882e903b93959><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/>第 12 章 通用访问方法SCSI控制器</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/#scsi-synopsis>12.1. 提纲</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/#scsi-general>12.2. 通用基础结构</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/#scsi-polling>12.3. 轮询</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/#scsi-async>12.4. 异步事件</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/#scsi-interrupts>12.5. 中断</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/#scsi-errors>12.6. 错误总览</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/scsi/#scsi-timeout>12.7. 超时处理</a></li></ul></li><li><input type=checkbox id=chapter-bdaa4909dfbdcec8d7be976fd87cb00e class=toggle>
<label class="icon cursor" for=chapter-bdaa4909dfbdcec8d7be976fd87cb00e><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/usb/>第 13 章 USB设备</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/usb/#usb-intro>13.1. 简介</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/usb/#usb-hc>13.2. 主控器</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/usb/#usb-dev>13.3. USB设备信息</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/usb/#usb-devprobe>13.4. 设备的探测和连接</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/usb/#usb-protocol>13.5. USB驱动程序的协议信息</a></li></ul></li><li><input type=checkbox id=chapter-5fc5c179f5014d968a5c8feec7e10e59 class=toggle>
<label class="icon cursor" for=chapter-5fc5c179f5014d968a5c8feec7e10e59><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/newbus/>第 14 章 Newbus</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/newbus/#newbus-devdrivers>14.1. 设备驱动程序</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/newbus/#newbus-overview>14.2. Newbus概览</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/newbus/#newbus-api>14.3. Newbus API</a></li></ul></li><li><input type=checkbox id=chapter-7d3796cced00105c77e7f87e84edd73b class=toggle>
<label class="icon cursor" for=chapter-7d3796cced00105c77e7f87e84edd73b><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sound/>第 15 章 声音子系统</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sound/#oss-intro>15.1. 简介</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sound/#oss-files>15.2. 文件</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sound/#pcm-probe-and-attach>15.3. 探测，连接等</a></li><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/sound/#oss-interfaces>15.4. 接口</a></li></ul></li><li><input type=checkbox id=chapter-41c74c3e72fcf5116f6d999c36ef185b class=toggle>
<label class="icon cursor" for=chapter-41c74c3e72fcf5116f6d999c36ef185b><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/pccard/>第 16 章 PC Card</a><ul><li><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/pccard/#pccard-adddev>16.1. 添加设备</a></li></ul></li><li><input type=checkbox id=chapter-2a7cf37011599a8e3d62d1e3008c3c5d class=toggle>
<label for=chapter-2a7cf37011599a8e3d62d1e3008c3c5d><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/partiii/>Part III. 附录</a></li><li><input type=checkbox id=chapter-d4c82056f0235da9fde0d29203d44f9a class=toggle>
<label for=chapter-d4c82056f0235da9fde0d29203d44f9a><a role=button></a></label><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/bibliography/>参考书目</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>第 1 章 引导过程与内核初始化</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#boot-synopsis>1.1. 概述</a></li><li><a href=#boot-overview>1.2. 总览</a></li><li><a href=#boot-bios>1.3. BIOS POST</a></li><li><a href=#boot-boot0>1.4. <code>boot0</code>阶段</a></li><li><a href=#boot-boot2>1.5. <code>boot2</code>阶段</a></li><li><a href=#boot-loader>1.6. loader阶段</a></li><li><a href=#boot-kernel>1.7. 内核初始化</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=boot-synopsis>1.1. 概述<a class=anchor href=#boot-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>这一章是对引导过程和系统初始化过程的总览。这些过程始于BIOS(固件)POST, 直到第一个用户进程建立。由于系统启动的最初步骤是与硬件结构相关的、是紧配合的， 这里用IA-32(Intel Architecture 32bit)结构作为例子。</p></div></div></div><div class=sect1><h2 id=boot-overview>1.2. 总览<a class=anchor href=#boot-overview></a></h2><div class=sectionbody><div class=paragraph><p>一台运行FreeBSD的计算机有多种引导方法。这里讨论其中最通常的方法， 也就是从安装了操作系统的硬盘上引导。引导过程分几步完成:</p></div><div class=ulist><ul><li><p>BIOS POST</p></li><li><p><code>boot0</code>阶段</p></li><li><p><code>boot2</code>阶段</p></li><li><p>loader阶段</p></li><li><p>内核初始化</p></li></ul></div><div class=paragraph><p><code>boot0</code>和<code>boot2</code>阶段在手册 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a>中被称为<em>bootstrap stages 1 and 2</em>， 是FreeBSD的3阶段引导过程的开始。在每一阶段都有各种各样的信息显示在屏幕上， 你可以参考下表识别出这些步骤。请注意实际的显示内容可能随机器的不同而有一些区别:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:90%><col style=width:10%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>视不同机器而定</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BIOS(固件)消息</p></td></tr><tr><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1    FreeBSD
F2    BSD
F5    Disk 2</code></pre></div></div></div></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>boot0</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span>FreeBSD/i386 BOOT
Default: 1:ad<span class=o>(</span>1,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>boot2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>BTX loader 1.0 BTX version is 1.01
BIOS drive A: is disk0
BIOS drive C: is disk1
BIOS 639kB/64512kB available memory
FreeBSD/i386 bootstrap loader, Revision 0.8
Console internal video/keyboard
<span class=o>(</span>jkh@bento.freebsd.org, Mon Nov 20 11:41:23 GMT 2000<span class=o>)</span>
/kernel <span class=nv>text</span><span class=o>=</span>0x1234 <span class=nv>data</span><span class=o>=</span>0x2345 <span class=nv>syms</span><span class=o>=[</span>0x4+0x3456]
Hit <span class=o>[</span>Enter] to boot immediately, or any other key <span class=k>for </span><span class=nb>command </span>prompt
Booting <span class=o>[</span>kernel] <span class=k>in </span>9 seconds..._</code></pre></div></div></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>loader</p></td></tr><tr><td class="tableblock halign-left valign-top"><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Copyright <span class=o>(</span>c<span class=o>)</span> 1992-2002 The FreeBSD Project.
Copyright <span class=o>(</span>c<span class=o>)</span> 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
        The Regents of the University of California. All rights reserved.
FreeBSD 4.6-RC <span class=c>#0: Sat May  4 22:49:02 GMT 2002</span>
    devnull@kukas:/usr/obj/usr/src/sys/DEVNULL
Timecounter <span class=s2>&#34;i8254&#34;</span>  frequency 1193182 Hz</code></pre></div></div></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>内核</p></td></tr></tbody></table></div></div><div class=sect1><h2 id=boot-bios>1.3. BIOS POST<a class=anchor href=#boot-bios></a></h2><div class=sectionbody><div class=paragraph><p>当PC加电后，处理器的寄存器被设为某些特定值。在这些寄存器中， <em>指令指针</em>寄存器被设为32位值0xfffffff0。 指令指针寄存器指向处理器将要执行的指令代码。<code>cr1</code>， 一个32位控制寄存器，在刚启动时值被设为0。cr1的PE(Protected Enabled， 保护模式使能)位用来指示处理器是处于保护模式还是实地址模式。 由于启动时该位被清位，处理器在实地址模式中引导。在实地址模式中， 线性地址与物理地址是等同的。</p></div><div class=paragraph><p>值0xfffffff0略小于4G,因此计算机没有4G字节物理内存， 这就不会是一个有效的内存地址。计算机硬件将这个地址转指向BIOS存储块。</p></div><div class=paragraph><p>BIOS表示<em>Basic Input Output System</em> (基本输入输出系统)。在主板上，它被固化在一个相对容量较小的 只读存储器(Read-Only Memory, ROM)。BIOS包含各种各样为主板硬件 定制的底层例程。就这样，处理器首先指向常驻BIOS存储器的地址 0xfffffff0。通常这个位置包含一条跳转指令，指向BIOS的POST例程。</p></div><div class=paragraph><p>POST表示<em>Power On Self Test</em>(加电自检)。 这套程序包括内存检查，系统总线检查和其它底层工具， 从而使得CPU能够初始化整台计算机。这一阶段中有一个重要步骤， 就是确定引导设备。现在所有的BIOS都允许手工选择引导设备。 你可以从软盘、光盘驱动器、硬盘等设备引导。</p></div><div class=paragraph><p>POST的最后一步是执行<code>INT 0x19</code>指令。 这个指令从引导设备第一个扇区读取512字节，装入地址0x7c00。 <em>第一个扇区</em>的说法最早起源于硬盘的结构， 硬盘面被分为若干圆柱形轨道。给轨道编号，同时又将轨道分为 一定数目(通常是64)的扇形。0号轨道是硬盘的最外圈，1号扇区， 第一个扇区(轨道、柱面都从0开始编号，而扇区从1开始编号) 有着特殊的作用，它又被称为主引导记录(Master Boot Record, MBR)。 第一轨剩余的扇区常常不使用。</p></div></div></div><div class=sect1><h2 id=boot-boot0>1.4. <code>boot0</code>阶段<a class=anchor href=#boot-boot0></a></h2><div class=sectionbody><div class=paragraph><p>让我们看一下文件<span class=filename>/boot/boot0</span>。 这是一个仅512字节的小文件。如果在FreeBSD安装过程中选择 "bootmanager"，这个文件中的内容将被写入硬盘MBR</p></div><div class=paragraph><p>如前所述， <code>INT 0x19</code> 指令装载 MBR， 也就是 <span class=filename>boot0</span> 的内容至内存地址 0x7c00。 再看文件 <span class=filename>sys/boot/i386/boot0/boot0.S</span>， 可以猜想这里面发生了什么 - 这是引导管理器， 一段由 Robert Nordier书写的令人起敬的程序片段。</p></div><div class=paragraph><p>MBR里，也就是<span class=filename>boot0</span>里， 从偏移量0x1be开始有一个特殊的结构，称为 <em>分区表</em>。其中有4条记录 (称为<em>分区记录</em>)，每条记录16字节。 分区记录表示硬盘如何被划分，在FreeBSD的术语中， 这被称为slice(d)。16字节中有一个标志字节决定这个分区是否可引导。 有仅只能有一个分区可设定这一标志。否则， <span class=filename>boot0</span>的代码将拒绝继续执行。</p></div><div class=paragraph><p>一个分区记录有如下域：</p></div><div class=ulist><ul><li><p>1字节 文件系统类型</p></li><li><p>1字节 可引导标志</p></li><li><p>6字节 CHS格式描述符</p></li><li><p>8字节 LBA格式描述符</p></li></ul></div><div class=paragraph><p>一个分区记录描述符包含某一分区在硬盘上的确切位置信息。 LBA和CHS两种描述符指示相同的信息，但是指示方式有所不同：LBA (逻辑块寻址，Logical Block Addressing)指示分区的起始扇区和分区长度， 而CHS(柱面 磁头 扇区)指示首扇区和末扇区</p></div><div class=paragraph><p>引导管理器扫描分区表，并在屏幕上显示菜单，以便用户可以 选择用于引导的磁盘和分区。在键盘上按下相应的键后， <span class=filename>boot0</span>进行如下动作：</p></div><div class=ulist><ul><li><p>标记选中的分区为可引导，清除以前的可引导标志</p></li><li><p>记住本次选择的分区以备下次引导时作为缺省项</p></li><li><p>装载选中分区的第一个扇区，并跳转执行之</p></li></ul></div><div class=paragraph><p>什么数据会存在于一个可引导扇区(这里指FreeBSD扇区)的第一扇区里呢？ 正如你已经猜到的，那就是<span class=filename>boot2</span>。</p></div></div></div><div class=sect1><h2 id=boot-boot2>1.5. <code>boot2</code>阶段<a class=anchor href=#boot-boot2></a></h2><div class=sectionbody><div class=paragraph><p>也许你想知道，为什么<code>boot2</code>是在 <code>boot0</code>之后，而不是在boot1之后。事实上， 也有一个512字节的文件<span class=filename>boot1</span>存放在目录 <span class=filename>/boot</span>里，那是用来从一张软盘引导系统的。 从软盘引导时，<span class=filename>boot1</span>起着 <span class=filename>boot0</span>对硬盘引导相同的作用:它找到 <span class=filename>boot2</span>并运行之。</p></div><div class=paragraph><p>你可能已经看到有一文件<span class=filename>/boot/mbr</span>。 这是<span class=filename>boot0</span>的简化版本。 <span class=filename>mbr</span>中的代码不会显示菜单让用户选择， 而只是简单的引导被标志的分区。</p></div><div class=paragraph><p>实现<span class=filename>boot2</span>的代码存放在目录 <span class=filename>sys/boot/i386/boot2/</span>里，对应的可执行文件在 <span class=filename>/boot</span>里。在<span class=filename>/boot</span>里的文件 <span class=filename>boot0</span>和<span class=filename>boot2</span>不会在引导过程中使用， 只有boot0cfg这样的工具才会使用它们。 <span class=filename>boot0</span>的内容应在MBR中才能生效。 <span class=filename>boot2</span>位于可引导的FreeBSD分区的开始。 这些位置不受文件系统控制，所以它们不可用ls 之类的命令查看。</p></div><div class=paragraph><p><code>boot2</code>的主要任务是装载文件 <span class=filename>/boot/loader</span>，那是引导过程的第三阶段。 在<code>boot2</code>中的代码不能使用诸如 <code>open()</code>和<code>read()</code> 之类的例程函数,因为内核还没有被加载。而应当扫描硬盘， 读取文件系统结构，找到文件<span class=filename>/boot/loader</span>， 用BIOS的功能将它读入内存，然后从其入口点开始执行之。</p></div><div class=paragraph><p>除此之外，<code>boot2</code>还可提示用户进行选择， loader可以从其它磁盘、系统单元、分区装载。</p></div><div class=paragraph><p><code>boot2</code> 的二进制代码用特殊的方式产生：</p></div><div class="literalblock programlisting"><div class=content><pre>sys/boot/i386/boot2/Makefile
boot2: boot2.ldr boot2.bin ${BTX}/btx/btx
	btxld -v -E ${ORG2} -f bin -b ${BTX}/btx/btx -l boot2.ldr \
		-o boot2.ld -P 1 boot2.bin</pre></div></div><div class=paragraph><p>这个Makefile片断表明<a href="https://man.freebsd.org/cgi/man.cgi?query=btxld&amp;sektion=8&amp;format=html">btxld(8)</a>被用来链接二进制代码。 BTX表示引导扩展器(BooT eXtender)是给程序(称为客户(client) 提供保护模式环境、并与客户程序相链接的一段代码。所以 <code>boot2</code>是一个BTX客户，使用BTX提供的服务。</p></div><div class=paragraph><p>工具btxld是链接器， 它将两个二进制代码链接在一起。<a href="https://man.freebsd.org/cgi/man.cgi?query=btxld&amp;sektion=8&amp;format=html">btxld(8)</a>和<a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a> 的区别是ld通常将两个目标文件 链接成一个动态链接库或可执行文件，而btxld 则将一个目标文件与BTX链接起来，产生适合于放在分区首部的二进制代码， 以实现系统引导。</p></div><div class=paragraph><p><code>boot0</code>执行跳转至BTX的入口点。 然后，BTX将处理器切换至保护模式，并准备一个简单的环境， 然后调用客户。这个环境包括：</p></div><div class=ulist><ul><li><p>虚拟8086模式。这意味着BTX是虚拟8086的监视程序。 实模式指令，如pushf, popf, cli, sti, if，均可被客户调用。</p></li><li><p>建立中断描述符表(Interrupt Descriptor Table, IDT)， 使得所有的硬件中断可被缺省的BIOS程序处理。 建立中断0x30，这是系统调用关口。</p></li><li><p>两个系统调用<code>exec</code>和 <code>exit</code>的定义如下:</p><div class="literalblock programlisting"><div class=content><pre>sys/boot/i386/btx/lib/btxsys.s:
		.set INT_SYS,0x30		# 中断号
#
# System call: exit
#
__exit: 	xorl %eax,%eax			# BTX系统调用0x0
		int $INT_SYS			#
#
# System call: exec
#
__exec: 	movl $0x1,%eax			# BTX系统调用0x1
		int $INT_SYS			#</pre></div></div></li></ul></div><div class=paragraph><p>BTX建立全局描述符表(Global Descriptor Table, GDT):</p></div><div class="literalblock programlisting"><div class=content><pre>sys/boot/i386/btx/btx/btx.s:
gdt:		.word 0x0,0x0,0x0,0x0		# 以空为入口
		.word 0xffff,0x0,0x9a00,0xcf	# SEL_SCODE
		.word 0xffff,0x0,0x9200,0xcf	# SEL_SDATA
		.word 0xffff,0x0,0x9a00,0x0	# SEL_RCODE
		.word 0xffff,0x0,0x9200,0x0	# SEL_RDATA
		.word 0xffff,MEM_USR,0xfa00,0xcf# SEL_UCODE
		.word 0xffff,MEM_USR,0xf200,0xcf# SEL_UDATA
		.word _TSSLM,MEM_TSS,0x8900,0x0 # SEL_TSS</pre></div></div><div class=paragraph><p>客户的代码和数据始于地址MEM_USR(0xa000)，选择符(selector) SEL_UCODE指向客户的数据段。选择符 SEL_UCODE 拥有第3级描述符权限 (Descriptor Privilege Level, DPL)，这是最低级权限。但是 <code>INT 0x30</code> 指令的处理程序存储于另一个段里， 这个段的选择符SEL_SCODE (supervisor code)由有着管理级权限。 正如代码建立IDT(中断描述符表)时进行的操作那样:</p></div><div class="literalblock programlisting"><div class=content><pre>		mov $SEL_SCODE,%dh		# 段选择符
init.2: 	shr %bx				# 是否处理这个中断？
		jnc init.3			# 否
		mov %ax,(%di)			# 设置处理程序偏移量
		mov %dh,0x2(%di)		# 设置处理程序选择符
		mov %dl,0x5(%di)		# 设置 P:DPL:type
		add $0x4,%ax			# 下一个中断处理程序</pre></div></div><div class=paragraph><p>所以，当客户调用 <code>__exec()</code>时，代码将被以最高权限执行。 这使得内核可以修改保护模式数据结构，如分页表(page tables)、全局描述符表(GDT)、 中断描述符表(IDT)等。</p></div><div class=paragraph><p><code>boot2</code> 定义了一个重要的数据结构： <code>struct bootinfo</code>。这个结构由 <code>boot2</code> 初始化，然后被转送到loader，之后又被转入内核。 这个结构的部分项目由<code>boot2</code>设定，其余的由loader设定。 这个结构中的信息包括内核文件名、BIOS提供的硬盘柱面/磁头/扇区数目信息、 BIOS提供的引导设备的驱动器编号，可用的物理内存大小，<code>envp</code> 指针(环境指针)等。定义如下：</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/machine/bootinfo.h
struct bootinfo {
	u_int32_t	bi_version;
	u_int32_t	bi_kernelname;		/* 用一个字节表示 * */
	u_int32_t	bi_nfs_diskless;	/* struct nfs_diskless * */
		/* 以上为常备项 */
#define	bi_endcommon	bi_n_bios_used
	u_int32_t	bi_n_bios_used;
	u_int32_t	bi_bios_geom[N_BIOS_GEOM];
	u_int32_t	bi_size;
	u_int8_t	bi_memsizes_valid;
	u_int8_t	bi_bios_dev;		/* 引导设备的BIOS单元编号 */
	u_int8_t	bi_pad[2];
	u_int32_t	bi_basemem;
	u_int32_t	bi_extmem;
	u_int32_t	bi_symtab;		/* struct symtab * */
	u_int32_t	bi_esymtab;		/* struct symtab * */
		/* 以下项目仅高级bootloader提供 */
	u_int32_t	bi_kernend;		/* 内核空间末端 */
	u_int32_t	bi_envp;		/* 环境 */
	u_int32_t	bi_modulep;		/* 预装载的模块 */
};</pre></div></div><div class=paragraph><p><code>boot2</code> 进入一个循环等待用户输入，然后调用 <code>load()</code>。如果用户不做任何输入，循环将在一段时间后结束， <code>load()</code> 将会装载缺省文件(<span class=filename>/boot/loader</span>)。 函数 <code>ino_t lookup(char *filename)</code>和 <code>int xfsread(ino_t inode, void *buf, size_t nbyte)</code> 用来将文件内容读入内存。<span class=filename>/boot/loader</span>是一个ELF格式二进制文件， 不过它的头部被换成了a.out格式中的<code>struct exec</code>结构。 <code>load()</code>扫描loader的ELF头部，装载<span class=filename>/boot/loader</span> 至内存，然后跳转至入口执行之：</p></div><div class="literalblock programlisting"><div class=content><pre>sys/boot/i386/boot2/boot2.c:
    __exec((caddr_t)addr, RB_BOOTINFO | (opts  RBX_MASK),
	   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),
	   0, 0, 0, VTOP(bootinfo));</pre></div></div></div></div><div class=sect1><h2 id=boot-loader>1.6. loader阶段<a class=anchor href=#boot-loader></a></h2><div class=sectionbody><div class=paragraph><p>loader也是一个 BTX 客户，在这里不作详述。 已有一部内容全面的手册 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> ，由Mike Smith书写。 比loader更底层的BTX的机理已经在前面讨论过。</p></div><div class=paragraph><p>loader 的主要任务是引导内核。当内核被装入内存后，即被loader调用:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/boot/common/boot.c:
    /* 从loader中调用内核中对应的exec程序 */
    module_formats[km-m_loader]-l_exec(km);</pre></div></div></div></div><div class=sect1><h2 id=boot-kernel>1.7. 内核初始化<a class=anchor href=#boot-kernel></a></h2><div class=sectionbody><div class=paragraph><p>让我们来看一下链接内核的命令。 这能帮助我们了解 loader 传递给内核的准确位置。 这个位置就是内核真实的入口点。</p></div><div class="literalblock programlisting"><div class=content><pre>sys/conf/Makefile.i386:
ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \
-dynamic-linker /red/herring -o kernel -X locore.o \
lots of kernel .o files</pre></div></div><div class=paragraph><p>在这一行中有一些有趣的东西。首先，内核是一个ELF动态链接二进制文件， 可是动态链接器却是<span class=filename>/red/herring</span>，一个莫须有的文件。 其次，看一下文件<span class=filename>sys/conf/ldscript.i386</span>， 可以对理解编译内核时ld的选项有一些启发。 阅读最前几行，字符串</p></div><div class="literalblock programlisting"><div class=content><pre>sys/conf/ldscript.i386:
ENTRY(btext)</pre></div></div><div class=paragraph><p>表示内核的入口点是符号 <code>btext</code>。这个符号在<span class=filename>locore.s</span> 中定义:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/locore.s:
	.text
/**********************************************************************
 *
 * This is where the bootblocks start us, set the ball rolling...
 * 入口
 */
NON_GPROF_ENTRY(btext)</pre></div></div><div class=paragraph><p>首先将寄存器EFLAGS设为一个预定义的值0x00000002， 然后初始化所有段寄存器:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/locore.s
/* 不要相信BIOS给出的EFLAGS值 */
	pushl	$PSL_KERNEL
	popfl

/*
 * 不要相信BIOS给出的%fs、%gs值。相信引导过程中设定的%cs、%ds、%es、%ss值
 */
	mov	%ds, %ax
	mov	%ax, %fs
	mov	%ax, %gs</pre></div></div><div class=paragraph><p>btext调用例程<code>recover_bootinfo()</code>, <code>identify_cpu()</code>,<code>create_pagetables()</code>。 这些例程也定在<span class=filename>locore.s</span>之中。这些例程的功能如下：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>recover_bootinfo</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>这个例程分析由引导程序传送给内核的参数。引导内核有3种方式: 由loader引导(如前所述), 由老式磁盘引导块引导,无盘引导方式。 这个函数决定引导方式，并将结构<code>struct bootinfo</code> 存储至内核内存。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>identify_cpu</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>这个函数侦测CPU类型，将结果存放在变量 <code>_cpu</code>中。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>create_pagetables</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>这个函数为分页表在内核内存空间顶部分配一块空间，并填写一定内容</p></td></tr></tbody></table><div class=paragraph><p>下一步是开启VME(如果CPU有这个功能):</p></div><div class="literalblock programlisting"><div class=content><pre>	testl	$CPUID_VME, R(_cpu_feature)
	jz	1f
	movl	%cr4, %eax
	orl	$CR4_VME, %eax
	movl	%eax, %cr4</pre></div></div><div class=paragraph><p>然后，启动分页模式:</p></div><div class="literalblock programlisting"><div class=content><pre>/* Now enable paging */
	movl	R(_IdlePTD), %eax
	movl	%eax,%cr3			/* load ptd addr into mmu */
	movl	%cr0,%eax			/* get control word */
	orl	$CR0_PE|CR0_PG,%eax		/* enable paging */
	movl	%eax,%cr0			/* and let&#39;s page NOW! */</pre></div></div><div class=paragraph><p>由于分页模式已经启动，原先的实地址寻址方式随即失效。 随后三行代码用来跳转至虚拟地址:</p></div><div class="literalblock programlisting"><div class=content><pre>	pushl	$begin				/* jump to high virtualized address */
	ret

/* 现在跳转至KERNBASE，那里是操作系统内核被链接后真正的入口 */
begin:</pre></div></div><div class=paragraph><p>函数<code>init386()</code>被调用；随参数传递的是一个指针， 指向第一个空闲物理页。随后执行<code>mi_startup()</code>。 <code>init386</code>是一个与硬件系统相关的初始化函数， <code>mi_startup()</code>是个与硬件系统无关的函数 (前缀’mi_'表示Machine Independent，不依赖于机器)。 内核不再从<code>mi_startup()</code>里返回； 调用这个函数后，内核完成引导:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/locore.s:
	movl	physfree, %esi
	pushl	%esi		/* 送给init386()的第一个参数 */
	call	_init386	/* 设置386芯片使之适应UNIX工作 */
	call	_mi_startup	/* 自动配置硬件，挂接根文件系统，等 */
	hlt		/* 不再返回到这里！ */</pre></div></div><div class=sect2><h3 id=_init386>1.7.1. <code>init386()</code><a class=anchor href=#_init386></a></h3><div class=paragraph><p><code>init386()</code>定义在 <span class=filename>sys/i386/i386/machdep.c</span>中， 它针对Intel 386芯片进行低级初始化。loader已将CPU切换至保护模式。 loader已经建立了最早的任务。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>译者注</div><div class=paragraph><p>每个"任务"都是与其它"<code>任务</code>"相对独立的执行环境。 任务之间可以分时切换，这为并发进程/线程的实现提供了必要基础。 对于Intel 80x86任务的描述，详见Intel公司关于80386 CPU及后续产品的资料， 或者在<a href=http://www.lib.tsinghua.edu.cn/>清华大学图书馆</a> 馆藏记录中用"80386"作为关键词所查找到的系统结构方面的书目。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在这个任务中，内核将继续工作。在讨论其代码前， 我将处理器对保护模式必须完成的一系列准备工作一并列出:</p></div><div class=ulist><ul><li><p>初始化内核的可调整参数，这些参数由引导程序传来</p></li><li><p>准备GDT(全局描述符表)</p></li><li><p>准备IDT(中断描述符表)</p></li><li><p>初始化系统控制台</p></li><li><p>初始化DDB(内核的点调试器)，如果它被编译进内核的话</p></li><li><p>初始化TSS(任务状态段)</p></li><li><p>准备LDT(局部描述符表)</p></li><li><p>建立proc0(0号进程，即内核的进程)的pcb(进程控制块)</p></li></ul></div><div class=paragraph><p><code>init386()</code>首先初始化内核的可调整参数， 这些参数由引导程序传来。先设置环境指针(environment pointer, envp)调用， 再调用<code>init_param1()</code>。 envp指针已由loader存放在结构<code>bootinfo</code>中:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
		kern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;

	/* 初始化基本可调整项,如hz等 */
	init_param1();</pre></div></div><div class=paragraph><p><code>init_param1()</code>定义在 <span class=filename>sys/kern/subr_param.c</span>之中。 这个文件里有一些sysctl项，还有两个函数， <code>init_param1()</code>和<code>init_param2()</code>。 这两个函数从<code>init386()</code>中调用:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/subr_param.c
	hz = HZ;
	TUNABLE_INT_FETCH(&#34;kern.hz&#34;, hz);</pre></div></div><div class=paragraph><p>TUNABLE_typename_FETCH用来获取环境变量的值:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src/sys/sys/kernel.h
#define	TUNABLE_INT_FETCH(path, var)	getenv_int((path), (var))</pre></div></div><div class=paragraph><p>Sysctl<code>kern.hz</code>是系统时钟频率。同时， 这些sysctl项被<code>init_param1()</code>设定: <code>kern.maxswzone, kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz, kern.dflssiz, kern.maxssiz, kern.sgrowsiz</code>。</p></div><div class=paragraph><p>然后<code>init386()</code> 准备全局描述符表 (Global Descriptors Table, GDT)。在x86上每个任务都运行在自己的虚拟地址空间里， 这个空间由"段址:偏移量"的数对指定。举个例子，当前将要由处理器执行的指令在 CS:EIP，那么这条指令的线性虚拟地址就是"代码段虚拟段地址CS" + EIP。 为了简便，段起始于虚拟地址0，终止于界限4G字节。所以，在这个例子中， 指令的线性虚拟地址正是EIP的值。段寄存器，如CS、DS等是选择符， 即全局描述符表中的索引(更精确的说，索引并非选择符的全部， 而是选择符中的INDEX部分)。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>译者注</div><div class=paragraph><p>对于80386， 选择符有16位，INDEX部分是其中的高13位。</p></div></td></tr></tbody></table></div><div class=paragraph><p>FreeBSD的全局描述符表为每个CPU保存着15个选择符:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
union descriptor gdt[NGDT * MAXCPU];	/* 全局描述符表 */

sys/i386/include/segments.h:
/*
 * 全局描述符表(GDT)中的入口
 */
#define	GNULL_SEL	0	/* 空描述符 */
#define	GCODE_SEL	1	/* 内核代码描述符 */
#define	GDATA_SEL	2	/* 内核数据描述符 */
#define	GPRIV_SEL	3	/* 对称多处理(SMP)每处理器专有数据 */
#define	GPROC0_SEL	4	/* Task state process slot zero and up, 任务状态进程 */
#define	GLDT_SEL	5	/* 每个进程的局部描述符表 */
#define	GUSERLDT_SEL	6	/* 用户自定义的局部描述符表 */
#define	GTGATE_SEL	7	/* 进程任务切换关口 */
#define	GBIOSLOWMEM_SEL	8	/* BIOS低端内存访问(必须是这第8个入口) */
#define	GPANIC_SEL	9	/* 会导致全系统异常中止工作的任务状态 */
#define GBIOSCODE32_SEL	10	/* BIOS接口(32位代码) */
#define GBIOSCODE16_SEL	11	/* BIOS接口(16位代码) */
#define GBIOSDATA_SEL	12	/* BIOS接口(数据) */
#define GBIOSUTIL_SEL	13	/* BIOS接口(工具) */
#define GBIOSARGS_SEL	14	/* BIOS接口(自变量，参数) */</pre></div></div><div class=paragraph><p>请注意，这些#defines并非选择符本身，而只是选择符中的INDEX域， 因此它们正是全局描述符表中的索引。 例如，内核代码的选择符(GCODE_SEL)的值为0x08。</p></div><div class=paragraph><p>下一步是初始化中断描述符表(Interrupt Descriptor Table, IDT)。 这张表在发生软件或硬件中断时会被处理器引用。例如，执行系统调用时， 用户应用程序提交<code>INT 0x80</code> 指令。这是一个软件中断， 处理器用索引值0x80在中断描述符表中查找记录。这个记录指向处理这个中断的例程。 在这个特定情形中，这是内核的系统调用关口。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>译者注</div><div class=paragraph><p>Intel 80386支持"<code>调用门</code>"，可以使得用户程序只通过一条call指令 就调用内核中的例程。可是FreeBSD并未采用这种机制， 也许是因为使用软中断接口可免去动态链接的麻烦吧。另外还有一个附带的好处： 在仿真Linux时，当遇到FreeBSD内核不支持的而又并非关键性的系统调用时， 内核只会显示一些出错信息，这使得程序能够继续运行； 而不是在真正执行程序之前的初始化过程中就因为动态链接失败而不允许程序运行。</p></div></td></tr></tbody></table></div><div class=paragraph><p>中断描述符表最多可以有256 (0x100)条记录。内核分配NIDT条记录的内存给中断描述符表， 这里NIDT=256，是最大值：</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
static struct gate_descriptor idt0[NIDT];
struct gate_descriptor *idt = idt0[0];	/* 中断描述符表 */</pre></div></div><div class=paragraph><p>每个中断都被设置一个合适的中断处理程序。 系统调用关口<code>INT 0x80</code>也是如此:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
 	setidt(0x80, IDTVEC(int0x80_syscall),
			SDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));</pre></div></div><div class=paragraph><p>所以当一个用户应用程序提交<code>INT 0x80</code>指令时， 全系统的控制权会传递给函数<code>_Xint0x80_syscall</code>， 这个函数在内核代码段中，将被以管理员权限执行。</p></div><div class=paragraph><p>然后，控制台和DDB(调试器)被初始化:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/i386/i386/machdep.c:
	cninit();
/* 以下代码可能因为未定义宏DDB而被跳过 */
#ifdef DDB
	kdb_init();
	if (boothowto  RB_KDB)
		Debugger(&#34;Boot flags requested debugger&#34;);
#endif</pre></div></div><div class=paragraph><p>任务状态段(TSS)是另一个x86保护模式中的数据结构。当发生任务切换时， 任务状态段用来让硬件存储任务现场信息。</p></div><div class=paragraph><p>局部描述符表(LDT)用来指向用户代码和数据。系统定义了几个选择符， 指向局部描述符表，它们是系统调用关口和用户代码、用户数据选择符:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/machine/segments.h
#define	LSYS5CALLS_SEL	0	/* Intel BCS强制要求的 */
#define	LSYS5SIGR_SEL	1
#define	L43BSDCALLS_SEL	2	/* 尚无 */
#define	LUCODE_SEL	3
#define	LSOL26CALLS_SEL	4	/* Solaris =2.6版系统调用关口 */
#define	LUDATA_SEL	5
/* separate stack, es,fs,gs sels ? 分别的栈、es、fs、gs选择符？ */
/* #define	LPOSIXCALLS_SEL	5*/	/* notyet, 尚无 */
#define LBSDICALLS_SEL	16	/* BSDI system call gate, BSDI系统调用关口 */
#define NLDT		(LBSDICALLS_SEL + 1)</pre></div></div><div class=paragraph><p>然后，proc0(0号进程，即内核所处的进程)的进程控制块(Process Control Block) (<code>struct pcb</code>)结构被初始化。proc0是一个 <code>struct proc</code> 结构，描述了一个内核进程。 内核运行时，该进程总是存在，所以这个结构在内核中被定义为全局变量:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/kern_init.c:
    struct	proc proc0;</pre></div></div><div class=paragraph><p>结构<code>struct pcb</code>是proc结构的一部分， 它定义在<span class=filename>/usr/include/machine/pcb.h</span>之中， 内含针对i386硬件结构专有的信息，如寄存器的值。</p></div></div><div class=sect2><h3 id=_mi_startup>1.7.2. <code>mi_startup()</code><a class=anchor href=#_mi_startup></a></h3><div class=paragraph><p>这个函数用冒泡排序算法，将所有系统初始化对象，然后逐个调用每个对象的入口:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
	for (sipp = sysinit; *sipp; sipp++) {

		/* ... 省略 ... */

		/* 调用函数 */
		(*((*sipp)-func))((*sipp)-udata);
		/* ... 省略 ... */
	}</pre></div></div><div class=paragraph><p>尽管sysinit框架已经在《FreeBSD开发者手册》中有所描述， 我还是在这里讨论一下其内部原理。</p></div><div class=paragraph><p>每个系统初始化对象(sysinit对象)通过调用宏建立。 让我们以<code>announce</code> sysinit对象为例。 这个对象打印版权信息:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
static void
print_caddr_t(void *data __unused)
{
	printf(&#34;%s&#34;, (char *)data);
}
SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright)</pre></div></div><div class=paragraph><p>这个对象的子系统标识是SI_SUB_COPYRIGHT(0x0800001)， 数值刚好排在SI_SUB_CONSOLE(0x0800000)后面。 所以，版权信息将在控制台初始化之后就被很早的打印出来。</p></div><div class=paragraph><p>让我们看一看宏<code>SYSINIT()</code>到底做了些什么。 它展开成宏<code>C_SYSINIT()</code>。 宏<code>C_SYSINIT()</code>然后展开成一个静态结构 <code>struct sysinit</code>。结构里申明里调用了另一个宏 <code>DATA_SET</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/kernel.h:
      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \
      static struct sysinit uniquifier ## _sys_init = { \ subsystem, \
      order, \ func, \ ident \ }; \ DATA_SET(sysinit_set,uniquifier ##
      _sys_init);

#define	SYSINIT(uniquifier, subsystem, order, func, ident)	\
	C_SYSINIT(uniquifier, subsystem, order,			\
	(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)</pre></div></div><div class=paragraph><p>宏<code>DATA_SET()</code>展开成<code>MAKE_SET()</code>， 宏<code>MAKE_SET()</code>指向所有隐含的sysinit幻数:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/linker_set.h
#define MAKE_SET(set, sym)						\
	static void const * const __set_##set##_sym_##sym = sym;	\
	__asm(&#34;.section .set.&#34; #set &#34;,\&#34;aw\&#34;&#34;);				\
	__asm(&#34;.long &#34; #sym);						\
	__asm(&#34;.previous&#34;)
#endif
#define TEXT_SET(set, sym) MAKE_SET(set, sym)
#define DATA_SET(set, sym) MAKE_SET(set, sym)</pre></div></div><div class=paragraph><p>回到我们的例子中，经过宏的展开过程，将会产生如下声明:</p></div><div class="literalblock programlisting"><div class=content><pre>static struct sysinit announce_sys_init = {
	SI_SUB_COPYRIGHT,
	SI_ORDER_FIRST,
	(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,
	(void *) copyright
};

static void const *const __set_sysinit_set_sym_announce_sys_init =
    announce_sys_init;
__asm(&#34;.section .set.sysinit_set&#34; &#34;,\&#34;aw\&#34;&#34;);
__asm(&#34;.long &#34; &#34;announce_sys_init&#34;);
__asm(&#34;.previous&#34;);</pre></div></div><div class=paragraph><p>第一个<code>__asm</code>指令在内核可执行文件中建立一个ELF节(section)。 这发生在内核链接的时候。这一节将被命令为<code>.set.sysinit_set</code>。 这一节的内容是一个32位值――announce_sys_init结构的地址，这个结构正是第二个 <code>\__asm</code>指令所定义的。第三个<code>\__asm</code>指令标记节的结束。 如果前面有名字相同的节定义语句，节的内容(那个32位值)将被填加到已存在的节里， 这样就构造出了一个32位指针数组。</p></div><div class=paragraph><p>用objdump察看一个内核二进制文件， 也许你会注意到里面有这么几个小的节:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% objdump <span class=nt>-h</span> /kernel
  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2<span class=k>**</span>2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2<span class=k>**</span>2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2<span class=k>**</span>2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2<span class=k>**</span>2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2<span class=k>**</span>2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2<span class=k>**</span>2
                  CONTENTS, ALLOC, LOAD, DATA</code></pre></div></div><div class=paragraph><p>这一屏信息显示表明节.set.sysinit_set有0x664字节的大小， 所以<code>0x664/sizeof(void *)</code>个sysinit对象被编译进了内核。 其它节，如<code>.set.sysctl_set</code>表示其它链接器集合。</p></div><div class=paragraph><p>通过定义一个类型为<code>struct linker_set</code>的变量， 节<code>.set.sysinit_set</code>将被"收集"到那个变量里:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
      extern struct linker_set sysinit_set; /* XXX */</pre></div></div><div class=paragraph><p><code>struct linker_set</code>定义如下:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/linker_set.h:
  struct linker_set {
	int	ls_length;
	void	*ls_items[1];		/* ls_length个项的数组, 以NULL结尾 */
};</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>译者注</div><div class=paragraph><p>实际上是说， 用C语言结构体linker_set来表达那个ELF节。</p></div></td></tr></tbody></table></div><div class=paragraph><p>第一项是sysinit对象的数量，第二项是一个以NULL结尾的数组， 数组中是指向那些对象的指针。</p></div><div class=paragraph><p>回到对<code>mi_startup()</code>的讨论， 我们清楚了sysinit对象是如何被组织起来的。 函数<code>mi_startup()</code>将它们排序， 并调用每一个对象。最后一个对象是系统调度器:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/include/sys/kernel.h:
enum sysinit_sub_id {
	SI_SUB_DUMMY		= 0x0000000,	/* 不被执行，仅供链接器使用 */
	SI_SUB_DONE		= 0x0000001,	/* 已被处理*/
	SI_SUB_CONSOLE		= 0x0800000,	/* 控制台*/
	SI_SUB_COPYRIGHT	= 0x0800001,	/* 最早使用控制台的对象 */
...
	SI_SUB_RUN_SCHEDULER	= 0xfffffff	/* 调度器:不返回 */
};</pre></div></div><div class=paragraph><p>系统调度器sysinit对象定义在文件<span class=filename>sys/vm/vm_glue.c</span>中， 这个对象的入口点是<code>scheduler()</code>。 这个函数实际上是个无限循环，它表示那个进程标识(PID)为0的进程――swapper进程。 前面提到的proc0结构正是用来描述这个进程。</p></div><div class=paragraph><p>第一个用户进程是_init_， 由sysinit对象<code>init</code>建立:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
static void
create_init(const void *udata __unused)
{
	int error;
	int s;

	s = splhigh();
	error = fork1(proc0, RFFDG | RFPROC, initproc);
	if (error)
		panic(&#34;cannot fork init: %d\n&#34;, error);
	initproc-p_flag |= P_INMEM | P_SYSTEM;
	cpu_set_fork_handler(initproc, start_init, NULL);
	remrunqueue(initproc);
	splx(s);
}
SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)</pre></div></div><div class=paragraph><p><code>create_init()</code>通过调用<code>fork1()</code> 分配一个新的进程，但并不将其标记为可运行。当这个新进程被调度器调度执行时， <code>start_init()</code>将会被调用。 那个函数定义在<span class=filename>init_main.c</span>中。 它尝试装载并执行二进制代码<span class=filename>init</span>， 先尝试<span class=filename>/sbin/init</span>，然后是<span class=filename>/sbin/oinit</span>， <span class=filename>/sbin/init.bak</span>，最后是<span class=filename>/stand/sysinstall</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sys/kern/init_main.c:
static char init_path[MAXPATHLEN] =
#ifdef	INIT_PATH
    __XSTRING(INIT_PATH);
#else
    &#34;/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall&#34;;
#endif</pre></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: March 9, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/parti class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/zh-cn/books/arch-handbook/locking class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#boot-synopsis>1.1. 概述</a></li><li><a href=#boot-overview>1.2. 总览</a></li><li><a href=#boot-bios>1.3. BIOS POST</a></li><li><a href=#boot-boot0>1.4. <code>boot0</code>阶段</a></li><li><a href=#boot-boot2>1.5. <code>boot2</code>阶段</a></li><li><a href=#boot-loader>1.6. loader阶段</a></li><li><a href=#boot-kernel>1.7. 内核初始化</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/zh-cn/books/arch-handbook/arch-handbook_zh-cn.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-cn/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/zh-cn/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>简体中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-cn class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/zh-cn/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>