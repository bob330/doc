<!doctype html><html class=theme-light lang=fr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/fr/books/handbook/config/><title>Chapitre 11. Configuration et optimisation | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapitre 11. Configuration et optimisation"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="fr"><meta property="og:url" content="https://docs.freebsd.org/fr/books/handbook/config/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/fr\/books\/handbook\/config\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/fr>Documentation portal</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/fr/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/fr/books>Books</a></li><li><a href=https://docs.freebsd.org/fr/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/fr/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=fr>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/preface/>Préface</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-audience>Public visé</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-changes-from2>Modifications depuis la Seconde Edition</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-changes>Modifications depuis la Première Edition</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-overview>Organisation de cet ouvrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-conv>Conventions utilisées dans ce livre</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-acknowledgements>Remerciements</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/parti/>Partie I. Pour commencer</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/introduction/>Chapitre 1. Introduction</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/introduction/#introduction-synopsis>1.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/introduction/#nutshell>1.2. Bienvenue à FreeBSD!</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/introduction/#history>1.3. A propos du Projet FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/>Chapitre 2. Installer FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Configuration matérielle minimale</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Tâches de pré-installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-start>2.4. Lancer l’installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#using-bsdinstall>2.5. Utilisation de bsdinstall</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Allouer l’espace disque</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Récupération des fichiers de distribution</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-post>2.8. Comptes utilisateurs, fuseau horaire, services et renforcement de la sécurité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-network>2.9. Interfaces réseau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Dépannage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#using-live-cd>2.11. Utilisation du CD Live</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/basics/>Chapitre 3. Quelques bases d'UNIX</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-synopsis>3.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#consoles>3.2. Consoles virtuelles terminaux</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#permissions>3.3. Permissions</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#dirstructure>3.4. Organisation de l’arborescence des répertoires</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#disk-organization>3.5. Organisation des disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#mount-unmount>3.6. Monter et démonter des systèmes de fichiers</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-processes>3.7. Processus</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-daemons>3.8. Daemons, signaux, et comment tuer un processus</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#shells>3.9. Interpréteurs de commandes - "Shells"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#editors>3.10. Editeurs de texte</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-devices>3.11. Périphériques et fichiers spéciaux de périphérique</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#binary-formats>3.12. Le format des fichiers binaires</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-more-information>3.13. Pour plus d’information</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/ports/>Chapitre 4. Installer des applications: les logiciels pré-compilés et les logiciels portés</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-synopsis>4.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-overview>4.2. Généralités sur l’installation de logiciels</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-finding-applications>4.3. Trouver votre application</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#packages-using>4.4. Utiliser le système des logiciels pré-compilés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-using>4.5. Utiliser le catalogue des logiciels portés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-nextsteps>4.6. Activités de post-installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-broken>4.7. Que faire avec les logiciels portés ne fonctionnant pas?</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/x11/>Chapitre 5. Le système X Window</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x11-synopsis>5.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-understanding>5.2. Terminologie</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-install>5.3. Installer X11</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-config>5.4. Configuration d’Xorg</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-fonts>5.5. Utilisation des polices de caractères sous Xorg</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-xdm>5.6. Le gestionnaire de connexion graphique XDM</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x11-wm>5.7. Environnements de bureau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-compiz-fusion>5.8. Installation de Compiz Fusion</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partii/>Partie II. Tâches courantes</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/desktop/>Chapitre 6. Bureautique</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-synopsis>6.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-browsers>6.2. Navigateurs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-productivity>6.3. Productivité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-viewers>6.4. Lecteurs de document</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-finance>6.5. Finance</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-summary>6.6. Résumé</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/>Chapitre 7. Multimédia</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#multimedia-synopsis>7.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#sound-setup>7.2. Configurer une carte son</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#sound-mp3>7.3. Fichiers MP3</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#video-playback>7.4. Lecture des Vidéos</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#tvcard>7.5. Configuration des cartes TV</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#scanners>7.6. Scanners</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/>Chapitre 8. Configurer le noyau de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Pourquoi compiler un noyau sur mesure?</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-building>8.3. Compiler et installer un noyau sur mesure</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-config>8.4. Le fichier de configuration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-trouble>8.5. Si quelque chose se passe mal</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/printing/>Chapitre 9. Imprimer</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-synopsis>9.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-intro-spooler>9.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-intro-setup>9.3. Configuration de base</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-advanced>9.4. Configuration avancée de l’imprimante</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-using>9.5. Using Printers <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-lpd-alternatives>9.6. Alternatives to the Standard Spooler <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-troubleshooting>9.7. Troubleshooting <strong>Traduction en Cours</strong></a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/>Chapitre 10. Compatibilité binaire avec Linux</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Configurer la compatibilité binaire avec Linux</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-packages>10.3. Système de base CentOS à partir des paquets binaires FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-debootstrap>10.4. Système de base Debian / Ubuntu avec debootstrap(8)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-advanced>10.5. Sujets avancés</a></li></ul></li><li><input type=checkbox id=chapter-54c06b703788dcba4081bec5a0407412 class=toggle>
<label class="icon cursor" for=chapter-54c06b703788dcba4081bec5a0407412><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/wine/>Chapitre 11. WINE</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-synopsis>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-overview-concepts>11.2. WINE généralités et concepts</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#installing-wine-on-freebsd>11.3. Installer WINE sur FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#running-first-wine-program>11.4. Lancer un premier programme WINE sous FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#configuring-wine-installation>11.5. Configurer WINE après installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-management-guis>11.6. Interfaces graphiques de gestion de WINE</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-in-multi-user-os-installations>11.7. WINE sur un système FreeBSD avec plusieurs utilisateurs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-on-os-faq>11.8. WINE sur FreeBSD Foire Aux Questions</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partiii/>Partie III. Administration Système</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle checked>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/config/>Chapitre 11. Configuration et optimisation</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#config-synopsis>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-core-configuration>11.2. Configuration principale</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-appconfig>11.3. Configuration des applications</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-starting-services>11.4. Démarrer des services</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-cron>11.5. Configuration de l’utilitaire <code>cron</code></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-rcd>11.6. Utilisation du système rc(8) sous FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#config-network-setup>11.7. Configuration des cartes réseaux</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-virtual-hosts>11.8. Hôtes virtuels</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-configfiles>11.9. Fichiers de configuration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-sysctl>11.10. Optimisation avec sysctl(8)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-disk>11.11. Optimiser les disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-kernel-limits>11.12. Optimisation des limitations du noyau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#adding-swap-space>11.13. Ajouter de l’espace de pagination</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#acpi-overview>11.14. Gestion de l’énergie et des ressources</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#ACPI-debug>11.15. Utiliser et déboguer l’ACPI sous FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/boot/>Chapitre 12. Processus de démarrage de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-synopsis>12.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-introduction>12.2. Le problème du démarrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-blocks>12.3. Le gestionnaire de démarrage et les étapes de démarrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-kernel>12.4. Interaction avec le noyau au démarrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#device-hints>12.5. "Device Hints"-Paramétrage des périphériques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-init>12.6. Init: Initialisation de la gestion des processus</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-shutdown>12.7. Séquence d’arrêt du système</a></li></ul></li><li><input type=checkbox id=chapter-d251c21b963b5ab783e5aec225e02b5a class=toggle>
<label class="icon cursor" for=chapter-d251c21b963b5ab783e5aec225e02b5a><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/users/>Chapitre 13. Gestion des comptes et des utilisateurs</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-synopsis>13.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-introduction>13.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-superuser>13.3. Le compte super-utilisateur</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-system>13.4. Comptes système</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-user>13.5. Comptes utilisateur</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-modifying>13.6. Modifier des comptes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-limiting>13.7. Mettre en place des restrictions pour les utilisateurs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-groups>13.8. Groupes</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/security/>Chapitre 14. Sécurité</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-synopsis>14.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-intro>14.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#securing-freebsd>14.3. Securing FreeBSD <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#crypt>14.4. DES, MD5, et chiffrement</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#one-time-passwords>14.5. Mots de passe non réutilisables</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#tcpwrappers>14.6. L’encapsuleur TCP ("TCP Wrappers")</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#kerberosIV>14.7. Kerberos</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#kerberos5>14.8. Kerberos5 <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#openssl>14.9. OpenSSL</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#ipsec>14.10. IPsec</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#openssh>14.11. OpenSSH</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#fs-acl>14.12. Listes de contrôle d’accès au système de fichiers</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-portaudit>14.13. Surveillance des problèmes de sécurité relatifs aux programmes tierce-partie</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-advisories>14.14. Avis de sécurité de FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-accounting>14.15. Comptabilité des processus</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/jails/>Chapitre 15. Environnements jail</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-synopsis>15.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-terms>15.2. Termes relatifs aux environnements jail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-intro>15.3. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-build>15.4. Création et contrôle de l’environnement jail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-tuning>15.5. Optimisation et administration</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/mac/>Chapitre 16. Mandatory Access Control ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-synopsis>16.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-glossary>16.2. Key Terms in this Chapter</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-initial>16.3. Explanation of MAC</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-understandlabel>16.4. Understanding MAC Labels</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-modules>16.5. Module Configuration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-bsdextended>16.6. The MAC bsdextended Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-ifoff>16.7. The MAC ifoff Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-portacl>16.8. The MAC portacl Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-labelingpolicies>16.9. MAC Policies with Labeling Features</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-partition>16.10. The MAC partition Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-mls>16.11. The MAC Multi-Level Security Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-biba>16.12. The MAC Biba Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-lomac>16.13. The MAC LOMAC Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-implementing>16.14. Implementing a Secure Environment with MAC</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#MAC-examplehttpd>16.15. Another Example: Using MAC to Constrain a Web Server</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-troubleshoot>16.16. Troubleshooting the MAC Framework</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/audit/>Chapitre 17. Audit des événements relatifs à la sécurité du système</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-synopsis>17.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-inline-glossary>17.2. Mots-clés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-config>17.3. Configuration de l’audit</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-administration>17.4. Travailler avec les traces d’audit</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/disks/>Chapitre 18. Stockage des données</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-synopsis>18.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-naming>18.2. Noms des périphériques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-adding>18.3. Ajouter des disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#raid>18.4. RAID</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#usb-disks>18.5. Périphériques de stockage USB</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#creating-cds>18.6. Création et utilisation de supports optiques (CDs)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#creating-dvds>18.7. Création et utilisation de supports optiques (DVDs)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#floppies>18.8. Création et utilisation de disquettes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backups-tapebackups>18.9. Créer et utiliser les bandes magnétiques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backups-floppybackups>18.10. Sauvegardes sur disquettes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backup-strategies>18.11. Stratégies de sauvegarde</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backup-basics>18.12. Sauvegardes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-virtual>18.13. Systèmes de fichiers réseaux, en mémoire et sauvegardés sur fichier</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#snapshots>18.14. Instantané ("Snapshot") d’un système de fichiers</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#quotas>18.15. Quotas d’utilisation des disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-encrypting>18.16. Chiffrer les partitions d’un disque</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#swap-encrypting>18.17. Chiffrage de l’espace de pagination</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/geom/>Chapitre 19. GEOM: architecture modulaire de gestion des disques</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-synopsis>19.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-intro>19.2. Introduction à GEOM</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-striping>19.3. RAID0 - "Striping"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-mirror>19.4. RAID1 - "mirroring"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#geom-ggate>19.5. Périphériques réseau "GEOM Gate"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#geom-glabel>19.6. Ajouter un label à un disque</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/zfs/>Chapitre 20. The Z File System (ZFS) ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-differences>20.1. What Makes ZFS Different</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-quickstart>20.2. Quick Start Guide</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-zpool>20.3. <code>zpool</code> Administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-zfs>20.4. <code>zfs</code> Administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-zfs-allow>20.5. Delegated Administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-links>20.6. Additional Resources</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-term>20.7. ZFS Features and Terminology</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/filesystems/>Chapitre 21. Autres systèmes de fichiers</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/filesystems/#filesystems-synopsis>21.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/filesystems/#filesystems-linux>21.2. Systèmes de fichiers Linux®</a></li></ul></li><li><input type=checkbox id=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e class=toggle>
<label class="icon cursor" for=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/vinum/>Chapitre 22. Le gestionnaire de volume Vinum</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-synopsis>22.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-intro>22.2. Les disques sont trop petits</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#_les_goulots_détranglement_daccès_aux_données>22.3. Les goulots d’étranglement d’accès aux données</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#_intégrité_des_données>22.4. Intégrité des données</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-objects>22.5. Objets Vinum</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-examples>22.6. Quelques exemples</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#_appellation_des_objets>22.7. Appellation des objets</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-config>22.8. Configuration de Vinum</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/>Chapitre 23. Virtualisation</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/#virtualization-synopsis>23.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/#virtualization-guest>23.2. FreeBSD comme système d’exploitation invité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/#virtualization-host>23.3. FreeBSD comme système d’exploitation hôte</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/l10n/>Chapitre 24. Localisation - Utilisation et configuration de l'I18N/L10N</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#l10n-synopsis>24.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#l10n-basics>24.2. Les bases</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#using-localization>24.3. Utiliser la localisation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#l10n-compiling>24.4. Compiler des programmes I18N</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#lang-setup>24.5. Localiser FreeBSD pour des langues spécifiques</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/>Chapitre 25. Mise à jour de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-synopsis>25.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>25.2. Mise à jour de FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-portsnap>25.3. Portsnap: un outil de mise à jour du catalogue des logiciels portés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-documentation>25.4. Updating the Documentation Set <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#current-stable>25.5. Suivre une branche de développement</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#synching>25.6. Synchroniser vos sources</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#makeworld>25.7. Recompiler le système</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#small-lan>25.8. Suivre les mises à jour pour plusieurs machines</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/>Chapitre 26. DTrace</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-synopsis>26.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-implementation>26.2. Des différences de mise en oeuvre</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-enable>26.3. Activer la prise en charge de DTrace</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-using>26.4. Utiliser DTrace</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-language>26.5. Le langage D</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partiv/>Partie IV. Réseau</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/>Chapitre 27. Serial Communications ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#serial-synopsis>27.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#serial>27.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#term>27.3. Terminals</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#dialup>27.4. Dial-in Service</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#dialout>27.5. Dial-out Service</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#serialconsole-setup>27.6. Setting Up the Serial Console</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/>Chapitre 28. PPP et SLIP</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>28.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#userppp>28.2. Using User PPP <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#ppp>28.3. Utiliser PPP intégré au noyau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#pppoe>28.4. Utiliser PPP sur Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#pppoa>28.5. Utiliser PPP sur ATM (PPPoA)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#slip>28.6. Utiliser SLIP</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/mail/>Chapitre 29. Courrier électronique</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-synopsis>29.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-using>29.2. Utilisation du courrier électronique</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#sendmail>29.3. Configuration de sendmail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-changingmta>29.4. Changer votre agent de transfert de courrier</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-trouble>29.5. Dépannage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-advanced>29.6. Sujets avancés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#SMTP-UUCP>29.7. SMTP avec UUCP</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#outgoing-only>29.8. Configuration pour l’envoi seul</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#SMTP-dialup>29.9. Utiliser le courrier électronique avec une connexion temporaire</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#SMTP-Auth>29.10. Authentification SMTP</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-agents>29.11. Clients de messagerie</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-fetchmail>29.12. Utiliser fetchmail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-procmail>29.13. Utiliser procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/>Chapitre 30. Serveurs réseau</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-servers-synopsis>30.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-inetd>30.2. Le "super-serveur" inetd</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-nfs>30.3. Système de fichiers réseau (NFS)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-nis>30.4. Services d’information réseau (NIS/YP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-dhcp>30.5. Configuration réseau automatique (DHCP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-dns>30.6. Serveurs de noms (DNS)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-apache>30.7. Serveur HTTP Apache</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-ftp>30.8. Protocole de transfert de fichiers (FTP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-samba>30.9. Serveur de fichiers et d’impression pour clients Microsoft® Windows® (Samba)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-ntp>30.10. Synchronisation de l’horloge avec NTP</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/>Chapitre 31. Firewalls ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-intro>31.1. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-concepts>31.2. Firewall Concepts</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-apps>31.3. Firewall Packages</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-pf>31.4. The OpenBSD Packet Filter (PF) and ALTQ</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-ipf>31.5. The IPFILTER (IPF) Firewall</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-ipfw>31.6. IPFW</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/>Chapitre 32. Administration réseau avancée</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#advanced-networking-synopsis>32.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-routing>32.2. Passerelles et routes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-wireless>32.3. Réseau sans fil</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-bluetooth>32.4. Bluetooth</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-bridging>32.5. Bridging</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-diskless>32.6. Système sans disque dur</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-isdn>32.7. ISDN</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-natd>32.8. Translation d’adresses</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-plip>32.9. IP sur liaison parallèle (PLIP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-ipv6>32.10. IPv6</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-atm>32.11. ATM ("Asynchronous Transfer Mode")</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partv/>Partie V. Annexes</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/>Annexe A. Se procurer FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-cdrom>A.1. Editeurs de CD-ROMs et DVDs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-ftp>A.2. Sites FTP</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#anoncvs>A.3. CVS anonyme</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#ctm>A.4. Utiliser CTM</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#cvsup>A.5. Utiliser CVSup</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#portsnap>A.6. Utiliser Portsnap</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#cvs-tags>A.7. Etiquettes CVS</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-afs>A.8. Sites AFS</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-rsync>A.9. Sites rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/>Annexe B. Bibliographie</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-freebsd>B.1. Livres magazines consacrés à FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-userguides>B.2. Manuels d’utilisation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-adminguides>B.3. Manuels d’administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-programmers>B.4. Manuels de programmation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-osinternals>B.5. "Internes" du système d’exploitation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-security>B.6. Ouvrages de référence en matière de sécurité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-hardware>B.7. Ouvrages de référence sur le matériel</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-history>B.8. Histoire d’UNIX®</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-journals>B.9. Revues et journaux</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/eresources/>Annexe C. Ressources sur Internet</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-mail>C.1. Listes de diffusion</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-news>C.2. Forums de discussion</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-web>C.3. Serveurs World Wide Web</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-email>C.4. Adresses électroniques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-shell>C.5. Comptes</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/pgpkeys/>Annexe D. Clés OpenPGP</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapitre 11. Configuration et optimisation</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Synopsis</a></li><li><a href=#configtuning-core-configuration>11.2. Configuration principale</a></li><li><a href=#configtuning-appconfig>11.3. Configuration des applications</a></li><li><a href=#configtuning-starting-services>11.4. Démarrer des services</a></li><li><a href=#configtuning-cron>11.5. Configuration de l’utilitaire <code>cron</code></a></li><li><a href=#configtuning-rcd>11.6. Utilisation du système rc(8) sous FreeBSD</a></li><li><a href=#config-network-setup>11.7. Configuration des cartes réseaux</a></li><li><a href=#configtuning-virtual-hosts>11.8. Hôtes virtuels</a></li><li><a href=#configtuning-configfiles>11.9. Fichiers de configuration</a></li><li><a href=#configtuning-sysctl>11.10. Optimisation avec sysctl(8)</a></li><li><a href=#configtuning-disk>11.11. Optimiser les disques</a></li><li><a href=#configtuning-kernel-limits>11.12. Optimisation des limitations du noyau</a></li><li><a href=#adding-swap-space>11.13. Ajouter de l’espace de pagination</a></li><li><a href=#acpi-overview>11.14. Gestion de l’énergie et des ressources</a></li><li><a href=#ACPI-debug>11.15. Utiliser et déboguer l’ACPI sous FreeBSD</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=config-synopsis>11.1. Synopsis<a class=anchor href=#config-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>La configuration correcte d’un système peut sensiblement réduire la quantité de travail impliquée dans la maintenance et la mise à jour. Ce chapitre décrit certains des aspects de la configuration des systèmes FreeBSD.</p></div><div class=paragraph><p>Ce chapitre décrira également certains paramètres qui peuvent être modifiés pour configurer un système FreeBSD pour des performances optimales.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Les bases de la configuration du fichier <span class=filename>rc.conf</span> et des fichiers de démarrage <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Comment configurer et tester une carte réseau.</p></li><li><p>Comment configurer des hôtes virtuels sur vos périphériques réseau.</p></li><li><p>Comment utiliser les divers fichiers de configuration du répertoire <span class=filename>/etc</span>.</p></li><li><p>Comment optimiser FreeBSD en utilisant les variables <code>sysctl</code>.</p></li><li><p>Comment optimiser les performances des disques et modifier les limitations du noyau.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les fondements d’UNIX® et de FreeBSD (<a href=../basics/#basics>Quelques bases d’UNIX</a>).</p></li><li><p>Etre familier avec la configuration et la compilation du noyau (<a href=../kernelconfig/#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=configtuning-core-configuration>11.2. Configuration principale<a class=anchor href=#configtuning-core-configuration></a></h2><div class=sectionbody><div class=paragraph><p>L’emplacement principal pour les données de configuration du système est le fichier <span class=filename>/etc/rc.conf</span>. Ce fichier contient une large gamme d’informations de configuration, principalement utilisées au démarrage du système pour configurer ce dernier. Son nom le sous-entend; c’est l’information de configuration pour les fichiers <span class=filename>rc*</span>.</p></div><div class=paragraph><p>Un administrateur devrait ajouter des entrées dans le fichier <span class=filename>rc.conf</span> pour remplacer les valeurs par défaut du fichier <span class=filename>/etc/defaults/rc.conf</span>. Les fichiers de valeurs par défaut ne devraient pas être copiés directement tels quels dans <span class=filename>/etc</span> - ils contiennent des valeurs par défaut, et non pas des exemples. Tout changement spécifique au système devrait être fait dans le fichier <span class=filename>rc.conf</span>.</p></div><div class=paragraph><p>Un certain nombre de stratégies peuvent être appliquées dans le cas d’applications en grappe pour séparer la configuration d’un site de celle d’un système afin de réduire le travail d’administration. L’approche recommandée est de placer la configuration propre au site dans le fichier <span class=filename>/etc/rc.conf.local</span>. Par exemple:</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div></li><li><p><span class=filename>/etc/rc.conf.local</span>:</p><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div></li></ul></div><div class=paragraph><p>Le fichier <span class=filename>rc.conf</span> peut être distribué à l’ensemble des systèmes en utilisant <code>rsync</code> ou un programme semblable, tandis que le fichier <span class=filename>rc.conf.local</span> reste unique.</p></div><div class=paragraph><p>Mettre à jour le système en employant <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> ou <code>make world</code> n’écrasera pas le fichier <span class=filename>rc.conf</span>, les informations de configuration du système ne seront donc pas perdues.</p></div><div class=paragraph><p>Le fichier de configuration <span class=filename>/etc/rc.conf</span> est analysé par <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Cela permet aux administrateurs système d’ajouter un certain niveau de logique à ce fichier, ce qui peut aider à créer des scénaris de configuration complexes. Veuillez consulter <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> pour plus d’information sur ce sujet.</p></div></div></div><div class=sect1><h2 id=configtuning-appconfig>11.3. Configuration des applications<a class=anchor href=#configtuning-appconfig></a></h2><div class=sectionbody><div class=paragraph><p>Généralement, les applications installées ont leurs propres fichiers de configuration, avec leur propre syntaxe, etc…​ Il est important que ces fichiers soient séparés du système de base, de sorte qu’ils soient facilement localisables et gérables par les outils de gestion des logiciels installés.</p></div><div class=paragraph><p>Ces fichiers sont généralement installés dans le répertoire <span class=filename>/usr/local/etc</span>. Dans le cas où une application possède un grand nombre de fichiers de configuration, un sous-répertoire sera créé pour les héberger.</p></div><div class=paragraph><p>Normalement, quand un logiciel porté ou pré-compilé est installé, des exemples de fichiers de configuration sont également installés. Ces derniers sont généralement identifiés par un suffixe ".default". Si aucun fichier de configuration n’existe pour l’application, on les créera en copiant les fichiers <span class=filename>.default</span>.</p></div><div class=paragraph><p>Par exemple, considérez le contenu du répertoire <span class=filename>/usr/local/etc/apache</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</pre></div></div><div class=paragraph><p>Les tailles des fichiers indiquent que seul le fichier <span class=filename>srm.conf</span> a été modifié. Une mise à jour, plus tard, du logiciel Apache ne devrait pas écraser le fichier modifié.</p></div></div></div><div class=sect1><h2 id=configtuning-starting-services>11.4. Démarrer des services<a class=anchor href=#configtuning-starting-services></a></h2><div class=sectionbody><div class=paragraph><p>Nombreux sont les utilisateurs qui choisissent d’installer des logiciels tierce partie sous FreeBSD à partir du catalogue des logiciels portés. Dans de nombreuses situations, il peut être nécessaire de configurer le logiciel de manière à ce qu’il soit lancé au démarrage du système. Des services comme <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> sont deux exemples de logiciels parmi tant d’autres qui peuvent être lancés à l’initialisation du système. Cette section explique les procédures disponibles pour démarrer certains logiciels tierce partie.</p></div><div class=paragraph><p>Sous FreeBSD, la plupart des services offerts, comme <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, sont lancés par l’intermédiaire des procédures de démarrage du système. Ces procédures peuvent varier en fonction de la version de FreeBSD, ou du fournisseur; cependant, l’aspect le plus important à considérer est que leur configuration de démarrage peut être gérée à l’aide de procédures de démarrage simples.</p></div><div class=sect2><h3 id=_configuration_étendue_des_applications>11.4.1. Configuration étendue des applications<a class=anchor href=#_configuration_étendue_des_applications></a></h3><div class=paragraph><p>Maintenant que FreeBSD dispose du système <span class=filename>rc.d</span>, la configuration du démarrage des applications est plus simple, et propose plus de possibilités. En utilisant les mots clés présentés dans la section sur le système <a href=#configtuning-rcd>rc.d</a>, les applications peuvent désormais être paramétrées pour démarrer après certains services, par exemple le DNS, des paramètres supplémentaires peuvent être passés par l’intermédiaire de <span class=filename>rc.conf</span> au lieu d’utiliser des paramètres fixes dans les procédures de démarrage, etc. Une procédure de base pourra ressembler à ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Cette procédure s’assurera que l’application utility sera lancée après le le service <code>DAEMON</code>. Elle fournie également une méthode de suivi du PID, ou encore ID (identifiant) de processus.</p></div><div class=paragraph><p>Cette application pourra alors avoir la ligne suivante la concernant dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Cette méthode permet également une manipulation plus aisée des arguments en ligne de commande, l’inclusion des fonctions offertes par défaut dans <span class=filename>/etc/rc.subr</span>, offre une compatibilité avec l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> et fournie une configuration plus aisée par l’intermédiaire du fichier <span class=filename>rc.conf</span>.</p></div></div><div class=sect2><h3 id=_utiliser_des_services_pour_démarrer_dautres_services>11.4.2. Utiliser des services pour démarrer d’autres services<a class=anchor href=#_utiliser_des_services_pour_démarrer_dautres_services></a></h3><div class=paragraph><p>Certains services, comme les serveurs POP3, IMAP, etc., peuvent être démarrés en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. Cela implique d’installer le service à partir du catalogue des logiciels portés et avec une ligne de configuration ajoutée au fichier <span class=filename>/etc/inetd.conf</span>, ou en décommentant une des lignes de configuration déjà présentes. L’utilisation d’inetd et sa configuration sont décrits en profondeur dans la section concernant <a href=../network-servers/#network-inetd>inetd</a>.</p></div><div class=paragraph><p>Dans certains cas, il peut être plus approprié d’utiliser le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> pour démarrer des services. Cette approche présente un certain nombre d’avantages parce que <code>cron</code> exécute ces processus sous les privilèges du propriétaire de la table <span class=filename>crontab</span>. Cela permet aux utilisateurs normaux de lancer et maintenir certaines applications.</p></div><div class=paragraph><p>L’utilitaire <code>cron</code> offre une fonction unique, <code>@reboot</code>, qui peut être utilisée en remplacement de la date d’exécution. Cela provoquera l’exécution de la tâche quand <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> est lancé, normalement lors de l’initialisation du système.</p></div></div></div></div><div class=sect1><h2 id=configtuning-cron>11.5. Configuration de l’utilitaire <code>cron</code><a class=anchor href=#configtuning-cron></a></h2><div class=sectionbody><div class=paragraph><p>Un des utilitaires les plus importants de FreeBSD est <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. L’utilitaire <code>cron</code> tourne en arrière plan et contrôle constamment le fichier <span class=filename>/etc/crontab</span>. L’utilitaire <code>cron</code> consulte également le répertoire <span class=filename>/var/cron/tabs</span>, à la recherche de nouveaux fichiers <span class=filename>crontab</span>. Ces fichiers <span class=filename>crontab</span> conservent les informations sur les tâches que <code>cron</code> est censé exécuter à des moments donnés.</p></div><div class=paragraph><p>L’utilitaire <code>cron</code> utilise deux types différents de fichiers de configuration, le fichier <span class=filename>crontab</span> système et les <span class=filename>crontab</span>s des utilisateurs. Ces deux formats diffèrent à partir du sixième champ. Dans le fichier <span class=filename>crontab</span> système, <code>cron</code> exécutera la commande en tant que l’utilisateur indiqué dans le sixième champ. Dans le fichier <span class=filename>crontab</span> d’un utilisateur, toutes les commandes sont exécutées sous l’utilisateur qui a créé ce fichier <span class=filename>crontab</span>, aussi le sixième champ est le dernier champ; c’est un aspect sécurité important. Le dernier champ est toujours la commande à exécuter.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les fichiers <span class=filename>crontab</span> utilisateur permettent aux utilisateurs de planifier l’exécution de tâches sans avoir besoin des privilèges du super-utilisateur <code>root</code>. Les commandes contenues dans le fichier <span class=filename>crontab</span> d’un utilisateur s’exécutent avec les privilèges de l’utilisateur auquel appartient ce fichier.</p></div><div class=paragraph><p>Le super-utilisateur <code>root</code> peut posséder un fichier <span class=filename>crontab</span> utilisateur comme tout autre utilisateur. Ce fichier est différent de <span class=filename>/etc/crontab</span> (le <span class=filename>crontab</span> système). Etant donné que le fichier <span class=filename>crontab</span> système invoque les commandes spécifiées en tant que <code>root</code>, il n’y a généralement pas besoin d’un fichier <span class=filename>crontab</span> utilisateur pour <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Examinons le fichier <span class=filename>/etc/crontab</span> (fichier <span class=filename>crontab</span> système):</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
#<i class=conum data-value=1></i><b>(1)</b>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
HOME=/var/log
#
#
#minute	heure	date	mois	jour	utilisateur	commande <i class=conum data-value=3></i><b>(3)</b>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Comme pour la plupart des fichiers de configuration de FreeBSD, le caractère <code>#</code> indique un commentaire. Un commentaire peut être ajouté dans le fichier comme rappel de ce que fait une action bien précise et pourquoi elle est effectuée. Les commentaires ne peuvent être situés sur la même ligne qu’une commande ou sinon ils seront interprétés comme faisant partie de la commande; ils doivent se trouver sur une nouvelle ligne. Les lignes vides sont ignorées.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Tout d’abord, les variables d’environnement doivent être définies. Le caractère égal (<code>=</code>) est utilisé pour définir tout paramètre concernant l’environnement, comme dans notre exemple où il a été utilisé pour les variables <code>SHELL</code>, <code>PATH</code>, et <code>HOME</code>. Si la ligne concernant l’interpréteur de commande est omise, <code>cron</code> utilisera celui par défaut, qui est <code>sh</code>. Si la variable <code>PATH</code> est omise, il n’y aura pas de valeur par défaut utilisée et l’emplacement des fichiers devra être absolu. Si <code>HOME</code> est omise, <code>cron</code> utilisera le répertoire personnel de l’utilisateur qui l’invoque.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Cette ligne définie un total de sept champs. Sont listés ici les valeurs <code>minute</code>, <code>heure</code>, <code>date</code>, <code>mois</code>, <code>jour</code>, <code>utilisateur</code>, et <code>commande</code>. Ces champs sont relativement explicites. <code>minute</code> représente l’heure en minute à laquelle la commande sera exécutée. L’option <code>heure</code> est semblable à l’option <code>minute</code>, mais en heures. Le champ <code>date</code> précise le jour dans le mois. <code>mois</code> est similaire à <code>heure</code> et <code>minute</code> mais désigne le mois. L’option <code>jour</code> représente le jour de la semaine. Tous ces champs doivent être des valeurs numériques, et respecter un format horaire de vingt quatre heures. Le champ <code>utilisateur</code> est spécial, et n’existe que dans le fichier <span class=filename>/etc/crontab</span>. Ce champ précise sous quel utilisateur sera exécutée la commande. Le dernier champ désigne la commande à exécuter.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Cette dernière ligne définie les valeurs discutées ci-dessus. Nous avons ici <code>*/5</code> suivi de plusieurs caractères <code>\*</code>. Ces caractères <code>*</code> signifient "premier-dernier", et peuvent être interprétés comme voulant dire à <em>chaque</em> instance. Aussi, d’après cette ligne, il apparaît que la commande <code>atrun</code> sera invoquée par l’utilisateur <code>root</code> toutes les cinq minutes indépendamment du jour ou du mois. Pour plus d’informations sur la commande <code>atrun</code>, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=atrun&amp;sektion=8&amp;format=html">atrun(8)</a>. N’importe quel nombre d’indicateur peut être passé à ces commandes; cependant, les commandes qui s’étendent sur de multiples lignes doivent être "cassées" avec le caractère, contre-oblique <code>\</code>, de continuation de lignes.</td></tr></tbody></table></div><div class=paragraph><p>Ceci est la configuration de base pour chaque fichier <span class=filename>crontab</span>, bien qu’il y ait une différence dans celui présenté ici. Le sixième champ, où est précisé le nom d’utilisateur, n’existe que dans le fichier système <span class=filename>/etc/crontab</span>. Ce champ devrait être omis pour les fichiers <span class=filename>crontab</span> d’utilisateur.</p></div><div class=sect2><h3 id=configtuning-installcrontab>11.5.1. Installer un fichier crontab<a class=anchor href=#configtuning-installcrontab></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Ne pas utiliser la procédure décrite ci-dessous pour éditer et installer le fichier <span class=filename>crontab</span> système. Utilisez directement votre éditeur: l’utilitaire <code>cron</code> remarquera le changement au niveau de ce fichier et utilisera immédiatement la nouvelle version. Consultez <a href=https://docs.freebsd.org/fr/books/faq/#ROOT-NOT-FOUND-CRON-ERRORS>cette entrée de la FAQ</a> pour plus d’information.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour installer un fichier <span class=filename>crontab</span> utilisateur fraîchement rédigé, tout d’abord utilisez votre éditeur favori pour créer un fichier dans le bon format, ensuite utilisez l’utilitaire <code>crontab</code>. L’usage le plus typique est:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># crontab fichier-crontab</span></code></pre></div></div><div class=paragraph><p>Dans cet exemple, <span class=filename>fichier-crontab</span> est le nom d’un fichier <span class=filename>crontab</span> qui a été précédemment créé.</p></div><div class=paragraph><p>Il existe également une option pour afficher les fichiers <span class=filename>crontab</span> installés, passez simplement le paramètre <code>-l</code> à <code>crontab</code> et lisez ce qui est affiché.</p></div><div class=paragraph><p>Pour les utilisateurs désirant créer leur fichier crontab à partir de zéro, sans utiliser de modèle, l’option <code>crontab -e</code> est disponible. Cela invoquera l’éditeur par défaut avec un fichier vide. Quand le fichier est sauvegardé, il sera automatiquement installé par la commande <code>crontab</code>.</p></div><div class=paragraph><p>Afin d’effacer le fichier <span class=filename>crontab</span> utilisateur complètement, utiliser la commande <code>crontab</code> avec l’option <code>-r</code>.</p></div></div></div></div><div class=sect1><h2 id=configtuning-rcd>11.6. Utilisation du système <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> sous FreeBSD<a class=anchor href=#configtuning-rcd></a></h2><div class=sectionbody><div class=paragraph><p>En 2002, le système <span class=filename>rc.d</span> de NetBSD pour l’initialisation du système a été intégré à FreeBSD. Les utilisateurs noteront les fichiers présents dans le répertoire <span class=filename>/etc/rc.d</span>. Plusieurs de ces fichiers sont destinés aux services de base qui peuvent être contrôlés avec les options <code>start</code>, <code>stop</code>, et <code>restart</code>. Par exemple, <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> peut être relancé avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd restart</span></code></pre></div></div><div class=paragraph><p>Cette procédure est similaire pour d’autres services. Bien sûr, les services sont généralement lancés automatiquement au démarrage dès qu’ils sont spécifiés dans le fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Par exemple, activer le "daemon" de translation d’adresses au démarrage est aussi simple que d’ajouter la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Si une ligne <code>natd_enable="NO"</code> est déjà présente, modifiez alors le <code>NO</code> par <code>YES</code>. Les procédures rc chargeront automatiquement les autres services dépendants lors du prochain redémarrage comme décrit ci-dessous.</p></div><div class=paragraph><p>Comme le système <span class=filename>rc.d</span> est à l’origine destiné pour lancer/arrêter les services au démarrage/à l’arrêt du système, les options standards <code>start</code>, <code>stop</code> et <code>restart</code> ne seront effectives que si les variables appropriées sont positionnées dans le fichier <span class=filename>/etc/rc.conf</span>. Par exemple, la commande <code>sshd restart</code> ci-dessus ne fonctionnera que si <code>sshd_enable</code> est fixée à <code>YES</code> dans <span class=filename>/etc/rc.conf</span>. Pour lancer, arrêter ou redémarrer un service indépendemment des paramétrages du fichier <span class=filename>/etc/rc.conf</span>, les commandes doivent être précédées par "one". Par exemple pour redémarrer <code>sshd</code> indépendemment du paramétrage du fichier <span class=filename>/etc/rc.conf</span>, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd onerestart</span></code></pre></div></div><div class=paragraph><p>Il est facile de contrôler si un service est activé dans le fichier <span class=filename>/etc/rc.conf</span> en exécutant la procédure <span class=filename>rc.d</span> appropriée avec l’option <code>rcvar</code>. Ainsi, un administrateur peut contrôler que <code>sshd</code> est réellement activé dans <span class=filename>/etc/rc.conf</span> en exécutant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd rcvar</span>
<span class=c># sshd</span>
<span class=nv>$sshd_enable</span><span class=o>=</span>YES</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La seconde ligne (<code># sshd</code>) est la sortie de la commande <code>sshd</code> et non pas une console <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour déterminer si un service est actif, une option appelée <code>status</code> est disponible. Par exemple pour vérifier que <code>sshd</code> a réellement été lancé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>Dans certains cas, il est également possible de recharger un service avec l’option <code>reload</code>. Le système tentera d’envoyer un signal à un service individuel, le forçant à recharger ses fichiers de configuration. Dans la plupart des cas cela signifie envoyer un signal <code>SIGHUP</code> au service. Le support de cette fonctionnalité n’est pas disponible pour chaque service.</p></div><div class=paragraph><p>Le système <span class=filename>rc.d</span> n’est pas uniquement utilisée pour les services réseaux, elle participe à la majeure partie de l’initialisation du système. Prenez par exemple le fichier <span class=filename>bgfsck</span>. Quand cette procédure est exécutée, il affichera le message suivant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Donc ce fichier est utilisé pour les vérifications du système de fichiers en arrière plan, qui sont uniquement effectuées lors de l’initialisation du système.</p></div><div class=paragraph><p>De nombreux services système dépendent d’autres services pour fonctionner correctement. Par exemple, NIS et les autres services basés sur les RPCs peuvent échouer s’ils sont lancés après le lancement du service <code>rpcbind</code> (portmapper). Pour résoudre ce problème, l’information concernant les dépendances et autres méta-données est inclue dans les commentaires au début de chaque procédure de démarrage. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> est alors utilisé pour analyser ces commentaires lors de l’initialisation du système en vue de déterminer l’ordre dans lequel les services système seront invoqués pour satisfaire les dépendances.</p></div><div class=paragraph><p>Les mots suivants doivent être présents en tête de tous les fichiers de démarrage (ils sont nécessaires pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> active les procédures de démarrages):</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: indique les services que fournit ce fichier.</p></li></ul></div><div class=paragraph><p>Les mots clés suivants peuvent être ajoutés au début de chaque fichier de démarrage. Ils ne sont pas strictement nécessaires, mais sont utiles comme aide pour <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>:</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: liste les fichiers dont dépend ce service. Ce fichier sera exécuté <em>après</em> les services indiqués.</p></li><li><p><code>BEFORE</code>: liste les services qui dépendent du service présent. Ce fichier sera exécuté <em>avant</em> les services indiqués.</p></li></ul></div><div class=paragraph><p>En utilisant avec soin ces mots clés pour chaque fichier de démarrage, un administrateur dispose d’un niveau de contrôle très fin de l’ordre d’exécution des procédures de démarrage sans les inconvénients des "runlevels" comme sur d’autres systèmes d’exploitation UNIX®.</p></div><div class=paragraph><p>Des informations supplémentaires concernant le système <span class=filename>rc.d</span> peuvent être trouvées dans les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Si vous êtes intéressé par l’écriture de vos propres procédures <span class=filename>rc.d</span> ou pour l’amélioration des procédures existantes, vous trouverez <a href=https://docs.freebsd.org/en/articles/rc-scripting/>cette article</a> utile.</p></div></div></div><div class=sect1><h2 id=config-network-setup>11.7. Configuration des cartes réseaux<a class=anchor href=#config-network-setup></a></h2><div class=sectionbody><div class=paragraph><p>De nos jours il est impossible de penser à un ordinateur sans penser connexion à un réseau. Installer et configurer une carte réseau est une tâche classique pour tout administrateur FreeBSD.</p></div><div class=sect2><h3 id=_déterminer_le_bon_pilote_de_périphérique>11.7.1. Déterminer le bon pilote de périphérique<a class=anchor href=#_déterminer_le_bon_pilote_de_périphérique></a></h3><div class=paragraph><p>Avant de commencer, vous devez connaître le modèle de la carte dont vous disposez, le circuit qu’elle utilise, et si c’est une carte PCI ou ISA. FreeBSD supporte une large variété de cartes PCI et ISA. Consultez la liste de compatibilité matérielle pour votre version de FreeBSD afin de voir si votre carte est supportée.</p></div><div class=paragraph><p>Une fois que vous êtes sûrs que votre carte est supportée, vous devez déterminer le bon pilote de périphérique pour la carte. Les fichiers <span class=filename>/usr/src/sys/conf/NOTES</span> et <span class=filename>/usr/src/sys/arch/conf/NOTES</span> vous donneront la liste des pilotes de périphériques pour cartes réseaux avec des informations sur les cartes/circuits supportés. Si vous avez des doutes au sujet du bon pilote, lisez la page de manuel du pilote. La page de manuel vous donnera plus d’information sur le matériel supporté et même les éventuels problèmes qui pourront apparaître.</p></div><div class=paragraph><p>Si vous possédez une carte courante, la plupart du temps vous n’aurez pas à chercher trop loin pour trouver un pilote. Les pilotes pour les cartes réseaux courantes sont présents dans le noyau <span class=filename>GENERIC</span>, aussi votre carte devrait apparaître au démarrage, comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>Dans cet exemple, nous voyons que deux cartes utilisant le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a> sont présentes sur le système.</p></div><div class=paragraph><p>Si le pilote de votre carte n’est pas présent dans le noyau <span class=filename>GENERIC</span>, vous devrez charger le module approprié pour pouvoir utiliser votre carte. Cela peut être effectué de deux manières différentes:</p></div><div class=ulist><ul><li><p>La méthode la plus simple est de charger le module pour votre carte réseau avec <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>, ou automatiquement au démarrage du système en ajoutant la ligne appropriée au fichier <span class=filename>/boot/loader.conf</span>. Tous les pilotes de cartes réseau ne sont pas disponibles sous forme de modules; les cartes ISA sont un bon exemple de périphériques pour lesquels les modules n’existent pas.</p></li><li><p>Alternativement, vous pouvez compiler en statique le support pour votre carte dans votre noyau. Consultez <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> et la page de manuel du pilote de périphérique pour savoir ce qu’il faut ajouter au fichier de configuration de votre noyau. Pour plus d’information sur la recompilation de votre noyau, veuillez lire le <a href=../kernelconfig/#kernelconfig>Configurer le noyau de FreeBSD</a>. Si votre carte a été détectée au démarrage par votre noyau (<span class=filename>GENERIC</span>) vous n’avez pas à compiler un nouveau noyau.</p></li></ul></div><div class=sect3><h4 id=config-network-ndis>11.7.1.1. Utilisation des pilotes NDIS de Windows®<a class=anchor href=#config-network-ndis></a></h4><div class=paragraph><p>Malheureusement il y a toujours de nombreux fabricants qui ne fournissent pas à la communauté des logiciels libres les informations concernant les pilotes pour leurs cartes considérant de telles informations comme des secrets industriels. Par conséquent, il ne reste aux développeurs de FreeBSD et d’autres systèmes d’exploitation libres que deux choix: développer les pilotes en passant par un long et pénible processus de "reverse engineering" ou utiliser les pilotes binaires existants disponibles pour la plateforme Microsoft® Windows®. La plupart des développeurs, y compris ceux impliqués dans FreeBSD, ont choisi cette dernière approche.</p></div><div class=paragraph><p>Grâce aux contributions de Bill Paul (wpaul), il existe un support "natif" pour la spécification d’interface des pilotes de périphérique réseau (Network Driver Interface Specification-NDIS). Le NDISulator FreeBSD (connu également sous le nom de Project Evil) prend un pilote binaire réseau Windows® et lui fait penser qu’il est en train de tourner sous Windows®. Etant donné que le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> utilise un binaire Windows®, il ne fonctionne que sur les systèmes i386™ et amd64. Les périphériques PCI, CardBus, PCMCIA (PC-Card), et USB sont supportés.</p></div><div class=paragraph><p>Pour utiliser le NDISulator, trois choses sont nécessaires:</p></div><div class="olist arabic"><ol class=arabic><li><p>les sources du noyau;</p></li><li><p>le pilote binaire Windows® XP (extension <span class=filename>.SYS</span>);</p></li><li><p>le fichier de configuration du pilote Windows® XP (extension <span class=filename>.INF</span>).</p></li></ol></div><div class=paragraph><p>Recherchez les fichiers spécifiques à votre carte. Généralement, ils peuvent être trouvés sur les CDs livrés avec la carte ou sur le site du fabricant. Dans les exemples qui suivent nous utiliseront les fichiers <span class=filename>W32DRIVER.SYS</span> et <span class=filename>W32DRIVER.INF</span>.</p></div><div class=paragraph><p>Le type de pilote doit correspondre à la version de FreeBSD. Pour FreeBSD/i386, utiliser un pilote Windows® 32bits. Pour FreeBSD/amd64, un pilote Windows® 64bits est nécessaire.</p></div><div class=paragraph><p>L’étape suivante est de compiler le pilote binaire dans un module chargeable du noyau. En tant que <code>root</code>, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> est interactif, il sollicitera l’utilisateur pour d’éventuelles informations complémentaires si nécessaire. Un nouveau module noyau est créé dans le répertoire courant. Utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> pour charger le nouveau module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER_SYS.ko</span></code></pre></div></div><div class=paragraph><p>Avec le module généré, vous devez également charger les modules <span class=filename>ndis.ko</span> et <span class=filename>if_ndis.ko</span>. Cela devrait être fait automatiquement quand vous chargez un module qui dépend de <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>. Si vous désirez les charger manuellement, utilisez les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>La première commande charge le pilote d’interface NDIS, la seconde charge l’interface réseau.</p></div><div class=paragraph><p>Contrôlez maintenant la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> à la recherche d’une quelconque erreur au chargement. Si tout s’est bien passé, vous devriez obtenir une sortie ressemblant à ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>A partir de là vous pouvez traiter le périphérique <span class=filename>ndis0</span> comme n’importe quelle interface réseau (par exemple <span class=filename>dc0</span>).</p></div><div class=paragraph><p>Vous pouvez configurer le système pour charger les modules NDIS au démarrage du système de la même manière que pour n’importe quel autre module. Tout d’abord, copiez le module généré, <span class=filename>W32DRIVER_SYS.ko</span>, dans le répertoire <span class=filename>/boot/modules</span>. Ajoutez ensuite la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_configuration_de_la_carte_réseau>11.7.2. Configuration de la carte réseau<a class=anchor href=#_configuration_de_la_carte_réseau></a></h3><div class=paragraph><p>Une fois que le bon pilote de périphérique pour la carte réseau est chargé, la carte doit être configurée. Comme beaucoup d’autres choses, la carte aura pu être configurée à l’installation par sysinstall.</p></div><div class=paragraph><p>Pour afficher la configuration des interfaces réseaux de votre système, entrer la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>Dans cet exemple, les périphériques suivants ont été affichés:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: La première interface Ethernet</p></li><li><p><span class=filename>dc1</span>: La seconde interface Ethernet</p></li><li><p><span class=filename>lo0</span>: L’interface "en boucle" ("loopback")</p></li></ul></div><div class=paragraph><p>FreeBSD utilise le nom du pilote de périphérique suivi par un chiffre représentant l’ordre dans lequel la carte est détectée au démarrage du noyau pour nommer la carte. Par exemple <span class=filename>sis2</span> serait la troisième carte sur le système utilisant le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a>.</p></div><div class=paragraph><p>Dans cet exemple, le périphérique <span class=filename>dc0</span> est actif et en fonctionnement. Les indicateurs importants sont:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> signifie que la carte est configurée et prête.</p></li><li><p>La carte possède une adresse Internet (<code>inet</code>) (dans ce cas-ci <code>192.168.1.3</code>).</p></li><li><p>Elle a un masque de sous-réseau valide (<code>netmask</code>; <code>0xffffff00</code> est équivalent à <code>255.255.255.0</code>).</p></li><li><p>Elle a une adresse de diffusion valide (dans ce cas-ci <code>192.168.1.255</code>).</p></li><li><p>L’adresse MAC de la carte (<code>ether</code>) est <code>00:a0:cc:da:da:da</code></p></li><li><p>La sélection du média est sur le mode d’autosélection (<code>media: Ethernet autoselect (100baseTX full-duplex)</code>). Nous voyons que <span class=filename>dc1</span> a été configurée pour utiliser un matériel de type <code>10baseT/UTP</code>. Pour plus d’information sur le type de matériel disponible pour un pilote de périphérique, référez-vous à sa page de manuel.</p></li><li><p>La liaison (<code>status</code>) est <code>active</code>, i.e. la porteuse est détectée. Pour <span class=filename>dc1</span>, nous lisons <code>status: no carrier</code>. Cela est normal lorsqu’aucun câble n’est branché à la carte.</p></li></ol></div><div class=paragraph><p>Si le résultat de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> est similaire à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active</code></pre></div></div><div class=paragraph><p>cela indiquerait que la carte n’a pas été configurée.</p></div><div class=paragraph><p>Pour configurer votre carte, vous avez besoin des privilèges de l’utilisateur <code>root</code>. La configuration de la carte réseau peut être faite à partir de la ligne de commande avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> mais vous aurez à répéter cette opération à chaque redémarrage du système. Le fichier <span class=filename>/etc/rc.conf</span> est l’endroit où ajouter la configuration de la carte réseau.</p></div><div class=paragraph><p>Ouvrez le fichier <span class=filename>/etc/rc.conf</span> dans votre éditeur favori. Vous devez ajouter une ligne pour chaque carte réseau présente sur le système, par exemple dans notre cas, nous avons ajouté ces lignes:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Vous devez remplacer <span class=filename>dc0</span>, <span class=filename>dc1</span>, et ainsi de suite, avec le périphérique correspondant pour vos cartes, et les adresses avec celles désirées. Vous devriez lire les pages de manuel du pilote de périphérique et d’<a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> pour plus de détails sur les options autorisées et également la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> pour plus d’information sur la syntaxe de <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Si vous avez configuré le réseau à l’installation, des lignes concernant la/les carte(s) réseau pourront être déjà présentes. Contrôler à deux fois le fichier <span class=filename>/etc/rc.conf</span> avant d’y ajouter des lignes.</p></div><div class=paragraph><p>Vous devrez également éditer le fichier <span class=filename>/etc/hosts</span> pour ajouter les noms et les adresses IP des diverses machines du réseau local, si elles ne sont pas déjà présentes. Pour plus d’information référez-vous à la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> et au fichier <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>S’il n’y a pas de serveur DHCP et qu’un accès à Internet est nécessaire, configurez manuellement la passerelle par défaut et le serveur de noms:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;your_default_router&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver your_DNS_server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_test_et_dépannage>11.7.3. Test et dépannage<a class=anchor href=#_test_et_dépannage></a></h3><div class=paragraph><p>Une fois les modifications nécessaires du fichier <span class=filename>/etc/rc.conf</span> effectuées, vous devrez redémarrer votre système. Cela permettra la prise en compte de la ou les modifications au niveau des interfaces, et permettra de vérifier que le système redémarre sans erreur de configuration. Sinon, une autre méthode pour faire prendre en compte les modifications au niveau de la gestion du réseau consiste à utiliser la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si une passerelle par défaut a été configurée dans <span class=filename>/etc/rc.conf</span>, lancez également cette commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Une fois que le système a été redémarré, vous testez les interfaces réseau.</p></div><div class=sect3><h4 id=_tester_la_carte_ethernet>11.7.3.1. Tester la carte Ethernet<a class=anchor href=#_tester_la_carte_ethernet></a></h4><div class=paragraph><p>Pour vérifier qu’une carte Ethernet est configurée correctement, vous devez essayer deux choses. Premièrement, "pinguer" l’interface, puis une autre machine sur le réseau local.</p></div><div class=paragraph><p>Tout d’abord testons l’interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=paragraph><p>Nous devons maintenant "pinguer" une autre machine sur le réseau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Vous pourrez utiliser le noms de la machine à la place de <code>192.168.1.2</code> si vous avez configuré le fichier <span class=filename>/etc/hosts</span>.</p></div></div><div class=sect3><h4 id=_dépannage>11.7.3.2. Dépannage<a class=anchor href=#_dépannage></a></h4><div class=paragraph><p>Le dépannage de matériels ou de logiciels est toujours une tâche relativement pénible, mais qui peut être rendue plus aisée en vérifiant en premier lieu certaines choses élémentaires. Votre câble réseau est-il branché? Avez-vous correctement configuré les services réseau? Le coupe-feu est-il bien configuré? Est-ce que la carte réseau est supportée par FreeBSD? Consultez toujours les notes concernant le matériel avant d’envoyer un rapport de bogue. Mettez à jour votre version de FreeBSD vers la dernière version STABLE. Consultez les archives des listes de diffusion, et faites même des recherches sur l’Internet.</p></div><div class=paragraph><p>Si la carte fonctionne mais les performances sont mauvaises, une lecture de la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a> peut valoir la peine. Vous pouvez également vérifier la configuration du réseau puisque des paramètres réseau incorrects peuvent donner lieu à des connexions lentes.</p></div><div class=paragraph><p>Certains utilisateurs peuvent voir apparaître un ou deux messages <code>device timeout</code>, ce qui est normal pour certaines cartes. Si ces messages se multiplient, assurez-vous que la carte n’est pas en conflit avec un autre périphérique. Contrôlez à deux fois les câbles de connexion. Peut-être que vous avez juste besoin d’une autre carte.</p></div><div class=paragraph><p>Parfois, des utilisateurs sont confrontés à des messages d’erreur <code>watchdog timeout</code>. La première chose à faire dans ce cas est de vérifier votre câble réseau. De nombreuses cartes demandent un slot PCI supportant le "Bus Mastering". Sur certaines cartes mère anciennes, seul un slot PCI le permet (la plupart du temps le slot 0). Consultez la documentation de la carte réseau et de la carte mère pour déterminer si cela peut être à l’origine du problème.</p></div><div class=paragraph><p>Les messages <code>No route to host</code> surviennent si le système est incapable de router un paquet vers la machine de destination. Cela peut arriver s’il n’y a pas de route par défaut de définie, ou si le câble réseau est débranché. Vérifiez la sortie de la commande <code>netstat -nr</code> et assurez-vous qu’il y a une route valide en direction de la machine que vous essayez d’atteindre. Si ce n’est pas le cas, lisez la <a href=../advanced-networking/#advanced-networking>Administration réseau avancée</a>.</p></div><div class=paragraph><p>Les messages d’erreur <code>ping: sendto: Permission denied</code> sont souvent dus à un coupe-feu mal configuré. Si <code>ipfw</code> est activé dans le noyau mais qu’aucune règle n’a été définie, alors la politique par défaut est de refuser tout trafic, même les requêtes "ping"! Lisez <a href=../firewalls/#firewalls>Firewalls</a> pour plus d’informations.</p></div><div class=paragraph><p>Parfois les performances de la carte ne sont pas bonnes, ou en dessous de la moyenne. Dans ce cas il est recommandé de passer la sélection du média du mode <code>autoselect</code> au mode adéquat. Alors que cela fonctionne généralement pour la plupart du matériel, il se peut que cela ne résolve pas le problème pour tout de monde. Encore une fois, contrôlez les paramétrages réseau et consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>11.8. Hôtes virtuels<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>Une utilisation très courante de FreeBSD est l’hébergement de sites virtuels, où un serveur apparaît pour le réseau comme étant plusieurs serveurs différents. Ceci est possible en assignant plusieurs adresses réseau à une interface.</p></div><div class=paragraph><p>Une interface réseau donnée possède une adresse "réelle", et peut avoir n’importe quel nombre d’adresses "alias". Ces alias sont normalement ajoutés en plaçant les entrées correspondantes dans le fichier <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Une entrée d’alias pour l’interface <span class=filename>fxp0</span> ressemble à:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>Notez que les entrées d’alias doivent commencer avec alias0 et continuer en ordre croissant, (par exemple, _alias1, _alias2, et ainsi de suite). Le processus de configuration s’arrêtera au premier nombre absent.</p></div><div class=paragraph><p>Le calcul des masques de réseau est important, mais heureusement assez simple. Pour une interface donnée, il doit y avoir une adresse qui représente correctement le masque de réseau de votre réseau. Tout autre adresse appartenant à ce réseau devra avoir un masque de réseau avec chaque bit à <code>1</code> (exprimé soit sous la forme <code>255.255.255.255</code> soit <code>0xffffffff</code>).</p></div><div class=paragraph><p>Par exemple, considérez le cas où l’interface <span class=filename>fxp0</span> est connectée à deux réseaux, le réseau <code>10.1.1.0</code> avec un masque de réseau de <code>255.255.255.0</code> et le réseau <code>202.0.75.16</code> avec un masque de <code>255.255.255.240</code>. Nous voulons que le système apparaisse de <code>10.1.1.1</code> jusqu’à <code>10.1.1.5</code> et à <code>202.0.75.17</code> jusqu’à <code>202.0.75.20</code>. Comme noté plus haut, seule la première adresse dans un intervalle réseau donné (dans ce cas, <code>10.0.1.1</code> et <code>202.0.75.17</code>) devrait avoir un masque de sous-réseau réel; toutes les autres adresses (<code>10.1.1.2</code> à <code>10.1.1.5</code> et <code>202.0.75.18</code> jusqu’à <code>202.0.75.20</code>) doivent être configurées avec un masque de sous-réseau de <code>255.255.255.255</code>.</p></div><div class=paragraph><p>Les entrées suivantes du fichier <span class=filename>/etc/rc.conf</span> configurent la carte correctement pour cet arrangement:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div></div></div><div class=sect1><h2 id=configtuning-configfiles>11.9. Fichiers de configuration<a class=anchor href=#configtuning-configfiles></a></h2><div class=sectionbody><div class=sect2><h3 id=_organisation_du_répertoire_etc>11.9.1. Organisation du répertoire <span class=filename>/etc</span><a class=anchor href=#_organisation_du_répertoire_etc></a></h3><div class=paragraph><p>Il existe un certain nombre de répertoires dans lesquels se trouvent les informations de configuration. Ceux-ci incluent:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Information de configuration générique du système; les données ici sont spécifiques au système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Version par défaut des fichiers de configuration du système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration de <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, et autres fichiers de configuration d’agent de transmission du courrier électronique.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration pour les programmes PPP utilisateur et intégré au noyau.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emplacement par défaut pour les données de <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. Normalement <span class=filename>named.conf</span> et les fichiers de zone sont stockés dans ce répertoire.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de configuration pour les applications installées. Peut contenir des sous-répertoires pour chaque application.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Procédures de lancement/d’arrêt pour les applications installées.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de bases de données automatiquement générés, spécifiques au système, comme la base de données des logiciels installés, la base de données de localisation des fichiers, et ainsi de suite.</p></td></tr></tbody></table></div><div class=sect2><h3 id=_nom_dhôtes>11.9.2. Nom d’hôtes<a class=anchor href=#_nom_dhôtes></a></h3><div class=sect3><h4 id=_etcresolv_conf>11.9.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h4><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> gère comment le résolveur de FreeBSD accède au système de nom de domaine d’Internet (DNS).</p></div><div class=paragraph><p>Les entrées la plus classiques du fichier <span class=filename>resolv.conf</span> sont:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’adresse IP du serveur de noms auquel le résolveur devrait envoyer ses requêtes. Les serveurs sont sollicités dans l’ordre listé avec un maximum de trois.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Liste de recherche pour la résolution de nom de machine. Ceci est normalement déterminé par le domaine de l’hôte local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le nom du domaine local.</p></td></tr></tbody></table><div class=paragraph><p>Un fichier <span class=filename>resolv.conf</span> typique:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Seule une des options <code>search</code> et <code>domain</code> devrait être utilisée.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous utilisez DHCP, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> réécrit habituellement <span class=filename>resolv.conf</span> avec l’information reçue du serveur DHCP.</p></div></div><div class=sect3><h4 id=_etchosts>11.9.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h4><div class=paragraph><p><span class=filename>/etc/hosts</span> est une simple base de données texte, une réminiscence des débuts d’Internet. Il travaille en conjonction avec les serveurs DNS et NIS pour fournir les correspondances nom vers adresse IP. Les ordinateurs locaux reliés par l’intermédiaire d’un réseau local peuvent être ajoutés dans ce fichier pour une résolution de noms simple plutôt que de configurer un serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. De plus <span class=filename>/etc/hosts</span> peut être utilisé pour fournir un enregistrement local de correspondances de nom, réduisant ainsi le besoin de requêtes vers l’extérieur pour les noms auxquels on accède couramment.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> suit le format simple suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet address] [official hostname] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>Par exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> pour plus d’informations.</p></div></div></div><div class=sect2><h3 id=_configuration_des_fichiers_de_trace>11.9.3. Configuration des fichiers de trace<a class=anchor href=#_configuration_des_fichiers_de_trace></a></h3><div class=sect3><h4 id=_syslog_conf>11.9.3.1. <span class=filename>syslog.conf</span><a class=anchor href=#_syslog_conf></a></h4><div class=paragraph><p><span class=filename>syslog.conf</span> est le fichier de configuration du programme <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>. Il indique quel type de messages <code>syslog</code> sera enregistré dans des fichiers de traces particuliers.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> pour plus d’informations.</p></div></div><div class=sect3><h4 id=_newsyslog_conf>11.9.3.2. <span class=filename>newsyslog.conf</span><a class=anchor href=#_newsyslog_conf></a></h4><div class=paragraph><p><span class=filename>newsyslog.conf</span> est le fichier de configuration de <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a>, un programme qui est normalement programmé <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> pour s’exécuter périodiquement. <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> détermine quand les fichiers de traces doivent être archivés ou réorganisés. <span class=filename>logfile</span> devient <span class=filename>logfile.0</span>, <span class=filename>logfile.0</span> devient à son tour <span class=filename>logfile.1</span>, et ainsi de suite. D’autre part, les fichiers de traces peuvent être archivés dans le format <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, ils se nommeront alors: <span class=filename>logfile.0.gz</span>, <span class=filename>logfile.1.gz</span>, et ainsi de suite.</p></div><div class=paragraph><p><span class=filename>newsyslog.conf</span> indique quels fichiers de traces doivent être gérés, combien doivent être conservés, et quand ils doivent être modifiés. Les fichiers de traces peuvent être réorganisés et/ou archivés quand ils ont soit atteint une certaine taille, soit à une certaine période/date.</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> pour plus d’informations.</p></div></div></div><div class=sect2><h3 id=configtuning-sysctlconf>11.9.4. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h3><div class=paragraph><p><span class=filename>sysctl.conf</span> ressemble à <span class=filename>rc.conf</span>. Les valeurs sont fixées sous la forme <code>variable=value</code>. Les valeurs spécifiées sont positionnées après que le système soit passé dans le mode multi-utilisateurs. Toutes les variables ne sont pas paramétrables dans ce mode.</p></div><div class=paragraph><p>Pour désactiver l’enregistrement des signaux fatals de fin de processus et empêcher les utilisateurs de voir les processus lancés par les autres, les variables suivantes peuvent être paramétrées dans <span class=filename>sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div></div></div><div class=sect1><h2 id=configtuning-sysctl>11.10. Optimisation avec <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#configtuning-sysctl></a></h2><div class=sectionbody><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> est une interface qui vous permet d’effectuer des changements de paramétrage sur un système FreeBSD en fonctionnement. Cela comprend de nombreuses options avancées de la pile TCP/IP et du système de mémoire virtuelle qui peuvent améliorer dramatiquement les performances pour un administrateur système expérimenté. Plus de cinq cent variables système peuvent être lues et modifiées grâce à <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> remplit deux fonctions: lire et modifier les paramétrages du système.</p></div><div class=paragraph><p>Pour afficher toutes les variables lisibles:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>Pour lire une variable particulière, par exemple, <code>kern.maxproc</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>Pour fixer une variable particulière, utilisez la syntaxe intuitive <em>variable</em>=<em>valeur</em> :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>Les valeurs des variables sysctl sont généralement des chaînes de caractères, des nombres, ou des booléens (un variable booléenne étant <code>1</code> pour oui ou un <code>0</code> pour non).</p></div><div class=paragraph><p>Si vous voulez fixer automatiquement certaines variables à chaque démarrage de la machine, ajoutez-les au fichier <span class=filename>/etc/sysctl.conf</span>. Pour plus d’information consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> et la <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect2><h3 id=sysctl-readonly>11.10.1. Variables <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> en lecture seule<a class=anchor href=#sysctl-readonly></a></h3><div class=paragraph><p>Dans certains cas, il peut être nécessaire de modifier des variables <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> en lecture seule. Bien que cela soit parfois inévitable, cela ne peut être fait qu’au (re)démarrage de la machine.</p></div><div class=paragraph><p>Par exemple sur certains modèles d’ordinateurs portables le périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> ne sondera pas le système à la recherche des zones mémoires, et échouera avec des erreurs du type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>Des cas comme le précédent demandent généralement la modification de paramètres <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> par défaut qui sont en lecture seule. Pour palier à ces situations un utilisateur peut placer un paramétrage ("OID"-Object IDentifier) <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> dans le fichier local <span class=filename>/boot/loader.conf.local</span>. Les paramétrages par défaut se trouvent dans le fichier <span class=filename>/boot/defaults/loader.conf</span>.</p></div><div class=paragraph><p>Pour corriger le problème précédent, il faudrait que l’utilisateur ajoute la ligne <code>hw.pci.allow_unsupported_io_range=1</code> dans le fichier précédemment indiqué. Désormais le périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> devrait fonctionner normalement.</p></div></div></div></div><div class=sect1><h2 id=configtuning-disk>11.11. Optimiser les disques<a class=anchor href=#configtuning-disk></a></h2><div class=sectionbody><div class=sect2><h3 id=_les_variables_sysctl>11.11.1. Les variables sysctl<a class=anchor href=#_les_variables_sysctl></a></h3><div class=sect3><h4 id=_vfs_vmiodirenable>11.11.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h4><div class=paragraph><p>La variable sysctl <code>vfs.vmiodirenable</code> peut être positionnée soit à 0 (désactivée) soit à 1 (activée); elle est a 1 par défaut. Cette variable spécifie comment les répertoires sont cachés par le système. La plupart des répertoires sont petits, utilisant juste un simple fragment du système de fichiers (typiquement 1KO) et moins dans le cache en mémoire (typiquement 512 octets). Avec cette variable désactivée (à 0), le cache en mémoire ne cachera qu’un nombre fixe de répertoires même si vous disposez d’une grande quantité de mémoire. Activée (à 1), cette variable sysctl permet au cache en mémoire d’utiliser le cache des pages de mémoire virtuelle pour cacher les répertoires, rendant toute la mémoire disponible pour cacher les répertoires. Cependant, la taille minimale de l’élément mémoire utilisé pour cacher un répertoire est une page physique (typiquement 4KO) plutôt que 512 octets. Nous recommandons de conserver de cette option activée si vous faites fonctionner des services qui manipulent un grand nombre de fichiers. De tels services peuvent être des caches web, d’importants systèmes de courrier électronique, et des systèmes serveurs de groupe de discussion. Conserver cette option activée ne réduira généralement pas les performances même avec la mémoire gaspillée mais vous devriez faire des expériences pour le déterminer.</p></div></div><div class=sect3><h4 id=_vfs_write_behind>11.11.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h4><div class=paragraph><p>La variable sysctl <code>vfs.write_behind</code> est positionnée par défaut à <code>1</code> (activée). Elle demande au système de fichiers d’effectuer les écritures lorsque des grappes complètes de données ont été collectées, ce qui se produit généralement lors de l’écriture séquentielle de gros fichiers. L’idée est d’éviter de saturer le cache tampon avec des tampons sales quand cela n’améliorera pas les performances d’E/S. Cependant, cela peut bloquer les processus et dans certaines conditions vous pouvez vouloir désactiver cette fonction.</p></div></div><div class=sect3><h4 id=_vfs_hirunningspace>11.11.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h4><div class=paragraph><p>La variable sysctl <code>vfs.hirunningspace</code> détermine combien d’opérations d’écriture peuvent être mises en attente à tout moment au niveau des contrôleurs disques du système. La valeur par défaut est normalement suffisante mais sur les machines avec de nombreux disques, vous pouvez vouloir l’augmenter jusqu’à quatre ou cinq <em>méga-octets</em>. Notez que fixer une valeur trop élevée (dépassant la limite d’écriture du cache tampon) peut donner lieu à de très mauvaises performances. Ne fixez pas cette valeur à une valeur élevée arbitraire! Des valeurs d’écriture élevées peuvent ajouter des temps de latence aux opérations d’écriture survenant au même moment.</p></div><div class=paragraph><p>Il existent d’autres variables sysctl relatives aux caches tampons et aux pages VM. Nous ne recommandons pas de modifier ces valeurs, le système VM effectue un très bon travail d’auto-optimisation.</p></div></div><div class=sect3><h4 id=_vm_swap_idle_enabled>11.11.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h4><div class=paragraph><p>La variable <code>vm.swap_idle_enabled</code> est utile dans le cas de systèmes multi-utilisateurs importants où il y a beaucoup d’utilisateurs s’attachant et quittant le système et de nombreux processus inactifs. De tels systèmes tendent à générer une pression assez importante et continue sur les réserves de mémoire libres. Activer cette fonction et régler l’hystéresis de libération de l’espace de pagination (en secondes d’inactivité) par l’intermédiaire des variables <code>vm.swap_idle_threshold1</code> et <code>vm.swap_idle_threshold2</code>, vous permet de diminuer la priorité des pages mémoire associées avec les processus inactifs plus rapidement qu’avec l’algorithme normal de libération. Cela aide le "daemon" de libération des pages. N’activez cette option que si vous en besoin, parce que la concession que vous faites est d’utiliser l’espace de pagination pour les pages mémoire plus tôt qu’à l’accoutumé, consommant par conséquent plus d’espace de pagination et de bande passante disque. Sur un petit système, cette option aura un effet limité mais dans le cas d’un système important qui fait appel à l’espace de pagination de façon modérée, cette option permettra au système VM de transférer l’ensemble des processus de et vers la mémoire aisément.</p></div></div><div class=sect3><h4 id=_hw_ata_wc>11.11.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h4><div class=paragraph><p>FreeBSD 4.3 a flirté avec la désactivation du cache en écriture des disques IDE. Cela réduisit la bande passante en écriture des disques IDE mais fut considéré comme nécessaire en raison de sérieux problèmes de cohérence de données introduits par les fabricants de disques durs. Le problème est que les disques IDE mentent sur le moment où une écriture est réellement terminée. Avec le cache en écriture IDE activé, les disques durs IDE non seulement n’écriront pas les données dans l’ordre, mais parfois retarderont l’écriture de certains blocs indéfiniment sous une charge disque importante. Un crash ou une coupure secteur pourra être à l’origine de sérieuses corruptions du système de fichiers. Par précaution le paramétrage par défaut de FreeBSD fut modifié. Malheureusement, le résultat fut une telle perte de performances que nous avons réactivé le cache en écriture après cette version de FreeBSD. Vous devriez contrôler la valeur par défaut sur votre système en examinant la variable sysctl <code>hw.ata.wc</code>. Si le cache en écriture des disques IDE est désactivé, vous pouvez le réactiver en positionnant la variable à 1. Cela doit être fait à partir du chargeur au démarrage. Tenter de le faire après le démarrage du noyau n’aura aucun effet.</p></div><div class=paragraph><p>Pour plus d’informations, veuillez consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect3><h4 id=_scsi_delay_kern_cam_scsi_delay>11.11.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h4><div class=paragraph><p>L’option de configuration du noyau <code>SCSI_DELAY</code> peut être utilisée pour réduire le temps de démarrage du système. Le délai par défaut est important et peut être responsable de plus de <code>15</code> secondes d’attente lors du processus de démarrage. Réduire ce délai à <code>5</code> secondes est généralement suffisant (tout particulièrement avec les disques modernes). L’option de démarrage <code>kern.cam.scsi_delay</code> devrait être utilisée. Cette option de démarrage et celle de configuration du noyau acceptent des valeurs en <em>millisecondes</em> et <em>non pas</em> en <em>secondes</em>.</p></div></div></div><div class=sect2><h3 id=soft-updates>11.11.2. Les "Soft Updates"<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> peut être utilisé pour régler finement un système de fichiers. Ce programme dispose de nombreuses options différentes, mais pour l’instant nous nous intéresserons uniquement à l’activation et la désactivation des "Soft Updates", ce qui fait avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>Un système de fichiers ne peut être modifié avec <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> tant qu’il est monté. Un bon moment pour activer les "Soft Updates" est avant que les partitions ne soient montées en mode mono-utilisateur.</p></div><div class=paragraph><p>Les "Soft Updates" améliorent de façon drastique les performances sur les méta-données, principalement la création et la suppression de fichier, par l’utilisation d’un cache mémoire. Nous recommandons d’activer les "Soft Updates" sur tous vos systèmes de fichiers. Il y a deux inconvénients aux "Soft Updates" que vous devez connaître: tout d’abord, les "Soft Updates" garantissent la cohérence du système de fichiers en cas de crash mais pourront facilement être en retard de quelques secondes (voir même une minute!) dans la mise à jour du disque. Si votre système plante il se peut que vous perdiez plus de travail que dans d’autres cas. Deuxièmement, les "Soft Updates" retardent la libération des blocs du système de fichiers. Si vous avez un système de fichiers (comme le système de fichiers racine) qui est presque plein, effectuer une mise à jour majeure, comme un <code>make installworld</code>, peut mener à un manque d’espace sur le système de fichiers et faire échouer la mise à jour.</p></div><div class=sect3><h4 id=_plus_de_détails_à_propos_des_soft_updates>11.11.2.1. Plus de détails à propos des "Soft Updates"<a class=anchor href=#_plus_de_détails_à_propos_des_soft_updates></a></h4><div class=paragraph><p>Il y a deux approches traditionnelles pour écrire les méta-données d’un système de fichiers sur le disque (mise à jour des méta-données et mise à jour des éléments sans données comme les inodes ou les répertoires).</p></div><div class=paragraph><p>Historiquement, le comportement par défaut était d’écrire les mises à jour des méta-données de façon synchrone. Si un répertoire a été modifié, le système attendait jusqu’à ce que le changement soit effectivement écrit sur le disque. Les tampons des données de fichier (contenu du fichier) passaient par le cache mémoire et étaient copiés sur le disque plus tard de façon asynchrone. L’avantage de cette implémentation est qu’elle est effectuée sans risque. S’il y a un problème durant une mise à jour, les méta-données sont toujours dans un état consistant. Un fichier est soit créé complètement soit pas du tout. Si les blocs de données d’un fichier n’ont pas trouvé leur chemin du cache mémoire vers le disque au moment du crash, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> est capable de s’en apercevoir et de réparer le système de fichiers en fixant la taille du fichier à 0. De plus, l’implémentation est claire et simple. L’inconvénient est que la modification des méta-données est lente. Un <code>rm -r</code>, par exemple, touche à tous les fichiers dans un répertoire séquentiellement, mais chaque modification du répertoire (effacement d’un fichier) sera écrite de façon synchrone sur le disque. Cela comprend les mises à jour du répertoire lui-même, de la table des inodes, et éventuellement celles sur des blocs indirects alloués par le fichier. Des considérations semblables s’appliquent à la création d’importantes hiérarchies ((<code>tar -x</code>).</p></div><div class=paragraph><p>Le deuxième cas est la mise à jour asynchrone des méta-données. C’est le comportement par défaut de Linux/ext2fs et de l’usage de <code>mount -o async</code> pour l’UFS des systèmes BSD. Toutes les mises à jour des méta-données passent également par l’intermédiaire d’un cache mémoire, c’est à dire, qu’elles seront mélangées aux mises à jour des données du contenu du fichier. L’avantage de cette implémentation est qu’il n’y a pas besoin d’attendre jusqu’à l’écriture sur le disque de chaque mise à jour de méta-données, donc toutes les opérations qui sont à l’origine d’une grande quantité de mise à jour de méta-données fonctionnent bien plus rapidement que dans le cas synchrone. De plus, l’implémentation est toujours claire et simple, il y a donc peu de risque qu’un bogue se cache dans le code. L’inconvénient est qu’il n’y a aucune garantie du tout sur la cohérence du système de fichiers. S’il y a un problème durant une opération qui met à jour une grande quantité de méta-données (comme une coupure secteur, ou quelqu’un appuyant sur le bouton reset), le système de fichiers sera laissé dans un état imprévisible. Il n’y a aucune opportunité d’examiner l’état du système de fichiers quand le système est à nouveau relancé; les blocs de données d’un fichier pourraient déjà avoir été inscrits sur le disque alors que la mise à jour de la table des inodes ou du répertoire associé n’a pas été faite. Il est en fait impossible d’implémenter un <code>fsck</code> qui est capable de nettoyer le chaos résultant (parce que l’information nécessaire n’est pas disponible sur le disque). Si le système de fichiers a été endommagé irrémédiablement, le seul choix est de le recréer avec <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> et de récupérer les données à partir de sauvegardes.</p></div><div class=paragraph><p>La solution commune pour ce problème fut d’implémenter une <em>région de trace</em>, dont on fait souvent référence sous le terme de <em>journalisation</em>, bien que ce terme ne soit pas toujours utilisé de façon cohérente et est occasionnellement utilisé pour d’autres formes de transaction avec trace. Les mises à jour des méta-données sont toujours écrites de façon synchrone, mais seulement sur une petite région du disque. Elles seront plus tard déplacées vers leur emplacement correct. Parce que la région de trace est une petite région contiguë sur le disque, il n’y a pas de grandes distances de déplacement pour les têtes des disques, même durant les opérations importantes, donc ces opérations sont plus rapides que les mises à jour synchrones. De plus la complexité de l’implémentation est relativement limitée, donc le risque de présence de bogues est faible. Un inconvénient est que toutes les méta-données sont écrites deux fois (une fois dans la région de trace et une fois sur l’emplacement correct) donc pour un fonctionnement normal, une baisse des performances pourra en résulter. D’autre part, dans le cas d’un crash, toutes les opérations sur les méta-données en attente peuvent rapidement être annulées ou complétées à partir de la zone de trace après le redémarrage du système, ayant pour résultat un démarrage rapide du système de fichiers.</p></div><div class=paragraph><p>Kirk McKusick, le développeur du FFS de Berkeley, a résolu le problème avec les "Soft Updates": toutes les mises à jour des méta-données sont conservées en mémoire et inscrites sur le disque selon une séquence ordonnée ("mise à jour ordonnée des méta-données"). Ceci a pour effet, dans le cas d’un nombre d’opérations sur les méta-données important, que les dernières mises à jour sur un élément "attrapent" les premières si ces dernières sont encore en mémoire et n’ont pas encore été inscrites sur le disque. Donc toutes les opérations sur, par exemple, un répertoire sont généralement effectuées en mémoire avant que la mise à jour ne soit écrite sur le disque (les blocs de données sont ordonnés en fonction de leur position de sorte à ce qu’ils ne soient pas sur le disque avant leur méta-données). Si le système crash, cela provoque un "retour dans les traces" implicite: toutes les opérations qui n’ont pas trouvé leur chemin vers le disque apparaissent comme si elles n’avaient jamais existé. Un état cohérent du système de fichiers est maintenu et apparaît comme étant celui de 30 ou 60 secondes plus tôt. L’algorithme utilisé garantie que toutes les ressources utilisées soient marquées avec leur bons "bitmaps": blocs et inodes. Après un crash, les seules erreurs d’allocation de ressources qui apparaissent sont les ressources qui ont été marquées comme "utilisées" et qui sont en fait "libre". <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> reconnaît cette situation, et libère les ressources qui ne sont plus utilisées. On peut ignorer sans risque l’état "sale" d’un système de fichiers après un crash en forçant son montage avec <code>mount -f</code>. Afin de libérer les ressources qui peuvent être inutilisées, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> doit être exécuté plus tard. C’est l’idée qu’il y a derrière le "<em>background fsck</em>" (fsck en tâche de fond): au démarrage du système, seule un "<em>snapshot</em>" (photographie) du système de fichiers est prise. La commande <code>fsck</code> peut être exécutée plus tard sur ce système de fichiers. Tous les systèmes de fichiers peuvent être montés "sales", donc le système passe en mode multi-utilisateurs. Ensuite, les <code>fsck</code> en tâche de fond seront programmés pour tous les systèmes de fichiers pour lesquels c’est nécessaire, pour libérer les ressources qui peuvent être inutilisées (les systèmes qui n’utilisent pas les "Soft Updates" ont toujours besoin du <code>fsck</code> en avant plan).</p></div><div class=paragraph><p>L’avantage est que les opérations sur les méta-données sont presque aussi rapides que les mises à jour asynchrones (i.e. plus rapide qu’avec le "<em>logging</em>" - traçage, qui doit écrire les méta-données deux fois). Les inconvénients sont la complexité du code (impliquant un haut risque de bogues dans une zone qui est hautement sensible en raison de risque perte de données utilisateur), et une plus grande consommation en mémoire. De plus il y a quelques particularités que l’on peut rencontrer lors de l’utilisation. Après un crash, l’état du système apparaît être en quelque sorte "plus vieux". Dans des situations où l’approche synchrone classique aurait donné lieu à des fichiers de taille nulle restant après le <code>fsck</code>, ces fichiers n’existent pas du tout avec un système de fichiers utilisant les "Soft Updates" parce que ni les méta-données ni les contenus de fichiers n’ont jamais été inscrits sur le disque. L’espace disque n’est pas rendu tant que les mises à jour n’ont pas été inscrites sur le disque, ce qui peut se produire quelques temps après l’exécution de <code>rm</code>. Cela peut être à l’origine de problèmes quand on installe une grande quantité de données sur un système de fichiers qui ne dispose pas de suffisamment d’espace pour contenir tous les fichiers deux fois.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-kernel-limits>11.12. Optimisation des limitations du noyau<a class=anchor href=#configtuning-kernel-limits></a></h2><div class=sectionbody><div class=sect2><h3 id=file-process-limits>11.12.1. Limitations sur les fichiers et les processus<a class=anchor href=#file-process-limits></a></h3><div class=sect3><h4 id=kern-maxfiles>11.12.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h4><div class=paragraph><p>Le paramètre <code>kern.maxfiles</code> peut être augmenté ou diminué en fonction des besoins du système. Cette variable indique le nombre maximal de descripteurs de fichier sur votre système. Quand la table de descripteurs de fichier est pleine, le message <code>file: table is full</code> s’affichera régulièrement dans le tampon des messages système, qui peut être visualisé avec la commande <code>dmesg</code>.</p></div><div class=paragraph><p>Chaque fichier ouvert, chaque "socket", ou chaque emplacement en pile utilise un descripteur de fichier. Un serveur important peut facilement demander plusieurs milliers de descripteurs de fichiers, en fonction du type et du nombre de services s’exécutant en même temps.</p></div><div class=paragraph><p>Sous les anciennes versions de FreeBSD, la valeur par défaut de <code>kern.maxfile</code> est fixée par l’option <code>maxusers</code> dans votre fichier de configuration du noyau. <code>kern.maxfiles</code> augmente proportionnellement avec la valeur de <code>maxusers</code>. Quand vous compilez un noyau sur mesure, il est bon de paramétrer cette option en fonction de l’utilisation de votre système. Ce nombre fixe la plupart des limites pré-définies du noyau. Même si une machine de production pourra ne pas avoir en réalité 256 utilisateurs connectés simultanément, les ressources requises pourront être semblables pour un serveur web important.</p></div><div class=paragraph><p>La variable <code>kern.maxusers</code> est automatiquement ajustée au démarrage en fonction de la quantité de mémoire disponible dans le système, sa valeur peut être connue durant le fonctionnement du système en examinant la valeur de la variable sysctl en lecture seule: <code>kern.maxusers</code>. Certains systèmes auront besoin de valeurs plus élevées ou plus faibles pour <code>kern.maxusers</code> et pourront donc la fixer au chargement du système; des valeurs de 64, 128, ou 256 ne sont pas inhabituelles. Nous recommandons de ne pas dépasser 256 à moins que vous ayez besoin d’un grand nombre de descripteurs de fichiers; plusieurs des variables dont la valeur par défaut dépend de <code>kern.maxusers</code> peuvent être fixées individuellement au démarrage ou en fonctionnement dans le fichier <span class=filename>/boot/loader.conf</span> (voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> ou le fichier <span class=filename>/boot/defaults/loader.conf</span> pour des exemples) ou comme décrit en d’autres endroits dans ce document.</p></div><div class=paragraph><p>Sous les anciennes versions, le système auto-ajuste ce paramètre pour vous si vous le fixez explicitement à <code>0</code>. En paramétrant cette option, vous devrez fixer <code>maxusers</code> à 4 au moins, en particulier si vous utilisez le système X Window ou compilez des logiciels. La raison de cela est que la valeur la plus importante que dimensionne <code>maxusers</code> est le nombre maximal de processus, qui est fixé à <code>20 + 16 * maxusers</code>, donc si vous positionnez <code>maxusers</code> à 1, alors vous ne pouvez avoir que 36 processus en simultanés, comprenant les 18, environ, que le système lance au démarrage et les 15, à peu près, que vous créerez probablement au démarrage du système X Window. Même une tâche simple comme la lecture d’une page de manuel lancera jusqu’à neuf processus pour la filtrer, la décompresser, et l’afficher. Fixer <code>maxusers</code> à 64 autorisera jusqu’à 1044 processus simultanés, ce qui devrait suffire dans la plupart des cas. Si, toutefois, vous obtenez le message d’erreur tant redouté quand vous tentez d’exécuter un nouveau programme, ou gérez un serveur avec un grand nombre d’utilisateurs en simultanés (comme <code>ftp.FreeBSD.org</code>), vous pouvez toujours augmenter cette valeur et recompiler le noyau.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>maxusers</code> ne limite <em>pas</em> le nombre d’utilisateurs qui pourront ouvrir une session sur votre machine. Cette valeur dimensionne simplement différentes tables à des valeurs raisonnables en fonction du nombre maximal d’utilisateur que vous aurez vraisemblablement sur votre système et combien de processus chacun d’entre eux pourra utiliser.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_kern_ipc_somaxconn>11.12.1.2. <code>kern.ipc.somaxconn</code><a class=anchor href=#_kern_ipc_somaxconn></a></h4><div class=paragraph><p>La variable sysctl <code>kern.ipc.somaxconn</code> limite la taille de la file d’attente acceptant les nouvelles connexions TCP. La valeur par défaut de <code>128</code> est généralement trop faible pour une gestion robuste des nouvelles connexions dans un environnement de serveur web très chargé. Pour de tels environnements, il est recommandé d’augmenter cette valeur à <code>1024</code> ou plus. Le "daemon" en service peut de lui-même limiter la taille de la file d’attente (e.g. <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, ou Apache) mais disposera, la plupart du temps, d’une directive dans son fichier de configuration pour ajuster la taille de la file d’attente. Les files d’attentes de grandes tailles sont plus adaptées pour éviter les attaques par déni de service ().</p></div></div></div><div class=sect2><h3 id=nmbclusters>11.12.2. Limitations réseau<a class=anchor href=#nmbclusters></a></h3><div class=paragraph><p>L’literal du noyau <code>NMBCLUSTERS</code> fixe la quantité de "Mbuf";s disponibles pour le système. Un serveur à fort trafic avec un nombre faible de "Mbuf";s sous-emploiera les capacités de FreeBSD. Chaque "cluster" représente approximativement 2 Ko de mémoire, donc une valeur de 1024 représente 2 mégaoctets de mémoire noyau réservée pour les tampons réseau. Un simple calcul peut être fait pour déterminer combien sont nécessaires. Si vous avez un serveur web qui culmine à 1000 connexions simultanées, et que chaque connexion consomme un tampon de réception de 16Ko et un tampon d’émission de 16 Ko, vous avez approximativement besoin de 32 Mo de tampon réseau pour couvrir les besoin du serveur web. Un bon principe est de multiplier ce nombre par 2, soit 2x32 Mo / 2 Ko = 64 Mo / 2 Ko =32768. Nous recommandons des valeurs comprises entre 4096 et 32768 pour les machines avec des quantités de mémoire plus élevées. Vous ne devriez, dans aucun circonstance, spécifier de valeur élevée arbitraire pour ce paramètre étant donné que cela peut être à l’origine d’un plantage au démarrage. L’option <code>-m</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> peut être utilisée pour observer l’utilisation des "clusters".</p></div><div class=paragraph><p>La variable <code>kern.ipc.nmbclusters</code> configurable au niveau du chargeur est utilisée pour ajuster cela au démarrage. Seules les anciennes versions de FreeBSD vous demanderont d’utiliser l’option de configuration du noyau <code>NMBCLUSTERS</code>.</p></div><div class=paragraph><p>Pour les serveurs chargés qui font une utilisation intensive de l’appel système <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a>, il peut être nécessaire d’augmenter le nombre de tampons <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> par l’intermédiaire de l’option de configuration du noyau <code>NSFBUFS</code> ou en fixant sa valeur dans le fichier <span class=filename>/boot/loader.conf</span> (consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> pour plus de détails). Un indicateur de la nécessité d’ajuster ce paramètre est lorsque des processus sont dans l’état <code>sfbufa</code>. La variable sysctl <code>kern.ipc.nsfbufs</code> est un aperçu en lecture seule de la variable du noyau. Ce paramètre s’ajuste de façon optimale avec <code>kern.maxusers</code>, il peut être cependant nécessaire de l’ajuster en fonction des besoins.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Même si une "socket" a été marquée comme étant non-bloquante, un appel de <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> sur la "socket" non-bloquante peut résulter en un blocage de l’appel <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> jusqu’à ce que suffisamment de <code>struct sf_buf</code> soient libérées.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_net_inet_ip_portrange>11.12.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h4><div class=paragraph><p>Les variables <code>net.inet.ip.portrange.*</code> contrôlent les intervalles de ports automatiquement alloués aux "socket"s TCP et UDP. Il y a trois intervalles: un intervalle bas, un intervalle par défaut, et intervalle un haut. La plupart des programmes réseau utilisent l’intervalle par défaut qui est contrôlé par <code>net.inet.ip.portrange.first</code> et <code>net.inet.ip.portrange.last</code>, qui ont pour valeur par défaut respectivement 1024 et 5000. Ces intervalles de ports sont utilisés pour les connexions sortantes, et il est possible de se trouver à court de ports dans certaines conditions. Cela arrive le plus souvent quand votre système fait tourner un proxy web très chargé. L’intervalle de ports n’est pas un problème quand vous exécutez des serveurs qui ne gèrent principalement que des connexions entrantes, comme un server web classique, ou qui ont un nombre de connexions sortantes limitées comme un relai de messagerie. Pour les cas où vous risquez d’être à court de ports, il est recommandé d’augmenter légèrement <code>net.inet.ip.portrange.last</code>. Une valeur de <code>10000</code>, <code>20000</code> ou <code>30000</code> doit être suffisante. Vous devriez également penser au problème du coupe-feu lors du changement de l’intervalle des ports. Certains coupes-feu peuvent bloquer de grands intervalles de ports (en général les ports inférieurs) et s’attendent à ce que les systèmes utilisent les intervalles supérieurs pour les connexions sortantes - pour cette raison il n’est pas conseillé de diminuer <code>net.inet.ip.portrange.first</code>.</p></div></div><div class=sect3><h4 id=_le_produit_délai_bande_passante_tcp>11.12.2.2. Le produit délai-bande passante TCP<a class=anchor href=#_le_produit_délai_bande_passante_tcp></a></h4><div class=paragraph><p>La limitation du produit délai-bande passante TCP est semblable au TCP/Vegas sous NetBSD. Elle peut être activée en positionnant à <code>1</code> la variable <code>net.inet.tcp.inflight.enable</code>. Le système tentera alors de calculer le produit délai-bande passante pour chaque connexion et limitera la quantité de données en attente à la quantité juste nécessaire au maintient d’un flux de sortie optimal.</p></div><div class=paragraph><p>Cette fonctionnalité est utile si vous diffusez des données par l’intermédiaire de modems, de connexions Ethernet Gigabit, ou même de liaisons hauts débits WAN (ou toute autre liaison avec un produit délai-bande passante élevé), tout particulièrement si vous utilisez également le dimensionnement des fenêtres d’émission ou que vous avez configuré une fenêtre d’émission importante. Si vous activez cette option, vous devriez également vous assurer que <code>net.inet.tcp.inflight.debug</code> est positionnée à <code>0</code> (désactive le débogage), et pour une utilisation en production, fixer <code>net.inet.tcp.inflight.min</code> à au moins <code>6144</code> peut être bénéfique. Notez, cependant, que fixer des minima élevés peut désactiver la limitation de bande passante selon la liaison. La fonction de limitation diminue la quantité de données accumulées dans les files d’attente intermédiaire de routage et de commutation, et diminue également la quantité de données présentes dans les files d’attente de l’interface de la machine locale. Avec moins de paquets dans les files d’attente, les connexions interactives, tout particulièrement sur des modems lents, seront en mesure de fonctionner avec des <em>temps d’aller-retour</em> plus faible. Mais cette fonctionnalité n’affecte que la transmission de données (transmission côté serveur). Ceci n’a aucun effet sur la réception de données (téléchargement).</p></div><div class=paragraph><p>Modifier <code>net.inet.tcp.inflight.stab</code> n’est <em>pas</em> recommandé. Ce paramètre est fixé par défaut à la valeur 20, représentant au maximum 2 paquets ajoutés à la fenêtre de calcul du produit délai-bande passante. La fenêtre supplémentaire est nécessaire pour stabiliser l’algorithme et améliorer la réponse aux changements de conditions, mais il peut en résulter des temps de "ping" plus élevés sur les liaisons lentes (mais cependant inférieurs à ce que vous obtiendriez sans l’algorithme de limitation). Dans de tels cas, vous pouvez essayer de réduire ce paramètre à 15, 10, ou 5, et vous pouvez avoir à réduire le paramètre <code>net.inet.tcp.inflight.min</code> (par exemple à 3500) pour obtenir l’effet désiré. Ces paramètres ne doivent être réduits qu’en dernier ressort.</p></div></div></div><div class=sect2><h3 id=_mémoire_virtuelle>11.12.3. Mémoire virtuelle<a class=anchor href=#_mémoire_virtuelle></a></h3><div class=sect3><h4 id=_kern_maxvnodes>11.12.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h4><div class=paragraph><p>Un vnode est la représentation interne d’un fichier ou d’un répertoire. Augmenter le nombre de vnodes disponibles pour le système d’exploitation diminue les accès disque. Cela est normalement géré par le système d’exploitation et n’a pas besoin d’être modifié. Dans certains cas où les accès aux disques sont un goulot d’étranglement pour le système et que ce dernier est à cours de vnodes, ce nombre aura besoin d’être augmenté. La quantité de RAM libre et inactive sera prise en compte.</p></div><div class=paragraph><p>Pour connaître le nombre de vnodes actuellement utilisés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>Pour connaître le maximum de vnodes utilisables:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>Si l’utilisation actuelle des vnodes est proche du maximum, augmenter de 1000 <code>kern.maxvnodes</code> est probablement une bonne idée. Gardez un oeil sur le nombre <code>vfs.numvnodes</code>. S’il approche à nouveau le maximum, <code>kern.maxvnodes</code> devra être augmenté de manière plus conséquente. Une modification dans votre utilisation de la mémoire devrait être visible dans <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. Une plus grande quantité de mémoire devrait être annoncée comme active.</p></div></div></div></div></div><div class=sect1><h2 id=adding-swap-space>11.13. Ajouter de l’espace de pagination<a class=anchor href=#adding-swap-space></a></h2><div class=sectionbody><div class=paragraph><p>Peu importe comment vous l’avez pensé, parfois un système ne fonctionne pas comme prévu. Si vous trouvez que vous avez besoin de plus d’espace de pagination, il est assez simple d’en rajouter. Vous avez trois manières d’augmenter votre espace de pagination: ajouter un nouveau disque dur, activer la pagination sur NFS, et créer un fichier de pagination sur une partition existante.</p></div><div class=paragraph><p>Pour des informations sur comment chiffrer l’espace de pagination, quelles options existent pour mener à bien cette tâche et pourquoi on devrait le faire, veuillez vous référer à la <a href=../disks/#swap-encrypting>Chiffrage de l’espace de pagination</a> du Manuel.</p></div><div class=sect2><h3 id=new-drive-swap>11.13.1. Espace de pagination sur un nouveau disque dur ou une partition existante<a class=anchor href=#new-drive-swap></a></h3><div class=paragraph><p>Ajouter un nouveau disque pour l’espace de pagination donne de meilleures performances qu’utiliser une partition sur un disque existant. La configuration des partitions et des disques durs est expliquée dans la <a href=../disks/#disks-adding>Ajouter des disques</a> tandis que la <a href=../bsdinstall/#configtuning-initial>Choix du partitionnement</a> aborde l’organisation des partitions et les problèmes relatifs à la taille de la partition de l’espace de pagination.</p></div><div class=paragraph><p>Utiliser la commande <code>swapon</code> pour ajouter une partition de pagination au système. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Il est possible d’utiliser n’importe quelle partition actuellement non-montée, même si cette dernière contient des données. Utiliser <code>swapon</code> sur une partition contenant des données écrasera et effacera ces données. Assurez-vous que la partition à utiliser comme espace de pagination est bien celle prévue à cet effet avant d’exécuter <code>swapon</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour ajouter cette partition de pagination automatiquement au démarrage, ajouter une entrée au fichier <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>Consulter <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> pour plus d’explications sur les entrées du fichier <span class=filename>/etc/fstab</span>. Plus d’informations sur <code>swapon</code> sont disponibles dans <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>.</p></div></div><div class=sect2><h3 id=nfs-swap>11.13.2. Espace de pagination sur NFS<a class=anchor href=#nfs-swap></a></h3><div class=paragraph><p>L’espace de pagination sur NFS n’est recommandé que si vous n’avez pas de disque dur local sur lequel avoir l’espace de pagination; la pagination sur NFS sera limitée par la bande passante du réseau et sera un fardeau supplémentaire pour le serveur NFS.</p></div></div><div class=sect2><h3 id=create-swapfile>11.13.3. Fichiers de pagination<a class=anchor href=#create-swapfile></a></h3><div class=paragraph><p>Vous pouvez créer un fichier d’une taille spécifique pour l’utiliser comme fichier de pagination. Dans notre exemple nous utiliserons un fichier de 64MO appelé <span class=filename>/usr/swap0</span>. Vous pouvez, bien sûr, utiliser le nom de votre choix.</p></div><div class=exampleblock><div class=title>Exemple 1. Créer un fichier de pagination sous FreeBSD</div><div class=content><div class="olist arabic"><ol class=arabic><li><p>Le noyau <span class=filename>GENERIC</span> inclut déjà le pilote de disque mémoire (<a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>) nécessaire à cette opération. Lors de la compilation d’un noyau sur mesures, assurez-vous d’inclure la ligne suivante dans le fichier de configuration:</p><div class="literalblock programlisting"><div class=content><pre>device   md</pre></div></div><div class=paragraph><p>Pour plus d’information sur la compilation du noyau, veuillez vous réferer à la <a href=../kernelconfig/#kernelconfig>Configurer le noyau de FreeBSD</a>.</p></div></li><li><p>Créez un fichier de pagination (<span class=filename>/usr/swap0</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</span></code></pre></div></div></li><li><p>Fixez les bonnes permissions sur <span class=filename>/usr/swap0</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Activez le fichier de pagination dans <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>swapfile=&#34;/usr/swap0&#34;   # Set to name of swapfile if aux swapfile desired.</pre></div></div></li><li><p>Redémarrez la machine ou activez directement le fichier de pagination:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /usr/swap0 -u 0  swapon /dev/md0</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=acpi-overview>11.14. Gestion de l’énergie et des ressources<a class=anchor href=#acpi-overview></a></h2><div class=sectionbody><div class=paragraph><p>Il est important d’utiliser les ressources matérielles d’une manière efficace. Avant l’apparition de l’ACPI, il était difficile pour les systèmes d’exploitation de gérer l’utilisation de l’alimentation et la température d’un système. Le matériel était géré par le BIOS et donc l’utilisateur avait moins de contrôle et de visibilité sur le paramétrage de la gestion de l’énergie. Une configuration limitée était accessible via l'<em>Advanced Power Management (APM)</em>. La gestion de l’énergie et des ressources est un des éléments clés d’un système d’exploitation moderne. Par exemple, vous pourrez vouloir qu’un système d’exploitation surveille certaines limites (et éventuellement vous alerte), au cas où la température de votre système augmente de façon inattendue.</p></div><div class=paragraph><p>Dans cette section, nous fournirons une information complète au sujet de l’ACPI. Il sera fait référence à des documents supplémentaires en fin de section pour plus de détails.</p></div><div class=sect2><h3 id=acpi-intro>11.14.1. Qu’est-ce que l’ACPI?<a class=anchor href=#acpi-intro></a></h3><div class=paragraph><p>L'"interface de configuration et d’alimentation avancée" (ACPI, Advanced Configuration and Power Interface) est une norme créée par un ensemble de constructeurs pour fournir une interface standard à la gestion des ressources et de l’énergie. C’est un élément clé dans le contrôle et la configuration par le système d’exploitation de de la gestion d’énergie, i.e., il permet plus de contrôle et flexibilité au système d’exploitation. Les systèmes modernes ont "repoussé" les limites des interfaces "Plug and Play" antérieures à l’apparition de l’ACPI. L’ACPI est le descendant direct de l’APM (Advanced Power Management - gestion avancée de l’énergie).</p></div></div><div class=sect2><h3 id=acpi-old-spec>11.14.2. Les imperfections de la gestion avancée de l’énergie (APM)<a class=anchor href=#acpi-old-spec></a></h3><div class=paragraph><p>Le système de <em>gestion avancée de l’énergie (APM)</em> gère l’utilisation de l’énergie par un système en fonction de son activité. Le BIOS APM est fourni par le fabricant (du système) et est spécifique à la plateforme matérielle. Un pilote APM au niveau du système d’exploitation gère l’accès à l'<em>interface logicielle APM</em> qui autorise la gestion des niveaux de consommation. L’APM devrait être toujours utilisé pour les systèmes fabriqués en ou avant 2000.</p></div><div class=paragraph><p>L’APM présente quatre problèmes majeurs. Tout d’abord la gestion de l’énergie est effectuée par le BIOS (spécifique au constructeur), et le système d’exploitation n’en a aucune connaissance. Un exemple de ce problème, est lorsque l’utilisateur fixe des valeurs pour le temps d’inactivité d’un disque dur dans le BIOS APM, qui une fois dépassé, provoque l’arrêt du disque (par le BIOS) sans le consentement du système d’exploitation. Deuxièmement, la logique de l’APM est interne au BIOS, et agit indépendamment du système d’exploitation. Cela signifie que les utilisateurs ne peuvent corriger les problèmes de leur BIOS APM qu’en flashant un nouveau BIOS; c’est une opération dangereuse, qui si elle échoue peut laisser le système dans un état irrécupérable. Troisièmement, l’APM est une technologie spécifique au constructeur, ce qui veut dire qu’il y a beaucoup de redondances (duplication des efforts) et de bogues qui peuvent être trouvées dans le BIOS d’un constructeur, et qui peuvent ne pas être corrigées dans d’autres BIOS. Et pour terminer, le dernier problème est le fait que le BIOS APM n’a pas suffisamment d’espace pour implémenter une politique sophistiquée de gestion de l’énergie, ou une politique qui peut s’adapter parfaitement aux besoins de la machine.</p></div><div class=paragraph><p>Le <em>BIOS Plug and Play (PNPBIOS)</em> n’était pas fiable dans de nombreuses situations. Le PNPBIOS est une technologie 16 bits, le système d’exploitation doit utiliser une émulation 16 bits afin de faire l'"interface" avec les méthodes PNPBIOS.</p></div><div class=paragraph><p>Le pilote APM FreeBSD est documenté dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a>.</p></div></div><div class=sect2><h3 id=acpi-config>11.14.3. Configurer l’ACPI<a class=anchor href=#acpi-config></a></h3><div class=paragraph><p>Le pilote <span class=filename>acpi.ko</span> est par défaut chargé par le <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> au démarrage et ne devrait <em>pas</em> être compilé dans le noyau. La raison derrière cela est que les modules sont plus facile à manipuler, par exemple pour passer à une autre version du module <span class=filename>acpi.ko</span> sans avoir à recompiler le noyau. Cela présente l’avantage de rendre les tests aisés. Une autre raison est que lancer l’ACPI après qu’un système ait terminé son lancement donne souvent lieu à des dysfonctionnements. Si des problèmes surviennent, vous pouvez désactiver l’ACPI. Ce pilote ne devrait et ne peut être déchargé car le bus système l’utilise pour différentes intéraction avec le matériel. L’ACPI peut être déactivé en ajoutant <code>hint.acpi.0.disabled="1"</code> dans le fichier <span class=filename>/boot/loader.conf</span> ou directement à l’invite du chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’ACPI et l’APM ne peuvent coexister et devraient être utilisé séparément. Le dernier chargé s’arrêtera s’il détecte l’autre en fonctionnement.</p></div></td></tr></tbody></table></div><div class=paragraph><p>L’ACPI peut être utilisé pour mettre en veille un système avec <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a>, les options <code>-s</code> et <code>1-5</code>. La plupart des utilisateurs n’auront besoin que de <code>1</code> ou <code>3</code> (système suspendu en RAM). L’option <code>5</code> provoquera un arrêt de l’alimentation par logiciel, effet identique à un:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># halt -p</span></code></pre></div></div><div class=paragraph><p>D’autres options sont disponibles via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Consultez les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> pour plus d’informations.</p></div></div></div></div><div class=sect1><h2 id=ACPI-debug>11.15. Utiliser et déboguer l’ACPI sous FreeBSD<a class=anchor href=#ACPI-debug></a></h2><div class=sectionbody><div class=paragraph><p>L’ACPI est une nouvelle méthode de recherche des périphériques, de gestion de l’énergie, et fourni un accès standardisé à différents matériels gérés auparavant par le BIOS. Des progrès ont été fait vers un fonctionnement de l’ACPI sur tous les systèmes, mais des bogues dans le "bytecode" du <em>langage machine ACPI</em> (<em>ACPI Machine Language</em>-AML), des imperfections dans les sous-systèmes du noyau FreeBSD, et des bogues dans l’interpréteur ACPI-CA d’Intel® continuent d’apparaître.</p></div><div class=paragraph><p>Ce document est destiné à vous permettre d’aider les développeurs du système ACPI sous FreeBSD à identifier la cause originelle des problèmes que vous observez et à déboguer et développer une solution. Merci de lire ce document et nous espérons pouvoir résoudre les problèmes de votre système.</p></div><div class=sect2><h3 id=ACPI-submitdebug>11.15.1. Soumettre des informations de débogage<a class=anchor href=#ACPI-submitdebug></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Avant de soumettre un problème, assurez-vous d’utiliser la dernière version de votre BIOS, et si elle est disponible, la dernière version du firmware du contrôleur utilisé.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour ceux désirant soumettre directement un problème, veuillez faire parvenir les informations suivantes à la liste <a href=mailto:freebsd-acpi@FreeBSD.org>freebsd-acpi@FreeBSD.org</a>:</p></div><div class=ulist><ul><li><p>Description du comportement défectueux, en ajoutant le type et le modèle du système et tout ce qui peut causer l’apparition du bogue. Notez également le plus précisément possible quand le bogue a commencé à se manifester s’il est nouveau.</p></li><li><p>La sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> après un <code>boot -v</code>, y compris tout message généré lors de la manifestation du bogue.</p></li><li><p>La sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> après un <code>boot -v</code> avec l’ACPI désactivé, si cette désactivation corrige le problème.</p></li><li><p>La sortie de <code>sysctl hw.acpi</code>. C’est également un bon moyen de déterminer quelles fonctionnalités sont offertes par votre système.</p></li><li><p>Une URL où peut être trouvé votre <em>code source ACPI</em> (ACPI Source Language-ASL). N’envoyez pas directement l’ASL sur la liste de diffusion, ce fichier peut être très gros. Vous pouvez générer une copie de votre ASL en exécutant la commande suivante:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>(Remplacez <em>name</em> par votre nom d’utilisateur et <em>system</em> par celui du constructeur/modèle. Par exemple: <span class=filename>njl-FooCo6000.asl</span>)</p></div></li></ul></div><div class=paragraph><p>La plupart des développeurs lisent la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a> mais soumettez également les problèmes rencontrés à la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a> afin d’être sûr qu’ils seront vus. Soyez patient, nous avons tous un travail à plein temps qui nous attend ailleurs. Si votre bogue n’est pas immédiatement apparent, nous vous demanderons probablement de soumettre un PR par l’intermédiaire de <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. Quand vous remplirez un PR, veillez à inclure les mêmes informations que celles précisées précédemment. Cela nous aidera à cerner et à résoudre le problème. N’envoyez pas de PR sans avoir contacté auparavant la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a> étant donné que nous utilisons les PRs comme pense-bêtes de problèmes existants, et non pas comme mécanisme de rapport. Il se peut que votre problème puisse avoir déjà été signalé par quelqu’un d’autre.</p></div></div><div class=sect2><h3 id=ACPI-background>11.15.2. Information de fond<a class=anchor href=#ACPI-background></a></h3><div class=paragraph><p>L’ACPI est présent sur tous les ordinateurs modernes compatibles avec l’une des architectures ia32 (x86), ia64 (Itanium), et amd64 (AMD). La norme complète définit des fonctionnalités comme la gestion des performances du CPU, des contrôles des niveaux d’énergie, des zones de températures, divers systèmes d’utilisation des batteries, des contrôleurs intégrés, et l’énumération du bus. La plupart des systèmes n’implémentent pas l’intégralité des fonctionnalités de la norme. Par exemple, un ordinateur de bureau n’implémentera généralement que la partie énumération de bus alors qu’un ordinateur portable aura également le support de la gestion du refroidissement et de la batterie. Les ordinateurs portables disposent également des modes de mise en veille et de réveil, avec toute la complexité qui en découle.</p></div><div class=paragraph><p>Un système compatible ACPI dispose de divers composants. Les fabricants de BIOS et de circuits fournissent des tables de description (FADT) fixes en mémoire qui définissent des choses comme la table APIC (utilisée par les systèmes SMP), les registres de configuration, et des valeurs de configuration simples. De plus, est fournie une table de "bytecode" (la <em>table différenciée de description du système-Differentiated System Description Table</em> DSDT) qui spécifie sous forme d’une arborescence l’espace des noms des périphériques et des méthodes.</p></div><div class=paragraph><p>Le pilote ACPI doit analyser les tables, implémenter un interpréteur pour le "bytecode", et modifier les pilotes de périphériques et le noyau pour qu’ils acceptent des informations en provenance du sous-système ACPI. Pour FreeBSD, Intel® fourni un interpréteur (ACPI-CA) qui est partagé avec Linux et NetBSD. L’emplacement du code source de l’interpréteur ACPI-CA est <span class=filename>src/sys/contrib/dev/acpica</span>. Le code "glu" permettant à ACPI-CA de fonctionner sous FreeBSD se trouve dans <span class=filename>src/sys/dev/acpica/Osd</span>. Et enfin, les pilotes qui gèrent les différents périphériques ACPI se trouvent dans <span class=filename>src/sys/dev/acpica</span>.</p></div></div><div class=sect2><h3 id=ACPI-comprob>11.15.3. Problèmes courants<a class=anchor href=#ACPI-comprob></a></h3><div class=paragraph><p>Pour un fonctionnement correct de l’ACPI, il faut que toutes les parties fonctionnent correctement. Voici quelques problèmes courants, par ordre de fréquence d’apparition, et quelques contournements ou corrections possibles.</p></div><div class=sect3><h4 id=_problèmes_avec_la_souris>11.15.3.1. Problèmes avec la souris<a class=anchor href=#_problèmes_avec_la_souris></a></h4><div class=paragraph><p>Dans certains cas le réveil après une mise en veille sera à l’origine d’un dysfonctionnement de la souris. Une solution connue est d’ajouter la ligne <code>hint.psm.0.flags="0x3000"</code> au fichier <span class=filename>/boot/loader.conf</span>. Si cela ne fonctionne pas, pensez à envoyer un rapport de bogue comme décrit plus haut.</p></div></div><div class=sect3><h4 id=_mise_en_veilleréveil>11.15.3.2. Mise en veille/réveil<a class=anchor href=#_mise_en_veilleréveil></a></h4><div class=paragraph><p>L’ACPI dispose de trois modes de mise en veille en RAM (STR-Suspend To RAM), <code>S1</code> à <code>S3</code>, et un mode de mise en veille vers le disque dur (<code>STD</code>-Suspend To Disk), appelé <code>S4</code>. Le mode <code>S5</code> est un arrêt "soft" et est le mode dans lequel se trouve votre système quand il est branché mais pas allumé. Le mode <code>S4</code> peut être implémenté de deux manières différentes. Le mode <code>S4</code>BIOS est une mise en veille vers le disque assistée par le BIOS. Le mode <code>S4</code>OS est implémenté intégralement par le système d’exploitation.</p></div><div class=paragraph><p>Commencez par examiner la sortie de <code>sysctl hw.acpi</code> à la recherche d’éléments concernant les modes de mise en veille. Voici les résultats pour un Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Cela signifie que nous pouvons utiliser <code>acpiconf -s</code> pour tester les modes <code>S3</code>, <code>S4</code>OS, et <code>S5</code>. Si <code>s4bios</code> était égal à <code>1</code>, nous disposerions d’un support <code>S4</code>BIOS à la place de <code>S4</code>OS.</p></div><div class=paragraph><p>Quand vous testez la mise en veille et le réveil, commencez avec le mode <code>S1</code>, pour voir s’il est supporté. Ce mode doit fonctionner dans la plupart des cas puisqu’il nécessite peu de support. Le mode <code>S2</code> n’est pas implémenté, mais si vous en disposez, il est similaire au mode <code>S1</code>. La chose suivante à essayer est le mode <code>S3</code>. C’est le mode STR le plus avancé et il nécessite un support du pilote important pour réinitialiser correctement votre matériel. Si vous avez des problèmes au réveil de la machine, n’hésitez pas à contacter la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a> mais ne vous attendez pas à ce que le problème soit résolu puisqu’il y a de nombreux pilotes/matériels qui nécessitent plus de tests et de développement.</p></div><div class=paragraph><p>Un problème courant avec la mise en veille/le réveil est que de nombreux pilotes de périphériques ne sauvegardent pas, ne restaurent pas, ou ne réinitialisent pas leurs logiciel, registres ou mémoire proprement. En premier lieu pour débogguer le problème, essayez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>Ce test émule le cycle de mise en veille/réveil de tous les pilotes de périphériques sans réellement passer dans l’état <code>S3</code>. Dans certains cas, les problèmes comme la perte de l’état du périphérique, le dépassement du délai du chien de garde du périphérique, les tentatives répétées, peuvent être capturés avec cette méthode. Notez que le système n’entrera pas vraiment dans l’état <code>S3</code>, ce qui signifie que les périphériques peuvent ne pas perdre leur alimentation, et nombreux fonctionneront correctement même si les méthodes de mise en veille/réveil sont totalement absentes, contrairement au cas d’un véritable état <code>S3</code>.</p></div><div class=paragraph><p>Les cas plus difficiles nécessitent un matériel supplémentaire, tel qu’un port série et un câble pour débogguer à l’aide d’une console série, un port firewire et un câble pour l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>, et des compétences en debogguage du noyau.</p></div><div class=paragraph><p>Pour isoler le problème, retirez du noyau tous les pilotes de périphériques possibles. Si cela fonctionne, vous pouvez alors identifier le pilote fautif en chargeant les pilotes un à un jusqu’à l’apparition du problème. Généralement les pilotes binaires comme <span class=filename>nvidia.ko</span>, les pilotes d’affichage X11, ou les pilotes USB seront victimes de la plupart des problèmes tandis que ceux concernant les interfaces Ethernet fonctionneront normalement. Si vous pouvez charger/décharger les pilotes de périphériques correctement, vous pouvez automatiser cela en ajoutant les commandes appropriées dans les fichiers <span class=filename>/etc/rc.suspend</span> et <span class=filename>/etc/rc.resume</span>. Il y a un exemple en commentaire pour décharger ou charger un pilote. Essayez de fixer <code>hw.acpi.reset_video</code> à zéro (<code>0</code>) si votre affichage est corrompu après un réveil de la machine. Essayez des valeurs plus grandes ou plus faibles pour <code>hw.acpi.sleep_delay</code> pour voir si cela aide.</p></div><div class=paragraph><p>Une autre méthode est d’essayer de charger une distribution Linux récente avec le support ACPI et tester la mise en veille et le réveil sur le même matériel. Si cela fonctionne sous Linux, c’est probablement donc un problème de pilotes FreeBSD et déterminer quel pilote est responsable des dysfonctionnements nous aidera à corriger le problème. Notez que les personnes qui maintiennent l’ACPI sous FreeBSD ne s’occupe pas généralement des autres pilotes de périphériques (comme le son, le système ATA, etc.), aussi tout rapport concernant un problème de pilote devrait probablement en fin de compte être posté sur la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a> et communiqué au responsable du pilote. Si vous vous sentez une âme d’aventurier, commencez à ajouter des <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>s de débogage dans un pilote problématique pour déterminer à quel moment dans sa fonction de réveil il se bloque.</p></div><div class=paragraph><p>Enfin, essayez de désactiver l’ACPI et d’activer l’APM à la place, pour voir si la mise en veille et le réveil fonctionnent avec l’APM, tout particulièrement dans le cas de matériel ancien (antérieur à 2000). Cela prend du temps aux constructeurs de mettre en place le support ACPI et le matériel ancien aura sûrement des problèmes de BIOS avec l’ACPI.</p></div></div><div class=sect3><h4 id=_blocages_du_système_temporaires_ou_permanents>11.15.3.3. Blocages du système (temporaires ou permanents)<a class=anchor href=#_blocages_du_système_temporaires_ou_permanents></a></h4><div class=paragraph><p>La plupart des blocages système sont le résultat d’une perte d’interruptions ou d’une tempête d’interruptions. Les circuits ont beaucoup de problèmes en fonction de la manière dont le BIOS configure les interruptions avant le démarrage, l’exactitude de la table APIC (MADT), et le routage du <em>System Control Interrupt</em> (SCI).</p></div><div class=paragraph><p>Les tempêtes d’interruptions peuvent être distinguées des pertes d’interruptions en contrôlant la sortie de la commande <code>vmstat -i</code> en examinant la ligne mentionnant <code>acpi0</code>. Si le compteur s’incrémente plusieurs fois par seconde, vous êtes victime d’une tempête d’interruptions. Si le système semble bloqué, essayez de basculer sous DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> sous la console) et tapez <code>show interrupts</code>.</p></div><div class=paragraph><p>Votre plus grand espoir quand vous faites face à des problèmes d’interruptions est d’essayer de désactiver le support APIC avec la ligne <code>hint.apic.0.disabled="1"</code> dans le fichier <span class=filename>loader.conf</span>.</p></div></div><div class=sect3><h4 id=_paniques>11.15.3.4. Paniques<a class=anchor href=#_paniques></a></h4><div class=paragraph><p>Les paniques sont relativement rares dans le cas de l’ACPI et sont au sommet des priorités en matière de problèmes à corriger. Le premier point est d’isoler les étapes nécessaires à la reproduction de la panique (si possible) et d’obtenir une trace de débogage. Suivez l’aide sur l’activation de <code>options DDB</code> et la configuration d’une console série (lire la <a href=../serialcomms/#serialconsole-ddb>Entering the DDB Debugger from the Serial Line</a>) ou la configuration d’une partition <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>. Vous pouvez obtenir une trace de débogage sous DDB avec la commande <code>tr</code>. Si vous devez recopier à la main la trace de débogage, assurez-vous de relever les cinq dernières lignes et les cinq premières ligne de la trace.</p></div><div class=paragraph><p>Ensuite essayez d’isoler le problème en démarrant avec l’ACPI désactivé. Si cela fonctionne, vous pouvez isoler le sous-système ACPI en utilisant différentes valeurs pour l’option <code>debug.acpi.disable</code>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> pour des exemples.</p></div></div><div class=sect3><h4 id=_le_système_redémarre_après_une_mise_en_veille_ou_un_arrêt>11.15.3.5. Le système redémarre après une mise en veille ou un arrêt<a class=anchor href=#_le_système_redémarre_après_une_mise_en_veille_ou_un_arrêt></a></h4><div class=paragraph><p>Tout d’abord, essayez de fixer <code>hw.acpi.disable_on_poweroff="0"</code> dans <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>. Cela empêche l’ACPI de désactiver divers événements lors du processus d’arrêt. Certains systèmes ont besoin d’avoir cette valeur fixée à <code>1</code> (valeur par défaut) pour la même raison. Cela corrige généralement le problème d’un système démarrant spontanément après une mise en veille ou un arrêt.</p></div></div><div class=sect3><h4 id=_autres_problèmes>11.15.3.6. Autres problèmes<a class=anchor href=#_autres_problèmes></a></h4><div class=paragraph><p>Si vous rencontrez d’autres problèmes avec l’ACPI (impossible de travailler avec une station d’amarrage, périphériques non détectés, etc.), veuillez envoyer un courrier descriptif à la liste de diffusion; cependant, certains de ces problèmes peuvent être relatifs à des partie incomplètes du sous-système ACPI et qui pourront prendre du temps à être implémentées. Soyez patient et prêt à tester les correctifs que nous pourront éventuellement vous envoyer.</p></div></div></div><div class=sect2><h3 id=ACPI-aslanddump>11.15.4. ASL, <code>acpidump</code>, et IASL<a class=anchor href=#ACPI-aslanddump></a></h3><div class=paragraph><p>Le problème le plus courant est le fait que les constructeurs fournissent des "bytecodes" erronés (ou plus simplement bogués!). Cela se manifeste généralement sur la console par des messages du noyau du type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>La plupart du temps vous pouvez corriger ces problèmes en mettant à jour votre BIOS avec la dernière version disponible. La majorité des messages sur la console sont inoffensifs mais si vous avez d’autres problèmes comme l’état de la batterie qui ne fonctionne pas, ce sont de bonnes raisons pour commencer à jeter un oeil à ces problèmes dans l’AML. Le "bytecode", connu sous le nom d’AML, est compilé à partir d’un langage source appelé ASL. L’AML se trouve dans une table appelée DSDT. Pour obtenir une copie de votre ASL, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>. Vous devriez utiliser de paire les options <code>-t</code> (qui affiche le contenu des tables fixes) et <code>-d</code> (qui désassemble l’AML en ASL). Consultez la section <a href=#ACPI-submitdebug>Soumettre des informations de déboguage</a> pour un exemple de syntaxe.</p></div><div class=paragraph><p>Le tout premier test que vous pouvez effectuer est de recompiler votre ASL à la recherche d’erreurs. Les avertissements peuvent être généralement ignorés mais les erreurs sont des bogues qui normalement empêchent l’ACPI de fonctionner correctement. Pour recompiler votre ASL, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div></div><div class=sect2><h3 id=ACPI-fixasl>11.15.5. Correction de votre ASL<a class=anchor href=#ACPI-fixasl></a></h3><div class=paragraph><p>A long terme, notre objectif est que tout le monde puisse avoir un système ACPI fonctionnant sans aucune intervention de l’utilisateur. Actuellement, nous sommes toujours en train de développer des solutions pour contourner les erreurs courantes faites par les fabricants de BIOS. L’interpréteur de Microsoft® (<span class=filename>acpi.sys</span> et <span class=filename>acpiec.sys</span>) ne contrôle pas de façon stricte la conformité avec la norme, et par conséquent de nombreux fabricants de BIOS qui testent l’ACPI uniquement sous Windows® ne corrigent donc jamais leur ASL. Nous espérons poursuivre à identifier et documenter avec exactitude les comportements non-standards autorisés par l’interpréteur de Microsoft® et les reproduire de manière à permettre à FreeBSD de fonctionner sans obliger les utilisateurs à corriger leur ASL. Comme solution et pour nous aider à identifier ces comportements, vous pouvez corriger manuellement votre ASL. Si cela fonctionne pour vous, veuillez nous envoyer un <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> de l’ancien et du nouveau ASL de façon à ce que nous puissions corriger le comportement incorrect dans ACPI-CA et rendre donc inutile à l’avenir votre correctif.</p></div><div class=paragraph><p>Voici une liste des messages d’erreur courants, leur cause, et comment les corriger:</p></div><div class=sect3><h4 id=_dépendances_os>11.15.5.1. Dépendances _OS<a class=anchor href=#_dépendances_os></a></h4><div class=paragraph><p>Certains AMLs supposent que le monde n’est fait de que différentes versions de Windows®. Vous pouvez demander à FreeBSD de s’annoncer comme étant n’importe quel système d’exploitation pour voir si cela corrige les problèmes que vous pouvez rencontrer. Une manière simple de faire cela est de fixer la variable <code>hw.acpi.osname="Windows 2001"</code> dans <span class=filename>/boot/loader.conf</span> ou avec une autre chaîne de caractères que vous trouvez dans l’ASL.</p></div></div><div class=sect3><h4 id=_missing_return_statements>11.15.5.2. <code>Missing Return statements</code><a class=anchor href=#_missing_return_statements></a></h4><div class=paragraph><p>Certaines méthodes ne renvoient pas explicitement une valeur comme la norme le demande. Bien qu’ACPI-CA ne gère pas cela, FreeBSD contourne ce problème en renvoyant implicitement la valeur. Vous pouvez également ajouter des "Return statements" explicites où cela est nécessaire si vous connaissez la valeur à renvoyer. Pour forcer <code>iasl</code> à compiler l’ASL, utilisez l’option <code>-f</code>.</p></div></div><div class=sect3><h4 id=_remplacer_laml_par_défaut>11.15.5.3. Remplacer l’AML par défaut<a class=anchor href=#_remplacer_laml_par_défaut></a></h4><div class=paragraph><p>Après avoir personnalisé <span class=filename>votre.asl</span>, vous voudrez le compiler, pour cela exécutez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div><div class=paragraph><p>Vous pouvez ajouter l’option <code>-f</code> pour forcer la création de l’AML, même s’il y a des erreurs lors de la compilation. Rappelez-vous que certaines erreurs (e.g., <code>missing Return statements</code>) sont automatiquement contournées par l’interpréteur.</p></div><div class=paragraph><p><span class=filename>DSDT.aml</span> est le fichier de sortie par défaut pour <code>iasl</code>. Vous pouvez le charger à la place de la version boguée de votre BIOS (qui est toujours présent dans la mémoire flash) en éditant le fichier <span class=filename>/boot/loader.conf</span> comme suit:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Assurez-vous de bien copier votre fichier <span class=filename>DSDT.aml</span> dans le répertoire <span class=filename>/boot</span>.</p></div></div></div><div class=sect2><h3 id=ACPI-debugoutput>11.15.6. Obtenir d’ACPI une sortie de débogage<a class=anchor href=#ACPI-debugoutput></a></h3><div class=paragraph><p>Le pilote ACPI dispose d’une fonction de débogage très flexible. Elle vous permet de spécifier un ensemble de sous-systèmes ainsi que le niveau de verbosité. Les sous-systèmes que vous désirez déboguer sont indiqués sous la forme de "couches" et sont divisés en composants ACPI-CA (ACPI_ALL_COMPONENTS) et en supports matériel ACPI (ACPI_ALL_DRIVERS). La verbosité de la sortie de débogage est spécifiée par un "niveau" et des intervalles de ACPI_LV_ERROR (rapporte juste les erreurs) à ACPI_LV_VERBOSE (tout). Le "niveau" est un masque de bits séparés par des espaces, aussi de nombreuses options peuvent être fixées à la fois. Dans la pratique, vous voudrez utiliser un console série pour afficher la sortie si les informations de débogage sont si importantes qu’elles dépassent le tampon des messages de la console. Une liste complète des couches individuelles et des niveaux peut être trouvée dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div><div class=paragraph><p>L’affichage des informations de débogage n’est pas activé par défaut. Pour l’activer, ajoutez la ligne <code>options ACPI_DEBUG</code> à votre fichier de configuration du noyau si l’ACPI est compilé dans le noyau. Vous pouvez ajouter la ligne <code>ACPI_DEBUG=1</code> à votre fichier <span class=filename>/etc/make.conf</span> pour l’activer de façon globale. Si l’ACPI est sous forme de module, vous pouvez recompiler votre module <span class=filename>acpi.ko</span> comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi</span>
<span class=o>&amp;&amp;</span> make clean <span class=o>&amp;&amp;</span>
make <span class=nv>ACPI_DEBUG</span><span class=o>=</span>1</code></pre></div></div><div class=paragraph><p>Installez <span class=filename>acpi.ko</span> dans le répertoire <span class=filename>/boot/kernel</span> et indiquez le niveau et la couche désirée dans <span class=filename>loader.conf</span>. L’exemple suivant active les messages de débogage pour tous les composants ACPI-CA et tous les pilotes de matériel ACPI (CPU, LID, etc.). Il n’affichera que les messages d’erreur, c’est le niveau le moins verbeux.</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>Si l’information que vous voulez est déclenchée par un événement particulier (disons par exemple une mise en veille suivi d’un réveil), vous pouvez abandonner les modifications dans <span class=filename>loader.conf</span> et utiliser à la place <code>sysctl</code> pour indiquer la couche et le niveau après le démarrage et préparer votre système pour cet événement particulier. Les variables <code>sysctl</code> sont appelées de la même manière que dans le fichier <span class=filename>loader.conf</span>.</p></div></div><div class=sect2><h3 id=ACPI-References>11.15.7. Références<a class=anchor href=#ACPI-References></a></h3><div class=paragraph><p>Plus d’information au sujet de l’ACPI peut être trouvé aux emplacements suivants:</p></div><div class=ulist><ul><li><p>La liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a></p></li><li><p>Les archives de la liste de diffusion ACPI <a href=http://lists.freebsd.org/pipermail/freebsd-acpi/>http://lists.freebsd.org/pipermail/freebsd-acpi/</a></p></li><li><p>Les archives de l’ancienne liste de diffusion ACPI <a href=http://home.jp.FreeBSD.org/mail-list/acpi-jp/>http://home.jp.FreeBSD.org/mail-list/acpi-jp/</a></p></li><li><p>La <a href=https://uefi.org/specifications#ACPI>spécification ACPI</a></p></li><li><p>Les pages de manuel: <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li><li><p><a href=http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt>Ressource sur le débogage de la DSDT</a>. (Utilise un exemple basé sur du matériel Compaq mais qui est en général intéressant.)</p></li></ul></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9 mars 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/fr/books/handbook/partiii class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/fr/books/handbook/boot class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Synopsis</a></li><li><a href=#configtuning-core-configuration>11.2. Configuration principale</a></li><li><a href=#configtuning-appconfig>11.3. Configuration des applications</a></li><li><a href=#configtuning-starting-services>11.4. Démarrer des services</a></li><li><a href=#configtuning-cron>11.5. Configuration de l’utilitaire <code>cron</code></a></li><li><a href=#configtuning-rcd>11.6. Utilisation du système rc(8) sous FreeBSD</a></li><li><a href=#config-network-setup>11.7. Configuration des cartes réseaux</a></li><li><a href=#configtuning-virtual-hosts>11.8. Hôtes virtuels</a></li><li><a href=#configtuning-configfiles>11.9. Fichiers de configuration</a></li><li><a href=#configtuning-sysctl>11.10. Optimisation avec sysctl(8)</a></li><li><a href=#configtuning-disk>11.11. Optimiser les disques</a></li><li><a href=#configtuning-kernel-limits>11.12. Optimisation des limitations du noyau</a></li><li><a href=#adding-swap-space>11.13. Ajouter de l’espace de pagination</a></li><li><a href=#acpi-overview>11.14. Gestion de l’énergie et des ressources</a></li><li><a href=#ACPI-debug>11.15. Utiliser et déboguer l’ACPI sous FreeBSD</a></li></ul></nav><hr><div class=resources><h3>Ressources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Téléchargement en PDF"></i><a href=https://download.freebsd.org/doc/fr/books/handbook/handbook_fr.pdf>Téléchargement en PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Éditer cette page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/fr/_index target=_blank>Éditer cette page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/fr/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>French</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Clair</option><option value=theme-dark>Sombre</option><option value=theme-high-contrast>Contraste élevé</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/fr class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/fr/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>