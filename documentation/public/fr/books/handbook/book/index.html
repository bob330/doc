<!doctype html><html class=theme-light lang=fr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/fr/books/handbook/book/><title>Manuel FreeBSD | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Manuel FreeBSD"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="fr"><meta property="og:url" content="http://172.16.201.134:1313/fr/books/handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/fr\/books\/handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/fr>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/fr/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/fr/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/fr/books>Books</a></li><li><a href=http://172.16.201.134:1313/fr/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/fr/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=fr>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>Manuel FreeBSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2022 Groupe de Documentation FreeBSD</div><div class=legalnotice><a id=trademarks></a><details><summary>Marques déposées</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390, and ThinkPad are trademarks of International Business Machines Corporation in the United States, other countries, or both.</p><p>IEEE, POSIX, and 802 are registered trademarks of Institute of Electrical and Electronics Engineers, Inc. in the United States.</p><p>Red Hat, RPM, are trademarks or registered trademarks of Red Hat, Inc. in the United States and other countries.</p><p>3Com and HomeConnect are registered trademarks of 3Com Corporation.</p><p>Adobe, Acrobat, Acrobat Reader, Flash and PostScript are either registered trademarks or trademarks of Adobe Systems Incorporated in the United States and/or other countries.</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. and other countries.</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, and Xeon are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.</p><p>Linux is a registered trademark of Linus Torvalds.</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries.</p><p>Motif, OSF/1, and UNIX are registered trademarks and IT DialTone and The Open Group are trademarks of The Open Group in the United States and other countries.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS and VirtualBox are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.</p><p>RealNetworks, RealPlayer, and RealAudio are the registered trademarks of RealNetworks, Inc.</p><p>Oracle is a registered trademark of Oracle Corporation.</p><p>3ware is a registered trademark of 3ware Inc.</p><p>ARM is a registered trademark of ARM Limited.</p><p>Adaptec is a registered trademark of Adaptec, Inc.</p><p>Android is a trademark of Google Inc.</p><p>Heidelberg, Helvetica, Palatino, and Times Roman are either registered trademarks or trademarks of Heidelberger Druckmaschinen AG in the U.S. and other countries.</p><p>Intuit and Quicken are registered trademarks and/or registered service marks of Intuit Inc., or one of its subsidiaries, in the United States and other countries.</p><p>LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID and Mylex are trademarks or registered trademarks of LSI Logic Corp.</p><p>MATLAB is a registered trademark of The MathWorks, Inc.</p><p>SpeedTouch is a trademark of Thomson.</p><p>VMware is a trademark of VMware, Inc.</p><p>Mathematica is a registered trademark of Wolfram Research, Inc.</p><p>Ogg Vorbis and Xiph.Org are trademarks of Xiph.Org.</p><p>XFree86 is a trademark of The XFree86 Project, Inc.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Préface</a><ul><li><a href=#preface-audience>Public visé</a></li><li><a href=#preface-changes-from2>Modifications depuis la Seconde Edition</a></li><li><a href=#preface-changes>Modifications depuis la Première Edition</a></li><li><a href=#preface-overview>Organisation de cet ouvrage</a></li><li><a href=#preface-conv>Conventions utilisées dans ce livre</a></li><li><a href=#preface-acknowledgements>Remerciements</a></li></ul></li><li><a href=#getting-started>Partie I: Pour commencer</a><ul><li><a href=#introduction>Chapitre 1. Introduction</a></li><li><a href=#bsdinstall>Chapitre 2. Installing FreeBSD</a></li><li><a href=#basics>Chapitre 3. Quelques bases d’UNIX</a></li><li><a href=#ports>Chapitre 4. Installer des applications: les logiciels pré-compilés et les logiciels portés</a></li><li><a href=#x11>Chapitre 5. Le système X Window</a></li></ul></li><li><a href=#common-tasks>Partie II: Tâches courantes</a><ul><li><a href=#desktop>Chapitre 6. Bureautique</a></li><li><a href=#multimedia>Chapitre 7. Multimédia</a></li><li><a href=#kernelconfig>Chapitre 8. Configurer le noyau de FreeBSD</a></li><li><a href=#printing>Chapitre 9. Imprimer</a></li><li><a href=#linuxemu>Chapitre 10. Compatibilité binaire avec Linux</a></li><li><a href=#wine>Chapitre 11. WINE</a></li></ul></li><li><a href=#system-administration>Partie III: Administration Système</a><ul><li><a href=#config-tuning>Chapitre 12. Configuration et optimisation</a></li><li><a href=#boot>Chapitre 13. Processus de démarrage de FreeBSD</a></li><li><a href=#users>Chapitre 14. Gestion des comptes et des utilisateurs</a></li><li><a href=#security>Chapitre 15. Sécurité</a></li><li><a href=#jails>Chapitre 16. Jails</a></li><li><a href=#mac>Chapitre 17. Mandatory Access Control <strong>Traduction en Cours</strong></a></li><li><a href=#audit>Chapitre 18. Audit des événements relatifs à la sécurité du système</a></li><li><a href=#disks>Chapitre 19. Stockage des données</a></li><li><a href=#geom>Chapitre 20. GEOM: architecture modulaire de gestion des disques</a></li><li><a href=#zfs>Chapitre 21. The Z File System (ZFS) <strong>Traduction en Cours</strong></a></li><li><a href=#filesystems>Chapitre 22. Autres systèmes de fichiers</a></li><li><a href=#vinum-vinum>Chapitre 23. Le gestionnaire de volume Vinum</a></li><li><a href=#virtualization>Chapitre 24. Virtualisation</a></li><li><a href=#l10n>Chapitre 25. Localisation - Utilisation et configuration de l’I18N/L10N</a></li><li><a href=#updating-upgrading>Chapitre 26. Mise à jour de FreeBSD</a></li><li><a href=#dtrace>Chapitre 27. DTrace</a></li></ul></li><li><a href=#network-communication>Partie IV: Réseau</a><ul><li><a href=#serialcomms>Chapitre 28. Serial Communications <strong>Traduction en Cours</strong></a></li><li><a href=#ppp-and-slip>Chapitre 29. PPP et SLIP</a></li><li><a href=#mail>Chapitre 30. Courrier électronique</a></li><li><a href=#network-servers>Chapitre 31. Serveurs réseau</a></li><li><a href=#firewalls>Chapitre 32. Firewalls <strong>Traduction en Cours</strong></a></li><li><a href=#advanced-networking>Chapitre 33. Administration réseau avancée</a></li></ul></li><li><a href=#appendices>Partie V: Annexes</a><ul><li><a href=#mirrors>Annexe A: Se procurer FreeBSD</a></li><li><a href=#bibliography>Annexe B: Bibliographie</a></li><li><a href=#eresources>Annexe C: Ressources sur Internet</a></li><li><a href=#pgpkeys>Annexe D: Clés OpenPGP</a></li></ul></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Résumé</p></div><div class=paragraph><p>Bienvenue à FreeBSD! Ce manuel décrit l’installation et l’utilisation quotidienne de <em>FreeBSD 13.1-RELEASE</em>, et <em>FreeBSD 12.3-RELEASE</em>.
Ce document est le résultat du travail toujours en cours de nombreuses personnes.
Certaines sections peuvent ne pas être à jour.
Les personnes qui sont intéressées pour aider à mettre à jour et à compléter ce document devraient envoyer un courrier électronique à la <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>liste de diffusion du groupe de documentation de FreeBSD</a>.</p></div><div class=paragraph><p>La dernière version anglaise de ce document est disponible sur le <a href=https://www.FreeBSD.org/>site Web de FreeBSD</a>.
Les versions antérieures peuvent être obtenues auprès de <a href=https://docs.FreeBSD.org/doc/>http://docs.FreeBSD.org/doc/</a>).
Il peut être aussi téléchargé dans divers formats et options de compression depuis le <a href=https://download.freebsd.org/doc/>serveur de téléchargement FreeBSD</a> ou l’un des nombreux <a href=./#mirrors>sites miroirs</a>.
Des recherches dans le Manuel et les autres documents peuvent être effectuées à partir de la <a href=https://www.FreeBSD.org/search/>page de recherches</a>.</p></div><div class=paragraph><p>N.d.T.: Contactez Marc Fonvieille &lt;<a href=mailto:blackend@FreeBSD.org>blackend@FreeBSD.org</a>> si vous voulez collaborer à la traduction.</p></div><hr></div></div><div class=sect1><h2 id=book-preface>Préface<a class=anchor href=#book-preface></a></h2><div class=sectionbody><div class=sect2><h3 id=preface-audience>Public visé<a class=anchor href=#preface-audience></a></h3><div class=paragraph><p>Le nouveau venu à FreeBSD constatera que la première section de ce livre guide l’utilisateur à travers le processus d’installation de FreeBSD, et présente progressivement les concepts et les conventions qui sont les fondements d’UNIX®. Travailler avec cette section demande un peu plus que le simple désire d’explorer, et la capacité d’assimiler de nouveaux concepts quand ils sont présentés.</p></div><div class=paragraph><p>Une fois que vous en êtes arrivé là, la seconde, bien plus grande, section du Manuel est une référence complète de tous les sujets qui intéressent les administrateurs systèmes de FreeBSD. Certains de ces chapitres peuvent vous recommander d’effectuer des lectures préliminaires, cela est noté dans le synopsis au début de chaque chapitre.</p></div><div class=paragraph><p>Pour une liste de sources d’informations complémentaires, veuillez consulter <a href=./#bibliography>Bibliographie</a>.</p></div></div><div class=sect2><h3 id=preface-changes-from2>Modifications depuis la Seconde Edition<a class=anchor href=#preface-changes-from2></a></h3><div class=paragraph><p>Cette seconde édition est le point culminant de plus de deux ans de travail pour les membres du Groupe de Documentation de FreeBSD. Ce qui suit présente les changements principaux de cette nouvelle édition:</p></div><div class=ulist><ul><li><p><a href=./#config-tuning>Configuration et optimisation</a>, le chapitre "Configuration et optimisation", a été augmenté avec des informations nouvelles sur la gestion ACPI des ressources et de l’énergie, sur l’utilitaire système <code>cron</code>, et sur d’autres d’options supplémentaires d’optimisation du noyau.</p></li><li><p><a href=./#security>Sécurité</a>, le chapitre "Sécurité", a été augmenté avec de nouvelles informations sur les réseaux privés virtuels (VPNs), les listes de contrôle d’accès au système de fichiers (ACLs), et sur les avis de sécurité.</p></li><li><p><a href=./#mac>Mandatory Access Control</a>, "Le contrôle d’accès obligatoire" (MAC) est un nouveau chapitre ajouté avec cette édition. Il explique ce qu’est le MAC et comment ce mécanisme peut être utilisé pour sécuriser un système FreeBSD.</p></li><li><p><a href=./#disks>Stockage des données</a>, le chapitre "Stockage des données", a bénéficié de l’ajout de nouvelles sections concernant les périphériques de stockage USB, les instantanés de systèmes de fichiers, les quotas d’utilisation des disques, les systèmes de fichiers réseaux et sauvegardés sur fichier, et le chiffrage de partitions.</p></li><li><p><a href=./#vinum-vinum>Le gestionnaire de volume Vinum</a>, "Vinum", est un nouveau chapitre apparaissant avec cette édition. Il décrit l’utilisation de Vinum, un gestionnaire de volume qui permet la création de disques logiques indépendants du périphérique, et l’utilisation de systèmes RAID-0, RAID-1 et RAID-5 logiciels.</p></li><li><p>Une section dépannage a été ajoutée au chapitre <a href=./#ppp-and-slip>PPP et SLIP</a>, PPP et SLIP.</p></li><li><p><a href=./#mail>Courrier électronique</a>, le chapitre "Courrier électronique", bénéficie de nouvelles sections sur l’utilisation d’agents de transfert de courrier alternatifs, sur l’authentification SMTP, l’UUCP, fetchmail, procmail, et d’autres sujets avancés.</p></li><li><p><a href=./#network-servers>Serveurs réseau</a> le chapitre "Serveurs réseau", apparaît avec cette édition. Ce chapitre traite de la configuration du serveur HTTP Apache, de ftpd, et celle d’un serveur pour clients Microsoft® Windows® à l’aide de Samba. Certaines sections du chapitre <a href=./#advanced-networking>Administration réseau avancée</a>, "Administration réseau avancée" ont été déplacées vers ce nouveau chapitre.</p></li><li><p><a href=./#advanced-networking>Administration réseau avancée</a>, le chapitre "Administration réseau avancée" a été complété avec des informations sur l’utilisation des périphériques Bluetooth® sous FreeBSD, la configuration de réseaux sans fil, et sur le mode de transfert réseau asynchrone (ATM).</p></li><li><p>Un glossaire a été ajouté pour centraliser les définitions des termes techniques employés tout au long de cet ouvrage.</p></li><li><p>La présentation des tableaux et des figures a été améliorée.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes>Modifications depuis la Première Edition<a class=anchor href=#preface-changes></a></h3><div class=paragraph><p>La seconde édition est le point culminant de deux ans de travail pour les membres du Groupe de Documentation de FreeBSD. Ce qui suit présente les changements principaux de cette nouvelle édition:</p></div><div class=ulist><ul><li><p>Un sommaire complet a été ajouté.</p></li><li><p>Toutes les figures ASCII ont été remplacées par des graphiques.</p></li><li><p>Un synopsis standard a été ajouté à chaque chapitre pour donner un rapide résumé des informations contenues par ce dernier et ce qu’est sensé connaître le lecteur.</p></li><li><p>Le contenu a été réorganisé de façon logique en trois parties: "Pour commencer", "L’Administration Système", et "Annexes".</p></li><li><p>Le <a href=./#bsdinstall>Installer FreeBSD</a> ("Installer FreeBSD") fut complètement réécrit avec de nombreuses photos d’écrans pour rendre le texte plus facile à comprendre pour les nouveaux utilisateurs.</p></li><li><p>Le <a href=./#basics>Quelques bases d’UNIX</a> ("Quelques bases d’UNIX®") a été augmenté pour contenir des informations additionnelles sur les processus, daemons et signaux.</p></li><li><p>Le <a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a> ("Installer des applications") a été augmenté pour contenir des informations complémentaires sur la gestion des applications pré-compilées.</p></li><li><p>Le <a href=./#x11>Le système X Window</a> ("Le système X Window") a complètement été réécrit en insistant sur l’utilisation de technologies modernes d’environnement de travail comme KDE et GNOME sous XFree86™ 4.X.</p></li><li><p>Le <a href=./#boot>Processus de démarrage de FreeBSD</a> ("Le processus de démarrage de FreeBSD") a été augmenté.</p></li><li><p>Le <a href=./#disks>Stockage des données</a> ("Stockage des données") fut réécrit à partir de ce qui était à l’origine deux chapitres séparés "Disques" et "Sauvegardes". Nous pensons que le sujet est plus facile à appréhender quand il est présenté en un seul chapitre. Une section sur RAID (matériel et logiciel) fut également ajoutée.</p></li><li><p>Le <a href=./#serialcomms>Serial Communications</a> ("Communications série") a été complètement réorganisé et mis à jour pour FreeBSD 4.X/5.X.</p></li><li><p>Le <a href=./#ppp-and-slip>PPP et SLIP</a> ("PPP et SLIP") a été sensiblement mis à jour.</p></li><li><p>Plusieurs nouvelles sections ont été ajouté au <a href=./#advanced-networking>Administration réseau avancée</a> ("Administration réseau avancée").</p></li><li><p>Le <a href=./#mail>Courrier électronique</a> ("Courrier électronique") fut augmenté pour inclure plus d’informations au sujet de la configuration de sendmail.</p></li><li><p>Le <a href=./#linuxemu>Compatibilité binaire avec Linux®</a> ("Compatibilité Linux®") a été augmenté pour inclure des informations sur l’installation d’Oracle® et SAP® R/3®.</p></li><li><p>Les nouveaux sujets suivants sont abordés dans cette seconde édition:</p><div class=ulist><ul><li><p>Configuration et optimisation (<a href=./#config-tuning>Configuration et optimisation</a>).</p></li><li><p>Multimédia (<a href=./#multimedia>Multimédia</a>)</p></li></ul></div></li></ul></div></div><div class=sect2><h3 id=preface-overview>Organisation de cet ouvrage<a class=anchor href=#preface-overview></a></h3><div class=paragraph><p>Ce livre est divisé en cinq parties logiquement distinctes. Le première section, <em>Pour commencer</em>, couvre l’installation et les bases de l’utilisation de FreeBSD. On s’attend à ce que le lecteur suive ces chapitres dans l’ordre, sautant éventuellement les chapitres traitant de sujets familiers. La seconde section <em>Tâches courantes</em>, couvre les fonctionnalités de FreeBSD fréquemment utilisées. Cette section, ainsi que toutes les sections suivantes, peuvent être lues dans n’importe quel ordre. Chaque chapitre débute avec un synopsis succinct qui décrit ce dont parle le chapitre et ce qu’on s’attend à ce que le lecteur sache déjà. Cela en vue de permettre au lecteur occasionnel de se rendre directement aux chapitres qui l’intéresse. La troisième section, <em>Administration système</em>, traite des sujets concernant l’administration. La quatrième section, <em>Réseaux</em>, couvre le domaine des réseaux et des serveurs. La cinquième section contient des annexes d’information de référence.</p></div><div class=dlist><dl><dt class=hdlist1><em><a href=./#introduction>Introduction</a></em></dt><dd><p>Présente FreeBSD à un nouvel utilisateur. Il décrit l’histoire du projet FreeBSD, ses objectifs, son mode de développement.</p></dd><dt class=hdlist1><em><a href=./#bsdinstall>Installer FreeBSD</a></em></dt><dd><p>Guide un utilisateur à travers le processus d’installation. Quelques sujets d’installation avancée, comme l’installation avec une console série, sont aussi couverts.</p></dd><dt class=hdlist1><em><a href=./#basics>Quelques bases d’UNIX</a></em></dt><dd><p>Couvre les commandes et fonctionnalités de base du système d’exploitation FreeBSD. Si vous êtes familier avec Linux® ou un autre type d’UNIX® alors vous pouvez probablement passer ce chapitre.</p></dd><dt class=hdlist1><em><a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a></em></dt><dd><p>Couvre l’installation de logiciels tiers avec l’innovant "Catalogue de logiciels portés" de FreeBSD et les logiciels pré-compilés.</p></dd><dt class=hdlist1><em><a href=./#x11>Le système X Window</a></em></dt><dd><p>Décrit le système X Window en général et l’utilisation d’X11 sur FreeBSD en particulier. Décrit également les environnements de travail comme KDE et GNOME.</p></dd><dt class=hdlist1><em><a href=./#desktop>Bureautique</a></em></dt><dd><p>Liste les applications de bureautique courantes, comme les navigateurs Web et les suites de bureautique, et décrit comment les installer sous FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#multimedia>Multimédia</a></em></dt><dd><p>Montre comment installer le support du son et de la vidéo pour votre système. Décrit également quelques applications audio et vidéo.</p></dd><dt class=hdlist1><em><a href=./#kernelconfig>Configurer le noyau de FreeBSD</a></em></dt><dd><p>Explique pour quelles raisons vous devriez configurer un nouveau noyau et fournit des instructions détaillées pour la configuration, la compilation et l’installation d’un noyau sur mesures.</p></dd><dt class=hdlist1><em><a href=./#printing>Imprimer</a></em></dt><dd><p>Décrit la gestion des imprimantes sous FreeBSD, y compris les informations sur les pages d’en-tête, la comptabilisation de l’usage et la configuration de base.</p></dd><dt class=hdlist1><em><a href=./#linuxemu>Compatibilité binaire avec Linux®</a></em></dt><dd><p>Décrit les caractéristiques de la compatibilité Linux® sous FreeBSD. Fournit également les instructions détaillées de l’installation de plusieurs applications Linux® populaires comme Oracle®, SAP® R/3® et Mathematica®.</p></dd><dt class=hdlist1><em><a href=./#config-tuning>Configuration et optimisation</a></em></dt><dd><p>Décrit les paramètres disponibles pour les administrateurs systèmes afin d' optimiser les performances d’un système FreeBSD. Décrit également les différents fichiers de configuration utilisés dans FreeBSD et où les trouver.</p></dd><dt class=hdlist1><em><a href=./#boot>Processus de démarrage de FreeBSD</a></em></dt><dd><p>Décrit le processus de démarrage de FreeBSD et explique comment contrôler ce processus avec des options de configuration.</p></dd><dt class=hdlist1><em><a href=./#users>Gestion des comptes et des utilisateurs</a></em></dt><dd><p>Décrit la création et la manipulation des comptes utilisateur. Traite également des limitations de ressources qui peuvent être appliquées aux utilisateurs et des autres tâches de gestion des comptes.</p></dd><dt class=hdlist1><em><a href=./#security>Sécurité</a></em></dt><dd><p>Décrit différents outils disponibles pour vous aider à sécuriser votre système FreeBSD, dont Kerberos, IPsec et OpenSSH.</p></dd><dt class=hdlist1><em><a href=./#jails>Environnements jails</a></em></dt><dd><p>Décrit l’organisation des environnements jail, et les améliorations apportées par ces environnements par rapport au support chroot traditionnel de FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mac>Mandatory Access Control</a></em></dt><dd><p>Explique ce qu’est le contrôle d’accès mandataire (MAC) et comment ce mécanisme peut être utilisé pour sécuriser un système FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#audit>Audit des événements relatifs à la sécurité du système</a></em></dt><dd><p>Décrit ce qu’est l’audit d’événements sous FreeBSD, comment cette fonctionnalité peut être installée, configurée et comment les audits peuvent être examinés et surveillés.</p></dd><dt class=hdlist1><em><a href=./#disks>Stockage des données</a></em></dt><dd><p>Décrit comment gérer les supports de stockage et les systèmes de fichiers avec FreeBSD. Cela inclut les disques physiques, les systèmes RAID, les supports optiques et bandes, les disques mémoires, et les systèmes de fichiers réseau.</p></dd><dt class=hdlist1><em><a href=./#geom>GEOM. architecture modulaire de gestion des disques</a></em></dt><dd><p>Décrit ce qu’est le système GEOM sous FreeBSD et comment configurer les différents niveaux de RAID supportés.</p></dd><dt class=hdlist1><em><a href=./#vinum-vinum>Le gestionnaire de volume Vinum</a></em></dt><dd><p>Décrit comment utiliser Vinum, un gestionnaire de volume logique qui permet d’avoir des disques logiques indépendants du périphérique, et le RAID-0, RAID-1 et RAID-5 logiciel.</p></dd><dt class=hdlist1><em><a href=./#virtualization>Virtualisation</a></em></dt><dd><p>Décrit ce que les systèmes de virtualisation apportent, et comment ils peuvent être utilisés avec FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#l10n>Localisation - Utilisation et configuration de l’I18N/L10N</a></em></dt><dd><p>Décrit comment utiliser FreeBSD avec des langues autres que l’anglais. Couvre la localisation du système et des applications.</p></dd><dt class=hdlist1><em><a href=./#updating-upgrading>Mise à jour de FreeBSD</a></em></dt><dd><p>Explique les différences entre FreeBSD-STABLE, FreeBSD-CURRENT et les versions de publication;. Décrit quel type d’utilisateurs pourrait tirer profit de suivre un système de développement et présente le processus.</p></dd><dt class=hdlist1><em><a href=./#serialcomms>Communications série</a></em></dt><dd><p>Explique comment connecter terminaux et modems à votre système FreeBSD aussi bien pour les connexions entrantes que sortantes.</p></dd><dt class=hdlist1><em><a href=./#ppp-and-slip>PPP et SLIP</a></em></dt><dd><p>Décrit comment utiliser PPP, SLIP ou PPP sur Ethernet pour se connecter à des systèmes distants à l’aide de FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mail>Courrier électronique</a></em></dt><dd><p>Explique les différents composants d’un serveur de courrier et plonge dans la configuration de base du serveur de courrier le plus populaire: sendmail.</p></dd><dt class=hdlist1><em><a href=./#network-servers>Serveurs réseau</a></em></dt><dd><p>Fournit des instructions détaillées et des exemples de fichiers de configuration pour configurer votre machine FreeBSD comme serveur de fichiers, serveur de noms de domaine, serveur d’information réseau, ou comme serveur de synchronisation d’horloge.</p></dd><dt class=hdlist1><em><a href=./#firewalls>Firewalls</a></em></dt><dd><p>Explique la philosophie des coupe-feux logiciels et fournit des informations détaillées sur la configuration des différents coupe-feux disponibles pour FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#advanced-networking>Administration réseau avancée</a></em></dt><dd><p>Décrit de nombreux sujets sur l’utilisation réseau, dont le partage d’une connexion Internet avec d’autres ordinateurs sur votre réseau local, routage, réseaux sans-fils, Bluetooth®, ATM, IPv6, et bien plus.</p></dd><dt class=hdlist1><em><a href=./#mirrors>Se procurer FreeBSD</a></em></dt><dd><p>Enumère les différentes sources pour obtenir FreeBSD sur CDROM ou DVD, ainsi que les différents sites Internet qui vous permettent de télécharger et d’installer FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#bibliography>Bibliographie</a></em></dt><dd><p>Cet ouvrage aborde de nombreux sujets cela peut vous laisser sur votre faim et à la recherche de plus de détails. La bibliographie énumère d’excellents ouvrages qui sont référencés dans le texte.</p></dd><dt class=hdlist1><em><a href=./#eresources>Ressources sur Internet</a></em></dt><dd><p>Décrit les nombreux forums disponibles pour les utilisateurs de FreeBSD pour poster des questions et engager des conversations techniques au sujet de FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#pgpkeys>Clés OpenPGP</a></em></dt><dd><p>Liste les clés PGP de nombreux développeurs FreeBSD.</p></dd></dl></div></div><div class=sect2><h3 id=preface-conv>Conventions utilisées dans ce livre<a class=anchor href=#preface-conv></a></h3><div class=paragraph><p>Pour fournir un texte logique et facile à lire, plusieurs conventions sont respectées tout au long du livre.</p></div><div class=sect3><h4 id=preface-conv-typographic>Conventions typographiques<a class=anchor href=#preface-conv-typographic></a></h4><div class=dlist><dl><dt class=hdlist1><em>Italique</em></dt><dd><p>Une police de caractères <em>italique</em> est utilisée pour les noms de fichiers, les URLs, le texte à mettre en valeur et la première utilisation de termes techniques.</p></dd><dt class=hdlist1><code>Police de caractères à chasse fixe</code></dt><dd><p>Une police de caractères à <code>chasse fixe</code> est utilisée pour les messages d’erreurs, les commandes, les variables d’environnement, les noms des logiciels portés, les noms d’hôtes, les noms d’utilisateurs, les noms de groupes, les noms de périphériques, les variables et les morceaux de code source.</p></dd><dt class=hdlist1>Caractères gras</dt><dd><p>Des caractères gras sont utilisés pour les applications, les commandes et les touches.</p></dd></dl></div></div><div class=sect3><h4 id=preface-conv-commands>Utilisation du clavier<a class=anchor href=#preface-conv-commands></a></h4><div class=paragraph><p>Les touches sont représentées en <strong>gras</strong> pour ressortir du texte. Les combinaisons de touches qui sont sensées être tapées simultanément sont représentées avec <code>+</code> entre chaque touche, comme par exemple:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span></p></div><div class=paragraph><p>Indiquant que l’utilisateur devra appuyer simultanément sur les touches <kbd>Ctrl</kbd>, <kbd>Alt</kbd>, et <kbd>Del</kbd>.</p></div><div class=paragraph><p>Les touches qui sont sensées être tapées en séquence seront séparées par une virgule, par exemple:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p></div><div class=paragraph><p>Signifiera que l’on on attend à ce que l’utilisateur tape les touches <kbd>Ctrl</kbd> et <kbd>X</kbd> simultanément et ensuite tape <kbd>Ctrl</kbd> et <kbd>S</kbd> simultanément.</p></div></div><div class=sect3><h4 id=preface-conv-examples>Exemples<a class=anchor href=#preface-conv-examples></a></h4><div class=paragraph><p>Les exemples commençant par <span class=filename>E:\</span> indiquent une commande MS-DOS®. Sauf indication contraire, on peut exécuter ces commandes depuis une fenêtre "d’invite de commande" dans un environnement Microsoft® Windows® moderne.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>E:<span class=se>\ </span>tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>Les exemples commençant par # indiquent que la commande doit être lancée en tant que super-utilisateur sous FreeBSD. Vous pouvez ouvrir une session en tant que <code>root</code> pour taper cette commande, ou ouvrir une session sous votre compte normal et utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> pour obtenir les privilèges de super-utilisateur.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>Les exemples commençant par % indiquent une commande qui devrait être lancée par un utilisateur normal. Sauf indication contraire, la syntaxe de l’interpréteur de commandes C-shell est utilisée pour configurer les variables d’environnement et autres commandes de l’interpréteur.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top</code></pre></div></div></div></div><div class=sect2><h3 id=preface-acknowledgements>Remerciements<a class=anchor href=#preface-acknowledgements></a></h3><div class=paragraph><p>L’ouvrage que vous avez en main représente les efforts de plusieurs centaines de personnes dans le monde. Qu’ils aient envoyé des corrections de fautes de frappe, ou soumis des chapitres entiers, toutes les contributions ont été utiles.</p></div><div class=paragraph><p>Plusieurs entreprises ont supporté le développement de ce document en payant des auteurs à travailler à plein temps dessus, en payant pour la publication etc…​ En particulier, BSDi (rachetée plus tard par <a href=http://www.windriver.com>Wind River Systems</a>) a payé à temps plein des membres du Groupe de Documentation de FreeBSD à l’amélioration de ce livre menant ainsi à la publication de la première version imprimée en Mars 2000 (ISBN 1-57176-241-8). Wind River Systems a ensuite payé plusieurs auteurs supplémentaires pour apporter un certain nombre d’améliorations à l’infrastructure de publication et à l’ajout de chapitres. Ce travail a abouti à la publication de la deuxième édition imprimée en Novembre 2001 (ISBN 1-57176-303-1). En 2003-2004, <a href=http://www.freebsdmall.com>FreeBSD Mall, Inc</a>, a payé plusieurs auteurs pour travailler sur l’amélioration de ce manuel en vue de la publication de la troisième édition papier.</p></div></div></div></div><h1 id=getting-started class=sect0>Partie I: Pour commencer<a class=anchor href=#getting-started></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Cette partie du Manuel FreeBSD est destinée aux nouveaux venus à FreeBSD, utilisateurs et administrateurs. Ces chapitres:</p></div><div class=ulist><ul><li><p>Présenteront FreeBSD.</p></li><li><p>Guideront les lecteurs à travers le processus d’installation.</p></li><li><p>Enseigneront quelques bases et fondements d’UNIX®.</p></li><li><p>Montreront comment installer la profusion d’applications tierces disponibles pour FreeBSD.</p></li><li><p>Présenteront X, le système de fenêtrage d’UNIX®, et détailleront comment configurer un environnement de travail qui rendra les utilisateurs plus productifs.</p></li></ul></div><div class=paragraph><p>Le nombre de références dans le texte a été limité au minimum afin que cette section du Manuel puisse être lue du début jusqu’à la fin avec le moins de changements de pages possibles.</p></div></div></div><div class=sect1><h2 id=introduction>Chapitre 1. Introduction<a class=anchor href=#introduction></a></h2><div class=sectionbody><div class=sect2><h3 id=introduction-synopsis>1.1. Synopsis<a class=anchor href=#introduction-synopsis></a></h3><div class=paragraph><p>Merci de votre intérêt pour FreeBSD! Le chapitre suivant traite de divers aspects concernant le projet FreeBSD, comme son histoire, ses objectifs, son mode de développement, et d’autres.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Comment FreeBSD est lié aux autres systèmes d’exploitation.</p></li><li><p>L’histoire du Projet FreeBSD.</p></li><li><p>Les objectifs du Projet FreeBSD.</p></li><li><p>Les bases du mode de développement open-source de FreeBSD.</p></li><li><p>Et bien sûr: l’origine du nom "FreeBSD".</p></li></ul></div></div><div class=sect2><h3 id=nutshell>1.2. Bienvenue à FreeBSD!<a class=anchor href=#nutshell></a></h3><div class=paragraph><p>FreeBSD est une système d’exploitation basé sur 4.4BSD-Lite2 pour les ordinateurs à base d’architecture Intel (x86 et Itanium®), AMD64, les ordinateurs DEC Alpha™, et Sun UltraSPARC®. Le portage pour d’autres architectures est également en cours. Pour connaître l’histoire du projet, lisez <a href=#history>Un court historique de FreeBSD</a>. Pour avoir une description de la version la plus récente, allez à la section <a href=#relnotes>A propos de cette version</a>. Si vous voulez contribuer d’une façon ou d’une autre au projet FreeBSD (code, matériel, dons), voyez s’il vous plaît à la section <a href=https://docs.freebsd.org/fr/articles/contributing/>Contribuer à FreeBSD</a>.</p></div><div class=sect3><h4 id=os-overview>1.2.1. Que peut faire FreeBSD?<a class=anchor href=#os-overview></a></h4><div class=paragraph><p>FreeBSD dispose de nombreuses caractéristiques remarquables. Parmi lesquelles:</p></div><div class=ulist><ul><li><p><em>Multi-tâche préemptif</em> avec ajustement dynamique des priorités pour garantir un partage équilibré et fluide de l’ordinateur entre les applications et les utilisateurs et cela même sous les charges les plus importantes.</p></li><li><p><em>Accès multi-utilisateurs</em> qui permet à de nombreuses personnes d’utiliser en même temps un système FreeBSD à des fins très différentes. Cela signifie, par exemple, que des périphériques tels que les imprimantes ou les lecteurs de bandes peuvent être partagés entre tous les utilisateurs sur le système ou sur le réseau et que des limitations d’utilisation des ressources peuvent être appliquées à des utilisateurs ou groupes d’utilisateurs, protégeant ainsi les ressources systèmes critiques d’une sur-utilisation.</p></li><li><p><em>Réseau TCP/IP</em> complet dont le support de standards industriels comme SCTP, DHCP, NFS, NIS, PPP, SLIP, IPsec, et IPv6. Cela signifie que votre machine FreeBSD peut coopérer facilement avec d’autres systèmes ou être utilisée comme serveur d’entreprise, fournissant des fonctions essentielles comme NFS (accès aux fichiers en réseau) et le service de courrier électronique, ou encore l’accès de votre entreprise à l’Internet grâce aux services WWW, FTP, et aux fonctionnalités de routage et de coupe-feu (sécurité).</p></li><li><p><em>La protection de la mémoire</em> garantit que les applications (ou les utilisateurs) ne peuvent interférer entre eux. Une application qui plante n’affectera en rien les autres.</p></li><li><p>FreeBSD est un système d’exploitation <em>32-bits</em> (<em>64-bits</em> sur l’architecture Alpha, Itanium®, AMD64, et UltraSPARC®) et a été conçu comme tel dès le début.</p></li><li><p>Le <em>Système X Window</em> (X11R7), standard industriel, fournit une interface graphique à l’utilisateur (Graphical User Interface - GUI), moyennant l’achat d’une carte VGA ordinaire et d’un moniteur, et est livré avec l’intégralité de son code source.</p></li><li><p><em>Compatibilité binaire</em> avec de nombreux programmes compilés pour Linux, SCO, SVR4, BSDI et NetBSD.</p></li><li><p>Des milliers d’applications <em>prêtes à l’emploi</em> sont disponibles grâce au catalogue des logiciels portés (ports) et au catalogue des logiciels <em>pré-compilés</em> (packages). Pourquoi chercher sur l’Internet alors que tout est là?.</p></li><li><p>Des milliers d’applications <em>faciles à porter</em> sont disponibles sur l’Internet. FreeBSD est compatible au niveau du code source avec les systèmes UNIX® commerciaux les plus répandus et donc la plupart des applications exigent peu, sinon aucune modification, pour les compiler.</p></li><li><p><em>Mémoire virtuelle</em> à la demande et "cache unifié pour les disques et la mémoire virtuelle" cela permet de répondre aux besoins des applications gourmandes en mémoire tout en garantissant le temps de réponse aux autres utilisateurs.</p></li><li><p>Support du <em>traitement symétrique multiprocesseurs</em> (SMP).</p></li><li><p>Des outils complets de développement <em>C</em>, <em>C++</em>, et <em>Fortran</em>. De nombreux autres langages pour la recherche de pointe et le développement sont aussi disponibles dans les catalogues des logiciels portés et pré-compilés.</p></li><li><p>La disponibilité <em>Code source</em> de l’intégralité du système vous donne un contrôle total sur votre environnement. Pourquoi être prisonnier d’une solution propriétaire et dépendant de votre fournisseur alors que vous pouvez avoir un véritable système ouvert?</p></li><li><p>Une <em>documentation en ligne</em> très complète.</p></li><li><p><em>Et beaucoup d’autres choses encore!</em></p></li></ul></div><div class=paragraph><p>FreeBSD est basé sur la version 4.4BSD-Lite2 du "Computer Systems Research Group" (CSRG) de l’Université de Californie à Berkeley et continue la tradition de développement renommée des systèmes BSD. En plus de l’excellent travail fourni par le CSRG, le Projet FreeBSD a investi des milliers d’heures de travail pour optimiser le système pour arriver aux meilleures performances et au maximum de fiabilité sous la charge d’un environnement de production. Alors que la plupart des géants dans le domaine des systèmes d’exploitation pour PC s’acharnent encore à obtenir de telles possibilités, performances et fiabilité, FreeBSD peut les offrir <em>dès maintenant</em>!</p></div><div class=paragraph><p>La seule limite aux domaines d’application auxquels FreeBSD peut satisfaire est votre propre imagination. Du développement de logiciels à la production robotisée, de la gestion de stocks à la correction d’azimut pour les antennes satellites; si un UNIX® commercial peut le faire, il y a de très fortes chances que FreeBSD le puisse aussi! FreeBSD bénéficie aussi de centaines d’applications de haute qualité développées par les centres de recherche et les universités du monde entier, souvent disponibles gratuitement ou presque. Il existe aussi des applications commerciales et leur nombre croît de jour en jour.</p></div><div class=paragraph><p>Comme le code source de FreeBSD lui-même est globalement disponible, le système peut aussi être adapté sur mesure à un point pratiquement jamais atteint pour des applications ou des projets particuliers, d’une façon qui serait habituellement impossible avec les systèmes d’exploitation commerciaux de la plupart des principaux fournisseurs. Voici juste quelques exemples d’applications pour lesquelles FreeBSD est utilisé:</p></div><div class=ulist><ul><li><p><em>Services Internet:</em> les fonctionnalités réseau TCP/IP robustes qu’inclut FreeBSD en font la plate-forme idéale pour un éventail de services Internet, tels que:</p><div class=ulist><ul><li><p>Serveurs FTP</p></li><li><p>Serveurs World Wide Web (standard ou sécurisé [SSL])</p></li><li><p>Routage IPv4 et IPv6</p></li><li><p>Coupe-feux et passerelles de traduction d’adresses ("IP masquerading")</p></li><li><p>Serveurs de courrier électronique</p></li><li><p>Serveurs de News USENET (forums de discussion) ou Bulletin Board Systems (BBS)</p></li><li><p>Et plus…​</p><div class=paragraph><p>Avec FreeBSD, vous pouvez facilement commencer petit avec un PC 386 à bas prix et évoluer jusqu’à un quadri-processeurs Xeon avec stockage RAID au fur et à mesure que votre entreprise s’agrandit.</p></div></li></ul></div></li><li><p><em>Education:</em> Etes-vous étudiant en informatique ou dans un domaine d’ingénierie apparenté? Il n’y a pas de meilleur moyen pour étudier les systèmes d’exploitation, l’architecture des ordinateurs et les réseaux que l’expérience directe et de "derrière la coulisse" que FreeBSD peut vous apporter. Il y a aussi un grand nombre d’outils mathématiques, graphiques et de Conception Assistée par Ordinateur qui en font un outil très utile pour ceux qui s’intéressent aux ordinateurs essentiellement pour faire un <em>autre</em> travail!</p></li><li><p><em>Recherche:</em> Avec le code source de la totalité du système disponible, FreeBSD est un excellent outil de recherche sur les systèmes d’exploitation tout autant que pour d’autres branches de l’informatique. Le fait que FreeBSD soit librement disponible rend aussi possible l’échange d’idées et le développement partagé entre groupes éloignés sans avoir à se préoccuper de problèmes de licence particulières ou de restrictions à ce qui pourrait être discuté sur des forums ouverts.</p></li><li><p><em>Réseau:</em> Il vous faut un nouveau routeur? Un serveur de domaine (DNS)? Un coupe-feu pour tenir les gens à l’écart de votre réseau interne? FreeBSD peut facilement faire de votre vieux 386 ou 486 inutilisé qui traîne dans un coin un routeur évolué avec des fonctionnalités sophistiquées de filtrage de paquets.</p></li><li><p><em>Station de travail X Window:</em> FreeBSD est un excellent choix pour faire un terminal X peu coûteux, en utilisant le serveur X11 librement disponible. Au contraire d’un terminal X, FreeBSD permet d’exécuter localement, si désiré, un grand nombre d’applications, déchargeant ainsi le serveur central. FreeBSD peut même démarrer "sans disque", ce qui permet de concevoir des postes de travail individuels moins chers et plus faciles à administrer.</p></li><li><p><em>Développement de logiciel:</em> Le système FreeBSD de base inclut un environnement de développement complet dont les compilateur et débogueur GNU C/C++ réputés.</p></li></ul></div><div class=paragraph><p>FreeBSD est disponible sous forme de code source ou binaire sur CDROM, DVD ou par ftp anonyme, Voyez <a href=./#mirrors>Se procurer FreeBSD</a> pour plus de détails.</p></div></div><div class=sect3><h4 id=_qui_utilise_freebsd>1.2.2. Qui utilise FreeBSD?<a class=anchor href=#_qui_utilise_freebsd></a></h4><div class=paragraph><p>FreeBSD est utilisé par certains des plus importants sites sur l’Internet, parmi lesquels:</p></div><div class=ulist><ul><li><p><a href=http://www.yahoo.com/>Yahoo!</a></p></li><li><p><a href=http://www.apache.org/>Apache</a></p></li><li><p><a href=http://www.bluemountain.com/>Blue Mountain Arts</a></p></li><li><p><a href=http://www.pair.com/>Pair Networks</a></p></li><li><p><a href=http://www.sony.co.jp/>Sony Japan</a></p></li><li><p><a href=http://www.netcraft.com/>Netcraft</a></p></li><li><p><a href=http://www.wni.com/>Weathernews</a></p></li><li><p><a href=http://www.supervalu.com/>Supervalu</a></p></li><li><p><a href=http://www.telehouse.com/>TELEHOUSE America</a></p></li><li><p><a href=http://www.sophos.com/>Sophos Anti-Virus</a></p></li><li><p><a href=http://www.jmawired.com/>JMA Wired</a></p></li></ul></div><div class=paragraph><p>et de nombreux autres.</p></div></div></div><div class=sect2><h3 id=history>1.3. A propos du Projet FreeBSD<a class=anchor href=#history></a></h3><div class=paragraph><p>La section suivante fournit des informations générales sur le projet, dont un court historique, les objectifs du projet, et le mode de développement du projet.</p></div><div class=sect3><h4 id=intro-history>1.3.1. Un court historique de FreeBSD<a class=anchor href=#intro-history></a></h4><div class=paragraph><p>Le projet FreeBSD a vu le jour au début de 1993, en partie comme extension du "Kit de mise à jour non officiel de 386BSD" des trois derniers coordinateurs du kit de mise à jour : Nate Williams, Rod Grimes et moi-même.</p></div><div class=paragraph><p>Notre objectif de départ était de fournir une distribution intermédiaire de 386BSD pour corriger un certain nombre de problèmes que le mécanisme du kit de mise à jour ne permettait pas de résoudre. Certains d’entre vous se rappellent peut-être que l’intitulé de travail d’origine du projet était "386 BSD 0.5" ou "386BSD Interim" en référence à ce problème.</p></div><div class=paragraph><p>386BSD était le système d’exploitation de Bill Jolitz, qui souffrait assez sévèrement à ce moment-là d’avoir été négligé pendant presque un an. Comme le kit de mise à jour enflait de plus en plus inconfortablement au fil des jours, nous avons décidé à l’unanimité qu’il fallait faire quelque chose et aider Bill en fournissant cette distribution provisoire de "remise à plat". Ces projets se sont brutalement interrompus lorsque Bill a décidé de retirer son aval au projet sans dire clairement ce qui serait fait à la place.</p></div><div class=paragraph><p>Il ne nous a pas fallu longtemps pour décider que l’objectif restait valable, même sans l’adhésion de Bill, et nous avons donc adopté le nom "FreeBSD", une proposition de David Greenman. Nos objectifs de départ ont été définis après avoir consulté les utilisateurs du moment du système et, dès qu’il est devenu clair que le projet était parti pour devenir un jour éventuellement réalité, nous avons contacté Walnut Creek CDROM dans l’optique d’améliorer la distribution de FreeBSD pour le grand nombre de ceux qui n’avaient pas la chance de pouvoir accéder facilement à l’Internet. Non seulement Walnut Creek CDROM a adopté l’idée de distribuer FreeBSD sur CDROM, mais a été jusqu’à fournir au projet une machine pour travailler et une connexion rapide à l’Internet. Sans le degré pratiquement sans précédent de confiance de Walnut Creek CDROM en ce qui n’était alors qu’un projet totalement inconnu, il y a peu de chance que FreeBSD ait été aussi loin, aussi vite, que là où il en est aujourd’hui.</p></div><div class=paragraph><p>La première version sur CDROM (et sur l’ensemble du Net) fut FreeBSD 1.0, parue en Décembre 1993. Elle reposait sur la bande 4.3BSD-Lite ("Net/2") de l’Université de Californie à Berkeley, avec de nombreux composants venant aussi de 386BSD et de la "Free Software Foundation". Ce fut un succès honnête pour une version initiale, qui fut suivi par le franc succès de la version 1.1 de FreeBSD, publiée en Mai 1994.</p></div><div class=paragraph><p>A peu près à cette époque, des nuages menaçants et inattendus apparurent lorsque commença la bataille juridique entre Novell et l’U.C. Berkeley autour du statut légal de la bande Net/2 de Berkeley. Dans les termes de l’accord, l’U.C. Berkeley concédait qu’une grande partie de Net/2 était du code "protégé" et propriété de Novell, qui l’avait à son tour racheté à AT&amp;T quelque temps auparavant. Berkeley obtint en retour la "bénédiction" de Novell que 4.4BSD-Lite soit, lorsqu’il vit finalement le jour, déclaré non protégé et que tous les utilisateurs de Net/2 soit fortement incités à migrer. Cela incluait FreeBSD, et l’on donna au projet jusqu’à Juillet 1994 pour mettre un terme à son propre produit basé sur Net/2. Selon les termes de cet accord, une dernière livraison était autorisée avant le délai final; ce fut FreeBSD 1.1.5.1.</p></div><div class=paragraph><p>FreeBSD s’attela alors à la tâche difficile de littéralement se réinventer à partir de fragments totalement nouveaux et assez incomplets de 4.4BSD-Lite. Les versions "Lite" étaient légères ("light") en partie parce que le CSRG avait retiré de gros morceaux du code nécessaires pour que l’on puisse effectivement en faire un système qui démarre (pour différentes raisons légales) et parce que le portage pour Intel de la version 4.4 était très partiel. Il fallu au projet jusqu’à Novembre 1994 pour terminer cette étape de transition et que FreeBSD 2.0 paraisse sur l’Internet et sur CDROM (fin Décembre). Bien qu’elle fut encore assez rugueuse aux angles, cette livraison obtint un succès significatif et fut suivie par la version 2.0.5 de FreeBSD, plus fiable et facile à installer, en Juin 1995.</p></div><div class=paragraph><p>Nous avons publié FreeBSD 2.1.5 en Août 1996, et il s’avéra suffisamment populaire chez les fournisseurs d’accès et les utilisateurs professionnels pour qu’une nouvelle version sur la branche 2.1-STABLE soit justifiée. Ce fut la version FreeBSD 2.1.7.1, parue en Février 1997 et qui marque la fin de 2.1-STABLE comme branche principale de développement. Dès lors, il n’y aurait plus que des améliorations quant à la sécurité et autres corrections de bogues critiques sur cette branche, (RELENG_2_1_0), passée en phase de maintenance.</p></div><div class=paragraph><p>La branche FreeBSD 2.2 fut créée à partir de la branche principale de développement ("-CURRENT") en Novembre 1996 en tant que branche RELENG_2_2, et la première version complète (2.2.1) parut en Avril 1997. Il y eut d’autres versions sur la branche 2.2 à l’été et à l’automne 97, la dernière (2.2.8) parut en Novembre 1998. La première version officielle 3.0 sortira en Octobre 1998 et annoncera le début de la fin pour la branche 2.2.</p></div><div class=paragraph><p>Il y eut la création de nouvelles branches le 20 Janvier 1999, donnant une branche 4.0-CURRENT et une branche 3.X-STABLE. De cette dernière il y eut la version 3.1 livrée le 15 Février 1999, la version 3.2 livrée le 15 Mai 1999, la 3.3 le 16 Septembre 1999, la 3.4 le 20 Décembre 1999 et la 3.5 le 24 Juin 2000, qui fut suivit quelques jours plus tard par une mise à jour mineure 3.5.1 pour rajouter quelques correctifs de sécurité de dernière minute sur Kerberos. Cela sera la dernière version de la la branche 3.X à paraître.</p></div><div class=paragraph><p>Le 13 Mars 2000 a vu l’apparition d’une nouvelle branche: la branche 4.X-STABLE. Il y a eu plusieurs versions jusqu’ici: la 4.0-RELEASE est sortie en Mars 2000, et la dernière version, la 4.11-RELEASE est sortie en Janvier 2005.</p></div><div class=paragraph><p>La tant attendue 5.0-RELEASE a été annoncée le 19 Janvier 2003. Etant le point culminant de près de trois ans de travail, cette version a engagé FreeBSD sur la voie d’un support avancé des systèmes multiprocesseurs et des "threads", et a introduit le support des plateformes UltraSPARC® et <code>ia64</code>. Cette version fut suivie de la 5.1 en Juin 2003. La dernier version 5.X issue de la branche -CURRENT fut la 5.2.1-RELEASE présentée en Février 2004.</p></div><div class=paragraph><p>La branche RELENG_5 créée en Août 2004, suivie par la 5.3-RELEASE, marque le début de la branche 5-STABLE. La version la plus récente, la 11.2-RELEASE, est sortie en June 28, 2018. Il n’est pas prévu de publier d’autres versions de la branche RELENG_5.</p></div><div class=paragraph><p>La branche RELENG_6 a été créée en Juillet 2005. La version 6.0-RELEASE, la première version issue de la branche 6.X a été rendue publique en Novembre 2005. La version la plus récente, la 12.0-RELEASE, est sortie en December 11, 2018. De nouvelles versions sont prévues pour la branche RELENG_6.</p></div><div class=paragraph><p>Pour le moment, les projets de développement à long terme continuent à se faire dans la branche (tronc) 7.X-CURRENT, et des "instantanées" de la 7.X sur CDROM (et, bien sûr, sur le net) sont continuellement mises à disposition sur le <a href=ftp://current.FreeBSD.org/pub/FreeBSD/snapshots/>serveur d’instantané</a> pendant l’avancement des travaux.</p></div></div><div class=sect3><h4 id=goals>1.3.2. Les objectifs du projet FreeBSD<a class=anchor href=#goals></a></h4><div class=paragraph><p>L’objectif du projet FreeBSD est de fournir du logiciel qui puisse être utilisé à n’importe quelle fin et sans aucune restriction. Nombre d’entre nous sont impliqués de façon significative dans le code (et dans le projet) et ne refuseraient certainement pas une petite compensation financière de temps à autre, mais ce n’est certainement pas dans nos intentions d’insister là dessus. Nous croyons que notre première et principale "mission" est de fournir du code à tout le monde, pour n’importe quel projet, de façon à ce qu’il soit utilisé le plus possible et avec le maximum d’avantages. C’est, nous le pensons, l’un des objectifs les plus fondamentaux du Logiciel Libre et l’un de ceux que nous soutenons avec enthousiasme.</p></div><div class=paragraph><p>Le code de l’arborescence des sources, qui est régi par la Licence Publique GNU ("GNU Public License" - GPL) ou la Licence Publique GNU pour les Bibliothèques ("GNU Library Public License" - GLPL) impose légèrement plus de contraintes, bien que plutôt liées à une disponibilité plus grande qu’au contraire, comme c’est généralement le cas. En raison des complications supplémentaires qui peuvent résulter de l’utilisation commerciale de logiciels GPL, nous essayons, cependant de remplacer ces derniers par des logiciels soumis à la licence BSD qui est plus souple, chaque fois que c’est possible.</p></div></div><div class=sect3><h4 id=development>1.3.3. Le mode de développement de FreeBSD<a class=anchor href=#development></a></h4><div class=paragraph><p>Le développement de FreeBSD est un processus très ouvert et très souple, c’est littéralement le résultat de contributions de centaines de personnes dans le monde entier, ce que reflète notre <a href=https://docs.freebsd.org/en/articles/contributors/>liste des participants</a>. L’infrastructure de développement de FreeBSD permet à ces centaines de développeurs de collaborer via l’Internet. Nous sommes toujours à l’affût de nouveaux développeurs et de nouvelles idées, et ceux que s’impliquer de plus près intéresse n’ont besoin que de contacter la <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>liste de diffusion pour les discussions techniques sur FreeBSD</a>. La <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>liste de diffusion pour les annonces relatives à FreeBSD</a> est aussi disponible pour ceux qui veulent faire connaître aux autres utilisateurs de FreeBSD les principaux domaines de développement en cours.</p></div><div class=paragraph><p>Quelques points utiles à connaître à propos du projet FreeBSD et de son processus de développement, que vous travailliez indépendamment ou en collaboration étroite:</p></div><div class=dlist><dl><dt class=hdlist1>Les archives CVS<a id=development-cvs-repository></a></dt><dd><p>L’arborescence centrale des sources de FreeBSD est gérée sous <a href=http://ximbiot.com/cvs/wiki/>CVS</a> (Concurrent Version System), un système librement disponible de gestion de version des sources qui est livré avec FreeBSD. Les <a href=http://www.freebsd.org/cgi/cvsweb.cgi>archives CVS</a> principales sont sur une machine à Santa Clara CA, USA, d’où elles sont répliquées sur de nombreuses machines miroir à travers le monde. L’arborescence CVS qui contient les branches <a href=./#current>-CURRENT</a> et <a href=./#stable>-STABLE</a> peut facilement être dupliquée sur votre propre machine. Reportez-vous à la section <a href=./#synching>Synchroniser votre arborescence des sources</a> pour plus d’informations sur la façon de procéder.</p></dd><dt class=hdlist1>La liste des personnes autorisées, les "committers"<a id=development-committers></a></dt><dd><p>Les personnes autorisées (<em>committers</em>) sont celles qui ont les droits en <em>écriture</em> sur l’arborescence CVS, et sont autorisées à faire des modifications dans les sources de FreeBSD (le terme "committer" vient de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> <code>commit</code>, que l’on utilise pour reporter des modifications dans les archives CVS). La meilleure façon de proposer des modifications pour qu’elles soient validées par les "committers" est d’utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. S’il semble y avoir un problème dans ce système, vous pouvez aussi les joindre en envoyant un courrier électronique à liste de diffusion pour les committers de FreeBSD.</p></dd><dt class=hdlist1>L’équipe de base de FreeBSD<a id=development-core></a></dt><dd><p><em>L’équipe de base de FreeBSD</em> serait l’équivalent du comité de direction si le Projet FreeBSD était une entreprise. La responsabilité principale de l’équipe de base est de s’assurer que le projet, dans son ensemble, fonctionne correctement et va dans la bonne direction. Proposer à des développeurs impliqués et responsables de rejoindre notre groupe de personnes autorisées est une des fonctions de l’équipe de base, ainsi que le recrutement de nouveaux membres de l’équipe de base quand d’autres s’en vont. L’actuelle équipe de base a été élu à partir d’un ensemble de "committers" candidats en Juillet 2006. Des élections ont lieu tous les 2 ans.</p><div class=paragraph><p>Certains membres de l’équipe de base ont aussi leur propre domaine de responsabilité, ce qui signifie qu’il leur est dévolu de veiller à ce qu’une partie significative du système satisfasse aux fonctionnalités annoncées. Pour une liste complète des développeurs FreeBSD et de leurs domaines de responsabilité, veuillez consulter la <a href=https://docs.freebsd.org/en/articles/contributors/>liste des participants au projet</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La plupart des membres de l’équipe de base sont volontaires en ce qui concerne le développement de FreeBSD et ne retirent aucun profit financier du projet, donc "implication" ne doit pas être compris "support garanti". La comparaison précédente avec un comité directeur n’est pas tout à fait exacte, et il serait plus juste de dire que ce sont des gens qui ont sacrifié leur vie à FreeBSD contre toute raison!</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>Contributions extérieures</dt><dd><p>Enfin, mais certainement pas des moindres, le groupe le plus important de développeurs est constitué par les utilisateurs eux-mêmes qui nous fournissent de façon quasi régulière leur retour d’expérience et leurs corrections de bogues. Le principal moyen d’entrer en contact avec le développement plus décentralisé de FreeBSD est de s’inscrire sur la <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>liste de diffusion pour les discussions techniques sur FreeBSD</a> où ces questions sont abordées. Voyez <a href=./#eresources>Ressources sur Internet</a> pour plus d’informations concernant les diverses listes de discussion FreeBSD.</p><div class=paragraph><p>La <a href=https://docs.freebsd.org/en/articles/contributors/>liste</a> de ceux qui ont contribué au projet est longue et en augmentation, pourquoi donc ne pas vous y joindre et contribuer à quelque chose en retour dès aujourd’hui?</p></div><div class=paragraph><p>Fournir du code n’est pas la seule manière de contribuer au projet; pour avoir une liste plus complète de ce qu’il y a à faire, voyez s’il vous plaît le <a href=https://www.FreeBSD.org/>site du projet FreeBSD</a>.</p></div></dd></dl></div><div class=paragraph><p>En résumé, notre modèle de développement est organisé comme un ensemble relâché de cercles concentriques. Ce modèle centralisé est en place pour la commodité des <em>utilisateurs</em> de FreeBSD, qui disposent ainsi d’un moyen facile de suivre l’évolution d’une base de code centrale, et non pour tenir à l’écart d’éventuels participants! Nous souhaitons fournir un système d’exploitation stable avec un nombre conséquent de <a href=./#ports>programmes d’application</a> cohérents que les utilisateurs puissent facilement installer et employer - c’est un modèle qui fonctionne très bien pour cela.</p></div><div class=paragraph><p>Tout ce que nous attendons de ceux qui se joindraient à nous pour développer FreeBSD est un peu de la même implication que les développeurs actuels ont vis-à-vis de sa réussite continue!</p></div></div><div class=sect3><h4 id=relnotes>1.3.4. A propos de cette version<a class=anchor href=#relnotes></a></h4><div class=paragraph><p>FreeBSD est une version librement disponible et incluant tout le code source basé sur 4.4BSD-Lite2 pour les ordinateurs à architectures Intel i386™, i486™, Pentium®, Pentium® Pro, Celeron®, Pentium® II, Pentium® III, Pentium® 4 (ou compatible), Xeon™, DEC Alpha™ et systèmes basés sur UltraSPARC® de Sun. Il est basé essentiellement sur du logiciel du groupe CSRG de l’Université de Californie à Berkeley, avec des additions venant de NetBSD, OpenBSD, 386BSD, et de la "Free Software Foundation".</p></div><div class=paragraph><p>Depuis la publication de FreeBSD 2.0 fin 1994, les performances, fonctionnalités et la stabilité de FreeBSD ont été améliorées de façon spectaculaire. La plus grosse modification est un gestionnaire de mémoire virtuelle totalement revu qui comprend un cache commun au disque et à la mémoire virtuelle, qui n’améliore pas seulement les performances, mais diminue aussi l’occupation de la mémoire, de telle sorte qu’une configuration avec 5 MO devienne un minimum acceptable. D’autres ajouts concernent le support intégral des clients et serveurs NIS, le support des transactions TCP, les connexions PPP à la demande, le support intégré DHCP, un sous-système SCSI amélioré, support ISDN, support pour l’ATM, FDDI, les cartes "Fast et Gigabit Ethernet" (1000 Mbit), un meilleur support des derniers contrôleurs Adaptec et des milliers de corrections de bogues.</p></div><div class=paragraph><p>En plus du système lui-même, FreeBSD offre un nouveau catalogue de logiciels portés ("ports") qui inclut des milliers de programmes habituellement demandés. A l’heure où sont écrites ces lignes il y avait plus de 36000 logiciels portés! La liste va des serveurs HTTP (WWW) aux jeux, langages, éditeurs et presque tout ce qui existe entre. Le catalogue complet des logiciels demande près de 3 GB d’espace disque, les portages se présentant sous forme de "delta" avec les sources d’origine. Cela rend leur mise à jour bien plus facile, et diminue de façon sensible l’espace nécessaire par rapport à l’ancien catalogue 1.0. Pour compiler un logiciel porté, il vous suffit d’aller dans le répertoire du programme que vous désirez installer, de taper <code>make install</code>, et de laisser le système faire le reste. La distribution originale complète de chaque logiciel est chargée dynamiquement depuis le CDROM ou un site FTP proche, il vous suffit de disposer de suffisamment d’espace disque pour compiler le logiciel que vous voulez. Presque tous les logiciels sont aussi fournis sous forme pré-compilée ("package"-paquetage) qui peut être installé avec une seule commande (<code>pkg_add</code>), si vous ne voulez pas les compiler à partir des sources. Plus d’information sur les paquetages et les logiciels portés peut être trouvée dans le <a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés.</a>.</p></div><div class=paragraph><p>Il y a un certain nombre d’autres documents qui vous serons peut-être très utiles à l’installation et à l’utilisation de FreeBSD, que vous pouvez maintenant trouver dans le répertoire <span class=filename>/usr/shared/doc</span> de n’importe quelle machine sous une version récente de FreeBSD. Vous pouvez consulter les manuels localement disponibles avec n’importe quel navigateur HTML aux URLs suivantes:</p></div><div class=dlist><dl><dt class=hdlist1>Le Manuel FreeBSD</dt><dd><p><a href=file://localhost/usr/shared/doc/handbook/index.html>/usr/shared/doc/handbook/index.html</a></p></dd><dt class=hdlist1>La FAQ de FreeBSD</dt><dd><p><a href=file://localhost/usr/shared/doc/faq/index.html>/usr/shared/doc/faq/index.html</a></p></dd></dl></div><div class=paragraph><p>Vous pouvez aussi consulter les exemplaires originaux (et les plus souvent mis à jour) sur <a href=http://www.FreeBSD.org/>http://www.FreeBSD.org</a>.</p></div></div></div></div></div><div class=sect1><h2 id=bsdinstall>Chapitre 2. Installing FreeBSD<a class=anchor href=#bsdinstall></a></h2><div class=sectionbody><div class=sect2><h3 id=bsdinstall-synopsis>2.1. Synopsis<a class=anchor href=#bsdinstall-synopsis></a></h3><div class=paragraph><p>En fonction de l’environnement utilisé, il existe plusieurs manières différentes pour obtenir un FreeBSD en mesure de fonctionner. Il existe des:</p></div><div class=ulist><ul><li><p>Images de machines virtuelles, à télécharger et à importer dans l’environnement virtuel de votre choix. Elles peuvent être récupérées à partir de la page <a href=https://www.freebsd.org/where/>Download FreeBSD</a>. Il existe des images pour KVM ("qcow2"), VMWare ("vmdk"), Hyper-V ("vhd"), ainsi que des images disque brutes ("raw") qui sont universellement supportées. Ce ne sont pas des images d’installation, mais plutôt des instances préconfigurées ("déjà installées"), prêtes à fonctionner et à effectuer les tâches de post-installation.</p></li><li><p>Images de machines virtuelles disponibles sur les plateformes Amazon <a href=https://aws.amazon.com/marketplace/pp/B07L6QV354>AWS Marketplace</a>, <a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps?search=freebsd&amp;page=1">Microsoft Azure Marketplace</a>, et <a href=https://console.cloud.google.com/marketplace/details/freebsd-cloud/freebsd-12>Google Cloud Platform</a>, à exécuter sur leurs services d’hébergement respectifs. Pour plus d’information sur le déploiement de FreeBSD sur Azure, veuillez consulter le chapitre correspondant de la <a href=https://docs.microsoft.com/en-us/azure/virtual-machines/linux/freebsd-intro-on-azure>Documentayion Azure</a>.</p></li><li><p>Images disque de cartes SD, pour les systèmes embarqués comme le Raspberry Pi ou le BeagleBone Black. Elles peuvent être téléchargées à partir de la page <a href=https://www.freebsd.org/where/>Download FreeBSD</a>. Ces fichiers doivent être décompressés et écrits sur une carte SD, comme un fichier d’image disque brut, à partir de laquelle la carte embarquée pourra démarrer.</p></li><li><p>Images disque d’installation, pour installer FreeBSD sur un disque dur pour les ordinateurs de bureau, ordinateurs portables ou les systèmes serveurs.</p></li></ul></div><div class=paragraph><p>Le reste de ce chapitre décrit les quatre cas, en expliquant comment installer FreeBSD en utilisant un programme d’installation en mode texte appelé bsdinstall.</p></div><div class=paragraph><p>Par défaut, les instructions d’installation de ce chapitre sont écrites pour les architectures i386™ et AMD64. Où elles seront applicables, des instructions spécifiques à d’autres architectures seront indiquées. Il peut y avoir des différences mineures entre le programme d’installation et ce qui est montré ici, aussi il faut utiliser ce chapitre comme un guide général plutôt qu’une suite d’instructions à suivre à la ligne près.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les utilisateurs préférant installer FreeBSD à l’aide d’un programme d’installation graphique peuvent être intéressés par <a href=https://ghostbsd.org>GhostBSD</a>, <a href=https://www.midnightbsd.org>MidnightBSD</a> ou <a href=https://www.nomadbsd.org>NomadBSD</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>La configuration matérielle minimale nécessaire et les architectures matérielles supportées par FreeBSD.</p></li><li><p>Comment créer le support d’installation de FreeBSD.</p></li><li><p>Comment lancer bsdinstall.</p></li><li><p>Les questions que bsdinstall posera, ce qu’elles signifient, et comment y répondre.</p></li><li><p>Comment dépanner une installation qui a échoué.</p></li><li><p>Comment accéder à la version "live" de FreeBSD avant d’effectuer une installation.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Lire la liste du matériel supporté fournie avec la version de FreeBSD qui va être installée, et vérifier que le matériel du système est supporté.</p></li></ul></div></div><div class=sect2><h3 id=bsdinstall-hardware>2.2. Configuration matérielle minimale<a class=anchor href=#bsdinstall-hardware></a></h3><div class=paragraph><p>La configuration minimale pour installer FreeBSD varie avec l’architecture matérielle concernée. Les architectures matérielles et les périphériques supportés par une version de FreeBSD sont listés sur la page d’<a href=https://www.FreeBSD.org/releases/>Information sur les versions de FreeBSD</a>. La page de <a href=https://www.FreeBSD.org/where/>Téléchargement de FreeBSD</a> donne également des recommandations pour le choix de l’image correcte pour les différentes architectures/</p></div><div class=paragraph><p>Une installation de FreeBSD nécessite un minimum de 96 Mo de RAM et 1.5 Go d’espace libre sur le disque dur. Néanmoins, des quantités aussi faibles de mémoire et d’espace disque ne sont réellement utilisables que pour des applications particulières comme les applications embarquées. Un ordinateur d’usage général aura besoin de plus de ressources. 2-4 Go de RAM et au moins 8 Go d’espace disque sont un bon point de départ.</p></div><div class=paragraph><p>Voici les contraintes sur les processeurs pour chaque architecture:</p></div><div class=dlist><dl><dt class=hdlist1>amd64</dt><dd><p>C’est le type de processeur pour ordinateur de bureau et portable le plus courant, utilisé dans les systèmes modernes. Intel® l’appelle Intel64. D’autres fabricants l’appelle parfois x86-64.</p><div class=paragraph><p>Des exemples de processeurs compatibles amd64 comprennent: les AMD Athlon™64, AMD Opteron™, Intel® Xeon™ multi-coeurs, Intel® Core™ 2 et processeurs suivants.</p></div></dd><dt class=hdlist1>i386</dt><dd><p>Les ordinateurs de bureau et portables plus anciens utilisent souvent cette architecture x86 32bits.</p><div class=paragraph><p>Presque tous les processeurs compatibles i386 avec une unité de calcul en virgule flottante sont supportés. Tous les processeurs Intel® 486 ou supérieurs sont supportés.
Néanmoins, les binaires publiés par le projet sont compilés pour le
processeur 686, une version spécifiquement compilée sera nécessaire pour
les systèmes 486 et 586.</p></div><div class=paragraph><p>FreeBSD utilisera le support de l’extension d’adresse physique ("Physical Address Extensions" ou PAE) sur les CPUs avec cette fonctionnalité. Un noyau avec la fonctionnalité PAE activée détectera la mémoire au-dessus de 4 Go et permettra son utilisation par le système. Néanmoins, utiliser PAE ajoutera des contraintes aux pilotes de périphériques et à d’autres fonctionnalités de FreeBSD.</p></div></dd><dt class=hdlist1>arm64</dt><dd><p>La plupart des cartes embarquées sont des systèmes à base d’ARM 64bits.
De nombreux serveurs arm64 sont supportés.</p></dd><dt class=hdlist1>arm</dt><dd><p>Les anciennes cartes armv7 sont supportées.</p></dd><dt class=hdlist1>powerpc</dt><dd><p>Tous les systèmes Apple® Mac® utilisant une ROM"New World" avec l’USB intégré sont supportés. Le fonctionnement SMP (multi-processeurs) est supporté sur les machines dotées de plusieurs CPUs.</p><div class=paragraph><p>Un noyau 32bits ne peut utiliser que les 2 premiers Go de RAM.</p></div></dd></dl></div></div><div class=sect2><h3 id=bsdinstall-pre>2.3. Tâches de pré-installation<a class=anchor href=#bsdinstall-pre></a></h3><div class=paragraph><p>Une fois déterminé que le système répond bien aux exigences minimales en termes de matériel pour installer FreeBSD, le fichier d’installation devrait être téléchargé et le support d’installation préparé. Avant de faire cela, vérifier que le système est prêt pour une installation en vérifiant les différents éléments de la liste de contrôle suivante:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Sauvegarder les données importantes</p><div class=paragraph><p>Avant d’installer tout système d’exploitation, il faut <em>toujours</em> en premier sauvegarder toutes les données importantes. Ne pas stocker la sauvegarde sur le système sur lequel aura lieu l’installation. A la place, sauvegarder les données sur un disque amovible comme un disque USB, sur un autre système sur le réseau, ou sur un système de sauvegarde en ligne. Tester la sauvegarde avant de lancer l’installation afin de s’assurer qu’elle contient tous les fichiers nécessaires. Quand le programme d’installation formate le disque du système, toutes les données stockées sur ce disque seront perdues.</p></div></li><li><p>Où installer FreeBSD?</p><div class=paragraph><p>Si FreeBSD sera le seul système d’exploitation installé, cette étape peut être passée. Mais si FreeBSD partagera le disque avec un autre système d’exploitation, choisir quel disque ou partition sera utilisée pour FreeBSD.</p></div><div class=paragraph><p>Dans les architectures i386 et amd64, les disques durs peuvent être divisés en plusieurs partitions en utilisant une des deux méthodes de partitionnement. Le <em>Master Boot Record</em> (MBR) traditionnel contient une table de partitions définissant jusqu’à quatre <em>partitions primaires</em>. Pour des raisons historiques, FreeBSD appelle ces partitions primaires <em>slices</em> ( <em>tranches</em>). Une de ces partitions primaire peut devenir une <em>partition étendue</em> contenant plusieurs <em>partitions logiques</em>. La <em>table de partitionnement GUID</em> (<em>GUID Partition Table</em> ou GPT) est une méthode nouvelle et plus simple pour partitionner un disque. Les implémentations classiques de GPT autorisent jusqu’à 128 partitions par disque, supprimant ainsi le recours à des partitions logiques.</p></div><div class=paragraph><p>Le chargeur d’amorçage de FreeBSD a besoin soit d’une partition primaire soit d’une partition GPT. Si toutes les partitions primaires ou GPT sont déjà utilisées, l’une d’entre elles devra être libérée pour FreeBSD. Pour créer une partition sans effacer les données existantes, utiliser un outil de redimensionnement de partition pour réduire une partition existante et créer une nouvelle partition en utilisant l’espace libéré.</p></div><div class=paragraph><p>De nombreux outils de partionnement gratuits et commerciaux sont listés sur <a href=http://en.wikipedia.org/wiki/List_of_disk_partitioning_software>http://en.wikipedia.org/wiki/List_of_disk_partitioning_software</a>. GParted Live (<a href=http://gparted.sourceforge.net/livecd.php>http://gparted.sourceforge.net/livecd.php</a>) est un CD Live gratuit qui comprend l’éditeur de partition GParted. GParted est également disponible sur d’autres CDs Live Linux.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Utilisés correctement, les outils de redimensionnement des disques peuvent créer, sans risque, l’espace nécessaire pour la création d’une nouvelle partition. Etant donnée que la possibilité de sélectionner la mauvaise partition existe, effectuer toujours une sauvegarde des données importantes et vérifier son intégrité avant de modifier les partitions du disque.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Disposer de différentes partitions contenant chacune un système d’exploitation différent rend possible l’installation de plusieurs systèmes d’exploitation sur un ordinateur. Une autre méthode est d’utiliser la virtualisation (<a href=./#virtualization>Virtualisation</a>) qui permet l’exécution simultanée de plusieurs systèmes d’exploitation sans avoir à modifier les partitions du disque dur.</p></div></li><li><p>Récupérer les informations relatives au réseau</p><div class=paragraph><p>Certaines méthodes d’installation de FreeBSD requièrent une connexion réseau pour télécharger les fichiers d’installation. Après toute installation, le programme d’installation proposera de configurer les interfaces réseau du système.</p></div><div class=paragraph><p>Si le réseau dispose d’un serveur DHCP, il peut être utilisé pour fournir une configuration réseau automatique. Si la configuration par DHCP n’est pas possible, les informations réseau suivantes pour le système doivent être obtenues auprès de l’administrateur réseau ou du fournisseur d’accès:</p></div><div id=bsdinstall-collect-network-information class="olist loweralpha"><ol class=loweralpha type=a><li><p>Adresse IP</p></li><li><p>Masque de sous-réseau</p></li><li><p>Adresse IP de la passerelle par défaut</p></li><li><p>Nom de domaine du réseau</p></li><li><p>Adresse(s) IP du serveur DNS du réseau</p></li></ol></div></li><li><p>Vérifier l’Errata FreeBSD</p><div class=paragraph><p>Bien que le projet FreeBSD s’efforce de s’assurer que chaque version de FreeBSD soit aussi stable que possible, des bogues peuvent parfois exister. Il est très rare que ces bogues affectent le processus d’installation. Dès que ces problèmes sont découverts et corrigés, ils sont notés dans l’Errata de FreeBSD (<a href=https://www.FreeBSD.org/releases/12.1r/errata/>https://www.freebsd.org/releases/12.1r/errata/</a>) présent sur le site Web de FreeBSD. Vérifier l’errata avant l’installation afin d’être sûr qu’il n’y a pas de problème pouvant affecter l’installation.</p></div><div class=paragraph><p>Les informations sur chaque version, y compris les errata, peuvent être trouvés sur le site web de FreeBSD dans la section d’information sur les différentes versions (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org/releases/</a>).</p></div></li></ol></div></div></div><div class=sect3><h4 id=bsdinstall-installation-media>2.3.1. Préparer le support d’installation<a class=anchor href=#bsdinstall-installation-media></a></h4><div class=paragraph><p>Le programme d’installation FreeBSD n’est pas une application qui peut être exécutée à partir d’un autre système d’exploitation. Au lieu de cela, télécharger un fichier d’installation de FreeBSD, copiez-le sur le support correspondant à sa taille (CD, DVD, ou clé USB) et démarrer le système pour installer à partir du support inséré ou branché sur l’ordinateur.</p></div><div class=paragraph><p>Les fichiers d’installation de FreeBSD sont disponibles sur <a href=https://www.FreeBSD.org/where/#download>www.freebsd.org/where/#download</a>. Chaque nom de fichier d’installation contient le numéro de la version de FreeBSD, l’architecture et le type de fichier. Par exemple pour installer FreeBSD 12.1 sur un système amd64 à partir d’un DVD, téléchargez <span class=filename>FreeBSD-12.1-RELEASE-amd64-dvd1.iso</span>, gravez ce fichier sur un DVD, et démarrer le système avec le DVD inséré.</p></div><div class=paragraph><p>Les fichiers d’installation sont disponibles dans différents formats. Les formats varient en fonction de l’architecture matérielle et du type de support.</p></div><div id=bsdinstall-installation-media-uefi class=paragraph><p>Des fichiers d’installation supplémentaires sont prévus pour les ordinateurs qui sont amorcés par UEFI (Unified Extensible Firmware Interface pour "Interface micrologicielle extensible unifiée"). Le nom de ces fichiers comprend la chaîne de caractères <span class=filename>uefi</span>.</p></div><div class=paragraph><p>Types de fichiers:</p></div><div class=ulist><ul><li><p><code>-bootonly.iso</code>: C’est le plus petit fichier d’installation car il ne contient que le programme d’installation. Une connexion à Internet fonctionnelle est requise lors de l’installation puisque le programme d’installation téléchargera les fichiers nécessaires pour effectuer l’installation de FreeBSD. Ce fichier doit être gravé sur un CD en utilisant une application de gravure de CDs.</p></li><li><p><code>-disc1.iso</code>: Ce fichier contient tous les fichiers nécessaires pour installer FreeBSD, ses sources, et le catalogue des logiciels portés. Il doit être gravé sur un CD en utilisant une application de gravure de CDs.</p></li><li><p><code>-dvd1.iso</code>: Ce fichier contient tous les fichiers nécessaires pour installer FreeBSD, ses sources, et le catalogue des logiciels portés. Il contient également un ensemble de paquetages binaires populaires pour installer un gestionnaire de fenêtres et des applications de manière à ce qu’un système complet puisse être installé sans nécessiter une connexion à Internet. Ce fichier être gravé sur un DVD en utilisant une application de gravure de DVDs.</p></li><li><p><code>-memstick.img</code>: Ce fichier contient tous les fichiers nécessaires pour installer FreeBSD, ses sources, et le catalogue des logiciels portés. Il doit être copié sur une clé USB en suivant les instructions données plus bas.</p></li><li><p><code>-mini-memstick.img</code>: Comme <code>-bootonly.iso</code>, ne contient pas les fichiers d’installation, mais les téléchargera au fur et à mesure des besoins. Une connexion à Internet fonctionnelle est requise lors de l’installation. Copier ce fichier sur une clé USB comme décrit dans <a href=#bsdinstall-usb>Ecrire un fichier image sur un disque USB</a>.</p></li></ul></div><div class=paragraph><p>Après avoir téléchargé le fichier image du support d’installation, téléchargez également le fichier <span class=filename>CHECKSUM.SHA256</span> à partir du même répertoire. Calculez une <em>somme de contrôle</em> ou <em>checksum</em> du fichier image. FreeBSD fournit <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a> à cet effet, à utiliser comme <code>sha256 <em>fichierimage</em></code>. Les autres systèmes d’exploitation proposent des outils similaires.</p></div><div class=paragraph><p>Comparez la somme de contrôle calculée avec celle donnée dans le fichier <span class=filename>CHECKSUM.SHA256</span>. Les sommes de contrôle doivent être identiques. Si une des sommes ne correspond pas, le fichier est corrompu et devra être téléchargé à nouveau.</p></div><div class=sect4><h5 id=bsdinstall-usb>2.3.1.1. Ecrire un fichier image sur un disque USB<a class=anchor href=#bsdinstall-usb></a></h5><div class=paragraph><p>Le fichier <span class=filename>*.img</span> est une <em>image</em> de l’intégralité du contenu d’une clé USB. Il <em>ne peut pas</em> être copié directement vers le périphérique de destination comme un simple fichier. Plusieurs applications existent pour écrire le fichier <span class=filename>*.img</span> sur une clé USB. Cette section décrit deux de ces utilitaires.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Avant de continuer, sauvegardez toutes les données importantes présentes sur la clé USB. Cette procédure effacera toutes les données sur la clé.</p></div></td></tr></tbody></table></div><div id=bsdinstall-usb-dd class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Utiliser <code>dd</code> pour écrire une image</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Cet exemple prend <span class=filename>/dev/da0</span> comme périphérique cible sur lequel l’image sera écrite. Vérifiez que le périphérique utilisé comme cible est bien le bon, car cette commande détruira les données existantes.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>L’utilitaire en ligne de commande <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> est disponible sur les systèmes BSD, Linux®, et Mac OS®. Pour écrire une image en utilisant <code>dd</code>, brancher la clé USB et déterminez son nom de périphérique. Indiquer, alors, le nom du fichier d’installation téléchargé et le nom du périphérique pour la clé USB. Cet exemple écrit le fichier image d’installation amd64 sur le premier périphérique USB sur un système FreeBSD existant.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=FreeBSD-12.1-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync</span></code></pre></div></div><div class=paragraph><p>Si cette commande échoue, vérifier que la clé USB n’est pas montée et que le nom de périphérique est bien celui d’un disque et non d’une partition. Certains systèmes d’exploitation pourront nécessiter l’exécution de cette commande avec <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a>. La syntaxe <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> varie légèrement en fonction des plate-formes; par exemple, Mac OS® a besoin d’un <code>bs=1m</code> en minuscules. Des systèmes comme Linux® pourront mettre en tampon les écritures. Pour forcer toutes les écritures en attente à s’effectuer, utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=sync&amp;sektion=8&amp;format=html">sync(8)</a>.</p></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Utiliser Windows® pour écrire l’image</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Assurez-vous de préciser le bon disque comme cible, car les données existantes sur ce disque seront écrasées et détruites.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>Récupérer Image Writer for Windows®</p><div class=paragraph><p>Image Writer for Windows® est une application gratuite pour écrire une image sur une clé USB. Téléchargez-la depuis <a href=https://sourceforge.net/projects/win32diskimager/>https://sourceforge.net/projects/win32diskimager/</a> et décompressez-la dans un répertoire.</p></div></li><li><p>Ecrire l’image avec Image Writer</p><div class=paragraph><p>Double-cliquez sur l’icone Win32DiskImager pour lancer le programme. Vérifiez que le lecteur affiché sous <code>Device</code> est celui de la clé USB. Cliquer sur l’icone répertoire et sélectionner l’image à écrire sur la clé. Cliquer sur <b class=button>Save</b> pour accepter le nom du fichier image. Vérifiez que tout est correct, et qu’il n’y a pas de répertoires présents sur la clé USB ouverts dans d’autres fenêtres. Puis quand tout est prêt, cliquer sur <b class=button>Write</b> pour écrire le fichier image sur la clé USB.</p></div></li></ol></div></div></div><div class=paragraph><p>Vous êtes maintenant prêt à commencer l’installation de FreeBSD.</p></div></div></div></div><div class=sect2><h3 id=bsdinstall-start>2.4. Lancer l’installation<a class=anchor href=#bsdinstall-start></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Par défaut, le processus d’installation ne modifiera rien sur le(s) disque(s) dur(s) jusqu’au message suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>Your changes will now be written to disk. If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?</pre></div></div><div class=paragraph><p>L’installation peut être quittée à tout moment avant cet avertissement. Si quelque chose a mal été configurée, arrêtez juste l’ordinateur avant ce point, et aucun changement ne sera effectué sur le disque dur.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Cette section décrit comment démarrer le système à partir du support d’installation qui a été préparé à l’aide des instructions de <a href=#bsdinstall-installation-media>Préparer le support d’installation</a>. Pour démarrer avec une clé USB démarrable, brancher la clé USB avant d’allumer l’ordinateur. Pour démarrer avec un CD ou un DVD, allumer l’ordinateur et insérer le disque à la première occasion. Comment configurer le système pour démarrer à partir du support utilisé dépend de l’architure matérielle.</p></div><div class=sect3><h4 id=bsdinstall-starting-i386>2.4.1. Démarrage pour les architectures i386™ et amd64<a class=anchor href=#bsdinstall-starting-i386></a></h4><div class=paragraph><p>Ces architectures disposent d’un menu du BIOS pour sélectionner le périphérique de démarrage. En fonction du support de démarrage choisi, sélectionner le lecteur CD/DVD ou l’USB comme premier périphérique de démarrage. La plupart des systèmes proposent également la sélection du périphérique d’amorçage au démarrage à l’aide d’une touche sans avoir à entrer dans le BIOS. Généralement, la touche est soit <kbd>F10</kbd>, soit <kbd>F11</kbd>, soit <kbd>F12</kbd>, ou encore <kbd>Escape</kbd>.</p></div><div class=paragraph><p>Si l’ordinateur charge le système d’exploitation existant, alors soit:</p></div><div class="olist arabic"><ol class=arabic><li><p>Le support d’installation n’a pas été inséré suffisamment tôt lors du processus de démarrage. Laisser le support inséré, et essayer de redémarrer l’ordinateur.</p></li><li><p>Soit les modifications du BIOS étaient incorrectes ou non-sauvegardées. Vérifier à nouveau que le bon périphérique a été choisi comme premier périphérique de démarrage.</p></li><li><p>Ce système est trop ancien pour supporter l’amorçage à partir du support choisi. Dans ce cas, le gestionnaire de démarrage Plop (<a href=http://www.plop.at/en/bootmanager.html>http://www.plop.at/en/bootmanager.html</a>) peut être utilisé pour démarrer à partir du support sélectionné.</p></li></ol></div></div><div class=sect3><h4 id=_démarrage_pour_larchitecture_powerpc>2.4.2. Démarrage pour l’architecture PowerPC®<a class=anchor href=#_démarrage_pour_larchitecture_powerpc></a></h4><div class=paragraph><p>Sur la plupart des machines, maintenir la touche <kbd>C</kbd> enfoncée lors du démarrage provoquera l’amorçage du CD. Sinon appuyez sur <span class=keyseq><kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span>, ou <span class=keyseq><kbd>Windows</kbd>+<kbd>Alt</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span> dans le cas des claviers non-Apple®. A l’invite <code>0</code>, entrez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nb>cd</span>:,<span class=se>\p</span>pc<span class=se>\l</span>oader <span class=nb>cd</span>:0</code></pre></div></div></div><div class=sect3><h4 id=bsdinstall-view-probe>2.4.3. Menu d’amorçage FreeBSD<a class=anchor href=#bsdinstall-view-probe></a></h4><div class=paragraph><p>Une fois le système démarré à partir du support d’installation, un menu similaire au suivant sera affiché:</p></div><div id=bsdinstall-newboot-loader-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-newboot-loader-menu.png alt="bsdinstall newboot loader menu"></div><div class=title>Figure 1. Menu du chargeur FreeBSD</div></div><div class=paragraph><p>Par défaut, le menu attendra dix secondes une saisie de l’utilisateur avant de démarrer dans le programme d’installation de FreeBSD ou, si FreeBSD est déjà installé, avant de démarrer sous FreeBSD. Pour mettre en pause ce décompte afin d’examiner les options offertes, appuyer sur <kbd>Espace</kbd>. Pour sélectionner une option, appuyer sur le chiffre, le caractère ou la touche en surbrillance. Les options disponibles sont les suivantes.</p></div><div class=ulist><ul><li><p><code>Boot Multi User</code> (Démarrage en mode multi-utilisateur): Cette option provoquera la poursuite du processus de démarrage de FreeBSD. Si le décompte du démarrage a été mis en pause, appuyer sur <kbd>1</kbd>, <kbd>B</kbd> majuscule ou minuscule, ou encore <kbd>Entrée</kbd>.</p></li><li><p><code>Boot Single User</code> (Démarrage en mode mono-utilisateur): Ce mode peut être employé pour réparer une installation de FreeBSD existante comme décrit dans la <a href=./#boot-singleuser>Mode mono-utilisateur</a>. Appuyer sur <kbd>2</kbd> ou <kbd>B</kbd> majuscule ou minuscule pour entrer dans ce mode.</p></li><li><p><code>Escape to loader prompt</code> (Quitter vers l’interpréteur de commandes du chargeur): Cela démarrera le système dans l’interpréteur de commandes du chargeur qui offre un nombre limité de commandes bas-niveau. Cette invite de commandes est abordée dans la <a href=./#boot-loader>Etape trois</a>. Appuyer sur <kbd>3</kbd> ou <kbd>Echap</kbd> pour démarrer dans ce mode.</p></li><li><p><code>Reboot</code>: Redémarre le système.</p></li><li><p><code>Kernel</code>: Charge un noyau différent.</p></li><li><p><code>Configure Boot Options</code>: Ouvre le menu montré et décrit sur la <a href=#bsdinstall-boot-options-menu>Menu des options du chargeur FreeBSD</a>.</p></li></ul></div><div id=bsdinstall-boot-options-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-boot-options-menu.png alt="bsdinstall boot options menu"></div><div class=title>Figure 2. Menu des options du chargeur FreeBSD</div></div><div class=paragraph><p>Le menu des options du chargeur est divisé en deux parties. La première partie peut être utilisée pour soit retourner au menu de démarrage principal soit pour réinitialiser les options à leur valeur par défaut.</p></div><div class=paragraph><p>La partie suivante est utilisée pour positionner les options disponibles sur <code>On</code> ou <code>Off</code> en appuyant sur le chiffre ou le caractère en surbrillance pour chaque option. Le système démarre toujours en utilisant le paramétrage choisi pour ces options jusqu’à ce qu’il soit modifié. Plusieurs options peuvent être modifées en utilisant ce menu:</p></div><div class=ulist><ul><li><p><code>ACPI Support</code>: Si le système se fige au démarrage, essayer de positionner cette option à <code>Off</code>.</p></li><li><p><code>Safe Mode</code>: Si le système se fige toujours durant le démarrage même avec l’option <code>ACPI Support</code> à <code>Off</code>, essayer de positionner cette option à <code>On</code>.</p></li><li><p><code>Single User</code> (Mono-utilisateur): Positionner cette option sur <code>On</code> pour réparer une installation existante de FreeBSD comme décrit dans la <a href=./#boot-singleuser>Mode mono-utilisateur</a>. Une fois le problème réglé, repositionner l’option à <code>Off</code>.</p></li><li><p><code>Verbose</code> (Verbeux): Positionner cette option sur <code>On</code> pour voir des messages plus détaillés lors du processus de démarrage. Cela peut être utile pour dépanner un matériel.</p></li></ul></div><div class=paragraph><p>Après avoir effectué les sélections nécessaires, appuyer sur <kbd>1</kbd> ou <kbd>Retour arrière</kbd> pour retourner au menu de démarrage principal, puis appuyer sur <kbd>Entrée</kbd> pour démarrer sous FreeBSD. Une série de messages de démarrage apparaîtra au fur et à mesure que FreeBSD détectera le matériel et chargera le programme d’installation. Une fois le démarrage achevé, le menu d’accueil de la <a href=#bsdinstall-choose-mode>Menu d’accueil</a> sera affiché.</p></div><div id=bsdinstall-choose-mode class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-choose-mode.png alt="bsdinstall choose mode"></div><div class=title>Figure 3. Menu d’accueil</div></div><div class=paragraph><p>Appuyer sur <kbd>Enter</kbd> pour sélectionner <b class=button>Install</b> pour entrer dans le programme d’installation. Le reste de ce chapitre décrit comment utiliser ce programme d’installation. Sinon, utiliser la flèche droite ou gauche ou les lettres colorées pour sélectionner l’élément désiré. <b class=button>Shell</b> peut être sélectionné pour accéder à un interpréteur de commandes FreeBSD afin d’utiliser des utilitaires en ligne de commande pour préparer les disques avant l’installation. L’option <b class=button>Live CD</b> peut être employée pour tester FreeBSD avant de l’installer. Cette option est décrite dans la <a href=#using-live-cd>Utilisation du CD Live</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Pour relire les messages de démarrage, dont la détection du matériel, appuyer sur la touche <kbd>S</kbd> majuscule ou minuscule, puis sur <kbd>Entrée</kbd> pour accéder à un interpréteur de commandes. A l’invite, taper <code>more /var/run/dmesg.boot</code> et utiliser la barre d’espace pour faire défiler les messages. Une fois terminé, taper <code>exit</code> pour revenir au menu d’accueil.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=using-bsdinstall>2.5. Utilisation de bsdinstall<a class=anchor href=#using-bsdinstall></a></h3><div class=paragraph><p>Cette section présente dans l’ordre les menus de bsdinstall et le type d’information qui sera demandé avant l’installation du système. Utiliser les touches fléchées pour sélectionner un menu, et ensuite la touche <kbd>Espace</kbd> pour sélectionner ou déselectionner cet élément du menu. Une fois terminé, utiliser <kbd>Enter</kbd> pour sauvegarder la sélection et passer à l’écran suivant.</p></div><div class=sect3><h4 id=bsdinstall-keymap>2.5.1. Sélectionner le menu des tables de clavier<a class=anchor href=#bsdinstall-keymap></a></h4><div class=paragraph><p>Avant de démarrer le processus d’installation, bsdinstall chargera les fichiers de tables de clavier comme indiqué dans <a href=#bsdinstall-keymap-loading>Chargement de la table de clavier</a>.</p></div><div id=bsdinstall-keymap-loading class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-loading.png alt="bsdinstall keymap loading"></div><div class=title>Figure 4. Chargement de la table de clavier</div></div><div class=paragraph><p>Après le chargement des tables de clavier, bsdinstall affiche le menu montré sur <a href=#bsdinstall-keymap-10>Menu de sélection de la table de clavier</a>. Utilisez les flèches haut et bas pour choisir la table de clavier la plus proche de celle du clavier relié au système. Appuyer sur <kbd>Enter</kbd> pour sauvegarder la sélection.</p></div><div id=bsdinstall-keymap-10 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-10.png alt="bsdinstall keymap 10"></div><div class=title>Figure 5. Menu de sélection de la table de clavier</div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Un appui sur <kbd>Echap</kbd> provoquera la sortie de ce menu et l’utilisation de la table par défaut. Si le choix ne semble pas évident, choisir <span class=guimenuitem>United States of America ISO-8859-1</span> est conseillé.</p></div></td></tr></tbody></table></div><div class=paragraph><p>De plus, lors de la sélection d’une table de clavier différente, l’utilisateur peut tester la table et s’assurer qu’elle est correcte avant de prendre en compte le changement comme montré sur <a href=#bsdinstall-keymap-testing>Menu de test de la table de clavier</a>.</p></div><div id=bsdinstall-keymap-testing class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-testing.png alt="bsdinstall keymap testing"></div><div class=title>Figure 6. Menu de test de la table de clavier</div></div></div><div class=sect3><h4 id=bsdinstall-hostname>2.5.2. Configurer le nom de la machine<a class=anchor href=#bsdinstall-hostname></a></h4><div class=paragraph><p>Le menu bsdinstall suivant est utilisé pour configurer le nom de machine à donner au système nouvellement installé.</p></div><div id=bsdinstall-config-hostname class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-hostname.png alt="bsdinstall config hostname"></div><div class=title>Figure 7. Configuration du nom de machine</div></div><div class=paragraph><p>Saisir un nom de machine qui est unique sur le réseau. Cela doit être un nom de machine complet comme <code>machine3.example.com</code></p></div></div><div class=sect3><h4 id=bsdinstall-components>2.5.3. Choisir les composants à installer<a class=anchor href=#bsdinstall-components></a></h4><div class=paragraph><p>Ensuite, bsdinstall demandera de choisir les composants optionnels à installer.</p></div><div id=bsdinstall-config-components class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-components.png alt="bsdinstall config components"></div><div class=title>Figure 8. Sélection des composants à installer</div></div><div class=paragraph><p>Décider quels composants installer dépendra principalement de l’utilisation prévue du système et de l’espace disque disponible. Le noyau FreeBSD et les utilitaires de base, formant ensemble ce que l’on nomme le <em>système de base</em>, sont toujours installés. Selon l’architecture, certains de ces composants peuvent ne pas apparaître:</p></div><div class=ulist><ul><li><p><code>base-dbg</code> - Outils de base comme cat, ls parmi tant d’autres avec les symboles de débogage activés.</p></li><li><p><code>kernel-dbg</code> - Noyau et modules avec les symboles de débogage activés.</p></li><li><p><code>lib32-dbg</code> - Bibliothèques de compatibilité pour l’exécution d’applications 32bits sur une version 64bits de FreeBSD avec les symboles de débogage activés.</p></li><li><p><code>lib32</code> - Bibliothèques de compatibilité pour l’exécution d’applications 32bits sur une version 64bits de FreeBSD.</p></li><li><p><code>ports</code> - Le catalogue des logiciels portés pour FreeBSD.</p><div class=paragraph><p>Le catalogue des logiciels portés est un ensemble de fichiers qui automatise le téléchargement, la compilation et l’installation de logiciels tierce-partie. Le <a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a> discute de l’utilisation du catalogue des logiciels portés.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Le programme d’installation ne vérifie pas la présence de l’espace requis. Sélectionner cette option uniquement si l’espace disque suffisant est disponible. Le catalogue des logiciels portés occupe environ 3 GB d’espace disque.</p></div></td></tr></tbody></table></div></li><li><p><code>src</code> - Code source complet du noyau et du système de base. Bien que n’étant pas requis pour la majorité des applications, il peut être nécessaire pour compiler des pilotes de périphériques, des modules du noyau, ou des applications du catalogue des logiciels portés. Il est également utilisé pour le développement de FreeBSD. L’arborescence complète des sources demande 1 Go d’espace disque, et la recompilation du système FreeBSD complet nécessite 5 Go d’espace supplémentaire.</p></li><li><p><code>tests</code> - Suite d’outils de test pour FreeBSD.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-netinstall>2.5.4. Installation à partir du réseau<a class=anchor href=#bsdinstall-netinstall></a></h4><div class=paragraph><p>Le menu affiché dans <a href=#bsdinstall-netinstall-notify>Installation à partir du réseau</a> n’apparaît que lors de l’installation à partir d’une image <span class=filename>-bootonly.iso</span> ou <span class=filename>-mini-memstick.img</span> étant donné que ces supports d’installation ne contiennent pas de copie des fichiers d’installation. Comme les fichiers d’installation doivent être récupérés par l’intermédiaire d’une connexion réseau, ce menu indique qu’une interface réseau doit être configurée en premier lieu. Si ce menu est affiché à un moment donné de l’installation, pensez à suivre les instructions données dans <a href=#bsdinstall-config-network-dev>Configuration des interfaces réseau</a>.</p></div><div id=bsdinstall-netinstall-notify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-files.png alt="bsdinstall netinstall files"></div><div class=title>Figure 9. Installation à partir du réseau</div></div></div></div><div class=sect2><h3 id=bsdinstall-partitioning>2.6. Allouer l’espace disque<a class=anchor href=#bsdinstall-partitioning></a></h3><div class=paragraph><p>Le menu suivant est utilisé pour déterminer la méthode pour allouer l’espace disque.</p></div><div id=bsdinstall-zfs-partmenu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-partmenu.png alt="bsdinstall zfs partmenu"></div><div class=title>Figure 10. Choix du partitionnement</div></div><div class=paragraph><p>bsdinstall propose à l’utilisateur quatre méthodes pour allouer l’espace disque:</p></div><div class=ulist><ul><li><p>le partitionnement <code>Auto (UFS)</code> fixe automatiquement les partitions disque et utilise le système de fichiers <code>UFS</code>.</p></li><li><p>le partitionnement <code>Manual</code> ("Manuel") permet aux utilisateurs avancés de créer des partitions sur mesures à partir des options du menu.</p></li><li><p><code>Shell</code> ouvre une invite d’interpréteur de commandes dans laquelle les utilisateurs avancés peuvent créer des partitions sur mesures en utilisant des utilitaires en ligne de commande comme <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></li><li><p>le partitionnement <code>Auto (ZFS)</code> créé un système de fichiers racine sur ZFS avec le support optionnel du chiffrement GELI pour les <em>environnements de démarrage</em>.</p></li></ul></div><div class=paragraph><p>Cette section décrit ce qui doit être pris en compte lors du partitionnement du disque. Elle montre ensuite comment utiliser les différentes méthodes de partionnement.</p></div><div class=sect3><h4 id=configtuning-initial>2.6.1. Choix du partitionnement<a class=anchor href=#configtuning-initial></a></h4><div class=paragraph><p>Lors du partitionnement, il faut garder à l’esprit que les disques durs transfèrent les données plus rapidement depuis les pistes extérieures que depuis les pistes intérieures. Aussi, les systèmes de fichiers plus petits et très sollicités devraient être positionnés vers l’extérieur du disque, alors que les partitions plus grandes comme <span class=filename>/usr</span> devraient être placées vers l’intérieur du disque. C’est une bonne idée de créer les partitions dans l’ordre suivant: <span class=filename>/</span>, espace de pagination, <span class=filename>/var</span>, et <span class=filename>/usr</span>.</p></div><div class=paragraph><p>La taille de la partition <span class=filename>/var</span> reflète l’utilisation prévue de la machine. Cette partition est utilisée pour contenir les boîtes aux lettres de messagerie, les fichiers journaux, et les queues d’impression. Les boîtes aux lettres et les fichiers journaux peuvent croître jusqu’à atteindre des tailles inattendues en fonction du nombre d’utilisateurs et combien de temps sont conservés les fichiers journaux. En moyenne, la plupart des utilisateurs n’auront rarement besoin de plus d’un gigaoctet d’espace disque pour <span class=filename>/var</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Parfois, beaucoup d’espace disque est nécessaire pour <span class=filename>/var/tmp</span>. Quand de nouveaux logiciels sont installés, les outils de paquetage extraient une copie temporaire des paquetages dans <span class=filename>/var/tmp</span>. Les logiciels importants comme Firefox, ou LibreOffice peuvent être délicats à installer si l’espace disque dans <span class=filename>/var/tmp</span> n’est pas suffisant.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La partition <span class=filename>/usr</span> contient beaucoup de fichiers nécessaires au système, dont le catalogue des logiciels portés de FreeBSD et le code source du système. Au moins 2 gigaoctets d’espace sont recommandés pour cette partition.</p></div><div class=paragraph><p>Lors du choix de la taille des partitions, gardez à l’esprit les besoins en espace. Manquer d’espace sur une partition alors qu’une autre est à peine utilisée peut être très frustrant.</p></div><div class=paragraph><p>Par principe, votre espace de pagination devrait typiquement avoir une taille double de la quantité de mémoire physique (RAM). Les systèmes avec peu de mémoire RAM pourront avoir de meilleures performances avec beaucoup plus d’espace de pagination. Configurer trop peu d’espace de pagination peut conduire à une certaine inefficacité du code de pagination de la mémoire virtuelle (VM) et peut être à l’origine de problèmes ultérieurement si vous ajoutez plus de mémoire à votre système.</p></div><div class=paragraph><p>Sur des systèmes importants avec de multiples disques SCSI ou de multiples disques IDE fonctionnant sur différents contrôleurs, il est vivement recommandé que vous configuriez un espace de pagination sur chaque disque, jusqu’à quatre disques. Les partitions de pagination sur les différents disques devront avoir approximativement la même taille. Le noyau peut gérer des tailles arbitraires mais les structures de données internes sont dimensionnées pour 4 fois la taille de la plus grande partition de pagination. Garder la taille des partitions de pagination proche permettra au noyau de répartir de manière optimale l’espace de pagination entre les disques. Des espaces de pagination importants ne sont pas problématiques, même s’ils sont peu utilisés. Il peut être plus simple de récupérer la main face un programme incontrôlable avant d’être forcé à redémarrer la machine.</p></div><div class=paragraph><p>En partitionnant correctement votre système, la fragmentation introduite sur les partitions plus petites et plus chargées en écriture ne s’étendra pas sur les partitions principalement utilisées en lecture. De plus, avoir les partitions principalement utilisées en écriture proche du bord du disque augmentera les performances d’E/S sur les partitions qui le demandent le plus. Bien qu’il soit nécessaire d’avoir de bonnes performances d’E/S sur les grandes partitions, les déplacer plus vers l’extérieur du disque ne donnera pas lieu à une augmentation significative des performances alors que le déplacement de performances alors que le déplacement de <span class=filename>/var</span> vers le bord peut avoir un sérieux impact.</p></div></div><div class=sect3><h4 id=bsdinstall-part-guided>2.6.2. Partitionnement guidé avec utilisation d’UFS<a class=anchor href=#bsdinstall-part-guided></a></h4><div class=paragraph><p>Quand cette méthode est sélectionnée, un menu affichera le(s) disque(s) disponible(s). Si plusieurs disques sont connectés, choisissez celui sur lequel FreeBSD doit être installé.</p></div><div id=bsdinstall-part-guided-disk class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-disk.png alt="bsdinstall part guided disk"></div><div class=title>Figure 11. Sélection parmi plusieurs disques</div></div><div class=paragraph><p>Une fois le disque sélectionné, le menu suivant demande si l’installation se fait soit sur l’intégralité du disque soit sur une partition à créer à partir de l’espace libre. Si <b class=button>Entire Disk</b> est sélectionné, une partition recouvrant la totalité du disque est automatiquement créée. Sélectionner <b class=button>Partition</b> créé une partition dans l’espace inutilisé du disque.</p></div><div id=bsdinstall-part-entire-part class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-entire-part.png alt="bsdinstall part entire part"></div><div class=title>Figure 12. Sélection de l’intégralité du disque ou d’une partition</div></div><div class=paragraph><p>Après la sélection de <b class=button>Entire Disk</b>, bsdinstall affiche une boîte de dialogue indiquant que le disque va être effacé.</p></div><div id=bsdinstall-ufs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-ufs-warning.png alt="bsdinstall ufs warning"></div><div class=title>Figure 13. Confirmation</div></div><div class=paragraph><p>Le menu suivant montre une liste avec les différents types d’organisation des partitions. GPT est généralement le choix le plus adapté pour les ordinateurs de type amd64. Les ordinateurs plus anciens qui ne sont pas compatibles avec GPT devraient utiliser un partionnement de type MBR. Les autres types de partionnement sont généralement utilisés pour les ordinateurs peu courants ou anciens. Plus d’informations sont disponibles dans la <a href=#partition-schemes>Tables de partitionnement</a>.</p></div><div id=bsdinstall-ufs-scheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div><div class=title>Figure 14. Sélection du système de partionnement</div></div><div class=paragraph><p>Une fois l’organisation des partitions créée, vérifiez-la afin de s’assurer qu’elle correspond bien aux besoins de l’installation. La sélection de <b class=button>Revert</b> permettra de revenir au partitionnement de départ, et l’appui sur <b class=button>Auto</b> créera les partitions FreeBSD automatiquement. Les partitions peuvent être créées, modifiées, ou supprimées manuellement. Quand le partitionnement est correct, sélectionner <b class=button>Finish</b> pour poursuivre l’installation.</p></div><div id=bsdinstall-part-review class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-review.png alt="bsdinstall part review"></div><div class=title>Figure 15. Vérification des partitions créées</div></div><div class=paragraph><p>Une fois les disques configurés, le menu suivant offre une dernière chance pour effectuer des modifications avant que les disques sélectionnés ne soient formatés. Si des changements doivent être faits, choisir <b class=button>Back</b> pour retourner dans le menu principal de partionnement. <b class=button>Revert Exit</b> fera quitter le programme d’installation sans qu’aucun changement n’ait été appliqué au disque dur. Sélectionner <b class=button>Commit</b> pour lancer le processus d’installation.</p></div><div id=bsdinstall-final-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-confirmation.png alt="bsdinstall final confirmation"></div><div class=title>Figure 16. Confirmation finale</div></div><div class=paragraph><p>Pour poursuivre le processus d’installation, aller à la <a href=#bsdinstall-fetching-distribution>Récupération des fichiers de distribution</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-manual>2.6.3. Partitionnement manuel<a class=anchor href=#bsdinstall-part-manual></a></h4><div class=paragraph><p>La sélection de cette méthode ouvre l’éditeur de partitions.</p></div><div id=bsdinstall-part-manual-create class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-create.png alt="bsdinstall part manual create"></div><div class=title>Figure 17. Créer manuellement les partitions</div></div><div class=paragraph><p>Sélectionner le disque d’installation(<span class=filename>ada0</span> dans cet exemple) et <b class=button>Create</b> pour afficher un menu sur le choix du type de table de partitionnement.</p></div><div id=bsdinstall-part-manual-partscheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div><div class=title>Figure 18. Créer manuellement les partitions</div></div><div class=paragraph><p>Le partitionnement GPT est généralement le choix le plus approprié pour les ordinateurs de type amd64 Les ordinateurs anciens qui ne sont pas compatibles avec GPT doivent utiliser à la place un partitionnement de type MBR. Les autres systèmes de partitionnement sont en général utilisés pour les ordinateurs plus anciens ou particuliers.</p></div><table id=partition-schemes class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 1. Tables de partitionnement</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Abbréviation</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>APM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Table de partition Apple, utilisée par l’architecture PowerPC®.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>BSD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Partition BSD (<em>BSD Labels</em>) sans MBR, parfois appelée <em>dangerously dedicated mode</em> ou "mode dédié" car les utilitaires disques non-BSD peuvent ne pas la reconnaître.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GPT</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Table de partition GUID (<a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>http://en.wikipedia.org/wiki/GUID_Partition_Table"</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>MBR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Master Boot Record (<a href=http://en.wikipedia.org/wiki/Master_boot_record>http://en.wikipedia.org/wiki/Master_boot_record"</a>).</p></td></tr></tbody></table><div class=paragraph><p>Après avoir choisi et créé le partitionnement, sélectionner à nouveau <b class=button>Create</b> créera les nouvelles partitions. La touche <kbd>Tab</kbd> est utilisée pour déplacer le curseur entre les différents champs.</p></div><div id=bsdinstall-part-manual-addpart class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-addpart.png alt="bsdinstall part manual addpart"></div><div class=title>Figure 19. Créer manuellement les partitions</div></div><div class=paragraph><p>Une installation standard de FreeBSD avec GPT utilise au moins trois partitions:</p></div><div class=ulist><ul><li><p><code>freebsd-boot</code> - Contient le code de démarrage FreeBSD.</p></li><li><p><code>freebsd-ufs</code> - Un système de fichiers UFS FreeBSD.</p></li><li><p><code>freebsd-zfs</code> - Un système de fichiers ZFS FreeBSD. Plus d’informations au sujet de ZFS est disponible dans le <a href=./#zfs>The Z File System (ZFS) <strong>Traduction en Cours </strong></a>.</p></li><li><p><code>freebsd-swap</code> - Espace de pagination pour FreeBSD.</p></li></ul></div><div class=paragraph><p>Consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> pour la description d’autres types de partitions disponibles pour GPT.</p></div><div class=paragraph><p>Des partitions avec plusieurs systèmes de fichiers peuvent être créées et certaines personnes préfèrent une organisation plus traditionnelle avec des partitions séparées pour les systèmes de fichiers <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span>, et <span class=filename>/usr</span>. Consulter <a href=#bsdinstall-part-manual-splitfs>Création d’un système traditionnel de partitions pour systèmes de fichiers séparés</a>, pour un exemple.</p></div><div class=paragraph><p>Les tailles peuvent être entrées avec les abréviations courantes: <em>K</em> for kilooctet, <em>M</em> pour mégaoctets, ou <em>G</em> pour gigaoctets.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Un alignement correct des secteurs sur le disque permet de meilleures performances, et créer des partitions de tailles multiples de 4Koctets permet de s’assurer de l’alignement sur les disques à secteur de 512 octets ou 4Koctets. Généralement, employer des tailles de partition qui sont des multiples d'1M ou 1G est le moyen le plus simple de garantir que chaque partition débute sur un multiple de 4K. Il existe une exception: la partition <em>freebsd-boot</em> ne devrait pas dépasser 512K en raison de limitations du code de démarrage.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Un point de montage est nécessaire si cette partition contiendra un système de fichiers. Si une seule partition UFS unique sera créée, le point de montage devra être <span class=filename>/</span>.</p></div><div class=paragraph><p>Un <code>Label</code> (ou étiquette) est le nom avec lequel la partition sera connue. Les noms ou numéros de disques peuvent varier si le disque est connecté à un contrôleur ou port différent, mais le label de partition ne changera pas. Se référer aux labels plutôt qu’aux noms de disques et numéros de partitions dans les fichiers comme <span class=filename>/etc/fstab</span> rend le système plus tolérant aux changements de matériel. Les labels GPT apparaissent dans le répertoire <span class=filename>/dev/gpt/</span> lorsqu’un disque est attaché au système. Les autres systèmes de partitionnement présentent d’autres possibilités au niveau des labels et leurs labels apparaissent sous différentes répertoires dans <span class=filename>/dev/</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Employez un label unique pour chaque partition pour éviter les conflits avec les labels identiques. Quelques lettres du nom du l’ordinateur, de son rôle, ou de son emplacement peuvent être ajoutées au label. Par exemple, <code>labroot</code> ou <code>rootfslab</code> pour la partition UFS racine de l’ordinateur appelé <code>lab</code>.</p></div></td></tr></tbody></table></div><div id=bsdinstall-part-manual-splitfs class=exampleblock><div class=title>Exemple 1. Création d’un système traditionnel de partitions pour systèmes de fichiers séparés</div><div class=content><div class=paragraph><p>Pour une organisation traditionnelle de partitions dans laquelle les répertoires <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span>, et <span class=filename>/usr</span> sont des systèmes de fichiers séparés ayant chacun leur propre partition, créer une table de partition GPT, puis créer les partitions comme montré ci-après. Les tailles de partitions indiquées sont celles typiques pour un disque de 20G. Si plus d’espace est disponible sur le disque cible, une partition de pagination ou une partition <span class=filename>/var</span> plus importantes peuvent être utiles. Les labels utilisés ici sont préfixés par <code>ex</code> pour "exemple", mais le lecteur peut utiliser un autre label unique comme décrit plus haut.</p></div><div class=paragraph><p>Par défaut, le programme <span class=filename>gptboot</span> de FreeBSD s’attend à ce que la première partition UFS trouvée soit la partition <span class=filename>/</span>.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Type de partition</th><th class="tableblock halign-left valign-top">Taille</th><th class="tableblock halign-left valign-top">Point de montage</th><th class="tableblock halign-left valign-top">Label</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-boot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>512K</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exrootfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-swap</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>4G</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exswap</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exvarfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>1G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>extmpfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>valeur proposée par défaut (le reste du disque)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exusrfs</code></p></td></tr></tbody></table></div></div><div class=paragraph><p>Après la création des partitions, sélectionnez <b class=button>Finish</b> pour poursuivre l’installation et rendez-vous à la <a href=#bsdinstall-fetching-distribution>Récupération des fichiers de distribution</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-zfs>2.6.4. Partitionnement guidé avec la racine du système de fichiers sur ZFS<a class=anchor href=#bsdinstall-part-zfs></a></h4><div class=paragraph><p>Ce mode de partitionnement ne fonctionne qu’avec des disques entiers et effacera le contenu du disque entier. Le menu principal de configuration ZFS présente plusieurs options pour contrôler la création du pool (ensemble de stockage constitué d’un ou plusieurs disques).</p></div><div id=bsdinstall-zfs-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-menu.png alt="bsdinstall zfs menu"></div><div class=title>Figure 20. Menu de partionnement ZFS</div></div><div class=paragraph><p>Voici un résumé des options pouvant être utilisées dans ce menu:</p></div><div class=ulist><ul><li><p><code>Install</code> - Procède à l’installation avec les options sélectionnées.</p></li><li><p><code>Pool Type/Disks</code> - Permet la configuration du <code>Pool Type</code> et des disques qui formeront le pool. Le programme d’installation ZFS automatique ne supporte, actuellement qu’un seul périphérique virtuel ("top level vdev") de niveau supérieur en dehors du mode stripe (un seul disque ou concaténation de plusieurs disques). Pour créer des pools plus complexes, utilisez les instructions de la <a href=#bsdinstall-part-shell>Partitionnement à partir de l’interpréteur de commandes</a> pour créer le pool.</p></li><li><p><code>Rescan Devices</code> - Met à jour la liste des disques disponibles.</p></li><li><p><code>Disk Info</code> - Ce menu peut être utilisé pour inspecter chaque disque, y compris sa table des partitions et différentes autres informations comme la référence du modèle et son numéro de série s’ils sont disponibles.</p></li><li><p><code>Pool Name</code> - Fixe le nom du pool. Le nom par défaut est <em>zroot</em>.</p></li><li><p><code>Force 4K Sectors?</code> - Force l’utilisation de secteurs d’une taille de 4Ko. Par défaut, le programme d’installation créera automatiquement des partitions qui seront alignées sur des emplacements multiples de 4Ko et force ZFS à utiliser des secteurs de 4Ko. C’est sans risque même pour les disques avec des secteurs de 512 octets, et présente l’avantage de s’assurer que les pools créés sur des disques à secteurs de 512 octets pourront se voir ajouter, dans le futur, des disques avec secteurs de 4Ko comme espace de stockage supplémentaire ou en remplacement de disques défectueux. Appuyez sur la touche <kbd>Enter</kbd> pour choisir d’activer ou non cette option.</p></li><li><p><code>Encrypt Disks?</code> - Le chiffrement des disques permet à l’utilisateur de chiffer les disques avec GELI. Plus d’information au sujet du chiffrement des disques est disponible dans la <a href=./#disks-encrypting-geli>Chiffrage des disques avec geli</a>. Appuyez sur la touche <kbd>Enter</kbd> pour choisir d’activer ou non cette option.</p></li><li><p><code>Partition Scheme</code> - Permet de choisir le système de partionnement. GPT est l’option recommandée dans la plupart des cas. Appuyez sur la touche <kbd>Enter</kbd> pour choisir parmi les differentes options.</p></li><li><p><code>Swap Size</code> - Fixe la quantité d’espace de pagination.</p></li><li><p><code>Mirror Swap?</code> - Permet à l’utilisateur de créer un miroir de l’espace de pagination sur chaque disque. Faites attention, activer l’espace de pagination en mode miroir rend les crashs dumps inutilisables. Appuyez sur la touche <kbd>Enter</kbd> pour choisir d’activer ou non cette option.</p></li><li><p><code>Encrypt Swap?</code> - Permet à l’utilisateur de chiffrer l’espace de pagination. Le système chiffre l’espace de pagination avec une clé temporaire à chaque démarrage du système et en change à chaque redémarrage. Appuyez sur la touche <kbd>Enter</kbd> pour choisir d’activer ou non cette option. Plus d’information au sujet du chiffrement de l’espace de pagination dans la <a href=./#swap-encrypting>Chiffrage de l’espace de pagination</a>.</p></li></ul></div><div class=paragraph><p>Sélectionner <kbd>T</kbd> pour configurer le <code>Pool Type</code> et le ou les disques qui constitueront le pool.</p></div><div id=bsdinstall-zfs-vdev_type class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_type.png alt="bsdinstall zfs vdev type"></div><div class=title>Figure 21. Type de pool ZFS</div></div><div class=paragraph><p>Voici un résumé des <code>Pool Type</code> pouvant être sélectionnés dans ce menu:</p></div><div class=ulist><ul><li><p><code>stripe</code> - Le mode striping ou entrelacé offre le maximum d’espace de stockage à partir de l’ensemble des périphériques connectés, mais pas de redondance. Si un seul disque tombe en panne, les données du pool seront perdues de manière définitive.</p></li><li><p><code>mirror</code> - Le mode miroir stocke une copie complète des données sur chaque disque. Le mode miroir offre de bonnes performances en lecture parce que les données sont lues à partir de tous les disques en parallèles. Les performances en écriture sont plus lentes étant donné que les données doivent être écrites sur tous les disques du pool. Ce mode permet à tous les disques sauf un de tomber en panne. Cette option nécessite aux moins deux disques.</p></li><li><p><code>raid10</code> - Miroirs entrelacés. Offre les meilleures performances mais le moins d’espace de stockage. Cette option nécessite un nombre pair de disques et au minimum quatre disques.</p></li><li><p><code>raidz1</code> - RAID à simple redondance. Permet la panne d’un seul disque. Cette option nécessite au moins trois disques.</p></li><li><p><code>raidz2</code> - RAID à double redondance. Permet la panne simultanée de deux disques. Cette option nécessite au moins quatre disques.</p></li><li><p><code>raidz3</code> - RAID à triple redondance. Permet la panne simultanée de trois disques. Cette option nécessite au moins cinq disques.</p></li></ul></div><div class=paragraph><p>Une fois que le <code>Pool Type</code> a été sélectionné, la liste des disques disponibles est affichée, et l’utilisateur est invité à choisir un ou plusieurs disques pour former le pool. La configuration doit être alors validée pour s’assurer que suffisamment de disques ont été sélectionnés. Si ce n’est pas le cas, sélectionner <b class=button>Change Selection</b> pour retourner à la liste des disques, ou <b class=button>Back</b> pour changer de <code>Pool Type</code>.</p></div><div id=bsdinstall-zfs-disk_select class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_select.png alt="bsdinstall zfs disk select"></div><div class=title>Figure 22. Sélection de disques</div></div><div id=bsdinstall-zfs-vdev_invalid class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_invalid.png alt="bsdinstall zfs vdev invalid"></div><div class=title>Figure 23. Sélection non-valide</div></div><div class=paragraph><p>Si un ou plusieurs disques manquent sur la liste, ou si des disques ont été ajoutés après le lancement du programme d’installation, sélectionner <b class=button>- Rescan Devices</b> pour mettre à jour la liste des disques disponibles.</p></div><div id=bsdinstall-zfs-rescan-devices class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-rescan-devices.png alt="bsdinstall zfs rescan devices"></div><div class=title>Figure 24. Recherche des périphériques</div></div><div class=paragraph><p>Pour éviter d’effacer par accident les mauvais disques, le menu <b class=button>- Disk Info</b> peut être utilisé pour inspecter chaque disque, y compris sa table des partitions et plusieurs autres informations comme le modèle de disque et son numéro de série si disponibles.</p></div><div id=bsdinstall-zfs-disk_info class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_info.png alt="bsdinstall zfs disk info"></div><div class=title>Figure 25. Analyse d’un disque</div></div><div class=paragraph><p>Sélectionnez <kbd>N</kbd> pour configurer le <code>Pool Name</code>. Entrez le nom souhaité puis sélectionnez <b class=button>OK</b> pour le prendre en compte ou <b class=button>Cancel</b> pour retourner au menu principal et conserver le nom par défaut.</p></div><div id=bsdinstall-zfs-pool-name class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-pool-name.png alt="bsdinstall zfs pool name"></div><div class=title>Figure 26. Nom du Pool</div></div><div class=paragraph><p>Sélectionnez <kbd>S</kbd> pour fixer la quantité d’espace de pagination. Entrez la quantité souhaitée puis sélectionnez <b class=button>OK</b> pour la prendre en compte ou <b class=button>Cancel</b> pour retourner au menu principal et conserver la quantité par défaut.</p></div><div id=bsdinstall-zfs-swap-amount class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-swap-amount.png alt="bsdinstall zfs swap amount"></div><div class=title>Figure 27. Quantité d’espace de pagination</div></div><div class=paragraph><p>Une fois que toutes les options ont été configurées aux valeurs souhaitées, sélectionnez l’option <b class=button>Install</b> en haut du menu. Le programme d’installation offre alors une dernière chance de tout annuler avant que le contenu des disques sélectionnés ne soit détruit pour créer le pool ZFS.</p></div><div id=bsdinstall-zfs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-warning.png alt="bsdinstall zfs warning"></div><div class=title>Figure 28. Dernière chance</div></div><div class=paragraph><p>Si le chiffrement GELI du disque a été activé, le programme d’installation demandera deux fois le mot de passe à utiliser pour chiffrer les disques. Ensuite, après cela, l’initialisation du chiffrement commence.</p></div><div id=bsdinstall-zfs-geli_password class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-geli_password.png alt="bsdinstall zfs geli password"></div><div class=title>Figure 29. Mot de passe de chiffrement des disques</div></div><div id=bsdinstall-zfs-init-encription class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-init-encription.png alt="bsdinstall zfs init encription"></div><div class=title>Figure 30. Initialisation du chiffrement</div></div><div class=paragraph><p>L’installation se poursuit alors normalement. Pour continuer l’installation, aller à <a href=#bsdinstall-fetching-distribution>Récupération des fichiers de distribution</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-shell>2.6.5. Partitionnement à partir de l’interpréteur de commandes<a class=anchor href=#bsdinstall-part-shell></a></h4><div class=paragraph><p>Dans le cas d’installations complexes, les menus de partitionnement de bsdinstall peuvent ne pas proposer le niveau de flexibilité recherché. Les utilisateurs expérimentés peuvent sélectionner l’option <b class=button>Shell</b> à partir du menu de partitionnement afin de partitionner manuellement les disques, de créer le ou les systèmes de fichiers, d’éditer <span class=filename>/tmp/bsdinstall_etc/fstab</span>, et de monter les systèmes de fichiers sous <span class=filename>/mnt</span>. Une fois cela fait, taper <code>exit</code> pour retourner dans bsdinstall et poursuivre l’installation.</p></div></div></div><div class=sect2><h3 id=bsdinstall-fetching-distribution>2.7. Récupération des fichiers de distribution<a class=anchor href=#bsdinstall-fetching-distribution></a></h3><div class=paragraph><p>La durée de l’installation variera en fonction de la distribution choisie, du support d’installation, et de la vitesse de l’ordinateur. Une série de messages indiquera la progression de l’installation.</p></div><div class=paragraph><p>En premier lieu, le programme d’installation formatera le(s) disque(s) sélectionné(s) et initialisera les partitions. Ensuite, dans le cas d’une installation à partir d’un support <code>bootonly media</code> ou <code>mini memstick</code>, il téléchargera les composants sélectionnés:</p></div><div id=bsdinstall-distfile-fetching class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-fetching.png alt="bsdinstall distfile fetching"></div><div class=title>Figure 31. Récupération des fichiers de distribution</div></div><div class=paragraph><p>Ensuite, l’intégrité des fichiers de distribution est vérifiée pour s’assurer qu’ils n’ont pas été corrompus durant le téléchargement ou leur lecture à partir du support d’installation.</p></div><div id=bsdinstall-distfile-verify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-verifying.png alt="bsdinstall distfile verifying"></div><div class=title>Figure 32. Vérification des fichiers de distribution</div></div><div class=paragraph><p>Enfin, les fichiers contrôlés sont décompressés sur le disque:</p></div><div id=bsdinstall-distfile-extract class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-extracting.png alt="bsdinstall distfile extracting"></div><div class=title>Figure 33. Décompression des fichiers de distribution</div></div><div class=paragraph><p>Une fois que tous les fichiers de distribution requis ont été décompressés, bsdinstall affichera le premier menu de post-installation. Cette série de menu est décrite dans la section suivante.</p></div></div><div class=sect2><h3 id=bsdinstall-post>2.8. Comptes utilisateurs, fuseau horaire, services et renforcement de la sécurité<a class=anchor href=#bsdinstall-post></a></h3><div class=sect3><h4 id=bsdinstall-post-root>2.8.1. Définir le mot de passe de <code>root</code><a class=anchor href=#bsdinstall-post-root></a></h4><div class=paragraph><p>Tout d’abord, le mot de passe de l’utilisateur <code>root</code> doit être défini. Notez que lors de la saisie du mot de passe, les caractères tapés ne sont pas affichés sur l’écran. Après sa saisie, le mot de passe devra être entré une deuxième fois. Cela permet d’éviter les erreurs de frappe.</p></div><div id=bsdinstall-post-set-root-passwd class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-post-root-passwd.png alt="bsdinstall post root passwd"></div><div class=title>Figure 34. Saisie du mot de passe <code>root</code></div></div></div><div class=sect3><h4 id=bsdinstall-timezone>2.8.2. Réglage du fuseau horaire<a class=anchor href=#bsdinstall-timezone></a></h4><div class=paragraph><p>La série de menus suivante permet de déterminer l’heure locale correcte en choisissant la région du monde, le pays et le fuseau horaire. Régler le fuseau horaire permet au système de corriger automatiquement l’heure lors des modifications régionales comme l’heure d’été ou d’hiver, et d’effectuer correctement toute autre modification relative au fuseau horaire.</p></div><div class=paragraph><p>L’exemple présenté ici concerne une machine située dans le fuseau horaire du centre de l’Espagne en Europe. Les choix pourront varier en fonction de la zone géographique.</p></div><div id=bsdinstall-timezone-region class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-region.png alt="bsdinstall timezone region"></div><div class=title>Figure 35. Sélectionner une région</div></div><div class=paragraph><p>La région appropriée est choisie en utilisant les touches flèches puis en appuyant sur <kbd>Entrée</kbd>.</p></div><div id=bsdinstall-timezone-country class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-country.png alt="bsdinstall timezone country"></div><div class=title>Figure 36. Sélection d’un pays</div></div><div class=paragraph><p>Sélectionner le pays approprié en utilisant les touches flèches et appuyer sur <kbd>Entrée</kbd>.</p></div><div id=bsdinstall-timezone-zone class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-zone.png alt="bsdinstall timezone zone"></div><div class=title>Figure 37. Sélection d’un fuseau horaire</div></div><div class=paragraph><p>Le fuseau horaire approprié est choisi en utilisant les touches flèches, puis en appuyant sur <kbd>Entrée</kbd>.</p></div><div id=bsdinstall-timezone-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-confirm.png alt="bsdinstall timezone confirm"></div><div class=title>Figure 38. Confirmation du fuseau horaire</div></div><div class=paragraph><p>Confirmez que l’abréviation pour le fuseau horaire est correcte.</p></div><div id=bsdinstall-timezone-date class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-date.png alt="bsdinstall timezone date"></div><div class=title>Figure 39. Sélection de la date</div></div><div class=paragraph><p>La date correcte est sélectionnée en utilisant les touches flèches puis en appuyant sur <b class=button>Set Date</b>. Sinon, la sélection de la date peut être passée en appuyant sur <b class=button>Skip</b>.</p></div><div id=bsdinstall-timezone-time class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-time.png alt="bsdinstall timezone time"></div><div class=title>Figure 40. Configuration de l’heure</div></div><div class=paragraph><p>L’heure correcte est sélectionnée en utilisant les touches flèches puis en appuyant sur <b class=button>Set Time</b>. Sinon, cette configuration peut être passée en appuyant sur <b class=button>Skip</b>.</p></div></div><div class=sect3><h4 id=bsdinstall-sysconf>2.8.3. Activation des services<a class=anchor href=#bsdinstall-sysconf></a></h4><div class=paragraph><p>Le menu suivant est destiné à choisir quels services système seront lancés au démarrage. Tous ces services sont optionnels. Ne lancez que les services nécessaires au fonctionnement du système.</p></div><div id=bsdinstall-config-serv class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-services.png alt="bsdinstall config services"></div><div class=title>Figure 41. Sélection de services supplémentaires à activer</div></div><div class=paragraph><p>Voici un résumé des services pouvant être activés dans ce menu:</p></div><div class=ulist><ul><li><p><code>local_unbound</code> - Active le résolveur DNS local. Il est important de garder à l’esprit que c’est le résolveur du système de base qui n’est destiné à être utilisé uniquement qu’en tant que résolveur cache local. Si l’objectif est de mettre en place un résolveur pour tout le réseau, installer <a class=package href=https://cgit.freebsd.org/ports/tree/dns/unbound/>dns/unbound</a>.</p></li><li><p><code>sshd</code> - Le daemon <em>Secure Shell</em> (SSH) est utilisé pour l’accès à un système à distance via une connexion chiffrée. Activez ce service que si le système doit être accessible pour l’ouverture de session à distance.</p></li><li><p><code>moused</code> - Activez ce service si la souris sera utilisée à partir de la console système en ligne de commande.</p></li><li><p><code>ntpdate</code> - Active la mise à l’heure automatique de l’horloge au démarrage. La fonction de ce programme est désormais disponible dans le daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>. Après une certaine période d’adaptation, l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> sera supprimé.</p></li><li><p><code>ntpd</code> - Le daemon du protocole de temps réseau (<em>Network Time Protocol</em>) (NTP) pour la synchronisation automatique de l’horloge. Activez ce service s’il y a un serveur Windows®, Kerberos, ou LDAP sur le réseau.</p></li><li><p><code>powerd</code> - Utilitaire de contrôle de la gestion de l’énergie du système pour le contrôle de la consommation en énergie.</p></li><li><p><code>dumpdev</code> - Activer les crash dumps peut s’avérer très utile pour déboguer les problèmes du système, aussi les utilisateurs sont encouragés à activer les crashs dumps.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-hardening>2.8.4. Activer les options de renforcement de la sécurité<a class=anchor href=#bsdinstall-hardening></a></h4><div class=paragraph><p>Le menu suivant est utilisé pour sélectionner quelles options de sécurité seront activées. Toutes ces options sont facultatives. Mais leur utilisation est encouragée.</p></div><div id=bsdinstall-hardening-options class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-hardening.png alt="bsdinstall hardening"></div><div class=title>Figure 42. Sélection des options de renforcement de la sécurité</div></div><div class=paragraph><p>Voici un résumé des options qui peuvent être activées dans ce menu:</p></div><div class=ulist><ul><li><p><code>hide_uids</code> - Cache les processus en cours d’exécution sous des utilisateurs différents pour éviter que des utilisateurs non autorisés puissent voir les processus en cours d’exécution exécutés par d’autres utilisateurs (UID) évitant ainsi la fuite d’information.</p></li><li><p><code>hide_gids</code> - Cache les processus en cours d’exécution sous des groupes différents pour éviter que des utilisateurs non autorisés puissent voir les processus en cours d’exécution exécutés par d’autres groupes (GID) évitant ainsi la fuite d’information.</p></li><li><p><code>hide_jail</code> - Cache les processus en cours d’exécution dans des jails pour éviter que des utilisateurs non autorisés puissent voir les processus en cours d’exécution dans les jails.</p></li><li><p><code>read_msgbuf</code> - Désactive la lecture du tampon des messages du noyau pour les utilisateurs non autorisés en empêchant l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> pour lire les messages du tampon de trace du noyau.</p></li><li><p><code>proc_debug</code> - La désactivation des fonctionnalités de débogage des processus pour les utilisateurs non autorisés désactive une variété de services de débogage inter-processus non-privilégiés, cela comprend certaines fonctionnalités procfs, ptrace(), et and ktrace(). Veuillez noter que cela empêche également le fonctionnement d’outils de débogage pour les utilisateurs non autorisés comme <a href="https://man.freebsd.org/cgi/man.cgi?query=lldb&amp;sektion=1&amp;format=html">lldb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=truss&amp;sektion=1&amp;format=html">truss(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=procstat&amp;sektion=1&amp;format=html">procstat(1)</a>, ainsi que certaines fonctionnalités de débogage intégrées dans certains langages comme PHP, etc.</p></li><li><p><code>random_pid</code> - Rend aléatoire le choix de la valeur du PID de chaque nouveau processus.</p></li><li><p><code>clear_tmp</code> - Nettoie le répertoire <span class=filename>/tmp</span> au démarrage du système.</p></li><li><p><code>disable_syslogd</code> - Désactive l’ouverture d’un socket réseau syslogd. Par défaut, FreeBSD exécute syslogd de manière sécurisée avec le paramètre <code>-s</code>. Cela évite que le daemon écoute sur le port 514 les requêtes UDP entrantes. Avec cette option activée syslogd sera exécuté avec les paramètres <code>-ss</code> ce qui empêche l’ouverture de ports par syslogd. Pour des informations supplémentaires, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>.</p></li><li><p><code>disable_sendmail</code> - Désactive l’agent de transfert de courrier Sendmail.</p></li><li><p><code>secure_console</code> - Quand cette option est activée, l’invite réclame le mot de passe <code>root</code> lors de l’entrée en mode utilisateur unique.</p></li><li><p><code>disable_ddtrace</code> - DTrace peut fonctionner dans un mode qui affectera le noyau en exécution. Des actions destructives ne pourront pas être utilisées sauf si elles ont été explicitement autorisées. Pour activer cette option lors de l’utilisation de DTrace utilisez le paramètre <code>-w</code>. Pour des informations supplémentaires, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a>.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-addusers>2.8.5. Ajouter des utilisateurs<a class=anchor href=#bsdinstall-addusers></a></h4><div class=paragraph><p>Le menu suivant demande de créer au moins un compte utilisateur. Il est recommandé d’utiliser un compte utilisateur pour l’ouverture de session sur le système plutôt que d’employer le compte <code>root</code>. Quand on utilise une session <code>root</code>, il n’existe aucune limite ou protection quant à ce qui peut être fait. Ouvrir une session en tant qu’utilisateur normal est plus sûr et plus sécurisé.</p></div><div class=paragraph><p>Sélectionner <b class=button>Yes</b> pour ajouter de nouveaux utilisateurs.</p></div><div id=bsdinstall-add-user1 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser1.png alt="bsdinstall adduser1"></div><div class=title>Figure 43. Ajout de comptes utilisateur</div></div><div class=paragraph><p>Suivez les instructions et saisissez les informations demandées pour le compte utilisateur à ajouter. L’exemple donné dans <a href=#bsdinstall-add-user2>Entrée des informations utilisateur</a> créé le compte utilisateur <code>asample</code>.</p></div><div id=bsdinstall-add-user2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser2.png alt="bsdinstall adduser2"></div><div class=title>Figure 44. Entrée des informations utilisateur</div></div><div class=paragraph><p>Voici un résumé des informations à saisir:</p></div><div class=ulist><ul><li><p><code>Username</code> - Le nom d’utilisateur ou identifiant que l’utilisateur entrera pour ouvrir une session. Une convention courante est d’utiliser la première lettre du prénom associé au nom, tant que chaque nom d’utilisateur reste unique sur le système. Le nom d’utilisateur est sensible à la casse et ne devrait pas contenir d’espace.</p></li><li><p><code>Full name</code> - Le nom complet de l’utilisateur. Il peut contenir des espaces et est utilisé comme description du compte utilisateur.</p></li><li><p><code>Uid</code> - L’identifiant numérique pour cet utilisateur. En général, ce champ est laissé vide de façon à ce que le système assigne par lui-même une valeur.</p></li><li><p><code>Login group</code> - Le groupe de l’utilisateur. Généralement il est laissé vide pour accepter le choix par défaut.</p></li><li><p><code>Invite <em>user</em> into other groups?</code> - Groupes supplémentaires pour lesquels l’utilisateur sera également ajouté comme membre. Si l’utilisateur a besoin d’un accès administrateur, tapez <code>wheel</code> ici.</p></li><li><p><code>Login class</code> - Généralement laissé vide pour accepter la valeur par défaut.</p></li><li><p><code>Shell</code> - Tapez un des noms listés pour choisir l’interpréteur de commande de l’utilisateur. Consulter <a href=./#shells>Interpréteurs de commandes - “Shells”</a> pour plus d’information sur les interpréteurs de commande.</p></li><li><p><code>Home directory</code> - Le répertoire de l’utilisateur. La valeur par défaut est, en général, correcte.</p></li><li><p><code>Home directory permissions</code> - Les permissions sur le répertoire utilisateur. La valeur par défaut est, en général, correcte.</p></li><li><p><code>Use password-based authentication?</code> - En général <code>yes</code> de manière à ce que l’utilisateur soit invité à entrer son mot de passe à l’ouverture de session.</p></li><li><p><code>Use an empty password?</code> - En général <code>no</code> car c’est un problème de sécurité d’avoir un mot de passe vide.</p></li><li><p><code>Use a random password?</code> - En général <code>no</code> de manière à ce que l’utilisateur puisse entrer son propre mot de passe à l’invite suivante.</p></li><li><p><code>Enter password</code> - Le mot de passe pour cet utilisateur. Les caractères tapés n’apparaîtront pas sur l’écran.</p></li><li><p><code>Enter password again</code> - Le mot de passe doit à nouveau être saisi pour vérification.</p></li><li><p><code>Lock out the account after creation?</code> - En général <code>no</code> de manière à ce que l’utilisateur puisse ouvrir une session.</p></li></ul></div><div class=paragraph><p>Après avoir tout saisi, un résumé est affiché pour vérification. Si une erreur a été faite, entrez <code>no</code> et recommencez. Si tout est correct, entrez <code>yes</code> pour créer ce nouvel utilisateur.</p></div><div id=bsdinstall-add-user3 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser3.png alt="bsdinstall adduser3"></div><div class=title>Figure 45. Quitter la gestion des utilisateurs et des groupes</div></div><div class=paragraph><p>S’il y a d’autres utilisateurs à ajouter, répondez <code>yes</code> à la question <code>Add another user?</code>. Entrez <code>no</code> pour terminer l’ajout d’utilisateurs et continuer l’installation.</p></div><div class=paragraph><p>Pour plus d’information sur l’ajout d’utilisateurs et leur gestion, consultez <a href=./#users-synopsis>Synopsis</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-final-conf>2.8.6. Configuration finale<a class=anchor href=#bsdinstall-final-conf></a></h4><div class=paragraph><p>Après avoir tout installé et configuré, une dernière chance de modifier les réglages est proposée.</p></div><div id=bsdinstall-final-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-finalconfiguration.png alt="bsdinstall finalconfiguration"></div><div class=title>Figure 46. Configuration finale</div></div><div class=paragraph><p>Utilisez ce menu pour effectuer des changements ou toute configuration supplémentaire avant de terminer l’installation.</p></div><div class=ulist><ul><li><p><code>Add User</code> - Décrit dans la <a href=#bsdinstall-addusers>Ajouter des utilisateurs</a>.</p></li><li><p><code>Root Password</code> - Décrit dans la <a href=#bsdinstall-post-root>Définir le mot de passe de <code>root</code></a>.</p></li><li><p><code>Hostname</code> - Décrit dans la <a href=#bsdinstall-hostname>Configurer le nom de la machine</a>.</p></li><li><p><code>Network</code> - Décrit dans la <a href=#bsdinstall-config-network-dev>Configuration des interfaces réseau</a>.</p></li><li><p><code>Services</code> - Décrit dans la <a href=#bsdinstall-sysconf>Activation des services</a>.</p></li><li><p><code>System Hardening</code> - Décrit dans la <a href=#bsdinstall-hardening>Activer les options de renforcement de la sécurité</a>.</p></li><li><p><code>Time Zone</code> - Décrit dans la <a href=#bsdinstall-timezone>Réglage du fuseau horaire</a>.</p></li><li><p><code>Handbook</code> - Télécharge et installe le Manuel FreeBSD.</p></li></ul></div><div class=paragraph><p>Une fois la configuration finale achevée, sélectionnez <b class=button>Exit</b>.</p></div><div id=bsdinstall-final-modification-shell class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-modification-shell.png alt="bsdinstall final modification shell"></div><div class=title>Figure 47. Configuration manuelle</div></div><div class=paragraph><p>bsdinstall demandera s’il y a des éléments supplémentaires à configurer avant le redémarrage sur le nouveau système. Sélectionner <b class=button>Yes</b> pour quitter vers un interpréteur de commande, ou <b class=button>No</b> pour passer à la dernière étape d’installation.</p></div><div id=bsdinstall-final-main class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-mainexit.png alt="bsdinstall mainexit"></div><div class=title>Figure 48. Achever l’installation</div></div><div class=paragraph><p>Si d’autre configuration ou une configuration spécifique est nécessaire, choisissez <b class=button>Live CD</b> pour démarrer dans le mode du CD Live.</p></div><div class=paragraph><p>Si l’installation est achevée, sélectionnez <b class=button>Reboot</b> pour redémarrer l’ordinateur et démarrer le nouveau système FreeBSD. N’oubliez pas de retirer le support d’installation de FreeBSD ou l’ordinateur risque de redémarrer dessus à nouveau.</p></div><div class=paragraph><p>Lors du démarrage de FreeBSD, des messages d’information sont affichés. Une fois que le système a achevé son démarrage, une invite de session est affichée. A l’invite <code>login:</code>, saisissez le nom d’utilisateur ajouté lors de l’installation. Evitez d’ouvrir des sessions en tant que <code>root</code>. Consultez <a href=./#users-superuser>Le compte super-utilisateur</a> pour des instructions sur comment devenir super-utilisateur quand un accès administrateur est nécessaire.</p></div><div class=paragraph><p>Les messages qui ont défilé lors du démarrage peuvent être à nouveau visualisés en appuyant sur <kbd>Scroll-Lock</kbd> (ou <kbd>Arrêtdéfil</kbd>) pour activer le <em>défilement arrière du tampon des messages</em>. Les touches <kbd>PgUp</kbd>, <kbd>PgDn</kbd>, et les touches fléchées pourront être utilisées pour remonter dans les messages. Une fois terminé, appuyez à nouveau sur <kbd>Scroll-Lock</kbd> pour déverrouiller l’écran et fera revenir à l’affichage normal de la console. Pour revoir ces messages quand le système en fonctionnement depuis un certain temps, tapez <code>less /var/run/dmesg.boot</code> à partir de l’invite. Appuyez sur <kbd>q</kbd> pour retourner à l’invite de commande après la visualisation.</p></div><div class=paragraph><p>Si sshd a été activé dans <a href=#bsdinstall-config-serv>Sélection de services supplémentaires à activer</a>, le premier démarage pourra être un peu plus lent en raison de la génération des clés RSA et DSA. Les démarrages suivants seront plus rapides. Les empreintes des clés seront affichées, comme montré dans cet exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Generating public/private rsa1 key pair.
Your identification has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.
Your public key has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key<span class=s1>&#39;s randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key&#39;</span>s randomart image is:
+--[ DSA 1024]----+
|       ..     <span class=nb>.</span> .|
|      o  <span class=nb>.</span>   <span class=nb>.</span> + |
|     <span class=nb>.</span> ..   <span class=nb>.</span> E .|
|    <span class=nb>.</span> <span class=nb>.</span>  o o <span class=nb>.</span> <span class=nb>.</span> |
|     +  S <span class=o>=</span> <span class=nb>.</span>    |
|    +  <span class=nb>.</span> <span class=o>=</span> o     |
|     +  <span class=nb>.</span> <span class=k>*</span> <span class=nb>.</span>    |
|    <span class=nb>.</span> <span class=nb>.</span>  o <span class=nb>.</span>     |
|      .o. <span class=nb>.</span>      |
+-----------------+
Starting sshd.</code></pre></div></div><div class=paragraph><p>Consulter <a href=./#openssh>OpenSSH</a> pour plus d’information au sujet des empreintes et de SSH.</p></div><div class=paragraph><p>FreeBSD n’installe pas d’environnement graphique par défaut, mais de nombreux sont disponibles. Consultez <a href=./#x11>Le système X Window</a> pour plus d’information au sujet de l’installation et la configuration d’un gestionnaire de fenêtres graphique.</p></div><div class=paragraph><p>Arrêter proprement un ordinateur sous FreeBSD aide à protéger les données et même le matériel de tout dommage. <em>Ne coupez pas l’alimentation tant que le système n’est pas correctement arrêté!</em> Si l’utilisateur est membre du groupe <code>wheel</code>, passez en super-utilisateur en tapant <code>su</code> sur la ligne de commande et en entrant le mot de passe de <code>root</code>. Ensuite, utilisez la commande <code>shutdown -p now</code> et le système se fermera proprement, et si le matériel le support, s’éteindra lui-même.</p></div></div></div><div class=sect2><h3 id=bsdinstall-network>2.9. Interfaces réseau<a class=anchor href=#bsdinstall-network></a></h3><div class=sect3><h4 id=bsdinstall-config-network-dev>2.9.1. Configuration des interfaces réseau<a class=anchor href=#bsdinstall-config-network-dev></a></h4><div class=paragraph><p>Ensuite, est affichée une liste des interfaces réseaux trouvées sur l’ordinateur. Sélectionner l’interface à configurer.</p></div><div id=bsdinstall-configure-net-interface class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface.png alt="bsdinstall configure network interface"></div><div class=title>Figure 49. Choix d’une interface réseau</div></div><div class=paragraph><p>Si une interface réseau Ethernet est choisie, le programme d’installation passera au menu montré dans la <a href=#bsdinstall-configure-net-ipv4>Sélection d’un fonctionnement réseau en IPv4</a>. Si une interface réseau sans-fil est choisie, le système recherchera les points d’accès sans-fil:</p></div><div id=bsdinstall-wireless-scan class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-scan.png alt="bsdinstall configure wireless scan"></div><div class=title>Figure 50. Recherche des points d’accès sans-fil</div></div><div class=paragraph><p>Les réseaux sans-fil sont identifiés par un <em>Service Set Identifier</em> (SSID), qui est un nom, court, unique donné à chaque réseau. Les SSIDs trouvés durant la recherche sont affichés, suivis par une description des types de chiffrement disponibles pour chaque réseau. Si le SSID désiré n’apparaît pas dans la liste, sélectionner <b class=button>Rescan</b> pour rechercher à nouveau. Si le réseau désiré n’apparaît toujours pas, vérifiez qu’il n’y a pas de problèmes d’antenne ou essayez de rapprocher l’ordinateur du point d’accès. Rescannez après chaque modification.</p></div><div id=bsdinstall-wireless-accesspoints class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-accesspoints.png alt="bsdinstall configure wireless accesspoints"></div><div class=title>Figure 51. Sélection d’un réseau sans-fil</div></div><div class=paragraph><p>Ensuite, entrer les informations de chiffrement pour se connecter au réseau sans-fil sélectionné. Le chiffrement WPA2 est fortement recommandé sachant que les chiffrements plus anciens, comme WEP, offrent peu de sécurité. Si le réseau utilise WPA2, entrez le mot de passe également connu sous le nom de <em>Pre-Shared Key</em> (PSK). Pour des raisons de sécurité, les caractères tapés dans la boîte de saisie apparaissent sous la forme d’astérisques.</p></div><div id=bsdinstall-wireless-wpa2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-wpa2setup.png alt="bsdinstall configure wireless wpa2setup"></div><div class=title>Figure 52. Configuration WPA2</div></div><div class=paragraph><p>Ensuite, indiquez si une adresse réseau en IPv4 doit être configurée ou non sur l’interface Ethernet ou sans-fil:</p></div><div id=bsdinstall-configure-net-ipv4 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4.png alt="bsdinstall configure network interface ipv4"></div><div class=title>Figure 53. Sélection d’un fonctionnement réseau en IPv4</div></div><div class=paragraph><p>Il existe deux méthodes de configuration IPv4. En DHCP, l’interface réseau sera configurée automatiquement, c’est la méthode à privilégier si le réseau dispose d’un serveur DHCP. Sinon, les informations de configuration du réseau devront être saisies manuellement sous la forme d’une configuration statique.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>N’entrez pas de paramètres réseau au hasard, cela ne fonctionnera pas. Si un serveur DHCP n’est pas disponible, récupérez les paramètres listés dans <a href=#bsdinstall-collect-network-information>Informations réseau nécessaires</a> auprès de l’administrateur réseau ou du fournisseur d’accès à Internet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si un serveur DHCP est disponible, sélectionner <b class=button>Yes</b> dans le menu suivant pour configurer automatiquement l’interface réseau. Le programme d’installation s’arrêtera pendant environ une minute pour trouver le serveur DHCP et récupérer l’information de configuration du réseau pour le système.</p></div><div id=bsdinstall-net-ipv4-dhcp class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-dhcp.png alt="bsdinstall configure network interface ipv4 dhcp"></div><div class=title>Figure 54. Sélection de la configuration IPv4 avec DHCP</div></div><div class=paragraph><p>S’il n’y a pas de serveur DHCP, sélectionner <b class=button>No</b> et tapez les paramètres d’adressage suivants dans le menu qui suit:</p></div><div id=bsdinstall-net-ipv4-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-static.png alt="bsdinstall configure network interface ipv4 static"></div><div class=title>Figure 55. Configuration IPv4 en statique</div></div><div class=ulist><ul><li><p><code>IP Address</code> - L’adresse IPv4 assignée à cet ordinateur. Cette adresse doit être unique et ne pas être déjà utilisée par un autre équipement sur le réseau local.</p></li><li><p><code>Subnet Mask</code> - Le masque de sous-réseau utilisé par le réseau.</p></li><li><p><code>Default Router</code> - L’adresse IP de la passerelle par défaut du réseau.</p></li></ul></div><div class=paragraph><p>L’écran suivant demandera si l’interface doit être configurée pour l’IPv6. Si l’IPv6 est disponible et désiré, choisir <b class=button>Yes</b> pour le sélectionner.</p></div><div id=bsdinstall-net-ipv6 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6.png alt="bsdinstall configure network interface ipv6"></div><div class=title>Figure 56. Sélection d’un réseau IPv6</div></div><div class=paragraph><p>Un réseau IPv6 peut être configuré suivant deux méthodes. Le système d'<em>autoconfiguration sans état</em> ou <em>StateLess Address AutoConfiguration</em> (SLAAC) demandera automatiquement les informations de configuration correctes à un routeur local. Consulter <a href=http://tools.ietf.org/html/rfc4862>http://tools.ietf.org</a> pour plus d’information. La configuration statique, quant à elle, demande la saisie manuelle des informations réseau.</p></div><div class=paragraph><p>Si un routeur IPv6 est disponible, sélectionner <b class=button>Yes</b> dans le menu suivant pour configurer automatiquement l’interface réseau. Le programme d’installation s’arrêtera pendant environ une minute pour trouver le routeur et obtenir les informations de configuration réseau pour le système.</p></div><div id=bsdinstall-net-ipv6-slaac class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-slaac.png alt="bsdinstall configure network interface slaac"></div><div class=title>Figure 57. Sélection de la configuration IPv6 SLAAC</div></div><div class=paragraph><p>S’il n’y a pas de routeur IPv6, sélectionnez <b class=button>No</b> et tapez les paramètres d’adressage suivants dans le menu qui suit:</p></div><div id=bsdinstall-net-ipv6-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6-static.png alt="bsdinstall configure network interface ipv6 static"></div><div class=title>Figure 58. Configuration IPv6 en statique</div></div><div class=ulist><ul><li><p><code>IPv6 Address</code> - L’adresse IP assignée à cet ordinateur. Cette adresse doit être unique et ne pas être déjà utilisée par un autre équipement sur le réseau local.</p></li><li><p><code>Default Router</code> - L’adresse IPv6 de la passerelle par défaut du réseau.</p></li></ul></div><div class=paragraph><p>Le dernier menu de configuration est utilisé pour configurer le système de résolution <em>Domain Name System</em> (ou DNS) qui convertit les noms de machine en adresses réseau et inversement. Si la méthode du DHCP ou du SLAAC a été utilisée pour configurer automatiquement la carte réseau, les valeurs de configuration du système de résolution de noms (<code>Resolver Configuration</code>) pourront déjà être complétées. Dans le cas contraire, entrer le nom de domaine du réseau local dans le champ <code>Search</code>. <code>DNS #1</code> et <code>DNS #2</code> sont les adresses IPv4 et/ou IPv6 des serveurs DNS locaux. Au moins un serveur DNS est nécessaire.</p></div><div id=bsdinstall-net-dns-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-ipv4-dns.png alt="bsdinstall configure network ipv4 dns"></div><div class=title>Figure 59. Configuration du DNS</div></div><div class=paragraph><p>Une fois l’interface réseau configurée, sélectionnez un site miroir qui est situé dans la même région du monde que l’ordinateur sur lequel FreeBSD doit être installé. Les fichiers peuvent être récupérés plus rapidement quand le miroir est proche de l’ordinateur cible, réduisant ainsi le temps d’installation.</p></div><div id=bsdinstall-netinstall-mirror class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-mirrorselect.png alt="bsdinstall netinstall mirrorselect"></div><div class=title>Figure 60. Sélection d’un site miroir</div></div></div></div><div class=sect2><h3 id=bsdinstall-install-trouble>2.10. Dépannage<a class=anchor href=#bsdinstall-install-trouble></a></h3><div class=paragraph><p>Cette section couvre le dépannage basique de l’installation, comme les problèmes courants rencontrés.</p></div><div class=paragraph><p>Vérifier la liste du matériel supporté (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org/releases/</a>) de la version de FreeBSD pour être sûr que le matériel est supporté. Si le matériel est supporté et que des blocages ou autres problèmes surviennent, compiler un noyau personnalisé en utilisant les instructions de <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a> pour ajouter le support pour les périphériques qui ne sont pas présents dans le noyau <span class=filename>GENERIC</span>. Le noyau est configuré de telle façon qu’il supposera que la plupart des périphériques seront dans leur configuration d’usine en termes d’IRQs, d’adresses d’E/S, et canaux de DMA. Si le matériel a été reconfiguré, un fichier de configuration du noyau personnalisé peut indiquer à FreeBSD où trouver les choses.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quelques problèmes d’installation peuvent être évités ou allégés en mettant à jour le firmware de divers composants matériels, en particulier la carte mère. Le firmware de la carte mère peut également être désigné par le terme BIOS. La plupart des constructeurs de cartes mères ou d’ordinateur disposent d’un site web où peuvent être trouvées les mises à jour et les informations de mises à jour.</p></div><div class=paragraph><p>Les fabricants déconseillent fortement de mettre à jour le BIOS de la carte mère à moins d’avoir une bonne raison de le faire, comme une mise à jour critique. Le processus de mise à jour <em>peut</em> mal se passer, laissant un BIOS incomplet et l’ordinateur inutilisable.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si le système se bloque au démarrage pendant la détection du matériel, ou se comporte de manière étrange lors de l’installation, l’ACPI peut être le coupable. FreeBSD utilise de manière intensive le système ACPI sur les plateformes i386 et amd64, s’il est détecté au démarrage, pour aider à la configuration du matériel. Malheureusement, des bogues persistent dans le pilote ACPI, et sur les cartes mères et leur BIOS. L’ACPI peut être désactivé en positionnant le paramètre <code>hint.acpi.0.disabled</code> pour le chargeur de démarrage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div><div class=paragraph><p>Ce paramètre est réinitialisé à chaque démarrage du système, il est donc nécessaire d’ajouter <code>hint.acpi.0.disabled="1"</code> au fichier <span class=filename>/boot/loader.conf</span>. Plus d’information au sujet du chargeur peut être trouvée dans la <a href=./#boot-synopsis>Menu d’accueil</a>.</p></div></div><div class=sect2><h3 id=using-live-cd>2.11. Utilisation du CD Live<a class=anchor href=#using-live-cd></a></h3><div class=paragraph><p>Le menu d’accueil de bsdinstall, montré dans <a href=#bsdinstall-choose-mode>Menu d’accueil</a>, propose une option <b class=button>Live CD</b>. C’est utile pour ceux qui se demandent si FreeBSD est le bon choix et désirent tester certaines fonctionnalités avant l’installation.</p></div><div class=paragraph><p>Les points suivants devront être pris en compte avant l’utilisation du :<b class=button>Live CD</b></p></div><div class=ulist><ul><li><p>Pour utiliser le système, une authentification est nécessaire. Le nom d’utilisateur est <code>root</code>, sans mot de passe.</p></li><li><p>Etant donné que le système s’exécute directement à partir du support d’installation, le système sera bien plus lent que s’il était installé sur un disque dur.</p></li><li><p>Cette option ne propose qu’une invite de commande et pas d’interface graphique.</p></li></ul></div></div></div></div><div class=sect1><h2 id=basics>Chapitre 3. Quelques bases d’UNIX<a class=anchor href=#basics></a></h2><div class=sectionbody><div class=sect2><h3 id=basics-synopsis>3.1. Synopsis<a class=anchor href=#basics-synopsis></a></h3><div class=paragraph><p>Le chapitre suivant couvrira les commandes et fonctionnalités de base du système d’exploitation FreeBSD. La plupart de ces informations sera valable pour n’importe quel système d’exploitation UNIX®. Soyez libre de passer ce chapitre si vous êtes familier avec ces informations. Si vous êtes nouveau à FreeBSD, alors vous voudrez certainement lire attentivement ce chapitre.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Comment utiliser les "consoles virtuelles" de FreeBSD.</p></li><li><p>Comment les permissions des fichiers d’UNIX® fonctionnent ainsi que l’utilisation des indicateurs de fichiers sous FreeBSD.</p></li><li><p>L’architecture par défaut du système de fichiers sous FreeBSD.</p></li><li><p>L’organisation des disques sous FreeBSD.</p></li><li><p>Comment monter et démonter des systèmes de fichier.</p></li><li><p>Ce que sont les processus, daemons et signaux.</p></li><li><p>Ce qu’est un interpréteur de commande, et comment changer votre environnement de session par défaut.</p></li><li><p>Comment utiliser les éditeurs de texte de base.</p></li><li><p>Ce que sont les périphériques et les fichiers spéciaux de périphérique.</p></li><li><p>Quel est le format des binaires utilisé sous FreeBSD.</p></li><li><p>Comment lire les pages de manuel pour plus d’information.</p></li></ul></div></div><div class=sect2><h3 id=consoles>3.2. Consoles virtuelles terminaux<a class=anchor href=#consoles></a></h3><div class=paragraph><p>FreeBSD peut être utilisé de diverses façons. L’une d’elles est en tapant des commandes sur un terminal texte. Une bonne partie de la flexibilité et de la puissance d’un système d’exploitation UNIX® est directement disponible sous vos mains en utilisant FreeBSD de cette manière. Cette section décrit ce que sont les "terminaux" et les "consoles", et comment les utiliser sous FreeBSD.</p></div><div class=sect3><h4 id=consoles-intro>3.2.1. La console<a class=anchor href=#consoles-intro></a></h4><div class=paragraph><p>Si vous n’avez pas configuré FreeBSD pour lancer automatiquement un environnement graphique au démarrage, le système vous présentera une invite d’ouverture de session après son démarrage, juste après la fin des procédures de démarrage. Vous verrez quelque chose de similaire à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 <span class=o>(</span>pc3.example.org<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>Les messages pourront être différents sur votre système, mais cela devrait y ressembler. Les deux dernières lignes sont celles qui nous intéressent actuellement. La seconde de ces lignes nous donne:</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD/i386 (pc3.example.org) (ttyv0)</pre></div></div><div class=paragraph><p>Cette ligne contient quelques éléments d’information sur le système que vous venez de démarrer. Vous êtes en train de lire une console "FreeBSD", tournant sur un processeur Intel ou compatible de la famille x86. Le nom de cette machine (chaque machine UNIX® a un nom) est <code>pc3.example.org</code>, et vous regardez actuellement sa console système-le terminal <span class=filename>ttyv0</span>.</p></div><div class=paragraph><p>Et enfin, la dernière ligne est toujours:</p></div><div class="literalblock programlisting"><div class=content><pre>login:</pre></div></div><div class=paragraph><p>C’est le moment où vous êtes supposé taper votre "nom d’utilisateur" pour vous attacher au système FreeBSD. La section suivante décrit comment procéder.</p></div></div><div class=sect3><h4 id=consoles-login>3.2.2. Ouvrir une session sur un système FreeBSD<a class=anchor href=#consoles-login></a></h4><div class=paragraph><p>FreeBSD est un système multi-utilisateur, multi-processeur. C’est la description formelle qui est habituellement donnée pour un système qui peut être utilisé par différentes personnes, qui exécutent simultanément de nombreux programmes sur une machine individuelle.</p></div><div class=paragraph><p>Chaque système multi-utilisateur a besoin d’un moyen pour distinguer un "utilisateur" du reste. Sous FreeBSD (et sous tous les systèmes de type UNIX®), cela est effectué en demandant à chaque utilisateur de "s’attacher" au système avant d’être en mesure d’exécuter des programmes. Chaque utilisateur possède un nom unique (le nom d’utilisateur) et une clé secrète personnelle (le mot de passe). FreeBSD demandera ces deux éléments avant d’autoriser un utilisateur à lancer un programme.</p></div><div class=paragraph><p>Juste après que FreeBSD ait démarré et en ait terminé avec l’exécution des procédures de démarrage, il présentera une invite et demandera un nom d’utilisateur valide:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login:</code></pre></div></div><div class=paragraph><p>Pour cet exemple, supposons que votre nom d’utilisateur est <code>john</code>. Tapez <code>john</code> à cette invite puis appuyez sur <kbd>Entrée</kbd>. Alors vous devrez être invité à entrer un "mot de passe":</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login: john
Password:</code></pre></div></div><div class=paragraph><p>Tapez maintenant le mot de passe de <code>john</code>, et appuyez sur <kbd>Entrée</kbd>. Le mot de passe <em>n’est pas affiché!</em> Vous n’avez pas à vous préoccuper de cela maintenant. Il suffit de penser que cela est fait pour des raisons de sécurité.</p></div><div class=paragraph><p>Si vous avez tapé correctement votre mot de passe, vous devriez être maintenant attaché au système et prêt à essayer toutes les commandes disponibles.</p></div><div class=paragraph><p>Vous devriez voir apparaître le MOTD ou message du jour suivi de l’invite de commande (un caractère <code>#</code>, <code>$</code>, ou <code>%</code>). Cela indique que vous avez ouvert avec succès une session sous FreeBSD.</p></div></div><div class=sect3><h4 id=consoles-virtual>3.2.3. Consoles multiples<a class=anchor href=#consoles-virtual></a></h4><div class=paragraph><p>Exécuter des commandes UNIX® dans une console est bien beau, mais FreeBSD peut exécuter plusieurs programmes à la fois. Avoir une seule console sur laquelle les commandes peuvent être tapées serait un peu du gaspillage quand un système d’exploitation comme FreeBSD peut exécuter des dizaines de programmes en même temps. C’est ici que des "consoles virtuelles" peuvent être vraiment utiles.</p></div><div class=paragraph><p>FreeBSD peut être configuré pour présenter de nombreuses consoles virtuelles. Vous pouvez basculer d’une console virtuelle à une autre en utilisant une combinaison de touches sur votre clavier. Chaque console a son propre canal de sortie, et FreeBSD prend soin de rediriger correctement les entrées au clavier et la sortie vers écran quand vous basculez d’une console virtuelle à la suivante.</p></div><div class=paragraph><p>Des combinaisons de touches spécifiques ont été réservées par FreeBSD pour le basculement entre consoles. Vous pouvez utiliser <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span>, jusqu’à <span class=keyseq><kbd>Alt</kbd>+<kbd>F8</kbd></span> pour basculer vers une console virtuelle différente sous FreeBSD.</p></div><div class=paragraph><p>Quand vous basculez d’une console à une autre, FreeBSD prend soin de sauvegarder et restaurer la sortie d’écran. Il en résulte l'"illusion" d’avoir plusieurs écrans et claviers "virtuels" que vous pouvez utiliser pour taper des commandes pour FreeBSD. Les programmes que vous lancez sur une console virtuelle ne cessent pas de tourner quand cette console n’est plus visible. Ils continuent de s’exécuter quand vous avez basculé vers une console virtuelle différente.</p></div></div><div class=sect3><h4 id=consoles-ttys>3.2.4. Le fichier <span class=filename>/etc/ttys</span><a class=anchor href=#consoles-ttys></a></h4><div class=paragraph><p>La configuration par défaut de FreeBSD démarre avec huit consoles virtuelles. Cependant ce n’est pas un paramétrage fixe, et vous pouvez aisément personnaliser votre installation pour démarrer avec plus ou moins de consoles virtuelles. Le nombre et les paramétrages des consoles virtuelles sont configurés dans le fichier <span class=filename>/etc/ttys</span>.</p></div><div class=paragraph><p>Vous pouvez utiliser le fichier <span class=filename>/etc/ttys</span> pour configurer les consoles virtuelles de FreeBSD. Chaque ligne non-commentée dans ce fichier (les lignes qui ne débutent pas par le caractère <code>#</code>) contient le paramétrage d’un terminal ou d’une console virtuelle. La version par défaut de ce fichier livrée avec FreeBSD configure neuf consoles virtuelles, et en active huit. Ce sont les lignes commençant avec le terme <code>ttyv</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>Pour une description détaillée de chaque colonne de ce fichier et toutes les options que vous pouvez utiliser pour configurer les consoles virtuelles, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>.</p></div></div><div class=sect3><h4 id=consoles-singleuser>3.2.5. Console en mode mono-utilisateur<a class=anchor href=#consoles-singleuser></a></h4><div class=paragraph><p>Une description détaillée de ce qu’est "le mode mono-utilisateur" peut être trouvée dans <a href=./#boot-singleuser>Mode mono-utilisateur</a>. Il est important de noter qu’il n’y a qu’une console de disponible quand vous exécutez FreeBSD en mode mono-utilisateur. Il n’y a aucune console virtuelle de disponible. Le paramétrage de la console en mode mono-utilisateur peut être également trouvé dans le fichier <span class=filename>/etc/ttys</span>. Recherchez la ligne qui commence avec le mot <code>console</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Comme l’indiquent les commentaires au-dessus de la ligne <code>console</code>, vous pouvez éditer cette ligne et changer <code>secure</code> pour <code>insecure</code>. Si vous faites cela, quand FreeBSD démarrera en mode mono-utilisateur, il demandera le mot de passe de <code>root</code>.</p></div><div class=paragraph><p><em>Cependant faites attention quand vous modifiez cela pour <code>insecure</code>.</em> Si vous oubliez le mot de passe de <code>root</code>, le démarrage en mode mono-utilisateur sera condamné. Il est encore possible, mais cela pourra être relativement compliqué pour quelqu’un qui n’est pas à l’aise avec le processus de démarrage de FreeBSD et les programmes entrant en jeu.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=consoles-vidcontrol>3.2.6. Modifier la résolution de la console<a class=anchor href=#consoles-vidcontrol></a></h4><div class=paragraph><p>La résolution (ou encore le mode vidéo) de la console FreeBSD peut être réglée à 1024x768, 1280x1024, ou tout autre résolution supportée par le circuit graphique et le moniteur. Pour utiliser une résolution vidéo différente vous devez en premier lieu recompiler votre noyau en ajoutant deux options supplémentaires:</p></div><div class="literalblock programlisting"><div class=content><pre>options VESA
options SC_PIXEL_MODE</pre></div></div><div class=paragraph><p>Une fois votre noyau recompilé avec ces deux options, vous pouvez déterminer quels sont les modes vidéo supportés par votre matériel en utilisant l’outil <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>. Pour obtenir une liste des modes supportés, tapez la ligne suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol -i mode</span></code></pre></div></div><div class=paragraph><p>La sortie de cette commande est une liste des modes vidéo que supporte votre matériel. Vous pouvez ensuite décider d’utiliser un nouveau mode en le passant à la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> tout en ayant les droits de <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol MODE_279</span></code></pre></div></div><div class=paragraph><p>Si le nouveau mode vidéo est satisfaisant, il peut être activé au démarrage de manière permanente en le configurant dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;MODE_279&#34;</pre></div></div></div></div><div class=sect2><h3 id=permissions>3.3. Permissions<a class=anchor href=#permissions></a></h3><div class=paragraph><p>FreeBSD, étant un descendant direct de l’UNIX® BSD, est basé sur plusieurs concepts clés d’UNIX®. Le premier, et le plus prononcé, est le fait que FreeBSD est un système d’exploitation multi-utilisateurs. Le système peut gérer plusieurs utilisateurs travaillant tous simultanément sur des tâches complètement indépendantes. Le système est responsable du partage correct et de la gestion des requêtes pour les périphériques matériels, la mémoire, et le temps CPU de façon équitable entre chaque utilisateur.</p></div><div class=paragraph><p>Puisque le système est capable de supporter des utilisateurs multiples, tout ce que le système gère possède un ensemble de permissions définissant qui peut écrire, lire, et exécuter la ressource. Ces permissions sont stockées sous forme de trois octets divisés en trois parties, une pour le propriétaire du fichier, une pour le groupe auquel appartient le fichier, et une autre pour le reste du monde. Cette représentation numérique fonctionne comme ceci:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Valeur</th><th class="tableblock halign-left valign-top">Permission</th><th class="tableblock halign-left valign-top">Contenu du répertoire</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pas d’accès en lecture, pas d’accès en écriture, pas d’accès en exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>---</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pas d’accès en lecture, pas d’accès en écriture, exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>--x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pas d’accès en lecture, écriture, pas d’accès en exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-w-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pas d’accès en lecture, écriture, exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-wx</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lecture, pas d’accès en écriture, pas d’accès en exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r--</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lecture, pas d’accès en écriture, exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r-x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lecture, écriture, pas d’accès en exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rw-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lecture, écriture, exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rwx</code></p></td></tr></tbody></table><div class=paragraph><p>Vous pouvez utiliser l’option <code>-l</code> avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> pour afficher le contenu du répertoire sous forme une longue et détaillée qui inclut une colonne avec des informations sur les permissions d’accès des fichiers pour le propriétaire, le groupe, et le reste du monde. Par exemple un <code>ls -l</code> dans un répertoire quelconque devrait donner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span>
total 530
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 myfile
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 otherfile
<span class=nt>-rw-r--r--</span>  1 root  wheel    7680 Sep  5 12:31 email.txt
...</code></pre></div></div><div class=paragraph><p>Voici comment est divisée la première colonne de l’affichage généré par <code>ls -l</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rw-r--r--</span></code></pre></div></div><div class=paragraph><p>Le premier caractère (le plus à gauche) indique si c’est un fichier normal, un répertoire, ou un périphérique mode caractère, une socket, ou tout autre pseudo-périphérique. Dans ce cas, <code>-</code> indique un fichier normal. Les trois caractères suivants, <code>rw-</code> dans cet exemple, donnent les permissions pour le propriétaire du fichier. Les trois caractères qui suivent, <code>r--</code>, donnent les permissions pour le groupe auquel appartient le fichier. Les trois derniers caractères, <code>r--</code>, donnent les permissions pour le reste du monde. Un tiret signifie que la permission est désactivée. Dans le cas de ce fichier, les permissions sont telles que le propriétaire peut lire et écrire le fichier, le groupe peut lire le fichier, et le reste du monde peut seulement lire le fichier. D’après la table ci-dessus, les permissions pour ce fichier seraient <code>644</code>, où chaque chiffre représente les trois parties des permissions du fichier.</p></div><div class=paragraph><p>Tout cela est bien beau, mais comment le système contrôle les permissions sur les périphériques? En fait FreeBSD traite la plupart des périphériques sous la forme d’un fichier que les programmes peuvent ouvrir, lire, et écrire des données dessus comme tout autre fichier. Ces périphériques spéciaux sont stockés dans le répertoire <span class=filename>/dev</span>.</p></div><div class=paragraph><p>Les répertoires sont aussi traités comme des fichiers. Ils ont des droits en lecture, écriture et exécution. Le bit d’exécution pour un répertoire a une signification légèrement différente que pour les fichiers. Quand un répertoire est marqué exécutable, cela signifie qu’il peut être traversé, i.e. il est possible d’utiliser "cd" (changement de répertoire). Ceci signifie également qu’à l’intérieur du répertoire il est possible d’accéder aux fichiers dont les noms sont connus (en fonction, bien sûr, des permissions sur les fichiers eux-mêmes).</p></div><div class=paragraph><p>En particulier, afin d’obtenir la liste du contenu d’un répertoire, la permission de lecture doit être positionnée sur le répertoire, tandis que pour effacer un fichier dont on connaît le nom, il est nécessaire d’avoir les droits d’écriture <em>et</em> d’exécution sur le répertoire contenant le fichier.</p></div><div class=paragraph><p>Il y a d’autres types de permissions, mais elles sont principalement employées dans des circonstances spéciales comme les binaires "setuid" et les répertoires "sticky". Si vous désirez plus d’information sur les permissions de fichier et comment les positionner, soyez sûr de consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>.</p></div><div class=sect3><h4 id=_permissions_symboliques>3.3.1. Permissions symboliques<a class=anchor href=#_permissions_symboliques></a></h4><div class=paragraph><p>Les permissions symboliques, parfois désignées sous le nom d’expressions symboliques, utilisent des caractères à la place de valeur en octal pour assigner les permissions aux fichiers et répertoires. Les expressions symboliques emploient la syntaxe: (qui) (action) (permissions), avec les valeurs possibles suivantes:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Option</th><th class="tableblock halign-left valign-top">Lettre</th><th class="tableblock halign-left valign-top">Représente</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(qui)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>u</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilisateur</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(qui)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>g</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Groupe</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(qui)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>o</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Autre</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(qui)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tous ("le monde entier")</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(action)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ajouter des permissions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(action)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Retirer des permissions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(action)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fixe les permissions de façon explicite</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>r</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lecture</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>w</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ecriture</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exécution</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>t</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>bit collant (sticky)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>s</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exécuter avec l’ID utilisateur (UID) ou groupe (GID)</p></td></tr></tbody></table><div class=paragraph><p>Ces valeurs sont utilisées avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> comme précédemment mais avec des lettres. Par exemple, vous pourriez utiliser la commande suivante pour refuser l’accès au fichier <em>FICHIER</em> à d’autres utilisateurs:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span><span class=nv>go</span><span class=o>=</span> FICHIER</code></pre></div></div><div class=paragraph><p>Une liste séparé par des virgules peut être fournie quand plus d’un changement doit être effectué sur un fichier. Par exemple la commande suivante retirera les permissions d’écriture au groupe et au "reste du monde" sur le fichier <em>FICHIER</em>, puis ajoutera la permission d’exécution pour tout le monde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>go-w,a+x FICHIER</code></pre></div></div></div><div class=sect3><h4 id=_indicateurs_des_fichiers_sous_freebsd>3.3.2. Indicateurs des fichiers sous FreeBSD<a class=anchor href=#_indicateurs_des_fichiers_sous_freebsd></a></h4><div class=paragraph><p>En addition des permissions sur les fichiers précédemment présentées, FreeBSD supporte l’utilisation d'"indicateurs de fichiers". Ces indicateurs rajoutent un niveau de contrôle et de sécurité sur les fichiers, mais ne concernent pas les répertoires.</p></div><div class=paragraph><p>Ces indicateurs ajoutent donc un niveau de contrôle supplémentaire des fichiers, permettant d’assurer que dans certains cas même le super-utilisateur <code>root</code> ne pourra effacer ou modifier des fichiers.</p></div><div class=paragraph><p>Les indicateurs de fichiers peuvent être modifiés avec l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>, ce dernier présentant une interface simple. Par exemple, pour activer l’indicateur système de suppression impossible sur le fichier <span class=filename>file1</span>, tapez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags sunlink file1</span></code></pre></div></div><div class=paragraph><p>Et pour désactiver l’indicateur de suppression impossible, utilisez la commande précédente avec le préfixe "no" devant l’option <code>sunlink</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags nosunlink file1</span></code></pre></div></div><div class=paragraph><p>Pour afficher les indicateurs propres à ce fichier, utilisez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> avec l’option <code>-lo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -lo file1</span></code></pre></div></div><div class=paragraph><p>La sortie de la commande devrait ressembler à:</p></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</pre></div></div><div class=paragraph><p>Plusieurs indicateurs ne peuvent être positionnés ou retirés que par le super-utilisateur <code>root</code>. Dans les autres cas, le propriétaire du fichier peut activer ces indicateurs. Pour plus d’information, la lecture des pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a> est recommandée à tout administrateur.</p></div></div></div><div class=sect2><h3 id=dirstructure>3.4. Organisation de l’arborescence des répertoires<a class=anchor href=#dirstructure></a></h3><div class=paragraph><p>L’organisation de l’arborescence des répertoires de FreeBSD est essentielle pour obtenir une compréhension globale du système. Le concept le plus important à saisir est celui du répertoire racine, "/". Ce répertoire est le premier a être monté au démarrage et il contient le système de base nécessaire pour préparer le système d’exploitation au fonctionnement multi-utilisateurs. Le répertoire racine contient également les points de montage pour les autres systèmes de fichiers qui sont montés lors du passage en mode multi-utilisateurs.</p></div><div class=paragraph><p>Un point de montage est un répertoire où peuvent être greffés des systèmes de fichiers supplémentaires au système de fichiers parent (en général le système de fichiers racine). Cela est décrit plus en détails dans la <a href=#disk-organization>Organisation des disques</a>. Les points de montage standards incluent <span class=filename>/usr</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span>, <span class=filename>/mnt</span>, et <span class=filename>/cdrom</span>. Ces répertoires sont en général référencés par des entrées dans le fichier <span class=filename>/etc/fstab</span>. <span class=filename>/etc/fstab</span> est une table des divers systèmes de fichiers et de leur point de montage utilisé comme référence par le système. La plupart des systèmes de fichiers présents dans <span class=filename>/etc/fstab</span> sont montés automatiquement au moment du démarrage par la procédure <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> à moins que l’option <code>noauto</code> soit présente. Plus de détails peuvent être trouvés dans la <a href=#disks-fstab>Le fichier <span class=filename>fstab</span></a>.</p></div><div class=paragraph><p>Une description complète de l’arborescence du système de fichiers est disponible dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a>. Pour l’instant, une brève vue d’ensemble des répertoires les plus courants suffira.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Répertoire</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Répertoire racine du système de fichiers.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programmes utilisateur fondamentaux aux deux modes de fonctionnement mono et multi-utilisateurs.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programmes et fichiers de configuration utilisés durant le processus de démarrage du système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de configuration par défaut du processus de démarrage; voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers spéciaux de périphérique; voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=intro&amp;sektion=4&amp;format=html">intro(4)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Procédures et fichiers de configuration du système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de configuration du système par défaut; voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de configuration pour les agents de transport du courrier électronique comme <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de configuration de <code>named</code>; voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/periodic/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Procédures qui sont exécutées de façon quotidienne, hebdomadaire et mensuelle par l’intermédiaire de <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>; voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de configuration de <code>ppp</code>; voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/mnt/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Répertoire vide habituellement utilisé par les administrateurs système comme un point de montage temporaire.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/proc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le système de fichiers pour les processus; voir les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programmes liés en statique pour les réparations d’urgence; consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/root/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Répertoire personnel du compte <code>root</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programmes systèmes et utilitaires systèmes fondamentaux aux environnements mono et multi-utilisateurs.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers temporaires. Le contenu de <span class=filename>/tmp</span> n’est en général PAS préservé par un redémarrage du système. Un système de fichiers en mémoire est souvent monté sur <span class=filename>/tmp</span>. Cela peut être automatisé en utilisant les variables <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> relatives au système "tmpmfs" (ou à l’aide d’une entrée dans le fichier <span class=filename>/etc/fstab</span>; consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La majorité des utilitaires et applications utilisateur.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilitaires généraux, outils de programmation, et applications.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers d’en-tête C standard.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ensemble des bibliothèques.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libdata/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Divers fichiers de données de service.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilitaires et daemons système (exécutés par d’autres programmes).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exécutables, bibliothèques, etc…​ Egalement utilisé comme destination de défaut pour les logiciels portés pour FreeBSD. Dans <span class=filename>/usr/local</span>, l’organisation générale décrite par la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> pour <span class=filename>/usr</span> devrait être utilisée. Exceptions faites du répertoire man qui est directement sous <span class=filename>/usr/local</span> plutôt que sous <span class=filename>/usr/local/share</span>, et la documentation des logiciels portés est dans <span class=filename>share/doc/port</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/obj/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arborescence cible spécifique à une architecture produite par la compilation de l’arborescence <span class=filename>/usr/src</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le catalogue des logiciels portés (optionnel).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilitaires et daemons système (exécutés par les utilisateurs).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/shared/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers indépendants de l’architecture.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers source FreeBSD et/ou locaux.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/X11R6/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exécutables, bibliothèques etc…​ de la distribution d’X11R6 (optionnel).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de traces, fichiers temporaires, et fichiers tampons. Un système de fichiers en mémoire est parfois monté sur <span class=filename>/var</span>. Cela peut être automatisé en utilisant les variables <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> relatives au système "varmfs" (ou à l’aide d’une entrée dans le fichier <span class=filename>/etc/fstab</span>; consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/log/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Divers fichiers de trace du système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Boîtes aux lettres des utilisateurs.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/spool/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Divers répertoires tampons des systèmes de courrier électronique et d’impression.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers temporaires. Ces fichiers sont généralement conservés lors d’un redémarrage du système, à moins que <span class=filename>/var</span> ne soit un système de fichiers en mémoire.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/yp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tables NIS.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disk-organization>3.5. Organisation des disques<a class=anchor href=#disk-organization></a></h3><div class=paragraph><p>Le plus petit élément qu’utilise FreeBSD pour retrouver des fichiers est le nom de fichier. Les noms de fichiers sont sensibles à la casse des caractères, ce qui signifie que <span class=filename>readme.txt</span> et <span class=filename>README.TXT</span> sont deux fichiers séparés. FreeBSD n’utilise pas l’extension (<span class=filename>.txt</span>) d’un fichier pour déterminer si ce fichier est un programme, un document ou une autre forme de donnée.</p></div><div class=paragraph><p>Les fichiers sont stockés dans des répertoires. Un répertoire peut ne contenir aucun fichier, ou en contenir plusieurs centaines. Un répertoire peut également contenir d’autre répertoires, vous permettant de construire une hiérarchie de répertoires à l’intérieur d’un autre. Cela rend plus simple l’organisation de vos données.</p></div><div class=paragraph><p>Les fichiers et les répertoires sont référencés en donnant le nom du fichier ou du répertoire, suivi par un slash, <code>/</code>, suivi par tout nom de répertoire nécessaire. Si vous avez un répertoire <span class=filename>foo</span>, qui contient le répertoire <span class=filename>bar</span>, qui contient le fichier <span class=filename>readme.txt</span>, alors le nom complet, ou <em>chemin</em> ("path") vers le fichier est <span class=filename>foo/bar/readme.txt</span>.</p></div><div class=paragraph><p>Les répertoires et les fichiers sont stockés sur un système de fichiers. Chaque système de fichiers contient à son niveau le plus haut un répertoire appelé <em>répertoire racine</em> pour ce système de fichiers. Ce répertoire racine peut alors contenir les autres répertoires.</p></div><div class=paragraph><p>Jusqu’ici cela est probablement semblable à n’importe quel autre système d’exploitation que vous avez pu avoir utilisé. Il y a quelques différences: par exemple, MS-DOS® utilise <code>\</code> pour séparer les noms de fichier et de répertoire, alors que MacOS utilise <code>:</code>.</p></div><div class=paragraph><p>FreeBSD n’utilise pas de lettre pour les lecteurs, ou d’autres noms de disque dans le chemin. Vous n’écrirez pas <span class=filename>c:/foo/bar/readme.txt</span> sous FreeBSD.</p></div><div class=paragraph><p>Au lieu de cela, un système de fichiers est désigné comme <em>système de fichiers racine</em>. La racine du système de fichiers racine est représentée par un <code>/</code>. Tous les autres systèmes de fichiers sont alors <em>montés</em> sous le système de fichiers racine. Peu importe le nombre de disques que vous avez sur votre système FreeBSD, chaque répertoire apparaît comme faisant partie du même disque.</p></div><div class=paragraph><p>Supposez que vous avez trois systèmes de fichiers, appelés <code>A</code>, <code>B</code>, et <code>C</code>. Chaque système de fichiers possède un répertoire racine, qui contient deux autres répertoires, nommés <code>A1</code>, <code>A2</code> (et respectivement <code>B1</code>, <code>B2</code> et <code>C1</code>, <code>C2</code>).</p></div><div class=paragraph><p>Appelons <code>A</code> le système de fichiers racine. Si vous utilisiez la commande <code>ls</code> pour visualiser le contenu de ce répertoire, vous verriez deux sous-répertoires, <code>A1</code> et <code>A2</code>. L’arborescence des répertoires ressemblera à ceci:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir1.png alt="example dir1"></div></div><div class=paragraph><p>Un système de fichiers doit être monté dans un répertoire d’un autre système de fichiers. Supposez maintenant que vous montez le système de fichiers <code>B</code> sur le répertoire <code>A1</code>. Le répertoire racine de <code>B</code> remplace <code>A1</code>, et les répertoires de <code>B</code> par conséquent apparaissent:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir2.png alt="example dir2"></div></div><div class=paragraph><p>Tout fichier de <code>B1</code> ou <code>B2</code> peut être atteint avec le chemin <span class=filename>/A1/B1</span> ou <span class=filename>/A1/B2</span> si nécessaire. Tous les fichiers qui étaient dans <span class=filename>A1</span> ont été temporairement cachés. Ils réapparaîtront si <code>B</code> est <em>démonté</em> de A.</p></div><div class=paragraph><p>Si <code>B</code> a été monté sur <code>A2</code> alors le diagramme sera semblable à celui-ci:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir3.png alt="example dir3"></div></div><div class=paragraph><p>et les chemins seront <span class=filename>/A2/B1</span> et respectivement <span class=filename>/A2/B2</span>.</p></div><div class=paragraph><p>Les systèmes de fichiers peuvent être montés au sommet d’un autre. En continuant l’exemple précédent, le système de fichiers <code>C</code> pourrait être monté au sommet du répertoire <code>B1</code> dans le système de fichiers <code>B</code>, menant à cet arrangement:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir4.png alt="example dir4"></div></div><div class=paragraph><p>Où <code>C</code> pourrait être monté directement sur le système de fichiers <code>A</code>, sous le répertoire <code>A1</code>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir5.png alt="example dir5"></div></div><div class=paragraph><p>Si vous êtes familier de MS-DOS®, ceci est semblable, bien que pas identique, à la commande <code>join</code>.</p></div><div class=paragraph><p>Ce n’est normalement pas quelque chose qui doit vous préoccuper. Généralement vous créez des systèmes de fichiers à l’installation de FreeBSD et décidez où les monter, et ensuite ne les modifiez jamais à moins que vous ajoutiez un nouveau disque.</p></div><div class=paragraph><p>Il est tout à fait possible de n’avoir qu’un seul grand système de fichiers racine, et de ne pas en créer d’autres. Il y a quelques inconvénients à cette approche, et un avantage.</p></div><div class=ulist><div class=title>Avantages des systèmes de fichiers multiples</div><ul><li><p>Les différents systèmes de fichiers peuvent avoir différentes <em>options de montage</em>. Par exemple, avec une planification soigneuse, le système de fichiers racine peut être monté en lecture seule, rendant impossible tout effacement par inadvertance ou édition de fichier critique. La séparation des systèmes de fichiers inscriptibles par l’utilisateur permet leur montage en mode <em>nosuid</em>; cette option empêche les bits <em>suid</em>/<em>guid</em> des exécutables stockés sur ce système de fichiers de prendre effet, améliorant peut-être la sécurité.</p></li><li><p>FreeBSD optimise automatiquement la disposition des fichiers sur un système de fichiers, selon la façon dont est utilisé le système de fichiers. Aussi un système de fichiers contenant beaucoup de petits fichiers qui sont écrits fréquemment aura une optimisation différente à celle d’un système contenant moins, ou de plus gros fichiers. En ayant un seul grand système de fichiers cette optimisation est perdue.</p></li><li><p>Les systèmes de fichiers de FreeBSD sont très robustes même en cas de coupure secteur. Cependant une coupure secteur à un moment critique pourrait toujours endommager la structure d’un système de fichiers. En répartissant vos données sur des systèmes de fichiers multiples il est plus probable que le système redémarre, vous facilitant la restauration des données à partir de sauvegardes si nécessaire.</p></li></ul></div><div class=ulist><div class=title>Avantage d’un système de fichiers unique</div><ul><li><p>Les systèmes de fichiers ont une taille fixe. Si vous créez un système de fichiers à l’installation de FreeBSD et que vous lui donnez une taille spécifique, vous pouvez plus tard vous apercevoir que vous avez besoin d’une partition plus grande. Cela n’est pas facilement faisable sans sauvegardes, recréation du système de fichiers, et enfin restauration des données.</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>FreeBSD dispose d’une commande, <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a>, qui permettra d’augmenter la taille d’un système de fichiers au vol, supprimant cette limitation.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Les systèmes de fichiers sont contenus dans des partitions. Cela n’a pas la même signification que l’utilisation commune du terme partition (par exemple une partition MS-DOS®), en raison de l’héritage Unix de FreeBSD. Chaque partition est identifiée par une lettre de <code>a</code> à <code>h</code>. Chaque partition ne contient qu’un seul système de fichiers, cela signifie que les systèmes de fichiers sont souvent décrits soit par leur point de montage typique dans la hiérarchie du système de fichiers, soit par la lettre de la partition qui les contient.</p></div><div class=paragraph><p>FreeBSD utilise aussi de l’espace disque pour <em>l’espace de pagination</em> ("swap"). L’espace de pagination fournit à FreeBSD la <em>mémoire virtuelle</em>. Cela permet à votre ordinateur de se comporter comme s’il disposait de beaucoup plus de mémoire qu’il n’en a réellement. Quand FreeBSD vient à manquer de mémoire il déplace certaines données qui ne sont pas actuellement utilisées vers l’espace de pagination, et les rapatrie (en déplaçant quelque chose d’autre) quand il en a besoin.</p></div><div class=paragraph><p>Quelques partitions sont liées à certaines conventions.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Partition</th><th class="tableblock halign-left valign-top">Convention</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Contient normalement le système de fichiers racine</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Contient normalement l’espace de pagination</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>c</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Normalement de la même taille que la tranche ("slice") contenant les partitions. Cela permet aux utilitaires devant agir sur l’intégralité de la tranche (par exemple un analyseur de blocs défectueux) de travailler sur la partition <code>c</code>. Vous ne devriez normalement pas créer de système de fichiers sur cette partition.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La partition <code>d</code> a eu dans le passé une signification particulière, ce n’est plus le cas aujourd’hui, et <code>d</code> pourra être utilisée comme une partition classique.</p></td></tr></tbody></table><div class=paragraph><p>Chaque partition contenant un système de fichiers est stockée dans ce que FreeBSD appelle une <em>tranche</em> ("slice"). Tranche - "slice" est le terme FreeBSD pour ce qui est communément appelé partition, et encore une fois, cela en raison des fondations Unix de FreeBSD. Les tranches sont numérotées, en partant de 1, jusqu’à 4.</p></div><div class=paragraph><p>Les numéros de tranche suivent le nom du périphérique, avec le préfixe <code>s</code>, et commencent à 1. Donc "da0<em>s1</em>" est la première tranche sur le premier disque SCSI. Il ne peut y avoir que quatre tranches physiques sur un disque, mais vous pouvez avoir des tranches logiques dans des tranches physiques d’un type précis. Ces tranches étendues sont numérotées à partir de 5, donc "ad0<em>s5</em>" est la première tranche étendue sur le premier disque IDE. Elles sont utilisées par des systèmes de fichiers qui s’attendent à occuper une tranche entière.</p></div><div class=paragraph><p>Les tranches, les disques "en mode dédié", et les autres disques contiennent des <em>partitions</em>, qui sont représentées par des lettres allant de <code>a</code> à <code>h</code>. Cette lettre est ajoutée au nom de périphérique, aussi "da0<em>a</em>" est la partition a sur le premier disque da, qui est en "en mode dédié". "ad1s3<em>e</em>" est la cinquième partition de la troisième tranche du second disque IDE.</p></div><div class=paragraph><p>En conclusion chaque disque présent sur le système est identifié. Le nom d’un disque commence par un code qui indique le type de disque, suivi d’un nombre, indiquant de quel disque il s’agit. Contrairement aux tranches, la numérotation des disques commence à 0. Les codes communs que vous risquez de rencontrer sont énumérés dans le <a href=#basics-dev-codes>Codes des périphériques disques</a>.</p></div><div class=paragraph><p>Quand vous faites référence à une partition, FreeBSD exige que vous nommiez également la tranche et le disque contenant la partition, et quand vous faites référence à une tranche vous devrez également faire référence au nom du disque. On fait donc référence à une partition en écrivant le nom du disque, <code>s</code>, le numéro de la tranche, et enfin la lettre de la partition. Des exemples sont donnés dans l'<a href=#basics-disk-slice-part>Exemples d’appellation de disques, tranches et partitions</a>.</p></div><div class=paragraph><p>L'<a href=#basics-concept-disk-model>Modèle conceptuel d’un disque</a> montre un exemple de l’organisation d’un disque qui devrait aider à clarifier les choses.</p></div><div class=paragraph><p>Afin d’installer FreeBSD vous devez tout d’abord configurer les tranches sur votre disque, ensuite créer les partitions dans la tranche que vous utiliserez pour FreeBSD, et alors créer un système de fichiers (ou espace de pagination) dans chaque partition, et décider de l’endroit où seront montés les systèmes de fichiers.</p></div><table id=basics-dev-codes class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 2. Codes des périphériques disques</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Code</th><th class="tableblock halign-left valign-top">Signification</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>ad</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disque ATAPI (IDE)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>da</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disque SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>acd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CDROM ATAPI (IDE)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>cd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CDROM SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>fd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lecteur de disquette</p></td></tr></tbody></table><div id=basics-disk-slice-part class=exampleblock><div class=title>Exemple 2. Exemples d’appellation de disques, tranches et partitions</div><div class=content><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nom</th><th class="tableblock halign-left valign-top">Signification</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad0s1a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Première partition (<code>a</code>) sur la première tranche (<code>s1</code>) du premier disque IDE (<code>ad0</code>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da1s2e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Cinquième partition (<code>e</code>) sur la seconde tranche (<code>s2</code>) du deuxième disque SCSI (<code>da1</code>).</p></td></tr></tbody></table></div></div><div id=basics-concept-disk-model class=exampleblock><div class=title>Exemple 3. Modèle conceptuel d’un disque</div><div class=content><div class=paragraph><p>Ce diagramme montre comment FreeBSD voit le premier disque IDE attaché au système. Supposons que le disque a une capacité de 4 Go, et contient deux tranches de 2 Go (partitions MS-DOS®). La première tranche contient un disque MS-DOS®, <span class=filename>C:</span>, et la seconde tranche contient une installation de FreeBSD. Dans cet exemple l’installation de FreeBSD a trois partitions de données, et une partition de pagination.</p></div><div class=paragraph><p>Les trois partitions accueilleront chacune un système de fichiers. La partition <code>a</code> sera utilisée en tant que système de fichiers racine, la partition <code>e</code> pour le contenu du répertoire <span class=filename>/var</span>, et <code>f</code> pour l’arborescence du répertoire <span class=filename>/usr</span>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/disk-layout.png alt="disk layout"></div></div></div></div></div><div class=sect2><h3 id=mount-unmount>3.6. Monter et démonter des systèmes de fichiers<a class=anchor href=#mount-unmount></a></h3><div class=paragraph><p>Le système de fichiers peut être vu comme un arbre enraciné sur le répertoire <span class=filename>/</span>. <span class=filename>/dev</span>, <span class=filename>/usr</span>, et les autres répertoires dans le répertoire racine sont des branches, qui peuvent avoir leurs propres branches, comme <span class=filename>/usr/local</span>, et ainsi de suite.</p></div><div class=paragraph><p>Il y a diverses raisons pour héberger certains de ces répertoires sur des systèmes de fichiers séparés. <span class=filename>/var</span> contient les répertoires <span class=filename>log/</span>, <span class=filename>spool/</span>, et divers types de fichiers temporaires, et en tant que tels, peuvent voir leur taille augmenter de façon importante. Remplir le système de fichiers racine n’est pas une bonne idée, aussi séparer <span class=filename>/var</span> de <span class=filename>/</span> est souvent favorable.</p></div><div class=paragraph><p>Une autre raison courante de placer certains répertoires sur d’autres systèmes de fichiers est s’ils doivent être hébergés sur des disques physiques séparés, ou sur des disques virtuels séparés, comme les <a href=./#network-nfs>systèmes de fichiers réseau</a>, ou les lecteurs de CDROM.</p></div><div class=sect3><h4 id=disks-fstab>3.6.1. Le fichier <span class=filename>fstab</span><a class=anchor href=#disks-fstab></a></h4><div class=paragraph><p>Durant le <a href=./#boot>processus de démarrage</a>, les systèmes de fichiers listés dans <span class=filename>/etc/fstab</span> sont automatiquement montés (à moins qu’il ne soient listés avec l’option <code>noauto</code>).</p></div><div class=paragraph><p>Le fichier <span class=filename>/etc/fstab</span> contient une liste de lignes au format suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>device       /mount-point fstype     options      dumpfreq     passno</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>device</code></dt><dd><p>Un nom de périphérique (qui devrait exister), comme expliqué dans la <a href=./#disks-naming>Noms des périphériques</a>.</p></dd><dt class=hdlist1><code>mount-point</code></dt><dd><p>Un répertoire (qui devrait exister), sur lequel sera monté le système de fichier.</p></dd><dt class=hdlist1><code>fstype</code></dt><dd><p>Le type de système de fichiers à indiquer à <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Le système de fichiers par défaut de FreeBSD est l'<code>ufs</code>.</p></dd><dt class=hdlist1><code>options</code></dt><dd><p>Soit <code>rw</code> pour des systèmes de fichiers à lecture-écriture, soit <code>ro</code> pour des systèmes de fichiers à lecture seule, suivi par toute option qui peut s’avérer nécessaire. Une option courante est <code>noauto</code> pour les systèmes de fichiers qui ne sont normalement pas montés durant la séquence de démarrage. D’autres options sont présentées dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></dd><dt class=hdlist1><code>dumpfreq</code></dt><dd><p>C’est utilisé par <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> pour déterminer quels systèmes de fichiers nécessitent une sauvegarde. Si ce champ est absent, une valeur de zéro est supposée.</p></dd><dt class=hdlist1><code>passno</code></dt><dd><p>Ceci détermine l’ordre dans lequel les systèmes de fichiers devront être vérifiés. Les systèmes de fichiers qui doivent être ignorés devraient avoir leur <code>passno</code> positionné à zéro. Le système de fichiers racine (qui doit être vérifié avant tout le reste) devrait avoir son <code>passno</code> positionné à un, et les options <code>passno</code> des autres systèmes fichiers devraient être positionnées à des valeurs supérieures à un. Si plus d’un système de fichiers ont le même <code>passno</code> alors <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> essaiera de vérifier les systèmes de fichiers en parallèle si c’est possible.</p></dd></dl></div><div class=paragraph><p>Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> pour plus d’information sur le format du fichier <span class=filename>/etc/fstab</span> et des options qu’il contient.</p></div></div><div class=sect3><h4 id=disks-mount>3.6.2. La commande <code>mount</code><a class=anchor href=#disks-mount></a></h4><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> est ce qui est finalement utilisé pour monter des systèmes de fichiers.</p></div><div class=paragraph><p>Dans sa forme la plus simple, vous utilisez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount device mountpoint</span></code></pre></div></div><div class=paragraph><p>Il y beaucoup d’options, comme mentionné dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, mais les plus courantes sont:</p></div><div class=dlist><div class=title>Options de montage</div><dl><dt class=hdlist1><code>-a</code></dt><dd><p>Monte tous les systèmes de fichiers listés dans <span class=filename>/etc/fstab</span>. Exception faite de ceux marqués comme "noauto", ou exclus par le drapeau <code>-t</code>, ou encore ceux qui sont déjà montés.</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>Tout effectuer à l’exception de l’appel système de montage réel. Cette option est utile conjointement avec le drapeau <code>-v</code> pour déterminer ce que <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> est en train d’essayer de faire.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Force le montage d’un système de fichiers non propre (dangereux), ou force la révocation de l’accès en écriture quand on modifie l’état de montage d’un système de fichiers de l’accès lecture-écriture à l’accès lecture seule.</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>Monte le système de fichiers en lecture seule. C’est identique à l’utilisation de l’argument <code>ro</code> (<code>rdonly</code> pour les versions de FreeBSD antérieures à la 5.2) avec l’option <code>-o</code>.</p></dd><dt class=hdlist1><code>-t</code> <em>fstype</em></dt><dd><p>Monte le système de fichiers comme étant du type de système donné, ou monte seulement les systèmes de fichiers du type donné, si l’option <code>-a</code> est précisée.</p><div class=paragraph><p>"ufs" est le type de système de fichiers par défaut.</p></div></dd><dt class=hdlist1><code>-u</code></dt><dd><p>Mets à jour les options de montage sur le système de fichiers.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>Rends la commande prolixe.</p></dd><dt class=hdlist1><code>-w</code></dt><dd><p>Monte le système de fichiers en lecture-écriture.</p></dd></dl></div><div class=paragraph><p>L’option <code>-o</code> accepte une liste d’options séparées par des virgules, dont les suivantes:</p></div><div class=dlist><dl><dt class=hdlist1>noexec</dt><dd><p>Ne pas autoriser l’exécution de binaires sur ce système de fichiers. C’est également une option de sécurité utile.</p></dd><dt class=hdlist1>nosuid</dt><dd><p>Ne pas prendre en compte les indicateurs setuid ou setgid sur le système de fichiers. C’est également une option de sécurité utile.</p></dd></dl></div></div><div class=sect3><h4 id=disks-umount>3.6.3. La commande <code>umount</code><a class=anchor href=#disks-umount></a></h4><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> prend, comme paramètre, un des points de montage, un nom de périphérique, ou l’option <code>-a</code> ou <code>-A</code>.</p></div><div class=paragraph><p>Toutes les formes acceptent <code>-f</code> pour forcer de démontage, et <code>-v</code> pour le mode prolixe. Soyez averti que l’utilisation de <code>-f</code> n’est généralement pas une bonne idée. Démonter de force des systèmes de fichiers pourrait faire planter l’ordinateur ou endommager les données sur le système de fichiers.</p></div><div class=paragraph><p>Les options <code>-a</code> et <code>-A</code> sont utilisées pour démonter tous les systèmes de fichiers actuellement montés, éventuellement modifié par les types de systèmes de fichiers listés après l’option <code>-t</code>. Cependant l’option <code>-A</code>, n’essaye pas de démonter le système de fichiers racine.</p></div></div></div><div class=sect2><h3 id=basics-processes>3.7. Processus<a class=anchor href=#basics-processes></a></h3><div class=paragraph><p>FreeBSD est un système d’exploitation multi-tâches. Cela veut dire qu’il semble qu’il y ait plus d’un programme fonctionnant à la fois. Tout programme fonctionnant à un moment donné est appelé un <em>processus</em>. Chaque commande que vous utiliserez lancera au moins un nouveau processus, et il y a de nombreux processus système qui tournent constamment, maintenant ainsi les fonctionnalités du système.</p></div><div class=paragraph><p>Chaque processus est identifié de façon unique par un nombre appelé <em>process ID</em> (identifiant de processus), ou <em>PID</em>, et, comme pour les fichiers, chaque processus possède également un propriétaire et un groupe. Les informations sur le propriétaire et le groupe sont utilisées pour déterminer quels fichiers et périphériques sont accessibles au processus, en utilisant le principe de permissions de fichiers abordé plus tôt. La plupart des processus ont également un processus parent. Le processus parent est le processus qui les a lancés. Par exemple, si vous tapez des commandes sous un interpréteur de commandes, alors l’interpréteur de commandes est un processus, et toute commande que vous lancez est aussi un processus. Chaque processus que vous lancez de cette manière aura votre interpréteur de commandes comme processus parent. Une exception à cela est le processus spécial appelé <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. <code>init</code> est toujours le premier processus, donc son PID est toujours 1. <code>init</code> est lancé automatiquement par le noyau au démarrage de FreeBSD.</p></div><div class=paragraph><p>Deux commandes sont particulièrement utiles pour voir les processus sur le système, <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. La commande <code>ps</code> est utilisée pour afficher une liste statique des processus tournant actuellement, et peut donner leur PID, la quantité de mémoire qu’ils utilisent, la ligne de commande par l’intermédiaire de laquelle ils ont été lancés, et ainsi de suite. La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> affiche tous les processus, et actualise l’affichage régulièrement, de sorte que vous puissiez voir de façon intéractive ce que fait l’ordinateur.</p></div><div class=paragraph><p>Par défaut, <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> n’affiche que les commandes que vous faites tourner et dont vous êtes le propriétaire. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl <span class=o>(</span>xemacs-21.1.14<span class=o>)</span>
37393  p0  I      0:03.11 xemacs freebsd.dsl <span class=o>(</span>xemacs-21.1.14<span class=o>)</span>
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 <span class=o>(</span>dns helper<span class=o>)</span> <span class=o>(</span>navigator-linux-<span class=o>)</span>
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt <span class=nt>-y</span>
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 <span class=nt>-tcsh</span> <span class=o>(</span>tcsh<span class=o>)</span>
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx <span class=nt>--</span> <span class=nt>-bpp</span> 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc <span class=nt>--</span> <span class=nt>-bpp</span> 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</code></pre></div></div><div class=paragraph><p>Comme vous pouvez le voir dans cet exemple, la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> est organisée en un certain nombre de colonnes. <code>PID</code> est l’identifiant de processus discuté plus tôt. Les PIDs sont assignés à partir de 1, et vont jusqu’à 99999, et puis repassent à 1 quand le maximum est atteint (un PID n’est pas réassigné s’il est déjà utilisé). La colonne <code>TT</code> donne le terminal sur lequel tourne le programme, et peut être pour le moment ignoré sans risque. <code>STAT</code> affiche l’état du programme, peut être également ignoré. <code>TIME</code> est la durée d’utilisation du CPU-ce n’est généralement pas le temps écoulé depuis que vous avez lancé le programme, comme la plupart des programmes passent beaucoup de temps à attendre que certaines choses se produisent avant qu’ils n’aient besoin de dépenser du temps CPU. Et enfin, <code>COMMAND</code> est la ligne de commande qui a été utilisée lors du lancement du programme.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> supporte un certain nombre d’options différentes pour modifier les informations affichées. Un des ensembles d’options les plus utiles est <code>auxww</code>. <code>a</code> affiche l’information au sujet de tous les processus tournant, et pas seulement les vôtres. <code>u</code> donne le nom de l’utilisateur du propriétaire du processus, ainsi que l’utilisation de la mémoire. <code>x</code> affiche des informations sur les processus "daemon", et <code>ww</code> oblige <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> à afficher la ligne de commande complète pour chaque processus, plutôt que de la tronquer quand elle est trop longue pour tenir à l’écran.</p></div><div class=paragraph><p>La sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> est semblable. Un extrait de session ressemble à ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top
last pid: 72257<span class=p>;</span>  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% <span class=nb>nice</span>,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K <span class=k>select   </span>2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K <span class=k>select   </span>5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K <span class=k>select   </span>0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K <span class=k>select   </span>3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K <span class=k>select   </span>1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</code></pre></div></div><div class=paragraph><p>La sortie est divisée en deux sections. L’entête (les cinq premières lignes) donne le PID du dernier processus lancé, la charge système moyenne (qui est une mesure de l’occupation du système), la durée de fonctionnement du système (le temps écoulé depuis le dernier redémarrage), et l’heure actuelle. Les autres éléments de l’entête concernent le nombre de processus en fonctionnement (47 dans notre cas), combien d’espace mémoire et d’espace de pagination sont occupés, et combien de temps le système passe dans les différents états du CPU.</p></div><div class=paragraph><p>En dessous il y a une série de colonnes contenant des informations semblables à celles données par <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>. Comme précédemment vous pouvez lire le PID, le nom d’utilisateur, la quantité de temps CPU consommée, et la commande qui a été lancée. <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> vous affiche par défaut la quantité d’espace mémoire utilisée par chaque processus. Cela est divisé en deux colonnes, une pour la quantité totale, et une autre pour la quantité résidente-la quantité totale représente l’espace mémoire dont a eu besoin l’application, et la quantité résidente représente l’espace qui est en fait utilisé actuellement. Dans cet exemple vous pouvez voir que <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> a exigé presque 30 Mo de RAM, mais utilise actuellement seulement 9Mo.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> actualise l’affichage toutes les deux secondes; cela peut être modifié avec l’option <code>s</code>.</p></div></div><div class=sect2><h3 id=basics-daemons>3.8. Daemons, signaux, et comment tuer un processus<a class=anchor href=#basics-daemons></a></h3><div class=paragraph><p>Quand vous utilisez un éditeur il est facile de le contrôler, de lui dire de charger des fichiers, et ainsi de suite. Vous pouvez faire cela parce que l’éditeur fournit les possibilités de le faire, et parce qu’un éditeur est attaché à un <em>terminal</em>. Certains programmes ne sont pas conçus pour fonctionner avec un dialogue constant avec l’utilisateur, et donc ils se déconnectent du terminal à la première occasion. Par exemple, un serveur web passe son temps à répondre aux requêtes web, il n’attend normalement pas d’entrée de votre part. Les programmes qui transportent le courrier électronique de site en site sont un autre exemple de cette classe d’application.</p></div><div class=paragraph><p>Nous appelons ces programmes des <em>daemons</em> (démons). Les "daemons" étaient des personnages de la mythologie Grecque: ni bon ni mauvais, c’étaient de petits esprits serviteurs qui, généralement, ont été à l’origine de choses utiles à l’humanité, un peu comme les serveurs web ou de messagerie d’aujourd’hui nous sont utiles. C’est pourquoi la mascotte BSD a été, pendant longtemps, un démon à l’apparence joyeuse portant des chaussures de tennis et une fourche.</p></div><div class=paragraph><p>Il existe une convention pour nommer les programmes qui fonctionnent normalement en tant que daemons qui est d’utiliser une terminaison en "d". BIND est le "Berkeley Internet Name Domain", mais le programme réel qui est exécuté s’appelle <code>named</code>); le programme correspondant au serveur web Apache est appelé <code>httpd</code>; le daemon de gestion de la file d’attente de l’imprimante est <code>lpd</code>, et ainsi de suite. C’est une convention, mais pas une obligation pure et simple; par exemple le daemon principal de gestion du courrier électronique pour l’application Sendmail est appelé <code>sendmail</code>, et non pas <code>maild</code>, comme vous pourriez l’imaginer.</p></div><div class=paragraph><p>Parfois vous devrez communiquer avec un processus daemon. Une manière de procéder est de lui (ou à tout processus en cours d’exécution) envoyer ce que l’on appelle un <em>signal</em>. Il existe un certain nombre de signaux différents que vous pouvez envoyer-certains d’entre eux ont une signification précise, d’autres sont interprétés par l’application, et la documentation de l’application vous indiquera comment l’application interprète ces signaux. Vous ne pouvez envoyer de signaux qu’aux processus dont vous êtes le propriétaire. Si vous envoyez un signal à un processus appartenant à quelqu’un d’autre avec <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=2&amp;format=html">kill(2)</a>, vous obtiendrez un refus de permission. Il existe une exception à cela: l’utilisateur <code>root</code>, qui peut envoyer des signaux aux processus de chacun.</p></div><div class=paragraph><p>Dans certain cas FreeBSD enverra également aux applications des signaux. Si une application est mal écrite, et tente d’accéder à une partie de mémoire à laquelle elle n’est pas supposée avoir accès, FreeBSD envoie au processus le signal de <em>violation de segmentation</em> (<code>SIGSEGV</code>). Si une application a utilisé l’appel système <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> pour être avertie dès qu’une période de temps précise est écoulée alors lui sera envoyé le signal d’alarme (<code>SIGALRM</code>), et ainsi de suite.</p></div><div class=paragraph><p>Deux signaux peuvent être utilisés pour arrêter un processus, <code>SIGTERM</code> et <code>SIGKILL</code>. <code>SIGTERM</code> est la manière polie de tuer un processus; le processus peut <em>attraper</em> le signal, réaliser que vous désirez qu’il se termine, fermer les fichiers de trace qu’il a peut-être ouvert, et généralement finir ce qu’il était en train de faire juste avant la demande d’arrêt. Dans certains cas un processus peut ignorer un <code>SIGTERM</code> s’il est au milieu d’une tâche qui ne peut être interrompue.</p></div><div class=paragraph><p><code>SIGKILL</code> ne peut être ignoré par un processus. C’est le signal "Je me fiche de ce que vous faites, arrêtez immédiatement". Si vous envoyez un <code>SIGKILL</code> à un processus alors FreeBSD stoppera le processus.</p></div><div class=paragraph><p>Les autres signaux que vous pourriez avoir envie d’utiliser sont <code>SIGHUP</code>, <code>SIGUSR1</code>, et <code>SIGUSR2</code>. Ce sont des signaux d’usage général, et différentes applications se comporteront différemment quand ils sont envoyés.</p></div><div class=paragraph><p>Supposez que vous avez modifié le fichier de configuration de votre serveur web-vous voudriez dire à votre serveur web de relire son fichier de configuration. Vous pourriez arrêter et relancer <code>httpd</code>, mais il en résulterait une brève période d’indisponibilité de votre serveur web, ce qui peut être indésirable. La plupart des daemons sont écrits pour répondre au signal <code>SIGHUP</code> en relisant leur fichier de configuration. Donc au lieu de tuer et relancer <code>httpd</code> vous lui enverriez le signal <code>SIGHUP</code>. Parce qu’il n’y a pas de manière standard de répondre à ces signaux, différents daemons auront différents comportements, soyez sûr de ce que vous faites et lisez la documentation du daemon en question.</p></div><div class=paragraph><p>Les signaux sont envoyés en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a>, comme cet exemple le montre:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Envoyer un signal à un processus</strong></p></div><div class=paragraph><p>Cet exemple montre comment envoyer un signal à <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. Le fichier de configuration d'<code>inetd</code> est <span class=filename>/etc/inetd.conf</span>, et <code>inetd</code> relira ce fichier de configuration quand un signal <code>SIGHUP</code> est envoyé.</p></div><div class="olist arabic"><ol class=arabic><li><p>Trouvez l’identifiant du processus (PID) auquel vous voulez envoyer le signal. Faites-le en employant <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a>. La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a> est utilisée pour rechercher dans le résultat la chaîne de caractères que vous spécifiez. Cette commande est lancée en tant qu’utilisateur normal, et <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> est lancé en tant que <code>root</code>, donc les options <code>ax</code> doivent être passées à <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps <span class=nt>-ax</span> | <span class=nb>grep </span>inetd
  198  ??  IWs    0:00.00 inetd <span class=nt>-wW</span></code></pre></div></div><div class=paragraph><p>Donc le PID d’<a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> est 198. Dans certains cas la commande <code>grep inetd</code> pourrait aussi apparaître dans le résultat. C’est à cause de la façon dont <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> recherche la liste des processus en fonctionnement.</p></div></li><li><p>Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> pour envoyer le signal. Etant donné qu’<a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> tourne sous les droits de l’utilisateur <code>root</code> vous devez utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> pour devenir, en premier lieu, <code>root</code>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:
<span class=c># /bin/kill -s HUP 198</span></code></pre></div></div><div class=paragraph><p>Comme la plupart des commandes UNIX®, <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> n’affichera rien si la commande est couronnée de succès. Si vous envoyez un signal à un processus dont vous n’êtes pas le propriétaire alors vous verrez <code>kill: <em>PID</em>: Operation not permitted</code>. Si vous avez fait une erreur dans le PID, vous enverrez le signal soit à un mauvais processus, ce qui peut être mauvais, soit, si vous êtes chanceux, vous enverrez le signal à un PID qui n’est pas actuellement utilisé, et vous verrez <code>kill: <em>PID</em>: No such process</code>.</p></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Pourquoi utiliser <code>/bin/kill</code>?</div><div class=paragraph><p>De nombreux interpréteurs de commandes fournissent la commande <code>kill</code> comme commande interne; c’est à dire, que l’interpréteur de commandes enverra directement le signal, plutôt que de lancer <span class=filename>/bin/kill</span>. Cela peut être utile, cependant les différents interpréteurs ont une syntaxe différente pour spécifier le nom du signal à envoyer. Plutôt que de tenter de les apprendre toutes, il peut être plus simple de juste employer directement la commande <code>/bin/kill …​</code>.</p></div></td></tr></tbody></table></div></div></div><div class=paragraph><p>Envoyer d’autres signaux est très semblable, substituez juste <code>TERM</code> ou <code>KILL</code> dans la ligne de commande si nécessaire.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Tuer au hasard des processus sur le système peut être une mauvaise idée. En particulier, <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, processus à l’identifiant 1, qui est très particulier. Lancer la commande <code>/bin/kill -s KILL 1</code> est une manière rapide d’arrêter votre système. Vérifiez <em>toujours</em> à deux fois les arguments que vous utilisez avec <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> <em>avant</em> d’appuyer sur <kbd>Entrée</kbd>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=shells>3.9. Interpréteurs de commandes - "Shells"<a class=anchor href=#shells></a></h3><div class=paragraph><p>Sous FreeBSD, beaucoup du travail quotidien est effectué sous une interface en ligne de commande appelée interpréteur de commandes ou "shell". Le rôle principal d’un interpréteur de commandes est de prendre les commandes sur le canal d’entrée et de les exécuter. Beaucoup d’interpréteurs de commandes ont également des fonctions intégrées pour aider dans les tâches quotidiennes comme la gestion de fichiers, le mécanisme de remplacement et d’expansion des jokers ("file globbing"), l’édition de la ligne de commande, les macros commandes, et les variables d’environnement. FreeBSD est fournit avec un ensemble d’interpréteurs de commandes, comme <code>sh</code>, l’interpréteur de commandes Bourne, et <code>tcsh</code>, l’interpréteur de commandes C-shell amélioré. Beaucoup d’autres interpréteurs de commandes sont disponibles dans le catalogue des logiciels portés, comme <code>zsh</code> et <code>bash</code>.</p></div><div class=paragraph><p>Quel interpréteur de commandes utilisez-vous? C’est vraiment une question de goût. Si vous programmez en C vous pourriez vous sentir plus à l’aise avec un interpréteur de commandes proche du C comme <code>tcsh</code>. Si vous venez du monde Linux ou que vous êtes nouveau à l’interface en ligne de commande d’UNIX® vous pourriez essayer <code>bash</code>. L’idée principale est que chaque interpréteur de commandes à des caractéristiques uniques qui peuvent ou ne peuvent pas fonctionner avec votre environnement de travail préféré, et que vous avez vraiment le choix de l’interpréteur de commandes à utiliser.</p></div><div class=paragraph><p>Une des caractéristiques communes des interpréteurs de commandes est de pouvoir compléter les noms de fichiers ("filename completion"). En tapant les premières lettres d’une commande ou d’un fichier, vous pouvez habituellement faire compléter automatiquement par l’interpréteur de commandes le reste de la commande ou du nom du fichier en appuyant sur la touche <kbd>Tab</kbd> du clavier. Voici un exemple. Supposez que vous avez deux fichiers appelés respectivement <span class=filename>foobar</span> et <span class=filename>foo.bar</span>. Vous voulez effacer <span class=filename>foo.bar</span>. Donc ce que vous devriez taper sur le clavier est: <code>rm fo[Tab].[Tab]</code>.</p></div><div class=paragraph><p>L’interpréteur de commandes devrait afficher <code>rm foo[BEEP].bar</code>.</p></div><div class=paragraph><p>Le [BEEP] est la sonnerie de la console, c’est l’interpréteur de commande indiquant qu’il n’est pas en mesure de compléter totalement le nom du fichier parce qu’il y a plus d’une possibilité. <span class=filename>foobar</span> et <span class=filename>foo.bar</span> commencent tous les deux par <code>fo</code>, mais il fut capable de compléter jusqu’à <code>foo</code>. Si vous tapez <code>.</code>, puis appuyez à nouveau sur <kbd>Tab</kbd>, l’interpréteur de commandes devrait pouvoir compléter le reste du nom du fichier pour vous.</p></div><div class=paragraph><p>Une autre caractéristique de l’interpréteur de commandes est l’utilisation de variables d’environnement. Les variables d’environnement sont une paire variable/valeur stockées dans l’espace mémoire d’environnement de l’interpréteur de commandes. Cet espace peut être lu par n’importe quel programme invoqué par l’interpréteur de commandes, et contient ainsi beaucoup d’éléments de configuration des programmes. Voici une liste des variables d’environnement habituelles et ce qu’elles signifient:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Variable</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>USER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le nom d’utilisateur de la personne actuellement attachée au système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La liste des répertoires, séparés par deux points, pour la recherche des programmes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>DISPLAY</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le nom réseau de l’affichage X11 auquel on peut se connecter, si disponible.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>SHELL</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le nom de l’interpréteur de commandes actuellement utilisé.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERM</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le nom du type de terminal de l’utilisateur. Utilisé pour déterminer les capacités du terminal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERMCAP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’entrée de la base de données des codes d’échappement pour permettre l’exécution de diverses fonctions du terminal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>OSTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Type du système d’exploitation, e.g. FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MACHTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’architecture du CPU sur lequel tourne actuellement le système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>EDITOR</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’éditeur de texte préferé de l’utilisateur.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PAGER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le visualisateur de page de texte préferré de l’utilisateur.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MANPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La liste des répertoires, séparés par deux points, pour la recherche des pages de manuel.</p></td></tr></tbody></table><div class=paragraph><p>Fixer une variable d’environnement diffère légèrement d’un interpréteur de commandes à l’autre. Par exemple, dans le style de l’interpréteur de commandes de type C-shell comme <code>tcsh</code> et <code>csh</code>, vous utiliseriez <code>setenv</code> pour fixer le contenu d’une variable d’environnement. Sous les interpréteurs de commandes Bourne comme <code>sh</code> et <code>bash</code>, vous utiliseriez <code>export</code> pour configurer vos variables d’environnement. Par exemple, pour fixer ou modifier la variable d’environnement <code>EDITOR</code>, sous <code>csh</code> ou <code>tcsh</code> une commande comme la suivante fixera <code>EDITOR</code> à <span class=filename>/usr/local/bin/emacs</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv EDITOR /usr/local/bin/emacs</code></pre></div></div><div class=paragraph><p>Sous les interpréteurs de commandes Bourne:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;/usr/local/bin/emacs&#34;</span></code></pre></div></div><div class=paragraph><p>Vous pouvez faire afficher à la plupart des interpréteurs de commandes la variable d’environnement en plaçant un caractère <code>$</code> juste devant son nom sur la ligne de commande. Par exemple, <code>echo $TERM</code> affichera le contenu de <code>$TERM</code>, car l’interpréteur de commande complète <code>$TERM</code> et passe la main à <code>echo</code>.</p></div><div class=paragraph><p>Les interpréteurs de commandes traitent beaucoup de caractères spéciaux, appelés métacaractères, en tant que représentation particulière des données. Le plus commun est le caractère <code>*</code>, qui représente zéro ou plusieurs caractères dans le nom du fichier. Ces métacaractères spéciaux peuvent être utilisés pour compléter automatiquement le nom des fichiers. Par exemple, taper <code>echo *</code> est presque la même chose que taper <code>ls</code> parce que l’interpréteur de commandes prendra tous les fichiers qui correspondent à <code>*</code> et les passera à <code>echo</code> pour les afficher.</p></div><div class=paragraph><p>Pour éviter que l’interpréteur de commande n’interprète les caractères spéciaux, ils peuvent être neutralisés en ajoutant un caractère antislash (<code>\</code>) devant. <code>echo $TERM</code> affichera votre type de terminal. <code>echo \$TERM</code> affichera <code>$TERM</code> tel quel.</p></div><div class=sect3><h4 id=changing-shells>3.9.1. Changer d’interpréteur de commandes<a class=anchor href=#changing-shells></a></h4><div class=paragraph><p>La méthode la plus simple pour changer votre interpréteur de commandes est d’utiliser la commande <code>chsh</code>. En lançant <code>chsh</code> vous arriverez dans l’éditeur correspondant à votre variable d’environnement <code>EDITOR</code>; si elle n’est pas fixée, cela sera <code>vi</code>. Modifiez la ligne "Shell:" en conséquence.</p></div><div class=paragraph><p>Vous pouvez également passer le paramètre <code>-s</code> à <code>chsh</code>; cela modifiera votre interpréteur de commandes sans avoir à utiliser un éditeur. Par exemple, si vous vouliez changer votre interpréteur de commandes pour <code>bash</code>, ce qui suit devrait faire l’affaire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% chsh <span class=nt>-s</span> /usr/local/bin/bash</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’interpréteur de commandes que vous désirez utiliser <em>doit</em> être présent dans le fichier <span class=filename>/etc/shells</span>. Si vous avez installé l’interpréteur de commandes à partir du <a href=./#ports>catalogue des logiciels portés</a>, alors cela a dû déjà être fait pour vous. Si vous avez installé à la main l’interpréteur de commandes, vous devez alors le faire.</p></div><div class=paragraph><p>Par exemple, si vous avez installé <code>bash</code> à la main et l’avez placé dans <span class=filename>/usr/local/bin</span>, vous devrez faire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/local/bin/bash  /etc/shells</span></code></pre></div></div><div class=paragraph><p>Puis relancer <code>chsh</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=editors>3.10. Editeurs de texte<a class=anchor href=#editors></a></h3><div class=paragraph><p>Beaucoup de configurations sous FreeBSD sont faites en éditant des fichiers textes. Aussi ce serait une bonne idée de se familiariser avec un éditeur de texte. FreeBSD est fourni avec quelques-uns en tant qu’éléments du système de base, et beaucoup d’autres sont disponibles dans le catalogue des logiciels portés.</p></div><div class=paragraph><p>L’éditeur de plus facile et le plus simple à apprendre est un éditeur appelé ee, qui signifie l’éditeur facile (easy editor). Pour lancer ee, on taperait sur la ligne de commande <code>ee fichier</code> où <em>fichier</em> est le nom du fichier qui doit être édité. Par exemple, pour éditer <span class=filename>/etc/rc.conf</span>, tapez <code>ee /etc/rc.conf</code>. Une fois sous <code>ee</code>, toutes les commandes pour utiliser les fonctions de l’éditeur sont affichées en haut de l’écran. Le caractère <code>^</code> représente la touche <kbd>Ctrl</kbd> sur le clavier, donc <code>^e</code> représente la combinaison de touches <span class=keyseq><kbd>Ctrl</kbd>+<kbd>e</kbd></span>. Pour quitter ee, appuyez sur la touche <kbd>Echap</kbd>, ensuite choisissez "leave editor". L’éditeur vous demandera s’il doit sauver les changements si le fichier a été modifié.</p></div><div class=paragraph><p>FreeBSD est également fourni avec des éditeurs de texte plus puissants comme vi en tant qu’élément du système de base, alors que d’autres éditeurs, comme Emacs et vim, en tant qu’élément du catalogue des logiciels portés de FreeBSD (<a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> et <a class=package href=https://cgit.freebsd.org/ports/tree/editors/vim/>editors/vim</a>). Ces éditeurs offrent beaucoup plus de fonctionnalités et de puissance aux dépens d’être un peu plus compliqués à apprendre. Cependant si vous projetez de faire beaucoup d’édition de texte, l’étude d’un éditeur plus puissant comme vim ou Emacs vous permettra d’économiser beaucoup plus de temps à la longue.</p></div></div><div class=sect2><h3 id=basics-devices>3.11. Périphériques et fichiers spéciaux de périphérique<a class=anchor href=#basics-devices></a></h3><div class=paragraph><p>Un périphérique est un terme utilisé la plupart du temps pour les activités en rapport avec le matériel présent sur le système, incluant les disques, les imprimantes, les cartes graphiques, et les claviers. Quand FreeBSD démarre, la majorité de ce qu’affiche FreeBSD est la détection des périphériques. Vous pouvez à nouveau consulter les messages de démarrage en visualisant le fichier <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class=paragraph><p>Par exemple, <span class=filename>acd0</span> est le premier lecteur de CDROM IDE, tandis que <span class=filename>kbd0</span> représente le clavier.</p></div><div class=paragraph><p>La plupart de ces périphériques sous un système d’exploitation UNIX® peuvent être accédés par l’intermédiaire de fichiers appelés fichiers spéciaux de périphérique ("device node"), qui sont situés dans le répertoire <span class=filename>/dev</span>.</p></div><div class=sect3><h4 id=_créer_des_fichiers_spéciaux_de_périphérique>3.11.1. Créer des fichiers spéciaux de périphérique<a class=anchor href=#_créer_des_fichiers_spéciaux_de_périphérique></a></h4><div class=paragraph><p>Quand vous ajoutez un nouveau périphérique à votre système, ou compilez le support pour des périphériques supplémentaires, de nouveaux fichiers spéciaux de périphérique doivent être créés.</p></div><div class=sect4><h5 id=_devfs_device_file_system_système_de_fichiers_de_périphérique>3.11.1.1. <code>DEVFS</code> ("DEVice File System" - Système de fichiers de périphérique)<a class=anchor href=#_devfs_device_file_system_système_de_fichiers_de_périphérique></a></h5><div class=paragraph><p>Le système de fichiers de périphérique, ou <code>DEVFS</code>, fournit un accès à l’espace nom des périphériques du noyau dans l’espace nom du système de fichiers global. Au lieu d’avoir à créer et modifier les fichiers spéciaux de périphérique, <code>DEVFS</code> maintient ce système de fichiers particulier pour vous.</p></div><div class=paragraph><p>Voir la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> pour plus d’information.</p></div></div></div></div><div class=sect2><h3 id=binary-formats>3.12. Le format des fichiers binaires<a class=anchor href=#binary-formats></a></h3><div class=paragraph><p>Afin de comprendre pourquoi FreeBSD utilise le format <a href="https://man.freebsd.org/cgi/man.cgi?query=elf&amp;sektion=5&amp;format=html">elf(5)</a>, vous devez d’abord connaître quelques détails concernant les trois formats "dominants" d’exécutables actuellement en vigueur sous UNIX®:</p></div><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a></p><div class=paragraph><p>Le plus vieux et le format objet "classique" d’UNIX®. Il utilise une entête courte et compacte avec un nombre magique au début qui est souvent utilisé pour caractériser le format (voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a> pour plus de détails). Il contient trois segments chargés: .text, .data, et .bss plus une table de symboles et une table de chaînes de caractères.</p></div></li><li><p>COFF</p><div class=paragraph><p>Le format objet SVR3. L’entête comprend une table de section, de telle sorte que vous avez plus de sections qu’uniquement .text, .data et .bss.</p></div></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=elf&amp;sektion=5&amp;format=html">elf(5)</a></p><div class=paragraph><p>Le successeur de COFF, qui permet des sections multiples et des valeurs possibles de 32 bits et 64 bits. Un inconvénient majeur: ELF a aussi été conçu en supposant qu’il y aurait qu’un seul ABI par architecture système. Cette hypothèse est en fait assez incorrecte, et même dans le monde SYSV (qui a au moins trois ABIs: SVR4, Solaris, SCO) cela ne se vérifie pas.</p></div><div class=paragraph><p>FreeBSD essaye de contourner ce problème en fournissant un utilitaire pour <em>marquer</em> un exécutable connu ELF avec des informations sur l’ABI qui va avec. Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> pour plus d’informations.</p></div></li></ul></div><div class=paragraph><p>FreeBSD vient du camp "classique" et a utilisé le format <a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a>, une technologie employée et éprouvée à travers des générations de BSDs, jusqu’aux débuts de la branche 3.X. Bien qu’il fut possible de compiler et d’exécuter des binaires natifs ELF (et noyaux) sous FreeBSD avant cela, FreeBSD a initialement résisté à la "pression" de passer à ELF comme format par défaut. Pourquoi? Bien, quand le camp Linux ont fait leur pénible transition vers ELF, ce n’est pas tant fuir le format <span class=filename>a.out</span> qui rendait difficile la construction de bibliothèques partagée pour les développeurs mais le mécanisme de bibliothèques partagées basé sur des tables de sauts inflexible. Puisque les outils ELF disponibles offraient une solution au problème des bibliothèques partagées et étaient perçus comme "le chemin à suivre" de toute façon, le coût de la migration a été accepté comme nécessaire, et la transition a été réalisée. Le mécanisme FreeBSD de bibliothèques partagées se rapproche plus du style de mécanisme de bibliothèques partagées de SunOS™ de Sun, et est très simple à utiliser.</p></div><div class=paragraph><p>Pourquoi existe-t-il tant de formats différents?</p></div><div class=paragraph><p>Dans un obscure et lointain passé, il y avait du matériel simple. Ce matériel simple supportait un simple petit système. <span class=filename>a.out</span> était complètement adapté pour représenter les binaires sur ce système simple (un PDP-11). Au fur et à mesure que des personnes portaient UNIX® à partir de ce système simple, ils ont maintenus le format <span class=filename>a.out</span> parce qu’il était suffisant pour les premiers portages d’UNIX® sur des architectures comme le Motorola 68k, les VAX, etc.</p></div><div class=paragraph><p>Alors un certain ingénieur matériel brillant a décidé qu’il pourrait forcer le matériel à faire des choses bizarre, l’autorisant ainsi à réduire le nombre de portes logiques et permettant au coeur du CPU de fonctionner plus rapidement. Bien qu’on l’a fait fonctionner avec ce nouveau type de matériel (connu de nos jour sous le nom de RISC), <span class=filename>a.out</span> n’était pas adapté à ce matériel, aussi beaucoup de formats ont été développés pour obtenir de meilleures performances de ce matériel que ce que pouvait offrir le simple et limité format qu’était <span class=filename>a.out</span>. Des choses comme COFF, ECOFF, et quelques autres obscures formats ont été inventé et leur limites explorées avant que les choses ne se fixent sur ELF.</p></div><div class=paragraph><p>En outre, les tailles des programmes devenaient énormes alors que les disques (et la mémoire physique) étaient toujours relativement petits, aussi le concept de bibliothèque partagée est né. Le système de VM (mémoire virtuelle) est également devenu plus sophistiqué. Tandis que chacune de ces avancées était faites en utilisant le format <span class=filename>a.out</span>, son utilité a été élargie de plus en plus avec chaque nouvelle fonction. De plus les gens ont voulu charger dynamiquement des choses à l’exécution, ou se débarrasser de partie de leur programme après l’initialisation pour économiser de l’espace mémoire et de pagination. Les langages sont devenus plus sophistiqués et les gens ont voulu du code appelé automatiquement avant la partie principale du programme. Beaucoup de modifications ont été apportées au format <span class=filename>a.out</span> pour rendre possible toutes ces choses, et cela a fonctionné pendant un certain temps. Avec le temps, <span class=filename>a.out</span> n’était plus capable de gérer tous ces problèmes sans une augmentation toujours croissante du code et de sa complexité. Tandis ELF résolvait plusieurs de ces problèmes, il aurait été pénible de quitter un système qui a fonctionné. Ainsi ELF a dû attendre jusqu’au moment où il était plus pénible de rester avec <span class=filename>a.out</span> que d’émigrer vers ELF.</p></div><div class=paragraph><p>Cependant, avec le temps, les outils de compilation desquels ceux de FreeBSD sont dérivés (l’assembleur et le chargeur tout spécialement) ont évolué en parallèle. Les développeurs FreeBSD ajoutèrent les bibliothèques partagées et corrigèrent quelques bogues. Les gens de chez GNU qui ont à l’origine écrit ces programmes, les récrivirent et ajoutèrent un support plus simple pour la compilation multi-plateformes, avec différents formats à volonté, et ainsi de suite. Lorsque beaucoup de personnes ont voulu élaborer des compilateurs multi-plateformes pour FreeBSD, elles n’eurent pas beaucoup de chance puisque les anciennes sources que FreeBSD avait pour as et ld n’étaient pas adaptées à cette tâche. Le nouvel ensemble d’outils de GNU (binutils) supporte la compilation multi-plateformes, ELF, les bibliothèques partagées, les extensions C++, etc. De plus, de nombreux vendeurs de logiciels fournissent des binaires ELF, et c’est une bonne chose pour permettre leur exécution sous FreeBSD.</p></div><div class=paragraph><p>ELF est plus expressif qu'<span class=filename>a.out</span> et permet plus d’extensibilité dans le système de base. Les outils ELF sont mieux maintenus, et offrent un support pour la compilation multi-plateformes, ce qui est important pour de nombreuses personnes. ELF peut être légèrement plus lent qu'<span class=filename>a.out</span>, mais tenter de mesurer cette différence n’est pas aisé. Il y a également de nombreux détails qui diffèrent entre les deux dans la façon dont ils mappent les pages mémoire, gère le code d’initialisation, etc. Dans le futur, le support <span class=filename>a.out</span> sera retiré du noyau <span class=filename>GENERIC</span>, et par la suite retiré des sources du noyau une fois que le besoin d’exécuter d’anciens programmes <span class=filename>a.out</span> aura disparu.</p></div></div><div class=sect2><h3 id=basics-more-information>3.13. Pour plus d’information<a class=anchor href=#basics-more-information></a></h3><div class=sect3><h4 id=basics-man>3.13.1. Les pages de manuel<a class=anchor href=#basics-man></a></h4><div class=paragraph><p>La documentation la plus complète sur FreeBSD est sous la forme de pages de manuel. Presque chaque programme sur le système est fournit avec un court manuel de référence expliquant l’utilisation de base et les diverses options. Ces manuels peuvent être visualisés avec la commande <code>man</code>. L’utilisation de la commande <code>man</code> est simple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>command</span></code></pre></div></div><div class=paragraph><p><code>command</code> est le nom de la commande à propos de laquelle vous désirez en savoir plus. Par exemple, pour en savoir plus au sujet de la commande <code>ls</code> tapez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>Les manuels en ligne sont divisés en sections numérotées:</p></div><div class="olist arabic"><ol class=arabic><li><p>Commandes utilisateur.</p></li><li><p>Appels système et numéros d’erreur.</p></li><li><p>Fonctions des bibliothèques C.</p></li><li><p>Pilotes de périphérique.</p></li><li><p>Formats de fichier.</p></li><li><p>Jeux et autres divertissements.</p></li><li><p>Information diverse.</p></li><li><p>Commandes de maintenance et d’utilisation du système.</p></li><li><p>Information de développement du noyau.</p></li></ol></div><div class=paragraph><p>Dans certains cas, le même sujet peut apparaître dans plus d’une section du manuel en ligne. Par exemple, il existe une commande utilisateur <code>chmod</code> et un appel système <code>chmod()</code>. Dans ce cas, vous pouvez préciser à la commande <code>man</code> laquelle vous désirez en spécifiant la section:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man 1 <span class=nb>chmod</span></code></pre></div></div><div class=paragraph><p>Cela affichera la page de manuel de la commande utilisateur <code>chmod</code>. Les références à une section particulière du manuel en ligne sont traditionnellement placées entre parenthèses, ainsi <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> se rapporte à la commande utilisateur <code>chmod</code> et <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> se rapporte à l’appel système.</p></div><div class=paragraph><p>C’est parfait si vous connaissez le nom de la commande et vous souhaitez simplement savoir comment l’utiliser, mais qu’en est-il si vous ne pouvez pas vous rappelez du nom de la commande? Vous pouvez utiliser <code>man</code> pour rechercher des mots-clés dans les descriptions de commandes en employant l’option <code>-k</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nt>-k</span> mail</code></pre></div></div><div class=paragraph><p>Avec cette commande on vous affichera la liste des commandes qui ont le mot-clé "mail" dans leurs descriptions. C’est en fait équivalent à l’utilisation de la commande <code>apropos</code>.</p></div><div class=paragraph><p>Ainsi, vous regardez toutes ces commandes fantaisistes contenues dans <span class=filename>/usr/bin</span> mais vous n’avez pas la moindre idée de ce quelles font vraiment? Faites simplement:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% man <span class=nt>-f</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>ou</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% whatis <span class=k>*</span></code></pre></div></div><div class=paragraph><p>ce qui fait la même chose.</p></div></div><div class=sect3><h4 id=basics-info>3.13.2. Fichiers GNU Info<a class=anchor href=#basics-info></a></h4><div class=paragraph><p>FreeBSD inclut beaucoup d’applications et d’utilitaires produit par la Fondation pour le Logiciel Libre ( Free Software Foundation). En plus des pages de manuel, ces programmes sont fournis avec des documents hypertexte appelés fichiers <code>info</code> qui peuvent être lus avec la commande <code>info</code> ou, si vous avez installé emacs, dans le mode info d’emacs.</p></div><div class=paragraph><p>Pour utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a>, tapez simplement:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% info</code></pre></div></div><div class=paragraph><p>Pour une brève introduction, tapez <code>h</code>. Pour une référence rapide sur la commande, tapez <code>?</code>.</p></div></div></div></div></div><div class=sect1><h2 id=ports>Chapitre 4. Installer des applications: les logiciels pré-compilés et les logiciels portés<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-synopsis>4.1. Synopsis<a class=anchor href=#ports-synopsis></a></h3><div class=paragraph><p>FreeBSD est livré avec une riche collection d’outils en tant que partie du système de base. Beaucoup de choses peuvent être faites avant d’avoir besoin de recourir à l’installation d’une application tiers pour effectuer un travail précis. FreeBSD fournit deux technologies complémentaires pour installer des logiciels tiers sur votre système: le Catalogue des logiciels portés de FreeBSD (pour une installation à partir des sources), et les logiciels pré-compilés ou "paquetages" (pour installer des binaires pré-compilés). N’importe laquelle de ces deux méthodes peut être utilisée pour installer les nouvelles versions de vos applications favorites à partir d’un support local ou directement depuis le réseau.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Comment installer des logiciels tiers pré-compilés.</p></li><li><p>Comment compiler des logiciels tiers à partir des sources en utilisant le catalogue de logiciels portés.</p></li><li><p>Comment effacer les logiciels pré-compilés ou portés précédemment installés.</p></li><li><p>Comment modifier les paramètres par défaut utilisés par le catalogue des logiciels portés.</p></li><li><p>Comment trouver l’application recherchée.</p></li><li><p>Comment mettre à jour vos applications.</p></li></ul></div></div><div class=sect2><h3 id=ports-overview>4.2. Généralités sur l’installation de logiciels<a class=anchor href=#ports-overview></a></h3><div class=paragraph><p>Si vous avez utilisé auparavant un système UNIX® vous saurez que la procédure typique pour installer les logiciels tiers ressemble à ceci:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Télécharger le logiciel, qui peut être distribué sous forme de code source, ou sous forme d’un binaire.</p></li><li><p>Extraire le logiciel de son format de distribution (généralement une archive tar compressée soit avec <a href="https://man.freebsd.org/cgi/man.cgi?query=compress&amp;sektion=1&amp;format=html">compress(1)</a>, soit avec <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, ou encore <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a>).</p></li><li><p>Recherchez la documentation (peut être un fichier <span class=filename>INSTALL</span> ou <span class=filename>README</span>, ou des fichiers dans un sous répertoire <span class=filename>doc/</span>) et lisez les informations sur comment installer le logiciel.</p></li><li><p>Si le logiciel était distribué sous forme de sources, compilez-le. Cela peut impliquer l’édition d’un <span class=filename>Makefile</span>, ou l’exécution d’une procédure <code>configure</code>, et d’autres activités.</p></li><li><p>Tester et installer le logiciel.</p></li></ol></div></div></div><div class=paragraph><p>Et cela si seulement tout se passe bien. Si vous installez un logiciel qui n’a pas été spécialement porté pour FreeBSD, il se peut que vous deviez éditer le code source pour le faire fonctionner correctement.</p></div><div class=paragraph><p>Si vous le voulez, vous pouvez continuer d’installer des logiciels suivant la méthode "traditionnelle" sous FreeBSD. Cependant, FreeBSD fournit deux technologies avec lesquelles vous pouvez vous économiser beaucoup d’efforts: les logiciels pré-compilés et le catalogue des logiciels portés. A l’heure de l’écriture de ces lignes, plus de 36000 applications tierces sont ainsi mises à disposition.</p></div><div class=paragraph><p>Pour n’importe quelle application donnée, le logiciel pré-compilé FreeBSD pour cette application est un unique fichier à télécharger. Il contient les copies pré-compilées de toutes les commandes de l’application, ainsi que tous fichiers de configuration et documentation. Un logiciel pré-compilé téléchargé peut être manipulé avec les commandes FreeBSD de gestion des logiciels pré-compilés, comme <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a>, et ainsi de suite. L’installation d’une nouvelle application peut être effectuée grâce à une unique commande.</p></div><div class=paragraph><p>Un logiciel porté pour FreeBSD est un ensemble de fichiers conçus pour automatiser le processus de compilation d’une application à partir du code source.</p></div><div class=paragraph><p>Rappelez-vous qu’il y a un certain nombre d’étapes que vous effectueriez si vous compiliez un programme vous-même (téléchargement, extraction, application de correctifs, compilation, installation). Les fichiers qui composent un logiciel porté contiennent toute l’information nécessaire pour permettre au système de faire cela pour vous. Vous lancez une poignée de commandes simples et le code source de l’application est automatiquement téléchargé, extrait, corrigé, compilé, et installé pour vous.</p></div><div class=paragraph><p>En fait, le catalogue des logiciels portés peut être utilisé pour générer ce qui pourra plus tard être manipulé avec <code>pkg_add</code> et d’autres commandes de gestion des logiciels pré-compilés qui seront présentés sous peu.</p></div><div class=paragraph><p>Les logiciels pré-compilés et le catalogue des logiciels portés comprennent la notion de <em>dépendances</em>. Supposez que vous voulez installer une application qui dépend de l’installation d’une bibliothèque particulière. L’application et la bibliothèque ont été toutes deux rendues disponibles sous forme de logiciel porté pour FreeBSD ou de logiciel pré-compilé. Si vous utilisez la commande <code>pkg_add</code> ou le catalogue des logiciels portés pour ajouter l’application, tous les deux remarqueront que la bibliothèque n’a pas été installée, et installeront automatiquement en premier la bibliothèque.</p></div><div class=paragraph><p>Etant donné que les deux technologies sont presque semblables, vous pourriez vous demander pourquoi FreeBSD s’ennuie avec les deux. Les logiciels pré-compilés et le catalogue de logiciels portés ont chacun leurs propres forces, et celle que vous emploierez dépendra de votre préférence.</p></div><div class=ulist><div class=title>Avantages des logiciels pré-compilés</div><ul><li><p>L’archive compressée d’un logiciel pré-compilé est généralement plus petite que l’archive compressée contenant le code source de l’application.</p></li><li><p>Les logiciels pré-compilés ne nécessitent pas de compilation supplémentaire. Pour les grosses applications, comme Mozilla, KDE, ou GNOME cela peut s’avérer important, particulièrement si vous êtes sur un système lent.</p></li><li><p>Les logiciels pré-compilés ne demandent pas une compréhension du processus impliqué dans la compilation de logiciels sous FreeBSD.</p></li></ul></div><div class=ulist><div class=title>Avantages du catalogue des logiciels portés</div><ul><li><p>Les logiciels pré-compilés sont normalement compilés avec des options conservatrices, parce qu’ils doivent pouvoir tourner sur le plus grand nombre de systèmes. En installant à partir du catalogue des logiciels portés, vous pouvez ajuster les options de compilation pour (par exemple) générer du code spécifique au Pentium 4 ou à l’Athlon.</p></li><li><p>Certaines applications ont des options de compilation concernant ce qu’elles peuvent faire et ne pas faire. Par exemple, Apache peut être configuré avec une très large variété d’options intégrées différentes. En compilant à partir du catalogue des logiciels portés vous n’avez pas à accepter les options par défaut, et vous pouvez les configurez vous-même.</p><div class=paragraph><p>Dans certains cas, de multiples logiciels pré-compilés existeront pour la même application pour spécifier certaines configurations. Par exemple, Ghostscript est disponible comme logiciel pré-compilé <span class=filename>ghostscript</span> et <span class=filename>ghostscript-nox11</span> , en fonction de si vous avez installé ou non un serveur X11. Ce type d’arrangement est possible avec les logiciels pré-compilés, mais devient rapidement impossible si une application a plus d’une ou deux options de compilation.</p></div></li><li><p>Les licences de certains logiciels interdisent les distributions binaires. Ils doivent être distribués sous forme de code source.</p></li><li><p>Certaines personnes ne font pas confiance aux distributions binaires. Au moins avec le code source, vous pouvez (en théorie) le parcourir et chercher les problèmes potentiels par vous-même.</p></li><li><p>Si vous avez des correctifs locaux, vous aurez besoin du code source afin de les appliquer.</p></li><li><p>Certaines personnes aiment avoir le code source à portée de main, ainsi elles peuvent le lire si elles s’ennuient, le modifier, y faire des emprunts (si la licence le permet bien sûr), etc…​</p></li></ul></div><div class=paragraph><p>Pour suivre les mises à jour du catalogue des logiciels portés, inscrivez-vous à la <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>liste de diffusion à propos du catalogue des logiciels portés de FreeBSD</a> et la <a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>liste de diffusion à propos des rapports de bogue concernant le catalogue des logiciels portés de FreeBSD</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Avant d’installer une application, vous devriez consulter <a href=http://vuxml.freebsd.org/>http://vuxml.freebsd.org/</a> à la recherche de problème de sécurité concernant votre application.</p></div><div class=paragraph><p>Vous pouvez également installer <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portaudit/>ports-mgmt/portaudit</a> qui contrôlera automatiquement toutes les applications installées à la recherche de vulnérabilités connues, un contrôle sera également effectué avant toute compilation de logiciel porté. De même, vous pouvez utiliser la commande <code>portaudit -F -a</code> après avoir installé des logiciels pré-compilés.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le reste de ce chapitre expliquera comment utiliser les logiciels pré-compilés et le catalogue des logiciels portés et la gestion des logiciels tiers sous FreeBSD.</p></div></div><div class=sect2><h3 id=ports-finding-applications>4.3. Trouver votre application<a class=anchor href=#ports-finding-applications></a></h3><div class=paragraph><p>Avant que vous puissiez installer des applications vous devez savoir ce que vous voulez, et comment se nomment les applications.</p></div><div class=paragraph><p>La liste des applications disponibles pour FreeBSD augmente de jours en jours. Heureusement, il y a plusieurs façons de trouver ce que vous désirez:</p></div><div class=ulist><ul><li><p>Le site web de FreeBSD maintient à jour une liste, dans laquelle on peut effectuer des recherches, de toutes les applications disponibles à l’adresse <a href=https://www.FreeBSD.org/ports/>http://www.FreeBSD.org/ports/</a>. Le catalogue des logiciels portés est divisé en catégories, et vous pouvez soit chercher une application par son nom (si vous le connaissez), soit lister toutes les applications disponibles dans une catégorie.</p></li><li><p>Dan Langille maintient FreshPorts, à l’adresse <a href=http://www.FreshPorts.org/>http://www.FreshPorts.org/</a>. FreshPorts suit les modifications des applications dans le catalogue des logiciels portés, vous permet de "surveiller" un ou plusieurs logiciels portés, et peut vous envoyer un courrier électronique quand ils sont mis à jour.</p></li><li><p>Si vous ne connaissez pas le nom de l’application que vous voulez, essayez d’utiliser un site comme FreshMeat (<a href=http://www.freshmeat.net/>http://www.freshmeat.net/</a>) pour trouver une application, ensuite vérifiez sur le site de FreeBSD si l’application a déjà été portée.</p></li><li><p>Si vous connaissez le nom exact du logiciel, vous devez juste déterminer dans quelle catégorie il se trouve, vous pouvez utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=whereis&amp;sektion=1&amp;format=html">whereis(1)</a> pour cela. Tapez simplement <code>whereis file</code> où <em>file</em> est le programme que vous voulez installer. S’il est trouvé sur le système, on vous indiquera où il se trouve, de la manière suivante:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># whereis lsof</span>
lsof: /usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Cela nous indique que <code>lsof</code> (un utilitaire système) peut être trouvé dans le répertoire <span class=filename>/usr/ports/sysutils/lsof</span>.</p></div></li><li><p>Vous pouvez également utiliser une simple commande <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a> pour déterminer où se trouve un logiciel porté dans le catalogue de logiciels portés. Par exemple:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/ports/*/*lsof*</span>
/usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Notez que cette commande retournera tout fichier téléchargé du répertoire <span class=filename>/usr/ports/distfiles</span> correspondant à ce motif de recherche.</p></div></li><li><p>Encore une autre façon de trouver un logiciel porté particulier est d’utiliser le mécanisme de recherche interne du catalogue des logiciels portés. Pour utiliser la fonction de recherche, vous devrez vous trouver dans le répertoire <span class=filename>/usr/ports</span>. Une fois dans ce répertoire, lancez <code>make search name=program-name</code> où <em>program-name</em> représente le nom du programme que vous voulez localiser. Par exemple, si vous recherchiez <code>lsof</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make search name=lsof</span>
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span>
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps:
R-deps:</code></pre></div></div><div class=paragraph><p>La partie du message de sortie à laquelle vous devez prêter attention est la ligne "Path:", car cela vous indique où trouver le logiciel porté. Les autres informations ne sont pas nécessaires afin d’installer le logiciel porté, aussi on en parlera pas ici.</p></div><div class=paragraph><p>Pour une recherche plus en profondeur vous pouvez également utiliser <code>make search key=string</code> où <em>string</em> est le texte à rechercher. Cela recherche les noms de logiciels portés, les commentaires, les descriptions et les dépendances et peut être utilisé pour trouver des logiciels portés se rapportant à un sujet particulier si vous ne connaissez pas le nom du programme que vous cherchez.</p></div><div class=paragraph><p>Dans les deux cas, la chaîne de caractère de recherche n’est pas sensible à la casse des caractères. Rechercher "LSOF" mènera aux même résultats que la recherche de "lsof".</p></div></li></ul></div></div><div class=sect2><h3 id=packages-using>4.4. Utiliser le système des logiciels pré-compilés<a class=anchor href=#packages-using></a></h3><div class=paragraph><p>Il existe plusieurs outils utilisés pour la gestion des logiciels pré-compilés sur FreeBSD</p></div><div class=ulist><ul><li><p>Les outils de gestion en ligne de commande des logiciels pré-compilés, qui sont le sujet de la suite de cette section.</p></li></ul></div><div class=sect3><h4 id=_installation_dun_logiciel_pré_compilé>4.4.1. Installation d’un logiciel pré-compilé<a class=anchor href=#_installation_dun_logiciel_pré_compilé></a></h4><div class=paragraph><p>Vous pouvez utiliser l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> pour installer un logiciel pré-compilé FreeBSD à partir d’un fichier local ou d’un serveur sur le réseau.</p></div><div class=exampleblock><div class=title>Exemple 4. Télécharger un logiciel pré-compilé à la main puis l’installer localement</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ftp -a ftp2.FreeBSD.org</span>
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server <span class=o>(</span>Version 6.00LS<span class=o>)</span> ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is <span class=k>in </span>Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system <span class=nb>type </span>is UNIX.
Using binary mode to transfer files.
ftp&gt; <span class=nb>cd</span> /pub/FreeBSD/ports/packages/sysutils/
250 CWD <span class=nb>command </span>successful.
ftp&gt; get lsof-4.56.4.tgz
<span class=nb>local</span>: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT <span class=nb>command </span>successful.
150 Opening BINARY mode data connection <span class=k>for</span> <span class=s1>&#39;lsof-4.56.4.tgz&#39;</span> <span class=o>(</span>92375 bytes<span class=o>)</span><span class=nb>.</span>
100% |<span class=k>**************************************************</span>| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received <span class=k>in </span>5.60 seconds <span class=o>(</span>16.11 KB/s<span class=o>)</span>
ftp&gt; <span class=nb>exit</span>
<span class=c># pkg_add lsof-4.56.4.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>Si vous ne disposez pas d’une source locale de logiciels pré-compilés (comme l’ensemble de CDROM de FreeBSD) alors il sera probablement plus facile d’utiliser l’option <code>-r</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>. Cela fera déterminer automatiquement à l’utilitaire le format objet et la version corrects et ensuite récupérer et installer le logiciel pré-compilé à partir d’un site FTP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r lsof</span></code></pre></div></div><div class=paragraph><p>L’exemple ci-dessus téléchargera le logiciel pré-compilé correct sans plus d’intervention de l’utilisateur. Si vous désirez indiquer un autre miroir FreeBSD pour les logiciels pré-compilés à la place du site de distribution principal, vous devez positionner en conséquence la variable d’environnement <code>PACKAGESITE</code>, pour remplacer les paramètres par défaut. <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> utilise <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> pour télécharger les fichiers, qui respecte diverses variables d’environnement, dont <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code>, et <code>FTP_PASSWORD</code>. Il se peut que vous ayez besoin de configurer une ou plusieurs de ces dernières si vous êtes derrière un coupe-feu, ou devez utiliser un proxy FTP/HTTP. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> pour la liste complète des variables. Vous pouvez également remarquer que dans l’exemple ci-dessus <code>lsof</code> est utilisé au lieu de <code>lsof-4.56.4</code>. Quand la fonction de récupération à distance est utilisée, le numéro de version doit être retiré. <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> téléchargera automatiquement la toute dernière version de l’application.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> téléchargera la dernière version de votre application si vous êtes sous FreeBSD-CURRENT ou FreeBSD-STABLE. Si vous utilisez une version -RELEASE, il récupérera la version compilée avec votre version lors de sa publication. Il est possible de modifier ce comportement en surchargeant la variable d’environnement <code>PACKAGESITE</code>. Par exemple, si vous utilisez un système FreeBSD 8.1-RELEASE, par défaut <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> tentera de récupérer les applications pré-compilées à partir de <code><a href=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8.1-release/Latest/ class=bare>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8.1-release/Latest/</a></code>. Si vous désirez forcer <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> à télécharger les versions des logiciels pré-compilés pour FreeBSD 8-STABLE, positionnez la variable <code>PACKAGESITE</code> à <code><a href=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8-stable/Latest/ class=bare>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8-stable/Latest/</a></code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Les logiciels pré-compilés sont distribués dans les formats <span class=filename>.tgz</span> et <span class=filename>.tbz</span>. Vous pouvez les trouver sur <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/</a>, ou sur le CDROM de distribution de FreeBSD. Chaque CD de l’ensemble de 4-CD de FreeBSD (et le PowerPak, etc…​) contient des logiciels pré-compilés dans le répertoire <span class=filename>/packages</span>. L’organisation des logiciels pré-compilés est semblable à celle de l’arborescence <span class=filename>/usr/ports</span>. Chaque catégorie possède son propre répertoire, et chaque logiciel pré-compilé peut être trouvé dans le répertoire <span class=filename>All</span>.</p></div><div class=paragraph><p>La structure de répertoires du système de logiciels pré-compilés correspond à celle du catalogue des logiciels portés; ils travaillent ensemble pour former l’intégralité du système de logiciels pré-compilés/portés.</p></div></div><div class=sect3><h4 id=_gestion_des_logiciels_pré_compilés>4.4.2. Gestion des logiciels pré-compilés<a class=anchor href=#_gestion_des_logiciels_pré_compilés></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a> est un utilitaire qui liste et décrit les divers logiciels pré-compilés installés.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info</span>
cvsup-16.1          A general network file distribution system optimized <span class=k>for </span>CV
docbook-1.2         Meta-port <span class=k>for </span>the different versions of the DocBook DTD
...</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_version&amp;sektion=1&amp;format=html">pkg_version(1)</a> est un utilitaire qui récapitule les versions de tous les logiciels pré-compilés installés. Il compare la version du logiciel pré-compilé avec la version actuelle trouvée dans le catalogue des logiciels portés.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version</span>
cvsup                       <span class=o>=</span>
docbook                     <span class=o>=</span>
...</code></pre></div></div><div class=paragraph><p>Les symboles dans la seconde colonne indiquent l’âge relatif de la version installée et de la version disponible dans le catalogue des logiciels portés local.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Symbole</th><th class="tableblock halign-left valign-top">Signification</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La version du logiciel pré-compilé installée est équivalente à celle de celui trouvé dans le catalogue des logiciels portés local.</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>La version installée est plus ancienne que celle disponible dans le catalogue des logiciels portés.</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>La version installée est plus récente que celle trouvée dans le catalogue local des logiciels portés. (le catalogue local des logiciels portés est probablement ancien)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>?</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le logiciel pré-compilé ne peut être trouvé dans l’index du catalogue des logiciels portés. (Cela peut se produire quand, par exemple, un logiciel installé est supprimé du catalogue des logiciels portés ou renommé.)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Il y a de multiples versions de ce logiciel pré-compilé.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>!</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le logiciel installé existe dans l’index mais pour une raison inconnue, <code>pkg_version</code> a été incapable de comparer le numéro de version du paquetage installé avec l’entrée correspondante dans l’index.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_effacer_un_logiciel_pré_compilé>4.4.3. Effacer un logiciel pré-compilé<a class=anchor href=#_effacer_un_logiciel_pré_compilé></a></h4><div class=paragraph><p>Pour désinstaller un logiciel pré-compilé précédemment installé, utilisez l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete xchat-1.7.1</span></code></pre></div></div><div class=paragraph><p>Notez que <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a> a besoin du nom complet du paquetage et du numéro de version; la commande précédente n’aurait pas fonctionné avec <em>xchat</em> à la place de <em>xchat-1.7.1</em>. It est cependant facile de retrouver la version du paquetage installé à l’aide de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_version&amp;sektion=1&amp;format=html">pkg_version(1)</a>. Vous pouvez à la place simplement utiliser un joker:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete xchat\*</span></code></pre></div></div><div class=paragraph><p>dans ce cas, tous les logiciels dont le nom commence par <code>xchat</code> seront supprimés.</p></div></div><div class=sect3><h4 id=_divers>4.4.4. Divers<a class=anchor href=#_divers></a></h4><div class=paragraph><p>Toute l’information sur les logiciels pré-compilés est stockée dans le répertoire <span class=filename>/var/db/pkg</span>. La liste des fichiers installés pour chaque logiciel pré-compilé peut être trouvée dans des fichiers de ce répertoire.</p></div></div></div><div class=sect2><h3 id=ports-using>4.5. Utiliser le catalogue des logiciels portés<a class=anchor href=#ports-using></a></h3><div class=paragraph><p>Les sections suivantes fournissent des instructions de base sur l’utilisation du catalogue des logiciels portés pour installer et désinstaller des programmes sur votre système. Une description détaillée des cibles <code>make</code> et de variables d’environnement est disponible dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div><div class=sect3><h4 id=ports-tree>4.5.1. Obtenir le catalogue des logiciels portés<a class=anchor href=#ports-tree></a></h4><div class=paragraph><p>Avant que vous puissiez installer des logiciels portés, vous devez d’abord récupérer le catalogue des logiciels portés- qui est essentiellement un ensemble de <span class=filename>Makefiles</span>, de correctifs, et de fichiers de description habituellement placés dans <span class=filename>/usr/ports</span>.</p></div><div class=paragraph><p>Quand vous avez installé votre système FreeBSD, sysinstall vous a demandé si vous aimeriez installer le catalogue des logiciels portés. Si vous avez choisi non, vous pouvez suivre ces instructions pour obtenir le catalogue des logiciels portés:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: La méthode CVSup</strong></p></div><div class=paragraph><p>C’est une méthode rapide pour récupérer le catalogue des logiciels portés en utilisant le protocole CVSup. Si vous voulez en apprendre plus au sujet de CVSup, lisez la section <a href=./#cvsup>Utiliser CVSup</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’implémentation du protocole CVSup présente dans le système de base de FreeBSD se nomme csup.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Assurez-vous que le répertoire <span class=filename>/usr/ports</span> est vide avant d’utiliser csup pour la première fois. Si vous avez déjà un catalogue des logiciels portés, obtenu à partir d’une autre source, csup n’effacera pas les correctifs qui ont été supprimés.</p></div><div class="olist arabic"><ol class=arabic><li><p>Exécuter la commande <code>csup</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># csup -L 2 -h cvsup.FreeBSD.org /usr/shared/examples/cvsup/ports-supfile</span></code></pre></div></div><div class=paragraph><p>Remplacez <em>cvsup.FreeBSD.org</em> avec un serveur CVSup proche de vous. Voir <a href=./#cvsup-mirrors>Sites CVSup</a> (<a href=./#cvsup-mirrors>Sites CVSup</a>) pour une liste complète des sites miroirs.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains peuvent vouloir utiliser leur propre <span class=filename>ports-supfile</span>, par exemple pour éviter d’avoir à passer le serveur CVSup sur la ligne de commande.</p></div><div class="olist loweralpha procedure"><ol class=loweralpha type=a><li><p>Dans ce cas, en tant que <code>root</code>, copier <span class=filename>/usr/shared/examples/cvsup/ports-supfile</span> à un nouvel emplacement, comme <span class=filename>/root</span> ou votre répertoire d’utilisateur.</p></li><li><p>Editez <span class=filename>ports-supfile</span>.</p></li><li><p>Remplacez <em>CHANGE_THIS.FreeBSD.org</em> avec un serveur CVSup proche de vous. Voir <a href=./#cvsup-mirrors>Sites CVSup</a> (<a href=./#cvsup-mirrors>Sites CVSup</a>) pour une liste complète des sites miroirs.</p></li><li><p>Maintenant pour lancer <code>csup</code>, utilisez ce qui suit:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># csup -L 2 /root/ports-supfile</span></code></pre></div></div></li></ol></div></td></tr></tbody></table></div></li><li><p>L’exécution ultérieure de <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> téléchargera et appliquera tous les changements récents à votre catalogue des logiciels portés sans pour autant recompiler vos logiciels.</p></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: La méthode Portsnap</strong></p></div><div class=paragraph><p>Portsnap est un système alternatif de distribution du catalogue des logiciels portés. Veuillez vous reporter à la section <a href=./#portsnap>Utiliser Portsnap</a> pour une description détaillée de toutes les caractéristiques de Portsnap.</p></div><div class="olist arabic"><ol class=arabic><li><p>Téléchargez un instantané compressé du catalogue des logiciels portés dans le répertoire <span class=filename>/var/db/portsnap</span>. Vous pouvez vous déconnecter de l’Internet, si vous le désirez, après cette opération:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span></code></pre></div></div></li><li><p>Si vous exécutez Portsnap pour la première fois, il faut extraire l’instantané dans le répertoire <span class=filename>/usr/ports</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span></code></pre></div></div><div class=paragraph><p>Si votre répertoire <span class=filename>/usr/ports</span> contient déjà une version du catalogue des logiciels portés et que vous désirez juste mettre à jour, utilisez plutôt la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap update</span></code></pre></div></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: La méthode Sysinstal</strong></p></div><div class=paragraph><p>Cette méthode implique l’utilisation de sysinstall pour installer le catalogue des logiciels portés à partir du disque d’installation. Il faut noter que la version du catalogue qui sera installée est la version datant de la publication de votre disque d’installation. Si vous disposez d’un accès à l’Internet, vous devriez toujours utiliser une des méthodes précédemment exposées.</p></div><div class="olist arabic"><ol class=arabic><li><p>En tant que <code>root</code>, lancez <code>sysinstall</code> comme montré ci-dessous:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysinstall</span></code></pre></div></div></li><li><p>Faites défiler l’écran vers le bas et sélectionnez <span class=guimenuitem>Configure</span>, appuyez sur <kbd>Entrée</kbd>.</p></li><li><p>Faites défiler l’écran vers le bas et sélectionnez <span class=guimenuitem>Distributions</span>, appuyez sur <kbd>Entrée</kbd>.</p></li><li><p>Faites défiler l’écran vers le bas jusqu’à <span class=guimenuitem>ports</span>, appuyez sur <kbd>Espace</kbd>.</p></li><li><p>Remontez jusqu’à <span class=guimenuitem>Exit</span>, appuyez sur <kbd>Entrée</kbd>.</p></li><li><p>Choisissez le support d’installation désiré, comme un CDROM, par FTP, etc.</p></li><li><p>Remontez jusqu’à <span class=guimenuitem>Exit</span> et appuyez sur <kbd>Enter</kbd>.</p></li><li><p>Appuyez sur la touche <kbd>X</kbd> pour quitter sysinstall.</p></li></ol></div></div></div></div><div class=sect3><h4 id=ports-skeleton>4.5.2. Installation de logiciels portés<a class=anchor href=#ports-skeleton></a></h4><div class=paragraph><p>La première chose qui devrait être expliquée quand on aborde le catalogue des logiciels portés est ce que l’on entend par "squelette". En bref, un squelette est un ensemble minimal de fichiers qui indique à votre système FreeBSD comment compiler et installer proprement un programme. Chaque squelette contient:</p></div><div class=ulist><ul><li><p>Un fichier <span class=filename>Makefile</span>. Le fichier <span class=filename>Makefile</span> contient les diverses déclarations qui indiquent comment l’application devrait être compilée et où elle devrait être installée sur votre système.</p></li><li><p>Un fichier <span class=filename>distinfo</span>. Ce fichier contient l’information à propos des fichiers qui doivent être téléchargés pour compiler le logiciel, et leurs sommes de contrôle (en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a>), pour s’assurer que ces fichiers n’ont pas été corrompus durant le téléchargement.</p></li><li><p>Un répertoire <span class=filename>files</span>. Ce répertoire contient les correctifs pour permettre la compilation et l’installation du programme sur votre système FreeBSD. Les correctifs sont à la base de petits fichiers qui indiquent des modifications sur des fichiers particuliers. Ils sont sous forme de fichiers texte, qui disent "Effacer la ligne 10" ou "Modifier la ligne 26 par…​". Les correctifs sont également connus sous le nom de "diffs" car ils sont générés par le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>.</p><div class=paragraph><p>Ce répertoire peut également contenir d’autres fichiers utilisés pour la compilation du logiciel porté.</p></div></li><li><p>Un fichier <span class=filename>pkg-descr</span>. C’est une description plus détaillée du programme, souvent en plusieurs lignes.</p></li><li><p>Un fichier <span class=filename>pkg-plist</span>. C’est une liste de tous les fichiers qui seront installés par le logiciel porté. Il indique également au système des logiciels portés quels fichiers sont à effacer lors d’une désinstallation.</p></li></ul></div><div class=paragraph><p>Certains logiciels portés utilisent d’autres fichiers, comme <span class=filename>pkg-message</span>. Le catalogue des logiciels portés utilise ces fichiers pour faire face à certaines situations spéciales. Si vous désirez plus de détails au sujet de ces fichiers, et sur les logiciels portés en général, consultez le <a href=https://docs.freebsd.org/fr/books/porters-handbook/>Manuel du développeur de logiciels portés</a>.</p></div><div class=paragraph><p>Le logiciel porté contient les instructions pour compiler le code source, mais ne contient pas le code source. Vous pouvez obtenir le code source à partie d’un CDROM ou de l’Internet. Le code source est distribué de la façon dont l’auteur le désire. Fréquemment c’est une archive tar compressée avec gzip, mais elle pourra être compressée avec un autre outil ou même non compressée. Le code source d’un programme, peu importe la forme sous laquelle il est distribué, est appelé un fichier "distfile". Les deux méthodes pour l’installation d’un logiciel porté pour FreeBSD sont décrites ci-dessous.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vous devez avoir ouvert une session sous l’utilisateur <code>root</code> pour installer des logiciels portés.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Avant d’installer un logiciel porté, vous devez vous assurer d’avoir un catalogue des logiciels portés à jour et vous devez consulter <a href=http://vuxml.freebsd.org/>http://vuxml.freebsd.org/</a> pour les problèmes de sécurité relatifs à votre logiciel.</p></div><div class=paragraph><p>Un contrôle des problèmes de sécurité peut être effectué automatiquement par portaudit avant toute nouvelle installation d’application. Cet outil peut être trouvé dans le catalogue des logiciels porté (<a class=package href=https://cgit.freebsd.org/ports/tree/security/portaudit/>security/portaudit</a>). Vous pouvez lancer <code>portaudit -F</code> avant l’installation d’un nouveau logiciel porté, pour télécharger la base de données actualisée des vulnérabilités. Un audit de sécurité et une mise à jour de la base de données sera effectuée lors du contrôle quotidien de sécurité de la machine. Pour plus d’informations, lisez les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=portaudit&amp;sektion=1&amp;format=html">portaudit(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le catalogue des logiciels portés suppose que vous disposez d’une connection active à l’Internet. Si ce n’est pas le cas, vous devez placer manuellement une copie du distfile dans le répertoire <span class=filename>/usr/ports/distfiles</span>.</p></div><div class=paragraph><p>Pour commencer, rendez-vous dans le répertoire du logiciel porté que vous voulez installer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span></code></pre></div></div><div class=paragraph><p>Une fois à l’intérieur du répertoire <span class=filename>lsof</span> vous verrez le squelette du logiciel porté. L’étape suivante est de compiler (également appelé la "construction") le logiciel porté. Cela est fait en tapant simplement <code>make</code> à l’invite. Une fois que c’est fait, vous devriez voir quelque chose comme ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make</span>
<span class=o>&gt;&gt;</span> lsof_4.57D.freebsd.tar.gz doesn<span class=s1>&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.57
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.57
===&gt;  Applying FreeBSD patches for lsof-4.57
===&gt;  Configuring for lsof-4.57
...
[configure output snipped]
...
===&gt;  Building for lsof-4.57
...
[compilation output snipped]
...
#</span></code></pre></div></div><div class=paragraph><p>Notez qu’une fois la compilation terminée, vous vous retrouvez face à l’invite. L’étape suivante est d’installer le logiciel porté. Afin de l’installer, vous devez juste ajouter un mot à la commande <code>make</code>, et ce mot est <code>install</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make install</span>
<span class=o>===&gt;</span>  Installing <span class=k>for </span>lsof-4.57
...
<span class=o>[</span>installation output snipped]
...
<span class=o>===&gt;</span>   Generating temporary packing list
<span class=o>===&gt;</span>   Compressing manual pages <span class=k>for </span>lsof-4.57
<span class=o>===&gt;</span>   Registering installation <span class=k>for </span>lsof-4.57
<span class=o>===&gt;</span>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Une fois de retour à l’invite, vous devriez être en mesure d’exécuter l’application que vous venez juste d’installer. Comme <code>lsof</code> est un programme qui tourne avec des privilèges accrus, un avertissement sur la sécurité est affiché. Durant la compilation et l’installation de logiciels portés, vous devriez faire attention à tout avertissement qui pourrait apparaître.</p></div><div class=paragraph><p>Il est conseillé de supprimer le sous-répertoire de travail, qui contient tous les fichiers temporaires utilisés lors de la compilation. Non seulement cela consomme de l’espace disque, mais cela posera problème plus tard lors de la mise à jour vers une nouvelle version du logiciel porté.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make clean</span>
<span class=o>===&gt;</span>  Cleaning <span class=k>for </span>lsof-4.57
<span class=c>#</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vous pouvez vous économiser deux étapes supplémentaires en lançant juste <code>make install clean</code> à la place de <code>make</code>, <code>make install</code> et <code>make clean</code> sous la forme de trois étapes séparées.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains interpréteurs de commandes maintiennent un cache des commandes qui sont disponibles dans les répertoires listés dans la variable d’environnement <code>PATH</code>, pour accélérer les opérations de recherche des fichiers exécutables de ces commandes. Si vous utilisez un de ces interpréteurs de commandes, vous pourrez avoir à utiliser la commande <code>rehash</code> après l’installation d’un logiciel porté, avant que la commande fraîchement installée ne puisse être utilisée. Cette commande fonctionnera pour les interpréteurs de commandes comme <code>tcsh</code>. Utilisez la commande <code>hash -r</code> pour les interpréteurs tels que <code>sh</code>. Consultez la documentation de votre interpréteur de commandes pour plus d’information.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Certains DVD-ROMs comme le FreeBSD Toolkit de <a href=http://www.freebsdmall.com/>FreeBSD Mall</a> contiennent des distfiles. Ils peuvent être utilisés avec le catalogue des logiciels portés. Montez le DVD-ROM sous <span class=filename>/cdrom</span>. Si vous utilisez un point de montage différent, positionnez la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> <code>CD_MOUNTPTS</code>. Les distfiles nécessaires seront automatiquement utilisés s’ils sont présent sur le disque.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Soyez conscient que les licences de quelques logiciels portés n’autorisent pas leur présence sur le CD-ROM. Cela peut être dû à la nécessité de remplir un formulaire d’enregistrement avant le téléchargement, ou que la redistribution n’est pas permise, ou toute autre raison. Si vous désirez installer un logiciel porté qui n’est pas disponible sur le CD-ROM, vous devrez vous connecter afin de récupérer les fichiers nécessaires.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le catalogue des logiciels portés utilise <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> pour télécharger les fichiers, qui respecte diverses variables d’environnement, dont <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code>, et <code>FTP_PASSWORD</code>. Il se peut que vous ayez besoin de configurer une ou plusieurs de ces dernières si vous êtes derrière un coupe-feu, ou devez utiliser un proxy FTP/HTTP. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> pour la liste complète des variables.</p></div><div class=paragraph><p>Pour les utilisateurs qui ne peuvent rester connectés à l’Internet indéfiniment, il existe la commande <code>make fetch</code>. Exécutez cette commande à la base du catalogue des logiciels portés (<span class=filename>/usr/ports</span>) et les fichiers nécessaires seront téléchargés. Cette commande fonctionnera également dans les sous-répertoires du catalogue, par exemple: <span class=filename>/usr/ports/net</span>. Notez que si un logiciel porté dépend de bibliothèques particulières ou d’autres logiciels portés, cette commande de récupérera <em>pas</em> les sources de ces logiciels. Remplacez <code>fetch</code> par <code>fetch-recursive</code> si vous voulez récupérer également les sources des logiciels dont dépend un logiciel porté.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vous pouvez compiler tous les logiciels d’une catégorie ou de l’ensemble du catalogue en exécutant la commande <code>make</code> dans un répertoire de base, juste comme la commande <code>make fetch</code> précédente. C’est, cependant, une idée dangereuse étant donné que certains logiciels portés ne peuvent coexister. Dans d’autres cas, certains logiciels portés peuvent installer des fichiers différents ayant le même nom.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dans de rares cas les utilisateurs peuvent vouloir récupérer les archives à partir d’un site différent du <code>MASTER_SITES</code> par défaut (l’emplacement par défaut à partir duquel les fichiers sont téléchargés). Vous pouvez surcharger l’option <code>MASTER_SITES</code> avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/répertoire</span>
<span class=c># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre></div></div><div class=paragraph><p>Dans cet exemple nous modifions la valeur par défaut de l’option <code>MASTER_SITES</code> pour <code>ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains logiciels portés autorisent (ou même nécessitent) des options de compilation qui permettent l’activation/désactivation de parties de l’application qui ne sont pas nécessaires, de certaines options de sécurité, et autres personnalisations. Quelques noms de logiciels viennent immédiatement à l’esprit: <a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/security/gpgme/>security/gpgme</a>, et <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a>. Un message sera affiché quand de telles options sont disponibles.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_modifier_les_répertoires_par_défaut_des_logiciels_portés>4.5.2.1. Modifier les répertoires par défaut des logiciels portés<a class=anchor href=#_modifier_les_répertoires_par_défaut_des_logiciels_portés></a></h5><div class=paragraph><p>Il est parfois utile (ou obligatoire) d’utiliser des répertoires de travail ou cible différents. Les variables <code>WRKDIRPREFIX</code> et <code>PREFIX</code> permettent de modifier les répertoires par défaut. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=/usr/home/example/ports install</span></code></pre></div></div><div class=paragraph><p>compilera le logiciel dans le répertoire <span class=filename>/usr/home/example/ports</span> et installera tout dans <span class=filename>/usr/local</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make PREFIX=/usr/home/example/local install</span></code></pre></div></div><div class=paragraph><p>le compilera dans <span class=filename>/usr/ports</span> et l’installera dans <span class=filename>/usr/home/example/local</span>.</p></div><div class=paragraph><p>Et bien sûr</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre></div></div><div class=paragraph><p>combinera les deux (c’est trop long pour tenir sur cette page, mais cela devrait vous donner une idée générale).</p></div><div class=paragraph><p>Alternativement, ces variables peuvent également être configurées dans votre environnement. Consultez la page de manuel de votre interpréteur de commandes pour des instructions sur la procédure à suivre.</p></div></div><div class=sect4><h5 id=_travailler_avec_imake>4.5.2.2. Travailler avec <code>imake</code><a class=anchor href=#_travailler_avec_imake></a></h5><div class=paragraph><p>Certains logiciels portés qui utilisent <code>imake</code> (une partie du système X Window) ne fonctionnent pas correctement avec la variable <code>PREFIX</code>, et insisteront pour s’installer sous <span class=filename>/usr/X11R6</span>. De façon similaire, certains logiciels Perl ignorent <code>PREFIX</code> et s’installent dans l’arborescence Perl. Faire en sorte que ces logiciels portés respectent <code>PREFIX</code> est une tâche difficile voire impossible.</p></div></div><div class=sect4><h5 id=_reconfigurer_les_logiciels_portés>4.5.2.3. Reconfigurer les logiciels portés<a class=anchor href=#_reconfigurer_les_logiciels_portés></a></h5><div class=paragraph><p>Lors de la compilation de certains logiciels portés, un menu <a href="https://man.freebsd.org/cgi/man.cgi?query=ncurses&amp;sektion=3&amp;format=html">ncurses(3)</a> pourra s’afficher et à partir de celui-ci vous pourrez sélectionner certaines options de compilation. Il n’est pas inhabituel pour les utilisateurs de vouloir revoir ce menu pour ajouter, supprimer, ou modifier ces options après la compilation d’un logiciel. Il y a plusieurs manières pour y parvenir. Une possibilité est de se rendre dans le répertoire contenant le logiciel porté et de taper <code>make config</code>, qui affichera à nouveau le menu avec les mêmes options sélectionnées. Une autre possibilité est d’utiliser <code>make showconfig</code> qui vous affichera toutes les options de configuration pour le logiciel porté. Enfin, une autre possibilité est d’exécuter <code>make rmconfig</code> qui supprimera toutes les options sélectionnées et permettra donc de repartir à zéro. Toutes ces options, et bien d’autres, sont détaillées dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div></div></div><div class=sect3><h4 id=ports-removing>4.5.3. Supprimer des logiciels portés installés<a class=anchor href=#ports-removing></a></h4><div class=paragraph><p>Maintenant que vous savez comment installer des logiciels portés, vous vous demandez probablement comment les effacer, juste au cas où vous en installez un et plus tard vous vous apercevez que vous n’avez pas installé le bon logiciel porté. Nous désinstallerons notre exemple précédent (qui était <code>lsof</code> pour ceux d’entre vous qui n’ont pas suivi). Les logiciels portés sont supprimés de la même manière que pour les logiciels pré-compilés (comme décrit dans la section <a href=#packages-using>Utiliser le système des logiciels pré-compilés</a>) en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete lsof-4.57</span></code></pre></div></div></div><div class=sect3><h4 id=ports-upgrading>4.5.4. Mise à jour des logiciels portés<a class=anchor href=#ports-upgrading></a></h4><div class=paragraph><p>Tout d’abord, listez les logiciels portés périmés dont une nouvelle version est disponible dans le catalogue des logiciels portés à l’aide de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_version&amp;sektion=1&amp;format=html">pkg_version(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -v</span></code></pre></div></div><div class=sect4><h5 id=ports-file-updating>4.5.4.1. <span class=filename>/usr/ports/UPDATING</span><a class=anchor href=#ports-file-updating></a></h5><div class=paragraph><p>Une fois que vous avez mis à jour le catalogue des logiciels portés, avant de tenter la mise à jour d’un logiciel porté, vous devrez consulter le fichier <span class=filename>/usr/ports/UPDATING</span>. Ce fichier décrit les divers problèmes et les étapes supplémentaires que les utilisateurs pourront rencontrer ou devront effectuer lors de la mise à jour un logiciel porté, comme la modification de format de fichiers, le changement des emplacements des fichiers de configuration, ou des incompatibilités avec les versions antérieures.</p></div><div class=paragraph><p>Si le contenu du fichier <span class=filename>UPDATING</span> prime même s’il est en est en contradiction avec des informations présentées ici.</p></div></div><div class=sect4><h5 id=portupgrade>4.5.4.2. Mise à jour des logiciels portés à l’aide de portupgrade<a class=anchor href=#portupgrade></a></h5><div class=paragraph><p>Le logiciel portupgrade a été conçu pour une mise à jour aisée des logiciels portés installés. Il est disponible via le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a>. Installez-le de la même manière que pour n’importe quel autre logiciel en employant la commande <code>make install clean</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Ensuite, parcourez la liste des logiciels installés avec la commande <code>pkgdb -F</code> et corrigez toutes les inconsistances qu’il signale. C’est une bonne idée d’effectuer ce contrôle régulièrement avant chaque mise à jour.</p></div><div class=paragraph><p>En lançant <code>portupgrade -a</code>, portupgrade mettra à jour tous les logiciels portés périmés installés sur votre système. Ajoutez l’indicateur <code>-i</code> si vous voulez être consulté pour confirmer chaque mise à jour individuelle.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -ai</span></code></pre></div></div><div class=paragraph><p>Si vous désirez mettre à jour qu’une seule application bien particulière et non pas l’intégralité des applications, utilisez la commande: <code>portupgrade nom_du_logiciel_porté</code>. Ajoutez l’option <code>-R</code> si portupgrade doit mettre à jour en premier lieu tous les logiciels portés nécessaires à l’application.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -R firefox</span></code></pre></div></div><div class=paragraph><p>Pour utiliser les versions pré-compilées plutôt que les logiciels portés pour l’installation, utilisez l’option <code>-P</code>. Avec cette option portupgrade cherche les répertoires locaux listé dans la variable <code>PKG_PATH</code>, ou récupère les paquetages à partir d’un site distant s’ils ne sont pas trouvés localement. Si les paquetages ne peuvent pas être trouvés localement ou récupérés à distance, portupgrade utilisera les logiciels portés. Pour éviter l’usage des logiciels portés, spécifiez l’option <code>-PP</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PP gnome2</span></code></pre></div></div><div class=paragraph><p>Pour juste récupérer les sources (ou les paquetages, si l’option <code>-P</code> est utilisée) sans compiler ni installer quelque chose, utilisez <code>-F</code>. Pour plus d’informations consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=portupgrade&amp;sektion=1&amp;format=html">portupgrade(1)</a>.</p></div></div><div class=sect4><h5 id=portmanager>4.5.4.3. Mise à jour des logiciels portés à l’aide de Portmanager<a class=anchor href=#portmanager></a></h5><div class=paragraph><p>Portmanager est un autre utilitaire de mise à jour aisée des logiciels portés installés. Il est disponible via le logiciel portés <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmanager/>ports-mgmt/portmanager</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmanager</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Tous les logiciels portés installés peuvent être mis à jour en utilisant cette simple commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager -u</span></code></pre></div></div><div class=paragraph><p>Vous pouvez ajouter l’option <code>-ui</code> pour être sollicité pour une confirmation à chaque opération qu’effectuera Portmanager. Portmanager peut également être employé pour installer de nouveaux logiciels portés sur le système. Contrairement à la commande <code>make install clean</code> habituelle, il mettra à jour toutes les dépendances avant de compiler et d’installer le logiciel sélectionné.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager x11/gnome2</span></code></pre></div></div><div class=paragraph><p>Si des problèmes concernant les dépendances du logiciel porté sélectionné apparaissent, vous pouvez utiliser Portmanager pour toutes les recompiler dans le bon ordre. Cette recompilation achevée, le logiciel porté en question peut alors être à son tour recompilé.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager graphics/gimp -f</span></code></pre></div></div><div class=paragraph><p>Pour plus d’information, consultez la page de manuel de Portmanager.</p></div></div><div class=sect4><h5 id=portmaster>4.5.4.4. Mise à jour des logiciels portés à l’aide de Portmaster<a class=anchor href=#portmaster></a></h5><div class=paragraph><p>Portmaster est un autre utilitaire destiné à la mise à jour des logiciels installés. Portmaster a été conçu pour utiliser les outils présents dans le système de "base" (il ne dépend pas d’un autre logiciel porté) et utilise les informations contenues dans le répertoire <span class=filename>/var/db/pkg/</span> pour déterminer quel logiciel doit être mis à jour. Il est disponible à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmaster</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Portmaster répartit les logiciels portés en quatre catégories:</p></div><div class=ulist><ul><li><p>logiciels dits "Root" (pas de dépendance, aucun logiciel n’en dépend);</p></li><li><p>logiciels dits "Trunk" (pas de dépendance, d’autres logiciels en dépendent);</p></li><li><p>logiciels dits "Branch" (ont des dépendances, d’autres logiciels en dépendent);</p></li><li><p>logiciels dits "Leaf" (ont des dépendances, aucun logiciel n’en dépend).</p></li></ul></div><div class=paragraph><p>Vous pouvez lister tous les logiciels installés et rechercher les mises à jour en utilisant l’option <code>-L</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -L</span>
<span class=o>===&gt;&gt;&gt;</span> Root ports <span class=o>(</span>No dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> ispell-3.2.06_18
<span class=o>===&gt;&gt;&gt;</span> screen-4.0.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: screen-4.0.3_1
<span class=o>===&gt;&gt;&gt;</span> tcpflow-0.21_1
<span class=o>===&gt;&gt;&gt;</span> 7 root ports
...
<span class=o>===&gt;&gt;&gt;</span> Branch ports <span class=o>(</span>Have dependencies, are depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> apache-2.2.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: apache-2.2.8
...
<span class=o>===&gt;&gt;&gt;</span> Leaf ports <span class=o>(</span>Have dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> automake-1.9.6_2
<span class=o>===&gt;&gt;&gt;</span> bash-3.1.17
        <span class=o>===&gt;&gt;&gt;</span> New version available: bash-3.2.33
...
<span class=o>===&gt;&gt;&gt;</span> 32 leaf ports

<span class=o>===&gt;&gt;&gt;</span> 137 total installed ports
        <span class=o>===&gt;&gt;&gt;</span> 83 have new versions available</code></pre></div></div><div class=paragraph><p>L’ensemble des logiciels portés installés peut être mis à jour en utilisant cette simple commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -a</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Par défaut Portmaster fera une sauvegarde avant la suppression d’un logiciel porté. Si l’installation de la nouvelle version se passe correctement, Portmaster supprimera la sauvegarde. L’option <code>-b</code> demandera à Portmaster de ne pas supprimer automatiquement la sauvegarde. L’ajout de l’option <code>-i</code> lancera Portmaster en mode interactif, vous serez alors sollicité avant la mise à jour de chaque logiciel.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous rencontrez des erreurs lors du processus de mise à jour, vous pouvez utiliser l’option <code>-f</code> pour mettre à jour ou recompiler tous les logiciels installés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>Vous pouvez également employer Portmaster pour installer de nouveaux logiciels portés en mettant à jour toutes les dépendances avant la compilation et l’installation du nouveau logiciel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster shells/bash</span></code></pre></div></div><div class=paragraph><p>Pour plus d’information veuillez consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a>.</p></div></div></div><div class=sect3><h4 id=ports-disk-space>4.5.5. Logiciels portés et espace disque<a class=anchor href=#ports-disk-space></a></h4><div class=paragraph><p>A la longue, l’utilisation du catalogue des logiciels portés consommera rapidement votre espace disque. Après la compilation et l’installation de logiciels à partir du catalogue des logiciels portés, vous devriez toujours penser à supprimer les répertoires de travail temporaires, <span class=filename>work</span>, en utilisant la commande <code>make clean</code>. Vous pouvez balayer l’intégralité du catalogue des logiciels portés pour supprimer tous les répertoires temporaires oubliés précédement, employez alors la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -C</span></code></pre></div></div><div class=paragraph><p>Avec le temps, vous accumulerez beaucoup de fichiers sources obsolètes dans le répertoire <span class=filename>distfiles</span>. Vous pouvez les supprimer manuellement, ou vous pouvez utiliser la commande suivante pour effacer toutes les sources qui ne correspondent plus à des logiciels portés d’actualité:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -D</span></code></pre></div></div><div class=paragraph><p>Ou pour supprimer les fichiers sources ne correspondant à aucun logiciel installé sur votre systèmes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’utilitaire <code>portsclean</code> fait partie de la suite portupgrade.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pensez à supprimer les logiciels portés installés que vous n’utilisez plus. Un outil qui permet d’automatiser cette tâche est disponible via le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg_cutleaves/>ports-mgmt/pkg_cutleaves</a>.</p></div></div></div><div class=sect2><h3 id=ports-nextsteps>4.6. Activités de post-installation<a class=anchor href=#ports-nextsteps></a></h3><div class=paragraph><p>Après l’installation d’une nouvelle application vous voudrez normalement lire la documentation qui a pu être également installée, éditer les fichiers de configuration nécessaires, vérifier que l’application est lancée au démarrage (si c’est un daemon), et ainsi de suite.</p></div><div class=paragraph><p>Les étapes que vous devez suivre pour configurer chaque application seront bien évidemment différentes. Cependant, si vous venez juste d’installer une nouvelle application et que vous vous demandez "Et maintenant?" les astuces suivantes pourront vous aider:</p></div><div class=ulist><ul><li><p>Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a> pour déterminer quels fichiers ont été installés et à quel endroit. Par exemple, si vous venez juste d’installer FooPackage version 1.0.0, alors la commande</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info -L foopackage-1.0.0 | less</span></code></pre></div></div><div class=paragraph><p>affichera tous les fichiers installés par le logiciel pré-compilé. Portez une attention toute particulière aux fichiers dans les répertoires <span class=filename>man/</span>, qui seront des pages de manuel, dans les répertoires <span class=filename>etc/</span> , qui seront des fichiers de configuration, et dans <span class=filename>doc/</span> qui seront de la documentation plus complète.</p></div><div class=paragraph><p>Si vous n’êtes pas sûr de la version de l’application qui vient juste d’être installée, une commande comme</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info | grep -i foopackage</span></code></pre></div></div><div class=paragraph><p>déterminera tous les logiciels pré-compilés installés qui ont <em>foopackage</em> dans leur nom. Remplacez <em>foopackage</em> dans votre ligne de commande par ce qui convient.</p></div></li><li><p>Une fois que vous avez identifié où les pages de manuel de l’application ont été installées, consultez-les en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a>. De même, jetez un coup d’oeil aux exemples de fichiers de configuration, et toute autre documentation additionnelle qui peut avoir été fournie.</p></li><li><p>Si l’application a un site web, consultez-le pour de la documentation supplémentaire, des listes de questions fréquemment posées, etc. Si vous n’êtes pas sûr de l’adresse du site web, elle peut être affichée dans le résultat de la commande:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info foopackage-1.0.0</span></code></pre></div></div><div class=paragraph><p>La ligne <code>WWW:</code>, si elle est présente, devrait donner l’URL du site web de l’application.</p></div></li><li><p>Les logiciels qui doivent être lancés au démarrage (comme les serveurs Internet) installent généralement un exemple de procédure de lancement dans le répertoire <span class=filename>/usr/local/etc/rc.d</span>. Vous devriez contrôler si ce fichier est correct et l’éditer ou le renommer si nécessaire. Consultez la section <a href=./#configtuning-starting-services>Démarrer des services</a> pour plus d’informations.</p></li></ul></div></div><div class=sect2><h3 id=ports-broken>4.7. Que faire avec les logiciels portés ne fonctionnant pas?<a class=anchor href=#ports-broken></a></h3><div class=paragraph><p>Si vous rencontrez un portage qui ne fonctionne pas, il y a certaines choses que vous pouvez faire:</p></div><div class="olist arabic"><ol class=arabic><li><p>Vérifiez s’il n’y a pas de correctif en attente pour le logiciel porté dans la <a href=https://www.FreeBSD.org/support/#gnats>base des rapports de bogue</a>. Si c’est le cas, il se peut que vous puissiez utiliser le correctif proposé.</p></li><li><p>Demandez l’aide du responsable du logiciel porté. Tapez la commande <code>make maintainer</code> ou lisez le fichier <span class=filename>Makefile</span> pour trouver l’adresse électronique du responsable. Pensez à préciser le nom et la version du logiciel porté (envoyer la ligne <code>$FreeBSD:</code> du fichier <span class=filename>Makefile</span>) et les messages d’erreurs quand vous écrivez au responsable.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains logiciels portés ne sont pas maintenus par une personne mais par une <a href=https://docs.freebsd.org/en/articles/mailing-list-faq/>liste de diffusion</a>. Plusieurs, si ce n’est toutes, les adresses de ces listes ressemblent à <a href=mailto:freebsd-listname@FreeBSD.org>freebsd-listname@FreeBSD.org</a>. Veuillez prendre cela en compte en rédigeant vos questions.</p></div><div class=paragraph><p>En particulier, les logiciels portés apparaissant comme maintenus par <a href=mailto:ports@FreeBSD.org>ports@FreeBSD.org</a> ne sont en fait maintenus par personne. Correctifs et aide, s’ils y en a, provient de la communauté qui est abonnée à cette liste de diffusion. Des volontaires supplémentaires sont toujours les bienvenus!</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous n’obtenez pas de réponse, vous pouvez utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> pour soumettre un rapport de bogue (consultez <a href=https://docs.freebsd.org/fr/articles/problem-reports/>Ecrire des rapports de bogue pour FreeBSD</a>).</p></div></li><li><p>Corrigez le problème! Le <a href=https://docs.freebsd.org/fr/books/porters-handbook/>Manuel du développeur de logiciels portés</a> inclut des informations détaillées sur l’infrastructure des logiciels portés vous permettant de corriger le portage éventuellement défectueux ou même soumettre le votre!</p></li><li><p>Récupérez la version pré-compilée sur un serveur FTP proche de vous. Le catalogue de "référence" des logiciels pré-compilés se trouve sur <code>ftp.FreeBSD.org</code> dans le répertoire <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/>packages</a>, mais vérifiez <em>d’abord</em> votre <a href=http://mirrorlist.FreeBSD.org/>miroir local</a>! Il y a globalement plus de chances que cela marche, que d’essayez de compiler à partir des sources, et cela va également beaucoup plus vite. Utilisez le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> pour installer le logiciel pré-compilé sur votre système.</p></li></ol></div></div></div></div><div class=sect1><h2 id=x11>Chapitre 5. Le système X Window<a class=anchor href=#x11></a></h2><div class=sectionbody><div class=sect2><h3 id=x11-synopsis>5.1. Synopsis<a class=anchor href=#x11-synopsis></a></h3><div class=paragraph><p>Une installation de FreeBSD à l’aide de bsdinstall n’installe pas automatiquement d’interface graphique. Ce chapitre décrit comment installer et configurer Xorg, qui implémente une version libre du système X Window qui est utilisé pour fournir un environnement graphique. Il décrit ensuite comme trouver et installer un environnement de bureau ou un gestionnaire de fenêtres.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les utilisateurs préférant une méthode d’installation qui configure automatiquement Xorg devraient à <a href=https://ghostbsd.org>GhostBSD</a>, <a href=https://www.midnightbsd.org>MidnightBSD</a> or <a href=https://nomadbsd.org/>NomadBSD</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour plus d’informations sur le matériel vidéo supporté par Xorg, consultez le site Web <a href=http://www.x.org/>x.org</a>.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Les divers composants du système X Window et comment ils fonctionnent ensemble.</p></li><li><p>Comment installer et configurer Xorg.</p></li><li><p>Comment installer et configurer différents gestionnaires de fenêtres et environnements de bureau.</p></li><li><p>Comment utiliser les polices de caractères TrueType® sous Xorg.</p></li><li><p>Comment configurer votre système pour l’utilisation de procédures de connexions graphiques (XDM).</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Savoir comment installer des logiciels tiers comme décrit dans le <a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>.</p></li></ul></div></div><div class=sect2><h3 id=x-understanding>5.2. Terminologie<a class=anchor href=#x-understanding></a></h3><div class=paragraph><p>Alors qu’il n’est pas nécessaire de comprendre tout le détail des divers composants du système X Window, ni comment ils interagissent entre eux, une certaine connaissance de base de ces composants peut être utile.</p></div><div class=dlist><dl><dt class=hdlist1>Le serveur X</dt><dd><p>X a été conçu dès le départ centré autour du réseau, et adopte un modèle "client-serveur". Dans ce modèle, le "serveur X" tourne sur l’ordinateur sur lequel sont branchés le clavier, le moniteur et la souris. Le serveur est responsable de tâches telles que la gestion de l’affichage, des entrées en provenance du clavier et de la souris, et les entrées ou sorties d’autres périphériques comme une tablette ou un vidéo-projecteur. Cela jette le trouble chez certaines personnes, parce que la terminologie X est exactement le contraire de ce à quoi ils s’attendent. Ils s’attendent à ce que le "serveur X" soit la grosse machine puissante au fond du couloir, et que le "client X" soit a machine sur leur bureau.</p></dd><dt class=hdlist1>Le client X</dt><dd><p>Chaque application X, comme XTerm ou Firefox est un "client". Un client envoie des messages au serveur comme "Dessine une fenêtre aux coordonnées suivantes", et le serveur renvoie au client des messages du type "L’utilisateur vient de cliquer sur le bouton OK".</p><div class=paragraph><p>A la maison ou dans un petit bureau, le serveur X et les clients X tourneront en général sur le même ordinateur. Il est également possible de faire tourner le serveur X sur un ordinateur moins puissant et d’exécuter les applications X sur un système plus puissant. Dans ce scénario, la communication entre le client X et le serveur se fera par l’intermédiaire du réseau.</p></div></dd><dt class=hdlist1>Le gestionnaire de fenêtres</dt><dd><p>X n’essaye pas de dicter quel aspect doivent avoir les fenêtres à l’écran, comment les déplacer avec la souris, quelles combinaisons de touches devraient être utilisées pour passer de l’une à l’autre, comment devraient être les barres de titres de chaque fenêtre, etc. Au lieu de cela, X délègue cette responsabilité à une application séparée, le gestionnaire de fenêtres ("window manager"). Il existe des <a href=http://www.xwinman.org/>douzaines de gestionnaires de fenêtres</a> disponibles. Chaque gestionnaire de fenêtres propose une apparence et une prise en mains différentes: certains supportent les bureaux virtuels, d’autres permettent de personnaliser les combinaisons de touches pour la gestion du bureau, certains ont un bouton "Démarrer", et certains permettent d’utiliser des thèmes, pour un changement complet d’apparence et de prise en main du bureau. Les gestionnaires de fenêtres sont disponibles dans la catégorie <span class=filename>x11-wm</span> du catalogue des logiciels portés.</p><div class=paragraph><p>Chaque gestionnaire de fenêtre utilise un mécanisme de configuration propre. Certains demandent un fichier de configuration écrit à la main, alors que d’autres disposent d’outils graphiques pour la plupart des tâches de configuration.</p></div></dd><dt class=hdlist1>Environnement de bureau</dt><dd><p>KDE et GNOME sont considérés comme des environnements de bureau car ils intègrent une suite complète d’applications pour effectuer les tâches classiques d’un bureau informatique. Ils peuvent disposer de suites bureautiques, de navigateurs Web, ou encore de jeux.</p></dd><dt class=hdlist1>Politique de focus</dt><dd><p>Le gestionnaire de fenêtres est responsable de la politique ou stratégie de focus de la souris. Cette politique offre plusieurs méthodes pour choisir quelle fenêtre doit recevoir les frappes au clavier et comment indiquer visuellement la fenêtre actuellement active.</p><div class=paragraph><p>Une des politiques de focus est appelée "click-to-focus" ("cliquer pour obtenir le focus"). Dans ce mode, une fenêtre devient active quand elle reçoit un clic de la souris. Dans le mode "focus-follows-mouse" ("le focus suit la souris"), la fenêtre qui est sous le pointeur de la souris est la fenêtre qui a le focus et le focus est modifié en pointant sur une autre fenêtre. Si la souris est sur la fenêtre racine (ou fond d’écran), alors cette fenêtre a le focus. Dans le mode "sloppy-focus" ("focus relâché"), si la souris est déplacée sur la fenêtre racine, la dernière fenêtre à avoir eu le focus le conserve. Avec le mode focus relâché, le focus n’est modifié que si le pointeur passe sur une nouvelle fenêtre, et non pas quand il quitte la fenêtre actuelle. Dans la politique "click-to-focus", la fenêtre active est sélectionnée par un clic de la souris. La fenêtre peut être remontée au premier plan au-dessus des autres fenêtres. Toutes les frappes au clavier seront désormais dirigées vers cette fenêtre, même si le curseur est déplacé vers une autre fenêtre.</p></div><div class=paragraph><p>Les différents gestionnaires de fenêtres supportent différents modes pour le focus. Tous supportent le clic pour obtenir le focus, et une grande majorité supporte également d’autres politiques. Consultez la documentation du gestionnaire de fenêtres pour déterminer quels modes sont disponibles.</p></div></dd><dt class=hdlist1>widgets - Eléments graphiques</dt><dd><p>Widget est un terme pour désigner tous les éléments de l’interface utilisateur qui peuvent être cliqués ou manipulés d’une façon ou d’une autre. Cela comprend les boutons, les boîtes à cocher, les boutons radio, les icônes et les listes. Une boîte à outils de widgets est un ensemble d’éléments graphiques utilisés afin de créer des applications graphiques. Il existe de nombreuses boîtes à outils d’éléments graphiques populaires comme Qt, utilisée par KDE, et GTK+, utilisée par GNOME. Cela aura pour conséquence pour les applications de présenter une apparence et une prise en main différente en fonction de la famille d’éléments graphiques utilisée pour créer ces applications.</p></dd></dl></div></div><div class=sect2><h3 id=x-install>5.3. Installer X11<a class=anchor href=#x-install></a></h3><div class=paragraph><p>Sous FreeBSD, Xorg peut être installé à l’aide soit d’un paquet précompilé soit d’un logiciel porté.</p></div><div class=paragraph><p>Le paquet pré-compilé peut être installé rapidement mais avec moins d’options de personnalisation:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xorg</span></code></pre></div></div><div class=paragraph><p>Pour compiler et installer à partir du catalogue des logiciels portés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/xorg</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Chacune de ces deux méthodes d’installation installera une version complète d’Xorg. La version en paquets pré-compilés reste la meilleure option pour la plupart des utilisateurs.</p></div><div class=paragraph><p>Une plus petite version du système X adaptée aux utilisateurs expérimentés est disponible dans le paquet <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg-minimal/>x11/xorg-minimal</a>. La plupart des documentations, des bibliothèques, et des applications ne sera pas installée. Certaines applications ont besoin de ces composants additionnels pour fonctionner.</p></div></div><div class=sect2><h3 id=x-config>5.4. Configuration d’Xorg<a class=anchor href=#x-config></a></h3><div class=sect3><h4 id=x-config-quick-start>5.4.1. Démarrage rapide<a class=anchor href=#x-config-quick-start></a></h4><div class=paragraph><p>Xorg supporte les cartes graphiques, les claviers et les périphériques de pointage les plus courants.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Les cartes graphiques, moniteurs et périphériques d’entrée sont détectés automatiquement. Ne créez pas de fichier <span class=filename>xorg.conf</span> ou n’utilisez pas l’option <code>-configure</code> en dehors d’un échec de la configuration automatique.</p></div></td></tr></tbody></table></div><div class="olist arabic procedure"><ol class=arabic><li><p>Si Xorg a déjà été utilisé sur cet ordinateur avant, déplacez ou supprimez les fichiers existants:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /etc/X11/xorg.conf ~/xorg.conf.etc</span>
<span class=c># mv /usr/local/etc/X11/xorg.conf ~/xorg.conf.localetc</span></code></pre></div></div></li><li><p>Ajouter au groupe <code>video</code> ou <code>wheel</code> l’utilisateur qui exécutera Xorg pour activer l’accélération 3D quand elle est disponible. Pour ajouter l’utilisateur <em>jru</em> aux groupes disponibles:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m jru || pw groupmod wheel -m jru</span></code></pre></div></div></li><li><p>Le gestionnaire de fenêtres twm est inclu par défaut. Il est lancé quand Xorg démarre:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div></li><li><p>Sur certaines anciennes versions de FreeBSD, la console système doit être configurée en <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> avant que le retour à la console texte puisse correctement fonctionner. Consultez <a href=#x-config-kms>Kernel Mode Setting (KMS)</a>.</p></li></ol></div></div><div class=sect3><h4 id=x-config-user-group>5.4.2. Groupe utilisateur pour l’accélération graphique<a class=anchor href=#x-config-user-group></a></h4><div class=paragraph><p>L’accès à <span class=filename>/dev/dri</span> est nécessaire pour autoriser l’accélération 3D sur les cartes graphiques. Il est en général plus simple d’ajouter l’utilisateur qui exécutera X soit au groupe <code>video</code> soit au groupe <code>wheel</code>. Ici, <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> est utilisé pour ajouter l’utilisateur <em>slurms</em> au groupe <code>video</code>, ou au groupe <code>wheel</code> s’il n’y a pas de groupe <code>video</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m slurms || pw groupmod wheel -m slurms</span></code></pre></div></div></div><div class=sect3><h4 id=x-config-kms>5.4.3. Kernel Mode Setting (KMS)<a class=anchor href=#x-config-kms></a></h4><div class=paragraph><p>Quand l’ordinateur bascule de l’affichage sur la console vers une définition d’écran plus haute pour X, il doit fixer le <em>mode</em> de sortie graphique. Les versions récentes de Xorg utilisent un système présent dans le noyau pour effectuer ces changements de manière la plus efficace. Les anciennes versions de FreeBSD utilisent <a href="https://man.freebsd.org/cgi/man.cgi?query=sc&amp;sektion=4&amp;format=html">sc(4)</a> qui n’a pas connaissance du système KMS. La conséquence est qu’après avoir fermé X, l’affichage de la console système sera vide même si elle reste fonctionnelle. La nouvelle console <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> évite ce problème.</p></div><div class=paragraph><p>Ajoutez la ligne suivante au fichier <span class=filename>/boot/loader.conf</span> pour activer <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.vty=vt</pre></div></div></div><div class=sect3><h4 id=x-config-files>5.4.4. Fichiers de configuration<a class=anchor href=#x-config-files></a></h4><div class=paragraph><p>Une configuration manuelle n’est généralement pas nécessaire. Ne créez pas de fichiers de configuration à la main à moins que la configuration automatique ne fonctionne pas.</p></div><div class=sect4><h5 id=x-config-files-directory>5.4.4.1. Répertoire<a class=anchor href=#x-config-files-directory></a></h5><div class=paragraph><p>Xorg recherche ses fichiers de configuration dans plusieurs répertoires. <span class=filename>/usr/local/etc/X11/</span> est le répertoire recommandé pour ces fichiers sous FreeBSD. L’utilisation de ce répertoire permet de conserver une séparation entre les fichiers des applications et ceux du système d’exploitation.</p></div><div class=paragraph><p>Stocker les fichiers de configuration dans le répertoire <span class=filename>/etc/X11/</span> originel fonctionne toujours. Cependant, cela a pour conséquence de mélanger des fichiers concernant des applications avec ceux du système de base FreeBSD et n’est pas recommandé.</p></div></div><div class=sect4><h5 id=x-config-files-single-or-multi>5.4.4.2. Un seul ou plusieurs fichiers<a class=anchor href=#x-config-files-single-or-multi></a></h5><div class=paragraph><p>Il est plus simple d’utiliser plusieurs fichiers qui chacun individuellement s’occupe de la configuration d’un paramètre précis plutôt qu’un seul fichier <span class=filename>xorg.conf</span> traditionnel. Ces fichiers sont stockés dans le sous-répertoire <span class=filename>xorg.conf.d/</span> du répertoire principal de configuration. Son chemin d’accès complet est en général <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span>.</p></div><div class=paragraph><p>Des exemples de ces fichiers sont présentés plus bas dans cette section.</p></div><div class=paragraph><p>Le fichier unique traditionnel <span class=filename>xorg.conf</span> fonctionne toujours mais n’est ni clair ni aussi flexible que plusieurs fichiers dans le sous-répertoire <span class=filename>xorg.conf.d/</span>.</p></div></div></div><div class=sect3><h4 id=x-config-video-cards>5.4.5. Cartes graphiques<a class=anchor href=#x-config-video-cards></a></h4><div class=paragraph><p>En raison de changements effectués dans les versions récentes de FreeBSD, il est désormais possible d’utiliser les pilotes de périphériques graphiques proposés dans le catalogue des logiciels portés ou sous forme pré-compilé. Par conséquent, les utilisateurs peuvent utiliser un des pilotes disponibles à partir du logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/>graphics/drm-kmod</a>.</p></div><div id=x-config-video-cards-ports class=dlist><dl><dt class=hdlist1>Intel KMS driver</dt><dd><p>L’accélération 2D et 3D sont supportées par la plupart des cartes graphiques Intel KMS driver en provenance d’Intel.</p><div class=paragraph><p>Nom du pilote: <code>i915kms</code></p></div><div class=paragraph><p>L’accélération 2D et 3D sont supportées par la plupart des anciennes cartes graphiques Radeon KMS driver en provenance d’AMD.</p></div><div class=paragraph><p>Nom du pilote: <code>radeonkms</code></p></div><div class=paragraph><p>L’accélération 2D et 3D sont supportées par la plupart des nouvelles cartes graphiques AMD KMS driver en provenance d’AMD.</p></div><div class=paragraph><p>Nom du pilote: <code>amdgpu</code></p></div><div class=paragraph><p>Pour information, veuillez consulter <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a> ou <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a> pour une liste des GPUs supportés.</p></div></dd></dl></div><div id=x-config-video-cards-intel class=dlist><dl><dt class=hdlist1>Intel®</dt><dd><p>L’accélération 3D est supportée sur la plupart des cartes graphiques Intel® jusqu’au Ivy Bridge (HD Graphics 2500, 4000, et P4000), y compris Iron Lake (HD Graphics) et Sandy Bridge (HD Graphics 2000).</p><div class=paragraph><p>Nom du pilote: <code>intel</code></p></div><div class=paragraph><p>Pour information, consultez <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-radeon class=dlist><dl><dt class=hdlist1>AMD® Radeon</dt><dd><p>L’accélération 2D et 3D sont supportées par les cartes Radeon jusqu’à la série HD6000 comprise.</p><div class=paragraph><p>Nom du pilote: <code>radeon</code></p></div><div class=paragraph><p>Pour information, consultez <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-nvidia class=dlist><dl><dt class=hdlist1>NVIDIA</dt><dd><p>Plusieurs pilotes NVIDIA sont disponibles dans la catégorie <span class=filename>x11</span> du catalogue des logiciels portés. Installez le pilote correspondant à la carte graphique.</p><div class=paragraph><p>Pour information, consultez <a href=https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-hybrid class=dlist><dl><dt class=hdlist1>Configuration graphique hybride</dt><dd><p>Certains ordinateurs portables ont un processeur graphique supplémentaire en plus de celui intégré dans le chipset ou le microprocesseur. Le système <em>Optimus</em> combine du matériel Intel® et NVIDIA. Les <em>systèmes graphiques sélectionnables</em> ou <em>systèmes graphiques hybrides</em> sont la combinaison d’un processeur Intel® ou AMD® et d’un GPU AMD® Radeon.</p><div class=paragraph><p>L’implémentation de ces systèmes graphiques hybrides varie, et Xorg sous FreeBSD n’est pas en mesure de faire fonctionner toutes les versions.</p></div><div class=paragraph><p>Certains ordinateurs fournissent une option du BIOS pour désactiver une de ces cartes graphiques ou pour sélectionner un mode <em>discret</em> qui peut être utilisé avec un des pilotes graphiques standard. Par exemple, il est parfois possible de désactiver le GPU NVIDIA dans un système Optimus. La partie graphique Intel® peut alors être utilisée avec un pilote Intel®.</p></div><div class=paragraph><p>Les paramètres du BIOS dépendent du modèle d’ordinateur. Dans certaines situations, les deux GPU peuvent être laissés actifs, mais la création d’un fichier de configuration utilisant seulement le GPU principal dans la partie <code>Device</code> est suffisant pour qu’un tel système fonctionne.</p></div></dd></dl></div><div id=x-config-video-cards-other class=dlist><dl><dt class=hdlist1>Autres cartes graphiques</dt><dd><p>Les pilotes pour les cartes graphiques moins courantes peuvent être trouvés dans la catégorie <span class=filename>x11-drivers</span> du catalogue des logiciels portés.</p><div class=paragraph><p>Les cartes qui ne sont pas supportées par un pilote précis pourront toujours être utilisables avec le pilote <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a>. Ce pilote est installé par <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a>. Il peut également être installé manuellement en tant que <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a>. Xorg tente d’utiliser ce pilote quand un pilote spécifique à la carte graphique n’est pas trouvé.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-scfb/>x11-drivers/xf86-video-scfb</a> est un pilote graphique non-spécifique qui fonctionne sur de nombreux ordinateurs UEFI et ARM®.</p></div></dd></dl></div><div id=x-config-video-cards-file class=dlist><dl><dt class=hdlist1>Configuration du pilote graphique dans un fichier</dt><dd><p>Pour configurer le pilote Intel® dans un fichier de configuration:</p><div id=x-config-video-cards-file-intel class=exampleblock><div class=title>Exemple 5. Sélection du pilote graphique Intel® à l’aide d’un fichier</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-intel.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;intel&#34;
	# BusID    &#34;PCI:1:0:0&#34;
EndSection</pre></div></div><div class=paragraph><p>Si plus d’une carte graphique est présente, l’identifiant <code>BusID</code> peut être décommenté et paramétré pour sélectionné la carte désirée. Une liste des IDs des cartes graphiques peut être obtenu avec <code>pciconf -lv | grep -B3 display</code>.</p></div></div></div><div class=paragraph><p>Pour configurer le pilote Radeon dans un fichier de configuration:</p></div><div id=x-config-video-cards-file-radeon class=exampleblock><div class=title>Exemple 6. Sélection du pilote graphique Radeon à l’aide d’un fichier</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-radeon.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;radeon&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>Pour configurer le pilote VESA dans un fichier de configuration:</p></div><div id=x-config-video-cards-file-vesa class=exampleblock><div class=title>Exemple 7. Sélection du pilote graphique VESA à l’aide d’un fichier</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-vesa.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;vesa&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>Pour configurer le pilote <code>scfb</code> pour une utilisation avec un ordinateur UEFI ou ARM®:</p></div><div id=x-config-video-cards-file-scfb class=exampleblock><div class=title>Exemple 8. Sélection du pilote graphique <code>scfb</code> à l’aide d’un fichier</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-scfb.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;scfb&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-monitors>5.4.6. Moniteurs<a class=anchor href=#x-config-monitors></a></h4><div class=paragraph><p>Presque tous les moniteurs supportent la norme <em>Extended Display Identification Data</em> (EDID). Xorg utilise EDID pour communiquer avec le moniteur et détecter les définitions et les taux de rafraichissement supportés. Ensuite, il sélectionne la combinaison de paramètres la plus adaptée pour le moniteur.</p></div><div class=paragraph><p>Les autres définitions supportées par le moniteur peuvent être sélectionnées en indiquant celle désirée dans les fichiers de configuration, ou à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> après avoir lancé le serveur X.</p></div><div id=x-config-monitors-xrandr class=dlist><dl><dt class=hdlist1>Utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a></dt><dd><p>Exécutez <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> sans aucun paramètre pour voir la liste des sorties vidéos et des modes détectés du moniteur:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 3000 x 1920, maximum 8192 x 8192
DVI-0 connected primary 1920x1200+1080+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 495mm x 310mm
   1920x1200     59.95<span class=k>*</span>+
   1600x1200     60.00
   1280x1024     85.02    75.02    60.02
   1280x960      60.00
   1152x864      75.00
   1024x768      85.00    75.08    70.07    60.00
   832x624       74.55
   800x600       75.00    60.32
   640x480       75.00    60.00
   720x400       70.08
DisplayPort-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
HDMI-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Ceci montre que la sortie <code>DVI-0</code> est utilisée actuellement pour afficher une définition d’écran de 1920x1200 pixels à une fréquence de rafraichissement d’environ 60 Hz. Il n’y a pas de moniteur branché aux connecteurs <code>DisplayPort-0</code> et <code>HDMI-0</code>.</p></div><div class=paragraph><p>N’importe quel autre mode d’affichage peut être choisi avec <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a>. Par exemple, pour basculer sur 1280x1024 à 60 Hz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--mode</span> 1280x1024 <span class=nt>--rate</span> 60</code></pre></div></div><div class=paragraph><p>Une opération courante est d’utiliser une sortie vidéo externe sur un ordinateur portable pour un vidéo-projecteur.</p></div><div class=paragraph><p>Le type et le nombre de connecteurs de sortie varient en fonction des systèmes, et le nom donné à chaque sortie varie d’un pilote graphique à l’autre. Ce qu’un pilote appelle <code>HDMI-1</code>, un autre l’appellera <code>HDMI1</code>. Aussi la première chose à faire est de lancer <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> pour lister toutes les sorties disponibles.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS1 connected 1366x768+0+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 344mm x 193mm
   1366x768      60.04<span class=k>*</span>+
   1024x768      60.00
   800x600       60.32    56.25
   640x480       59.94
VGA1 connected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
   1280x1024     60.02 +  75.02
   1280x960      60.00
   1152x864      75.00
   1024x768      75.08    70.07    60.00
   832x624       74.55
   800x600       72.19    75.00    60.32    56.25
   640x480       75.00    72.81    66.67    60.00
   720x400       70.08
HDMI1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
DP1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Quatre sorties ont été trouvées: l’écran intégré <code>LVDS1</code>, et les connecteurs externes <code>VGA1</code>, <code>HDMI1</code>, et <code>DP1</code>.</p></div><div class=paragraph><p>Le projecteur a été connecté à la sortie <code>VGA1</code>. <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> est maintenant utilisé pour régler cette sortie sur la définition native de ce vidéo-projecteur et pour ajouter l’espace d’affichage supplémentaire à droite du bureau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--output</span> VGA1 <span class=nt>--auto</span> <span class=nt>--right-of</span> LVDS1</code></pre></div></div><div class=paragraph><p>Le paramètre <code>--auto</code> sélectionne la définition et le taux de rafraichissement détecté par EDID. Si la définition n’est pas correctement détectée, une valeur définie peut être donnée avec le paramètre <code>--mode</code> à la place de <code>--auto</code>. Par exemple, la plupart des vidéo-projecteurs acceptent une définition de 1024x768 qui est réglée avec <code>--mode 1024x768</code>.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> est souvent exécuté à partir de <span class=filename>.xinitrc</span> pour régler le mode adapté quand X est lancé.</p></div></dd></dl></div><div id=x-config-monitors-files class=dlist><dl><dt class=hdlist1>Configuration de la définition du moniteur dans un fichier</dt><dd><p>Pour configurer la définition de l’écran à 1024x768 dans un fichier de configuration:</p><div class=exampleblock><div class=title>Exemple 9. Sélection de la définition d’écran à l’aide d’un fichier</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/screen-resolution.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	SubSection &#34;Display&#34;
	Modes      &#34;1024x768&#34;
	EndSubSection
EndSection</pre></div></div></div></div><div class=paragraph><p>Les quelques moniteurs ne supportant pas l’EDID peuvent être configurés en paramétrant <code>HorizSync</code> et <code>VertRefresh</code> avec les plages de fréquences supportées par le moniteur.</p></div><div class=exampleblock><div class=title>Exemple 10. Configuration manuelle des fréquences du moniteur</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/monitor0-freq.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
	Identifier   &#34;Monitor0&#34;
	HorizSync    30-83   # kHz
	VertRefresh  50-76   # Hz
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-input>5.4.7. Périphériques d’entrée<a class=anchor href=#x-config-input></a></h4><div class=sect4><h5 id=x-config-input-keyboard>5.4.7.1. Claviers<a class=anchor href=#x-config-input-keyboard></a></h5><div id=x-config-input-keyboard-layout class=dlist><dl><dt class=hdlist1>Disposition des touches de clavier</dt><dd><p>L’emplacement normalisé des touches d’un clavier est appelé <em>disposition</em> (<em>layout</em>). Les dispositions et d’autres paramètres réglables sont listés dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=xkeyboard-config&amp;sektion=7&amp;format=html">xkeyboard-config(7)</a>.</p><div class=paragraph><p>Une disposition des touches américaine est celle utilisée par défaut. Pour sélectionner une disposition différente, configurez les options <code>XkbLayout</code> et <code>XkbVariant</code> dans une section <code>InputClass</code>. Cette configuration sera appliquée à tous les périphériques d’entrée qui correspondent à cette classe.</p></div><div class=paragraph><p>Cet exemple sélectionne une disposition de touches française.</p></div><div class=exampleblock><div class=title>Exemple 11. Configuration d’une disposition des touches de clavier</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-fr.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbLayout&#34; &#34;fr&#34;
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>Exemple 12. Configuration de plusieurs dispositions des touches</div><div class=content><div class=paragraph><p>Configuration des dispositions américaine, espagnole et ukrainienne. Le passage de l’une à l’autre de ces dispositions se fait en appuyant sur kbd[Alt+Shift]. <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xxkb/>x11/xxkb</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/x11/sbxkb/>x11/sbxkb</a> peuvent être utilisés pour un contrôle de la sélection de la disposition des touches amélioré et pour avoir des indicateurs de la disposition en cours d’utilisation.</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/kbd-layout-multi.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;All Keyboards&#34;
	MatchIsKeyboard	&#34;yes&#34;
	Option		&#34;XkbLayout&#34; &#34;us, es, ua&#34;
EndSection</pre></div></div></div></div></dd></dl></div><div id=x-config-input-keyboard-zap class=dlist><dl><dt class=hdlist1>Quitter Xorg à partir du clavier</dt><dd><p>X peut être fermé à partir d’une combinaison de touches. Par défaut, cette combinaison n’est pas définie car elle entre en conflit avec les commandes passées au clavier pour certaines applications. L’activation de cette option nécessite d’effectuer des modifications à la section <code>InputDevice</code> du clavier:</p><div class=exampleblock><div class=title>Exemple 13. Activation de la sortie d’X à l’aide du clavier</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-zap.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbOptions&#34; &#34;terminate:ctrl_alt_bksp&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect4><h5 id=x11-input-mice>5.4.7.2. Souris et périphériques de pointage<a class=anchor href=#x11-input-mice></a></h5><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Si vous utilisez <a class=package href=https://cgit.freebsd.org/ports/tree/xorg-server/>xorg-server</a> 1.20.8 ou les versions suivantes sous FreeBSD 12.1 et que vous n’utilisez pas <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a>, ajoutez la ligne <code>kern.evdev.rcpt_mask=12</code> au fichier <span class=filename>/etc/sysctl.conf</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Plusieurs paramètres de la souris peuvent être réglés avec les options de configuration. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mousedrv&amp;sektion=4&amp;format=html">mousedrv(4)</a> pour une liste complète.</p></div><div id=x11-input-mice-buttons class=dlist><dl><dt class=hdlist1>Butons de la souris</dt><dd><p>Le nombre de boutons d’une souris peut être configuré dans la section <code>InputDevice</code> du fichier <span class=filename>xorg.conf</span>. Pour fixer le nombre de boutons à 7:</p><div class=exampleblock><div class=title>Exemple 14. Réglage du nombre de boutons de la souris</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/mouse0-buttons.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier  &#34;Mouse0&#34;
	Option      &#34;Buttons&#34; &#34;7&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div></div><div class=sect3><h4 id=x-config-manual-configuration>5.4.8. Configuration manuelle<a class=anchor href=#x-config-manual-configuration></a></h4><div class=paragraph><p>Dans certains cas, la configuration automatique d’Xorg ne fonctionne pas avec un matériel spécifique, ou une configuration différente est recherchée. Pour ces cas, un fichier de configuration personnalisé peut être créé.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ne créez pas de fichiers de configuration à la main à moins que cela ne soit nécessaire. Une configuration inadaptée peut empêcher un fonctionnement correct.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Un fichier de configuration basé sur le matériel détecté peut être généré par Xorg. Ce fichier est un point de départ utile pour une configuration personnalisée.</p></div><div class=paragraph><p>Génération d’un fichier <span class=filename>xorg.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -configure</span></code></pre></div></div><div class=paragraph><p>Le fichier de configuration est enregistré sous <span class=filename>/root/xorg.conf.new</span>. Effectuez les modifications désirées, puis tester ce fichier (avec l’option <code>-retro</code> de manière à avoir un fond d’écran visible) avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -retro -config /root/xorg.conf.new</span></code></pre></div></div><div class=paragraph><p>Une fois que la nouvelle configuration a été ajustée et testée, elle peut être divisée en plus petits fichiers dans les emplacements habituels, <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span>.</p></div></div></div><div class=sect2><h3 id=x-fonts>5.5. Utilisation des polices de caractères sous Xorg<a class=anchor href=#x-fonts></a></h3><div class=sect3><h4 id=type1>5.5.1. Polices de caractères Type1<a class=anchor href=#type1></a></h4><div class=paragraph><p>Les polices de caractères livrées par défaut avec Xorg sont loin d’être idéales pour des applications de type publication. Les grandes polices utilisées pour les présentations présentent un aspect en escalier et peu professionnel, et les petites polices sont presque complètement illisibles. Cependant, il existe de nombreuses polices Type1 (PostScript®) gratuites, de hautes qualités qui peuvent être aisément utilisées avec Xorg.. Par exemple, la collection de polices de caractères URW (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/urwfonts/>x11-fonts/urwfonts</a>) comprend une version haute qualité des polices de caractères standards type1 (Times Roman™, Helvetica™, Palatino™ et autres). La collection Freefonts (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/>x11-fonts/freefonts</a>) comprend beaucoup plus de polices de caractères, mais la plupart d’entre elles sont destinées à être utilisées avec des logiciels graphiques comme Gimp, et ne sont pas suffisamment complètes pour servir de polices de caractères d’affichage. De plus Xorg peut être configuré pour utiliser les polices de caractères TrueType® avec un minimum d’effort. Pour plus de détails à ce sujet, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> ou la section <a href=#truetype>Polices de caractères TrueType®</a>.</p></div><div class=paragraph><p>Pour installer les collections de polices de caractères Type1 précédentes à partir des paquets binaires, lancez les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install urwfonts</span></code></pre></div></div><div class=paragraph><p>Pour les compiler à partir du catalogue des logiciels portés, lancez les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fonts/urwfonts</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Et de même pour la collection Freefont ou d’autres. Pour que le serveur X détecte ces polices, ajoutez une ligne appropriée au fichier de configuration du serveur X (<span class=filename>/etc/X11/xorg.conf</span>), du type:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath &#34;/usr/local/share/fonts/URW/&#34;</pre></div></div><div class=paragraph><p>Autre possibilité, en ligne de commande dans une session X lancez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/share/fonts/urwfonts
% xset fp rehash</code></pre></div></div><div class=paragraph><p>Cela fonctionnera mais la configuration sera perdue quand la session X sera fermée, à moins de l’ajouter dans le fichier de démarrage (<span class=filename>~/.xinitrc</span> pour une session <code>startx</code> classique, ou dans <span class=filename>~/.xsession</span> quand on s’attache au système par l’intermédiaire d’un gestionnaire de session graphique comme XDM). Une troisième méthode est d’utiliser le nouveau fichier <span class=filename>/usr/local/etc/fonts/local.conf</span>: comme montré dans la section <a href=#antialias>Polices de caractères anticrénelage</a>.</p></div></div><div class=sect3><h4 id=truetype>5.5.2. Polices de caractères TrueType®<a class=anchor href=#truetype></a></h4><div class=paragraph><p>Xorg dispose d’un support intégré pour le rendu des polices TrueType®. Il y a deux différents modules qui peuvent activer cette fonctionnalité. Le module freetype est utilisé dans cet exemple parce qu’il est plus compatible avec les autres moteurs de rendu des polices de caractères. Pour activer le module freetype ajoutez juste la ligne suivante dans la section <code>"Module"</code> du fichier <span class=filename>/etc/X11/xorg.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>Load  &#34;freetype&#34;</pre></div></div><div class=paragraph><p>Maintenant créez un répertoire pour les polices TrueType® (par exemple <span class=filename>/usr/local/share/fonts/TrueType</span>) et copiez toutes les polices TrueType® dans ce répertoire. Gardez à l’esprit que les polices TrueType® ne peuvent être directement prises d’un Apple® Mac®; elles doivent être dans un format UNIX®/MS-DOS®/Windows® pour être utilisées sous Xorg. Une fois les fichiers copiés dans ce répertoire, utilisez mkfontscale pour créer un fichier <span class=filename>fonts.dir</span>, de façon à ce que le moteur d’affichage des polices d’X sache que de nouveaux fichiers ont été installés. mkfontscale peut être installé à partir d’un paquet binaire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mkfontscale</span></code></pre></div></div><div class=paragraph><p>Puis créez un index des polices de caractères pour X dans le répertoire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/share/fonts/TrueType</span>
<span class=c># mkfontscale</span></code></pre></div></div><div class=paragraph><p>Maintenant ajoutez le répertoire des polices TrueType® au chemin des polices de caractères. Cela est identique à ce qui est décrit dans la section <a href=#type1>Polices de caractères Type1</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/share/fonts/TrueType
% xset fp rehash</code></pre></div></div><div class=paragraph><p>ou ajouter une ligne <code>FontPath</code> au fichier <span class=filename>xorg.conf</span>.</p></div><div class=paragraph><p>Désormais Gimp, LibreOffice, et toutes les autres applications X devraient maintenant reconnaître les polices de caractères TrueType® installées. Les polices très petites (comme le texte de page web visualisé sur un écran haute résolution) et les très grandes polices (dans LibreOffice) auront un rendu bien meilleur maintenant.</p></div></div><div class=sect3><h4 id=antialias>5.5.3. Polices de caractères anticrénelage<a class=anchor href=#antialias></a></h4><div class=paragraph><p>Toutes les polices de caractères sous Xorg se trouvant dans les répertoires <span class=filename>/usr/local/share/fonts/</span> et <span class=filename>~/.fonts/</span> sont automatiquement disponibles pour l’anticrénelage avec les applications compatibles Xft. La plupart des application sont compatibles Xft, comme KDE, GNOME, et Firefox.</p></div><div class=paragraph><p>Afin de contrôler quelles polices de caractères sont anticrénelées, ou pour configurer les propriétés de l’anticrénelage, créez (ou éditez, s’il existe déjà) le fichier <span class=filename>/usr/local/etc/fonts/local.conf</span>. Plusieurs caractéristiques avancées du système de fontes Xft peuvent être ajustées par l’intermédiaire de ce fichier; cette section ne décrit que des possibilités simples. Pour plus de détails, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a>.</p></div><div class=paragraph><p>Ce fichier doit être dans le format XML. Faites attention à la casse des caractères, et assurez-vous que toutes les balises sont correctement fermées. Le fichier débute avec l’entête XML classique suivie par une définition DOCTYPE, puis de la balise <code>fontconfig</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>	?xml version=&#34;1.0&#34;?
	!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;
	fontconfig</pre></div></div><div class=paragraph><p>Comme précisé précédemment, l’ensemble des polices de caractères du répertoire <span class=filename>/usr/local/share/fonts/</span> comme du répertoire <span class=filename>~/.fonts/</span> sont disponibles pour les applications compatibles Xft. Si vous désirez ajouter un autre répertoire en dehors des ces deux là, ajoutez une ligne similaire à la suivante au fichier <span class=filename>/usr/local/etc/fonts/local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dir/chemin/vers/mes/fontes/dir</pre></div></div><div class=paragraph><p>Après l’ajout de nouvelles polices, et tout particulièrement de nouveaux répertoires de polices, vous devrez exécuter la commande suivante pour reconstituer le cache des polices de caractères:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fc-cache -f</span></code></pre></div></div><div class=paragraph><p>L’anticrénelage rend les bords légèrement flous, ce qui rend le texte très petit plus lisible et enlève l’effet "d’escalier" des grands textes, mais peut provoquer une fatigue visuelle si c’est appliqué au texte de taille normale. Pour exclure les tailles de polices inférieures à 14 points de l’anticrénelage, ajoutez ces lignes:</p></div><div class="literalblock programlisting"><div class=content><pre>	 match target=&#34;font&#34;
	  test name=&#34;size&#34; compare=&#34;less&#34;
		double14/double
	  /test
	  edit name=&#34;antialias&#34; mode=&#34;assign&#34;
		boolfalse/bool
	  /edit
	/match
	match target=&#34;font&#34;
	  test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;
		double14/double
	  /test
	  edit mode=&#34;assign&#34; name=&#34;antialias&#34;
		boolfalse/bool
	  /edit
	/match</pre></div></div><div class=paragraph><p>L’espacement pour certaines polices de caractères à chasse fixe peut également être inapproprié avec l’anticrénelage. Cela semble être un problème avec KDE, en particulier. Une solution possible pour cela est de forcer l’espacement pour de telles polices de caractères à 100. Ajoutez les lignes suivantes:</p></div><div class="literalblock programlisting"><div class=content><pre>	 match target=&#34;pattern&#34; name=&#34;family&#34;
	  test qual=&#34;any&#34; name=&#34;family&#34;
	    stringfixed/string
	  /test
	  edit name=&#34;family&#34; mode=&#34;assign&#34;
	    stringmono/string
	  /edit
	/match
	match target=&#34;pattern&#34; name=&#34;family&#34;
	  test qual=&#34;any&#34; name=&#34;family&#34;
	    stringconsole/string
	  /test
	  edit name=&#34;family&#34; mode=&#34;assign&#34;
	    stringmono/string
	  /edit
	/match</pre></div></div><div class=paragraph><p>(ceci ajoute un alias <code>"mono"</code> pour les autres noms communs des polices de caractères fixes), puis ajoutez:</p></div><div class="literalblock programlisting"><div class=content><pre>	 match target=&#34;pattern&#34; name=&#34;family&#34;
	  test qual=&#34;any&#34; name=&#34;family&#34;
	    stringmono/string
	  /test
	  edit name=&#34;spacing&#34; mode=&#34;assign&#34;
	    int100/int
	  /edit
	/match</pre></div></div><div class=paragraph><p>Certaines polices de caractères, comme Helvetica, peuvent présenter des problèmes lors de l’anticrénelage. Généralement cela se manifeste par l’impression que la fonte semble coupée en deux verticalement. Au pire cela peut provoquer des crashs avec certaines applications. Pour éviter cela, pensez à ajouter ce qui suit au fichier <span class=filename>local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>	 match target=&#34;pattern&#34; name=&#34;family&#34;
	  test qual=&#34;any&#34; name=&#34;family&#34;
	    stringHelvetica/string
	  /test
	  edit name=&#34;family&#34; mode=&#34;assign&#34;
	    stringsans-serif/string
	  /edit
	/match</pre></div></div><div class=paragraph><p>Une fois l’édition de <span class=filename>local.conf</span> achevée, assurez-vous que le fichier se termine par la balise <code>/fontconfig</code>. Si ce n’est pas le cas, tous vos changements seront ignorés.</p></div><div class=paragraph><p>Les utilisateurs peuvent ajouter leurs propres paramètres par l’intermédiaire de leur propre fichier <span class=filename>~/.config/fontconfig/fonts.conf</span>. Ce fichier doit utiliser le même format XML décrit précédemment.</p></div><div class=paragraph><p>Un dernier point: avec un écran LCD, un échantillonnage "sub-pixel" peut être désiré. Fondamentalement, ceci traite les composantes rouge, verte et bleu séparément (horizontalement séparées) pour améliorer la résolution horizontale; les résultats peuvent être dramatiques. Pour activer cela, ajoutez quelque part dans le fichier <span class=filename>local.conf</span> les lignes:</p></div><div class="literalblock programlisting"><div class=content><pre>	 match target=&#34;font&#34;
	  test qual=&#34;all&#34; name=&#34;rgba&#34;
	    constunknown/const
	  /test
	  edit name=&#34;rgba&#34; mode=&#34;assign&#34;
	    constrgb/const
	  /edit
	/match</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En fonction de type d’écran, le terme <code>rgb</code> pourra devoir être changé pour <code>bgr</code>, <code>vrgb</code> ou <code>vbgr</code>: expérimentez pour déterminer lequel fonctionne le mieux.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x-xdm>5.6. Le gestionnaire de connexion graphique XDM<a class=anchor href=#x-xdm></a></h3><div class=paragraph><p>Xorg propose un gestionnaire de connexion graphique, XDM, qui peut être utilisé pour la gestion des procédures de connexion graphique. XDM fournit une interface graphique pour sélectionner à quel serveur d’affichage se connecter et entrer des informations d’autorisation d’accès comme l’ensemble identifiant et mot de passe.</p></div><div class=paragraph><p>Cette section montre comment configurer le gestionnaire de connexion graphique X sous FreeBSD. Certains environnements de bureau fournissent leur propre gestionnaire de connexion graphique. Se référer à la <a href=#x11-wm-gnome>GNOME</a> pour des instructions sur comment configurer le gestionnaire de connexion graphique GNOME et à la <a href=#x11-wm-kde>KDE</a> pour des instructions concernant la configuration du gestionnaire de connexion graphique KDE.</p></div><div class=sect3><h4 id=_configurer_xdm>5.6.1. Configurer XDM<a class=anchor href=#_configurer_xdm></a></h4><div class=paragraph><p>Pour installer XDM, utilisez le logiciel porté ou la version pré-compilée <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xdm/>x11/xdm</a>. Une fois installé, XDM peut être configuré pour être lancé au démarrage de la machine en modifiant la ligne suivante dans <span class=filename>/etc/ttys</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ttyv8   <span class=s2>&#34;/usr/local/bin/xdm -nodaemon&#34;</span>  xterm   off secure</code></pre></div></div><div class=paragraph><p>Modifiez le <code>off</code> pour <code>on</code> et sauvegardez la modification. Le champ <code>ttyv8</code> sur cette ligne indique que XDM démarrera sur le neuvième terminal virtuel.</p></div><div class=paragraph><p>Le répertoire de configuration d’XDM est situé dans <span class=filename>/usr/local/etc/X11/xdm</span>. Ce répertoire contient plusieurs fichiers utilisés pour modifier le comportement et l’apparence d’XDM, ainsi que quelques procédures et programmes utilisés pour configurer le bureau quand XDM est exécuté. <a href=#xdm-config-files>Fichiers de configuration d’XDM</a> résume la fonction de chacun de ces fichiers. La syntaxe exacte et l’utilisation de ces fichiers sont décrites dans <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div><table id=xdm-config-files class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 3. Fichiers de configuration d’XDM</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Fichier</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xaccess</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le protocole utilisé pour se connecter à XDM est appelé le "X Display Manager Connection Protocol" (XDMCP). Ce fichier est un ensemble de règles d’autorisation client pour contrôler les connexions XDMCP à partir de machines distantes. Par défaut, ce fichier n’autorise pas la connexion de clients distants.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xresources</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ce fichier contrôle l’apparence et la prise en main du programme de sélection et d’ouverture de session XDM. La configuration par défaut est une simple fenêtre d’ouverture de session rectangulaire avec le nom de la machine hôte affiché en haut dans une grande police de caractères et avec les invites "Login:" et "Password:" en dessous. Le format de ce fichier est identique au fichier de paramètres par défaut décrit dans la documentation Xorg</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xservers</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Liste des affichages distants et locaux que le système doit proposer à l’ouverture de session.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsession</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Procédure d’ouverture de session par défaut qui est exécutée par XDM quand un utilisateur se connecte. Elle pointe vers une procedure personnalisée de session dans le répertoire <span class=filename>~/.xsession</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsetup_</span>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Procédures utilisées pour lancer automatiquement des applications avant d’afficher les interfaces de sélection et d’ouverture de session. Il existe une procedure pour chaque écran utilisé, nommée <span class=filename>Xsetup_*</span>, où <code>*</code> est le numéro local de l’écran. En général, ces procédures exécutent un ou deux programmes en tâche de fond comme <code>xconsole</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-config</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration globale pour tous les écrans tournant sur cette machine.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-errors</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Contient les erreurs générées par le programme serveur. Si une connexion qu’XDM tente d’ouvrir se bloque, examinez ce fichier pour trouver des messages d’erreur. Ces messages sont également écrits dans le fichier <span class=filename>~/.xsession-errors</span> de l’utilisateur à chaque session.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-pid</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’identifiant, ID, du processus exécutant XDM.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_configurer_laccès_à_distance>5.6.2. Configurer l’accès à distance<a class=anchor href=#_configurer_laccès_à_distance></a></h4><div class=paragraph><p>Par défaut, seuls les utilisateurs sur le même système peuvent ouvrir une session en utilisant XDM. Pour permettre aux utilisateurs d’autres système de se connecter au gestionnaire d’affichage, éditez les règles de contrôle d’accès et activez l’écoute des demandes de connexion.</p></div><div class=paragraph><p>Pour configurer XDM pour l’écoute des demandes de connexions distantes, commentez la ligne <code>DisplayManager.requestPort</code> dans le fichier <span class=filename>/usr/local/etc/X11/xdm/xdm-config</span> en ajoutant un <code>!</code> devant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span> SECURITY: <span class=k>do </span>not listen <span class=k>for </span>XDMCP or Chooser requests
<span class=o>!</span> Comment out this line <span class=k>if </span>you want to manage X terminals with xdm
DisplayManager.requestPort:     0</code></pre></div></div><div class=paragraph><p>Sauvegardez et relancez XDM. Pour restreindre l’accès à distance, consultez les exemples dans <span class=filename>/usr/local/etc/X11/xdm/Xaccess</span> ainsi que la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> pour plus d’informations</p></div></div></div><div class=sect2><h3 id=x11-wm>5.7. Environnements de bureau<a class=anchor href=#x11-wm></a></h3><div class=paragraph><p>Cette section décrit comment installer sur un système FreeBSD un des trois environnements de bureau populaires. Un environnement de bureau peut aller du simple gestionnaire de fenêtres jusqu’à la suite complète d’applications de bureau. Plus d’une centaine d’environnements est disponible dans la catégorie <span class=filename>x11-wm</span> du catalogue des logiciels portés.</p></div><div class=sect3><h4 id=x11-wm-gnome>5.7.1. GNOME<a class=anchor href=#x11-wm-gnome></a></h4><div class=paragraph><p>GNOME est un environnement de bureau convivial. Il comprend un panneau ("panel") pour lancer des applications et afficher des états, un bureau, un ensemble d’outils et d’applications, et un ensemble de conventions qui rendent aisée la coopération et la cohérence entre applications. Plus d’informations concernant GNOME sous FreeBSD peuvent être trouvées sur <a href=https://www.FreeBSD.org/gnome>https://www.FreeBSD.org/gnome</a>. Le site contient de la documentation supplémentaire sur l’installation, la configuration, et l’administration de GNOME sous FreeBSD.</p></div><div class=paragraph><p>Cet environnement de bureau peut être installé à partir d’un paquet pré-compilé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnome3</span></code></pre></div></div><div class=paragraph><p>Pour plutôt compiler GNOME à partir du catalogue des logiciels portés, utilisez la commande qui suit. GNOME est une application importante en taille et qui demandera un temps notable pour être compilée, et cela, même sur un ordinateur rapide.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/gnome3</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>GNOME a besoin que <span class=filename>/proc</span> soit monté. Ajoutez la ligne suivante au fichier <span class=filename>/etc/fstab</span> pour monter ce système de fichiers automatiquement au démarrage:</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>GNOME utilise D-Bus et HAL comme bus des messages et couche d’abstraction matérielle. Ces applications sont automatiquement installées comme dépendances à GNOME. Activez-les dans <span class=filename>/etc/rc.conf</span> pour qu’elles soient lancées au démarrage du système:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Après l’installation, il faut configurer Xorg pour lancer GNOME. La manière la plus simple de faire cela est d’activer le gestionnaire d’affichage de GNOME, GDM, qui est installé par défaut comme élément du paquet pré-compilé ou du logiciel porté GNOME. Il peut être activé en ajoutant la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gdm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Il est souvent intéressant de lancer également tous les services GNOME. Pour accomplir cela, ajoutez une seconde ligne à <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gnome_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>GDM sera lancé automatiquement au démarrage du système.</p></div><div class=paragraph><p>Une deuxième méthode de lancement de GNOME est de taper <code>startx</code> à partir de la ligne de commande après avoir configuré le fichier <span class=filename>~/.xinitrc</span>. Si ce fichier existe déjà, remplacez la ligne qui lance le gestionnaire de fenêtres actuel par une qui exécute <span class=filename>/usr/local/bin/gnome-session</span>. Si ce fichier n’existe pas, créez-le avec la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Une troisième méthode est d’utiliser XDM comme gestionnaire d’affichage. Dans ce cas, créez un exécutable <span class=filename>~/.xsession</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div><div class=sect3><h4 id=x11-wm-kde>5.7.2. KDE<a class=anchor href=#x11-wm-kde></a></h4><div class=paragraph><p>KDE est un autre environnement de bureau simple d’utilisation. Ce bureau propose une suite d’applications avec une apparence et une prise en main commune, des menus et des barres d’outils, des raccourcis clavier, des couleurs et une régionalisation standardisés, ainsi qu’un système de configuration de l’environnement centralisé. Plus d’informations sur KDE peuvent être trouvées sur <a href=http://www.kde.org/>http://www.kde.org/</a>. Pour des informations spécifiques à FreeBSD, consultez <a href=http://freebsd.kde.org/>http://freebsd.kde.org</a>.</p></div><div class=paragraph><p>Pour installer la version pré-compilée de KDE, tapez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/kde5</span></code></pre></div></div><div class=paragraph><p>Pour plutôt compiler KDE à partir du catalogue des logiciels portés, utilisez la commande qui suit. L’installation du logiciel porté proposera un menu pour sélectionner quel composant à installer. KDE est une application importante en taille et qui demandera un temps notable pour être compilée, et cela, même sur un ordinateur rapide.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde5</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>KDE a besoin que <span class=filename>/proc</span> soit monté. Ajoutez la ligne suivante au fichier <span class=filename>/etc/fstab</span> pour monter ce système de fichiers automatiquement au démarrage:</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>KDE utilise D-Bus et HAL comme bus des messages et couche d’abstraction matérielle. Ces applications sont automatiquement installées comme dépendances à KDE. Activez-les dans <span class=filename>/etc/rc.conf</span> pour qu’elles soient lancées au démarrage du système:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Depuis KDE Plasma 5, le gestionnaire d’affichage KDE, KDM, n’est plus développé. Un remplacement possible est SDDM. Pour l’installer, tapez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/sddm</span></code></pre></div></div><div class=paragraph><p>Ajoutez cette ligne à <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sddm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Une deuxième méthode de lancement de KDE Plasma est de taper <code>startx</code> à partir de la ligne de commande. Pour que cela fonctionne, la ligne suivante est requise dans <span class=filename>~/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ck-launch-session startplasma-x11</pre></div></div><div class=paragraph><p>Une troisième méthode de lancement de KDE Plasma utilise XDM. Dans ce cas, créez un exécutable <span class=filename>~/.xsession</span> comme indiqué:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec ck-launch-session startplasma-x11&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div><div class=paragraph><p>Une fois KDE Plasma lancée, consultez son système d’aide intégrée pour plus d’informations sur comment utiliser ses différents menus et applications.</p></div></div><div class=sect3><h4 id=x11-wm-xfce>5.7.3. XFce<a class=anchor href=#x11-wm-xfce></a></h4><div class=paragraph><p>XFce est un environnement de bureau basé sur le "toolkit" GTK+ utilisé par GNOME. Cependant, il est plus léger et offre un bureau simple, efficace et simple d’utilisation. Il est complètement configurable, dispose d’une barre principale avec des menus, des petites applications et des lanceurs d’applications, il fournit un gestionnaire de fichiers et un gestionnaire du son, et il est personnalisable avec des thèmes. Puisqu’il est rapide, léger et efficace, il est idéal pour les machines anciennes ou lentes avec des limitations en mémoire. Plus d’informations sur XFce peuvent être trouvées sur le site <a href=http://www.xfce.org/>http://www.xfce.org</a>.</p></div><div class=paragraph><p>Pour installer le paquet pré-compilé de Xfce:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xfce</span></code></pre></div></div><div class=paragraph><p>Alternativement, pour compiler le logiciel porté:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-wm/xfce4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Xfce utilise D-Bus comme bus des messages. Cette application est automatiquement installée comme dépendance à Xfce. Activez-la dans <span class=filename>/etc/rc.conf</span> pour qu’elle soit lancée au démarrage du système:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Contrairement à GNOME ou KDE, Xfce ne fournit pas son propre gestionnaire de session. Afin de lancer Xfce à partir de la ligne de commande en tapant <code>startx</code>, créez d’abord le fichier <span class=filename>~/.xinitrc</span> à l’aide de la ligne:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Une méthode alternative est d’utiliser XDM. Pour configurer cette méthode, créez un exécutable <span class=filename>~/.xsession</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div></div><div class=sect2><h3 id=x-compiz-fusion>5.8. Installation de Compiz Fusion<a class=anchor href=#x-compiz-fusion></a></h3><div class=paragraph><p>Une méthode pour rendre l’utilisation d’un ordinateur plus plaisante est l’ajout de jolis effets en 3D.</p></div><div class=paragraph><p>L’installation du paquet binaire Compiz Fusion est simple, mais sa configuration demande quelques étapes qui ne sont pas décrites dans la documentation du logiciel porté.</p></div><div class=sect3><h4 id=x-compiz-video-card>5.8.1. Configuration du pilote nVidia FreeBSD<a class=anchor href=#x-compiz-video-card></a></h4><div class=paragraph><p>Les effets visuels dans l’environnement de bureau peuvent être à l’origine d’une charge non-négligeable pour la carte graphique. Pour les cartes graphiques nVidia, le pilote de périphérique propriétaire est nécessaire pour obtenir de bonnes performances. Les utilisateurs d’autres cartes graphiques peuvent sauter cette section et poursuivre avec la partie sur la configuration d'<span class=filename>xorg.conf</span>.</p></div><div class=paragraph><p>Pour déterminer quel pilote nVidia est requis, consultez la <a href=https://docs.freebsd.org/fr/books/faq/#idp59950544>FAQ à ce sujet</a>.</p></div><div class=paragraph><p>Après avoir déterminé le pilote correct à utiliser pour votre carte, l’installation est aussi simple que d’installer n’importe quel autre paquet binaire.</p></div><div class=paragraph><p>Par exemple, pour installer la dernière version du pilote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/nvidia-driver</span></code></pre></div></div><div class=paragraph><p>Le pilote créera un module noyau, qui doit être chargé au démarrage du système. Ajoutez la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nvidia_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour charger immédiatement le module noyau dans le noyau en cours d’utilisation, utilisez une commande du type <code>kldload nvidia</code>. Cependant, il a été remarqué que certaines versions d’Xorg ne fonctionnaient pas correctement si le pilote n’était pas chargé lors du démarrage du système. Après l’édition du fichier <span class=filename>/boot/loader.conf</span>, un redémarrage est donc recommandé.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Avec le module noyau chargé, seul la modification d’une ligne dans <span class=filename>xorg.conf</span> est nécessaire pour activer le pilote propriétaire:</p></div><div class=paragraph><p>Trouvez la ligne suivante dans <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nv&#34;</pre></div></div><div class=paragraph><p>et modifiez-la pour:</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nvidia&#34;</pre></div></div><div class=paragraph><p>Lancez l’interface graphique comme vous en avez l’habitude, et vous devriez être accueilli par le logo nVidia. Tout devrait fonctionner comme à l’accoutumée.</p></div></div><div class=sect3><h4 id=xorg-configuration>5.8.2. Configuration d’xorg.conf pour les effets visuels<a class=anchor href=#xorg-configuration></a></h4><div class=paragraph><p>Pour activer Compiz Fusion, <span class=filename>/etc/X11/xorg.conf</span> doit être modifié:</p></div><div class=paragraph><p>Ajoutez la section suivante pour activer les effets du compositeur:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Extensions&#34;
    Option         &#34;Composite&#34; &#34;Enable&#34;
EndSection</pre></div></div><div class=paragraph><p>Recherchez la section "Screen" qui devrait être semblable à celle ci-dessous:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
    Identifier     &#34;Screen0&#34;
    Device         &#34;Card0&#34;
    Monitor        &#34;Monitor0&#34;
    ...</pre></div></div><div class=paragraph><p>et ajouter les deux lignes suivantes (après la ligne "Monitor"):</p></div><div class="literalblock programlisting"><div class=content><pre>DefaultDepth    24
Option         &#34;AddARGBGLXVisuals&#34; &#34;True&#34;</pre></div></div><div class=paragraph><p>Recherchez la partie "Subsection" faisant référence à la définition de l’écran que vous voulez utiliser. Par exemple, si vous voulez utiliser une définition de 1280x1024, recherchez la partie comme ci-dessous. Si la définition voulue n’apparaît nulle part, vous devrez ajouter l’entrée correspondante à la main:</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>Une profondeur de couleurs de 24 bits est requise pour un bureau utilisant la composition, modifiez la section précédente pour:</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Depth       24
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>Et enfin, vérifiez que les modules "glx" et "extmod" sont chargés dans la section "Module":</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Module&#34;
    Load           &#34;extmod&#34;
    Load           &#34;glx&#34;
    ...</pre></div></div><div class=paragraph><p>Ce qui précède peut être effectué automatiquement avec <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-xconfig/>x11/nvidia-xconfig</a> en exécutant (en tant que <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nvidia-xconfig --add-argb-glx-visuals</span>
<span class=c># nvidia-xconfig --composite</span>
<span class=c># nvidia-xconfig --depth=24</span></code></pre></div></div></div><div class=sect3><h4 id=compiz-fusion>5.8.3. Installation et configuration de Compiz Fusion<a class=anchor href=#compiz-fusion></a></h4><div class=paragraph><p>L’installation de Compiz Fusion est aussi simple que celle de n’importe quel paquet binaire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11-wm/compiz-fusion</span></code></pre></div></div><div class=paragraph><p>Quand l’installation est achevée, lancez votre environnement de bureau et, à un terminal, entrez les commandes suivantes (sous l’utilisateur normal):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% compiz <span class=nt>--replace</span> <span class=nt>--sm-disable</span> <span class=nt>--ignore-desktop-hints</span> ccp
% emerald <span class=nt>--replace</span></code></pre></div></div><div class=paragraph><p>Votre écran devrait clignoter quelques secondes, étant donné que votre gestionnaire de fenêtres (par exemple Metacity si vous utilisez GNOME) est remplacé par Compiz Fusion. Emerald s’occupera de la décoration des fenêtres (c’est à dire, les boutons de fermeture, de réduction, d’agrandissement, les barres de titres etc.).</p></div><div class=paragraph><p>Vous avez la possibilité de convertir tout cela en une procédure à exécuter automatiquement au démarrage (par exemple en l’ajoutant à "Sessions" dans le cas d’un bureau GNOME):</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh
compiz --replace --sm-disable --ignore-desktop-hints ccp
emerald --replace</pre></div></div><div class=paragraph><p>Sauvegardez ce fichier dans votre répertoire personnel sous le nom, par exemple, <span class=filename>start-compiz</span> et rendez-le exécutable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod</span> +x ~/start-compiz</code></pre></div></div><div class=paragraph><p>Utilisez ensuite l’interface graphique pour l’ajouter au menu <span class=guimenuitem>Startup Programs</span> (situé dans <span class=guimenuitem>System</span>, <span class=guimenuitem>Preferences</span>, <span class=guimenuitem>Sessions</span> dans le cas d’un environnement de bureau GNOME).</p></div><div class=paragraph><p>Pour sélectionner tous les effets visuels désirés et leurs paramètres, exécutez (toujours en tant qu’utilisateur normal) le programme Compiz Config Settings Manager:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ccsm</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sous GNOME, il peut être trouvé dans le menu <span class=guimenuitem>System</span>, puis <span class=guimenuitem>Preferences</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous avez sélectionné "gconf support" lors de la compilation, vous pourrez également voir ces paramètres en utilisant <code>gconf-editor</code> sous <code>apps/compiz</code>.</p></div></div><div class=sect3><h4 id=compiz-troubleshooting>5.8.4. Dépannage de Compiz Fusion<a class=anchor href=#compiz-troubleshooting></a></h4><div class=sect4><h5 id=_jai_installé_compiz_fusion_et_après_avoir_lancé_les_commandes_que_vous>5.8.4.1. J’ai installé Compiz Fusion, et après avoir lancé les commandes que vous<a class=anchor href=#_jai_installé_compiz_fusion_et_après_avoir_lancé_les_commandes_que_vous></a></h5><div class=paragraph><p>mentionnez, mes fenêtres n’ont plus de barre de titre et de boutons.
Qu’est-ce qui ne va pas?</p></div><div class=paragraph><p>Il vous manque probablement une configuration dans
<span class=filename>/etc/X11/xorg.conf</span>. Relisez avec attention ce fichier et
contrôlez tout particulièrement les directives <code>DefaultDepth</code> et
<code>AddARGBGLXVisuals</code>.</p></div></div><div class=sect4><h5 id=_quand_jexécute_la_commande_pour_lancer_compiz_fusion_le_serveur_x>5.8.4.2. Quand j’exécute la commande pour lancer Compiz Fusion, le serveur X<a class=anchor href=#_quand_jexécute_la_commande_pour_lancer_compiz_fusion_le_serveur_x></a></h5><div class=paragraph><p>plante et je retourne à la console. Qu’est-ce qui ne va pas?</p></div><div class=paragraph><p>Si vous contrôlez le contenu du fichier
<span class=filename>/var/log/Xorg.0.log</span>, vous trouverez surement des messages
d’erreur lors du démarrage de X. Les plus courants seront:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     Failed to initialize the GLX module<span class=p>;</span> please check <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     log file that the GLX module has been loaded <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     server, and that the module is the NVIDIA GLX module.  If
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     you <span class=k>continue </span>to encounter problems, Please try
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     reinstalling the NVIDIA driver.</code></pre></div></div><div class=paragraph><p>C’est généralement le cas quand vous mettez à jour Xorg. Vous devrez
réinstaller le paquet <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver/>x11/nvidia-driver</a> afin que le module glx
soit compilé à nouveau.</p></div></div></div></div></div></div><h1 id=common-tasks class=sect0>Partie II: Tâches courantes<a class=anchor href=#common-tasks></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Maintenant que les bases sont maîtrisées, cette partie du Manuel va traiter de certaines fonctionnalités de FreeBSD fréquemment utilisées. Ces chapitres:</p></div><div class=ulist><ul><li><p>Présentent des applications de bureautique populaires et utiles: des navigateurs, des outils de productivité, des lecteurs de documents, etc.</p></li><li><p>Présentent plusieurs outils multimédia disponibles pour FreeBSD.</p></li><li><p>Expliquent le processus de compilation d’un noyau FreeBSD personnalisé, pour permettre l’ajout de fonctionnalités supplémentaires.</p></li><li><p>Décrivent le système d’impression en détail, pour les configurations d’imprimante locale et en réseau.</p></li><li><p>Montrent comment exécuter des applications Linux sur le système FreeBSD.</p></li></ul></div><div class=paragraph><p>Certains de ces chapitres conseillent des lectures préalables, ceci est noté dans le synopsis au début de chaque chapitre.</p></div></div></div><div class=sect1><h2 id=desktop>Chapitre 6. Bureautique<a class=anchor href=#desktop></a></h2><div class=sectionbody><div class=sect2><h3 id=desktop-synopsis>6.1. Synopsis<a class=anchor href=#desktop-synopsis></a></h3><div class=paragraph><p>FreeBSD peut faire fonctionner une large variété d’applications de bureautique, comme des navigateurs et des traitements de textes. La plupart de ces derniers sont disponibles sous forme pré-compilée ou peuvent être compilé automatiquement à partir du catalogue des logiciels portés. De nombreux utilisateurs s’attendent à trouver ces types d’applications dans leur environnement de travail. Ce chapitre vous montrera comment installer quelques unes des applications de bureautique les plus populaires sans trop d’effort, soit à partir de versions pré-compilées soit à partir du catalogue des logiciels portés.</p></div><div class=paragraph><p>Notez que lorsque l’on installe des programmes à partir du catalogue des logiciels portés, ils sont compilés à partir des sources. Cela peut prendre un temps relativement long, en fonction de ce que vous compilez et de la puissance de votre machine. Si la compilation à partir des sources requiert un temps prohibitif, vous pouvez installer la plupart des programmes de l’arbre des ports à partir de version pré-compilées.</p></div><div class=paragraph><p>Comme FreeBSD dispose d’un système de compatibilité avec les binaires Linux, de nombreuses applications développées à l’origine pour Linux sont disponibles pour votre environnement de travail. Il est vivement recommandé que vous lisiez le <a href=./#linuxemu>Compatibilité binaire avec Linux®</a> avant d’installer des applications Linux. De nombreux logiciels portés utilisant la compatibilité binaire Linux débutent avec le terme "linux-". Souvenez-vous de cela quand vous recherchez un logiciel porté bien particulier, par exemple à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=whereis&amp;sektion=1&amp;format=html">whereis(1)</a>. Dans le reste de ce chapitre on suppose que vous avez activé la compatibilité Linux avant d’installer des applications Linux.</p></div><div class=paragraph><p>Voici les catégories d’applications couvertes par ce chapitre:</p></div><div class=ulist><ul><li><p>Navigateurs (comme Mozilla, Opera, Firefox, Konqueror)</p></li><li><p>Productivité (comme KOffice, AbiWord, The GIMP, OpenOffice.org)</p></li><li><p>Lecteurs de document (comme Acrobat Reader®, gv, Xpdf, GQview)</p></li><li><p>Finance (comme GnuCash, Gnumeric, Abacus)</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Savoir comment installer des logiciels tiers (<a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li><li><p>Savoir comment installer des logiciels pour Linux (<a href=./#linuxemu>Compatibilité binaire avec Linux®</a>).</p></li></ul></div><div class=paragraph><p>Pour des informations sur comment mettre en place un environnement multimédia, lisez le <a href=./#multimedia>Multimédia</a>. Si vous désirez configurer et utiliser le courrier électronique, veuillez vous référer au <a href=./#mail>Courrier électronique</a>.</p></div></div><div class=sect2><h3 id=desktop-browsers>6.2. Navigateurs<a class=anchor href=#desktop-browsers></a></h3><div class=paragraph><p>FreeBSD n’est pas livré avec un navigateur particulier installé. Au lieu de cela, le répertoire <a href=http://www.FreeBSD.org/ports/>www</a> du catalogue des logiciels portés contient de nombreux navigateurs prêts à être installés. Si vous n’avez pas le temps de tout compiler (cela peut prendre un temps relativement long dans certains cas) nombres d’entre eux sont disponibles sous forme pré-compilée.</p></div><div class=paragraph><p>KDE et GNOME fournissent déjà un navigateur HTML. Veuillez vous référer au <a href=./#x11-wm>Environnements de bureau</a> pour plus d’information sur comment configurer ces environnements de travail.</p></div><div class=paragraph><p>Si vous êtes à la recherche de navigateurs légers, vous devriez consulter le catalogue des logiciels portés pour <a class=package href=https://cgit.freebsd.org/ports/tree/www/dillo/>www/dillo</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/www/links/>www/links</a>, ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/w3m/>www/w3m</a>.</p></div><div class=paragraph><p>Cette section couvre les applications suivantes:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nom de l’application</th><th class="tableblock halign-left valign-top">Ressources nécessaires</th><th class="tableblock halign-left valign-top">Installation à partir du catalogue des logiciels portés</th><th class="tableblock halign-left valign-top">Dépendances principales</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Mozilla</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>importantes</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Opera</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légère</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Version native FreeBSD et Linux disponibles. La version Linux dépend de la compatibilité binaire Linux et de linux-openmotif.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>moyennes</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>moyennes</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bibliothèques KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_mozilla>6.2.1. Mozilla<a class=anchor href=#_mozilla></a></h4><div class=paragraph><p>Mozilla est un navigateur moderne et stable, dont le portage FreeBSD est complet: il présente un moteur d’affichage HTML qui respecte vraiment les normes; il intègre un lecteur de courrier électronique et de forums de discussion. Il possède même un éditeur HTML si vous projetez d’écrire vous-même quelques pages Web. Les utilisateurs de <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> trouveront des similitudes avec la suite Communicator, étant donné que les deux navigateurs partagent certains développements passés.</p></div><div class=paragraph><p>Sur les machines lentes, avec une vitesse de processeur de moins de 233MHz ou avec moins de 64MO de RAM, Mozilla peut être trop consommateur en ressources pour être vraiment utilisable. Vous pourrez vouloir essayer à la place le navigateur Opera décrit plus tard dans ce chapitre.</p></div><div class=paragraph><p>Si vous ne pouvez ou ne voulez compiler Mozilla, pour une quelconque raison, l’équipe GNOME de FreeBSD l’a déjà fait pour vous. Installez juste la version pré-compilée à partir du réseau avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r mozilla</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible, et que vous avez suffisamment de temps et d’espace disque, vous pouvez obtenir les sources pour Mozilla, le compiler et l’installer sur votre système. Cela s’effectue en faisant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/mozilla</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Le logiciel porté Mozilla s’assure d’une initialisation correcte en exécutant la configuration de la base de registre chrome avec les privilèges de <code>root</code> privilèges. Cependant si vous désirez récupérer des modules additionnels comme "mouse gestures", vous devez exécuter Mozilla en tant que <code>root</code> pour obtenir une installation correcte de ces modules.</p></div><div class=paragraph><p>Une fois que vous avez achevé l’installation de Mozilla, vous n’avez plus besoin d’être sous <code>root</code>. Vous pouvez lancer Mozilla en tant que navigateur en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mozilla</code></pre></div></div><div class=paragraph><p>Vous pouvez lancer directement les lecteurs de courrier électronique et de forums comme montré ci-dessous:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mozilla <span class=nt>-mail</span></code></pre></div></div></div><div class=sect3><h4 id=_firefox>6.2.2. Firefox<a class=anchor href=#_firefox></a></h4><div class=paragraph><p>Firefox est la génération suivante de navigateurs basés sur le code de Mozilla. Mozilla est une suite complète d’applications, comme un navigateur, un client de messagerie, un client de discussion et bien plus. Firefox est juste un navigateur, ce qui le rend plus petit et plus rapide.</p></div><div class=paragraph><p>Installez la version pré-compilée du logiciel en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r firefox</span></code></pre></div></div><div class=paragraph><p>Vous pouvez également utiliser le catalogue des logiciels portés si vous désirez effectuer la compilation à partir des sources:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/firefox</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=moz-java-plugin>6.2.3. Firefox, Mozilla et le greffon Java™<a class=anchor href=#moz-java-plugin></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans cette section et la suivante, nous supposerons que vous avez déjà installé Firefox ou Mozilla.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La fondation FreeBSD a acquis auprès de Sun Microsystems une licence de distribution des binaires FreeBSD pour le Java Runtime Environment (JRE™) et le Java Development Kit (JDK™). Les paquetages binaires pour FreeBSD sont disponibles sur le site de la <a href=http://www.freebsdfoundation.org/downloads/java.shtml>fondation FreeBSD</a>.</p></div><div class=paragraph><p>Pour ajouter le support Java™ à Firefox ou Mozilla, vous devez installer tout d’abord le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/java/javavmwrapper/>java/javavmwrapper</a>. Ensuite, téléchargez le paquetage Diablo JRE™ à l’adresse <a href=http://www.freebsdfoundation.org/downloads/java.shtml>http://www.freebsdfoundation.org/downloads/java.shtml</a>, et installez-le à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>.</p></div><div class=paragraph><p>Lancez votre navigateur et tapez <code>about:plugins</code> dans la barre d’adresse et appuyez sur <kbd>Entrée</kbd>. Une page listant les greffons installés s’affichera; le greffon Java™ devrait désormais apparaître dans la liste. Si ce n’est pas le cas, en tant que <code>root</code>, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /usr/local/diablo-jre1.5.0/plugin/i386/ns7/libjavaplugin_oji.so \</span>
  /usr/local/lib/browser_plugins/</code></pre></div></div><div class=paragraph><p>puis relancez votre navigateur.</p></div></div><div class=sect3><h4 id=moz-flash-plugin>6.2.4. Firefox, Mozilla et le greffon Macromedia® Flash™<a class=anchor href=#moz-flash-plugin></a></h4><div class=paragraph><p>Le greffon Macromedia® Flash™ n’est pas disponible pour FreeBSD. Cependant il existe une couche logicielle ("wrapper") pour utiliser la version Linux du greffon. Ce "wrapper" supporte également les greffons Adobe® Acrobat®, RealPlayer® et plus.</p></div><div class=paragraph><p>Installez le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/www/nspluginwrapper/>www/nspluginwrapper</a>. Ce logiciel nécessite <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base/>emulators/linux_base</a> qui occupe un espace relativement important.</p></div><div class=paragraph><p>L’étape suivante est l’installation du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/www/linux-flashplugin7/>www/linux-flashplugin7</a>. Une fois le logiciel installé, le greffon doit être installé par chaque utilisateur à l’aide de la commande <code>nspluginwrapper</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nspluginwrapper <span class=nt>-v</span> <span class=nt>-a</span> <span class=nt>-i</span></code></pre></div></div><div class=paragraph><p>Lancez ensuite votre navigateur, tapez <code>about:plugins</code> dans la barre d’adresse et appuyez sur <kbd>Entrée</kbd>. Une liste des greffons actuellement disponibles devrait apparaître.</p></div></div><div class=sect3><h4 id=_opera>6.2.5. Opera<a class=anchor href=#_opera></a></h4><div class=paragraph><p>Opera est un navigateur complet respectant les standards. Il intègre un lecteur de courrier électronique et de forums de discussion, un client IRC, un lecteur de flux RSS/Atom et beaucoup plus. Malgré cela, Opera reste relativement léger et très rapide. Il est disponible en deux versions: une version "native" pour FreeBSD et une version utilisant l’émulation Linux.</p></div><div class=paragraph><p>Pour naviguer sur le Web avec la version FreeBSD d’Opera, installez la version pré-compilée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r opera</span></code></pre></div></div><div class=paragraph><p>Certains sites FTP n’ont pas toutes les versions pré-compilées, mais Opera peut également être obtenu avec le catalogue des logiciels portés en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/port/www/opera</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Pour installer la version Linux d’Opera, utilisez <code>linux-opera</code> à la place d'<code>opera</code> dans les exemples précédents. La version Linux est utile dans les situations demandant l’utilisation de greffons qui sont uniquement disponibles pour Linux, comme Acrobat Reader®. Dans tous les autres aspects, les versions FreeBSD et Linux devraient être identiques.</p></div></div><div class=sect3><h4 id=_konqueror>6.2.6. Konqueror<a class=anchor href=#_konqueror></a></h4><div class=paragraph><p>Konqueror fait partie de KDE mais peut être également utilisé en dehors de KDE en installant <a class=package href=https://cgit.freebsd.org/ports/tree/x11/kdebase3/>x11/kdebase3</a>. Konqueror est plus qu’un navigateur, c’est également un gestionnaire de fichiers et une visionneuse multimedia</p></div><div class=paragraph><p>Il existe également un ensemble de greffons pour Konqueror disponible dans <a class=package href=https://cgit.freebsd.org/ports/tree/misc/konq-plugins/>misc/konq-plugins</a>.</p></div><div class=paragraph><p>Konqueror supporte également Flash™; un tutorial pour avoir le support de Flash™ sous Konqueror est disponible à l’adresse <a href=http://freebsd.kde.org/howto.php>http://freebsd.kde.org/howto.php</a>.</p></div></div></div><div class=sect2><h3 id=desktop-productivity>6.3. Productivité<a class=anchor href=#desktop-productivity></a></h3><div class=paragraph><p>Quand on parle de productivité, les nouveaux utilisateurs recherchent souvent une bonne suite bureautique ou un traitement de texte convivial. Bien que certains <a href=./#x11-wm>environnements de travail</a> comme KDE fournissent déjà une suite de bureautique, il n’y a pas de logiciels de productivité par défaut. FreeBSD fournit tout ce qui est nécessaire, indépendamment de votre environnement de travail.</p></div><div class=paragraph><p>Cette section couvre les applications suivantes:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nom de l’application</th><th class="tableblock halign-left valign-top">Ressources nécessaires</th><th class="tableblock halign-left valign-top">Installation à partir du catalogue des logiciels portés</th><th class="tableblock halign-left valign-top">Dépendances principales</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légères</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légères</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ ou GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The Gimp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légères</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>OpenOffice.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>importantes</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>très lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>JDK™ 1.4, Mozilla</p></td></tr></tbody></table><div class=sect3><h4 id=_koffice>6.3.1. KOffice<a class=anchor href=#_koffice></a></h4><div class=paragraph><p>La communauté KDE propose son environnement de travail avec une suite de bureautique qui peut être utilisée en dehors de KDE. Elle comprend quatre composants standard que l’on peut trouver dans d’autres suites. KWord est le traitement de texte, KSpread est le tableur, KPresenter est le programme pour gérer des présentations, et Kontour vous permet de créer des documents graphiques.</p></div><div class=paragraph><p>Avant d’installer la dernière version de KOffice, soyez sûr d’avoir une version à jour de KDE.</p></div><div class=paragraph><p>Pour installer KOffice à partir de la version pré-compilée, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r koffice</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible, vous pouvez utiliser le catalogue des logiciels portés. Par exemple, pour installer KOffice pour KDE3, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/koffice-kde3</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_abiword>6.3.2. AbiWord<a class=anchor href=#_abiword></a></h4><div class=paragraph><p>AbiWord est un traitement de texte gratuit similaire au niveau de l’apparence et de la prise en main à Microsoft® Word. Il convient pour taper des lettres, des rapports, des mémos, et ainsi de suite. Il est très rapide, dispose de nombreuses fonctions, et très convivial.</p></div><div class=paragraph><p>AbiWord peut importer et exporter dans de nombreux formats de fichiers, dont certains formats propriétaires comme le <span class=filename>.doc</span> de Microsoft®.</p></div><div class=paragraph><p>AbiWord est disponible sous forme pré-compilée. Vous pouvez l’installer avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r abiword</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible, il peut être compilé à partir du catalogue des logiciels portés. Le catalogue devra être plus à jour. Cela peut être fait de cette façon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/abiword</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_the_gimp>6.3.3. The GIMP<a class=anchor href=#_the_gimp></a></h4><div class=paragraph><p>Pour la création et la retouche d’image The GIMP est un programme de manipulation d’image très sophistiqué. Il peut être utilisé comme un simple programme de dessin ou comme une suite de retouche d’image de qualité photo. Il supporte un grand nombre de modules additionnels et présente une interface de création de procédures. The GIMP peut lire et écrire dans un très grand nombre de formats de fichiers. Il supporte l’interfaçage avec des scanners et des tablettes graphiques.</p></div><div class=paragraph><p>Vous pouvez installer la version pré-compilée en utilisant cette commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gimp</span></code></pre></div></div><div class=paragraph><p>Si votre site FTP ne dispose pas de la version pré-compilée, vous pouvez utiliser le catalogue des logiciels portés. Le répertoire <a href=http://www.FreeBSD.org/ports/>graphics</a> du catalogue contient également le Manuel de The Gimp. Voici comment les installer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gimp</span>
<span class=c># make install clean</span>
<span class=c># cd /usr/ports/graphics/gimp-manual-pdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le répertoire <a href=http://www.FreeBSD.org/ports/>graphics</a> du catalogue des logiciels portés contient la version de développement de The GIMP dans <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp-devel/>graphics/gimp-devel</a>. Une version HTML du Manuel de The Gimp est disponible à partir de <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp-manual-html/>graphics/gimp-manual-html</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_openoffice_org>6.3.4. OpenOffice.org<a class=anchor href=#_openoffice_org></a></h4><div class=paragraph><p>OpenOffice.org comprend toutes les applications indispensables d’une suite de bureautique complète: un traitement de texte, un tableur, un programme de gestion de présentation, et un logiciel de dessin. Son interface utilisateur est très proche de celle d’autres suites de bureautique, et elle peut importer et exporter dans divers formats de fichiers populaires. Elle est disponible dans de nombreuses langues - l’interface, les correcteurs orthographiques, et les dictionnaires ont été internationalisés.</p></div><div class=paragraph><p>Le traitement de texte d’OpenOffice.org utilise un format de fichier natif en XML pour augmenter la portabilité et la flexibilité. Le tableur dispose d’un langage de macro et il peut être interfacé avec des bases de données extérieures. OpenOffice.org est déjà stable et fonctionne en natif sous Windows®, Solaris™, Linux, FreeBSD, et Mac OS® X. Plus d’information à propos d’OpenOffice.org peut être trouvé sur le <a href=http://www.openoffice.org/>site Web d’OpenOffice.org</a>. Pour une information spécifique à FreeBSD, et pour télécharger directement les versions précompilées, utilisez le site Web de <a href=http://porting.openoffice.org/freebsd/>l’Equipe FreeBSD de portage d’OpenOffice.org</a>.</p></div><div class=paragraph><p>Pour installer OpenOffice.org, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r openoffice.org</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cette commande devrait fonctionner si vous utilisez une version -RELEASE de FreeBSD. Si ce n’est pas le cas, vous devriez consulter le site de l’équipe de portage d’OpenOffice.org pour télécharger puis installer le paquetage adéquat en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>. Les versions actuelles et de développement sont disponibles.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Une fois l’installation effective, vous avez juste à taper la commande suivante pour exécuter OpenOffice.org:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice.org</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Lors de la première exécution, quelques questions vous seront posées et un répertoire <span class=filename>.openoffice.org2</span> sera créé dans votre répertoire utilisateur.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si les version pré-compilées d’OpenOffice.org ne sont pas disponibles, vous avez toujours la possibilité de compiler le logiciel porté. Cependant, vous devez garder à l’esprit que cela demande beaucoup d’espace disque et un temps de compilation relativement long.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/openoffice.org-2</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous désirez compiler une version localisée, remplacez la dernière ligne de commande avec la suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=votre_langage install clean</span></code></pre></div></div><div class=paragraph><p>Vous devez remplacer <em>votre_langage</em> avec le code ISO de langage approprié. Une liste des codes de langage supportés est disponible dans le fichier <span class=filename>files/Makefile.localized</span> situé dans le répertoire du logiciel porté.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Une fois cela effectué, OpenOffice.org peut être lancé avec la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice.org</code></pre></div></div></div></div><div class=sect2><h3 id=desktop-viewers>6.4. Lecteurs de document<a class=anchor href=#desktop-viewers></a></h3><div class=paragraph><p>Certains nouveaux formats de documentation ont gagné en popularité depuis l’avènement d’UNIX®; les lecteurs standard qu’ils nécessitent peuvent ne pas être disponibles dans le système de base. Nous verrons, dans cette section, comment installer ces lecteurs de document.</p></div><div class=paragraph><p>Cette section couvre les applications suivantes:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nom de l’application</th><th class="tableblock halign-left valign-top">Ressources nécessaires</th><th class="tableblock halign-left valign-top">Installation à partir du catalogue des logiciels portés</th><th class="tableblock halign-left valign-top">Dépendances principales</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Acrobat Reader®</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légère</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Compatibilité binaire Linux</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légère</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Xaw3d</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légère</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeType</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GQview</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légère</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ ou GNOME</p></td></tr></tbody></table><div class=sect3><h4 id=_acrobat_reader>6.4.1. Acrobat Reader®<a class=anchor href=#_acrobat_reader></a></h4><div class=paragraph><p>De nombreux documents sont désormais distribués sous forme de fichiers PDF, qui signifie "Format Portable de Document" - Portable Document Format. Un des lecteurs recommandé est Acrobat Reader®, sorti par Adobe pour Linux. Comme FreeBSD peut exécuter les binaires Linux, il est également disponible pour FreeBSD.</p></div><div class=paragraph><p>Pour installer Acrobat Reader® 7, à partir du catalogue de logiciels portés, faire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/acroread7</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Il n’existe pas de paquetage pour des raisons de licence.</p></div></div><div class=sect3><h4 id=_gv>6.4.2. gv<a class=anchor href=#_gv></a></h4><div class=paragraph><p>gv un lecteur de fichier PostScript® et PDF. Il est a l’origine basé sur ghostview mais présente un plus bel aspect grâce à la bibliothèque Xaw3d. Il est rapide et son interface est simple. gv possède de nombreuses fonctionnalités comme l’orientation, le format du papier, l’échelle, l’anticrénelage. Presque toutes les opérations peuvent être effectuées soit à partir du clavier soit à la souris.</p></div><div class=paragraph><p>Pour installer gv à partir de la version pré-compilée, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gv</span></code></pre></div></div><div class=paragraph><p>Si vous ne pouvez obtenir la version pré-compilée, vous pouvez utiliser le catalogue des logiciels portés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/gv</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_xpdf>6.4.3. Xpdf<a class=anchor href=#_xpdf></a></h4><div class=paragraph><p>Si vous désirez un petit lecteur de fichiers PDF, Xpdf est léger et efficace. Il demande très peu de ressources et est très stable. Il utilise les polices de caractères standards de X et ne requiert pas Motif® ou tout autre ensemble d’éléments graphiques pour X.</p></div><div class=paragraph><p>Pour installer la version pré-compilée d’Xpdf utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r xpdf</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible ou que vous préfériez utiliser le catalogue des logiciels portés, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/xpdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Une fois l’installation achevée, vous pouvez lancer Xpdf et utiliser le bouton droit de la souris pour activer le menu.</p></div></div><div class=sect3><h4 id=_gqview>6.4.4. GQview<a class=anchor href=#_gqview></a></h4><div class=paragraph><p>GQview est un gestionnaire d’image. Vous pouvez visualiser un fichier avec un simple clic, lancer un éditeur externe, obtenir une pré-visualisation par vignettes, et bien plus. Il propose également un mode présentation et quelques possibilités d’opérations sur fichiers de base. Vous pouvez gérer des collections d’images et trouver facilement les doublons. GQview supporte l’affichage plein écran et l’internationalisation de l’interface.</p></div><div class=paragraph><p>Si vous désirez installer la version pré-compilée de GQview, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gqview</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible ou que vous préférez utiliser le catalogue des logiciels portés, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gqview</span>
<span class=c># make install clean</span></code></pre></div></div></div></div><div class=sect2><h3 id=desktop-finance>6.5. Finance<a class=anchor href=#desktop-finance></a></h3><div class=paragraph><p>Si, pour diverses raisons, vous voudriez gérer vos finances personnelles sous FreeBSD, il existe quelques applications puissantes et simples d’emploi prêtes à être installées. Certaines d’entre elles sont compatibles avec des formats de fichiers très répandus comme ceux utilisés par Quicken ou Excel pour stocker des documents.</p></div><div class=paragraph><p>Cette section couvre les programmes suivants:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nom de l’application</th><th class="tableblock halign-left valign-top">Ressources nécessaires</th><th class="tableblock halign-left valign-top">Installation à partir du catalogue des logiciels portés</th><th class="tableblock halign-left valign-top">Dépendances principales</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Abacus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>légère</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tcl/Tk</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>faibles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lourde</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_gnucash>6.5.1. GnuCash<a class=anchor href=#_gnucash></a></h4><div class=paragraph><p>GnuCash fait partie de l’effort GNOME en vue de fournir des applications puissantes et conviviales pour l’utilisateur final. Avec GnuCash, vous pouvez suivre vos crédits et débits, vos comptes bancaires, et vos actions. Il présente une interface intuitive tout en restant très professionnel.</p></div><div class=paragraph><p>GnuCash fournit un registre intelligent, un système hiérarchique pour les comptes, de nombreux raccourcis clavier et des systèmes d’autocomplémentation de la frappe au clavier. Il peut diviser une simple transaction en plusieurs étapes plus détaillées. GnuCash peut importer et fusionner des fichiers QIF de Quicken. Il supporte également la plupart des formats internationaux de date et de monnaies.</p></div><div class=paragraph><p>Pour installer GnuCash sur votre système, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnucash</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible, vous pouvez utiliser le catalogue des logiciels portés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/gnucash</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_gnumeric>6.5.2. Gnumeric<a class=anchor href=#_gnumeric></a></h4><div class=paragraph><p>Gnumeric est un tableur, faisant partie de l’environnement de travail GNOME. Il dispose d’un système automatique "devinant" le type d’entrée de l’utilisateur en fonction du format de la cellule avec un système de remplissage automatique pour de nombreuses séquences d’utilisation. Il peut importer des fichiers de nombreux formats populaires comme ceux d’Excel, Lotus 1-2-3, ou Quattro Pro. Gnumeric supporte l’affichage de graphiques grâce au programme de tracé <a class=package href=https://cgit.freebsd.org/ports/tree/math/guppi/>math/guppi</a>. Il dispose d’un grand nombre de fonctions intégrées et permet tous les formats de cellule habituels comme le format numérique, monétaire, date, temps, et bien plus.</p></div><div class=paragraph><p>Pour installer Gnumeric sous forme pré-compilée, tapez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnumeric</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible, vous pouvez utiliser le catalogue des logiciels portés en faisant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/math/gnumeric</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_abacus>6.5.3. Abacus<a class=anchor href=#_abacus></a></h4><div class=paragraph><p>Abacus est un tableur léger et facile d’emploi. Il incorpore de nombreuses fonctions utiles dans plusieurs domaines comme les statistiques, la finance, et les mathématiques. Il peut importer et exporter en format Excel. Abacus peut produire des sorties en PostScript®.</p></div><div class=paragraph><p>Pour installer Abacus à partir de la version pré-compilée, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r abacus</span></code></pre></div></div><div class=paragraph><p>Si la version pré-compilée n’est pas disponible, vous pouvez utiliser le catalogue des logiciels portés en faisant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/deskutils/abacus</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_kmymoney>6.5.4. KMyMoney<a class=anchor href=#_kmymoney></a></h4><div class=paragraph><p>KMyMoney est un programme de comptabilité personnelle pour KDE. KMyMoney a pour objectif de fournir et d’incorporer toutes les fonctionnalités importantes que l’on retrouve dans les applications de comptabilité personnelle commerciales. Il met également l’accent sur la facilité d’utilisation et la mise en place d’une comptabilité en partie double. KMyMoney peut importer les fichiers au format Quicken (QIF), suivre des placements, gérer plusieurs monnaies et fournir une quantité de compte-rendus. La possibilité d’importer des fichiers au format OFX est également disponible à l’aide d’un greffon séparé.</p></div><div class=paragraph><p>Pour installer KMyMoney sous forme d’un paquetage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r kmymoney2</span></code></pre></div></div><div class=paragraph><p>Si le paquetage n’est pas disponible, vous pouvez utiliser le catalogue des logiciels portés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/kmymoney2</span>
<span class=c># make install clean</span></code></pre></div></div></div></div><div class=sect2><h3 id=desktop-summary>6.6. Résumé<a class=anchor href=#desktop-summary></a></h3><div class=paragraph><p>Alors que FreeBSD est populaire parmi les fournisseurs d’accès à Internet pour ses performances et sa stabilité, il est quasiment prêt pour une utilisation quotidienne en tant que station de travail. Avec plusieurs milliers d’applications disponibles sous forme <a href=http://www.FreeBSD.org/where/>pré-compilées</a> ou dans le <a href=http://www.FreeBSD.org/ports/>catalogue des logiciels portés</a>, vous pouvez vous construire l’environnement de travail qui vous conviendra le mieux.</p></div><div class=paragraph><p>Voici un bref rappel de toutes les applications abordées dans ce chapitre:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Nom de l’application</th><th class="tableblock halign-left valign-top">Nom du logiciel pré-compilé</th><th class="tableblock halign-left valign-top">Nom du logiciel porté</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Mozilla</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>mozilla</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Opera</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>opera</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/opera/>www/opera</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>firefox</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>koffice-kde3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/koffice-kde3/>editors/koffice-kde3</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>abiword</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/abiword/>editors/abiword</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The GIMP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gimp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp/>graphics/gimp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>OpenOffice.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>openoffice</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/openoffice-1.1/>editors/openoffice-1.1</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Acrobat Reader®</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acroread</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/acroread7/>print/acroread7</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gv</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/gv/>print/gv</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>xpdf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xpdf/>graphics/xpdf</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GQview</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gqview</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gqview/>graphics/gqview</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gnucash</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/finance/gnucash/>finance/gnucash</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gnumeric</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/math/gnumeric/>math/gnumeric</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Abacus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>abacus</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/deskutils/abacus/>deskutils/abacus</a></p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=multimedia>Chapitre 7. Multimédia<a class=anchor href=#multimedia></a></h2><div class=sectionbody><div class=sect2><h3 id=multimedia-synopsis>7.1. Synopsis<a class=anchor href=#multimedia-synopsis></a></h3><div class=paragraph><p>FreeBSD supporte une grande variété de cartes son, vous permettant d’obtenir un son haute fidélité à partir de votre ordinateur. Ceci inclut la possibilité d’enregistrer et de jouer les formats "MPEG Audio Layer 3" (MP3), WAV et Ogg Vorbis aussi bien que de nombreux autres formats. Le catalogue de logiciels portés de FreeBSD contient également des applications vous permettant d’éditer vos enregistrements, rajouter des effets sonores, et contrôler des périphériques MIDI.</p></div><div class=paragraph><p>Avec un peu d’expérimentation, FreeBSD pourra lire des fichiers vidéo et des DVDs. Le nombre d’applications pour encoder, convertir, et lire divers supports vidéo est plus limité que le nombre d’applications équivalentes dans le domaine du son. Par exemple au moment de l’écriture de ces lignes, il n’existe pas de bonne application d’encodage dans le catalogue des logiciels portés de FreeBSD, qui pourra être utilisée pour convertir d’un format à un autre, comme peut le faire pour le son le programme <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a>. Cependant, le paysage logiciel dans ce domaine évolue rapidement.</p></div><div class=paragraph><p>Ce chapitre décrira les étapes nécessaires pour configurer votre carte son. La configuration et l’installation d’X11 (<a href=./#x11>Le système X Window</a>) ont déjà pris soin des problèmes matériel de votre carte vidéo, bien qu’il puisse y avoir quelques réglages à ajuster pour obtenir une meilleure lecture des vidéos.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Comment configurer votre système afin que votre carte son soit reconnue.</p></li><li><p>Les méthodes pour tester le fonctionnement de votre carte.</p></li><li><p>Comment faire face aux problèmes de configuration de votre carte son.</p></li><li><p>Comment jouer et encoder des MP3s.</p></li><li><p>Comment la vidéo est supportée par X11.</p></li><li><p>Quelques logiciels portés qui donnent de bon résultats pour lire/encoder de la vidéo.</p></li><li><p>Comment lire des DVDs, des fichiers <span class=filename>.mpg</span> et <span class=filename>.avi</span>.</p></li><li><p>Comment extraire l’information présente sur des CDs et des DVDs.</p></li><li><p>Comment configurer une carte TV.</p></li><li><p>Comment configurer un scanner.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Savoir comment configurer et installer un nouveau noyau (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Essayer de monter des CDs audio avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> aura pour résultat une erreur, au moins, et une <em>panique du noyau</em>, au pire. Ces supports ont des codages spécifiques qui diffèrent du système de fichiers ISO classique.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=sound-setup>7.2. Configurer une carte son<a class=anchor href=#sound-setup></a></h3><div class=sect3><h4 id=sound-device>7.2.1. Configuration du système<a class=anchor href=#sound-device></a></h4><div class=paragraph><p>Avant que vous commenciez, vous devriez connaître le modèle de carte son que vous avez, la puce qu’elle utilise, et si c’est une carte PCI ou ISA. FreeBSD supporte une grande variété de cartes PCI et ISA. Consultez la liste des périphériques audio supportés des <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>notes de compatibilité matériel</a> pour voir si votre carte est supportée. Ces notes indiqueront également quel pilote supporte votre carte.</p></div><div class=paragraph><p>Pour utiliser votre carte son, vous devrez charger le pilote de périphérique approprié. Cela peut être fait de deux façons. La plus simple est de charger le module pour votre carte son avec <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>, ce qui peut être soit fait à partir de la ligne de commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_emu10k1</span></code></pre></div></div><div class=paragraph><p>soit en ajoutant la ligne appropriée dans le fichier <span class=filename>/boot/loader.conf</span> comme cela:</p></div><div class="literalblock programlisting"><div class=content><pre>snd_emu10k1_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ces exemples concernent la carte Creative SoundBlaster® Live!. Les autres modules son chargeables sont listés dans <span class=filename>/boot/defaults/loader.conf</span>. Si vous n’êtes pas sûr du pilote à utiliser, vous pouvez tenter de charger le pilote <span class=filename>snd_driver</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_driver</span></code></pre></div></div><div class=paragraph><p>C’est un méta-pilote chargeant directement les pilotes les plus courants. Cela accélère la recherche du pilote adapté. Il est également possible de charger l’intégralité des pilotes de cartes son en utilisant le système <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Si vous voulez connaître le pilote sélectionné lors du chargement du méta-pilote <span class=filename>snd_driver</span>, vous pouvez consulter le fichier <span class=filename>/dev/sndstat</span> à cet effet, et cela à l’aide de la commande <code>cat /dev/sndstat</code>.</p></div><div class=paragraph><p>Une seconde méthode est de compiler le support pour votre carte son en statique dans votre noyau. La section ci-dessous fournit les informations nécessaires pour ajouter le support de votre matériel de cette manière. Pour plus d’informations au sujet de la recompilation de votre noyau, veuillez consulter le <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>.</p></div><div class=sect4><h5 id=_configurer_un_noyau_sur_mesure_avec_support_du_son>7.2.1.1. Configurer un noyau sur mesure avec support du son<a class=anchor href=#_configurer_un_noyau_sur_mesure_avec_support_du_son></a></h5><div class=paragraph><p>La première chose à effectuer est d’ajouter au noyau le pilote de périphérique audio générique <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a>; pour cela vous devrez ajouter la ligne suivante au fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device sound</pre></div></div><div class=paragraph><p>Ensuite, vous devez ajouter le support pour votre carte son. Par conséquent, vous devez savoir quel pilote supporte la carte. Consultez la liste des périphériques audio supportés des <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>notes de compatibilité matériel</a> pour déterminer le pilote correct pour votre carte son. Par exemple, une carte son Creative SoundBlaster® Live! est supportée par le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_emu10k1&amp;sektion=4&amp;format=html">snd_emu10k1(4)</a>. Pour ajouter le support pour cette carte, utilisez ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_emu10k1</pre></div></div><div class=paragraph><p>Assurez-vous de lire la page de manuel du pilote pour la syntaxe à utiliser. La syntaxe de la configuration du noyau pour chaque pilote de carte son supportée peut être également trouvée dans le fichier <span class=filename>/usr/src/sys/conf/NOTES</span>.</p></div><div class=paragraph><p>Les cartes son ISA non-PnP pourront nécessiter de fournir au noyau des informations sur le paramétrage de la carte (IRQ, port d’E/S, etc.), comme c’est en général le cas pour toutes les cartes ISA non-PnP. Cela s’effectue par l’intermédiaire du fichier <span class=filename>/boot/device.hints</span>. Au démarrage du système, le chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) lira ce fichier et passera les paramètres au noyau. Par exemple, une vieille carte ISA non-PnP Creative SoundBlaster® 16 utilisera le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> de paire avec <code>snd_sb16</code>, on ajoutera alors la ligne suivante au fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_sbc
device snd_sb16</pre></div></div><div class=paragraph><p>avec également ceci dans le fichier <span class=filename>/boot/device.hints</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sbc.0.at=&#34;isa&#34;
hint.sbc.0.port=&#34;0x220&#34;
hint.sbc.0.irq=&#34;5&#34;
hint.sbc.0.drq=&#34;1&#34;
hint.sbc.0.flags=&#34;0x15&#34;</pre></div></div><div class=paragraph><p>Dans ce cas, la carte utilise le port d’E/S <code>0x220</code> et l’IRQ <code>5</code>.</p></div><div class=paragraph><p>La syntaxe utilisée dans le fichier <span class=filename>/boot/device.hints</span> est abordée dans la page de manuel du pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> ainsi que celle du pilote spécifique à la carte son.</p></div><div class=paragraph><p>Les paramètres donnés ci-dessus sont ceux par défaut. Dans certains cas, vous pouvez avoir besoin de modifier l’IRQ ou tout autre paramètre en fonction de votre carte son. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> pour plus d’informations au sujet de cette carte.</p></div></div></div><div class=sect3><h4 id=sound-testing>7.2.2. Tester la carte son<a class=anchor href=#sound-testing></a></h4><div class=paragraph><p>Après avoir redémarré avec le noyau modifié, ou après avoir chargé le module nécessaire, la carte son devrait apparaître dans le tampon des messages du système (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>) d’un manière proche de la suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pcm0: &lt;Intel ICH3 <span class=o>(</span>82801CA<span class=o>)&gt;</span> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: <span class=o>[</span>GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</code></pre></div></div><div class=paragraph><p>L’état de la carte son peut être contrôlée par l’intermédiaire du fichier <span class=filename>/dev/sndstat</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /dev/sndstat</span>
FreeBSD Audio Driver <span class=o>(</span>newpcm<span class=o>)</span>
Installed devices:
pcm0: &lt;Intel ICH3 <span class=o>(</span>82801CA<span class=o>)&gt;</span> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich <span class=o>(</span>1p/2r/0v channels duplex default<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Le résultat pourra être différent sur votre système. Si aucun périphérique <span class=filename>pcm</span> n’apparaît, retournez en arrière et revoyez ce qui a été fait précédemment. Contrôlez à nouveau votre fichier de configuration du noyau et vérifiez que vous avez choisi le périphérique correct. Les problèmes courants sont listés dans la <a href=#troubleshooting>Problèmes courants</a>.</p></div><div class=paragraph><p>Si tout va bien, vous devriez avoir maintenant une carte son qui fonctionne. Si la sortie audio de votre lecteur de CD-ROM ou de DVD-ROM est correctement reliée à votre carte son, vous pouvez introduire un CD dans le lecteur et le jouer avec <a href="https://man.freebsd.org/cgi/man.cgi?query=cdcontrol&amp;sektion=1&amp;format=html">cdcontrol(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdcontrol <span class=nt>-f</span> /dev/acd0 play 1</code></pre></div></div><div class=paragraph><p>Diverses applications, comme <a class=package href=https://cgit.freebsd.org/ports/tree/audio/workman/>audio/workman</a> offrent une meilleure interface. Vous pouvez vouloir installer une application comme <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> pour écouter des fichiers audio MP3.</p></div><div class=paragraph><p>Une autre méthode rapide pour tester la carte est d’envoyer des données au <span class=filename>/dev/dsp</span>, de la manière suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>filename  /dev/dsp</code></pre></div></div><div class=paragraph><p>où <em>filename</em> peut être n’importe quel fichier. Cette ligne de commande devrait produire des sons, confirmant le bon fonctionnement de la carte son.</p></div><div class=paragraph><p>Les niveaux du mixer de la carte son peuvent être modifiés par la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a>. Plus de détails peuvent être trouvés dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a>.</p></div><div class=sect4><h5 id=troubleshooting>7.2.2.1. Problèmes courants<a class=anchor href=#troubleshooting></a></h5><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Erreur</th><th class="tableblock halign-left valign-top">Solution</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb_dspwr(XX) timed out</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le port d’E/S n’est pas configuré correctement.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bad irq XX</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’IRQ sélectionnée est incorrecte. Vérifiez que l’IRQ choisie et l’IRQ de la carte son sont les mêmes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: gus pcm not attached, out of memory</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Il n’y a pas suffisamment de mémoire disponible pour utiliser ce périphérique.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: can’t open /dev/dsp!</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vérifiez avec la commande <code>fstat | grep dsp</code> si une autre application maintient le périphérique ouvert. Souvent à l’origine de ce type de problème on trouve esound et le support son de KDE.</p></td></tr></tbody></table></div></div><div class=sect3><h4 id=sound-multiple-sources>7.2.3. Utiliser des sources sonores multiples<a class=anchor href=#sound-multiple-sources></a></h4><div class=paragraph><p>Il est souvent intéressant de pouvoir jouer simultanément du son à partir de multiples sources, comme lorsque esound ou artsd ne supportent pas le partage du périphérique son avec certaines applications.</p></div><div class=paragraph><p>FreeBSD vous permet de le faire par l’intermédiaire de <em>Canaux Sonores Virtuels</em>, qui peuvent être activés avec la fonction <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Les canaux virtuels vous permettent de multiplexer la sortie de votre carte son en mixant le son au niveau du noyau.</p></div><div class=paragraph><p>Pour configurer le nombre de canaux virtuels, il existe deux paramètres de sysctl qui, si vous avez les privilèges de l’utilisateur <code>root</code>, peuvent être configurés comme ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.snd.pcm0.vchans=4</span>
<span class=c># sysctl hw.snd.maxautovchans=4</span></code></pre></div></div><div class=paragraph><p>L’exemple ci-dessus alloue quatre canaux virtuels, ce qui est un nombre suffisant pour une utilisation classique. <code>hw.snd.pcm0.vchans</code> est le nombre de canaux virtuels que possède <span class=filename>pcm0</span>, et est configurable une fois que le périphérique a été attaché au système. <code>hw.snd.maxautovchans</code> est le nombre de canaux virtuels alloués à un nouveau périphérique audio quand il est attaché à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Comme le module <span class=filename>pcm</span> peut être chargé indépendamment des pilotes de périphériques, <code>hw.snd.maxautovchans</code> peut stocker combien de canaux virtuels seront alloués à chaque périphérique attaché par la suite.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vous ne pouvez pas modifier le nombre de canaux virtuels pour un périphérique en cours d’utilisation. Quittez avant tout autre chose les programmes utilisant le périphérique en question, comme les lecteurs de fichiers sonores ou les "daemons" audios.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous n’utilisez pas <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>, vous devrez faire pointer vos applications sur <span class=filename>/dev/dsp0</span>.<em>x</em>, où <em>x</em> est 0 à 3 si <code>hw.snd.pcm.0.vchans</code> est fixé à 4. Sur un système utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>, ce qui précède sera automatiquement effectué de façon transparente pour le programme qui réclame le périphérique <span class=filename>/dev/dsp0</span>.</p></div></div><div class=sect3><h4 id=_définir_les_valeurs_par_défaut_du_mixeur_des_différents_canaux>7.2.4. Définir les valeurs par défaut du mixeur des différents canaux<a class=anchor href=#_définir_les_valeurs_par_défaut_du_mixeur_des_différents_canaux></a></h4><div class=paragraph><p>Les valeurs par défaut du mixeur des différents canaux sont fixées en dur dans le code source du pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a>. Il existe plusieurs applications et "daemons" qui vous permettent de fixer les valeurs du mixeur qui seront mémorisées entre chaque invocation, mais ce n’est pas une solution idéale. Il est possible régler les valeurs par défaut au niveau du pilote - ceci se fait en définissant les valeurs adéquates dans le fichier <span class=filename>/boot/device.hints</span>. Par exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.pcm.0.vol=&#34;50&#34;</pre></div></div><div class=paragraph><p>Cela fixera le volume du canal à une valeur par défaut de 50; dès que le module <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> est chargé.</p></div></div></div><div class=sect2><h3 id=sound-mp3>7.3. Fichiers MP3<a class=anchor href=#sound-mp3></a></h3><div class=paragraph><p>Les fichiers MP3 (MPEG Layer 3 Audio) donnent un son proche de la qualité d’un CD audio, il n’y a aucune raison pour que votre station de travail FreeBSD ne puisse pas en profiter.</p></div><div class=sect3><h4 id=mp3-players>7.3.1. Lecteurs de MP3s<a class=anchor href=#mp3-players></a></h4><div class=paragraph><p>De loin, le plus populaire des lecteurs MP3 pour X11 est XMMS (X Multimedia System). Les thèmes (skins) de Winamp peuvent être utilisés avec XMMS dès lors que l’interface est quasiment identique à celle du Winamp de Nullsoft. XMMS dispose aussi d’un support natif pour modules externes (plug-in).</p></div><div class=paragraph><p>XMMS peut être installé à partir du catalogue de logiciels portés <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xmms/>multimedia/xmms</a> ou de la version pré-compilée.</p></div><div class=paragraph><p>L’interface d’XMMS est intuitive, avec une liste de lecture, un égaliseur graphique, et plus. Ceux qui sont familiers avec Winamp trouveront XMMS simple d’utilisation.</p></div><div class=paragraph><p>Le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> est une alternative, un lecteur de MP3 en ligne de commande.</p></div><div class=paragraph><p>mpg123 peut être utilisé en spécifiant le périphérique sonore et le fichier MP3 sur la ligne de commande, comme montré ci-dessous:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3</span>
High Performance MPEG 1.0/2.0/2.5 Audio Player <span class=k>for </span>Layer 1, 2 and 3.
Version 0.59r <span class=o>(</span>1999/Jun/15<span class=o>)</span><span class=nb>.</span> Written and copyrights by Michael Hipp.
Uses code from various people. See <span class=s1>&#39;README&#39;</span> <span class=k>for </span>more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from Foobar-GreastestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</code></pre></div></div><div class=paragraph><p><code>/dev/dsp1.0</code> devrait être remplacé par le périphérique <span class=filename>dsp</span> correspondant sur votre système.</p></div></div><div class=sect3><h4 id=rip-cd>7.3.2. Extraire les pistes de CDs Audio<a class=anchor href=#rip-cd></a></h4><div class=paragraph><p>Avant d’encoder la totalité d’un CD ou une piste en MP3, les données audio doivent être extraites et transférées sur le disque dur. Cela se fait en copiant les données brutes CDDA (CD Digital Audio) en fichiers WAV.</p></div><div class=paragraph><p>L’utilitaire <code>cdda2wav</code>, qui fait partie de la suite <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, est utilisé pour extraire les données audio de CDs et les informations rattachées.</p></div><div class=paragraph><p>Avec le CD audio dans le lecteur, la commande suivante peut être utilisée (en tant que <code>root</code>) pour convertir l’intégralité d’un CD en fichiers WAV (un par piste):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -B</span></code></pre></div></div><div class=paragraph><p>cdda2wav supportera également les lecteurs de CDROM ATAPI (IDE). Pour faire l’extraction à partir d’un lecteur IDE, précisez le nom du périphérique à la place de l’unité SCSI. Par exemple, pour extraite la piste 7 à partir d’un lecteur IDE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D /dev/acd0 -t 7</span></code></pre></div></div><div class=paragraph><p>Le <code>-D <em>0,1,0</em></code> spécifie le périphérique SCSI <span class=filename>0,1,0</span>, qui correspond à ce qui est donné par la commande <code>cdrecord -scanbus</code>.</p></div><div class=paragraph><p>Pour extraire des pistes individuelles, utilisez l’option <code>-t</code> comme ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 7</span></code></pre></div></div><div class=paragraph><p>Cet exemple extrait la septième piste du CD audio. Pour extraire un ensemble de pistes, par exemple, de la piste 1 à 7, précisez un intervalle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 1+7</span></code></pre></div></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> peut également être utilisé pour extraire des pistes audios à partir de lecteurs ATAPI, consultez la <a href=./#duplicating-audiocds>Dupliquer des CDs Audio</a> pour plus d’informations sur cette possibilité.</p></div></div><div class=sect3><h4 id=mp3-encoding>7.3.3. Encoder des MP3s<a class=anchor href=#mp3-encoding></a></h4><div class=paragraph><p>De nos jours, l’encodeur mp3 à utiliser est lame. Lame peut être trouvé dans le catalogue de logiciels portés: <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a>.</p></div><div class=paragraph><p>En utilisant les fichiers WAV extraits, la commande suivante convertira le fichier <span class=filename>audio01.wav</span> en <span class=filename>audio01.mp3</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lame -h -b 128 \</span>
<span class=nt>--tt</span> <span class=s2>&#34;La chanson XY&#34;</span> <span class=se>\</span>
<span class=nt>--ta</span> <span class=s2>&#34;Artiste XY&#34;</span> <span class=se>\</span>
<span class=nt>--tl</span> <span class=s2>&#34;Album XY&#34;</span> <span class=se>\</span>
<span class=nt>--ty</span> <span class=s2>&#34;2001&#34;</span> <span class=se>\</span>
<span class=nt>--tc</span> <span class=s2>&#34;Extrait et encodé par XY&#34;</span> <span class=se>\</span>
<span class=nt>--tg</span> <span class=s2>&#34;Genre&#34;</span> <span class=se>\</span>
audio01.wav audio01.mp3</code></pre></div></div><div class=paragraph><p>128 kbits semble être le taux standard actuel du débit audio utilisé pour les MP3s. Nombreux sont ceux qui préfèrent des taux de haute qualité: 160 ou 192. Plus le débit audio est élevé plus l’espace disque utilisé par le fichier MP3 sera grand mais la qualité sera meilleure. L’option <code>-h</code> active le mode "haute qualité, mais un peu plus lent". Les options commençant par <code>--t</code> indiquent des balises ID3, qui généralement contiennent les informations sur le morceau, devant être intégrées au fichier MP3. D’autres informations sur l’encodage peuvent être trouvées en consultant la page de manuel de Lame.</p></div></div><div class=sect3><h4 id=mp3-decoding>7.3.4. Décoder des MP3s<a class=anchor href=#mp3-decoding></a></h4><div class=paragraph><p>Afin de pouvoir graver un CD audio à partir de fichiers MP3, ces derniers doivent être convertis dans le format WAV non compressé. XMMS et mpg123 supportent tous les deux la sortie de fichiers MP3 en format de fichier non compressé.</p></div><div class=paragraph><p>Ecriture sur le disque avec XMMS:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Lancez XMMS.</p></li><li><p>Clic-droit sur la fenêtre pour faire apparaître le menu d’XMMS.</p></li><li><p>Sélectionner <code>Preference</code> sous <code>Options</code>.</p></li><li><p>Changez l’option "Output Plugin" pour "Disk Writer Plugin".</p></li><li><p>Appuyez sur <code>Configure</code>.</p></li><li><p>Entrez (ou choisissez browse) un répertoire où va être écrit le fichier décompressé.</p></li><li><p>Chargez le fichier MP3 dans XMMS comme à l’accoutumé, avec le volume à 100% et l’égaliseur (EQ settings) désactivé.</p></li><li><p>Appuyez sur <code>Play</code> - XMMS devrait se comporter comme s’il jouait le MP3, mais aucun son ne sera audible. Il est en fait en train de "jouer" le MP3 dans un fichier.</p></li><li><p>Vérifiez que vous avez rétabli l’option "Output Plugin" à sa valeur de départ afin de pouvoir écouter à nouveau des MP3s.</p></li></ol></div></div></div><div class=paragraph><p>Ecriture sur le disque avec mpg123:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Lancez <code>mpg123 -s audio01.mp3 audio01.pcm</code></p></li></ol></div></div></div><div class=paragraph><p>XMMS crée un fichier au format WAV, tandis que mpg123 convertit le fichier MP3 en données audio PCM brutes. Ces deux formats peuvent être utilisés avec cdrecord pour créer des CDs audio. Vous devez utiliser des fichiers PCM bruts avec <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a>. Si vous utilisez des fichiers WAV, vous noterez un petit parasite au début de chaque piste, ce son est l’entête du fichier WAV. Vous pouvez simplement retirer l’entête d’un fichier WAV avec l’utilitaire SoX (il peut être installé à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a> ou de la version pré-compilée):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sox <span class=nt>-t</span> wav <span class=nt>-r</span> 44100 <span class=nt>-s</span> <span class=nt>-w</span> <span class=nt>-c</span> 2 track.wav track.raw</code></pre></div></div><div class=paragraph><p>Lisez la <a href=./#creating-cds>Création et utilisation de supports optiques (CDs)</a> pour plus d’informations sur l’utilisation d’un graveur de CD sous FreeBSD.</p></div></div></div><div class=sect2><h3 id=video-playback>7.4. Lecture des Vidéos<a class=anchor href=#video-playback></a></h3><div class=paragraph><p>Les applications pour lire des vidéos sont assez récentes et se développent très rapidement. Soyez patient. Tout ne va pas fonctionner aussi bien que cela pu être le cas avec le son.</p></div><div class=paragraph><p>Avant que vous ne commenciez, vous devrez connaître le modèle de carte vidéo dont vous disposez ainsi que le circuit intégré qu’elle utilise. Alors qu’Xorg et XFree86™ supportent une large variété de cartes vidéo, seul un petit nombre d’entre elles donne de bonnes performances en lecture de vidéos. Pour obtenir la liste des extensions supportées par le serveur X utilisant votre carte employez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=xdpyinfo&amp;sektion=1&amp;format=html">xdpyinfo(1)</a> durant le fonctionnement d’X11.</p></div><div class=paragraph><p>C’est une bonne idée d’avoir un court fichier MPEG qui pourra être utilisé comme fichier test pour évaluer divers lecteurs et leurs options. Comme certains programmes de lecture de DVD chercheront un support DVD sur <span class=filename>/dev/dvd</span> par défaut, ou ont ce périphérique fixé définitivement dans leur code, vous pourrez trouver utile de créer des liens symboliques vers les périphériques corrects:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /dev/acd0 /dev/dvd</span>
<span class=c># ln -sf /dev/acd0 /dev/rdvd</span></code></pre></div></div><div class=paragraph><p>Notez qu’en raison de la nature du système <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>, les liens créés à la main comme les précédents ne seront pas conservés si vous redémarrez le système. Afin de créer automatiquement les liens symboliques dès que vous redémarrez votre système, ajoutez les lignes suivantes au fichier <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>link acd0 dvd
link acd0 rdvd</pre></div></div><div class=paragraph><p>De plus, le décodage de DVD, qui nécessite de faire appel à des fonctions spéciales du lecteur de DVD, demande d’avoir la permission d’écrire sur les périphériques DVD.</p></div><div class=paragraph><p>Pour augmenter la mémoire partagée pour l’interface X11, il est recommandé que les valeurs de certaines variables <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> soient augmentées:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</pre></div></div><div class=sect3><h4 id=video-interface>7.4.1. Déterminer les capacités vidéo<a class=anchor href=#video-interface></a></h4><div class=paragraph><p>Il y a plusieurs manières possibles pour afficher de la vidéo sous X11. Ce qui fonctionnera vraiment est énormément dépendant du matériel. Chaque méthode décrite ci-dessous donnera différents résultats en fonction du matériel. De plus, le rendu de la vidéo sous X11 est un sujet recevant beaucoup d’attention dernièrement, et avec chaque nouvelle version d’Xorg, ou d’XFree86™, il pourra y avoir des améliorations significatives.</p></div><div class=paragraph><p>Une liste des interfaces vidéo communes:</p></div><div class="olist arabic"><ol class=arabic><li><p>X11: sortie X11 classique utilisant de la mémoire partagée.</p></li><li><p>XVideo: une extension de l’interface X11 qui supporte la vidéo sur n’importe quelle partie de l’écran contrôlé par X11.</p></li><li><p>SDL: "Simple Directmedia Layer" - couche simple d’accès directe au média.</p></li><li><p>DGA: "Direct Graphics Access" - accès direct au graphique.</p></li><li><p>SVGAlib: couche graphique bas niveau pour la console.</p></li></ol></div><div class=sect4><h5 id=video-interface-xvideo>7.4.1.1. XVideo<a class=anchor href=#video-interface-xvideo></a></h5><div class=paragraph><p>Xorg et XFree86™ 4.X disposent d’une extension appelée <em>XVideo</em> (également connue sous les termes Xvideo, Xv, ou xv) qui permet d’afficher directement de la vidéo à travers une accélération spécifique. Cette extension fournit une très bonne qualité de rendu même sur les machines bas de gamme.</p></div><div class=paragraph><p>Pour vérifier si l’extension fonctionne utilisez <code>xvinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xvinfo</code></pre></div></div><div class=paragraph><p>XVideo est supporté pour votre carte si le résultat de la commande ressemble à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
  Adaptor <span class=c>#0: &#34;Savage Streams Engine&#34;</span>
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      <span class=s2>&#34;XV_COLORKEY&#34;</span> <span class=o>(</span>range 0 to 16777215<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 2110<span class=o>)</span>
      <span class=s2>&#34;XV_BRIGHTNESS&#34;</span> <span class=o>(</span>range <span class=nt>-128</span> to 127<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
      <span class=s2>&#34;XV_CONTRAST&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_SATURATION&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_HUE&#34;</span> <span class=o>(</span>range <span class=nt>-180</span> to 180<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      <span class=nb>id</span>: 0x32595559 <span class=o>(</span>YUY2<span class=o>)</span>
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x32315659 <span class=o>(</span>YV12<span class=o>)</span>
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x30323449 <span class=o>(</span>I420<span class=o>)</span>
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x36315652 <span class=o>(</span>RV16<span class=o>)</span>
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      <span class=nb>id</span>: 0x35315652 <span class=o>(</span>RV15<span class=o>)</span>
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      <span class=nb>id</span>: 0x31313259 <span class=o>(</span>Y211<span class=o>)</span>
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</code></pre></div></div><div class=paragraph><p>Notez également que les formats listés (YUV2, YUV12, etc…​) ne sont pas présents dans chaque implémentation d’XVideo et leur absence pourra gêner certains programmes.</p></div><div class=paragraph><p>Si le résultat ressemble à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
no adaptors present</code></pre></div></div><div class=paragraph><p>Alors XVideo n’est probablement pas supporté pour votre carte.</p></div><div class=paragraph><p>Si XVideo n’est pas supporté pour votre carte, cela signifie seulement qu’il sera plus difficile pour votre système d’affichage de répondre aux demandes du rendu vidéo en termes de puissance de calcul. En fonction de votre carte vidéo et de votre processeur, vous pourriez encore obtenir de bons résultats. Vous devriez probablement vous documenter sur les méthodes pour améliorer les performances en lisant la <a href=#video-further-reading>Lectures supplémentaires</a>.</p></div></div><div class=sect4><h5 id=video-interface-SDL>7.4.1.2. "Simple Directmedia Layer" - couche simple d’accès directe au média<a class=anchor href=#video-interface-SDL></a></h5><div class=paragraph><p>La couche simple d’accès directe au média, SDL, a été prévue pour être une couche de portage entre Microsoft® Windows®, BeOS, et UNIX®, permettant à des applications "cross-platform" qui font un usage efficace du son et du graphique d’être développées. La couche SDL fournit une abstraction de bas niveau vers le matériel qui peut parfois être plus efficace que l’interface X11.</p></div><div class=paragraph><p>La bibliothèque SDL peut être trouvée dans <a class=package href=https://cgit.freebsd.org/ports/tree/devel/sdl12/>devel/sdl12</a>.</p></div></div><div class=sect4><h5 id=video-interface-DGA>7.4.1.3. "Direct Graphics Access" - accès direct au graphique<a class=anchor href=#video-interface-DGA></a></h5><div class=paragraph><p>L’accès direct au graphique est une extension X11 qui permet à un programme de bypasser le serveur X et d’accéder directement au matériel. Comme il repose sur une copie bas niveau de la mémoire, les programmes l’utilisant doivent être exécutés avec les privilèges de l’utilisateur <code>root</code>.</p></div><div class=paragraph><p>L’extension DGA et ses performances peuvent être testées avec <a href="https://man.freebsd.org/cgi/man.cgi?query=dga&amp;sektion=1&amp;format=html">dga(1)</a>. Quand <code>dga</code> est exécuté, il changera les couleurs de l’affichage à chaque appui sur une touche. Pour quitter, utilisez la touche <kbd>q</kbd>.</p></div></div></div><div class=sect3><h4 id=video-ports>7.4.2. Logiciels portés et pré-compilés relatifs à la vidéo<a class=anchor href=#video-ports></a></h4><div class=paragraph><p>Cette section traite des logiciels disponibles dans le catalogue des logiciels portés de FreeBSD qui peuvent être utilisés pour lire de la vidéo. Les applications vidéos sont un domaine de développement très actif, et les capacités de diverses applications seront sujettes à des divergences avec la description donnée ici.</p></div><div class=paragraph><p>Premièrement, il est important de savoir que plusieurs des applications vidéos fonctionnant sous FreeBSD ont été développées comme des applications pour Linux. Plusieurs de ces applications sont encore considérées comme étant de qualité bêta. Parmi les problèmes que l’on peut rencontrer avec les applications vidéos sous FreeBSD, nous trouvons:</p></div><div class="olist arabic"><ol class=arabic><li><p>Une application ne peut pas lire un fichier produit par une autre application.</p></li><li><p>Une application ne peut pas lire un fichier quelle a produit.</p></li><li><p>La même application sur deux machines différentes, recompilée sur chaque machine pour la machine elle-même, jouera le fichier différemment.</p></li><li><p>Un filtre apparemment insignifiant comme un changement d’échelle de l’image donne de très mauvais résultats en raison d’une routine de changement d’échelle boguée.</p></li><li><p>Une application qui plante régulièrement.</p></li><li><p>La documentation n’est pas installée avec le logiciel porté et peut être trouvée sur Internet ou dans le répertoire <span class=filename>work</span> du logiciel porté.</p></li></ol></div><div class=paragraph><p>Parmin ces applications, nombreuses sont celles qui peuvent présenter des "Linuxismes". Aussi, il y peut y avoir des problèmes résultants de la façon dont certaines bibliothèques standards sont implémentées dans les distributions Linux, ou certaines caractéristiques du noyau Linux qui ont été employées par les auteurs des applications. Ces problèmes ne sont pas toujours remarqués et contournés par les responsables du portage du logiciel ce qui peut mener vers quelques ennuis comme ceux-ci:</p></div><div class="olist arabic"><ol class=arabic><li><p>L’utilisation de <span class=filename>/proc/cpuinfo</span> pour détecter les caractéristiques du processeur.</p></li><li><p>Une mauvaise utilisation des "threads" qui provoque le blocage de programme au lieu de se terminer complètement.</p></li><li><p>Des logiciels habituellement utilisés en conjonction avec l’application ne sont pas encore dans le catalogue des logiciels portés.</p></li></ol></div><div class=paragraph><p>Jusqu’ici, les développeurs de ces applications ont été coopératifs avec les responsables des logiciels portés pour minimiser les modifications nécessaires au portage.</p></div><div class=sect4><h5 id=video-mplayer>7.4.2.1. MPlayer<a class=anchor href=#video-mplayer></a></h5><div class=paragraph><p>MPlayer est une application pour lire des vidéos récemment et rapidement développée. Les objectifs de l’équipe de MPlayer sont la rapidité et la flexibilité sur Linux et autre UNIX®. Le projet fut démarré quand le fondateur de l’équipe en eu assez des mauvaises performances en lecture des autres lecteurs disponibles. Certains diront que l’interface graphique a été sacrifiée pour une conception rationalisée. Cependant, une fois que vous avez les options en ligne de commande et les combinaisons de touches en main, cela fonctionne très bien.</p></div><div class=sect5><h6 id=video-mplayer-building>7.4.2.1.1. Compiler MPlayer<a class=anchor href=#video-mplayer-building></a></h6><div class=paragraph><p>MPlayer réside dans <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mplayer/>multimedia/mplayer</a>. MPlayer effectue un certain nombre de contrôle du matériel durant le processus de compilation, il en résulte un binaire qui ne sera pas portable d’un système à l’autre. Ainsi il est important d’utiliser le logiciel porté et de ne pas utiliser un logiciel pré-compilé. En plus, un certain nombre d’options peuvent être spécifiées dans la ligne de commande <code>make</code>, comme décrit dans le fichier <span class=filename>Makefile</span> et au départ de la compilation:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mplayer</span>
<span class=c># make</span>
N - O - T - E

Take a careful look into the Makefile <span class=k>in </span>order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either <span class=nb>install</span>
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html</code></pre></div></div><div class=paragraph><p>Les options par défaut du logiciel porté devraient être suffisantes pour la plupart des utilisateurs. Cependant si vous avez besoin du codec XviD, vous devez spécifier l’option <code>WITH_XVID</code> dans la ligne de commande. Le périphérique DVD par défaut peut également être défini avec l’option <code>WITH_DVD_DEVICE</code>, par défaut <span class=filename>/dev/acd0</span> sera utilisé.</p></div><div class=paragraph><p>Au moment de l’écriture de ces lignes, le logiciel porté de MPlayer compilera sa documentation HTML et deux exécutables, <code>mplayer</code> et <code>mencoder</code>, qui est un outil pour ré-encoder de la vidéo.</p></div><div class=paragraph><p>La documentation HTML de MPlayer est très complète. Si le lecteur trouve l’information sur le matériel vidéo et les interfaces manquante dans ce chapitre, la documentation de MPlayer est une alternative très complète. Vous devriez certainement prendre le temps de lire la documentation de MPlayer, si vous êtes à la recherche d’informations sur le support vidéo sous UNIX®.</p></div></div><div class=sect5><h6 id=video-mplayer-using>7.4.2.1.2. Utiliser MPlayer<a class=anchor href=#video-mplayer-using></a></h6><div class=paragraph><p>Chaque utilisateur de MPlayer doit créer un sous-répertoire <span class=filename>.mplayer</span> dans son répertoire d’utilisateur. Pour créer ce sous-répertoire nécessaire, vous pouvez taper ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/ports/multimedia/mplayer
% make install-user</code></pre></div></div><div class=paragraph><p>Les options de commande de <code>mplayer</code> sont données dans la page de manuel. Pour plus de détails il y a la documentation HTML. Dans cette section, nous décrirons que quelques unes des utilisations les plus courantes.</p></div><div class=paragraph><p>Pour lire à un fichier, comme <span class=filename>testfile.avi</span> en utilisant une des diverses interfaces vidéo utilisez l’option <code>-vo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> xv testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> sdl testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> x11 testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga testfile.avi</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo &#39;sdl:dga&#39; testfile.avi</span></code></pre></div></div><div class=paragraph><p>Cela vaut la peine d’essayer toutes ces options, comme leur performance relative dépend de nombreux facteurs et variera de façon significative avec le matériel.</p></div><div class=paragraph><p>Pour lire un DVD, remplacez <span class=filename>testfile.avi</span> par <code>dvd://<em>N</em> -dvd-device <em>DEVICE</em></code> où <em>N</em> est le numéro du titre à jouer et <span class=filename>DEVICE</span> est le fichier spécial de périphérique correspondant au lecteur de DVD. Par exemple, pour jouer le titre 3 depuis <span class=filename>/dev/dvd</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo xv dvd://3 -dvd-device /dev/dvd</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le périphérique DVD par défaut peut être défini lors de la compilation du logiciel porté MPlayer par l’intermédiaire de l’option <code>WITH_DVD_DEVICE</code>. Par défaut, ce périphérique est <span class=filename>/dev/acd0</span>. Plus de détails peuvent être trouvés dans le <span class=filename>Makefile</span> du logiciel porté.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour arrêter, avancer, etc…​, consultez les combinaisons de touches, qui sont données en exécutant <code>mplayer -h</code> ou lisez la page de manuel.</p></div><div class=paragraph><p>D’autres options importantes pour la lecture sont: <code>-fs -zoom</code> qui active le mode plein écran et <code>-framedrop</code> qui aide au niveau des performances.</p></div><div class=paragraph><p>Pour que la ligne de commande à taper ne devienne pas trop longue, l’utilisateur peut créer un fichier <span class=filename>.mplayer/config</span> et y fixer les options par défaut:</p></div><div class="literalblock programlisting"><div class=content><pre>vo=xv
fs=yes
zoom=yes</pre></div></div><div class=paragraph><p>Enfin, <code>mplayer</code> peut être utilisé pour extraire une piste du DVD dans un fichier <span class=filename>.vob</span>. Pour récupérer la seconde piste vidéo d’un DVD, tapez ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</span></code></pre></div></div><div class=paragraph><p>Le fichier de sortie, <span class=filename>out.vob</span>, sera du MPEG et peut être manipulé par les autres logiciels décrits dans cette section.</p></div></div><div class=sect5><h6 id=video-mencoder>7.4.2.1.3. mencoder<a class=anchor href=#video-mencoder></a></h6><div class=paragraph><p>Avant d’utiliser <code>mencoder</code> c’est une bonne idée de vous familiariser avec les options données par la documentation HTML. Il existe une page de manuel, mais elle n’est pas très utile sans la documentation en HTML. Il y a d’innombrables façons d’améliorer la qualité, diminuer le débit binaire, et modifier les formats, et certaines de ces options peuvent faire la différence entre de bonnes et mauvaises performances. Voici quelques exemples pour y arriver. Tout d’abord une simple copie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> copy <span class=nt>-ovc</span> copy <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>De mauvaises combinaisons d’options peuvent conduire à des fichiers illisibles même par <code>mplayer</code>. Aussi, si vous voulez juste extraire un fichier, restez sur l’option <code>-dumpfile</code> de <code>mplayer</code>.</p></div><div class=paragraph><p>Pour convertir <span class=filename>input.avi</span> au format MPEG4 avec un codage audio MPEG3 (<a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a> est nécessaire):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> mp3lame <span class=nt>-lameopts</span> <span class=nv>br</span><span class=o>=</span>192 <span class=se>\</span>
	 <span class=nt>-ovc</span> lavc <span class=nt>-lavcopts</span> <span class=nv>vcodec</span><span class=o>=</span>mpeg4:vhq <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>Ceci a produit un fichier lisible par <code>mplayer</code> et <code>xine</code>.</p></div><div class=paragraph><p><span class=filename>input.avi</span> peut être remplacé par <code>dvd://1 -dvd-device /dev/dvd</code> et exécuté en tant que <code>root</code> pour ré-encoder directement un titre DVD. Puisque vous êtes susceptible de ne pas être satisfait du résultat la première fois, il est recommandé d’extraire le titre vers un fichier et de travailler sur le fichier.</p></div></div></div><div class=sect4><h5 id=video-xine>7.4.2.2. Le lecteur xine<a class=anchor href=#video-xine></a></h5><div class=paragraph><p>Le lecteur xine est un projet de grande envergure visant non seulement à être une solution vidéo tout-en-un, mais également de produire une bibliothèque de base réutilisable et un exécutable modulaire qui peut être étendu grâce à des greffons. Il est fourni sous forme pré-compilée et de logiciel porté, <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xine/>multimedia/xine</a>.</p></div><div class=paragraph><p>Le lecteur xine est encore un peu brut, mais c’est clairement un bon début. Dans la pratique, xine demande soit un processeur rapide avec une carte vidéo rapide, soit l’extension XVideo. L’interface graphique est utilisable, mais peu pratique.</p></div><div class=paragraph><p>Au moment de l’écriture de ces lignes, il n’y a pas de module d’entrée fourni avec xine qui lira les DVDs codés en CSS. Il existe des versions tiers qui ont des modules à cet effet intégrés, mais aucune de ces dernières ne se trouve dans le catalogue des logiciels portés de FreeBSD.</p></div><div class=paragraph><p>Comparé à MPlayer, xine fait plus pour l’utilisateur, mais au même moment, rend inaccessible à l’utilisateur certains contrôles bien précis. Le lecteur xine se comporte le mieux sur les interfaces XVideo.</p></div><div class=paragraph><p>Par défaut, le lecteur xine lancera une interface graphique. Les menus peuvent alors être utilisés pour ouvrir un fichier précis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine</code></pre></div></div><div class=paragraph><p>Alternativement, le lecteur peut être invoqué pour jouer directement un fichier sans l’interface graphique avec la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine <span class=nt>-g</span> <span class=nt>-p</span> mymovie.avi</code></pre></div></div></div><div class=sect4><h5 id=video-ports-transcode>7.4.2.3. Les utilitaires transcode<a class=anchor href=#video-ports-transcode></a></h5><div class=paragraph><p>Le logiciel transcode n’est pas un lecteur, mais une suite d’outils pour ré-encoder les fichiers audio et vidéo. Avec transcode, on a la capacité de fusionner des fichiers vidéos, réparer les fichiers endommagés, en utilisant les outils en ligne de commande avec des interfaces de flots <span class=filename>stdin/stdout</span>.</p></div><div class=paragraph><p>Un grand nombre d’options peut être précisé lors de la compilation du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/transcode/>multimedia/transcode</a>, nous recommandons d’utiliser la ligne de commande suivante pour compiler transcode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \</span>
<span class=nv>WITH_MJPEG</span><span class=o>=</span><span class=nb>yes</span> <span class=nt>-DWITH_XVID</span><span class=o>=</span><span class=nb>yes</span></code></pre></div></div><div class=paragraph><p>Le paramétrage proposé devrait convenir à la plupart des utilisateurs.</p></div><div class=paragraph><p>Pour illustrer les capacités de <code>transcode</code>, voici un exemple montrant comment convertir un fichier DivX en fichier MPEG-1 en standard PAL (VCD PAL):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% transcode <span class=nt>-i</span> input.avi <span class=nt>-V</span> <span class=nt>--export_prof</span> vcd-pal <span class=nt>-o</span> output_vcd
% mplex <span class=nt>-f</span> 1 <span class=nt>-o</span> output_vcd.mpg output_vcd.m1v output_vcd.mpa</code></pre></div></div><div class=paragraph><p>Le fichier MPEG résultant, <span class=filename>output_vcd.mpg</span>, peut être directement lu avec MPlayer. Vous pourrez même le graver sur un CD pour créer ainsi un Vidéo CD; dans ce cas vous devrez installer et utiliser les programmes <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/vcdimager/>multimedia/vcdimager</a> et <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a>.</p></div><div class=paragraph><p>Il existe une page de manuel pour <code>transcode</code>, mais il est conseillé de consulter également le <a href=http://www.transcoding.org/cgi-bin/transcode>wiki de transcode</a> pour plus d’information et des exemples.</p></div></div></div><div class=sect3><h4 id=video-further-reading>7.4.3. Lectures supplémentaires<a class=anchor href=#video-further-reading></a></h4><div class=paragraph><p>Les différents logiciels vidéo pour FreeBSD se développent rapidement. Il est fort possible que dans un futur proche plusieurs des problèmes abordés ici seront résolus. Entre temps ceux qui veulent tirer partie des possibilités audio/vidéo de FreeBSD devront se débrouiller avec des connaissances extraites de plusieurs FAQs et guides et utiliser différentes applications. Cette section existe pour fournir au lecteur des références sur ces documentations additionnelles.</p></div><div class=paragraph><p>La <a href=http://www.mplayerhq.hu/DOCS/>documentation de MPlayer</a> est techniquement très instructive. Ces documents devraient probablement être consultés par quiconque désirant obtenir un niveau élevé d’expertise sur la vidéo et UNIX®. La liste de diffusion de MPlayer est hostile à toute personne qui n’a pas pris la peine de lire la documentation, aussi si vous projetez de leur envoyer des rapports de bogue, lisez la documentation!</p></div><div class=paragraph><p>Le <a href=http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html>HOWTO de xine</a> contient un chapitre sur l’amélioration des performances qui est général à tous les lecteurs de vidéo.</p></div><div class=paragraph><p>Et enfin, il y a quelques autres applications prometteuses que le lecteur devrait essayer:</p></div><div class=ulist><ul><li><p><a href=http://avifile.sourceforge.net/>Avifile</a> qui est également un logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/avifile/>multimedia/avifile</a>.</p></li><li><p><a href=http://www.dtek.chalmers.se/groups/dvd/>Ogle</a> qui est également un logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/ogle/>multimedia/ogle</a>.</p></li><li><p><a href=http://xtheater.sourceforge.net/>Xtheater</a></p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a>, un logiciel libre pour la création de DVDs.</p></li></ul></div></div></div><div class=sect2><h3 id=tvcard>7.5. Configuration des cartes TV<a class=anchor href=#tvcard></a></h3><div class=sect3><h4 id=_introduction>7.5.1. Introduction<a class=anchor href=#_introduction></a></h4><div class=paragraph><p>Les cartes TV vous permettent de regarder sur votre ordinateur la télévision par voie hertzienne ou par câble. La plupart d’entre elles acceptent de la vidéo composite par l’intermédiaire de connecteurs RCA ou S-video et certaines de ces cartes disposent d’un tuner radio FM.</p></div><div class=paragraph><p>FreeBSD founit le support pour les cartes TV PCI utilisant un circuit de capture video Brooktree Bt848/849/878/879 ou Conexant CN-878/Fusion 878a à l’aide du pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>. Vous devez également vous assurer que la carte dispose d’un tuner supporté, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> pour une liste des tuners supportés.</p></div></div><div class=sect3><h4 id=_ajout_du_pilote_de_périphérique>7.5.2. Ajout du pilote de périphérique<a class=anchor href=#_ajout_du_pilote_de_périphérique></a></h4><div class=paragraph><p>Pour utiliser votre carte, vous devrez charger le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>, cela peut être effectué en ajoutant la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Alternativement, vous pouvez compiler en statique dans le noyau le support pour la carte TV, dans ce cas ajouter les lignes suivantes dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device	 bktr
device	iicbus
device	iicbb
device	smbus</pre></div></div><div class=paragraph><p>Ces pilotes de périphériques supplémentaires sont nécessaires étant donné que les composants de la carte sont interconnectés via un bus I2C. Compilez et installez, ensuite, un nouveau noyau.</p></div><div class=paragraph><p>Une fois que le support a été ajouté au système, vous devez redémarrer votre machine. Durant le processus de démarrage, votre carte TV devrait apparaître de cette manière:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr0: BrookTree 848A mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: I2C bit-banging driver on bti2c0
iicbus0: Philips I2C bus on iicbb0 master-only
iicbus1: Philips I2C bus on iicbb0 master-only
smbus0: System Management Bus on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</pre></div></div><div class=paragraph><p>Bien évidemment ces messages peuvent varier en fonction de votre matériel. Cependant assurez-vous que le tuner est correctement détecté; il est possible de forcer certains des paramètres détecté à l’aide du système <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> et d’options de configuration du noyau. Par exemple, si vous désirez forcer le tuner pour un tuner Philips SECAM, vous devrez ajouter la ligne suivante au fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options OVERRIDE_TUNER=6</pre></div></div><div class=paragraph><p>ou vous pouvez directement utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.bt848.tuner=6</span></code></pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> et le fichier <span class=filename>/usr/src/sys/conf/NOTES</span> pour plus de détails sur les options disponibles.</p></div></div><div class=sect3><h4 id=_applications_utiles>7.5.3. Applications utiles<a class=anchor href=#_applications_utiles></a></h4><div class=paragraph><p>Pour utiliser votre carte TV, vous devrez installer une des applications suivantes:</p></div><div class=ulist><ul><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/fxtv/>multimedia/fxtv</a> qui permet de regarder la télévision et d’enregistrer des images, du son et de la vidéo.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xawtv/>multimedia/xawtv</a> est également une application pour regarder la télévision avec les mêmes fonctionnalités que fxtv.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/misc/alevt/>misc/alevt</a> décode et affiche les informations Vidéotexte/Télétexte.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmradio/>audio/xmradio</a>, un programme pour utiliser le tuner FM fourni avec certaines cartes TV.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/wmtune/>audio/wmtune</a>, une application intégrable dans votre environnement de travail pour gérer les tuners radio.</p></li></ul></div><div class=paragraph><p>Plus d’applications sont disponibles dans le catalogue des logiciels portés de FreeBSD.</p></div></div><div class=sect3><h4 id=_en_cas_de_problème>7.5.4. En cas de problème<a class=anchor href=#_en_cas_de_problème></a></h4><div class=paragraph><p>Si vous rencontrez un quelconque problème avec votre carte TV, vous devriez contrôler tout d’abord que le circuit de capture video et le tuner sont vraiment supportés par le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> et si vous avez utilisé les bonnes options de configuration. Pour plus de support et pour les diverses questions que vous pouvez vous poser à propos de votre carte TV, vous pouvez contacter et utiliser les archives de la liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>liste de diffusion pour les discussions concernant le multimédia sous FreeBSD</a>.</p></div></div></div><div class=sect2><h3 id=scanners>7.6. Scanners<a class=anchor href=#scanners></a></h3><div class=sect3><h4 id=_introduction_2>7.6.1. Introduction<a class=anchor href=#_introduction_2></a></h4><div class=paragraph><p>Sous FreeBSD, l’accès aux scanners est possible grâce à l’APISANE (Scanner Access Now Easy) disponible dans le catalogue des logiciels portés. SANE utilisera également certains pilotes de périphériques FreeBSD pour accéder à la partie matérielle du scanner.</p></div><div class=paragraph><p>FreeBSD supporte les scanners SCSI et USB. Assurez-vous que votre scanner est supporté par SANE avant d’effectuer une quelconque configuration. SANE dispose d’une liste des <a href=http://www.sane-project.org/sane-supported-devices.html>périphériques supportés</a> qui peut vous informer sur le support et son statut pour un scanner particulier. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=uscanner&amp;sektion=4&amp;format=html">uscanner(4)</a> donne également une liste des scanners USB supportés.</p></div></div><div class=sect3><h4 id=_configuration_du_noyau>7.6.2. Configuration du noyau<a class=anchor href=#_configuration_du_noyau></a></h4><div class=paragraph><p>Comme mentionné plus haut les interfaces SCSI et USB sont supportées. En fonction de l’interface de votre scanner, différents pilotes de périphérique sont nécessaires.</p></div><div class=sect4><h5 id=scanners-kernel-usb>7.6.2.1. Interface USB<a class=anchor href=#scanners-kernel-usb></a></h5><div class=paragraph><p>Le noyau <span class=filename>GENERIC</span> inclut par défaut les pilotes nécessaires au support des scanners USB. Si vous décidez d’utiliser un noyau personnalisé, assurez-vous que les lignes suivantes sont présentes dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device usb
device uhci
device ohci
device uscanner</pre></div></div><div class=paragraph><p>En fonction du contrôleur USB présent sur votre carte mère, vous n’avez besoin que d’une des deux lignes <code>device uhci</code> et <code>device ohci</code>, cependant avoir ces deux lignes simultanément dans la configuration du noyau est sans risque.</p></div><div class=paragraph><p>Si vous ne désirez pas recompiler votre noyau et que votre noyau n’est pas le <span class=filename>GENERIC</span>, vous pouvez directement charger le module du pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=uscanner&amp;sektion=4&amp;format=html">uscanner(4)</a> à l’aide de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload uscanner</span></code></pre></div></div><div class=paragraph><p>Pour charger ce module à chaque démarrage du système, ajoutez la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>uscanner_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Après avoir redémarré avec le bon noyau, ou après avoir chargé le module nécessaire, branchez votre scanner USB. Une ligne montrant la détection de votre scanner devrait apparaître dans le tampon des messages du système (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</code></pre></div></div><div class=paragraph><p>Ceci nous indique que notre scanner utilise le fichier spécial de périphérique <span class=filename>/dev/uscanner0</span>.</p></div></div><div class=sect4><h5 id=_interface_scsi>7.6.2.2. Interface SCSI<a class=anchor href=#_interface_scsi></a></h5><div class=paragraph><p>Si votre scanner dispose d’une interface SCSI, il est important de connaître quelle carte contrôleur SCSI vous utiliserez. En fonction du contrôleur sur la carte, vous devrez adapter votre configuration du noyau. Le noyau <span class=filename>GENERIC</span> supporte les contrôleurs SCSI les plus courants. Assurez-vous d’avoir lu le fichier <span class=filename>NOTES</span> et ajoutez la ligne adéquate dans votre fichier de configuration du noyau. En plus du pilote de votre carte SCSI, vous avez besoin des lignes suivantes dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device pass</pre></div></div><div class=paragraph><p>Une fois que votre noyau a été correctement compilé et installé, vous devriez être en mesure de voir les périphériques au démarrage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</code></pre></div></div><div class=paragraph><p>Si votre scanner n’était pas alimenté au démarrage du système, il est encore possible de forcer sa détection, en en sondant le bus SCSI avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol rescan all</span>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</code></pre></div></div><div class=paragraph><p>Ensuite le scanner apparaîtra dans la liste des périphériques SCSI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 <span class=o>(</span>pass0,da0<span class=o>)</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 <span class=o>(</span>pass1,da1<span class=o>)</span>
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 <span class=o>(</span>pass3<span class=o>)</span>
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 <span class=o>(</span>pass2,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Plus de détails sur les périphériques SCSI sont disponibles dans les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=scsi&amp;sektion=4&amp;format=html">scsi(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>.</p></div></div></div><div class=sect3><h4 id=_configuration_de_sane>7.6.3. Configuration de SANE<a class=anchor href=#_configuration_de_sane></a></h4><div class=paragraph><p>Le système SANE est divisé en deux parties: les "backend"s (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>) et les "frontend"s (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a>). Les "backend"s fournissent l’accès au scanner. La liste des <a href=http://www.sane-project.org/sane-supported-devices.html>périphériques supportés</a> par SANE indique quel "backend" supportera votre scanner. Il est indispensable de déterminer correctement le "backend" relatif à votre scanner si vous voulez être en mesure d’utiliser votre périphérique. La partie "frontend"s fournie l’interface graphique de numérisation (xscanimage).</p></div><div class=paragraph><p>La première étape est d’installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a> ou sa version pré-compilée. Ensuite, utilisez la commande <code>sane-find-scanner</code> pour contrôler la détection du scanner par l’ensemble SANE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found SCSI scanner <span class=s2>&#34;AGFA SNAPSCAN 600 1.10&#34;</span> at /dev/pass3</code></pre></div></div><div class=paragraph><p>Le résultat de la commande affichera le type d’interface utilisée par le scanner et le fichier spécial de périphérique utilisé pour attacher le scanner au système. Le fabricant et le modèle peuvent ne pas apparaître, cela n’est pas important.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains scanners USB requièrent le chargement préalable d’un "firmware", cela est expliqué dans la page de manuel du "backend" utilisé. Vous devriez également consulter les pages de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=sane-find-scanner&amp;sektion=1&amp;format=html">sane-find-scanner(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=linprocfs&amp;sektion=7&amp;format=html">linprocfs(7)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nous devons maintenant vérifier si le scanner sera identifié par un "frontend" de numérisation. Par défaut, les "backend"s SANE sont fournies avec un outil en ligne de commande appelé <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a>. Cette commande vous permet de lister les périphériques et d’effectuer une acquisition d’image à partir de la ligne de commande. L’option <code>-L</code> est employée pour afficher les scanners présents sur le système:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>snapscan:/dev/pass3<span class=s1>&#39; is a AGFA SNAPSCAN 600 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Aucun résultat, ou un message disant qu’aucun scanner n’a été identifié indiquent que <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a> est incapable d’identifier le scanner. Si cela se produit, vous devrez éditer le fichier de configuration du "backend" du scanner et définir le type de scanner utilisé. Le répertoire <span class=filename>/usr/local/etc/sane.d/</span> contient tous les fichiers de configurations des "backend"s. Ce problème d’identification apparaît essentiellement avec certains scanners USB.</p></div><div class=paragraph><p>Par exemple, avec le scanner USB utilisé dans la <a href=#scanners-kernel-usb>Interface USB</a>, <code>sane-find-scanner</code> nous donne l’information suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found USB scanner <span class=o>(</span>UNKNOWN vendor and product<span class=o>)</span> at device /dev/uscanner0</code></pre></div></div><div class=paragraph><p>Le scanner est correctement détecté, il utilise l’interface USB et est attaché au fichier spécial de périphérique <span class=filename>/dev/uscanner0</span>. Nous pouvons maintenant vérifier si le scanner est correctement identifié:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged <span class=k>in</span>, turned on and detected by the
sane-find-scanner tool <span class=o>(</span><span class=k>if </span>appropriate<span class=o>)</span><span class=nb>.</span> Please <span class=nb>read </span>the documentation
which came with this software <span class=o>(</span>README, FAQ, manpages<span class=o>)</span>.</code></pre></div></div><div class=paragraph><p>Comme le scanner n’est pas identifié, nous devons éditer le fichier <span class=filename>/usr/local/etc/sane.d/epson.conf</span>. Le scanner utilisé était un EPSON Perfection® 1650, nous en déduisons donc que ce scanner utilisera le "backend" <code>epson</code>. Assurez-vous de bien lire les commentaires d’aide présents dans les fichiers de configuration des "backend"s. Les modifications à faire sont relativement simples: commentez toutes les lignes concernant une interface différente de celle utilisée par votre scanner (dans notre cas, nous commenterons toutes les lignes débutant par le mot <code>scsi</code> étant donné que notre scanner utilise une interface USB), ajoutez ensuite à la fin du fichier une ligne indiquant l’interface et le fichier spécial de périphérique utilisé. Dans ce cas, nous ajoutons la ligne suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>usb /dev/uscanner0</pre></div></div><div class=paragraph><p>Veuillez vous assurer de bien lire les commentaires fournis dans les fichiers de configurations des "backend"s ainsi que les pages de manuel correspondantes pour plus de détails concernant la syntaxe correcte à utiliser. Nous pouvons maintenant vérifier si le scanner est identifié:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>epson:/dev/uscanner0<span class=s1>&#39; is a Epson GT-8200 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Notre scanner a été identifié. Ce n’est pas important si la marque et le modèle ne correspondent pas au scanner. L’important est le champ <code>epson:/dev/uscanner0'</code>, qui nous donne le "backend" et le fichier spécial de périphérique corrects.</p></div><div class=paragraph><p>Une fois que la commande <code>scanimage -L</code> est en mesure d’identifier le scanner, la configuration est terminée. Le périphérique est prêt à effectuer sa première numérisation.</p></div><div class=paragraph><p>Bien que <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a> permette d’effectuer une numérisation à partir de la ligne de commande, il est préférable d’utiliser une interface graphique. SANE offre une interface graphique simple mais efficace: xscanimage (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a>).</p></div><div class=paragraph><p>Xsane (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a>) est une autre interface graphique de numérisation assez populaire. Ce programme offre des fonctions avancées comme différents mode de numérisation (photocopie, fax, etc.), la correction des couleurs, la numérisation par lots, etc. Ces deux applications sont utilisables comme greffon pour GIMP.</p></div></div><div class=sect3><h4 id=_donner_laccès_au_scanner_aux_autres_utilisateurs>7.6.4. Donner l’accès au scanner aux autres utilisateurs<a class=anchor href=#_donner_laccès_au_scanner_aux_autres_utilisateurs></a></h4><div class=paragraph><p>Toutes les opérations précédentes ont été effectuées avec les privilèges <code>root</code>. Vous pourrez, cependant, avoir besoin que d’autres utilisateurs puissent accéder au scanner. L’utilisateur devra avoir les permissions de lecture et d’écriture sur le fichier spécial de périphérique <span class=filename>/dev/uscanner0</span> dont le propriétaire est le groupe <code>operator</code>. L’ajout de l’utilisateur <code>joe</code> au groupe <code>operator</code> lui autorisera l’accès au scanner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod operator -m joe</span></code></pre></div></div><div class=paragraph><p>Pour plus de détails, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>. Vous devez également fixer les permissions d’écriture correctes (0660 or 0664) sur le fichier spécial de périphérique <span class=filename>/dev/uscanner0</span>, par défaut le groupe <code>operator</code> n’a qu’un accès en lecture. Cela se fait en ajoutant les lignes suivantes au fichier <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path uscanner0 mode 660</pre></div></div><div class=paragraph><p>Ajoutez ensuite ce qui suit au fichier <span class=filename>/etc/rc.conf</span> et redémarrez la machine:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Plus d’information concernant ces lignes peut être trouvée dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bien sûr, pour des raisons de sécurité, vous devriez réfléchir à deux fois avant d’ajouter un utilisateur à n’importe quel groupe, tout particulièrement au groupe <code>operator</code>.</p></div></td></tr></tbody></table></div></div></div></div></div><div class=sect1><h2 id=kernelconfig>Chapitre 8. Configurer le noyau de FreeBSD<a class=anchor href=#kernelconfig></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelconfig-synopsis>8.1. Synopsis<a class=anchor href=#kernelconfig-synopsis></a></h3><div class=paragraph><p>Le noyau est le coeur du système d’exploitation FreeBSD. Il est responsable de la gestion de la mémoire, de la mise en application des contrôles de sécurité, du réseau, des accès disque, et bien plus. Bien que FreeBSD devienne de plus en plus configurable dynamiquement, il est toujours nécessaire occasionnellement de reconfigurer et recompiler votre noyau.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Pourquoi vous pourriez avoir besoin de compiler un noyau sur mesure.</p></li><li><p>Comment écrire un fichier de configuration du noyau, ou modifier un fichier de configuration existant.</p></li><li><p>Comment utiliser le fichier de configuration du noyau pour créer et recompiler un nouveau noyau.</p></li><li><p>Comment installer un nouveau noyau.</p></li><li><p>Que faire si quelque chose se passe mal.</p></li></ul></div><div class=paragraph><p>Toutes les commandes listées dans les exemples de ce chapitre doivent être exécutées en tant que <code>root</code> afin de fonctionner.</p></div></div><div class=sect2><h3 id=kernelconfig-custom-kernel>8.2. Pourquoi compiler un noyau sur mesure?<a class=anchor href=#kernelconfig-custom-kernel></a></h3><div class=paragraph><p>Traditionnellement, FreeBSD a eu ce qui s’appelle un noyau "monolithique". Cela signifie que le noyau était un gros programme, supportant une liste figée de périphériques, et si vous vouliez modifier le comportement du noyau alors vous deviez compiler un nouveau noyau, et ensuite redémarrer votre ordinateur avec le nouveau noyau.</p></div><div class=paragraph><p>Aujourd’hui, FreeBSD s’oriente rapidement vers un modèle où une grande partie des fonctions du noyau est contenue dans des modules qui peuvent être dynamiquement chargés et déchargés si nécessaire. Cela permet au noyau de s’adapter au nouveau matériel devenant soudainement disponible (comme les cartes PCMCIA dans un ordinateur portable), ou pour qu’une nouvelle fonctionnalité qui n’était pas nécessaire lors de la compilation du noyau y soit intégrée. On appelle cela un noyau modulaire.</p></div><div class=paragraph><p>En dépit de cela, il est encore nécessaire d’effectuer certaines configurations de noyau en statique. Dans certains cas c’est parce que la fonctionnalité est si proche du noyau qu’elle ne peut être rendue dynamiquement chargeable. Dans d’autres cas, cela peut tout simplement venir du fait que personne n’a encore pris le temps d’écrire un module dynamiquement chargeable pour cette fonctionnalité.</p></div><div class=paragraph><p>Compiler un noyau sur mesure est l’un des plus importants rites de passage que doit endurer tout utilisateur BSD. Cette opération, tout en prenant du temps, apportera de nombreuses améliorations à votre système FreeBSD. A la différence du noyau <span class=filename>GENERIC</span>, qui doit supporter une large gamme de matériels, un noyau sur mesure ne contient que le support pour <em>votre</em> configuration matérielle. Cela a de nombreux avantages, comme:</p></div><div class=ulist><ul><li><p>Un temps de démarrage plus court. Comme le noyau ne recherchera que le matériel présent sur votre système, le temps nécessaire au démarrage de votre système peut diminuer de façon importante.</p></li><li><p>Une utilisation plus faible de la mémoire. Un noyau sur mesure utilise souvent moins de mémoire que le noyau <span class=filename>GENERIC</span>, ce qui est important car le noyau doit toujours résider en mémoire. Pour cette raison, un noyau sur mesure est tout particulièrement utile sur un système dont les ressources mémoire sont limitées.</p></li><li><p>Le support de matériels supplémentaires. Un noyau sur mesure vous permet d’intégrer le support pour des périphériques, qui ne sont pas présents dans le noyau <span class=filename>GENERIC</span> comme les cartes son.</p></li></ul></div></div><div class=sect2><h3 id=kernelconfig-building>8.3. Compiler et installer un noyau sur mesure<a class=anchor href=#kernelconfig-building></a></h3><div class=paragraph><p>Commençons par passer rapidement en revue le répertoire de configuration du noyau. Tous les chemins d’accès mentionnés seront relatifs au répertoire principal <span class=filename>/usr/src/sys</span>, qui est également accessible via le lien symbolique <span class=filename>/sys</span>. Il comporte un certain nombre de sous-répertoires correspondants à différentes parties du noyau, mais les plus importantes, en ce qui nous concerne, sont <span class=filename>arch/conf</span>, où vous éditerez votre fichier configuration personnalisé, et <span class=filename>compile</span>, qui est l’espace de travail où votre noyau sera compilé. <em>arch</em> représente une des architectures suivante: <span class=filename>i386</span>, soit <span class=filename>alpha</span>, <span class=filename>amd64</span>, <span class=filename>ia64</span>, <span class=filename>powerpc</span>, <span class=filename>sparc64</span>, ou encore <span class=filename>pc98</span> (une branche alternative de développement de l’architecture PC, populaire au Japon). Tout ce qui se trouve dans un répertoire particulier à une architecture est propre uniquement à cette architecture; le reste du code est un code indépendant du type de machine et commun à toutes les plates-formes sur lesquelles FreeBSD pourrait être potentiellement porté. Remarquez l’organisation logique de l’arborescence des répertoires, où chaque périphérique, système de fichiers, et option supportés a son propre sous-répertoire.</p></div><div class=paragraph><p>Les exemples de ce chapitre supposent que vous utilisez l’architecture i386. Si ce n’est pas votre cas, effectuez les ajustements appropriés au niveau des chemins d’accès pour votre architecture.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>S’il n’y a <em>pas</em> de répertoire <span class=filename>/usr/src/sys</span> sur votre système, alors c’est que les sources du noyau n’ont pas été installées. La manière la plus facile de les installer est d’exécuter <code>sysinstall</code> en tant que <code>root</code>, et sélectionner <span class=guimenuitem>Configure</span>, puis <span class=guimenuitem>Distributions</span>, <span class=guimenuitem>src</span>, puis <span class=guimenuitem>base</span> et <span class=guimenuitem>sys</span>. Si vous avez une aversion envers sysinstall et que vous disposez d’un CDROM "officiel" de FreeBSD, alors vous pouvez installer les sources depuis la ligne de commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># mkdir -p /usr/src/sys</span>
<span class=c># ln -s /usr/src/sys /sys</span>
<span class=c># cat /cdrom/src/ssys.[a-d]* | tar -xzvf -</span>
<span class=c># cat /cdrom/src/sbase.[a-d]* | tar -xzvf -</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Ensuite allez dans le répertoire <span class=filename>arch/conf</span> et copiez le fichier de configuration <span class=filename>GENERIC</span> dans un fichier qui portera le nom que vous voulez donner à votre noyau. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf</span>
<span class=c># cp GENERIC MONNOYAU</span></code></pre></div></div><div class=paragraph><p>Par tradition, c’est un nom en majuscules, et si vous maintenez plusieurs machines FreeBSD avec des configurations matérielles différentes, c’est une bonne idée de lui donner le même nom que la machine. Nous l’appellerons <span class=filename>MONNOYAU</span> pour les besoins de cet exemple.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Conserver votre fichier de configuration du noyau directement sous <span class=filename>/usr/src</span> peut être une mauvaise idée. Si vous avez des problèmes il peut être tentant de juste effacer <span class=filename>/usr/src</span> et recommencer à nouveau. Après avoir fait cela ne prends que quelques secondes pour vous rendre compte que vous venez d’effacer votre fichier de configuration du noyau personnalisé. N’éditez pas, non plus, directement le fichier <span class=filename>GENERIC</span>, il peut être écrasé à la prochaine <a href=./#updating-upgrading>mise à jour de l’arborescence des sources</a>, et vos modifications seraient perdues.</p></div><div class=paragraph><p>Vous voudrez peut être conserver votre fichier de configuration du noyau ailleurs et alors créer un lien symbolique vers le fichier dans le répertoire <span class=filename>i386</span>.</p></div><div class=paragraph><p>Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf</span>
<span class=c># mkdir /root/noyaux</span>
<span class=c># cp GENERIC /root/noyaux/MONNOYAU</span>
<span class=c># ln -s /root/noyaux/MONNOYAU</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Editez maintenant <span class=filename>MONNOYAU</span> avec votre éditeur de texte préféré. Si vous venez tout juste de finir l’installation, le seul éditeur disponible sera probablement vi, qui est trop complexe pour être décrit ici, mais est bien expliqué dans de nombreux ouvrages de la <a href=./#bibliography>bibliographie</a>. Cependant, FreeBSD offre un éditeur plus simple appelé ee qui, si vous êtes débutant, sera votre éditeur de choix. N’hésitez pas à modifier les commentaires d’entête pour y décrire votre configuration ou les modifications que vous avez apportés par rapport au noyau <span class=filename>GENERIC</span>.</p></div><div class=paragraph><p>Si vous avez déjà compilé un noyau sur SunOS™ ou tout autre système d’exploitation BSD, l’essentiel de fichier vous sera familier. Si vous venez d’un système d’exploitation comme DOS, à l’inverse, le fichier de configuration <span class=filename>GENERIC</span> vous paraîtra inintelligible, lisez alors lentement et attentivement la section sur <a href=#kernelconfig-config>le fichier de configuration</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous <a href=./#updating-upgrading>synchronisez votre arborescence des sources</a> avec les toutes dernières sources du projet FreeBSD, assurez-vous de toujours lire le fichier <span class=filename>/usr/src/UPDATING</span> avant d’effectuer une quelconque opération de mise à jour. Ce fichier décrit les problèmes importants ou les domaines demandant une attention particulière dans le code mis à jour. <span class=filename>/usr/src/UPDATING</span> correspond toujours à votre version des sources de FreeBSD, et est donc plus à jour que ce Manuel.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Vous devez maintenant compiler le code source du noyau.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Compiler un noya</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Passez dans le répertoire <span class=filename>/usr/src</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>Compilez le noyau:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MONNOYAU</span></code></pre></div></div></li><li><p>Installez le nouveau noyau:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MONNOYAU</span></code></pre></div></div></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il est indispensable d’avoir l’intégralité des sources du système FreeBSD pour compiler le noyau.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Par défaut, quand vous compilez un noyau personnalisé, <em>tous</em> les modules seront également recompilés. Si vous désirez mettre à jour un noyau plus rapidement ou compiler que certains modules, vous devez éditer le fichier <span class=filename>/etc/make.conf</span> avant de compiler le noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</pre></div></div><div class=paragraph><p>Cette variable définit une liste de modules à compiler à la place de l’intégralité des modules.</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs</pre></div></div><div class=paragraph><p>Cette variable définit une liste de modules à exclure du processus de compilation. Pour d’autres variables qui peuvent être intéressantes pour le processus de compilation du noyau, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le nouveau noyau sera copié dans le répertoire <span class=filename>/boot/kernel</span> avec le nom <span class=filename>/boot/kernel/kernel</span> et l’ancien noyau sera renommé en <span class=filename>/boot/kernel.old/kernel</span>. Maintenant, arrêtez le système et redémarrez pour utiliser votre nouveau noyau. Si quelque chose se passe mal, il y a quelques instructions de <a href=#kernelconfig-trouble>dépannage</a> à la fin de ce chapitre que vous pourrez trouver utiles. Assurez-vous de lire la section qui explique comment revenir en arrière dans le cas où votre nouveau noyau <a href=#kernelconfig-noboot>ne démarre pas</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les autres fichiers concernant le processus de démarrage, comme le chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) et la configuration du démarrage sont conservés dans le répertoire <span class=filename>/boot</span>. Les modules tiers et personnalisés peuvent être placés dans <span class=filename>/boot/kernel</span>, bien que les utilisateurs doivent être conscients que garder ses modules synchronisés avec le noyau compilé est très important. Les modules qui ne sont pas destinés à fonctionner avec le noyau compilé peuvent être instables et ne pas donner les résultats escomptés.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-config>8.4. Le fichier de configuration<a class=anchor href=#kernelconfig-config></a></h3><div class=paragraph><p>Le format général du fichier de configuration est assez simple. Chaque ligne est composée d’un mot-clé et d’un ou plusieurs arguments. Pour simplifier, la plupart des lignes ne contiennent qu’un seul argument. Tout ce qui suit le caractère <code>#</code> est considéré comme un commentaire et ignoré. Les sections suivantes décrivent chaque mot-clé, dans l’ordre où ils apparaissent dans le fichier <span class=filename>GENERIC</span>. <a id=kernelconfig-options></a>Pour une liste exhaustive des options et périphériques dépendants de l’architecture utilisée, consultez le fichier <span class=filename>NOTES</span> présent dans le même répertoire que le fichier <span class=filename>GENERIC</span>. Pour les options ne dépendant pas de l’architecture, consultez le fichier <span class=filename>/usr/src/sys/conf/NOTES</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour compiler un fichier contenant toutes les options possibles, en général pour effectuer des tests, exécutez la commande suivante en tant que <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf  make LINT</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Ce qui suit est un exemple de fichier de configuration du noyau <span class=filename>GENERIC</span> avec divers commentaires aux endroits nécessaires pour un peu plus de clarté. Cet exemple devrait correspondre de façon très proche à votre copie du fichier <span class=filename>/usr/src/sys/i386/conf/GENERIC</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>machine		i386</pre></div></div><div class=paragraph><p>C’est l’architecture de la machine. Elle doit être <code>alpha</code>, <code>amd64</code>, <code>i386</code>, <code>ia64</code>, <code>pc98</code>, <code>powerpc</code>, ou encore <code>sparc64</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</pre></div></div><div class=paragraph><p>Ce qui précède définit le type de CPU présent dans votre système. Il peut y avoir plusieurs occurrences de la ligne CPU (si, par exemple, vous n’êtes pas sûr de devoir utiliser <code>I586_CPU</code> ou <code>I686_CPU</code>), cependant, pour un noyau personnalisé, il est mieux de spécifier uniquement le CPU que vous avez. Si vous n’êtes pas sûr du type, vous pouvez lister le fichier <span class=filename>/var/run/dmesg.boot</span> pour visualiser les messages de démarrage.</p></div><div class="literalblock programlisting"><div class=content><pre>ident          GENERIC</pre></div></div><div class=paragraph><p>C’est l’identification du noyau. Vous devriez changer cela pour le nom, quel qu’il soit, que vous donnez à votre noyau, par exemple <code>MONNOYAU</code> si vous avez suivi les instructions des exemples précédents. La valeur que vous donnez à la chaîne <code>ident</code> s’affichera au démarrage du noyau, il est donc utile de donner au nouveau noyau un nom différent si vous voulez le différencier de votre noyau habituel (e.g., vous voulez compiler un noyau expérimental).</p></div><div class="literalblock programlisting"><div class=content><pre>#To statically compile in device wiring instead of /boot/device.hints
#hints          &#34;GENERIC.hints&#34;         #Default places to look for devices.</pre></div></div><div class=paragraph><p>Le fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> est utilisé pour configurer les paramètres des pilotes de périphériques. Le <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> recherchera le fichier <span class=filename>/boot/device.hints</span> au démarrage. En utilisant l’option <code>hints</code> vous pouvez compiler ces valeurs en statique dans votre noyau. Il n’est alors pas utile de créer de fichier <span class=filename>device.hints</span> dans <span class=filename>/boot</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions     DEBUG=-g          #Build kernel with gdb(1) debug symbols</pre></div></div><div class=paragraph><p>Le processus normal de compilation de FreeBSD inclut les informations de débogage lors de la compilation du noyau avec l’option <code>-g</code>, qui autorisera les informations de débogage quand le noyau sera passé à <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SCHED_4BSD         # 4BSD scheduler</pre></div></div><div class=paragraph><p>L’ordonnanceur ("scheduler") traditionnel et par défaut de FreeBSD. Conservez cette ligne.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PREEMPTION         # Enable kernel thread preemption</pre></div></div><div class=paragraph><p>Permet aux processus légers présents dans le noyau d’être devancés par des processus de priorité plus élevée. Cela améliore l’interactivité et permet aux processus d’interruption d’être exécutés le plus tôt possible au lieu d’attendre leur tour.</p></div><div class="literalblock programlisting"><div class=content><pre>options          INET          #InterNETworking</pre></div></div><div class=paragraph><p>Support réseau. Conservez-le, même si vous n’envisagez pas de vous connecter à un réseau. La plupart des programmes utilisent le réseau "en boucle" (i.e., établissent des connexions réseau avec le PC lui-même), cette option est donc quasiment obligatoire.</p></div><div class="literalblock programlisting"><div class=content><pre>options          INET6          #IPv6 communications protocols</pre></div></div><div class=paragraph><p>Ceci active les protocoles de communication IPv6.</p></div><div class="literalblock programlisting"><div class=content><pre>options          FFS          #Berkeley Fast Filesystem</pre></div></div><div class=paragraph><p>C’est le système de fichiers de base sur disque dur. Gardez ces options si vous démarrez depuis le disque dur.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SOFTUPDATES  #Enable FFS Soft Updates support</pre></div></div><div class=paragraph><p>Cette option rajoutera le support des "Soft Updates" dans le noyau, ce qui aidera l’accélération des accès en écriture sur les disques. Même quand cette fonction est fournit par le noyau, elle doit être activée sur chaque disque. Regardez le résultat de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> pour voir si les "Soft Updates" sont activées sur les disques de votre système. Si vous ne voyez pas apparaître l’option <code>soft-updates</code> alors vous devrez l’activer en utilisant les commandes <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> (pour les systèmes de fichiers existant) ou <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> (pour les nouveaux systèmes de fichiers).</p></div><div class="literalblock programlisting"><div class=content><pre>options          UFS_ACL      #Support for access control lists</pre></div></div><div class=paragraph><p>Cette option active le support des listes de contrôle d’accès au système de fichiers (ACL). Elles reposent sur l’utilisation d’attributs étendus et d’UFS2, cette fonctionnalité est décrite dans la <a href=./#fs-acl>Listes de contrôle d’accès au système de fichiers</a>. Les ACLs sont activées par défaut, et leur support ne devraient pas être retiré du noyau si elles ont été précédemment utilisées sur un système de fichiers, étant donné que cela supprimera les listes de contrôle d’accès changeant alors la façon dont sont protégés les fichiers d’une manière imprévisible.</p></div><div class="literalblock programlisting"><div class=content><pre>options          UFS_DIRHASH  #Improve performance on big directories</pre></div></div><div class=paragraph><p>Cette option inclut certaines fonctions pour accélérer les opérations disque sur de gros répertoires, aux dépens d’employer de la mémoire supplémentaire. Vous conserverez normalement cela pour un gros serveur, ou une station de travail très active, et vous l’enlèverez si vous utilisez FreeBSD sur un petit système où la mémoire prime et la vitesse d’accès disque est moins importante, comme pour un coupe-feu.</p></div><div class="literalblock programlisting"><div class=content><pre>options          MD_ROOT      #MD is a potential root device</pre></div></div><div class=paragraph><p>Cette option active le support pour des disques virtuels en mémoire utilisés comme périphérique racine.</p></div><div class="literalblock programlisting"><div class=content><pre>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</pre></div></div><div class=paragraph><p>Le système de fichiers réseau. A moins que vous n’envisagiez de monter des partitions d’un serveur de fichiers UNIX® par l’intermédiaire d’un réseau TCP/IP, vous pouvez mettre en commentaire ces options.</p></div><div class="literalblock programlisting"><div class=content><pre>options          MSDOSFS      #MSDOS Filesystem</pre></div></div><div class=paragraph><p>Le système de fichiers MS-DOS®. A moins que vous n’envisagiez de monter une partition DOS d’un disque dur au démarrage, vous pouvez sans risque commenter cette option. Le module sera automatiquement chargé la première fois que vous monterez une partition DOS, comme décrit plus haut. Par ailleurs, l’excellent logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> vous permet d’accéder à des disquettes DOS sans avoir besoin de les monter (et ne requiert pas non plus <code>MSDOSFS</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>options          CD9660       #ISO 9660 Filesystem</pre></div></div><div class=paragraph><p>Le système de fichiers ISO 9660 pour les CDROMs. Commentez ces options si vous n’avez pas de lecteur de CDROM ou que vous ne montez qu’occasionnellement des CDROMs (il sera chargé dynamiquement dès que vous monterez un CDROM). Les CDROMs audios n’ont pas besoin de ce système de fichiers.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PROCFS            # Process filesystem (requires PSEUDOFS)</pre></div></div><div class=paragraph><p>Le système de fichiers pour les processus. C’est un "pseudo-système" de fichiers monté sur <span class=filename>/proc</span> qui permet à des programmes comme <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> de vous fournir plus d’informations sur les processus qui tournent sur le système. L’utilisation de <code>PROCFS</code> n’est pas nécessaire la plupart du temps, comme la majeur partie des outils de débogage et de monitoring ont été adaptés pour s’exécuter sans <code>PROCFS</code>: les nouvelles installations ne monteront pas par défaut ce système de fichiers.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PSEUDOFS     #Pseudo-filesystem framework</pre></div></div><div class=paragraph><p>Les noyaux 6.X faisant usage du système <code>PROCFS</code> doivent également inclure le support pour <code>PSEUDOFS</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          GEOM_GPT          # GUID Partition Tables.</pre></div></div><div class=paragraph><p>Cette option apporte la possibilité d’avoir un grand nombre de partitions sur un seul disque.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_43    #Compatible with BSD 4.3 [KEEP THIS!]</pre></div></div><div class=paragraph><p>Compatibilité avec 4.3BSD. Conservez cette option; certains programmes auront un comportement bizarre si vous la commentez.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD4     #Compatible with FreeBSD4</pre></div></div><div class=paragraph><p>Cette option est nécessaires aux systèmes i386™ et Alpha fonctionnant sous FreeBSD 5.X pour supporter les applications compilées sur d’anciennes version de FreeBSD qui utilisent d’anciennes interfaces d’appel système. Il est recommandé d’utiliser cette option sur tous les systèmes i386™ et Alpha susceptibles d’exécuter d’anciennes applications; les plateformes apparues sous FreeBSD 5.0, comme l’ia64 et sparc64, n’ont pas besoin de cette option.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD5   # Compatible with FreeBSD5</pre></div></div><div class=paragraph><p>Cette option est nécessaire sous FreeBSD 6.X et versions supérieures pour supporter les applications compilées sous FreeBSD 5.X et qui utilisent les interfaces d’appel système FreeBSD 5.X.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SCSI_DELAY=5000    #Delay (in ms) before probing SCSI</pre></div></div><div class=paragraph><p>Cette option oblige le noyau à attendre 5 secondes avant de rechercher les périphériques SCSI présents sur votre système. Si vous n’avez que des disques IDE, vous pouvez l’ignorer, sinon vous pouvez essayer de diminuer cette valeur, pour accélérer le démarrage du système. Bien sûr, si vous le faites, et que FreeBSD a du mal à reconnaître vos périphériques SCSI, vous devrez l’augmenter à nouveau.</p></div><div class="literalblock programlisting"><div class=content><pre>options          KTRACE              #ktrace(1) support</pre></div></div><div class=paragraph><p>Ceci permet de tracer le processus du noyau, ce qui est utile pour le débogage.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVSHM             #SYSV-style shared memory</pre></div></div><div class=paragraph><p>Cette option implémente la mémoire partagée System V. L’usage le plus courant qui en est fait est l’extension XSHM d’X, dont de nombreux logiciels gourmants en graphique tireront automatiquement parti pour fonctionner plus vite. Si vous utilisez X, vous utiliserez absolument cette option.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVMSG             #SYSV-style message queues</pre></div></div><div class=paragraph><p>Support des messages System V. Cette option n’augmente que de quelques centaines d’octets la taille du noyau.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVSEM             #SYSV-style semaphores</pre></div></div><div class=paragraph><p>Support des sémaphores System V. D’un usage moins courant, mais n’augmente la taille du noyau que de quelques centaines d’octets.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’option <code>-p</code> de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ipcs&amp;sektion=1&amp;format=html">ipcs(1)</a> donnera la liste des processus utilisant chacun de ces mécanismes System V.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</pre></div></div><div class=paragraph><p>Extensions temps-réel ajoutées dans la norme POSIX® 1993. Certaines applications du catalogue des logiciels portés les utilisent (comme StarOffice™).</p></div><div class="literalblock programlisting"><div class=content><pre>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</pre></div></div><div class=paragraph><p>Cette option concerne le clavier. Elle installe une entrée CDEV dans le répertoire <span class=filename>/dev</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</pre></div></div><div class=paragraph><p>"Giant" est le nom d’un mécanisme d’exclusion mutuelle (un "mutex" dormant) qui protège l’accès à un ensemble important de ressources du noyau. Aujourd’hui c’est un goulot d’étranglement des performances inacceptable que l’on est en train de remplacer activement par des verrous qui protègent les ressources individuelles. L’option <code>ADAPTIVE_GIANT</code> permet à Giant d’être inclus dans l’ensemble des mutex lancés de manière adaptative. C’est à dire, quand un thread désire verrouiller le mutex Giant, mais que ce dernier est déjà verrouillé par un thread sur un autre CPU, le premier thread continuera à fonctionner et attendra la libération du verrou. Normalement, le thread retournera à l’état dormant et attendra une nouvelle chance de pouvoir s’exécuter. Si vous n’êtes pas sûr, laissez la configuration en l’état.</p></div><div class="literalblock programlisting"><div class=content><pre>device          apic               # I/O APIC</pre></div></div><div class=paragraph><p>Le périphérique apic active l’utilisation de l’E/S APIC pour l’acheminement des interruptions. Le périphérique apic peut être utilisé dans les noyaux UP (monoprocesseur) et SMP, mais est requis pour les noyaux SMP. Ajoutez <code>options SMP</code> pour inclure le support pour plusieurs processeurs.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le périphérique apic n’existe que sur l’architecture i386, cette ligne de configuration ne doit pas être utilisée sur d’autres architectures.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          eisa</pre></div></div><div class=paragraph><p>Rajoutez cela si vous avez une carte mère EISA. Cela permet l’auto-détection et la configuration de tous les périphériques présents sur le bus EISA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          pci</pre></div></div><div class=paragraph><p>Ajoutez cette option si vous avez une carte mère PCI. Cela permet l’auto-détection des cartes PCI et gère l’interface entre les bus PCI et ISA.</p></div><div class="literalblock programlisting"><div class=content><pre># Floppy drives
device          fdc</pre></div></div><div class=paragraph><p>C’est le contrôleur de lecteur de disquettes.</p></div><div class="literalblock programlisting"><div class=content><pre># ATA and ATAPI devices
device          ata</pre></div></div><div class=paragraph><p>Ce pilote supporte tous les périphériques ATA et ATAPI. Vous n’avez besoin que d’une seule ligne <code>device ata</code> pour que le noyau détecte tous les périphériques PCI ATA/ATAPI sur les machines modernes.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atadisk                 # ATA disk drives</pre></div></div><div class=paragraph><p>Ceci est requis avec <code>device ata</code> pour les disques ATA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ataraid                 # ATA RAID drives</pre></div></div><div class=paragraph><p>Ceci est nécessaire avec <code>device ata</code> pour les disques RAID ATA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapicd                 # ATAPI CDROM drives</pre></div></div><div class=paragraph><p>Ceci est nécessaire avec <code>device ata</code> pour le support des lecteurs de CDROM ATAPI.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapifd                 # ATAPI floppy drives</pre></div></div><div class=paragraph><p>Ceci est nécessaire avec <code>device ata</code> pour le support des lecteurs de disquettes ATAPI.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapist                 # ATAPI tape drives</pre></div></div><div class=paragraph><p>Ceci est nécessaire avec <code>device ata</code> pour le support des lecteurs de bande ATAPI.</p></div><div class="literalblock programlisting"><div class=content><pre>options         ATA_STATIC_ID           #Static device numbering</pre></div></div><div class=paragraph><p>Cela rend la numérotation des périphériques statique, sans cela l’allocation des numéros de périphériques sera dynamique.</p></div><div class="literalblock programlisting"><div class=content><pre># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr&#39;)
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</pre></div></div><div class=paragraph><p>Contrôleurs SCSI. Mettez en commentaires ceux que vous n’avez pas sur votre système. Si vous n’avez qu’un système IDE, vous pouvez supprimer toutes ces lignes. Les lignes <code>*_REG_PRETTY_PRINT</code> sont des options de débogage pour leur pilote respectif.</p></div><div class="literalblock programlisting"><div class=content><pre># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</pre></div></div><div class=paragraph><p>Périphériques SCSI. A nouveau, mettez en commentaires tous ceux que vous n’avez pas, ou si vous n’avez que du matériel IDE, vous pouvez tous les supprimer.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le pilote USB <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> et quelques autres pilotes utilisent le sous-système SCSI même si ce ne sont pas de véritables périphériques SCSI. Par conséquent assurez-vous de ne pas retirer le support SCSI si un tel pilote fait partie de la configuration du noyau.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</pre></div></div><div class=paragraph><p>Contrôleurs RAID supportés. Si vous n’avez aucun de ces derniers dans votre système, vous pouvez les mettre en commentaires ou les supprimer.</p></div><div class="literalblock programlisting"><div class=content><pre># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</pre></div></div><div class=paragraph><p>Le contrôleur du clavier (<code>atkbdc</code>) permet de gérer les E/S du clavier AT et des périphériques de pointage PS/2. Ce contrôleur est nécessaire au pilote de périphérique du clavier (<code>atkbd</code>) et celui des périphériques de pointage PS/2 (<code>psm</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>device          atkbd      # AT keyboard</pre></div></div><div class=paragraph><p>Le pilote de périphérique <code>atkbd</code>, associé au contrôleur <code>atkbdc</code>, fournit un accès au clavier AT 84 touches ou au clavier AT étendu qui est connecté au contrôleur de clavier de la machine.</p></div><div class="literalblock programlisting"><div class=content><pre>device          psm        # PS/2 mouse</pre></div></div><div class=paragraph><p>Utilisez ce périphérique si votre souris se branche sur le port PS/2.</p></div><div class="literalblock programlisting"><div class=content><pre>device          kbdmux        # keyboard multiplexer</pre></div></div><div class=paragraph><p>Support de base pour le multiplexage de claviers. Si vous n’avez pas l’intention d’utiliser sur le système plus d’un clavier, vous pouvez supprimer cette ligne sans risque.</p></div><div class="literalblock programlisting"><div class=content><pre>device          vga        # VGA video card driver</pre></div></div><div class=paragraph><p>Pilote de la carte graphique.</p></div><div class="literalblock programlisting"><div class=content><pre>device          splash     # Splash screen and screen saver support</pre></div></div><div class=paragraph><p>Ecran/bannière de démarrage. Les économiseurs d’écran ont également besoin de ce pseudo-périphérique.</p></div><div class="literalblock programlisting"><div class=content><pre># syscons is the default console driver, resembling an SCO console
device          sc</pre></div></div><div class=paragraph><p><code>sc</code> est le pilote par défaut pour la console, qui ressemble à une console SCO. Comme la plupart des programmes en mode plein-écran accèdent à la console par l’intermédiaire d’une base de données de description des terminaux comme <span class=filename>termcap</span>, cela n’a guère d’importance que vous choisissiez ce pilote ou <code>vt</code>, le pilote compatible <code>VT220</code>. Quand vous ouvrez une session, positionnez votre variable d’environnement <code>TERM</code> à <code>scoansi</code> si vous avez des problèmes pour utiliser des programmes en mode plein-écran avec cette console.</p></div><div class="literalblock programlisting"><div class=content><pre># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</pre></div></div><div class=paragraph><p>C’est le pilote de console compatible VT220, et, rétrospectivement, compatible VT100/102. Il fonctionne bien sur certains ordinateurs portables qui sont matériellement incompatibles avec le pilote <code>sc</code>. Comme précédemment, positionnez la variable d’environnement <code>TERM</code> lorsque que vous ouvrez une session, mais cette fois-ci à <code>vt100</code> ou <code>vt220</code>. Ce pilote peut aussi s’avérer utile quand vous vous connectez à un grand nombre de machines différentes par le réseau sur lesquelles les entrées pour le périphérique <code>sc</code> ne sont souvent pas définies dans leurs fichiers <span class=filename>termcap</span> ou <span class=filename>terminfo</span> - alors que le terminal <code>vt100</code> devrait être disponible sur pratiquement toutes les plates-formes.</p></div><div class="literalblock programlisting"><div class=content><pre>device          agp</pre></div></div><div class=paragraph><p>Ajoutez cette option si vous avez une carte AGP dans votre système. Cela activera le support AGP, et l’AGP GART pour les cartes qui ont cette fonction.</p></div><div class="literalblock programlisting"><div class=content><pre># Power management support (see NOTES for more options)
device          apm</pre></div></div><div class=paragraph><p>"Advanced Power Management support" - gestion avancée de l’énergie. Utile pour les ordinateurs portables, ceci est cependant désactivé par défaut dans le noyau <span class=filename>GENERIC</span> sous FreeBSD 5.X et versions suivantes</p></div><div class="literalblock programlisting"><div class=content><pre># Add suspend/resume support for the i8254.
device           pmtimer</pre></div></div><div class=paragraph><p>Pilote du périphérique de gestion du temps pour les événements de la gestion de l’énergie, comme l’APM ou l’ACPI.</p></div><div class="literalblock programlisting"><div class=content><pre># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</pre></div></div><div class=paragraph><p>Support PCMCIA. Vous en avez besoin si vous utilisez un ordinateur portable.</p></div><div class="literalblock programlisting"><div class=content><pre># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</pre></div></div><div class=paragraph><p>Cela représente les ports séries, appelés ports <span class=filename>COM</span> dans le monde MS-DOS®/Windows®.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous avez un modem interne sur le port <span class=filename>COM4</span> et un port série <span class=filename>COM2</span>, vous devrez changer l’IRQ du modem en 2 (pour d’obscures raisons techniques, IRQ 2 = IRQ 9) pour y accéder avec FreeBSD. Si vous avez une carte série multi-ports, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> pour plus d’informations sur les bonnes valeurs à ajouter à votre fichier <span class=filename>/boot/device.hints</span>. Certaines cartes vidéo (notamment celle à base de circuits S3) utilisent des adresses d’E/S sous la forme <code>0x*2e8</code>, et comme de nombreuses cartes séries bon marché de décodent pas complètement l’espace d’adresse d’E/S 16 bits, il y a aura des conflits avec ces cartes, rendant le port <span class=filename>COM4</span> pratiquement inutilisable.</p></div><div class=paragraph><p>Chaque port série doit avoir une IRQ unique (à moins que vous n’utilisiez une carte multi-ports qui autorise le partage d’interruption), donc les IRQs par défaut pour les ports <span class=filename>COM3</span> et <span class=filename>COM4</span> ne peuvent être utilisées.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Parallel port
device          ppc</pre></div></div><div class=paragraph><p>C’est l’interface parallèle du bus ISA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ppbus      # Parallel port bus (required)</pre></div></div><div class=paragraph><p>Fournit le support pour le bus du port parallèle.</p></div><div class="literalblock programlisting"><div class=content><pre>device          lpt        # Printer</pre></div></div><div class=paragraph><p>Support pour les imprimantes parallèles.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les trois lignes précédentes sont nécessaires pour permettre le support des imprimantes parallèles.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          plip       # TCP/IP over parallel</pre></div></div><div class=paragraph><p>C’est le pilote pour l’interface réseau sur port parallèle.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ppi        # Parallel port interface device</pre></div></div><div class=paragraph><p>Port d’E/S d’usage général ("geek port") + port d’E/S IEEE1284.</p></div><div class="literalblock programlisting"><div class=content><pre>#device         vpo        # Requires scbus and da</pre></div></div><div class=paragraph><p>Ceci est pour le lecteur Zip de Iomega. Les options <code>scbus</code> et <code>da</code> sont également requises. Les meilleures performances sont obtenues avec les ports configurés dans le mode EPP 1.9.</p></div><div class="literalblock programlisting"><div class=content><pre>#device         puc</pre></div></div><div class=paragraph><p>Décommentez ce périphérique si vous disposez d’une carte PCI série ou parallèle "idiote" qui est supportée par le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=puc&amp;sektion=4&amp;format=html">puc(4)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (Tulip)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (Typhoon)
device          vx         # 3Com 3c590, 3c595 (Vortex)</pre></div></div><div class=paragraph><p>Divers pilotes de cartes réseaux PCI. Mettez en commentaires ou supprimer les lignes de celles qui ne sont pas présentes sur votre système.</p></div><div class="literalblock programlisting"><div class=content><pre># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the &#39;device miibus&#39; line in order to use these NICs!
device          miibus     # MII bus support</pre></div></div><div class=paragraph><p>Le support du bus MII est nécessaire pour certaines cartes Ethernet PCI 10/100, à savoir celles qui utilisent des interfaces compatibles MII ou implémentent une gestion de l’interface opérant comme le bus MII. Ajouter <code>device miibus</code> à la configuration du noyau intègre le support pour l’API miibus générique et tous les pilotes d’interfaces PHY, incluant un pilote générique pour les interfaces PHYs qui ne sont pas spécifiquements gérées par un pilote individuel.</p></div><div class="literalblock programlisting"><div class=content><pre>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over &#39;lnc&#39;)
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (Starfire)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x  SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 EPIC)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (Boomerang, Cyclone)</pre></div></div><div class=paragraph><p>Pilotes qui utilisent le code du contrôleur du bus MII.</p></div><div class="literalblock programlisting"><div class=content><pre># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# &#39;device ed&#39; requires &#39;device miibus&#39;
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC&#39;s 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</pre></div></div><div class=paragraph><p>Pilotes pour les cartes Ethernet ISA. Consultez le fichier <span class=filename>/usr/src/sys/i386/conf/NOTES</span> pour savoir quelles cartes sont supportées et par quel pilote.</p></div><div class="literalblock programlisting"><div class=content><pre># Wireless NIC cards
device          wlan            # 802.11 support</pre></div></div><div class=paragraph><p>Support 802.11 générique. Cette ligne est nécessaire pour le réseau sans fil.</p></div><div class="literalblock programlisting"><div class=content><pre>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</pre></div></div><div class=paragraph><p>Support pour le chiffrage pour les périphériques 802.11. Ces lignes sont nécessaires si vous avez l’intention d’utiliser le chiffrage et les protocoles de sécurité 802.11i.</p></div><div class="literalblock programlisting"><div class=content><pre>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC&#39;s
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</pre></div></div><div class=paragraph><p>Support pour diverses cartes réseau sans fil.</p></div><div class="literalblock programlisting"><div class=content><pre># Pseudo devices
device   loop          # Network loopback</pre></div></div><div class=paragraph><p>C’est l’interface générique en boucle de TCP/IP. Si vous employez telnet ou FTP sur <code>localhost</code> (aussi connu en tant qu’adresse <code>127.0.0.1</code>) la réponse vous parviendra via ce pseudo-périphérique. Ceci est <em>obligatoire</em>.</p></div><div class="literalblock programlisting"><div class=content><pre>device   random        # Entropy device</pre></div></div><div class=paragraph><p>Générateur de nombres aléatoire sécurisé pour les applications de chiffrement.</p></div><div class="literalblock programlisting"><div class=content><pre>device   ether         # Ethernet support</pre></div></div><div class=paragraph><p><code>ether</code> ne sert que si vous avez une carte Ethernet. Cela intègre le code générique pour le protocole Ethernet.</p></div><div class="literalblock programlisting"><div class=content><pre>device   sl            # Kernel SLIP</pre></div></div><div class=paragraph><p><code>sl</code> est le support pour le protocole SLIP. Il a été presque entièrement supplanté par le protocole PPP, plus facile à mettre en oeuvre, mieux adapté aux connexions par modem, et aussi plus puissant.</p></div><div class="literalblock programlisting"><div class=content><pre>device   ppp           # Kernel PPP</pre></div></div><div class=paragraph><p>C’est le support intégré au noyau du protocole PPP pour les connexions par modem. Il y a aussi une version de PPP sous forme de programme utilisateur qui utilise <code>tun</code> et offre plus de souplesse et de possibilités comme la connexion à la demande.</p></div><div class="literalblock programlisting"><div class=content><pre>device   tun           # Packet tunnel.</pre></div></div><div class=paragraph><p>Ceci est utilisé par le programme PPP en mode utilisateur. Voyez la section <a href=#userppp>PPP</a> de ce manuel pour plus d’informations.</p></div><div class="literalblock programlisting"><div class=content><pre>device   pty           # Pseudo-ttys (telnet etc)</pre></div></div><div class=paragraph><p>C’est un "pseudo-terminal" ou un port simulant une session. Il est utilisé par les sessions <code>telnet</code> et <code>rlogin</code> entrantes, par xterm, et d’autres applications comme Emacs.</p></div><div class="literalblock programlisting"><div class=content><pre>device   md            # Memory disks</pre></div></div><div class=paragraph><p>Pseudo-périphérique de disque mémoire.</p></div><div class="literalblock programlisting"><div class=content><pre>device   gif     # IPv6 and IPv4 tunneling</pre></div></div><div class=paragraph><p>Ceci implémente l’encapsulation du protocole IPv6 par dessus l’IPv4, l’IPv4 par dessus l’IPv6, l’encapsulation IPv4 par dessus l’IPv4, et IPv6 par dessus IPv6. Le périphérique `gif`"s’auto-duplique", et créera les fichiers spéciaux de périphérique en fonction des besoins.</p></div><div class="literalblock programlisting"><div class=content><pre>device   faith   # IPv6-to-IPv4 relaying (translation)</pre></div></div><div class=paragraph><p>Ce pseudo-périphérique capture les paquets qui lui sont envoyés et les détourne vers le "daemon" de translation IPv4/IPv6.</p></div><div class="literalblock programlisting"><div class=content><pre># The `bpf&#39; device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that &#39;bpf&#39; is required for DHCP.
device   bpf           # Berkeley packet filter</pre></div></div><div class=paragraph><p>C’est le filtre de paquets de Berkeley. Ce pseudo-périphérique permet de placer les interfaces en mode "promiscuous" (indiscret), pour capturer chaque paquet sur réseau de diffusion (e.g., un réseau Ethernet). Ces paquets peuvent être enregistrés sur le disque et/ou examinés avec le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> est également utilisé par <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> pour obtenir une adresse IP du routeur par défaut (passerelle) et ainsi de suite. Si vous utilisez DHCP, conservez cette ligne non commentée.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># USB support
device          uhci          # UHCI PCI-USB interface
device          ohci          # OHCI PCI-USB interface
device          ehci          # EHCI PCI-USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # Human Interface Devices
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</pre></div></div><div class=paragraph><p>Support pour divers périphériques USB.</p></div><div class="literalblock programlisting"><div class=content><pre># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</pre></div></div><div class=paragraph><p>Support pour divers périphériques Firewire.</p></div><div class=paragraph><p>Pour plus d’informations et pour avoir la liste de périphériques supplémentaires supportés par FreeBSD, voyez le fichier <span class=filename>/usr/src/sys/i386/conf/NOTES</span>.</p></div><div class=sect3><h4 id=_configurations_mémoire_importantes_pae>8.4.1. Configurations mémoire importantes (PAE)<a class=anchor href=#_configurations_mémoire_importantes_pae></a></h4><div class=paragraph><p>Les machines à configuration mémoire importante ont besoin de pouvoir accéder à plus d’espace mémoire utilisateur et noyau que la limite des 4 gigaoctets de l’espace d’adresse noyau+utilisateur ("Kernel Virtual Address"-KVA). En raison de cette limite, Intel a ajouté le support d’adresses physiques sur 36 bits pour l’espace d’adresses dans les familles de microprocesseurs Pentium® Pro et suivantes.</p></div><div class=paragraph><p>L’extension de l’adressage physique-,"Physical Address Extension" (PAE) est une caractéristique des microprocesseurs Intel® Pentium® Pro et suivants autorisant les configurations mémoires jusqu’à 64 gigaoctets. FreeBSD fournit un support pour cette caratéristique via l’option de configuration du noyau <code>PAE</code>, disponible sous toutes les versions actuelles de FreeBSD. En raison des limitations de l’architecture mémoire Intel®, aucune distinction n’est faite entre la mémoire au-dessus et en-dessous de 4 gigaoctets. La mémoire allouée au-dessus de 4 gigaoctets est simplement ajoutée à l’ensemble de la mémoire disponible.</p></div><div class=paragraph><p>Pour activer le support PAE dans le noyau, ajoutez simplement la ligne suivante dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options		PAE</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le support PAE sous FreeBSD est uniquement disponible pour les processeurs IA-32 d’Intel®. Il doit être noté que le support PAE sous FreeBSD n’a pas été énormément testé, et devrait être considéré comme bêta comparé aux autres fonctionnalités stables de FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le support PAE sous FreeBSD a quelques limitations:</p></div><div class=ulist><ul><li><p>Un processus est incapable d’accéder à plus de 4 gigaoctets d’espace mémoire.</p></li><li><p>Les modules KLD ne peuvent être chargés dans un noyau avec PAE activé, en raison des différences entre la structure d’un module et du noyau.</p></li><li><p>Les pilotes de périphériques qui n’utilisent pas l’interface <a href="https://man.freebsd.org/cgi/man.cgi?query=bus_dma&amp;sektion=9&amp;format=html">bus_dma(9)</a> seront à l’origine de corruption de données avec un noyau PAE et ne sont pas recommandés. Pour cette raison, le fichier de configuration du noyau avec support <span class=filename>PAE</span> qui est fourni avec FreeBSD exclut tous les pilotes connus pour ne pas fonctionner avec un noyau avec support PAE.</p></li><li><p>Certains paramètres modifiables du système déterminent l’utilisation des ressources mémoire par la quantité de la mémoire physique disponible. De tels paramètres peuvent être inutilement sur-alloués en raison de la grande quantité de mémoire d’un système PAE. Un bon exemple est le "sysctl" <code>kern.maxvnodes</code>, qui contrôle le nombre maximal de "vnodes" alloués par le noyau. Il est recommandé d’ajuster ce dernier et les autres paramètres du même genre à des valeurs raisonnables.</p></li><li><p>Il pourra être nécessaire d’augmenter l’espace d’adressage virtuel du noyau ("kernel virtual address"-KVA) ou de réduire le montant de la ressource spécifique du noyau qui est fortement utilisée (voir plus haut) afin d’éviter l’épuisement de l’espace KVA. L’option du noyau <code>KVA_PAGES</code> peut être employée pour augmenter l’espace KVA.</p></li></ul></div><div class=paragraph><p>Pour des considérations de performance et de stabilité, il est recommandé de consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=pae&amp;sektion=4&amp;format=html">pae(4)</a> contient des informations à jour sur le support PAE sous FreeBSD.</p></div></div></div><div class=sect2><h3 id=kernelconfig-trouble>8.5. Si quelque chose se passe mal<a class=anchor href=#kernelconfig-trouble></a></h3><div class=paragraph><p>Il y a cinq types de problèmes qui peuvent survenir lors de la compilation d’un noyau sur mesure. Ce sont:</p></div><div class=dlist><dl><dt class=hdlist1>La commande <code>config</code> échoue</dt><dd><p>Si la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> échoue quand vous lui passez en paramètre la description de votre noyau, vous avez probablement fait une simple erreur quelque part. Heureusement <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> affichera le numéro de la ligne qui lui a posé problème, vous pouvez donc localiser rapidement la ligne contenant l’erreur. Par exemple, si vous avez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>config: line 17: syntax error</code></pre></div></div><div class=paragraph><p>Vérifiez que la ligne est correctement écrite, en le comparant avec le noyau <span class=filename>GENERIC</span> ou une autre référence.</p></div></dd><dt class=hdlist1>La commande <code>make</code> échoue</dt><dd><p>Si la commande <code>make</code> échoue, cela signale habituellement une erreur dans la description de votre noyau, mais qui n’est pas suffisamment sérieuse pour que la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> la détecte. A nouveau, vérifiez votre fichier de configuration, et si vous n’arrivez toujours pas à résoudre le problème, envoyez un courrier électronique à la <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>liste de diffusion pour les questions d’ordre général à propos de FreeBSD</a> en joignant votre fichier de configuration du noyau, le diagnostic devrait être rapide.</p><div class=dlist><dl><dt class=hdlist1>Le noyau ne démarre pas:<a id=kernelconfig-noboot></a></dt><dd><p>Si votre nouveau noyau ne démarre pas, ou ne reconnaît pas vos périphériques, ne paniquez pas! Heureusement, FreeBSD dispose d’un excellent mécanisme pour récupérer si le noyau ne fonctionne pas. Sélectionnez simplement le noyau, à partir duquel vous désirez démarrer, à l’invite du chargeur de FreeBSD. Vous pouvez y accéder quand le menu de démarrage apparaît. Sélectionner l’option 6, "Escape to a loader prompt". A l’invite, tapez <code>unload kernel</code> et ensuite <code>boot /boot/kernel.old/kernel</code>, ou le nom de fichier d’un autre noyau qui pourra démarrer proprement. Quand on reconfigure un noyau, il est toujours bon de conserver à portée de la main un noyau dont on sait qu’il fonctionne.</p><div class=paragraph><p>Après avoir démarré avec un noyau en état de marche, vous pouvez revérifier votre fichier de configuration et essayer de recompiler à nouveau votre noyau. Une ressource utile est le fichier <span class=filename>/var/log/messages</span> qui enregistre, entre autres, tous les messages du noyau à chaque démarrage réussi. En outre, la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> affichera les messages du noyau pour le dernier démarrage.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous avez des difficultés à compiler un noyau, veillez à conserver un noyau <span class=filename>GENERIC</span>, ou un autre noyau dont vous savez qu’il fonctionne, sous la main, avec un nom différent de sorte qu’il ne soit pas écrasé à la prochaine compilation. Vous ne pouvez pas faire confiance au noyau <span class=filename>kernel.old</span> parce qu’en installant un nouveau noyau, <span class=filename>kernel.old</span> est remplacé par le dernier noyau installé dont il n’est pas certain qu’il soit opérationnel. Aussi, dès que possible, déplacez le noyau opérationnel vers le bon emplacement <span class=filename>/boot/kernel</span> où des commandes comme <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> pourront ne pas fonctionner correctement. Pour cela, renommez le répertoire contenant le bon noyau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /boot/kernel /boot/kernel.bad</span>
<span class=c># mv /boot/kernel.good /boot/kernel</span></code></pre></div></div></td></tr></tbody></table></div></dd></dl></div></dd><dt class=hdlist1>Le noyau est opérationnel, mais la commande <code>ps</code> ne fonctionne plus du tout</dt><dd><p>Si vous avez installé une version du noyau différente de celle avec laquelle ont été compilés les utilitaires système, par exemple, un noyau -CURRENT sur un système -RELEASE, de nombreuses commandes d’affichage de l’état du système comme <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a> ne fonctionneront plus. Vous devrez <a href=./#makeworld>recompiler et installer un système</a> avec la même version de l’arborescence des sources de celle utilisée pour votre noyau. C’est une des raisons pour lesquelles il n’est pas judicieux d’utiliser des versions différentes du noyau et du reste du système d’exploitation.</p></dd></dl></div></div></div></div><div class=sect1><h2 id=printing>Chapitre 9. Imprimer<a class=anchor href=#printing></a></h2><div class=sectionbody><div class=sect2><h3 id=printing-synopsis>9.1. Synopsis<a class=anchor href=#printing-synopsis></a></h3><div class=paragraph><p>FreeBSD peut être utilisé pour imprimer sur une grande variété d’imprimantes, depuis la plus ancienne des imprimantes matricielles jusqu’aux toutes dernières imprimantes laser, en passant par tout ce qui peut exister entre les deux, et vous permet d’obtenir des impressions de haute qualité avec les programmes que vous exécutez.</p></div><div class=paragraph><p>Il est également possible de configurer FreeBSD pour qu’il fasse office de serveur d’impression sur un réseau; de cette manière FreeBSD peut recevoir des travaux d’impression ("jobs") en provenance de différents ordinateurs, comprenant d’autres machines sous FreeBSD et des machines sous Windows® ou Mac OS®. FreeBSD veillera à ce qu’un seul travail d’impression ne soit imprimé à la fois, et pourra tenir des statistiques sur les utilisateurs et les machines lançant le plus d’impressions, produire des pages d'"en-têtes" pour distinguer les impressions de chacun, et plus encore.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Comment configurer le gestionnaire d’impression de FreeBSD</p></li><li><p>Comment installer des filtres d’impression, pour gérer des travaux d’impression particuliers de manière différente, ce qui inclut la transformation de documents entrants en un format que vos imprimantes comprennent.</p></li><li><p>Comment inclure des en-têtes ou des pages bannière dans vos impressions.</p></li><li><p>Comment imprimer en utilisant des imprimantes connectées à d’autres ordinateurs.</p></li><li><p>Comment imprimer en utilisant des imprimantes connectées directement au réseau.</p></li><li><p>Comment gérer des restrictions d’impression, notamment comment limiter la taille des travaux d’impression, et empêcher certains utilisateurs d’imprimer.</p></li><li><p>Comment tenir des statistiques d’impression, et rendre compte de l’utilisation de l’imprimante.</p></li><li><p>Comment résoudre les problèmes d’impression.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devriez:</p></div><div class=ulist><ul><li><p>Savoir comment configurer et installer un nouveau noyau (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=printing-intro-spooler>9.2. Introduction<a class=anchor href=#printing-intro-spooler></a></h3><div class=paragraph><p>Afin d’utiliser des imprimantes avec FreeBSD, vous avez la possibilité de les paramétrer pour qu’elles utilisent le gestionnaire d’impression de Berkeley, également connu sous le nom de gestionnaire d’impression LPD, ou tout simplement LPD. C’est le système contrôle d’imprimante par défaut de FreeBSD. Ce chapitre présente LPD et vous assistera tout au long de sa configuration.</p></div><div class=paragraph><p>Si vous connaissez déjà LPD ou un autre système de gestion des impressions, vous pouvez directement vous rendre à la section <a href=#printing-intro-setup>Paramétrage de base</a>.</p></div><div class=paragraph><p>LPD contrôle tout ce qui relève des imprimantes. Il est responsable de plusieurs tâches:</p></div><div class=ulist><ul><li><p>Il contrôle l’accès aux imprimantes directement connectées au système ainsi qu’à celles connectées à d’autres machines via le réseau.</p></li><li><p>Il permet aux utilisateurs de soumettre des fichiers à imprimer; ces requêtes sont connues sous le nom de <em>travaux</em>.</p></li><li><p>Il empêche l’accès simultané de plusieurs utilisateurs à une même imprimante, en gérant une <em>queue</em> pour chaque imprimante.</p></li><li><p>Il peut produire des <em>pages d’en-tête</em> (également connues sous le nom de <em>pages bannières</em> ou encore <em>cartouches</em>) afin que les utilisateurs puissent facilement retrouver dans une pile d’impressions celles correspondant aux travaux qu’ils ont soumis.</p></li><li><p>Il s’occupe de paramétrer les communications lorsque les imprimantes sont connectées via un port série.</p></li><li><p>Il peut transmettre des travaux par réseau à un gestionnaire d’impression LPD situé sur une autre machine.</p></li><li><p>Il peut appliquer des filtres spéciaux afin d’assurer le formatage des travaux en fonction des différents langages et caractéristiques des imprimantes.</p></li><li><p>Il peut comptabiliser l’utilisation de l’imprimante.</p></li></ul></div><div class=paragraph><p>Vous pouvez, au travers d’un fichier de configuration (<span class=filename>/etc/printcap</span>) et en fournissant les programmes de filtres spéciaux, faire exécuter par LPD tout ou partie des tâches mentionnées ci-dessus sur une grande variété de modèles d’imprimantes.</p></div><div class=sect3><h4 id=printing-intro-why>9.2.1. Pourquoi vous devriez utiliser le gestionnaire d’impression<a class=anchor href=#printing-intro-why></a></h4><div class=paragraph><p>Si vous êtes l’unique utilisateur de votre système, vous vous demandez sans doute pourquoi il vous faudrait vous préoccuper du gestionnaire d’impression, alors que vous n’avez pas besoin de contrôle d’accès, de pages d’en-tête ni de statistiques relatives à l’utilisation de l’imprimante. Quand bien même il est possible de mettre en oeuvre l’accès direct à l’imprimante, vous devriez tout de même utiliser le gestionnaire d’impression, parce que:</p></div><div class=ulist><ul><li><p>LPD imprime les travaux en tâche de fond: vous n’êtes pas obligé d’attendre que les données soient passées à l’imprimante.</p></li><li><p>LPD peut commodément se charger d’appliquer des filtres à un travail pour adjoindre une en-tête contenant la date et l’heure, ou convertir un fichier au format particulier (comme un fichier DVI TeX) en un format que l’imprimante comprenne. Ainsi, vous n’aurez pas à vous charger de ces manipulations à la main.</p></li><li><p>Beaucoup d’applications, tant libres que commerciales, fournissant une fonctionnalité d’impression s’attendent généralement à traiter avec le gestionnaire d’impression. En le mettant en oeuvre, vous vous faciliterez le support des autres applications que vous pourriez ajouter plus tard, ou que vous avez déjà installées.</p></li></ul></div></div></div><div class=sect2><h3 id=printing-intro-setup>9.3. Configuration de base<a class=anchor href=#printing-intro-setup></a></h3><div class=paragraph><p>Pour utiliser des imprimantes avec le gestionnaire d’impression, il vous faudra configurer à la fois la partie matérielle (c’est à dire les imprimantes) et la partie logicielle (c’est à dire LPD). Ce document présente deux niveaux de configuration:</p></div><div class=ulist><ul><li><p>La section <a href=#printing-simple>Configuration simple de l’imprimante</a> vous apprendra à connecter une imprimante, à renseigner LPD sur la façon dont il doit communiquer avec elle, et à imprimer de simples fichiers textes.</p></li><li><p>La section <a href=#printing-advanced>Configuration avancée de l’imprimante</a> vous apprendra à imprimer différents formats de fichiers, des pages d’en-tête, par l’intermédiaire d’un réseau, à contrôler l’accès aux imprimantes, et comptabiliser leur utilisation.</p></li></ul></div><div class=sect3><h4 id=printing-simple>9.3.1. Configuration simple de l’imprimante<a class=anchor href=#printing-simple></a></h4><div class=paragraph><p>Cette section vous apprendra à configurer l’imprimante et LPD. Elle présente les bases:</p></div><div class=ulist><ul><li><p>La section <a href=#printing-hardware>Configuration matérielle</a> donne des indications sur la façon de connecter l’imprimante à l’un des ports de votre ordinateur.</p></li><li><p>La section <a href=#printing-software>Configuration logicielle</a> montre comment renseigner le fichier de configuration du gestionnaire d’impression LPD (<span class=filename>/etc/printcap</span>).</p></li></ul></div><div class=paragraph><p>Si vous mettez en oeuvre une imprimante réceptionnant les données à imprimer via un protocole réseau plutôt que par les interfaces locales de l’ordinateur, lisez la section <a href=#printing-advanced-network-net-if>Imprimantes avec des interfaces utilisant des flux réseau</a>.</p></div><div class=paragraph><p>Bien que cette section soit intitulée "Configuration simple de l’imprimante", elle s’avère en réalité plutôt complexe. La partie la plus difficile consiste à faire fonctionner l’imprimante avec votre ordinateur et LPD. Les options avancées telles les pages d’en-tête ou les statistiques sont relativement faciles à mettre en oeuvre une fois que l’imprimante fonctionne.</p></div><div class=sect4><h5 id=printing-hardware>9.3.1.1. Configuration matérielle<a class=anchor href=#printing-hardware></a></h5><div class=paragraph><p>Cette section détaille les différentes manières de connecter une imprimante à votre PC. Elle discute les types de ports et de câbles, et de la configuration noyau dont vous pourriez avoir besoin afin que FreeBSD puisse communiquer avec l’imprimante.</p></div><div class=paragraph><p>Si vous avez déjà connecté votre imprimante et réussi à imprimer sous un autre système d’exploitation, vous pouvez probablement passer à la section <a href=#printing-software>Configuration logicielle</a>.</p></div><div class=sect5><h6 id=printing-ports>9.3.1.1.1. Les ports et les câbles<a class=anchor href=#printing-ports></a></h6><div class=paragraph><p>Les imprimantes pour PC vendues aujourd’hui sont en général pourvues d’une ou plusieurs des trois interfaces suivantes:</p></div><div class=ulist><ul><li><p>Les interfaces <em>série</em>, également connues sous les noms RS-232 ou ports COM, utilisent un port série sur votre ordinateur pour envoyer des données à l’imprimante. Les interfaces série sont courantes, dans l’industrie informatique, et les câbles sont à la fois disponibles et faciles à réaliser. Elles réclament parfois des câbles spéciaux et peuvent nécessiter le paramétrage d’options de communication assez complexes. La plupart des ports série PC ont une vitesse de transmission maximale de 115200 bps, ce qui rend l’impression de travaux comportant beaucoup de graphismes malaisée.</p></li><li><p>Les interfaces <em>parallèles</em> utilisent un port parallèle sur votre ordinateur pour envoyer des données à l’imprimante. Les interfaces parallèles sont courantes dans l’industrie informatique et plus rapides que les interfaces série RS-232. Les câbles sont disponibles mais sont moins faciles à fabriquer à la main. En général, il n’y a aucune option de communication à paramétrer avec ces interfaces, ce qui rend leur configuration particulièrement simple.</p><div class=paragraph><p>Les interfaces parallèles sont parfois appelées "Centronics", nom tiré du type de connecteur de l’imprimante</p></div></li><li><p>Les interfaces USB, tenant leur nom de "Universal Serial Bus", ou "Bus Série Universel", s’avèrent plus véloces encore que les interfaces parallèles ou série RS-232. Les câbles sont simples et peu onéreux. L’USB surpasse les interfaces série RS-232 et parallèles pour l’impression, mais son support par les systèmes UNIX® n’est pas aussi bon. Une façon d’éviter ce problème est d’acheter une imprimante qui dispose à la fois d’une interface USB et d’une interface parallèle, comme beaucoup de modèles.</p></li></ul></div><div class=paragraph><p>En règle générale, les interfaces parallèles n’offrent qu’une communication unidirectionnelle (de l’ordinateur vers l’imprimante) alors que les interfaces série et USB permettent un échange bidirectionnel. Les imprimantes et ports parallèles plus récents (EPP et ECP) peuvent communiquer dans les deux sens sous FreeBSD lorsque l’on a recourt à un câble conforme à la norme IEEE-1284.</p></div><div class=paragraph><p>La communication bidirectionnelle avec l’imprimante en utilisant un port parallèle se fait en général de l’une des deux manières suivantes. La première utilise un pilote d’imprimante compilé pour FreeBSD comprenant le langage propriétaire de l’imprimante. C’est couramment le cas des imprimantes jet d’encre et cela peut être utilisé pour retourner les niveaux d’encre et autres informations d’état. La seconde méthode est employée lorsque l’imprimante supporte PostScript®.</p></div><div class=paragraph><p>Les travaux PostScript® sont en fait des programmes envoyés à l’imprimante. Ils ne génèrent pas nécessairement de sortie papier et peuvent retourner leurs résultats directement à l’ordinateur. PostScript® utilise aussi la communication bidirectionnelle pour avertir l’ordinateur de problèmes, comme des erreurs dans le programme PostScript® ou des bourrages papier. Vos utilisateurs apprécieraient certainement de telles informations. De surcroît, la meilleure façon de tenir des statistiques sérieusement avec une imprimante PostScript® nécessite la communication bidirectionnelle: on demande à l’imprimante quel est son compteur de pages (combien en a-t-elle imprimées depuis sa fabrication), puis on lui envoie le travail de l’utilisateur, enfin on lui redemande son compteur de pages. La différence entre les deux valeurs donne la consommation de papier que vous pouvez attribuer à cet utilisateur.</p></div></div><div class=sect5><h6 id=printing-parallel>9.3.1.1.2. Les ports parallèles<a class=anchor href=#printing-parallel></a></h6><div class=paragraph><p>Pour raccorder une imprimante utilisant une interface parallèle, branchez le câble Centronics sur l’imprimante et sur l’ordinateur. Les instructions accompagnant l’imprimante, l’ordinateur, ou les deux, devraient parfaitement vous renseigner.</p></div><div class=paragraph><p>Souvenez-vous du port parallèle que vous avez utilisé sur l’ordinateur. Pour FreeBSD, le premier se nomme <span class=filename>ppc0</span>; le deuxième, <span class=filename>ppc1</span>, et ainsi de suite. Le nom du fichier spécial de périphérique de l’imprimante suit les mêmes règles: <span class=filename>/dev/lpt0</span> pour celle connectée sur le premier port parallèle, etc.</p></div></div><div class=sect5><h6 id=printing-serial>9.3.1.1.3. Les ports série<a class=anchor href=#printing-serial></a></h6><div class=paragraph><p>Pour raccorder une imprimante utilisant une interface série, branchez le câble série adéquat sur l’imprimante et sur l’ordinateur. Les instructions accompagnant l’imprimante, l’ordinateur, ou les deux, devraient parfaitement vous renseigner.</p></div><div class=paragraph><p>Si vous n’êtes pas sûr de savoir quel est le bon câble, voici ce que vous pouvez essayer:</p></div><div class=ulist><ul><li><p>Un câble <em>modem</em> relie chacune des broches du connecteur depuis l’une des extrémités du câble directement à la broche lui correspondant dans le connecteur de l’autre extrémité. Ce type de câble est également connu sous le nom de câble "DTE-to-DCE".</p></li><li><p>Un câble <em>null-modem</em> relie certaines des broches directement, en intervertit d’autres (par exemple, "émission de données" et "réception de données"), et en court-circuite d’autres en interne sur chacun des sertissages des connecteurs. Ce type de câble est également connu sous le nom de câble "DTE-to-DTE".</p></li><li><p>Un câble <em>série pour imprimante</em>, requis par certaines imprimantes peu conventionnelles, ressemble au câble null-modem, à ceci près qu’il envoie certains signaux à l’autre extrémité au lieu de les court-circuiter en interne.</p></li></ul></div><div class=paragraph><p>Vous devriez également définir les paramètres de communication pour l’imprimante, d’ordinaire en utilisant les contrôles sur la face avant ou les commutateurs sur l’imprimante. Choisissez la valeur la plus élevée de <code>bps</code> (bits par seconde, encore appelés "vitesse de transmission") autorisée conjointement par votre ordinateur et votre imprimante. Choisissez 7 ou 8 bits de données; aucun contrôle de parité ou un bit de parité paire ou impaire; et 1 ou 2 bits d’arrêt. Choisissez également un protocole de contrôle de flux: soit aucun, soit XON/XOFF (également appelé "in-band", ou encore "contrôle logiciel"). Retenez ces paramètres pour la configuration logicielle, dans la section qui suit.</p></div></div></div><div class=sect4><h5 id=printing-software>9.3.1.2. Configuration logicielle<a class=anchor href=#printing-software></a></h5><div class=paragraph><p>Cette section détaille la configuration logicielle nécessaire pour imprimer sous FreeBSD avec le gestionnaire d’impression LPD.</p></div><div class=paragraph><p>Voici un aperçu des étapes à suivre:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Configurez le noyau, si nécessaire, pour utiliser le port sur lequel vous raccorderez votre imprimante; la section <a href=#printing-kernel>Configurer le noyau de FreeBSD</a> vous donnera la marche à suivre.</p></li><li><p>Paramétrez le mode de communication du port parallèle si vous utilisez une imprimante de ce type; la section <a href=#printing-parallel-port-mode>Paramétrer le mode de communication du port parallèle</a> vous donnera les détails.</p></li><li><p>Configurez LPD pour qu’il communique avec l’imprimante en renseignant le fichier <span class=filename>/etc/printcap</span>. Vous apprendrez comment faire un peu plus loin dans ce chapitre.</p></li></ol></div></div></div><div class=sect5><h6 id=printing-kernel>9.3.1.2.1. Configuration du noyau<a class=anchor href=#printing-kernel></a></h6><div class=paragraph><p>Le noyau du système d’exploitation est compilé avec le support d’un certain ensemble de périphériques. Les interfaces série ou parallèle de votre imprimante en font partie. De ce fait, vous pourriez avoir à ajouter le support d’un port série ou parallèle supplémentaire si votre noyau n’a pas déjà été configuré en ce sens.</p></div><div class=paragraph><p>Pour savoir si le support d’une interface série est activé dans le noyau que vous êtes en train d’utiliser, entrez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># # grep sioN /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>Où <em>N</em> représente le numéro du port série, en commençant à zéro. Si vous obtenez un affichage similaire à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio2 at port 0x3e8-0x3ef irq 5 on isa sio2: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>alors le port est activé dans le noyau.</p></div><div class=paragraph><p>Pour savoir si le noyau supporte une interface parallèle, entrez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep ppcN /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>Où <em>N</em> représente le numéro du port parallèle, en commençant à zéro. Si vous obtenez un affichage similaire à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppc0: &lt;Parallel port&gt; at port 0x378-0x37f irq 7 on isa0
ppc0: SMC-like chipset <span class=o>(</span>ECP/EPP/PS2/NIBBLE<span class=o>)</span> <span class=k>in </span>COMPATIBLE mode
ppc0: FIFO with 16/16/8 bytes threshold</code></pre></div></div><div class=paragraph><p>alors le port est activé dans le noyau.</p></div><div class=paragraph><p>Il se pourrait que vous ayez à reconfigurer le noyau afin que le système détecte et puisse utiliser un port parallèle ou série auquel vous avez connecté votre imprimante.</p></div><div class=paragraph><p>Pour ajouter le support d’un port série, voyez la section sur la configuration du noyau. Pour ajouter le support du port parallèle, voyez cette même section <em>et</em> celle qui suit.</p></div></div></div><div class=sect4><h5 id=printing-parallel-port-mode>9.3.1.3. Paramétrer le mode de communication du port parallèle<a class=anchor href=#printing-parallel-port-mode></a></h5><div class=paragraph><p>Lorsque vous utilisez l’interface parallèle, vous avez le choix entre deux modes de communication avec l’imprimante: par interruption, ou par polling (interrogation régulière ou scrutation). Le pilote d’imprimante générique (<a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a>) de FreeBSD utilise le système <a href="https://man.freebsd.org/cgi/man.cgi?query=ppbus&amp;sektion=4&amp;format=html">ppbus(4)</a>, qui contrôle le chipset du port via le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ppc&amp;sektion=4&amp;format=html">ppc(4)</a>.</p></div><div class=ulist><ul><li><p>Le mode par <em>interruption</em> est le mode par défaut avec un noyau GENERIC. De cette manière, le système d’exploitation utilise une ligne d’interruption (IRQ) pour déterminer si l’imprimante est prête à recevoir des données.</p></li><li><p>Le mode <em>par scrutation</em> enjoint au système d’exploitation d’interroger à intervalles réguliers l’imprimante pour savoir si elle est prête à recevoir d’autres données. Lorsqu’elle répond par l’affirmative, le noyau lui en envoie plus.</p></li></ul></div><div class=paragraph><p>Le mode par interruption est en général nettement plus rapide, mais consomme une précieuse ligne d’interruption (IRQ). On rapporte que certaines imprimantes HP récentes ne fonctionneraient pas correctement en mode par interruption, apparemment à cause d’un problème (pas encore très bien identifié) d’horloge. Ces imprimantes nécessitent le recours au mode par scrutation. Utilisez celui des deux qui fonctionne. Certaines imprimantes fonctionnent dans les deux modes, mais s’avèrent désagréablement lentes en mode par interruption.</p></div><div class=paragraph><p>Vous pouvez choisir le mode de communication de deux manières différentes: en configurant le noyau ou en utilisant le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a>.</p></div><div class=paragraph><p><em>Pour paramétrer le mode de communication en configurant le noyau:</em></p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Editez le fichier de configuration de votre noyau. Cherchez une entrée <code>ppc0</code>. Si vous voulez configurer le deuxième port parallèle, cherchez plutôt <code>ppc1</code>. Ou <code>ppc2</code> pour le troisième, et ainsi de suite.</p><div class=ulist><ul><li><p>Si vous souhaitez activer le mode par interruption, éditez la ligne suivante:</p><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.irq=&#34;N&#34;</pre></div></div><div class=paragraph><p>dans le fichier <span class=filename>/boot/device.hints</span> et remplacez <em>N</em> par le numéro d’IRQ approprié. Le fichier de configuration du noyau doit également comporter le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ppc&amp;sektion=4&amp;format=html">ppc(4)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device ppc</pre></div></div></li><li><p>Si vous souhaitez activer le mode par scrutation, ôtez la ligne suivante de votre fichier <span class=filename>/boot/device.hints</span>:</p><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.irq=&#34;N&#34;</pre></div></div><div class=paragraph><p>Dans certains cas, positionner le port en mode scrutation sous FreeBSD n’est pas suffisant. La plupart du temps cela vient du pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, ce dernier étant capable de sonder et d’attacher des périphériques, et donc de contrôler le mode d’accès au port de l’imprimante. Vous devrez donc vérifier votre configuration <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> pour résoudre ce problème.</p></div></li></ul></div></li><li><p>Sauvegardez le fichier, puis configurez, compilez, et installez le noyau avant de redémarrer. Consultez la section <a href=#kernelconfig>configuration du noyau</a> pour plus de détails.</p></li></ol></div></div></div><div class=paragraph><p><em>Pour paramétrer le mode de communication avec</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a>:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Entrez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptcontrol -i -d /dev/lptN</span></code></pre></div></div><div class=paragraph><p>pour sélectionner le mode par interruption pour <code>lptN</code>.</p></div></li><li><p>Entrez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptcontrol -p -d /dev/lptN</span></code></pre></div></div><div class=paragraph><p>pour sélectionner le mode par scrutation pour <code>lptN</code>.</p></div></li></ol></div></div></div><div class=paragraph><p>Vous pouvez placer ces commandes dans votre fichier <span class=filename>/etc/rc.local</span> pour sélectionner le mode à chaque démarrage du système. Consultez <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a> pour obtenir plus d’informations.</p></div></div><div class=sect4><h5 id=printing-testing>9.3.1.4. Vérifier la communication avec l’imprimante<a class=anchor href=#printing-testing></a></h5><div class=paragraph><p>Avant de passer à la configuration du gestionnaire d’impression, vous devriez vous assurer que le système d’exploitation fait parvenir avec succès des données à l’imprimante. Il est beaucoup plus facile de déboguer séparément la communication avec l’imprimante et la configuration du gestionnaire d’impression.</p></div><div class=paragraph><p>Pour tester l’imprimante, nous allons lui envoyer du texte. Pour les imprimantes qui peuvent immédiatement imprimer les caractères qui leur sont envoyés, le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> est parfait: il génère les 96 caractères ASCII imprimables sur 96 lignes.</p></div><div class=paragraph><p>Pour une imprimante PostScript® (ou basée sur un autre langage), il va nous falloir un test plus sophistiqué. Un petit programme PostScript®, tel que celui qui suit, devrait suffire:</p></div><div class="literalblock programlisting"><div class=content><pre>%!PS
100 100 moveto 300 300 lineto stroke
310 310 moveto /Helvetica findfont 12 scalefont setfont
(Is this thing working?) show
showpage</pre></div></div><div class=paragraph><p>Le code PostScript® ci-dessus peut être placé dans un fichier et utilisé comme indiqué dans les exemples qui apparaissent dans les sections suivantes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Lorsque ce document fait référence à un langage d’imprimante, il suppose un langage comme PostScript®, et pas le PCL de Hewlett-Packard. Quoique PCL dispose de fonctionnalités intéressantes, il est possible de mélanger du texte simple avec des séquences d’échappement. PostScript® ne permet pas d’imprimer du texte clair, c’est le type de langage d’imprimante pour lequel nous devons prendre des mesures particulières.</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=printing-checking-parallel>9.3.1.4.1. Tester une imprimante parallèle<a class=anchor href=#printing-checking-parallel></a></h6><div class=paragraph><p>Cette section vous apprendra à vérifier si FreeBSD peut communiquer avec une imprimante connectée sur un port parallèle.</p></div><div class=paragraph><p><em>Pour tester une imprimante connectée sur un port parallèle:</em></p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Passez en <code>root</code> avec <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>.</p></li><li><p>Envoyez des données à l’imprimante.</p><div class=ulist><ul><li><p>Si l’imprimante peut sortir du texte simple, alors utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>. Entrez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptest  /dev/lptN</span></code></pre></div></div><div class=paragraph><p>Où <em>N</em> est le numéro du port parallèle, en commençant à zéro.</p></div></li><li><p>Si l’imprimante comprend le PostScript® ou un autre langage d’imprimante, alors envoyez lui un petit programme. Entrez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat  /dev/lptN</span></code></pre></div></div><div class=paragraph><p>Tapez ensuite le programme, ligne à ligne et <em>attentivement</em>, car vous ne pouvez plus éditer une ligne une fois que vous avez appuyé sur la touche <code>Retour Chariot</code> ou <code>Entrée</code>. Une fois terminé, faites <code>CONTROL+D</code>, ou la combinaison correspondant à votre fin de fichier.</p></div><div class=paragraph><p>Une autre manière de procéder est de placer le programme dans un fichier et d’entrer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat fichier  /dev/lptN</span></code></pre></div></div><div class=paragraph><p>Où <em>fichier</em> désigne le nom du fichier que vous désirez envoyer à l’imprimante.</p></div></li></ul></div></li></ol></div></div></div><div class=paragraph><p>Vous devriez voir quelque chose s’imprimer. Ne vous inquiétez pas si l’apparence du texte n’est pas satisfaisante; nous remédierons à ce genre de soucis plus tard.</p></div></div><div class=sect5><h6 id=printing-checking-serial>9.3.1.4.2. Tester une imprimante série<a class=anchor href=#printing-checking-serial></a></h6><div class=paragraph><p>Dans cette section vous apprendrez à vérifier si FreeBSD parvient à communiquer avec une imprimante connectée à un port série.</p></div><div class=paragraph><p><em>Pour tester une imprimante connectée sur un port série:</em></p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Passez en <code>root</code> avec <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>.</p></li><li><p>Editez le fichier <span class=filename>/etc/remote</span>. Ajoutez l’entrée suivante:</p><div class="literalblock programlisting"><div class=content><pre>printer:dv=/dev/port:br#bps-rate:pa=parity</pre></div></div><div class=paragraph><p>Où <em>port</em> représente le fichier de périphérique du port série (<code>ttyd0</code>, <code>ttyd1</code>, etc.), <em>bps-rate</em> représente la vitesse en bits-par-seconde à laquelle l’imprimante communique, et <em>parity</em> représente la parité réclamée par l’imprimante (<code>even</code> pour paire, <code>odd</code> pour impaire, <code>none</code> pour aucune, ou <code>zero</code> pour zéro).</p></div><div class=paragraph><p>Voici un exemple d’entrée pour une imprimante connectée à 19200 bps, sans parité, sur le troisième port série:</p></div><div class="literalblock programlisting"><div class=content><pre>printer:dv=/dev/ttyd2:br#19200:pa=none</pre></div></div></li><li><p>Connectez-vous à l’imprimante avec <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>. Entrez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip printer</span></code></pre></div></div><div class=paragraph><p>Si cette étape ne fonctionne pas, éditez le fichier <span class=filename>/etc/remote</span> à nouveau et essayez d’utiliser <span class=filename>/dev/cuaaN</span> au lieu de <span class=filename>/dev/ttydN</span>.</p></div></li><li><p>Envoyez des données à l’imprimante.</p><div class=ulist><ul><li><p>Si l’imprimante peut sortir du texte simple, alors utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>. Entrez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nv>$lptest</span></code></pre></div></div></li><li><p>Si l’imprimante comprend le PostScript® ou tout autre langage d’imprimante, envoyez-lui un petit programme. Entrez-le ligne à ligne et <em>très attentivement</em>, dans la mesure où les touches d’édition, comme retour-arrière, peuvent revêtir une signification particulière pour l’imprimante. Vous pourriez également avoir besoin d’un caractère de fin de fichier ("EOF") particulier pour que l’imprimante sache qu’elle a reçu tout le programme. Pour les imprimantes PostScript®, appuyez sur <code>CONTROL+D</code>.</p><div class=paragraph><p>Une autre manière de procéder est de placer le programme dans un fichier et d’entrer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=o>&gt;</span>fichier</code></pre></div></div><div class=paragraph><p>Où <em>fichier</em> est le nom du fichier contenant le programme. Après avoir envoyé le fichier avec <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>, appuyez sur la touche de fin de fichier appropriée.</p></div></li></ul></div></li></ol></div></div></div><div class=paragraph><p>Vous devriez voir quelque chose s’imprimer. Ne vous inquiétez pas si l’apparence du texte n’est pas satisfaisante; nous remédierons à ce genre de soucis plus tard.</p></div></div></div><div class=sect4><h5 id=printing-printcap>9.3.1.5. Mettre en place le gestionnaire d’impression: le fichier <span class=filename>/etc/printcap</span><a class=anchor href=#printing-printcap></a></h5><div class=paragraph><p>A ce stade, votre imprimante doit être branchée, votre noyau configuré pour communiquer avec elle (si cela est nécessaire); et vous avez réussi à faire parvenir des données simples à l’imprimante. Nous sommes maintenant prêts à paramétrer LPD pour qu’il contrôle l’accès à l’imprimante.</p></div><div class=paragraph><p>LPD se paramètre en éditant le fichier <span class=filename>/etc/printcap</span>. Le gestionnaire d’impression LPD le lit à chaque fois que le gestionnaire est solicité, donc les mises à jour du fichier sont immédiatement prises en compte.</p></div><div class=paragraph><p>Le format du fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> est explicite. Utilisez votre éditeur favori pour modifier <span class=filename>/etc/printcap</span>. Le format est identique aux autres fichiers de configuration comme <span class=filename>/usr/shared/misc/termcap</span> et <span class=filename>/etc/remote</span>. Pour obtenir des informations complètes concernant ce format, consultez <a href="https://man.freebsd.org/cgi/man.cgi?query=cgetent&amp;sektion=3&amp;format=html">cgetent(3)</a>.</p></div><div class=paragraph><p>Le paramétrage simple du gestionnaire d’impression s’effectue selon les étapes suivantes:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Choisissez un nom (et quelques alias appropriés) pour l’imprimante, et placez-les dans <span class=filename>/etc/printcap</span>; lisez la section <a href=#printing-naming>Nommer l’imprimante</a> pour plus d’informations sur le nommage.</p></li><li><p>Désactivez les pages d’en-tête (elles sont activées par défaut) en insérant le paramètre <code>sh</code>; lisez la section <a href=#printing-no-header-pages>Supprimer les pages d’en-tête</a> pour plus d’informations.</p></li><li><p>Créez un répertoire de file d’attente, et précisez son chemin d’accès avec le paramètre <code>sd</code>; lisez la section <a href=#printing-spooldir>Créer le répertoire de fil d’attente</a> pour obtenir plus d’informations.</p></li><li><p>Sélectionnez l’entrée <span class=filename>dev</span> à utiliser pour l’imprimante, et notez la dans <span class=filename>/etc/printcap</span> avec le paramètre <code>lp</code>; lisez la section <a href=#printing-device>Identifier le périphérique d’imprimante</a> pour obtenir plus d’informations. De plus, si l’imprimante est reliée par un port série, précisez les paramètres de communication avec le paramètre <code>ms#</code>, qui est détaillé dans la section <a href=#printing-commparam>Configurer les paramètres de communication du gestionnaire d’impression</a>.</p></li><li><p>Installez un filtre d’entrée sous forme de fichier texte simple; lisez la section <a href=#printing-textfilter>Installer le filtre texte</a> pour obtenir plus de détails.</p></li><li><p>Testez la configuration en imprimant quelque chose avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>. Vous trouverez plus de détails dans les sections <a href=#printing-trying>Tester l’impression</a> et <a href=#printing-troubleshooting>Résolution des problèmes</a>.</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les imprimantes basées sur un langage d’impression, telles les imprimantes PostScript®, ne peuvent imprimer du texte simple directement. La configuration simple esquissée ci-dessus et détaillée dans les sections suivantes présuppose que si vous installez ce genre d’imprimante vous n’imprimerez que des fichiers qu’elle peut comprendre.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Les utilisateurs s’attendent souvent à pouvoir imprimer du texte simple sur n’importe laquelle des imprimante installées sur votre système. Les applications qui s’en remettent à LPD pour imprimer s’y attendent en général elles aussi. Si vous installez ce genre d’imprimante et désirez pouvoir imprimer à la fois des travaux dans le langage de l’imprimante <em>et</em> des travaux en texte simple, vous êtes instamment prié d’ajouter une étape supplémentaire à la configuration simple esquissée ci-dessus: installez un programme de conversion automatique texte simple vers PostScript® (ou tout autre langage d’imprimante). La section <a href=#printing-advanced-if-conversion>Prendre en charge des travaux texte sur des imprimantes PostScript®</a> vous apprendra à le faire.</p></div><div class=sect5><h6 id=printing-naming>9.3.1.5.1. Nommer l’imprimante<a class=anchor href=#printing-naming></a></h6><div class=paragraph><p>La première étape (facile) est de choisir un nom pour l’imprimante. Que vous choisissiez un nom fonctionnel ou fantaisiste n’a aucune importance puisque vous pouvez également fournir une série d’alias.</p></div><div class=paragraph><p>Au moins l’une des imprimantes définies dans le fichier <span class=filename>/etc/printcap</span> devrait avoir pour alias <code>lp</code>. C’est le nom de l’imprimante par défaut. Si les utilisateurs n’ont pas positionné la variable d’environnement <code>PRINTER</code> et ne spécifient pas le nom d’une imprimante lorsqu’ils utilisent une ligne de commande relative à LPD, <code>lp</code> sera l’imprimante par défaut utilisée.</p></div><div class=paragraph><p>Par ailleurs, l’usage commun veut que le dernier alias d’une imprimante en soit une description complète, en incluant le fabricant et le modèle.</p></div><div class=paragraph><p>Une fois le nom et des alias communs choisis, placez-les dans le fichier <span class=filename>/etc/printcap</span>. Le nom de l’imprimante devrait commencer dans la colonne la plus à gauche. Séparez chaque alias par une barre verticale et mettez le caractère deux-points après le dernier alias.</p></div><div class=paragraph><p>Dans l’exemple suivant, nous commençons avec le squelette d’un <span class=filename>/etc/printcap</span> qui définit deux imprimantes (une Diablo 630 et une imprimante PostScript® laser Panasonic KX-P4455):</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose
#
rattan|line|diablo|lp|Diablo 630 Line Printer:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:</pre></div></div><div class=paragraph><p>Dans cet exemple, la première imprimante se nomme <code>rattan</code> et possède les alias suivants: <code>line</code>, <code>diablo</code>, <code>lp</code> et <code>Diablo 630 Line Printer</code>. Puisque l’alias <code>lp</code> lui est attribué, elle est également l’imprimante par défaut. La seconde s’appelle <code>bamboo</code> et possède les alias suivants: <code>ps</code>, <code>PS</code>, <code>S</code>, <code>panasonic</code> et <code>Panasonic KX-P4455 PostScript v51.4</code>.</p></div></div><div class=sect5><h6 id=printing-no-header-pages>9.3.1.5.2. Supprimer les pages d’en-tête<a class=anchor href=#printing-no-header-pages></a></h6><div class=paragraph><p>Par défaut, le gestionnaire d’impression LPD imprime une <em>page d’en-tête</em> pour chaque impression. Celle-ci mentionne le nom de l’utilisateur qui a demandé l’impression, la machine qui l’a envoyé, et le nom de l’impression, en grands et jolis caractères. Malheureusement, tout ce texte supplémentaire parasite le débogage d’une configuration simple de l’imprimante, aussi supprimerons-nous ces pages d’en-têtes.</p></div><div class=paragraph><p>Pour cela, ajoutez le paramètre <code>sh</code> à l’entrée de l’imprimante dans <span class=filename>/etc/printcap</span>. Voici un exemple de <span class=filename>/etc/printcap</span> où <code>sh</code> a été ajouté:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - no header pages anywhere
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:</pre></div></div><div class=paragraph><p>Observez la façon dont nous avons respecté le format correct: la première ligne commence dans la colonne la plus à gauche, et les lignes suivantes sont indentées. Toutes les lignes d’une entrée sauf la dernière se terminent par un antislash.</p></div></div><div class=sect5><h6 id=printing-spooldir>9.3.1.5.3. Créer le répertoire de file d’attente<a class=anchor href=#printing-spooldir></a></h6><div class=paragraph><p>La prochaine étape dans la configuration simple du gestionnaire d’impression consiste à créer un <em>répertoire de file d’attente</em>, c’est à dire un répertoire où les travaux vont demeurer jusqu’à ce qu’ils soient imprimés, et où un certain nombre d’autres fichiers nécessaires au gestionnaire d’impression prennent place.</p></div><div class=paragraph><p>A cause de la nature variable des répertoires de file d’attente, il est d’usage de les placer dans <span class=filename>/var/spool</span>. Il n’est pas non plus nécessaire de sauvegarder leur contenu. Les recréer est aussi simple que de faire un <a href="https://man.freebsd.org/cgi/man.cgi?query=mkdir&amp;sektion=1&amp;format=html">mkdir(1)</a>.</p></div><div class=paragraph><p>Il est également d’usage de créer le répertoire avec un nom identique à celui de l’imprimante, comme dans l’exemple ci-dessous:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/spool/nom-de-l-imprimante</span></code></pre></div></div><div class=paragraph><p>Toutefois, si votre réseau comporte beaucoup d’imprimantes, vous pouvez préférer placer les répertoires de file d’attente dans un unique répertoire que vous réserverez à l’impression avec LPD. C’est ce que nous allons faire pour les deux imprimantes de notre exemple, <code>rattan</code> et <code>bamboo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/spool/lpd</span>
<span class=c># mkdir /var/spool/lpd/rattan</span>
<span class=c># mkdir /var/spool/lpd/bamboo</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si la confidentialité des travaux imprimés par les utilisateurs vous importe, vous souhaiterez certainement protéger le répertoire de file d’attente afin qu’il ne soit pas accessible par tout le monde. Les répertoires de file d’attente doivent appartenir, être accessibles en lecture et écriture et pouvoir être parcourus par l’utilisateur <code>daemon</code> et le groupe <code>daemon</code>, et personne d’autre. C’est ce que nous allons faire pour les deux imprimantes de notre exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown daemon:daemon /var/spool/lpd/rattan</span>
<span class=c># chown daemon:daemon /var/spool/lpd/bamboo</span>
<span class=c># chmod 770 /var/spool/lpd/rattan</span>
<span class=c># chmod 770 /var/spool/lpd/bamboo</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Pour finir, vous devez avertir LPD de l’existence de ces répertoires en utilisant le fichier <span class=filename>/etc/printcap</span>. Vous spécifiez le chemin du répertoire file d’attente avec le paramètre <code>sd</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added spooling directories
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:</pre></div></div><div class=paragraph><p>Notez que le nom de l’imprimante commence dans la première colonne mais que toutes les autres entrées décrivant l’imprimante doivent être indentées et que chaque fin de ligne doit être protégée par un antislash.</p></div><div class=paragraph><p>Si vous ne précisez pas de répertoire de file d’attente avec <code>sd</code>, le gestionnaire d’impression utilisera <span class=filename>/var/spool/lpd</span> par défaut.</p></div></div><div class=sect5><h6 id=printing-device>9.3.1.5.4. Identifier le périphérique d’imprimante<a class=anchor href=#printing-device></a></h6><div class=paragraph><p>Dans la section Entrées des périphériques nous avons identifié l’entrée du répertoire <span class=filename>/dev</span> que FreeBSD utiliserait pour communiquer avec l’imprimante. Maintenant, nous allons passer cette information à LPD. Quand le gestionnaire d’impression aura une impression à effectuer, il ouvrira le périphérique spécifié au nom du programme de filtre (qui est responsable de la transmission des données à l’imprimante).</p></div><div class=paragraph><p>Positionnez l’entrée pour le chemin d’accès <span class=filename>/dev</span> dans le fichier <span class=filename>/etc/printcap</span> en utilisant le paramètre <code>lp</code>.</p></div><div class=paragraph><p>Dans notre exemple, supposons que <code>rattan</code> est sur le premier port parallèle, et que <code>bamboo</code> est sur un sixième port série; voici les ajouts à apporter à <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - identified what devices to use
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyd5:</pre></div></div><div class=paragraph><p>Si dans votre <span class=filename>/etc/printcap</span> vous ne précisez pas le paramètre <code>lp</code> pour une imprimante, LPD utilisera <span class=filename>/dev/lp</span> par défaut. A l’heure actuelle, il n’existe pas d’entrée <span class=filename>/dev/lp</span> sous FreeBSD.</p></div><div class=paragraph><p>Si l’imprimante que vous êtes en train d’installer est connectée à un port parallèle, vous pouvez directement vous rendre à la section <a href=#printing-textfilter>Installer le filtre texte</a>. Sinon, assurez-vous de suivre les instructions de la section qui suit.</p></div></div><div class=sect5><h6 id=printing-commparam>9.3.1.5.5. Configurer les paramètres de communication du gestionnaire d’impression<a class=anchor href=#printing-commparam></a></h6><div class=paragraph><p>Pour les imprimantes connectées au port série, LPD peut configurer la vitesse en bps, la parité, et d’autres paramètres de communication série, pour le compte du programme de filtre qui envoie les données à l’imprimante. C’est avantageux dans la mesure où:</p></div><div class=ulist><ul><li><p>Cela vous laisse essayer divers paramètres simplement en éditant le fichier <span class=filename>/etc/printcap</span>; vous n’avez pas besoin de recompiler le programme de filtre.</p></li><li><p>Cela permet au gestionnaire d’impression d’utiliser le même programme pour de multiples imprimantes qui peuvent avoir des paramètres de communication série différents.</p></li></ul></div><div class=paragraph><p>Les paramètres <span class=filename>/etc/printcap</span> suivants contrôlent les options de communication série pour le périphérique spécifié dans le paramètre <code>lp</code>:</p></div><div class=dlist><dl><dt class=hdlist1><code>br#vitesse-bps</code></dt><dd><p>Positionne la vitesse de transmission du périphérique à <em>vitesse-bps</em>, où <em>vitesse-bps</em> peut prendre l’une des valeurs suivantes: 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, ou 115200 bits par seconde.</p></dd><dt class=hdlist1><code>ms#stty-mode</code></dt><dd><p>Positionne les options du périphérique de terminal après l’avoir ouvert. <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> présente les options disponibles.</p></dd></dl></div><div class=paragraph><p>Quand LPD ouvre le périphérique spécifié par le paramètre <code>lp</code>, il positionne les caractéristiques de ce périphérique aux valeurs précisées par le paramètre <code>ms#</code>. Les modes suivants, détaillés dans <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> sont particulièrement intéressants: <code>parenb</code>, <code>parodd</code>, <code>cs5</code>, <code>cs6</code>, <code>cs7</code>, <code>cs8</code>, <code>cstopb</code>, <code>crtscts</code>, et <code>ixon</code>.</p></div><div class=paragraph><p>Peaufinons notre exemple pour l’imprimante qui est connectée au sixième port série. Nous allons paramétrer sa vitesse à 38400 bps. Quant au mode, nous allons spécifier aucune parité avec <code>-parenb</code>, des caractères 8 bits avec <code>cs8</code>, aucun contrôle modem avec <code>clocal</code> et un contrôle de flux matériel avec <code>crtscts</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyd5:ms#-parenb cs8 clocal crtscts:</pre></div></div></div><div class=sect5><h6 id=printing-textfilter>9.3.1.5.6. Installer le filtre texte<a class=anchor href=#printing-textfilter></a></h6><div class=paragraph><p>Nous sommes maintenant en mesure de dire à LPD quel filtre texte utiliser pour envoyer les travaux à l’imprimante. Un <em>filtre texte</em>, également connu sous le nom de <em>filtre d’entrée</em>, est un programme que LPD lance lorsqu’il a une impression à effectuer. Lorsque LPD exécute le filtre texte pour une imprimante, il redirige l’entrée standard du filtre sur le travail d’impression, et la sortie standard sur le fichier spécial de périphérique spécifié par le paramètre <code>lp</code>. On attend du filtre qu’il lise le travail d’impression sur son entrée standard, effectue les transformations nécessaires pour l’imprimante, et écrive le résultat sur sa sortie standard, qui sera imprimée. Pour plus d’informations sur les filtres texte, lisez la section <a href=#printing-advanced-filters>Filtres</a>.</p></div><div class=paragraph><p>Pour notre configuration simple de l’imprimante, le filtre texte peut être une petite procédure d’interpréteur de commandes qui ne fera qu’exécuter <code>/bin/cat</code> pour envoyer le travail d’impression à l’imprimante. Un autre filtre est livré avec FreeBSD, nommé <span class=filename>lpf</span>, qui se charge de faire des suppressions arrière et des soulignements pour les imprimantes qui ne sauraient pas gérer correctement ce genre de flux de caractères. Et bien sûr, vous pouvez utiliser un autre filtre, quel qu’il soit. Le filtre <span class=filename>lpf</span> est détaillé dans la section <a href=#printing-advanced-lpf>lpf: un filtre texte</a>.</p></div><div class=paragraph><p>Tout d’abord, composons le filtre <span class=filename>/usr/local/libexec/if-simple</span> qui sera un simple filtre texte. Ecrivez ceci avec votre éditeur de texte favori:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# if-simple - Simple text input filter for lpd
# Installed in /usr/local/libexec/if-simple
#
# Simply copies stdin to stdout.  Ignores all filter arguments.

/bin/cat  exit 0
exit 2</pre></div></div><div class=paragraph><p>Rendez le fichier exécutable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/if-simple</span></code></pre></div></div><div class=paragraph><p>Et avertissez LPD qu’il doit l’utiliser, en renseignant le paramètre <code>if</code> dans <span class=filename>/etc/printcap</span>. Nous l’ajouterons aux deux imprimantes utilisées jusqu’ici dans notre <span class=filename>/etc/printcap</span> d’exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added text filter
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\ :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyd5:ms#-parenb cs8 clocal crtscts:\
        :if=/usr/local/libexec/if-simple:</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vous trouverez une copie du filtre <span class=filename>if-simple</span> dans le répertoire <span class=filename>/usr/shared/examples/printing</span>.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_lancer_lpd>9.3.1.5.7. Lancer LPD<a class=anchor href=#_lancer_lpd></a></h6><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> se lance depuis <span class=filename>/etc/rc</span>, avec la variable de contrôle <code>lpd_enable</code>. Cette variable a <code>NO</code> pour valeur par défaut. Si vous ne l’avez pas déjà fait, ajoutez la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>à votre <span class=filename>/etc/rc.conf</span>, puis relancez votre machine, ou lancez simplement <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpd</span></code></pre></div></div></div><div class=sect5><h6 id=printing-trying>9.3.1.5.8. Tester la configuration<a class=anchor href=#printing-trying></a></h6><div class=paragraph><p>Vous avez achevé la configuration simple de LPD. Malheureusement, les félicitations ne sont pas encore à l’ordre du jour, puisque nous devons encore tester la configuration et résoudre tout problème. Pour tester la configuration, essayez d’imprimer quelque chose. Pour imprimer avec le système LPD, vous devez utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, qui soumet un travail d’impression.</p></div><div class=paragraph><p>Vous pouvez combiner <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> au programme <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>, que nous avons présenté à la section <a href=#printing-testing>Vérifier la communication avec l’imprimante</a>, pour produire du texte de test.</p></div><div class=paragraph><p><em>Pour tester la configuration simple de LPD</em></p></div><div class=paragraph><p>Entrez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptest 20 5 | lpr -Pnom-de-l-imprimante</span></code></pre></div></div><div class=paragraph><p>Où <em>nom-de-l-imprimante</em> représente le nom (ou l’alias) d’une imprimante tel que spécifié dans <span class=filename>/etc/printcap</span>. Pour tester l’imprimante par défaut, tapez <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> sans aucun argument <code>-P</code>. Encore une fois, si vous faites ce test avec une imprimante qui s’attend à recevoir du PostScript®, envoyez un programme PostScript® au lieu d’employer <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>. Vous pouvez le faire en plaçant le programme dans un fichier et en entrant <code>lpr fichier</code>.</p></div><div class=paragraph><p>Pour une imprimante PostScript®, vous devriez obtenir le résultat du programme. Si vous utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a>, alors votre sortie devrait ressembler à ça:</p></div><div class="literalblock programlisting"><div class=content><pre>!&#34;#$%&#39;()*+,-./01234
&#34;#$%&#39;()*+,-./012345
#$%&#39;()*+,-./0123456
$%&#39;()*+,-./01234567
%&#39;()*+,-./012345678</pre></div></div><div class=paragraph><p>Pour tester l’imprimante plus encore, téléchargez des programmes (pour les imprimantes basées sur un langage spécifique) plus longs, ou lancez <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> avec des arguments différents. Par exemple, <code>lptest 80 60</code> produira 60 lignes de 80 caractères chacune.</p></div><div class=paragraph><p>Si l’impression ne fonctionne pas, lisez la section <a href=#printing-troubleshooting>Résolution des problèmes</a>.</p></div></div></div></div></div><div class=sect2><h3 id=printing-advanced>9.4. Configuration avancée de l’imprimante<a class=anchor href=#printing-advanced></a></h3><div class=paragraph><p>Cette section décrit les filtres à utiliser pour imprimer des fichiers au formatage particulier, des pages d’en-tête, pour imprimer en réseau, et pour restreindre et comptabiliser l’utilisation de l’imprimante.</p></div><div class=sect3><h4 id=printing-advanced-filter-intro>9.4.1. Les filtres<a class=anchor href=#printing-advanced-filter-intro></a></h4><div class=paragraph><p>Bien que LPD gère les protocoles réseaux, les files d’attente, le contrôle d’accès et d’autres aspects de l’impression, la plus grande partie du <em>véritable</em> travail intervient dans les <em>filtres</em>. Les filtres sont des programmes qui communiquent avec l’imprimante et gèrent ses dépendances matérielles ainsi que ses besoins particuliers. Dans la configuration simple de l’imprimante, nous avons installé un filtre texte simple- un filtre particulièrement basique qui devrait fonctionner avec la plupart des imprimantes (voir la section <a href=#printing-textfilter>Installer le filtre texte</a>).</p></div><div class=paragraph><p>Toutefois, afin de profiter de la conversion de format, de la comptabilisation de l’utilisation de l’imprimante, de particularités matérielles, et ainsi de suite, il vous faut comprendre le fonctionnement des filtres. En dernier ressort, il incombera au filtre de gérer ces aspects. Et la mauvaise nouvelle, c’est que la plupart du temps, c’est <em>vous</em> qui devrez produire ces filtres vous-même. La bonne nouvelle, c’est que beaucoup existent déjà et que, sinon, ils sont en général assez faciles à écrire.</p></div><div class=paragraph><p>Par ailleurs, il en est un livré avec FreeBSD, <span class=filename>/usr/libexec/lpr/lpf</span>, qui fonctionne avec beaucoup d’imprimantes capables d’imprimer du texte brut. (Il gère les retours arrière et les tabulations dans le fichier, effectue une comptabilisation, mais c’est à peu près tout). Vous trouverez également d’autres filtres et composants de filtres dans le catalogue des logiciels portés de FreeBSD.</p></div><div class=paragraph><p>Voici ce que vous trouverez dans cette section:</p></div><div class=ulist><ul><li><p>La section <a href=#printing-advanced-filters>Fonctionnement des filtres</a> tâche de donner une vue générale du rôle des filtres dans le processus d’impression. Il vous faut lire cette section pour comprendre ce qui se passe "sous le capot" lorsque LPD utilise des filtres. Cette connaissance vous permettra d’anticiper et de résoudre les problèmes que vous pourriez rencontrer quand vous installerez de plus en plus de filtres pour chacune de vos imprimantes.</p></li><li><p>LPD s’attend à ce que toutes les imprimantes sachent imprimer du texte brut par défaut. Cela pose un problème pour les imprimantes PostScript® (ou les imprimantes basées sur un autre langage) qui ne peut pas imprimer du texte brut directement. La section <a href=#printing-advanced-if-conversion>Gérer les travaux d’impression de texte brut sur des imprimantes PostScript®</a> vous indique la marche à suivre pour résoudre ce problème. Vous devrez lire cette section si vous avez une imprimante PostScript®.</p></li><li><p>PostScript® est un format de sortie courant pour beaucoup d’applications. Certaines personnes écrivent même du code PostScript® directement. Malheureusement, les imprimantes PostScript® sont onéreuses. La section <a href=#printing-advanced-ps>Emuler du PostScript® sur les imprimantes non-PostScript®</a> vous indiquera comment modifier un filtre texte pour qu’une imprimante <em>non-PostScript®</em> accepte et imprime du PostScript®. Vous devrez lire cette section si vous ne disposez pas d’une imprimante PostScript®.</p></li><li><p>La section <a href=#printing-advanced-convfilters>Filtres de conversion</a> vous apprendra à automatiser la conversion de formats de fichiers spécifiques, comme des graphiques ou des données de composition, en formats compréhensibles par l’imprimante. Après avoir lu cette section, vous serez en mesure de configurer vos imprimantes de telle sorte que vos utilisateurs pourront entrer la commande <code>lpr -t</code> pour imprimer du troff, ou <code>lpr -d</code> pour imprimer le format DVI produit par TeX, ou <code>lpr -v</code> pour imprimer des images en mode point, etc. Nous recommandons la lecture de cette section.</p></li><li><p>La section <a href=#printing-advanced-of>Filtres de sortie</a> révèle tout d’une fonctionnalité peu utilisée de LPD: les filtres de sortie. A moins que vous n’imprimiez des pages d’en-têtes (voir la section <a href=#printing-advanced-header-pages>Pages d’en-tête</a>), vous pouvez probablement complètement ignorer cette section.</p></li><li><p>La section <a href=#printing-advanced-lpf>lpf: un filtre texte</a> détaille <code>lpf</code>, un filtre texte destiné aux imprimantes en ligne (et aux imprimantes laser se comportant comme telles) plutôt complet malgré sa simplicité, et livré avec FreeBSD. Si vous avez besoin de mettre rapidement en place la comptabilisation de l’utilisation de l’imprimante pour du texte brut, ou si vous avez une imprimante qui fume lorsqu’elle voit passer des caractères de retour arrière, vous devez vraiment penser à <code>lpf</code>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Une copie des différents scripts présentés ci-dessous se trouve dans le répertoire <span class=filename>/usr/shared/examples/printing</span>.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=printing-advanced-filters>9.4.1.1. Fonctionnement des filtres<a class=anchor href=#printing-advanced-filters></a></h5><div class=paragraph><p>Comme expliqué précédemment, un filtre est un programme exécutable lancé par LPD pour gérer la partie de la communication avec l’imprimante qui est dépendante du périphérique.</p></div><div class=paragraph><p>Lorsque LPD veut imprimer un fichier d’un travail d’impression, il lance un programme de filtre. Il redirige l’entrée standard du filtre sur le fichier à imprimer, sa sortie standard vers l’imprimante, et l’erreur standard vers le fichier journal des erreurs (spécifié dans le paramètre <code>lf</code> du fichier <span class=filename>/etc/printcap</span>, ou <span class=filename>/dev/console</span> par défaut).</p></div><div class=paragraph><p>Le filtre lancé par LPD ainsi que les paramètres qui lui sont donnés dépendent de ce qui est placé dans le fichier <span class=filename>/etc/printcap</span> et des paramètres que l’utilisateur a passé sur la ligne de commande <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> pour ce travail d’impression. Par exemple, si l’utilisateur a entré <code>lpr -t</code>, LPD aurait lancé le filtre troff, précisé par la paramètre <code>tf</code> pour l’imprimante de destination. Si l’utilisateur veut imprimer du texte brut, il lancerait le filtre <code>if</code> (c’est vrai la plupart du temps: lisez la section <a href=#printing-advanced-of>Filtres de sortie</a> pour plus de détails).</p></div><div class=paragraph><p>Il existe trois types de filtres que vous pouvez spécifier dans <span class=filename>/etc/printcap</span>:</p></div><div class=ulist><ul><li><p>Le <em>filtre texte</em>, confusément appelé <em>filtre d’entrée</em> dans la documentation LPD, gère l’impression de texte classique. Considérez-le comme le filtre par défaut. LPD s’attend à ce que toutes les imprimantes sachent imprimer du texte brut par défaut, et c’est au filtre texte de s’assurer que les retours arrière, tabulations et autres caractères spéciaux ne trompent pas l’imprimante. Si vous êtes dans un environnement où il vous faut rendre compte de l’utilisation de l’imprimante, le filtre texte doit également comptabiliser les pages imprimées, généralement en comptant le nombre de lignes imprimées et en le comparant avec le nombre de lignes par page supporté par l’imprimante. Le filtre texte est exécuté avec la liste de paramètres suivante:</p><div class=paragraph><p><code>nom_du_filtre</code> [ -c ] -w <em>largeur</em> -l <em>hauteur</em> -i <em>indentation</em> -n <em>utilisateur</em> -h <em>machine</em> <em>fichier_comptabilité</em></p></div><div class=paragraph><p>où</p></div><div class=dlist><dl><dt class=hdlist1><code>-c</code></dt><dd><p>apparaît si le travail d’impression est lancé par la commande <code>lpr -l</code></p></dd><dt class=hdlist1><em>largeur</em></dt><dd><p>est la valeur du paramètre <code>pw</code> ("page width", pour "largeur de page") spécifié dans <span class=filename>/etc/printcap</span>, et possédant la valeur par défaut 132.</p></dd><dt class=hdlist1><em>hauteur</em></dt><dd><p>est la valeur du paramètre <code>pl</code> ("page length", pour "hauteur de page"), par défaut: 66.</p></dd><dt class=hdlist1><em>indentation</em></dt><dd><p>est le nombre d’indentations inséré par <code>lpr -i</code>, par défaut: 0.</p></dd><dt class=hdlist1><em>utilisateur</em></dt><dd><p>est le nom du compte de l’utilisateur imprimant le fichier.</p></dd><dt class=hdlist1><em>machine</em></dt><dd><p>est le nom de la machine depuis laquelle le travail d’impression a été soumis.</p></dd><dt class=hdlist1><em>fichier_comptabilité</em></dt><dd><p>est le nom du fichier de comptabilisation spécifié par le paramètre <code>af</code>.</p></dd></dl></div></li><li><p>Un <em>filtre de conversion</em> convertit un format de fichier spécifique en un autre que l’imprimante saura imprimer sur papier. Par exemple, des données de composition ditroff ne peuvent être imprimées directement, mais il vous est possible d’installer un filtre de conversion ditroff afin de convertir ces données ditroff en une forme que l’imprimante sait ingérer et imprimer. La section <a href=#printing-advanced-convfilters>Filtres de conversion</a> vous dira tout sur ce sujet. Les filtres de conversion doivent également tenir des statistiques, si vous avez besoin de comptabiliser les impressions. Les filtres de conversion sont lancés avec les paramètres suivants:</p><div class=paragraph><p><code>nom-du-filtre</code> -x <em>largeur-en-pixels</em> -y <em>hauteur-en-pixels</em> -n <em>login</em> -h <em>hôte</em> <em>fichier_comptabilité</em></p></div><div class=paragraph><p>où <em>largeur-en-pixels</em> est la valeur du paramètre <code>px</code> (0 par défaut) et <em>hauteur-en-pixels</em> est la valeur du paramètre <code>py</code> (0 par défaut).</p></div></li><li><p>Le <em>filtre de sortie</em> n’est utilisé que s’il n’y a pas de filtre texte, ou si les pages d’en-tête ont été activées. D’après notre expérience, les filtres de sortie sont rarement employés. La section <a href=#printing-advanced-of>Filtres de sortie</a> les détaillera. Un filtre de sortie ne prend que deux paramètres:</p><div class=paragraph><p><code>nom-du-filtre</code> -w <em>largeur</em> -l <em>hauteur</em></p></div><div class=paragraph><p>qui sont identiques aux paramètres <code>-w</code> et <code>-l</code> des filtres textes.</p></div></li></ul></div><div class=paragraph><p>Les filtres doivent également <em>retourner</em> avec le code de retour suivant:</p></div><div class=dlist><dl><dt class=hdlist1>exit 0</dt><dd><p>Si le filtre a imprimé avec succès le fichier.</p></dd><dt class=hdlist1>exit 1</dt><dd><p>Si le filtre n’a pu imprimer le fichier, mais désire que LPD essaie de l’imprimer à nouveau. LPD relancera un filtre s’il retourne avec ce code.</p></dd><dt class=hdlist1>exit 2</dt><dd><p>Si le filtre n’a pu imprimer le fichier et ne veut pas que LPD retente l’impression. LPD rejettera le fichier.</p></dd></dl></div><div class=paragraph><p>Le filtre texte livré avec FreeBSD, <span class=filename>/usr/libexec/lpr/lpf</span>, tire parti des paramètres de largeur et hauteur de page pour savoir quand envoyer une instruction de saut de page et comment comptabiliser l’utilisation de l’imprimante. Il utilise les paramètres nom d’utilisateur, nom de machine, et fichier de comptabilisation pour enregistrer les entrées concernant la consommation.</p></div><div class=paragraph><p>Si vous recherchez des filtres, prenez garde à ce qu’ils soient compatibles avec LPD. Si c’est le cas, ils doivent se conformer à la liste de paramètres décrite ci-dessus. Si vous songez à écrire des filtres à usage général, alors faites en sorte qu’ils se conforment à ces mêmes listes de paramètres et de codes de retour.</p></div></div><div class=sect4><h5 id=printing-advanced-if-conversion>9.4.1.2. Gérer les travaux d’impression de texte brut sur des imprimantes PostScript®<a class=anchor href=#printing-advanced-if-conversion></a></h5><div class=paragraph><p>Si vous êtes l’unique utilisateur de votre ordinateur et de votre imprimante PostScript® (ou basée sur un autre langage), et que vous promettez de ne jamais envoyer de texte brut à votre imprimante et de ne jamais utiliser les fonctionnalités des divers programmes qui voudraient lui en envoyer, alors vous pouvez tout à fait passer cette section l’esprit tranquille.</p></div><div class=paragraph><p>Toutefois, si vous désirez envoyer du PostScript® et du texte brut à l’imprimante, alors vous êtes instamment priés de compléter la configuration de votre imprimante. Pour ce faire, nous chargerons le filtre texte de détecter si le travail d’impression est du texte brut ou du PostScript®. Tous les travaux d’impression PostScript® doivent débuter par <code>%!</code> (en ce qui concerne les autres langages, référez-vous à la documentation de l’imprimante). Si ces deux caractères sont les deux premiers du travail d’impression, il s’agit de PostScript® et le reste du travail d’impression peut être passé directement à l’imprimante. Dans le cas contraire, alors le filtre convertit le texte en PostScript® et imprime le résultat.</p></div><div class=paragraph><p>Comment procéder?</p></div><div class=paragraph><p>Si vous disposez d’une imprimante série, une bonne façon de faire est d’installer <code>lprps</code>. Il s’agit d’un filtre d’impression PostScript® qui assure une communication en duplex avec l’imprimante. Il met à jour le fichier d’état de l’imprimante avec des informations détaillées que cette dernière lui fournit, de sorte que les utilisateurs et les administrateurs puissent connaître précisément l’état de l’imprimante (par exemple <code>niveau de toner bas</code> ou <code>bourrage papier</code>). Mais plus important encore, il inclut un programme nommé <code>psif</code> qui détecte si le travail d’impression qui vient d’arriver est du texte brut et lance <code>textps</code> (un autre programme fourni avec <code>lprps</code>) pour le convertir en PostScript®. Il utilise alors <code>lprps</code> pour envoyer le travail d’impression à l’imprimante.</p></div><div class=paragraph><p><code>lprps</code> fait partie du catalogue des logiciels portés FreeBSD (lisez la section <a href=./#ports>Le catalogue des logiciels portés</a>). Vous pouvez installer un des deux logiciels portés <a class=package href=https://cgit.freebsd.org/ports/tree/print/lprps-a4/>print/lprps-a4</a> et <a class=package href=https://cgit.freebsd.org/ports/tree/print/lprps-letter/>print/lprps-letter</a> en fonction du format de papier utilisé. Après avoir installé <code>lprps</code>, précisez simplement le chemin vers le programme <code>psif</code> qui fait partie de <code>lprps</code>. Si vous avez installé <code>lprps</code> en recourant au catalogue des logiciels portés, placez les valeurs suivantes pour l’entrée de l’imprimante série PostScript® dans <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/psif:</pre></div></div><div class=paragraph><p>Vous devrez également renseigner le paramètre <code>rw</code> qui indique à LPD de requérir l’imprimante en mode lecture/écriture.</p></div><div class=paragraph><p>Si vous disposez d’une imprimante PostScript® parallèle (et ne pouvez donc pas utiliser la communication en duplex avec l’imprimante dont a besoin <code>lprps</code>), vous pouvez recourir à la procédure suivante en tant que filtre texte:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psif - Imprime du PostScript ou du texte brut sur une imprimante PostScript
#  Version script; CECI N&#39;EST PAS la version fournie avec lprps
#  Fichier /usr/local/libexec/psif
#

IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

if [ &#34;$first_two_chars&#34; = &#34;%!&#34; ]; then
    #
    #  Travail PostScript, l&#39;imprimer.
    #
    echo &#34;$first_line&#34;  cat  printf &#34;\004&#34;  exit 0
    exit 2
else
    #
    #  Texte brut, le convertir, puis l&#39;imprimer.
    #
    ( echo &#34;$first_line&#34;; cat ) | /usr/local/bin/textps  printf &#34;\004&#34;  exit 0
    exit 2
fi</pre></div></div><div class=paragraph><p>Dans la procédure ci-dessus, <code>textps</code> est un programme que nous avons installé séparément pour convertir du texte en PostScript®. Vous pouvez recourir à n’importe quel programme texte-vers-PostScript®, selon votre désir. Le catalogue des logiciels portés de FreeBSD (voir la section <a href=./#ports>Le catalogue des logiciels portés</a>) comprend un programme de conversion texte-vers-PostScript® complet nommée <code>a2ps</code>, qui pourrait vous intéresser.</p></div></div><div class=sect4><h5 id=printing-advanced-ps>9.4.1.3. Emuler du PostScript® sur les imprimantes non-PostScript®<a class=anchor href=#printing-advanced-ps></a></h5><div class=paragraph><p>PostScript® est le standard <em>de fait</em> pour l’impression et la composition de haute qualité. Cependant, PostScript® est un standard <em>onéreux</em>. Heureusement, Aladdin Enterprises propose un succédané gratuit de PostScript® nommé Ghostscript qui fonctionne sous FreeBSD. Ghostscript peut lire la majorité des fichiers PostScript® et peut produire leurs pages sur une diversité de périphériques, incluant beaucoup de marques d’imprimantes non-PostScript®. En installant Ghostscript et en recourant à un filtre texte spécial, vous pouvez obtenir de votre imprimante non-PostScript® qu’elle se comporte comme une véritable imprimante PostScript®.</p></div><div class=paragraph><p>Ghostscript fait partie du catalogue des logiciels portés, de nombreuses versions sont disponibles, la version la plus couramment utilisée est <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript-gpl/>print/ghostscript-gpl</a>.</p></div><div class=paragraph><p>Pour émuler du PostScript®, il nous faut faire en sorte que le filtre texte détecte s’il imprime un fichier PostScript®. Si ce n’est pas le cas, alors le filtre doit passer le fichier directement à l’imprimante; sinon il recourra à Ghostscript pour tout d’abord le convertir dans un format que l’imprimante saura interpréter.</p></div><div class=paragraph><p>Voici un exemple: la procédure suivante est un filtre texte pour les imprimantes Hewlett Packard Deskjet 500. Pour d’autres modèles, changez le paramètre <code>-sDEVICE</code> de la commande <code>gs</code> (Ghostscript). (Entrez <code>gs -h</code> pour obtenir une liste des périphériques reconnus par l’installation actuelle de Ghostscript).</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  ifhp - Imprime du PostScript émulé par Ghostscript sur une DeskJet 500
#  Fichier /usr/local/libexec/ifhp

#
#  Traite LF comme CR+LF (pour éviter l&#39;&#34;effet d&#39;escalier&#34; sur les
#  imprimantes HP/PCL):
#
printf &#34;\033k2G&#34; || exit 2

#
#  Lit les deux premiers caractères du fichier
#
IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

if [ &#34;$first_two_chars&#34; = &#34;%!&#34; ]; then
    #
    #  Si c&#39;est du PostScript; utiliser Ghostscript pour le convertir et l&#39;imprimer
    #
    /usr/local/bin/gs -dSAFER -dNOPAUSE -q -sDEVICE=djet500 \
      -sOutputFile=- -  exit 0
else
    #
    #  Texte brut ou HP/PCL, donc impression directe; effectuer un
    #  saut de page à la fin pour éjecter la dernière page.
    #
    echo &#34;$first_line&#34;  cat  printf &#34;\033l0H&#34;
exit 0
fi

exit 2</pre></div></div><div class=paragraph><p>Pour finir, vous devez communiquer à LPD le filtre utilisé en positionnant le paramètre <code>if</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/ifhp:</pre></div></div><div class=paragraph><p>Voilà. Vous pouvez entrer <code>lpr texte.simple</code> et <span class=filename>lpr
peuimporte.ps</span>, et chacune des deux commandes devrait imprimer avec succès.</p></div></div><div class=sect4><h5 id=printing-advanced-convfilters>9.4.1.4. Filtres de conversion<a class=anchor href=#printing-advanced-convfilters></a></h5><div class=paragraph><p>Après avoir mené à bien la configuration basique décrite à la section <a href=#printing-simple>Configuration simple de l’imprimante</a>, la première chose que vous souhaiterez probablement faire sera d’installer des filtres de conversion pour vos formats de fichiers favoris (le simple texte ASCII mis à part).</p></div><div class=sect5><h6 id=_pourquoi_installer_des_filtres_de_conversion>9.4.1.4.1. Pourquoi installer des filtres de conversion?<a class=anchor href=#_pourquoi_installer_des_filtres_de_conversion></a></h6><div class=paragraph><p>Les filtres de conversion facilitent l’impression de différentes sortes de fichiers. Par exemple, supposons que nous travaillions énormément avec le système de composition TeX, et que nous ayons une imprimante PostScript®. Chaque fois que nous générerons un fichier DVI à partir de TeX, nous ne pouvons l’imprimer directement avant d’avoir converti ce fichier DVI en PostScript®. La séquence de commandes serait la suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dvips seaweed-analysis.dvi
% lpr seaweed-analysis.ps</code></pre></div></div><div class=paragraph><p>En installant un filtre de conversion pour fichiers DVI, nous pouvons à chaque fois nous passer de l’étape de conversion manuelle en chargeant LPD de le faire à notre place. Maintenant, à chaque fois que nous avons un fichier DVI, nous ne sommes plus qu’à un pas de l’impression:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-d</span> seaweed-analysis.dvi</code></pre></div></div><div class=paragraph><p>Nous faisons en sorte que LPD se charge de la conversion du fichier DVI à notre place en positionnant l’option <code>-d</code>. La section <a href=#printing-lpr-options-format>Options de conversion et de formatage</a> donne la liste des options de conversion.</p></div><div class=paragraph><p>Pour chacune des options de conversion que vous voulez faire accepter par une imprimante, installez un <em>filtre de conversion</em> et indiquez son chemin d’accès dans <span class=filename>/etc/printcap</span>. Un filtre de conversion ressemble au filtre texte de notre configuration de base (voir la section <a href=#printing-textfilter>Installer le filtre texte</a>), à ceci près qu’au lieu d’imprimer du texte brut, le filtre convertit le fichier en un format compréhensible par l’imprimante.</p></div></div><div class=sect5><h6 id=_quels_filtres_de_conversion_dois_je_installer>9.4.1.4.2. Quels filtres de conversion dois-je installer?<a class=anchor href=#_quels_filtres_de_conversion_dois_je_installer></a></h6><div class=paragraph><p>Vous devez installer les filtres de conversion que vous vous attendez à utiliser. Si vous imprimez beaucoup de données DVI, alors un filtre de conversion DVI est dans la logique des choses. Si vous devez imprimer beaucoup de troff, alors vous aurez sûrement besoin d’un filtre troff.</p></div><div class=paragraph><p>Le tableau suivant récapitule les filtres avec lesquels LPD fonctionne, leurs paramètres <span class=filename>/etc/printcap</span>, et comment les invoquer avec la <code>lpr</code>:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Type de fichier</th><th class="tableblock halign-left valign-top">paramètre /etc/printcap</th><th class="tableblock halign-left valign-top">option lpr</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cifplot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-c</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DVI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>df</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-d</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>plot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-g</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ditroff</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>nf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-n</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>code FORTRAN</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-f</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>troff</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>tf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-f</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>image en mode point</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>vf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-v</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>texte brut</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>if</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>aucune, <code>-p</code>, or <code>-l</code></p></td></tr></tbody></table><div class=paragraph><p>Dans notre exemple, utiliser <code>lpr -d</code> veut dire que l’imprimante a besoin du paramètre <code>df</code> dans l’entrée <span class=filename>/etc/printcap</span> la concernant.</p></div><div class=paragraph><p>Aussi fortement que certains puissent s’en émouvoir, des formats comme le code FORTRAN ou le plot sont probablement obsolètes. Sur votre site, vous pouvez attribuer de nouvelles significations à ces options ou à toute autre option de formatage en installant simplement des filtres personnalisés. Par exemple, supposons que vous aimeriez imprimer des fichiers Printerleaf directement (fichiers issus du programme de publication assistée par ordinateur Interleaf), mais jamais de fichiers plot. Vous pourriez alors installer un filtre de conversion Printerleaf sous le paramètre <code>gf</code> et ensuite informer vos utilisateurs que <code>lpr -g</code> veut dire "imprimer des fichiers Printerleaf".</p></div></div><div class=sect5><h6 id=_installer_des_filtres_de_conversion>9.4.1.4.3. Installer des filtres de conversion<a class=anchor href=#_installer_des_filtres_de_conversion></a></h6><div class=paragraph><p>Etant donné que les filtres de conversion sont des applications qui ne font pas partie du système FreeBSD de base, vous devriez les installer dans <span class=filename>/usr/local</span>. Le répertoire <span class=filename>/usr/local/libexec</span> est une destination de choix, car ce sont des programmes spécialisés que seul LPD lancera; les utilisateurs ordinaires ne devraient jamais avoir à les lancer.</p></div><div class=paragraph><p>Pour activer un filtre de conversion, précisez son chemin d’accès dans le paramètre relatif à l’imprimante de destination dans <span class=filename>/etc/printcap</span>.</p></div><div class=paragraph><p>Dans notre exemple, nous allons ajouter le filtre de conversion DVI pour l’imprimante nommée <code>bamboo</code>. Revoici le fichier <span class=filename>/etc/printcap</span> d’exemple, avec le nouveau paramètre <code>df</code> pour l’imprimante <code>bamboo</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine rose - ajout du filtre df pour bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyd5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Le filtre DVI est une procédure nommée <span class=filename>/usr/local/libexec/psdf</span>. En voici le contenu:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psdf - filtre DVI vers imprimante PostScript
#  Fichier /usr/local/libexec/psdf
#
# Appelé par lpd quand l&#39;utilisateur lance lpr -d
#
exec /usr/local/bin/dvips -f | /usr/local/libexec/lprps &#34;$@&#34;</pre></div></div><div class=paragraph><p>Cette procédure lance <code>dvips</code> en mode filtre (cela correspond au paramètre <code>-f</code>) sur l’entrée standard, qui est le travail d’impression à exécuter. Ensuite, elle lance le filtre pour imprimante PostScript® <code>lprps</code> (voir la section <a href=#printing-advanced-if-conversion>Gérer les travaux d’impression de texte brut sur des imprimantes PostScript®</a>) avec les paramètres que LPD lui a passés. Le programme <code>lprps</code> utilisera ces paramètres pour comptabiliser les pages imprimées.</p></div></div><div class=sect5><h6 id=_exemples_de_filtre_de_conversion_supplémentaires>9.4.1.4.4. Exemples de filtre de conversion supplémentaires<a class=anchor href=#_exemples_de_filtre_de_conversion_supplémentaires></a></h6><div class=paragraph><p>Il n’existe pas de procédure figée pour l’installation des filtres de conversion, des exemples fonctionnels sont présentés dans cette section. Inspirez-vous de ces exemples pour créer vos propres filtres. Utilisez les tels quels s’il s’avèrent adéquats.</p></div><div class=paragraph><p>Cet exemple présente un filtre de conversion d’image en mode point (en fait un fichier GIF) pour une imprimante Hewlett-Packard LaserJet III-Si:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpvf - Convertit des fichiers GIF en HP/PCL, puis les imprime
#  Fichier /usr/local/libexec/hpvf

PATH=/usr/X11R6/bin:$PATH; export PATH
giftopnm | ppmtopgm | pgmtopbm | pbmtolj -resolution 300 \
     exit 0 \
    || exit 2</pre></div></div><div class=paragraph><p>Son fonctionnement est le suivant: il convertit le fichier GIF en un format portable universel, puis en format portable en niveau de gris, et ensuite en bitmap portable, qu’il convertit enfin en données compatibles LaserJet/PCL.</p></div><div class=paragraph><p>Voici le <span class=filename>/etc/printcap</span> comportant une entrée pour une imprimante recourant au filtre ci-dessus:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sh:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:\
        :vf=/usr/local/libexec/hpvf:</pre></div></div><div class=paragraph><p>La procédure suivante est un filtre de conversion de données troff du système de composition groff pour l’imprimante PostScript® <code>bamboo</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  pstf - Convertit des données troff de groff en PS, puis imprime.
#  Fichier /usr/local/libexec/pstf
#
exec grops | /usr/local/libexec/lprps &#34;$@&#34;</pre></div></div><div class=paragraph><p>La procédure ci-dessus emploie de nouveau <code>lprps</code> pour gérer la communication avec l’imprimante. S’il s’agissait d’une imprimante sur port parallèle, nous utiliserions plutôt la procédure suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  pstf - Convertit des données troff de groff en PS, puis imprime.
#  Fichier /usr/local/libexec/pstf
#
exec grops</pre></div></div><div class=paragraph><p>C’est tout. Voici l’entrée qu’il faut ajouter dans <span class=filename>/etc/printcap</span> pour activer le filtre:</p></div><div class="literalblock programlisting"><div class=content><pre>:tf=/usr/local/libexec/pstf:</pre></div></div><div class=paragraph><p>Voici un exemple qui pourrait faire rougir les vieux briscards de FORTRAN. C’est un filtre de code FORTRAN pour toute imprimante sachant imprimer du texte brut. Nous l’installerons pour l’imprimante <code>teak</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# hprf - filtre texte FORTRAN pour LaserJet 3si:
# Fichier /usr/local/libexec/hprf
#

printf &#34;\033k2G&#34;  fpr  printf &#34;\033l0H&#34;
 exit 0
exit 2</pre></div></div><div class=paragraph><p>Et nous ajouterons cette ligne dans <span class=filename>/etc/printcap</span> pour l’imprimante <code>teak</code> afin d’activer le filtre:</p></div><div class="literalblock programlisting"><div class=content><pre>:rf=/usr/local/libexec/hprf:</pre></div></div><div class=paragraph><p>Voici un dernier exemple, quelque peu complexe. Nous allons ajouter un filtre DVI pour l’imprimante LaserJet <code>teak</code> présentée ci-dessus. Tout d’abord, la partie facile: mettre à jour <span class=filename>/etc/printcap</span> avec l’emplacement du filtre DVI:</p></div><div class="literalblock programlisting"><div class=content><pre>:df=/usr/local/libexec/hpdf:</pre></div></div><div class=paragraph><p>Et maintenant, la partie difficile: écrire le filtre. Pour cela, nous avons besoin d’un programme de conversion DVI-vers-LaserJet/PCL. Le catalogue des logiciels portés (voyez la section <a href=./#ports>Le catalogue des logiciels portés</a>) en possède un: <a class=package href=https://cgit.freebsd.org/ports/tree/print/dvi2xx/>print/dvi2xx</a>. Installer ce logiciel porté nous fournira le programme dont nous avons besoin, <code>dvilj2p</code>, qui convertit le DVI en code compatible LaserJet IIp, LaserJet III et LaserJet 2000.</p></div><div class=paragraph><p>L’utilitaire <code>dvilj2p</code> rend le filtre <code>hpdf</code> assez complexe, parce que <code>dvilj2p</code> ne sait pas lire l’entrée standard. Il lui faut un nom de fichier. Pire encore, le nom du fichier doit se terminer par <span class=filename>.dvi</span>, ce qui rend l’utilisation de <span class=filename>/dev/fd/0</span> pour l’entrée standard problématique. Nous pouvons contourner cette difficulté en créant un lien symbolique temporaire (se terminant par <span class=filename>.dvi</span>) pointant vers <span class=filename>/dev/fd/0</span>, obligeant ainsi <code>dvilj2p</code> à lire l’entrée standard.</p></div><div class=paragraph><p>Le seul petit accroc restant est que nous ne pouvons pas utiliser <span class=filename>/tmp</span> pour le lien temporaire. Les liens symboliques ont pour propriétaire l’utilisateur et le group <code>bin</code>. Le filtre est lancé sous l’utilisateur <code>daemon</code>. Et le bit "sticky" est positionné sur le répertoire <span class=filename>/tmp</span>. Le filtre peut créer le lien, mais il ne pourra pas nettoyer lorsqu’il aura fini et supprimer ce lien puisqu’il appartient à un utilisateur différent.</p></div><div class=paragraph><p>Au lieu de ça, le filtre créera le lien dans le répertoire courant, qui est le répertoire de la file d’attente des travaux d’impression (précisé par le paramètre <code>sd</code> dans <span class=filename>/etc/printcap</span>). C’est l’endroit idéal pour faire travailler les filtres, particulièrement parce qu’il y a (parfois) plus d’espace disque libre dans ce répertoire que sous <span class=filename>/tmp</span>.</p></div><div class=paragraph><p>Voici, enfin, le filtre:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpdf - Imprime des données DVI sur une imprimante HP/PCL
#  Fichier /usr/local/libexec/hpdf

PATH=/usr/local/bin:$PATH; export PATH

#
#  Définit une fonction de nettoyage de nos fichiers temporaires.  Ils prennent place
#  dans le répertoire courant, qui sera le répertoire
#  de file d&#39;attente
#  de l&#39;imprimante.
#
cleanup() {
   rm -f hpdf$$.dvi
}

#
#  Définit une fonction de gestion des erreurs fatales: affiche le message
#  d&#39;erreur et retourne 2.  Ce code d&#39;erreur de 2 indique à LPD
#  de ne pas essayer de réimprimer le travail d&#39;impression
#
fatal() {
    echo &#34;$@&#34; 12
    cleanup
    exit 2
}

#
#  Si l&#39;utilisateur enlève le travail d&#39;impression, LPD envoie SIGINT, donc
#  il faut capturer le signal SIGINT
#  (et quelques autres signaux) pour nettoyer après notre passage.
#
trap cleanup 1 2 15

#
#  Assurons-nous qu&#39;il n&#39;y ait pas conflit ce nom avec des fichiers existants.
#
cleanup

#
#  Lien du fichier DVI vers l&#39;entrée standard (fichier à imprimer).
#
ln -s /dev/fd/0 hpdf$$.dvi || fatal &#34;Cannot symlink /dev/fd/0&#34;

#
#  Conversion LF = CR+LF
#
printf &#34;\033k2G&#34; || fatal &#34;Cannot initialize printer&#34;

#
#  Conversion et impression.  Le code de retour de dvilj2p ne semble
#  pas fiable: ignorons-le.
#
dvilj2p -M1 -q -e- dfhp$$.dvi

#
#  Nettoyage et sortie de la procédure
#
cleanup
exit 0</pre></div></div></div><div class=sect5><h6 id=printing-advanced-autoconv>9.4.1.4.5. Conversion automatique: une alternative aux filtres de conversion<a class=anchor href=#printing-advanced-autoconv></a></h6><div class=paragraph><p>Tous ces filtres de conversion apportent beaucoup à votre environnement d’impression, mais nécessitent que l’utilisateur précise (dans la ligne de commande <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>) lequel utiliser. Si vos utilisateurs ne sont pas particulièrement versés en informatique, préciser une option de filtre sera problématique. Mais ce qui s’avère pire encore est qu’une option de filtre mal choisie peut lancer un filtre sur un type de fichier erroné et causer l’impression de centaines de pages.</p></div><div class=paragraph><p>Plutôt que d’installer quelque filtre de conversion que ce soit, vous préférerez sans doute laisser le filtre texte (puisque c’est le filtre par défaut) déterminer le type de fichier qu’on lui a demandé d’imprimer et lancer automatiquement le filtre de conversion approprié. Des outils comme <code>file</code> peuvent s’avérer utiles dans ce cas. Bien entendu, il sera difficile d’établir les différences entre <em>certains</em> types de fichiers-et vous pouvez toujours, bien sûr, fournir des filtres de conversion uniquement pour eux.</p></div><div class=paragraph><p>Le catalogue des logiciels portés FreeBSD contient un filtre texte, nommé <code>apsfilter</code> (<a class=package href=https://cgit.freebsd.org/ports/tree/print/apsfilter/>print/apsfilter</a>), qui sait effectuer la conversion automatique. Il peut reconnaître le texte brut, le PostScript® les fichiers DVI et quasiment n’importe quelle sorte de fichier, effectuer les conversions appropriées et imprimer.</p></div></div></div><div class=sect4><h5 id=printing-advanced-of>9.4.1.5. Filtres de sortie<a class=anchor href=#printing-advanced-of></a></h5><div class=paragraph><p>Le gestionnaire d’impression LPD reconnaît un autre type de filtre dont nous n’avons pas encore discuté: le filtre de sortie. Un filtre de sortie est destiné à l’impression de texte brut seulement, comme le filtre texte, mais avec de nombreuses simplifications. Si vous utilisez un filtre de sortie mais pas de filtre texte, alors:</p></div><div class=ulist><ul><li><p>LPD lance un filtre de sortie une seule fois par travail d’impression, au lieu d’une fois pour chacun des fichiers du travail d’impression.</p></li><li><p>LPD ne fournit rien pour permettre au filtre de sortie de repérer le début ou la fin des fichiers du travail d’impression.</p></li><li><p>LPD ne passe pas le nom de l’utilisateur ou le nom de la machine au filtre, qui n’est donc pas prévu pour effectuer la comptabilisation de l’impression. En fait, il ne reçoit que deux paramètres:</p><div class=paragraph><p><code>nom-du-filtre</code> -w <em>largeur</em> -l <em>hauteur</em></p></div><div class=paragraph><p>Où <em>largeur</em> provient du paramètre <code>pw</code> et <em>hauteur</em> du paramètre <code>pl</code> de l’entrée <span class=filename>/etc/printcap</span> pour l’imprimante en question.</p></div></li></ul></div><div class=paragraph><p>Ne vous laissez pas séduire par la simplicité d’un filtre de sortie. Si vous désirez que chaque fichier d’un travail d’impression commence sur une page différente, un filtre de sortie <em>ne conviendra pas</em>. Utilisez un filtre texte (également appelé filtre d’entrée); voir la section <a href=#printing-textfilter>Installer le filtre texte</a>. De plus, le filtre de sortie se révèle en fait <em>plus complexe</em> en ce sens qu’il doit examiner le flux d’octets qui lui est envoyé pour y rechercher des caractères spéciaux et qu’il doit s’envoyer à lui-même des signaux comme s’ils provenaient de LPD.</p></div><div class=paragraph><p>Toutefois, un filtre de sortie s’avère <em>nécessaire</em> si vous désirez des pages d’en-tête et avez besoin d’envoyer des séquences d’échappement ou d’autres chaînes d’initialisation afin de pouvoir imprimer la page d’en-tête. (Mais il est également <em>futile</em> si vous voulez imputer les pages d’en-tête au compte de l’utilisateur, puisque LPD ne livre pas d’information sur l’utilisateur ou la machine au filtre de sortie).</p></div><div class=paragraph><p>Sur une seule imprimante, LPD permet à la fois un filtre de sortie et des filtres texte ou autres. Dans de tels cas, LPD ne lancera le filtre de sortie que pour imprimer la page d’en-tête (consultez la section <a href=#printing-advanced-header-pages>Pages d’en-tête</a>). LPD attend alors que le filtre de sortie <em>s’arrête par lui-même</em> en envoyant deux octets au filtre: ASCII 031 suivi d’ASCII 001. Lorsqu’un filtre de sortie lit ces deux octets (031,001), il devrait s’arrêter en s’envoyant à lui-même un <code>SIGSTOP</code>. Lorsque LPD a fini d’exécuter les autres filtres, il relance le filtre de sortie en lui envoyant un <code>SIGCONT</code>.</p></div><div class=paragraph><p>S’il y a un filtre de sortie mais <em>aucun</em> filtre texte et que LPD s’occupe d’un travail d’impression concernant du texte brut, alors LPD utilise le filtre de sortie pour réaliser ce travail d’impression. Comme exposé plus haut, le filtre de sortie imprimera chacun des travaux d’impression séquentiellement sans que des sauts de page ou autres formes d’avancement du papier ne surviennent, et ce n’est vraisemblablement <em>pas</em> ce que vous désirez. Dans presque tous les cas, il vous faut un filtre texte.</p></div><div class=paragraph><p>Le programme <code>lpf</code>, que nous avons présenté précédemment comme un filtre texte, peut également fonctionner en tant que filtre de sortie. Si vous avez besoin d’un filtre de sortie vite-fait-bien-fait mais ne voulez pas écrire le code d’examen d’octets et d’envoi de signal, essayez <code>lpf</code>. Vous pouvez également inclure <code>lpf</code> dans une procédure pour prendre en charge tout code d’initialisation qui pourrait être requis par l’imprimante.</p></div></div><div class=sect4><h5 id=printing-advanced-lpf>9.4.1.6. <code>lpf</code>: un filtre texte<a class=anchor href=#printing-advanced-lpf></a></h5><div class=paragraph><p>Le programme <span class=filename>/usr/libexec/lpr/lpf</span> qui est fourni avec la distribution binaire FreeBSD est un filtre texte (un filtre d’entrée) qui sait indenter la sortie (un travail d’impression soumis avec <code>lpr -i</code>), laisse passer les caractères littéraux (travail d’impression soumis avec <code>lpr -l</code>), ajuste la position d’impression des retours arrière et des tabulations dans le travail d’impression, et comptabilise les pages imprimées. Il peut également servir de filtre de sortie.</p></div><div class=paragraph><p>Le filtre <code>lpf</code> convient à de nombreux environnements d’impression. Et bien qu’il ne puisse pas envoyer de séquences d’initialisation à une imprimante, il est aisé d’écrire une procédure pour effectuer l’initialisation nécessaire et ensuite exécuter <code>lpf</code>.</p></div><div class=paragraph><p>Afin que <code>lpf</code> mène à bien la comptabilisation des pages, il faut que des valeurs correctes soient indiquées pour les paramètres <code>pw</code> et <code>pl</code> dans le fichier <span class=filename>/etc/printcap</span>. Il utilise ces valeurs pour déterminer combien de texte peut être imprimé sur une page et combien de pages ont été imprimées dans le travail d’impression d’un utilisateur. Pour plus d’informations sur la comptabilisation de l’impression, lisez la section <a href=#printing-advanced-acct>Comptabiliser l’utilisation de l’imprimante</a>.</p></div></div></div><div class=sect3><h4 id=printing-advanced-header-pages>9.4.2. Pages d’en-tête<a class=anchor href=#printing-advanced-header-pages></a></h4><div class=paragraph><p>Si vous avez <em>beaucoup</em> d’utilisateurs, et que tous utilisent des imprimantes diverses, alors vous allez certainement envisager les <em>pages d’en-tête</em> comme un mal nécessaire.</p></div><div class=paragraph><p>Les pages d’en-tête, également appelées <em>bannières</em> ou <em>burst page</em>, identifient à qui appartiennent les travaux d’impression après qu’ils aient été imprimés. Elles sont en général imprimées en caractères de grande taille et en gras, peuvent comporter des bordures décorées, de sorte qu’elles contrastent dans une pile d’impressions avec les véritables documents formant les travaux d’impression des utilisateurs. Elles leur permettent de retrouver facilement leurs travaux d’impression. L’inconvénient majeur d’une page d’en-tête est qu’elle représente une page supplémentaire à imprimer pour chacun des travaux d’impression, son utilité éphémère ne dépasse pas quelques minutes, et elle termine au recyclage du papier ou dans une corbeille. (Notez que une page d’en-tête est liée à chaque travail d’impression et non à chaque fichier dans un travail d’impression: il se pourrait donc que le gâchis de papier ne soit pas si grand.)</p></div><div class=paragraph><p>Le système LPD peut fournir des pages d’en-tête automatiquement pour vos impressions <em>si</em> votre imprimante sait imprimer directement du texte brut. Si vous disposez d’une imprimante PostScript®, il vous faudra un programme externe pour générer la page d’en-tête; lisez la section <a href=#printing-advanced-header-pages-ps>Les pages d’en-tête sur les imprimantes PostScript®</a>.</p></div><div class=sect4><h5 id=printing-advanced-header-pages-enabling>9.4.2.1. Activer les pages d’en-tête<a class=anchor href=#printing-advanced-header-pages-enabling></a></h5><div class=paragraph><p>Dans la section <a href=#printing-simple>Configuration simple de l’imprimante</a>, nous avons désactivé les pages d’en-tête en positionnant le paramètre <code>sh</code> (ce qui signifie "suppress header", soit "suppression des en-têtes") dans <span class=filename>/etc/printcap</span>. Pour activer les pages d’en-tête sur une imprimante, il suffit d’enlever ce paramètre <code>sh</code>.</p></div><div class=paragraph><p>Cela semble trop facile, n’est-ce pas?</p></div><div class=paragraph><p>C’est vrai. Il se <em>pourrait</em> que vous ayez à fournir un filtre de sortie pour envoyer des chaînes d’initialisation à l’imprimante. Voici un exemple de filtre sortie pour les imprimantes Hewlett-Packard compatibles-PCL:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpof - filtre de sortie pour les imprimantes Hewlett Packard compatibles PCL
#  Fichier /usr/local/libexec/hpof

printf &#34;\033k2G&#34; || exit 2
exec /usr/libexec/lpr/lpf</pre></div></div><div class=paragraph><p>Spécifiez le chemin d’accès au filtre de sortie avec le paramètre <code>of</code>. Lisez la section <a href=#printing-advanced-of>Filtres de sortie</a> pour plus de détails.</p></div><div class=paragraph><p>Voici un fichier <span class=filename>/etc/printcap</span> d’exemple pour l’imprimante <code>teak</code> que nous avons présentée plus haut; nous avons activé les pages d’en-tête et ajouté le fichier de sortie ci-dessus:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:\
        :vf=/usr/local/libexec/hpvf:\
        :of=/usr/local/libexec/hpof:</pre></div></div><div class=paragraph><p>Désormais, lorsque les utilisateurs lancent des travaux d’impression avec <code>teak</code>, ils obtiennent une page d’en-tête avec chaque travail d’impression. Si vos utilisateurs désirent perdre du temps à rechercher leurs impressions, ils peuvent omettre la page d’en-tête en soumettant le travail d’impression avec la commande <code>lpr -h</code>; lisez la section <a href=#printing-lpr-options-misc>Options des pages d’en-tête</a> pour connaître plus d’options <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>LPD imprime un caractère de saut de page après une page d’en-tête. Si votre imprimante utilise un autre caractère ou séquence de caractères différente pour éjecter une page, précisez-le avec le paramètre <code>ff</code> dans <span class=filename>/etc/printcap</span>.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=printing-advanced-header-pages-controlling>9.4.2.2. Contrôle des pages d’en-tête<a class=anchor href=#printing-advanced-header-pages-controlling></a></h5><div class=paragraph><p>Une fois les pages d’en-tête activées, LPD produira un <em>en-tête long</em>, c’est à dire une page entière de grands caractères identifiant l’utilisateur, le nom de la machine et le travail d’impression. Voici un exemple (<code>kelly</code> a lancé le travail d’impression nommé "outline" depuis la machine <code>rose</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>      k                   ll       ll
      k                    l        l
      k                    l        l
      k   k     eeee       l        l     y    y
      k  k     e    e      l        l     y    y
      k k      eeeeee      l        l     y    y
      kk k     e           l        l     y    y
      k   k    e    e      l        l     y   yy
      k    k    eeee      lll      lll     yyy y
                                               y
                                          y    y
                                           yyyy

                                   ll
                          t         l        i
                          t         l
       oooo    u    u   ttttt       l       ii     n nnn     eeee
      o    o   u    u     t         l        i     nn   n   e    e
      o    o   u    u     t         l        i     n    n   eeeeee
      o    o   u    u     t         l        i     n    n   e
      o    o   u   uu     t  t      l        i     n    n   e    e
       oooo     uuu u      tt      lll      iii    n    n    eeee

      r rrr     oooo     ssss     eeee
      rr   r   o    o   s    s   e    e
      r        o    o    ss      eeeeee
      r        o    o      ss    e
      r        o    o   s    s   e    e
      r         oooo     ssss     eeee

                                              Job:  outline
                                              Date: Sun Sep 17 11:04:58 1995</pre></div></div><div class=paragraph><p>LPD ajoute un saut de page à ce texte de sorte que le travail d’impression commence sur une nouvelle page (à moins que <code>sf</code> (supprimer les sauts de page) ne soit dans l’entrée correspondant à l’imprimante dans <span class=filename>/etc/printcap</span>).</p></div><div class=paragraph><p>Si vous préférez, LPD peut générer des <em>en-tête courts</em>; ajoutez le paramètre <code>sb</code> (en-tête court) dans le fichier <span class=filename>/etc/printcap</span>. La page d’en-tête ressemblera à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>rose:kelly  Job: outline  Date: Sun Sep 17 11:07:51 1995</pre></div></div><div class=paragraph><p>Par défaut également, LPD imprime d’abord la page d’en-tête, puis le travail d’impression. Pour inverser ce comportement, placez le paramètre <code>hl</code> (en-tête à la fin) dans <span class=filename>/etc/printcap</span>.</p></div></div><div class=sect4><h5 id=printing-advanced-header-pages-accounting>9.4.2.3. Comptabiliser les pages d’en-tête<a class=anchor href=#printing-advanced-header-pages-accounting></a></h5><div class=paragraph><p>Utiliser les pages d’en-tête fournies par LPD provoque un comportement particulier lorsqu’il s’agit de comptabiliser l’utilisation de l’imprimante: les pages d’en-tête doivent être <em>gratuites</em>.</p></div><div class=paragraph><p>Pourquoi?</p></div><div class=paragraph><p>Parce que le filtre de sortie est le seul programme externe pouvant tenir les comptes qui aura le contrôle lors de l’impression de la page d’en-tête, et qu’aucune information sur <em>l’utilisateur ou le nom de la machine</em> ne lui est donnée ni aucun fichier de comptabilisation, par conséquent il ne sait pas à qui attribuer le coût de l’utilisation de l’imprimante. Il ne suffit pas non plus de simplement "ajouter une page" au filtre texte ou un quelconque filtre de conversion (qui, eux, possèdent des informations sur l’utilisateur et la machine) puisque les utilisateurs peuvent supprimer les pages d’en-tête avec <code>lpr -h</code>. Ils pourraient toujours se voir imputer des pages d’en-tête qu’ils n’auraient pas imprimées. En somme, <code>lpr -h</code> demeurera l’option favorite des utilisateurs soucieux de l’environnement, mais vous ne pouvez aucunement les inciter à l’utiliser.</p></div><div class=paragraph><p>Il ne <em>suffit pas non plus</em> de laisser chacun des filtres générer ses propres pages d’en-tête (ce qui permettrait de savoir à qui imputer les coûts). Si les utilisateurs désiraient omettre les pages d’en-tête avec <code>lpr -h</code>, ils les obtiendraient quand même et le coût leur serait attribué puisque LPD ne donne aucun renseignement sur l’emploi de l’option <code>-h</code> à aucun des filtres.</p></div><div class=paragraph><p>Alors, quelles sont les options à votre disposition?</p></div><div class=paragraph><p>Vous pouvez:</p></div><div class=ulist><ul><li><p>Accepter le comportement de LPD et la gratuité des pages d’en-tête.</p></li><li><p>Installer une alternative à LPD, comme LPRng. La section <a href=#printing-lpd-alternatives>Alternatives au gestionnaire d’impression standard</a> en dit plus au sujet des autres gestionnaires d’impression qui peuvent être substitués à LPD.</p></li><li><p>Ecrire un filtre de sortie <em>intelligent</em>. Normalement, un filtre de sortie n’est pas censé faire plus que d’initialiser une imprimante ou exécuter une conversion simple de caractères. Il convient aux pages d’en-tête et aux travaux d’impression de texte brut (lorsqu’il n’y a aucun filtre (d’entrée) texte). Mais, s’il existe un filtre texte pour les travaux d’impression de texte, alors LPD ne lancera le filtre de sortie que pour les pages d’en-tête. Le filtre de sortie peut également analyser le texte de la page d’en-tête généré par LPD pour déterminer quels sont l’utilisateur et la machine à qui il faut attribuer le coût de cette page d’en-tête. Le seul autre problème avec cette méthode est que le filtre de sortie ne sait toujours pas quel fichier de comptabilisation utiliser (le nom du fichier spécifié par le paramètre <code>af</code> ne lui est pas fourni), mais si vous disposez d’un fichier de comptabilisation bien identifié, vous pouvez le coder en dur dans le filtre de sortie. Afin de faciliter l’étape d’analyse, utilisez le paramètre <code>sh</code> (en-tête courte) dans <span class=filename>/etc/printcap</span>. D’un autre côté, tout cela pourrait bien représenter beaucoup de dérangement, et les utilisateurs apprécieront certainement davantage l’administrateur généreux qui propose la gratuité des pages d’en-tête.</p></li></ul></div></div><div class=sect4><h5 id=printing-advanced-header-pages-ps>9.4.2.4. Les pages d’en-tête sur les imprimantes PostScript®<a class=anchor href=#printing-advanced-header-pages-ps></a></h5><div class=paragraph><p>Comme décrit précédemment, LPD est en mesure de générer des pages d’en-tête texte convenant pour de nombreuses d’imprimantes. Bien entendu, PostScript® ne peut pas imprimer du texte directement, donc la fonctionnalité de page d’en-tête offerte par LPD est inutilisable ou presque.</p></div><div class=paragraph><p>Une solution manifeste est de faire générer la page d’en-tête par tous les filtres de conversion et le filtre texte. Les filtres devraient employer les paramètres utilisateur et nom de machine pour générer une page d’en-tête convenable. L’inconvénient de cette méthode est que les utilisateurs obtiendront toujours une page d’en-tête, même s’ils soumettent leurs travaux d’impression avec <code>lpr -h</code>.</p></div><div class=paragraph><p>Examinons cette méthode. La procédure ci-dessous prend trois paramètres (le nom de l’utilisateur, le nom de la machine et celui du travail d’impression) et réalise une page d’en-tête simple en PostScript®:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  make-ps-header - génére une page d&#39;en-tête PostScript sur la sortie standard
#  Fichier /usr/local/libexec/make-ps-header
#

#
#  Ce sont des unités PostScript (72 par pouce).  A modifier pour A4 ou
#  tout autre format papier employé:
#
page_width=612
page_height=792
border=72

#
#  Vérification des paramètres
#
if [ $# -ne 3 ]; then
    echo &#34;Usage: `basename $0` user host job&#34; 12
    exit 1
fi

#
#  Mémorisation des paramètres, pour la lisibilité du PostScript, plus bas.
#
user=$1
host=$2
job=$3
date=`date`

#
#  Envoi du code PostScript sur stdout.
#
exec cat EOF
%!PS

%
%  Assurons-nous qu&#39;il n&#39;y a pas d&#39;interférence avec le travail
%  utilisateur qui suivra
%
save

%
%  Applique une grosse bordure désagréable autour
%  du bord de la page.
%
$border $border moveto
$page_width $border 2 mul sub 0 rlineto
0 $page_height $border 2 mul sub rlineto
currentscreen 3 -1 roll pop 100 3 1 roll setscreen
$border 2 mul $page_width sub 0 rlineto closepath
0.8 setgray 10 setlinewidth stroke 0 setgray

%
%  Affiche le nom de l&#39;utilisateur, de façon jolie, grande et proéminente
%
/Helvetica-Bold findfont 64 scalefont setfont
$page_width ($user) stringwidth pop sub 2 div $page_height 200 sub moveto
($user) show

%
%  Maintenant, les détails ennuyant:
%
/Helvetica findfont 14 scalefont setfont
/y 200 def
[ (Job:) (Host:) (Date:) ] {
200 y moveto show /y y 18 sub def }
forall

/Helvetica-Bold findfont 14 scalefont setfont
/y 200 def
[ ($job) ($host) ($date) ] {
        270 y moveto show /y y 18 sub def
} forall

%
% C&#39;est tout
%
restore
showpage
EOF</pre></div></div><div class=paragraph><p>Désormais, chacun des filtres de conversion et le filtre texte peuvent appeler cette procédure pour d’abord générer la page d’en-tête, et ensuite imprimer le travail d’impression de l’utilisateur. Voici le filtre de conversion DVI déjà mentionné plus haut dans ce document, modifié afin de générer une page d’en-tête:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psdf - filtre DVI vers imprimante PostScript
#  Fichier /usr/local/libexec/psdf
#
#  Appelé par lpd quand l&#39;utilisateur lance lpr -d
#

orig_args=&#34;$@&#34;

fail() {
    echo &#34;$@&#34; 12
    exit 2
}

while getopts &#34;x:y:n:h:&#34; option; do
    case $option in
        x|y)  ;; # Ignore
        n)    login=$OPTARG ;;
        h)    host=$OPTARG ;;
        *)    echo &#34;LPD started `basename $0` wrong.&#34; 12
              exit 2
              ;;
    esac
done

[ &#34;$login&#34; ] || fail &#34;Pas de nom d&#39;utilisateur&#34;
[ &#34;$host&#34; ] || fail &#34;PAs de nom de machine&#34;

( /usr/local/libexec/make-ps-header $login $host &#34;DVI File&#34;
  /usr/local/bin/dvips -f ) | eval /usr/local/libexec/lprps $orig_args</pre></div></div><div class=paragraph><p>Observez que le filtre doit analyser la liste des paramètres pour déterminer le nom de l’utilisateur et celui de la machine. L’analyse menée par les autres filtres de conversion est identique. Toutefois, le filtre texte réclame un ensemble de paramètres légèrement différent (voyez la section <a href=#printing-advanced-filters>Fonctionnement des filtres</a>).</p></div><div class=paragraph><p>Comme précédemment exposé, cette solution, quoique relativement simple, invalide l’option de "suppression de page d’en-tête" (l’option <code>-h</code>) de <code>lpr</code>. Si les utilisateurs désiraient épargner la vie d’un arbre (ou économiser quelques centimes, si vous faites payer les pages d’en-tête), ils ne seraient pas en mesure de le faire, puisque chaque filtre va imprimer une page d’en-tête avec chaque travail d’impression.</p></div><div class=paragraph><p>Pour permettre aux utilisateurs de désactiver les pages d’en-tête en fonction du travail d’impression, il vous faudra recourir à l’une des astuces de la section <a href=#printing-advanced-header-pages-accounting>Comptabiliser les pages d’en-tête</a>: écrire un filtre de sortie qui analyse la page d’en-tête générée par LPD et produit une version PostScript®. Si l’utilisateur soumet le travail d’impression avec <code>lpr -h</code> alors ni LPD ni votre filtre de sortie ne généreront de page d’en-tête. Sinon, votre filtre de sortie lira le texte en provenance de LPD et enverra la page d’en-tête PostScript® appropriée à l’imprimante.</p></div><div class=paragraph><p>Si vous disposez d’une imprimante PostScript® sur une interface série, vous pouvez utiliser <code>lprps</code>, qui est livré avec un filtre de sortie, <code>psof</code>, qui réalise ce que nous venons d’exposer ci-dessus. Notez que <code>psof</code> n’assume pas la tenue de comptes pour les pages d’en-tête.</p></div></div></div><div class=sect3><h4 id=printing-advanced-network-printers>9.4.3. Imprimer via un réseau<a class=anchor href=#printing-advanced-network-printers></a></h4><div class=paragraph><p>FreeBSD gère l’impression via un réseau: c’est à dire en envoyant les travaux d’impression à des imprimantes distantes. L’impression via un réseau désigne deux choses différentes:</p></div><div class=ulist><ul><li><p>Accéder à une imprimante connectée à une machine distante. Vous installez une imprimante disposant d’une interface conventionnelle, série ou parallèle, sur une machine. Puis vous configurez LPD pour permettre l’accès à l’imprimante depuis d’autres machines du réseau. La section <a href=#printing-advanced-network-rm>Imprimantes installées sur des machines distantes</a> en détaillera la mise en œuvre.</p></li><li><p>Accéder à une imprimante directement connectée au réseau. L’imprimante dispose d’une interface réseau en plus (ou à la place) d’interfaces plus conventionnelles, série ou parallèle. Une imprimante de ce genre peut fonctionner ainsi:</p><div class=ulist><ul><li><p>Elle peut comprendre le protocole LPD et sait même gérer une file d’attente de travaux d’impression provenant de machines distantes. En ce cas, elle se comporte comme une machine normale qui exécuterait LPD. Suivez la même procédure que celle exposée à la section <a href=#printing-advanced-network-rm>Imprimantes installées sur des machines distantes</a> afin de configurer une imprimante de ce genre.</p></li><li><p>Elle peut savoir gérer un flux de données au travers d’une connexion réseau. Dans ce cas, vous pouvez "attacher" l’imprimante à l’une des machines du réseau en la rendant responsable de la gestion de la file d’impression et de l’envoi des travaux d’impression à l’imprimante. La section <a href=#printing-advanced-network-net-if>Imprimantes avec des interfaces utilisant des flux réseau</a> donne quelque indications sur l’installation d’imprimantes de ce type.</p></li></ul></div></li></ul></div><div class=sect4><h5 id=printing-advanced-network-rm>9.4.3.1. Imprimantes installées sur des machines distantes<a class=anchor href=#printing-advanced-network-rm></a></h5><div class=paragraph><p>Le gestionnaire d’impression LPD dispose des fonctions pour gérer l’envoi des travaux d’impression à d’autres machines exécutant également LPD (ou un système qui lui est compatible). Cette fonctionnalité vous permet d’installer une imprimante sur une machine, puis de la rendre accessible depuis les autres machines. Cela fonctionne également avec les imprimantes disposant d’interfaces réseau comprenant le protocole LPD.</p></div><div class=paragraph><p>Pour activer ce type d’impression à distance, installez d’abord une imprimante sur une machine, qui sera <em>la machine d’impression</em>, en suivant les instructions de configuration basique décrites à la section <a href=#printing-simple>Configuration simple de l’imprimante</a>. Réalisez toute étape de la <a href=#printing-advanced>configuration avancée de l’imprimante</a> dont vous pourriez avoir besoin. Veillez à tester l’imprimante et vérifiez qu’elle fonctionne avec les paramètres de LPD que vous avez activés. Assurez-vous également que <em>la machine locale</em> est autorisée à utiliser le service LPD sur <em>la machine distante</em> (lisez la section <a href=#printing-advanced-restricting-remote>Restreindre les impressions à distance</a>).</p></div><div class=paragraph><p>Si vous utilisez une imprimante avec une interface réseau qui est compatible avec LPD, alors <em>la machine d’impression</em> dans le texte ci-dessous est l’imprimante elle-même, et le <em>nom de l’imprimante</em> est le nom que vous avez paramétré pour l’imprimante. Lisez la documentation livrée avec votre imprimante ou l’interface réseau-imprimante.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Si vous utilisez une Hewlett Packard Laserjet, alors le nom d’imprimante <code>text</code> réalisera la conversion LF en CRLF automatiquement, de sorte que vous n’aurez pas besoin de la procédure <span class=filename>hpif</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ensuite, sur les autres machines pour lesquelles vous désirez autoriser l’accès à l’imprimante, créez une ligne dans leur <span class=filename>/etc/printcap</span> avec les paramètres suivants:</p></div><div class="olist arabic"><ol class=arabic><li><p>Nommez cette entrée comme vous le voulez. Par souci de simplicité, cependant, vous préférerez certainement employer les mêmes nom et alias que ceux utilisés sur la machine de d’impression.</p></li><li><p>Laissez le paramètre <code>lp</code> non-renseigné, de manière explicite (<code>:lp=:</code>).</p></li><li><p>Créez un répertoire de file d’impression et indiquez son chemin d’accès dans le paramètre <code>sd</code>. C’est là où LPD entreposera les travaux d’impression avant leur envoi vers la machine d’impression.</p></li><li><p>Indiquez le nom de la machine d’impression avec le paramètre <code>rm</code>.</p></li><li><p>Placez le nom de l’imprimante sur <em>la machine d’impression</em> dans le paramètre <code>rp</code>.</p></li></ol></div><div class=paragraph><p>C’est tout. Il n’est pas nécessaire de préciser la liste des filtres de conversion, les dimensions de la page, ou quoique ce soit d’autre dans le fichier <span class=filename>/etc/printcap</span>.</p></div><div class=paragraph><p>Voici un exemple. La machine <code>rose</code> dispose de deux imprimantes, <code>bamboo</code> et <code>rattan</code>. Nous allons permettre aux utilisateurs de la machine <code>orchid</code> d’imprimer avec ces imprimantes. Voici le fichier <span class=filename>/etc/printcap</span> pour <code>orchid</code> (apparu dans la section <a href=#printing-advanced-header-pages-enabling>Activer les pages d’en-tête</a>). Il contenait déjà une entrée pour l’imprimante <code>teak</code>; nous avons ajouté celles pour les deux imprimantes sur la machine <code>rose</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine orchid - ajout d&#39;imprimantes (distantes)
#    sur rose
#

#
#  teak est locale; connectée directement à orchid:
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/ifhp:\
        :vf=/usr/local/libexec/vfhp:\
        :of=/usr/local/libexec/ofhp:

#
#  rattan est connectée à rose; envoie les travaux pour rattan
#    à rose:
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/rattan:

#
#  bamboo est également connectée à rose:
#
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :lp=:rm=rose:rp=bamboo:sd=/var/spool/lpd/bamboo:</pre></div></div><div class=paragraph><p>Ensuite, nous n’avons qu’à créer les répertoires de file d’impression sur <code>orchid</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/rattan /var/spool/lpd/bamboo</span>
<span class=c># chmod 770 /var/spool/lpd/rattan /var/spool/lpd/bamboo</span>
<span class=c># chown daemon:daemon /var/spool/lpd/rattan /var/spool/lpd/bamboo</span></code></pre></div></div><div class=paragraph><p>Maintenant les utilisateurs d'<code>orchid</code> peuvent imprimer sur <code>rattan</code> et <code>bamboo</code>. Par exemple, si un utilisateur sur <code>orchid</code> entrait:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> bamboo <span class=nt>-d</span> sushi-review.dvi</code></pre></div></div><div class=paragraph><p>le système LPD sur <code>orchid</code> copierait le travail d’impression dans le répertoire de file d’impression <span class=filename>/var/spool/lpd/bamboo</span> et relèverait qu’il s’agit d’un travail d’impression DVI. Dès que la machine <code>rose</code> dispose d’assez de place dans son répertoire de file d’impression, les deux LPD transfèrent le fichier à <code>rose</code>. Le fichier reste en attente dans la file de <code>rose</code> jusqu’à son impression. Il sera converti de DVI en PostScript® (puisque <code>bamboo</code> est une imprimante PostScript®) sur <code>rose</code>.</p></div></div><div class=sect4><h5 id=printing-advanced-network-net-if>9.4.3.2. Imprimantes avec des interfaces utilisant des flux réseau<a class=anchor href=#printing-advanced-network-net-if></a></h5><div class=paragraph><p>Bien souvent, lorsque vous achetez une carte d’interface réseau pour une imprimante, vous avez le choix entre deux versions: l’une qui émule un gestionnaire d’impression (la version la plus onéreuse), ou une autre qui ne vous permet que de lui envoyer des données comme s’il s’agissait d’un port série ou parallèle (c’est la version la moins chère). Cette section vous indique comment utiliser cette seconde version moins onéreuse. Pour la plus chère, lisez la section précédente <a href=#printing-advanced-network-rm>Imprimantes installées sur des machines distantes</a>.</p></div><div class=paragraph><p>Le format du fichier <span class=filename>/etc/printcap</span> vous permet de préciser quelle interface série ou parallèle vous souhaitez utiliser, et (si vous employez une interface série) à quelle vitesse de transmission, s’il faut employer le contrôle de flux, les temporisations pour les tabulations, la conversion des sauts de lignes, et plus encore. Mais il n’existe aucun moyen de préciser une connexion à une imprimante qui écoute sur un port TCP/IP ou un autre port réseau.</p></div><div class=paragraph><p>Pour envoyer des données à une imprimante mise en réseau, il vous faut développer un programme de communication qui puisse être appelé par les filtres textes et de conversion. Voici un exemple: la procédure <code>netprint</code> récupère toutes les données sur l’entrée standard et les envoie à une imprimante connectée au réseau. Nous précisons le nom de machine de l’imprimante dans le premier paramètre et le numéro de port auquel se connecter dans le deuxième paramètre de <code>netprint</code>. Notez qu’il ne gère que la communication unidirectionnelle (dans le sens FreeBSD vers imprimante); de nombreuses imprimantes réseau supporte la communication bidirectionnelle, et vous désirerez certainement en tirer parti (afin de connaître le statut de l’imprimante, de comptabiliser l’utilisation, etc.).</p></div><div class="literalblock programlisting"><div class=content><pre>#!/usr/bin/perl
#
#  netprint - Filtre texte pour imprimante connectée au réseau
#  Fichier /usr/local/libexec/netprint
#
$#ARGV eq 1 || die &#34;Usage: $0 printer-hostname port-number&#34;;

$printer_host = $ARGV[0];
$printer_port = $ARGV[1];

require &#39;sys/socket.ph&#39;;

($ignore, $ignore, $protocol) = getprotobyname(&#39;tcp&#39;);
($ignore, $ignore, $ignore, $ignore, $address)
    = gethostbyname($printer_host);

$sockaddr = pack(&#39;S n a4 x8&#39;, AF_INET, $printer_port, $address);

socket(PRINTER, PF_INET, SOCK_STREAM, $protocol)
    || die &#34;Can&#39;t create TCP/IP stream socket: $!&#34;;
connect(PRINTER, $sockaddr) || die &#34;Can&#39;t contact $printer_host: $!&#34;;
while (STDIN) { print PRINTER; }
exit 0;</pre></div></div><div class=paragraph><p>Nous pouvons maintenant utiliser cette procédure avec différents filtres. Supposons que nous ayons une imprimante Diablo 750-N connectée au réseau. Elle reçoit les données à imprimer sur le port 5100. Le nom de machine de l’imprimante est <code>scrivener</code>. Voici le filtre texte pour cette imprimante:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  diablo-if-net - Filtre texte pour l&#39;imprimante  Diablo `scrivener&#39; écoutant
#  le port 5100.  Fichier /usr/local/libexec/diablo-if-net
#
exec /usr/libexec/lpr/lpf &#34;$@&#34; | /usr/local/libexec/netprint scrivener 5100</pre></div></div></div></div><div class=sect3><h4 id=printing-advanced-restricting>9.4.4. Restreindre l’utilisation de l’imprimante<a class=anchor href=#printing-advanced-restricting></a></h4><div class=paragraph><p>Cette section fournit des informations sur la restriction de l’utilisation de l’imprimante. Le système LPD vous permet de contrôler quels utilisateurs peuvent accéder à une imprimante, tant localement qu’à distance, s’il leur est autorisé d’imprimer en plusieurs exemplaires, quelles sont les tailles maximales de leurs travaux d’impression et des files d’impression.</p></div><div class=sect4><h5 id=printing-advanced-restricting-copies>9.4.4.1. Restreindre l’impression en plusieurs exemplaires<a class=anchor href=#printing-advanced-restricting-copies></a></h5><div class=paragraph><p>Le système LPD facilite l’impression de plusieurs copies d’un même fichier par les utilisateurs. Ils peuvent imprimer leur travail avec <code>lpr -#5</code> (par exemple) et obtenir cinq exemplaires de chaque fichier du travail d’impression. Le fait de savoir s’il s’agit là d’une bonne idée vous appartient.</p></div><div class=paragraph><p>Si vous estimez que les copies multiples provoquent charge et usure inutiles pour vos imprimantes, vous pouvez désactiver l’option <code>-<mark></mark></code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> en ajoutant le paramètre <code>sc</code> au fichier <span class=filename>/etc/printcap</span>. Lorsque des utilisateurs soumettront un travail d’impression avec l’option <code>-</code>, ils obtiendront cet affichage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>lpr: multiple copies are not allowed</code></pre></div></div><div class=paragraph><p>Notez que si vous avez mis en œuvre l’accès à une imprimante distante (voir la section <a href=#printing-advanced-network-rm>Imprimantes installées sur des machines distantes</a>), il faut que le paramètre <code>sc</code> soit positionné sur les <span class=filename>/etc/printcap</span> distants également, sinon vos utilisateurs auront toujours la possibilité d’imprimer des copies multiples en passant par une autre machine.</p></div><div class=paragraph><p>Voici un exemple. C’est le <span class=filename>/etc/printcap</span> pour la machine <code>rose</code>. L’imprimante <code>rattan</code> est plutôt robuste, et autorisera donc les copies multiples, par contre l’imprimante laser <code>bamboo</code> est quant à elle plus délicate, nous interdiront donc les impressions multiples en ajoutant le paramètre <code>sc</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine rose - restreint les impressions en plusieurs exemplaires sur bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:\
        :lp=/dev/ttyd5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Maintenant, il nous faut également ajouter le paramètre <code>sc</code> dans le fichier <span class=filename>/etc/printcap</span> de <code>orchid</code> (et tant que nous y sommes, désactivons les copies multiples pour l’imprimante <code>teak</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine orchid - pas d&#39;impression en
#  plusieurs exemplaires pour
#  l&#39;imprimante locale teak ou l&#39;imprimante distante bamboo
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:sc:\
        :if=/usr/local/libexec/ifhp:\
        :vf=/usr/local/libexec/vfhp:\
        :of=/usr/local/libexec/ofhp:

rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/rattan:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :lp=:rm=rose:rp=bamboo:sd=/var/spool/lpd/bamboo:sc:</pre></div></div><div class=paragraph><p>En recourant au paramètre <code>sc</code>, nous empêchons l’utilisation de <code>lpr -#</code>, mais cela n’empêche toujours pas les utilisateurs de lancer <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> à plusieurs reprises, ou de soumettre le même fichier plusieurs fois en un seul travail, de cette façon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr forsale.sign forsale.sign forsale.sign forsale.sign forsale.sign</code></pre></div></div><div class=paragraph><p>Il existe plusieurs moyens de prévenir ces abus (y compris les ignorer) que vous êtes libres d’essayer.</p></div></div><div class=sect4><h5 id=printing-advanced-restricting-access>9.4.4.2. Restreindre l’accès aux imprimantes<a class=anchor href=#printing-advanced-restricting-access></a></h5><div class=paragraph><p>Vous pouvez contrôler qui a le droit d’imprimer sur quelles imprimantes en utilisant le mécanisme des groupes UNIX® et le paramètre <code>rg</code> dans <span class=filename>/etc/printcap</span>. Placez simplement les utilisateurs à qui vous voulez donner l’accès à une imprimante dans un groupe, et précisez ce groupe avec le paramètre <code>rg</code>.</p></div><div class=paragraph><p>Les utilisateurs n’appartenant pas au groupe (<code>root</code> inclus) se verront gratifiés d’un <code>lpr: Not a member of the restricted group</code> s’ils essaient d’imprimer avec l’imprimante contrôlée.</p></div><div class=paragraph><p>De même que pour le paramètre <code>sc</code> (supprimer les exemplaires multiples), il vous faut activer <code>rg</code> sur les machines distantes qui eux aussi ont accès à vos imprimantes, si vous estimez que c’est approprié (voir la section <a href=#printing-advanced-network-rm>Imprimantes installées sur des machines distantes</a>).</p></div><div class=paragraph><p>Dans notre exemple, nous allons permettre l’accès à <code>rattan</code> à quiconque, mais seuls les membres du groupe <code>artists</code> pourront utiliser <code>bamboo</code>. Voici l’habituel <span class=filename>/etc/printcap</span> pour la machine <code>rose</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine rose - restreint au groupe pour bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:\
        :lp=/dev/ttyd5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Ne nous préoccupons pas de l’autre fichier <span class=filename>/etc/printcap</span> (pour la machine <code>orchid</code>). Bien entendu, n’importe qui sur <code>orchid</code> peut imprimer avec <code>bamboo</code>. Selon le cas, nous pourrons autoriser que certains utilisateurs sur <code>orchid</code>, et leur donner accès à l’imprimante. Ou non.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il ne peut exister qu’un seul groupe de restriction par imprimante.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=printing-advanced-restricting-sizes>9.4.4.3. Contrôler la taille des travaux d’impression<a class=anchor href=#printing-advanced-restricting-sizes></a></h5><div class=paragraph><p>Si beaucoup de vos utilisateurs accèdent aux imprimantes, vous aurez sans doute besoin de fixer une limite supérieure à la taille des fichiers qu’ils peuvent soumettre à l’impression. Après tout, le système de fichiers hébergeant les répertoires de file d’impression ne peut offrir que l’espace libre dont il dispose, et vous devez également vous assurer que de la place existe pour les travaux d’impression des autres utilisateurs.</p></div><div class=paragraph><p>LPD vous permet de fixer la taille maximale en octets qu’un fichier d’un travail d’impression peut atteindre avec le paramètre <code>mx</code>. Les unités sont exprimées en blocs de <code>BUFSIZ</code>, valant 1024 octets. Si vous donnez la valeur 0 à ce paramètre, la taille ne sera pas du tout limitée; en revanche, si aucun paramètre <code>mx</code> n’est défini, alors une limite par défaut de 1000 blocs sera utilisée.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La limite s’applique aux <em>fichiers</em> dans un travail d’impression, et <em>non pas</em> à la taille totale du travail d’impression.</p></div></td></tr></tbody></table></div><div class=paragraph><p>LPD ne refusera pas un fichier dont la taille excède la limite que vous fixez pour une imprimante. Au lieu de cela, il placera les octets du fichier dans la file jusqu’à ce que la limite soit atteinte, puis imprimera. Les octets supplémentaires seront ignorés. S’il s’agit là d’un comportement approprié est un choix qui vous appartient.</p></div><div class=paragraph><p>Ajoutons des limites pour nos imprimantes d’exemple, <code>rattan</code> et <code>bamboo</code>. Puisque les fichiers PostScript® des utilisateurs du groupe <code>artists</code> ont tendance à être volumineux, nous allons les limiter à cinq mégaoctets. Nous ne fixerons aucune limite pour l’imprimante texte:</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap pour la machine rose
#

#
#  Pas de limite sur la taille des travaux:
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:mx#0:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

#
#  Limite de cinq mégaoctets:
#
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:mx#5000:\
        :lp=/dev/ttyd5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Là encore, les limites ne s’appliquent qu’aux utilisateurs locaux. Si vous avez mis en place un accès distant à vos imprimantes, les utilisateurs distants ne seront pas contraints par ces limites. Il vous faudra positionner le paramètre <code>mx</code> dans les fichiers <span class=filename>/etc/printcap</span> distants également. Lisez la section <a href=#printing-advanced-network-rm>Imprimantes installées sur des machines distantes</a> pour obtenir plus d’informations sur l’impression à distance.</p></div><div class=paragraph><p>Il existe une autre manière spécifique pour limiter la taille des travaux d’impression sur les imprimantes à distance; lisez la section <a href=#printing-advanced-restricting-remote>Restreindre les impressions à distance</a>.</p></div></div><div class=sect4><h5 id=printing-advanced-restricting-remote>9.4.4.4. Restreindre les impressions à distance<a class=anchor href=#printing-advanced-restricting-remote></a></h5><div class=paragraph><p>Le gestionnaire d’impression LPD propose plusieurs moyens de restreindre les travaux d’impression soumis depuis des machines distants:</p></div><div class=dlist><dl><dt class=hdlist1>Restrictions en fonction des machines</dt><dd><p>Vous pouvez contrôler de quelles machines distantes les requêtes seront acceptées par un LPD local avec les fichiers <span class=filename>/etc/hosts.equiv</span> et <span class=filename>/etc/hosts.lpd</span>. LPD vérifie qu’une requête entrante provient d’une machine listée dans l’un de ces deux fichiers. Si ce n’est pas le cas, LPD refuse la requête.</p><div class=paragraph><p>Le format de ces fichiers est simple: un nom de machine par ligne. Notez que <span class=filename>/etc/hosts.equiv</span> est également utilisé par le protocole <a href="https://man.freebsd.org/cgi/man.cgi?query=ruserok&amp;sektion=3&amp;format=html">ruserok(3)</a>, et qu’il a un impact sur des programmes comme <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, aussi soyez prudent.</p></div><div class=paragraph><p>Par exemple, voici le fichier <span class=filename>/etc/hosts.lpd</span> présent sur la machine <code>rose</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>orchid
violet
madrigal.fishbaum.de</pre></div></div><div class=paragraph><p>Cela signifie que <code>rose</code> accepte les requêtes provenant des machines <code>orchid</code>, <code>violet</code> et <code>madrigal.fishbaum.de</code>. Si une quelconque autre machine tente d’accéder au LPD de <code>rose</code>, le travail d’impression sera refusé.</p></div></dd><dt class=hdlist1>Restrictions sur la taille</dt><dd><p>Vous pouvez contrôler combien d’espace doit demeurer libre sur le système de fichiers où se trouve un répertoire de file d’impression. Créez un fichier nommé <span class=filename>minfree</span> dans le répertoire de file d’impression pour l’imprimante locale. Placez dans ce fichier un nombre représentant combien de blocs disques (de 512 octets) d’espace libre il doit rester pour qu’un travail d’impression soit accepté.</p><div class=paragraph><p>Cela vous permet de vous assurer que des utilisateurs distants ne rempliront pas votre système de fichiers. Vous pouvez également vous en servir pour accorder une certaine priorité aux utilisateurs locaux: ils pourront placer des travaux d’impression dans la file bien après que l’espace libre soit tombé sous le seuil indiqué dans le fichier <span class=filename>minfree</span>.</p></div><div class=paragraph><p>Par exemple, ajoutons un fichier <span class=filename>minfree</span> pour l’imprimante <code>bamboo</code>. Nous examinons <span class=filename>/etc/printcap</span> pour trouver le répertoire de file d’impression pour cette imprimante; voici l’entrée concernant <code>bamboo</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:mx#5000:\
        :lp=/dev/ttyd5:ms#-parenb cs8 clocal crtscts:rw:mx#5000:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>Le répertoire de file d’impression est précisé par le paramètre <code>sd</code>. Nous placerons à trois méga-octets (soit 6144 blocs disque) la limite d’espace libre devant exister sur le système de fichiers pour que LPD accepte les travaux d’impression distants:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo 6144 &gt; /var/spool/lpd/bamboo/minfree</span></code></pre></div></div></dd><dt class=hdlist1>Restrictions sur l’utilisateur</dt><dd><p>Vous pouvez contrôler quels utilisateurs distants ont le droit d’imprimer sur les imprimantes locales en positionnant le paramètre <code>rs</code> dans <span class=filename>/etc/printcap</span>. Lorsque <code>rs</code> est présent dans l’entrée d’une imprimante connectée localement, LPD acceptera les travaux d’impressions de machines distantes <em>si</em> l’utilisateur soumettant le travail possède également un compte sous le même nom sur la machine locale. Sinon, LPD refusera le travail d’impression.</p><div class=paragraph><p>Ce paramètre se révèle particulièrement utile dans un environnement où (par exemple) existent plusieurs services qui partagent un réseau, et que des utilisateurs débordent les frontières de ces services. En leur donnant des comptes sur vos systèmes, vous leur permettez d’utiliser vos imprimantes depuis les systèmes de leur propre service. Si vous préférez les autoriser à n’utiliser <em>que</em> vos imprimantes et pas les autres ressources de l’ordinateur, alors vous pouvez leur attribuer des comptes "bloqués", sans répertoire de connexion et avec un interpréteur de commandes inutilisable comme <span class=filename>/usr/bin/false</span>.</p></div></dd></dl></div></div></div><div class=sect3><h4 id=printing-advanced-acct>9.4.5. Comptabiliser l’utilisation de l’imprimante<a class=anchor href=#printing-advanced-acct></a></h4><div class=paragraph><p>Donc vous voulez faire payer vos impressions. Et pourquoi pas? Le papier et l’encre coûtent de l’argent. Et puis, il y a les coûts de maintenance-les imprimantes sont constituées de pièces mobiles et ont tendance à tomber en panne. Vous avez étudié vos imprimantes, vos modes d’utilisation et factures de maintenance, et avez abouti à un coût par page (ou par pied, par mètre, ou par ce que vous voulez). Maintenant, comment commencer à comptabiliser les impressions, dans les faits?</p></div><div class=paragraph><p>Eh bien, la mauvaise nouvelle est que le gestionnaire d’impression LPD ne vous aide pas beaucoup dans ce domaine. La comptabilisation dépend fortement du type d’imprimante que vous employez, des formats que vous imprimez et de <em>vos</em> besoins pour ce qui est de faire payer l’utilisation de l’imprimante.</p></div><div class=paragraph><p>Pour mettre en œuvre la comptabilisation, il vous faut modifier le filtre texte de l’imprimante (pour faire payer les travaux d’impression de texte brut) et ses filtres de conversion (pour faire payer les autres formats de fichiers), pour compter les pages ou demander à l’imprimante combien elle en a imprimées. Vous ne pouvez pas vous en tirer en utilisant le filtre de sortie simple, puisqu’il ne peut pas gérer la comptabilisation. Voir la section <a href=#printing-advanced-filter-intro>Les filtres</a>.</p></div><div class=paragraph><p>En général, il existe deux façons de procéder à la comptabilisation:</p></div><div class=ulist><ul><li><p>La comptabilisation <em>périodique</em> est la plus habituelle, probablement parce que la plus facile. Chaque fois que quelqu’un imprime un travail, le filtre enregistre l’utilisateur, la machine et le nombre de pages dans un fichier de comptabilisation. Tous les mois, semestres, années ou toute autre échéance que vous désirez, vous récupérez les fichiers de comptabilisation des diverses imprimantes, établissez les pages imprimées par les utilisateurs, et faites payer l’utilisation. Purgez ensuite tous les fichiers de comptabilisation, pour commencer à zéro la nouvelle période.</p></li><li><p>La comptabilisation <em>à la volée</em> est moins répandue, peut-être parce qu’elle s’avère plus difficile. Cette méthode laisse les filtres s’occuper de taxer les utilisateurs pour les impressions dès qu’ils utilisent les imprimantes. Tout comme les quotas disques, la comptabilisation est immédiate. Vous pouvez empêcher les utilisateurs d’imprimer quand leur compte est dans le rouge, et pourriez leur fournir un moyen de vérifier et ajuster leurs "quotas d’impression". Cependant, cette méthode nécessite la mise en oeuvre d’une base de données afin de tracer les utilisateurs et leurs quotas.</p></li></ul></div><div class=paragraph><p>Le gestionnaire d’impression LPD gère les deux méthodes facilement: puisque vous devez fournir les filtres (enfin, la plupart du temps), vous devez également fournir le code de comptabilisation. Mais il y a un bon côté: vous disposez d’une énorme flexibilité dans vos méthodes de comptabilisation. Par exemple, vous avez le choix entre les comptabilisations périodique et à la volée. Vous avez le choix des informations à tracer: noms d’utilisateurs, noms de machines, types des travaux d’impression, pages imprimées, surface de papier utilisée, durée d’impression du travail, etc. Et vous le faites en modifiant les filtres afin d’enregistrer ces informations.</p></div><div class=sect4><h5 id=_comptabilisation_rapide_et_simplifiée_des_impressions>9.4.5.1. Comptabilisation rapide et simplifiée des impressions<a class=anchor href=#_comptabilisation_rapide_et_simplifiée_des_impressions></a></h5><div class=paragraph><p>Deux programmes sont livrés avec FreeBSD qui vous permettent de mettre en place une comptabilisation périodique simple immédiatement. Il s’agit du filtre texte <code>lpf</code>, détaillé dans la section <a href=#printing-advanced-lpf>lpf: un filtre texte</a>, et de <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>, un programme qui rassemble et fait le total des entrées contenues dans des fichiers de comptabilisation d’impressions.</p></div><div class=paragraph><p>Comme indiqué dans la section sur les filtres (<a href=#printing-advanced-filters>Fonctionnement des filtres</a>), LPD lance les filtres texte et de conversion avec le nom du fichier de comptabilisation à employer fourni en argument. Les filtres peuvent utiliser ce paramètre pour savoir où écrire un enregistrement de comptabilisation. Le nom de ce fichier provient du paramètre <code>af</code> dans <span class=filename>/etc/printcap</span>, et si le chemin donné n’est pas absolu, alors c’est un chemin d’accès relatif au répertoire de file d’impression.</p></div><div class=paragraph><p>LPD lance <code>lpf</code> avec les paramètres de largeur et hauteur de page (qui correspondent aux paramètres <code>pw</code> et <code>pl</code>). Le filtre <code>lpf</code> les utilise pour déterminer combien de papier sera consommé. Après avoir envoyé le fichier à l’imprimante, il enregistre ensuite une entrée dans le fichier de comptabilisation. Les entrées ressemblent à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>2.00 rose:andy
3.00 rose:kelly
3.00 orchid:mary
5.00 orchid:mary
2.00 orchid:zhang</pre></div></div><div class=paragraph><p>Vous devriez utiliser un fichier de comptabilisation séparé pour chaque imprimante, <code>lpf</code> ne disposant pas de mécanisme de verrouillage des fichiers, deux <code>lpf</code> pourraient corrompre leurs entrées respectives s’ils essayaient d’écrire dans le même fichier en même temps. Une manière aisée de s’assurer d’un fichier de comptabilisation séparé pour chaque imprimante est de recourir au paramètre <code>af=acct</code> dans <span class=filename>/etc/printcap</span>. Dès lors, un fichier de comptabilisation, nommé <span class=filename>acct</span>, sera placé dans le répertoire de file d’impression de chaque imprimante.</p></div><div class=paragraph><p>Lorsque vous serez prêts à faire payer les utilisateurs pour leurs impressions, lancez le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>. Placez-vous simplement dans le répertoire de file d’impression de l’imprimante pour laquelle vous voulez collecter les informations, et tapez <code>pac</code>. Vous obtiendrez un récapitulatif en dollars ressemblant à ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> Login               pages/feet   runs    price
orchid:kelly                5.00    1   <span class=nv>$ </span> 0.10
orchid:mary                31.00    3   <span class=nv>$ </span> 0.62
orchid:zhang                9.00    1   <span class=nv>$ </span> 0.18
rose:andy                   2.00    1   <span class=nv>$ </span> 0.04
rose:kelly                177.00  104   <span class=nv>$ </span> 3.54
rose:mary                  87.00   32   <span class=nv>$ </span> 1.74
rose:root                  26.00   12   <span class=nv>$ </span> 0.52

total                     337.00  154   <span class=nv>$ </span> 6.74</code></pre></div></div><div class=paragraph><p>Voici les arguments attendus par <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>:</p></div><div class=dlist><dl><dt class=hdlist1><code>-P<em>imprimante</em></code></dt><dd><p>Pour quelle <em>imprimante</em> effectuer un récapitulatif. Cette option ne fonctionne que si un chemin d’accès absolu est donné dans le paramètre <code>af</code> de <span class=filename>/etc/printcap</span>.</p></dd><dt class=hdlist1><code>-c</code></dt><dd><p>Trier selon le coût plutôt qu’alphabétiquement par nom d’utilisateur.</p></dd><dt class=hdlist1><code>-m</code></dt><dd><p>Ignorer le nom de la machine dans les fichiers de comptabilisation. Avec cette option, l’utilisateur <code>smith</code> sur la machine <code>alpha</code> est le même que l’utilisateur <code>smith</code> sur la machine <code>gamma</code>. Sans elle, ils représentent des utilisateurs distincts.</p></dd><dt class=hdlist1><code>-p<em>prix</em></code></dt><dd><p>Calculer le coût en comptant un <em>prix</em> en dollars par page ou par pied au lieu du prix indiqué par le paramètre <code>pc</code> dans <span class=filename>/etc/printcap</span>, ou deux cents (la valeur par défaut). Vous pouvez préciser le <em>prix</em> en nombre à virgule flottante.</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>Inverser l’ordre du tri.</p></dd><dt class=hdlist1><code>-s</code></dt><dd><p>Créer un fichier de rapport et tronquer le fichier de comptabilisation.</p></dd><dt class=hdlist1><em>nom …​</em></dt><dd><p>N’imprimer des statistiques que pour les utilisateurs dont les <em>nom</em>s sont donnés.</p></dd></dl></div><div class=paragraph><p>Dans le récapitulatif produit par défaut par <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a>, vous pouvez lire le nombre de pages imprimées par chaque utilisateur depuis les différentes machines. Si, sur votre site, la machine n’a pas d’importance (parce que les utilisateurs peuvent utiliser n’importe quelle machine), lancez <code>pac -m</code>, afin de produire le récapitulatif ci-dessous:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  Login               pages/feet   runs    price
andy                        2.00    1   <span class=nv>$ </span> 0.04
kelly                     182.00  105   <span class=nv>$ </span> 3.64
mary                      118.00   35   <span class=nv>$ </span> 2.36
root                       26.00   12   <span class=nv>$ </span> 0.52
zhang                       9.00    1   <span class=nv>$ </span> 0.18

total                     337.00  154   <span class=nv>$ </span> 6.74</code></pre></div></div><div class=paragraph><p>Afin de calculer le montant dû en dollars, <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> utilise le paramètre <code>pc</code> de <span class=filename>/etc/printcap</span> (200 par défaut, c’est à dire 2 cents par page). Précisez avec ce paramètre le prix par page ou par pied, exprimé en centièmes de cents, que vous voulez imputer aux impressions. Vous pouvez spécifier cette valeur lorsque vous lancez <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> avec l’option <code>-p</code>. Cependant, avec cette option, les unités sont exprimées en dollars, et non en centièmes de cents. Par exemple,</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pac -p1.50</span></code></pre></div></div><div class=paragraph><p>fait en sorte que chaque page coûte un dollar et cinquante cents. Vous pouvez vraiment faire des bénéfices en utilisant cette option.</p></div><div class=paragraph><p>Enfin, lancer <code>pac -s</code> enregistrera les informations du récapitulatif dans un fichier, dont le nom sera le même que le fichier de comptabilisation de l’imprimante mais avec le suffixe <code>_sum</code>. Il procède alors à la troncature du fichier de comptabilisation. Lorsque vous exécutez <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> à nouveau, il relit le fichier récapitulatif pour établir les totaux de départ, puis ajoute les informations du fichier de comptabilisation normal.</p></div></div><div class=sect4><h5 id=_comment_compter_les_pages_imprimées>9.4.5.2. Comment compter les pages imprimées?<a class=anchor href=#_comment_compter_les_pages_imprimées></a></h5><div class=paragraph><p>Afin de réaliser une comptabilisation précise et cela même à distance, vous devez pouvoir déterminer combien un travail d’impression consomme de papier. C’est le problème principal de la comptabilisation des impressions.</p></div><div class=paragraph><p>Pour du texte brut, ce problème n’est pas compliqué à résoudre: vous comptez combien un travail d’impression comporte de lignes et comparez avec le nombre de lignes par page que gère votre imprimante. N’oubliez pas de tenir compte des retours arrière dans le fichier, qui superposent les lignes, ou des longues lignes qui s’étendent sur une ou plusieurs lignes physiques supplémentaires.</p></div><div class=paragraph><p>Le filtre texte <code>lpf</code> (présenté à la section <a href=#printing-advanced-lpf>lpf: un filtre texte</a>) prend ces éléments en considération lorsqu’il effectue la comptabilisation. Si vous écrivez un filtre texte qui doit effectuer une comptabilisation, vous pouvez vous inspirer du code source de <code>lpf</code>.</p></div><div class=paragraph><p>Mais comment gérer les autres formats?</p></div><div class=paragraph><p>Eh bien, pour la conversion DVI-vers-LaserJet ou DVI-vers-PostScript®, vous pouvez faire analyser les messages de sortie de <code>dvilj</code> ou <code>dvips</code> par votre filtre et regarder combien de pages ont été converties. Vous devriez pouvoir procéder de manière identique avec d’autres formats de fichiers et programmes de conversion.</p></div><div class=paragraph><p>Mais ces méthodes connaissent un défaut: il se peut que l’imprimante n’imprime pas toutes ces pages. Par exemple, un bourrage peut se produire, l’imprimante peut arriver à cours d’encre, ou exploser - et l’utilisateur serait tout de même débité.</p></div><div class=paragraph><p>Alors, que pouvez-vous faire?</p></div><div class=paragraph><p>Il n’existe qu’une seule méthode <em>sûre</em> pour procéder à une comptabilisation <em>précise</em>. Prenez une imprimante qui sache dire combien de papier elle utilise, et reliez-la par un câble série ou une connection réseau. Presque toutes les imprimantes PostScript® gèrent cela. D’autres types et modèles également (les imprimantes laser réseau Imagen, par exemple). Modifiez les filtres pour ces imprimantes afin d’obtenir la consommation de pages après chaque travail d’impression et faites en sorte qu’elles enregistrent des informations de comptabilisation basées sur cette <em>seule</em> valeur. Nul besoin de compter les lignes ou d’une analyse de fichier susceptible d’être erronée.</p></div><div class=paragraph><p>Bien entendu, vous pouvez toujours être généreux et rendre toutes les impressions gratuites.</p></div></div></div></div><div class=sect2><h3 id=printing-using>9.5. Using Printers <strong>Traduction en Cours </strong><a class=anchor href=#printing-using></a></h3><div class=sect3><h4 id=printing-lpr>9.5.1. Printing Jobs<a class=anchor href=#printing-lpr></a></h4></div><div class=sect3><h4 id=printing-lpq>9.5.2. Checking Jobs<a class=anchor href=#printing-lpq></a></h4></div><div class=sect3><h4 id=printing-lprm>9.5.3. Removing Jobs<a class=anchor href=#printing-lprm></a></h4></div><div class=sect3><h4 id=printing-lpr-options>9.5.4. Beyond Plain Text: Printing Options<a class=anchor href=#printing-lpr-options></a></h4><div class=sect4><h5 id=printing-lpr-options-format>9.5.4.1. Formatting and Conversion Options<a class=anchor href=#printing-lpr-options-format></a></h5></div><div class=sect4><h5 id=printing-lpr-options-job-handling>9.5.4.2. Job Handling Options<a class=anchor href=#printing-lpr-options-job-handling></a></h5></div><div class=sect4><h5 id=printing-lpr-options-misc>9.5.4.3. Header Page Options<a class=anchor href=#printing-lpr-options-misc></a></h5></div></div><div class=sect3><h4 id=printing-lpc>9.5.5. Administering Printers<a class=anchor href=#printing-lpc></a></h4></div></div><div class=sect2><h3 id=printing-lpd-alternatives>9.6. Alternatives to the Standard Spooler <strong>Traduction en Cours </strong><a class=anchor href=#printing-lpd-alternatives></a></h3></div><div class=sect2><h3 id=printing-troubleshooting>9.7. Troubleshooting <strong>Traduction en Cours </strong><a class=anchor href=#printing-troubleshooting></a></h3></div></div></div><div class=sect1><h2 id=linuxemu>Chapitre 10. Compatibilité binaire avec Linux<a class=anchor href=#linuxemu></a></h2><div class=sectionbody><div class=sect2><h3 id=linuxemu-synopsis>10.1. Synopsis<a class=anchor href=#linuxemu-synopsis></a></h3><div class=paragraph><p>FreeBSD fournit en option une compatibilité binaire avec Linux®, permettant aux utilisateurs d’installer et d’exécuter desapplications Linux, sans avoir à les modifier, sur un système FreeBSD.
Cette option est disponible pour les architectures i386, amd64, et arm64.</p></div><div class=paragraph><p>Certaines caractéristiques spécifiques au système Linux ne sont pas encore supportées sous FreeBSD; cela concerne principalement des fonctionnalités spécifiques au matériel ou relatives à la gestion du système, comme les cgroups ou les espaces de noms.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Comment activer la compatibilité binaire avec Linux sur un système FreeBSD.</p></li><li><p>Comment installer des bibliothèques partagées Linux supplémentaires.</p></li><li><p>Comment installer des applications Linux sur un système FreeBSD.</p></li><li><p>Les détails de l’implémentation de la compatibilité Linux sous FreeBSD.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Savoir comment installer des <a href=./#ports>logiciels tiers</a>.</p></li></ul></div></div><div class=sect2><h3 id=linuxemu-lbc-install>10.2. Configurer la compatibilité binaire avec Linux<a class=anchor href=#linuxemu-lbc-install></a></h3><div class=paragraph><p>Par défaut, la compatibilité binaire avec Linux n’est pas activée.
Pour l’activer au démarrage, ajoutez cette ligne au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>linux_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Une fois activée, elle peut être lancée sans redémarrer en exécutant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service linux start</span></code></pre></div></div><div class=paragraph><p>La procédure <span class=filename>/etc/rc.d/linux</span> changera les modules noyau nécessaires et montera sous <span class=filename>/compat/linux</span> les systèmes de fichiers attendus par les applications Linux.
Ceci est suffisant pour faire fonctionner les binaires Linux statiques.
Ils peuvent être lancés de la même manière qu’un binaire natif FreeBSD; ils se comportent exactement de la même manière que des processus natifs et peuvent être suivis et debogués avec les méthodes habituelles.</p></div><div class=paragraph><p>Les binaires Linux liés de manière dynamique (c’est la vaste majorité des cas) demandent à ce que les bibliothèques dynamiques partgées Linux soient installées - ils peuvent être exécutés par le noyau FreeBSD, mais ne peuvent pas utiliser les bibliothèques FreeBSD; c’est semblable au principe des binaires 32bits qui ne peuvent pas utiliser les bibliothèques natives 64bits.
Il existe plusieurs méthodes pour mettre à disposition ces
bibliothèques: on peut les copier à partir d’une installation Linux
existante utilisant la même architecture, les installer à partir des
paquets binaires FreeBSD, ou les installer en utilisant
<a href="https://man.freebsd.org/cgi/man.cgi?query=deboostrap&amp;sektion=8&amp;format=html">deboostrap(8)</a> (à partir de <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/debootstrap/>sysutils/debootstrap</a>), etc.</p></div></div><div class=sect2><h3 id=linuxemu-packages>10.3. Système de base CentOS à partir des paquets binaires FreeBSD<a class=anchor href=#linuxemu-packages></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cette méthode n’est pas encore applicable sous arm64.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La méthode la plus simple pour installer les bibliotèques Linux est
d’installer la version pré-compilée ou la version compilée à partir du catalogue des logiciels portés <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base-c7/>emulators/linux_base-c7</a>, qui placera le système de base dérivé de CentOS 7 dans le répertoire <span class=filename>/compat/linux</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install linux_base-c7</span></code></pre></div></div><div class=paragraph><p>FreeBSD fournit les paquets des binaires Linux de certaines applications.
Par exemple, pour installer Sublime Text 4, avec les bibliothèques Linux
nécessaires, exécuter la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install linux-sublime-text4</span></code></pre></div></div></div><div class=sect2><h3 id=linuxemu-debootstrap>10.4. Système de base Debian / Ubuntu avec <a href="https://man.freebsd.org/cgi/man.cgi?query=debootstrap&amp;sektion=8&amp;format=html">debootstrap(8)</a><a class=anchor href=#linuxemu-debootstrap></a></h3><div class=paragraph><p>Une autre solution pour disposer des bibliothèques partagées Linux est
l’utilisation de <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/debootstrap/>sysutils/debootstrap</a>.
Cela a pour avantage de disposer d’une distribution complète Debian ou
Ubuntu. Pour l’utiliser, suivez les instructions données sur le Wiki
FreeBSD: <a href=https://wiki.freebsd.org/LinuxJails>FreeBSD Wiki - Linux Jails</a>.</p></div><div class=paragraph><p>Après cette installation, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> dans le répertoire nouvellement créé et installez le logiciel suivant la manière classique sous la distribution Linux installée, par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot /compat/ubuntu /bin/bash</span>
root@hostname:/# apt update</code></pre></div></div><div class=paragraph><p>Il est possible d’utiliser debootstrap dans le répertoire <span class=filename>/compat/linux</span>, mais cela est déconseillé pour éviter les colisions avec les fichiers installés à partir des logiciels portés ou pré-compilés FreeBSD.
A la place, utilisez un nom de répertoire dérivé du nom ou de la version de la distribution, e.g., <span class=filename>/compat/ubuntu</span>.
Si l’instance debootstrap est destinée à fournir des bibliothèques partagées Linux sans utiliser explicitement chroot ou les jails, on peut faire pointer le noyau dessus en modifiant le paramètre sysctl <code>compat.linux.emul_path</code> et en ajoutant une ligne comme ce qui suit au fichier <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>compat.linux.emul_path=&#34;/compat/ubuntu&#34;</pre></div></div><div class=paragraph><p>Ce paramètre sysctl contrôle le mécanisme de traduction du chemin du noyau, consultez <a href="https://man.freebsd.org/cgi/man.cgi?query=linux&amp;sektion=4&amp;format=html">linux(4)</a> pour plus de détails.
Veuillez noter que ce changement peut être à l’origine de problèmes pour les applications Linux installées à partir des paquets binaires FreeBSD; une des raisons est que beaucoup de ces applications sont toujours en 32bits, alors qu’Ubuntu semble abandonner le support des bibliothèques 32bits.</p></div></div><div class=sect2><h3 id=linuxemu-advanced>10.5. Sujets avancés<a class=anchor href=#linuxemu-advanced></a></h3><div class=paragraph><p>La couche de compatibilité Linux est un travail en constante progression.
Consultez <a href=https://wiki.freebsd.org/Linuxulator>FreeBSD Wiki - Linuxulator</a> pour plus d’informations.</p></div><div class=paragraph><p>Tous les paramètres <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> relatifs à Linux peuvent être trouvés dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=linux&amp;sektion=4&amp;format=html">linux(4)</a>.</p></div><div class=paragraph><p>Certaines applications ont besoin que des systèmes de fichiers spécifiques soient montés.
Cela est normalement géré par la procédure <span class=filename>/etc/rc.d/linux</span>, mais peut être désactivé en ajoutant la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>linux_mounts_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Les systèmes de fichiers montés par la procédure rc ne fonctionneront
pas pour les processus Linux à l’intérieur de jail ou chroot; si
nécessaire, configurez-les dans <span class=filename>/etc/fstab</span>:</p></div><div class=literalblock><div class=content><pre>devfs      /compat/linux/dev      devfs      rw,late                    0  0
tmpfs      /compat/linux/dev/shm  tmpfs      rw,late,size=1g,mode=1777  0  0
fdescfs    /compat/linux/dev/fd   fdescfs    rw,late,linrdlnk           0  0
linprocfs  /compat/linux/proc     linprocfs  rw,late                    0  0
linsysfs   /compat/linux/sys      linsysfs   rw,late                    0  0</pre></div></div><div class=paragraph><p>Depuis qu’à été ajouté le support pour l’exécution des binaires Linux 32 et 64 bits à la couche de compatibilité Linux (sur les hôtes 64 bits de type x86), il n’est plus possible d’ajouter l’émulation en statique dans un noyau personnalisé.</p></div><div class=sect3><h4 id=linuxemu-libs-manually>10.5.1. Installer des bibliothèques supplémentaires à la main<a class=anchor href=#linuxemu-libs-manually></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour un système de base dont l’arborescence a été créée avec <a href="https://man.freebsd.org/cgi/man.cgi?query=debootstrap&amp;sektion=8&amp;format=html">debootstrap(8)</a>, utilisez les instructions données plus haut.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si une application Linux se plaint de l’absence d’une bibliothèque partagée après avoir configuré la compatibilité binaire Linux, déterminez quelle est la bibliothèque partagée nécessaire au binaire Linux et installez-la à la main.</p></div><div class=paragraph><p>A partir d’un système Linux utilisant un processeur de même architecture, la commande <code>ldd</code> peut être utilisée pour déterminer quelles sont les bibliothèques partagées dont l’application a besoin. Par exemple, pour contrôler quelles bibliothèques partagées sont nécessaires à <code>linuxdoom</code>, exécuter cette commande à partir d’un système Linux où est installé Doom:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldd linuxdoom
libXt.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libX11.so.3.1.0
libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> <span class=o>=&gt;</span> /lib/libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Ensuite, copier tous les fichiers mentionnés dans la dernière colonne, du système sous Linux vers <span class=filename>/compat/linux</span> sur le système FreeBSD. Une fois copiés, créer les liens symboliques vers les noms de fichiers donnés dans la première colonne. Cet exemple donnera lieu aux fichiers suivants sur le système FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Si une bibliothèque Linux partagée existe avec le même numéro de version majeure que celle indiquée par la première colonne du résultat de la commande <code>ldd</code>, il est inutile de la copier vers le nom de fichier donné par la dernière colonne, la bibliothèque déjà existante devrait fonctionner. Il est cependant recommandé de copier malgré tout la bibliothèque partagée si c’est une version récente. L’ancienne version peut être supprimée, du moment que le lien symbolique pointe sur la nouvelle.</p></div><div class=paragraph><p>Par exemple, les bibliothèques suivantes existent déjà sur le système FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</code></pre></div></div><div class=paragraph><p>et <code>ldd</code> indique qu’un binaire a besoin d’une version plus récente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Etant donné que la bibliothèque existante n’a qu’une ou deux versions de retard sur le dernier digit, le programme devrait fonctionner avec la version légèrement plus ancienne. Il est, néanmoins, plus sûr de remplacer la <span class=filename>libc.so</span> existante avec la version plus récente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Généralement, vous ne devrez chercher à savoir de quelles bibliothèques partagées dépendent les binaires Linux que les premières fois que vous installerez des programmes Linux sur le système FreeBSD. Au bout d’un moment, il y aura un ensemble suffisant de bibliothèques partagées Linux sur le système pour être en mesure d’exécuter les binaires Linux nouvellement importés sans effort supplémentaire.</p></div></div><div class=sect3><h4 id=_marquage_des_binaires_linux_elf>10.5.2. Marquage des binaires Linux ELF<a class=anchor href=#_marquage_des_binaires_linux_elf></a></h4><div class=paragraph><p>Le noyau FreeBSD utilise plusieurs méthodes pour déterminer si le binaire à exécuter est pour Linux: il contrôle le marquage dans l’entête ELF du fichier, recherche les chemins connus vers l’interpréteur ELF et contrôle les notes dans le fichier ELF; enfin, par défaut, les exécutables ELF non marqués sont considérés comme étant pour Linux.
Si toutes ces méthodes échouent, une tentative pour exécuter le binaire pourra générer une erreur:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./mon-binaire-elf-linux
ELF binary <span class=nb>type </span>not known
Abort</code></pre></div></div><div class=paragraph><p>Pour que le noyau FreeBSD puisse distinguer un binaire ELF FreeBSD d’un binaire Linux, vous devez employer l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux mon-binaire-elf-linux</code></pre></div></div></div><div class=sect3><h4 id=_installer_une_application_linux_basée_sur_rpm>10.5.3. Installer une application Linux basée sur RPM<a class=anchor href=#_installer_une_application_linux_basée_sur_rpm></a></h4><div class=paragraph><p>Pour installer une application Linux basée sur RPM, installer en premier le logiciel précompilé ou porté <a class=package href=https://cgit.freebsd.org/ports/tree/archivers/rpm4/>archivers/rpm4</a>. Une fois installé, <code>root</code> peut utiliser la commande suivante pour installer un <span class=filename>.rpm</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /compat/linux</span>
<span class=c># rpm2cpio  /path/to/linux.archive.rpm | cpio -id</span></code></pre></div></div><div class=paragraph><p>Si nécessaire, utiliser <code>brandelf</code> sur les binaires ELF installés. Il faut noter que cela empêchera une desinstallation propre.</p></div></div><div class=sect3><h4 id=_configurer_le_résolveur_de_noms_de_domaines>10.5.4. Configurer le résolveur de noms de domaines<a class=anchor href=#_configurer_le_résolveur_de_noms_de_domaines></a></h4><div class=dlist><dl><dt class=hdlist1>Si le DNS ne fonctionne pas, ou si cette erreur apparaît</dt></dl></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>resolv+: <span class=s2>&#34;bind&#34;</span> is an invalid keyword resolv+:
<span class=s2>&#34;hosts&#34;</span> is an invalid keyword</code></pre></div></div><div class=paragraph><p>Vous devrez configurer un fichier <span class=filename>/compat/linux/etc/host.conf</span> contenant:</p></div><div class="literalblock programlisting"><div class=content><pre>order hosts, bind
multi on</pre></div></div><div class=paragraph><p>Cela indique qu’il faut tout d’abord regarder dans le fichier <span class=filename>/etc/hosts</span> puis interroger le DNS. Quand le fichier <span class=filename>/compat/linux/etc/host.conf</span> n’existe pas, les applications Linux trouvent le fichier <span class=filename>/etc/host.conf</span> et se plaignent de sa syntaxe FreeBSD incompatible. Supprimez <code>bind</code> si un serveur de noms n’est pas configuré avec le fichier <span class=filename>/etc/resolv.conf</span>.</p></div></div><div class=sect3><h4 id=linuxemu-misc>10.5.5. Divers<a class=anchor href=#linuxemu-misc></a></h4><div class=paragraph><p>Cette section décrit comment la compatibilité binaire avec Linux fonctionne, et est basée sur un courrier électronique de Terry Lambert <a href=mailto:tlambert@primenet.com>tlambert@primenet.com</a> envoyé à la <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>liste de diffusion pour la discussion de sujets non-techniques en rapport avec FreeBSD</a> (Message ID: <code>199906020108.SAA07001@usr09.primenet.com</code>).</p></div><div class=paragraph><p>FreeBSD possède une abstraction appelée "chargeur de classe d’exécution". C’est une portion de l’appel système <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a>.</p></div><div class=paragraph><p>Historiquement, le chargeur UNIX examinait le nombre magique (généralement les 4 ou 8 premiers octets du fichier) pour voir si c’était un binaire connu par le système, et si c’était le cas, invoquait le chargeur binaire.</p></div><div class=paragraph><p>Si ce n’était pas le type de binaire du système, l’appel <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> retournait un échec, et l’interpréteur de commandes tentait de l’exécuter comme une commande d’interpréteur. Cette hypothèse était celle par défaut "quel que soit l’interpréteur de commandes actuel".</p></div><div class=paragraph><p>Plus tard, une modification a été faite sur <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> pour examiner les deux premiers caractères, et s’ils étaient <code>:\n</code>, alors elle invoquait l’interpréteur de commandes <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> à la place.</p></div><div class=paragraph><p>FreeBSD possède désormais une liste de chargeurs, avec un chargeur par défaut, <code>#!</code>, pour exécuter les interpréteurs ou les procédures de commandes.</p></div><div class=paragraph><p>Pour le support de l’ABI Linux, FreeBSD voit le nombre magique comme un binaire ELF. Le chargeur ELF recherche une <em>marque</em> spécifique, qui se trouve dans une section de commentaires dans l’image ELF, et qui n’est pas présente dans les binaires SVR4/Solaris™ ELF.</p></div><div class=paragraph><p>Pour que les binaires Linux puissent fonctionner, ils doivent être <em>marqués</em> sous le type <code>Linux</code> avec <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brandelf -t Linux file</span></code></pre></div></div><div class=paragraph><p>Lorsque le chargeur ELF voit le marquage <code>Linux</code>, le chargeur remplace un pointeur dans la structure <code>proc</code>. Tous les appels système sont indexés par l’intermédiaire de ce pointeur (dans un système UNIX traditionnel, cela serait la structure <code>sysent[]</code>, contenant les appels système). De plus, le processus est marqué pour une gestion spéciale du vecteur d’interruption ("trap") pour le signal de code "trampoline", et plusieurs autres corrections (mineures) qui sont gérées par le noyau Linux.</p></div><div class=paragraph><p>Le vecteur d’appel système Linux contient, entre autres, une liste des entrées <code>sysent[]</code> dont les adresses résident dans le noyau.</p></div><div class=paragraph><p>Quand un appel système est effectué par le binaire Linux, le code "trap" déréférence de la structure <code>proc</code> le pointeur de la fonction de l’appel système, et utilise les points d’entrée Linux, et non pas FreeBSD, de l’appel système.</p></div><div class=paragraph><p>Le mode Linux <em>redéfinit dynamiquement</em> l’origine des requêtes. C’est, en effet, équivalent à l’option <code>union</code> de montage des systèmes de fichiers. Tout d’abord, une tentative est faite pour rechercher le fichier dans le répertoire <span class=filename>/compat/linux/chemin-origine</span>. Si cela échoue, la recherche est effectuée dans le répertoire <span class=filename>/chemin-origine</span>. Cela permet de s’assurer que les binaires nécessitant d’autres binaires puissent s’exécuter. Par exemple, l’ensemble des outils Linux peuvent tourner sous l’ABI Linux. Cela signifie également que les binaires Linux peuvent charger et exécuter les binaires FreeBSD, s’il n’y a pas de binaires Linux correspondant présents, et vous pourriez placer une commande <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> dans l’arborescence <span class=filename>/compat/linux</span> pour vous assurer que les binaires Linux ne puissent pas dire qu’ils ne tournent pas sous Linux.</p></div><div class=paragraph><p>En effet, il y a un noyau Linux dans le noyau FreeBSD. Les diverses fonctions sous-jacentes qui implémentent tous les services fournis par le noyau sont identiques entre les deux tables d’entrées des appels systèmes FreeBSD et Linux: les opérations sur les systèmes de fichiers, les opérations sur la mémoire virtuelle, la gestion des signaux, iet l’IPC System V. La seule différence est que les binaires FreeBSD utilisent les fonctions <em>glue</em> de FreeBSD, et les binaires Linux celles de Linux. Les fonctions <em>glue</em> de FreeBSD sont liées en statique dans le noyau, les fonctions <em>glue</em> Linux peuvent être liées statiquement, ou l’on peut y accéder via un module du noyau.</p></div><div class=paragraph><p>Techniquement, ce n’est pas vraiment de l’émulation, c’est l’implémentation d’une interface binaire pour les applications (ABI). Cela est parfois appelé "émulation Linux" parce que l’implémentation a été faite à une époque où il n’y avait pas vraiment d’autres mots pour décrire ce qui était en développement. Dire que FreeBSD exécutait les binaires Linux n’était pas vrai, jusqu’à ce le code de support Linux soit compilé ou le module soit chargé.</p></div></div></div></div></div><div class=sect1><h2 id=wine>Chapitre 11. WINE<a class=anchor href=#wine></a></h2><div class=sectionbody><div class=sect2><h3 id=wine-synopsis>11.1. Synopsis<a class=anchor href=#wine-synopsis></a></h3><div class=paragraph><p><a href=https://www.winehq.org/>WINE</a>, qui signifie Wine Is Not an Emulator, car c’est en fait un programme faisant office de surcouche d’interprétation des instructions système.
Celui-ci permet l’installation et l’utilisation de programmes à l’origine prévus pour fonctionner sous Windows® sur FreeBSD (mais aussi sous d’autres systèmes d’exploitation).</p></div><div class=paragraph><p>Il fonctionne par l’interception des appels systèmes, ou des requêtes venant d’un programme vers le système d’exploitation, et transforme les appels systèmes Windows® en appels systèmes que FreeBSD peut comprendre.
Il fera également en sorte de traduire dans le sens inverse les nouvelles instructions afin que le programme Windows® fonctionne comme espéré.
Alors oui dans un certain sens, il <em>émule</em> bien un environnement Windows®, car il fournit bons nombres des ressources nécessaires au bon fonctionnement des applications Windows®.</p></div><div class=paragraph><p>Cependant, il ne s’agit pas d’un émulateur au sens strict du terme.
En effet, dans la plupart des émulateurs, le fonctionnement est sensiblement différent. Ces derniers simulent des composants physiques informatiques afin de faire tourner des logiciels. C’est le cas notamment des solutions de virtualisation (comme: <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/qemu/>emulators/qemu</a>).
L’un des bénéfices notables de cette approche est la capacité d’installation d’un système d’exploitation entier.
Cela signifie, que du point de vue des applications exécutées au sein de cet émulateur, tout se passe comme sur un véritable système non émulé. De cette manière les programmes ont de bonnes chances de fonctionner comme escomptés.
Le mauvais côté inhérent à cette approche est tout simplement qu’un programme simulant du matériel informatique est forcément plus lent que ledit matériel qu’il tente de reproduire.
Le système émulé (appelé <em>invité</em>) a besoin des ressources de la machine physique (appelée <em>hôte</em>), et réserve ces ressources tant qu’il fonctionne.</p></div><div class=paragraph><p>D’un autre côté, le projet WINE, est plus économe en ressources système.
Il fera en sorte de traduire des instructions systèmes à la volée. Ce n’est en théorie pas aussi rapide qu’un véritable système Windows®, mais la différence de vitesse d’exécution reste minime.
D’un autre côté, WINE essaie d’interpréter au mieux les différentes évolutions des systèmes Windows® pour rester compatible avec les applications originellement conçues pour ces systèmes.
C’est une tâche complexe, ce qui veut dire qu’il faut garder en tête le fait que de nombreuses applications puissent ne pas fonctionner comme espéré sous WINE, ne marchent pas du tout, voire ne s’installent même pas.</p></div><div class=paragraph><p>De cette manière, WINE constitue une autre option dans le but d’essayer de faire fonctionner un programme Windows® sous FreeBSD.
Il peut servir de première solution, si cela fonctionne, car cela peut permettre de lancer l’application escomptée sans pour autant monopoliser toutes les ressources du système hôte FreeBSD.</p></div><div class=paragraph><p>Ce chapitre va décrire:</p></div><div class=ulist><ul><li><p>Comment installer WINE sur système un FreeBSD.</p></li><li><p>Comment WINE fonctionne et quelles sont ses différences vis-à-vis des autres alternatives comme la virtualisation.</p></li><li><p>Comment adapter WINE aux besoins spécifiques de certaines applications.</p></li><li><p>Comment installer des interfaces graphiques pour assister à la configuration de WINE.</p></li><li><p>Des astuces et des solutions à utiliser sous FreeBSD.</p></li><li><p>La prise en compte de WINE au sein d’un environnement multi-utilisateur.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, il serait utile de:</p></div><div class=ulist><ul><li><p>Comprendre <a href=./#basics>quelques bases d’UNIX®</a>.</p></li><li><p>Savoir <a href=./#bsdinstall>installer FreeBSD</a>.</p></li><li><p>Savoir <a href=./#advanced-networking>configurer une connexion réseau</a>.</p></li><li><p>Savoir <a href=./#ports>installer des applications</a>.</p></li></ul></div></div><div class=sect2><h3 id=wine-overview-concepts>11.2. WINE généralités et concepts<a class=anchor href=#wine-overview-concepts></a></h3><div class=paragraph><p>WINE est un système complexe, avant de pouvoir s’en servir au mieux sur FreeBSD, il convient de comprendre ce que c’est et comment il fonctionne.</p></div><div class=sect3><h4 id=what-is-wine>11.2.1. WINE qu’est-ce que c’est?<a class=anchor href=#what-is-wine></a></h4><div class=paragraph><p>Comme nous l’avons déjà vu dans le <a href=#wine-synopsis>Synopsis</a> de ce chapitre, WINE constitue une surcouche de compatibilité logicielle permettant l’utilisation d’applications Windows® sur d’autres systèmes d’exploitation.
En théorie, cela signifie que ces programmes pourront être exécutés sous des systèmes comme FreeBSD, macOS et Android.</p></div><div class=paragraph><p>Lorsque WINE lance un exécutable Windows®, il se passe deux choses:</p></div><div class=ulist><ul><li><p>Tout d’abord, WINE implémente un environnement qui imite celui de diverses versions de Windows®. Par exemple, si une application demande l’accès à une ressource de la machine comme la RAM, WINE possède une interface mémoire qui ressemble et se comporte (en tout cas pour l’application en question) comme Windows®.</p></li><li><p>Ensuite, une fois que l’application utilise cette interface, WINE reçoit les requêtes d’adressage mémoire et les transforme en instructions compatibles avec le système hôte. À l’inverse, lorsque l’application sous WINE veut obtenir des données, elles sont converties pour être exploitées par cette application Windows®.</p></li></ul></div></div><div class=sect3><h4 id=wine-and-the-os-system>11.2.2. WINE et le système FreeBSD<a class=anchor href=#wine-and-the-os-system></a></h4><div class=paragraph><p>L’installation de WINE sur un système FreeBSD entraînera celle de différents composants:</p></div><div class=ulist><ul><li><p>Les applications FreeBSD permettant l’exécution de tâches comme lancer un exécutable Windows®, configurer le sous-système WINE, ou compiler un programme avec une compatibilité WINE.</p></li><li><p>Un grand nombre de dépendances implémentant les fonctionnalités centrales de Windows® (par exemple <span class=filename>/lib/wine/api-ms-core-memory-l1-1-1.dll.so</span>, qui fait partie de l’interface mémoire mentionnée un petit peu plus haut).</p></li><li><p>Un certain nombre d’exécutables Windows®, qui sont (ou en tout cas imitent) les programmes courants (comme <span class=filename>/lib/wine/notepad.exe.so</span>, qui fournit l’éditeur de texte standard de Windows®).</p></li><li><p>Des composants additionnels de Windows®, en particulier les polices de caractères (comme Tahoma, qui se trouve <span class=filename>share/wine/fonts/tahoma.ttf</span> à la racine de l’installation).</p></li></ul></div></div><div class=sect3><h4 id=graphical-versus-text-modeterminal-programs-in-wine>11.2.3. Programmes avec interface graphique et programmes en mode texte/terminal sous WINE<a class=anchor href=#graphical-versus-text-modeterminal-programs-in-wine></a></h4><div class=paragraph><p>Comme dans le monde de FreeBSD, les terminaux sont extrêmement courants, il est naturel de penser que WINE possède une excellente prise en charge des programmes en mode texte.
Cependant, la majorité des applications pour Windows®, surtout les applications les plus populaires, sont conçues pour une utilisation avec une interface utilisateur graphique.
De ce fait, les outils de WINE sont conçus pour lancer par défaut des programmes possédant une interface graphique.</p></div><div class=paragraph><p>Néanmoins, il existe trois méthodes disponibles pour lancer ces programmes en interface utilisateur console:</p></div><div class=ulist><ul><li><p>L’approche <em>sortie directe</em> qui affichera directement sur la sortie standard d’un terminal.</p></li><li><p>La <em>wineconsole</em> qui est un outil qui peut être utilisé avec les options <em>user</em> ou <em>curses</em> afin d’utiliser certaines améliorations que fournit le système de WINE pour les applications consoles.</p></li></ul></div><div class=paragraph><p>Ces méthodes sont détaillées en profondeur sur cette page : <a href=https://wiki.winehq.org/Wine_User%27s_Guide#Text_mode_programs_.28CUI:_Console_User_Interface.29>Wiki du projet WINE</a>.</p></div></div><div class=sect3><h4 id=wine-derivative-projects>11.2.4. Projets dérivés de WINE<a class=anchor href=#wine-derivative-projects></a></h4><div class=paragraph><p>WINE est en lui-même un projet open source mature, de ce fait, ce n’est pas étonnant qu’il serve de base à d’autres solutions logicielles plus complexes.</p></div><div class=sect4><h5 id=commercial-wine-implementations>11.2.4.1. Implémentations commerciales de WINE<a class=anchor href=#commercial-wine-implementations></a></h5><div class=paragraph><p>Un certain nombre d’entreprises ont utilisé WINE comme base centrale d’un de leur propre produit propriétaire (sachant que la licence LGPL permet ceci).
Voici deux solutions populaires basées sur le projet WINE:</p></div><div class=ulist><ul><li><p>CrossOver de Codeweavers</p></li></ul></div><div class=paragraph><p>Cette solution propose des installations en un clic de différentes versions de WINE contenant différentes améliorations et optimisations (l’entreprise contribue au projet WINE en partageant certaines de ses améliorations).
La principale préoccupation de Codeweavers est de faire en sorte que la plupart des applications les plus populaires puissent s’installer et s’exécuter parfaitement.</p></div><div class=paragraph><p>Bien que l’entreprise ait par le passé produit une version native de CrossOver pour FreeBSD, ce n’est plus le cas depuis longtemps.
Certaines références en ligne sont encore disponibles (comme ici sur un <a href=https://www.codeweavers.com/compatibility/crossover/forum/freebsd>forum dédié</a>), cela fait cependant un certains temps qu’elles ne sont plus mises à jour.</p></div><div class=ulist><ul><li><p>Proton de Steam</p></li></ul></div><div class=paragraph><p>Steam qui distribue principalement des jeux vidéo utilise aussi WINE afin de permettre l’installation et l’exécution de jeux prévus pour Windows® sur d’autres systèmes d’exploitation.
Cela vise surtout à la base les systèmes de type Linux, bien qu’une certaine prise en charge de macOS existe également.</p></div><div class=paragraph><p>Tandis que Steam ne propose pas de version FreeBSD de leur client, il existe plusieurs options pour utiliser la versions Linux® du client en utilisant la surcouche de compatibilité Linux de FreeBSD.</p></div></div><div class=sect4><h5 id=wine-companion-programs>11.2.4.2. Programmes d’accompagnement de WINE<a class=anchor href=#wine-companion-programs></a></h5><div class=paragraph><p>Aux solutions propriétaires, nous pouvons ajouter d’autres projet ayant publié des applications conçues pour fonctionner en tandem avec la version standard et open source de WINE.
Le but de ces solutions va de rendre l’installation de WINE plus facile à la simplification de l’installation des programmes les plus populaires.</p></div><div class=paragraph><p>Ces solutions sont abordées avec plus de détails dans une partie ultérieure de ce chapitre: <a href=#wine-management-guis>interfaces graphiques pour la gestion de WINE </a>, avec notamment:</p></div><div class=ulist><ul><li><p>winetricks</p></li><li><p>Homura</p></li></ul></div></div></div><div class=sect3><h4 id=alternatives-to-wine>11.2.5. Les alternatives à WINE<a class=anchor href=#alternatives-to-wine></a></h4><div class=paragraph><p>Pour les utilisateurs de FreeBSD, certaines alternatives à WINE existent:</p></div><div class=ulist><ul><li><p>Le double-amorçage: Une solution évidente est de directement lancer les programmes conçus pour Windows® sur ce dernier. Cela veut bien sûr dire qu’il faudra quitter FreeBSD afin de démarrer sous Windows®, aussi cette méthode n’est pas envisageable si l’accès aux programmes des deux systèmes en simultané est nécessaire.</p></li><li><p>Les machines virtuelles: les machines virtuelles (ou VMs), comme mentionné plus tôt dans ce chapitre, sont des procédés logiciels qui émulent un ensemble complet de matériels informatiques, sur lequel un autre système d’exploitation (comprenant Windows®) peut être installé et utilisé. Les outils modernes rendent les VMs simples à créer et à gérer, mais cette méthode a un coût. En effet, une bonne portion des ressources du système hôte doit être allouée à chaque VM, sachant que ces ressources ne pourront pas être libérées tant que la VM est en fonctionnement. Il existe plusieurs solutions de gestion de machines virtuelles disponibles sous FreeBSD, les solutions open source comme qemu, bhyve et VirtualBox en sont un bon exemple. Voir le chapitre sur la <a href=#virtualization>Virtualisation</a> pour plus de détails.</p></li><li><p>L’accès distant: Comme beaucoup d’autres systèmes de type UNIX®, FreeBSD est capable d’utiliser un ensemble d’applications permettant aux utilisateurs d’accéder à des ordinateurs Windows® à distance afin d’utiliser leurs programmes et données. En plus des clients comme xrdp qui sont compatibles avec le protocole de bureau distant (RDP) standard de Windows®, il existe d’autres standards open source comme vnc pouvant aussi être utilisé (si un serveur compatible est présent à l’autre bout).</p></li></ul></div></div></div><div class=sect2><h3 id=installing-wine-on-freebsd>11.3. Installer WINE sur FreeBSD<a class=anchor href=#installing-wine-on-freebsd></a></h3><div class=paragraph><p>WINE peut être installé grâce à l’outil de gestion de logiciels pré-compilés de FreeBSD (pkg), ou bien en compilant le programme depuis le catalogue de logiciels portés.</p></div><div class=sect3><h4 id=wine-prerequistes>11.3.1. WINE les prérequis<a class=anchor href=#wine-prerequistes></a></h4><div class=paragraph><p>Avant de procéder à l’installation de WINE lui-même, il convient d’avoir préinstallé ce qui suit:</p></div><div class=ulist><ul><li><p>Une interface utilisateur graphique</p></li></ul></div><div class=paragraph><p>La plupart des programmes Windows® s’attendent à pouvoir interagir avec une interface graphique.
Si WINE est installé sans une interface graphique déjà présente, ses dépendances comprendront également le compositeur Wayland, et de ce fait, une interface graphique sera effectivement installée aux côtés de WINE.
Cela dit, il vaut mieux installer au préalable une interface graphique de votre choix, configurée et fonctionnelle avant de procéder à l’installation de WINE.</p></div><div class=ulist><ul><li><p>wine-gecko</p></li></ul></div><div class=paragraph><p>Pendant une longue période Windows® avait, par défaut, pré-installé le navigateur Web: Internet Explorer.
Par conséquent, certaines applications s’exécuteront en partant du principe qu’il y aura toujours quelque chose capable d’afficher des pages Web.
Dans le but de fournir cette fonctionnalité, la surcouche logicielle de WINE inclue un navigateur Internet basique utilisant le moteur de rendu Web Gecko issu du projet Mozilla.
Lorsque WINE sera lancé pour la première fois, une fenêtre de dialogue apparaîtra pour proposer le téléchargement et l’installation de Gecko. Il existe un certain nombre de raisons pour vouloir procéder ainsi (cela sera abordé plus loin).
Mais, il peut aussi être installé avant même d’installer WINE ou en parallèle de l’installation de ce dernier.</p></div><div class=paragraph><p>Pour installer ce programme en version pré-compilée, il faut procéder comme ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install wine-gecko</span></code></pre></div></div><div class=paragraph><p>ou alors, il est aussi possible de le compiler depuis le catalogue de logiciels portés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulator/wine-gecko</span>
<span class=c># make install</span></code></pre></div></div><div class=ulist><ul><li><p>wine-mono</p></li></ul></div><div class=paragraph><p>MONO est une implémentation open source de la plateforme de développement .NET de Microsoft.
Installer MONO devrait rendre plus facile l’installation et l’utilisation des applications écrites en .NET sous FreeBSD.</p></div><div class=paragraph><p>Pour l’installer la version pré-compilée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install wine-mono</span></code></pre></div></div><div class=paragraph><p>Pour compiler MONO à partir du catalogue de logiciels portés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulator/wine-mono</span>
<span class=c># make install</span></code></pre></div></div></div><div class=sect3><h4 id=installing-wine>11.3.2. Installer WINE depuis le dépôt de paquets de FreeBSD<a class=anchor href=#installing-wine></a></h4><div class=paragraph><p>Une fois les prérequis installés, il suffit de procéder à l’installation de WINE via la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install wine</span></code></pre></div></div><div class=paragraph><p>ou alors, WINE peut être compilé depuis le catalogue de logiciels portés avec les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulator/wine</span>
<span class=c># make install</span></code></pre></div></div></div><div class=sect3><h4 id=thirtytwo-vs-sixtyfour-bit-wine>11.3.3. Préoccupations concernant les différences entre les versions 32 et 64 bits de WINE<a class=anchor href=#thirtytwo-vs-sixtyfour-bit-wine></a></h4><div class=paragraph><p>Comme la plupart des applications, les programmes Windows®, sont, eux aussi, passés de l’ancienne architecture 32 bits à l’architecture 64 bits.
La plupart des logiciels récents sont écrits pour des systèmes d’exploitation 64 bits, cependant, les systèmes d’exploitation modernes peuvent parfois continuer d’utiliser des programmes plus anciens en 32 bits.
FreeBSD ne diffère en rien sur ce point, il supporte effectivement les architectures 64 bits depuis les versions 5.X du système.</p></div><div class=paragraph><p>Ainsi, le fait que les programmes les plus anciens ne soient plus pris en charge, peut justifier l’emploi d’émulateurs. Les utilisateurs se tournent bien souvent vers WINE afin de pouvoir jouer à des jeux et utiliser divers programmes qui ne fonctionnent plus correctement sur du matériel moderne.
Heureusement, FreeBSD prend en charge les trois cas de figures:</p></div><div class=ulist><ul><li><p>Pour une machine moderne 64 bits sur laquelle vous désirez lancer une application 64 bits Windows®, il suffit de procéder à l’installation des outils WINE comme détaillés dans les rubriques précédentes. En procédant ainsi, le système installera automatiquement la version 64 bits de Wine.</p></li><li><p>Si jamais, un utilisateur possède une vieille machine prenant en charge exclusivement les architectures 32 bits, il peut installer une version 32 bits de FreeBSD et ensuite procéder à l’installation de WINE comme indiqué précédemment.</p></li></ul></div></div></div><div class=sect2><h3 id=running-first-wine-program>11.4. Lancer un premier programme WINE sous FreeBSD<a class=anchor href=#running-first-wine-program></a></h3><div class=paragraph><p>Maintenant que WINE est installé, la prochaine étape est d’essayer WINE en tentant de lancer un programme simple.
Une manière simple de faire cela est de télécharger une application autonome, par exemple, un programme qu’il suffit d’extraire de son archive et de lancer directement sans aucun autre processus d’installation plus complexe.</p></div><div class=paragraph><p>Ces applications de types "portables" constituent de bons choix pour procéder à ce genre de tests, tout comme les programmes pouvant s’exécuter en s’appuyant sur un unique fichier exécutable.</p></div><div class=sect3><h4 id=running-a-program-from-the-command-line>11.4.1. Lancer un programme WINE en ligne de commande<a class=anchor href=#running-a-program-from-the-command-line></a></h4><div class=paragraph><p>Il existe deux méthodes différentes pour lancer des programmes Windows depuis un émulateur de terminal.
La première et la plus directe, est de naviguer dans le répertoire contenant l’exécutable du programme en question (<span class=filename>.EXE</span>) et de taper ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% wine program.exe</code></pre></div></div><div class=paragraph><p>Pour les applications qui acceptent des arguments en ligne de commande, il suffit de les ajouter après l’exécutable comme habituellement:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% wine program2.exe <span class=nt>-file</span> file.txt</code></pre></div></div><div class=paragraph><p>Il est aussi possible de fournir le chemin complet vers l’exécutable afin de l’utiliser dans un script, par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% wine /home/user/bin/program.exe</code></pre></div></div></div><div class=sect3><h4 id=running-a-program-from-a-gui>11.4.2. Lancer un programme WINE depuis une interface graphique<a class=anchor href=#running-a-program-from-a-gui></a></h4><div class=paragraph><p>Après l’installation de WINE, les environnements graphiques doivent être configurés pour associer les fichiers exécutables Windows® (<span class=filename>.EXE</span>) avec WINE.
Il sera ensuite possible de parcourir le système avec un gestionnaire de fichiers, puis de lancer une application Windows® de la même manière que n’importe quel autre programme (avec un clic ou en double-cliquant selon la manière dont est configurée l’interface graphique).</p></div><div class=paragraph><p>Sur la plupart des environnements de bureau, il suffit de vérifier que l’association est correcte en faisant un clic droit sur le fichier, puis de chercher une option de lancement correspondante dans le menu.
Une des options (normalement celle par défaut) devrait être lancer avec <strong>Wine - Chargeur de programmes Windows</strong>, comme dans la capture d’écran ci-dessous:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-run-np++-1.png alt="wine run np++ 1"></div></div><div class=paragraph><p>Dans l’éventualité où le programme ne se lancerait pas comme escompté, essayez de le lancer depuis un terminal afin de voir si un éventuel message d’erreur apparaît, vous donnant ainsi un indice pour débloquer la situation.
Dans le cas où WINE ne serait pas l’application par défaut pour ouvrir les fichiers <span class=filename>.EXE</span> après l’installation, veuillez vérifier les associations MIME pour cette extension de fichier dans l’environnement de bureau courant, l’interface système ou bien le gestionnaire de fichiers.</p></div></div></div><div class=sect2><h3 id=configuring-wine-installation>11.5. Configurer WINE après installation<a class=anchor href=#configuring-wine-installation></a></h3><div class=paragraph><p>Après avoir compris ce qu’était WINE et comment il fonctionne dans les grandes lignes, la prochaine étape consiste savoir l’utiliser de manière efficiente sur FreeBSD et de s’habituer à ses configurations.
Ce qui va suivre détaillera le concept clé de <em>préfixe WINE</em>, et comment il est utilisé pour contrôler la façon dont les applications fonctionnent via WINE.</p></div><div class=sect3><h4 id=wine-prefixes>11.5.1. Les préfixes WINE<a class=anchor href=#wine-prefixes></a></h4><div class=paragraph><p>Un <em>préfixe</em> WINE est un répertoire, il se trouve généralement (par défaut) ici: <span class=filename>$HOME/.wine</span> mais peut aussi se situer ailleurs.
Le préfixe est un ensemble de configurations et de fichiers utilisés par WINE pour configurer et utiliser l’environnement Windows® dont a besoin une application donnée.
Par défaut, une installation toute fraîche de WINE va mettre en place la structure suivante lors de la première utilisation par un utilisateur:</p></div><div class=ulist><ul><li><p><span class=filename>.update-timestamp</span>: contient la date de la dernière modification de <span class=filename>file /usr/share/wine/wine.inf</span>. WINE utilise cela pour déterminer si un préfixe n’est plus à jour et le met à jour automatiquement si besoin.</p></li><li><p><span class=filename>dosdevices/</span>: contient la correspondance entre les ressources de Windows® et les ressources du système hôte (FreeBSD) afin de rendre possible les interactions entre les deux systèmes.
Par exemple, après une nouvelle installation de WINE, ce répertoire devrait contenir au moins deux éléments permettant l’accès au système de fichiers de FreeBSD en utilisant le modèle de Windows®, c’est-à-dire avec les lecteurs associés à des lettres:</p><div class=ulist><ul><li><p><span class=filename>c:@</span> : un lien vers <span class=filename>drive_c</span> décrit juste après.</p></li><li><p><span class=filename>z:@</span> : un lien vers le répertoire racine du système hôte.</p></li></ul></div></li><li><p><span class=filename>drive_c/</span>: émule le disque principal d’un système Windows® (c’est-à-dire: <span class=filename>C:</span>). Il contient une arborescence de répertoires et fichiers imitant celui d’un système Windows® standard. Un préfixe WINE fraîchement créé devrait contenir les répertoires Windows® 10 comme <em>Users</em> et <em>Windows</em> qui contiennent le système d’exploitation lui-même. Par la suite, les applications qui seront installées au sein de ce préfixe se situeront soit dans <em>Program Files</em> ou <em>Program Files (x86)</em>, en fonction de leurs architectures respectives.</p></li><li><p><span class=filename>system.reg</span>: Ce fichier de registres contient les informations sur l’installation de Windows®, qui est dans le cas de WINE, l’environnement se trouvant dans <span class=filename>drive_c</span>.</p></li><li><p><span class=filename>user.reg</span>: Ce fichier de registres contient les configurations personnelles de l’utilisateur courant, générées par divers programmes ou bien via l’utilisation de l’éditeur de registres.</p></li><li><p><span class=filename>userdef.reg</span>: Ce fichier de registres comprends un ensemble de configurations par défaut pour les utilisateurs nouvellement crées.</p></li></ul></div></div><div class=sect3><h4 id=creating-and-using-wine-prefixes>11.5.2. Créer et utiliser un préfixe WINE<a class=anchor href=#creating-and-using-wine-prefixes></a></h4><div class=paragraph><p>Alors que WINE créera par défaut un préfixe dans le répertoire utilisateur <span class=filename>$HOME/.wine/</span>, il est possible de mettre en place plusieurs préfixes.
Il existe plusieurs raisons de procéder ainsi:</p></div><div class=ulist><ul><li><p>La raison la plus courante à cela est d’émuler différentes versions de Windows®, en fonctions des besoins en compatibilité de divers logiciels.</p></li><li><p>Il est également courant de rencontrer certaines applications ne fonctionnant pas correctement dans un environnement WINE par défaut, nécessitant ainsi une configuration spéciale. Il est généralement pratique d’isoler ce genre de programmes dans leur propre préfixe taillé sur mesure, de cette manière cela n’impactera pas le fonctionnement d’autres applications Windows®.</p></li><li><p>De façon similaire, cela peut aussi servir dans l’optique de tests. En effet, on peut très bien dupliquer le préfixe par défaut pour réaliser divers tests de compatibilité sans risquer de compromettre le préfixe principal.</p></li></ul></div><div class=paragraph><p>Pour créer un préfixe depuis le terminal, tapez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nv>WINEPREFIX</span><span class=o>=</span><span class=s2>&#34;/home/username/.wine-new&#34;</span> winecfg</code></pre></div></div><div class=paragraph><p>Ce qui lancera l’utilitaire de configuration des préfixes <code>winecfg</code> (nous verrons ceci de façon plus approfondie dans la section ultérieure).
En définissant un chemin de répertoire pour la variable <code>WINEPREFIX</code>, un nouveau préfixe sera créé à cet endroit, à supposer qu’un préfixe ayant un nom identique ne se trouve pas déjà là.</p></div><div class=paragraph><p>En fournissant la même variable au programme principal de WINE, le logiciel Windows® s’exécutera au sein de ce nouveau préfixe :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nv>WINEPREFIX</span><span class=o>=</span><span class=s2>&#34;/home/username/.wine-new&#34;</span> wine program.exe</code></pre></div></div></div><div class=sect3><h4 id=configuring-wine-prefixes-with-winecfg>11.5.3. Configuration des préfixes WINE à l’aide de winecfg<a class=anchor href=#configuring-wine-prefixes-with-winecfg></a></h4><div class=paragraph><p>Comme expliqué plus haut, WINE inclut <code>winecfg</code> un outil qui permet la configuration des préfixes depuis une interface graphique.
Il comprend plusieurs fonctionnalités qui sont détaillées dans les sections suivantes.
Quand <code>winecfg</code> est lancé depuis un préfixe, ou bien lancé en combinaison avec l’emplacement d’un préfixe dans la variable <code>WINEPREFIX</code>, cela autorisera la configuration de préfixe ainsi sélectionné comme décrit plus loin.</p></div><div class=paragraph><p>Les sélections faites dans l’onglet <em>Applications</em> affecterons la portée des changements effectués dans les onglets <em>Libraries</em> et <em>Graphics</em>, cela signifie que les changements apportés seront cantonnés aux applications sélectionnées.
Voir <a href=https://wiki.winehq.org/Wine_User%27s_Guide#Using_Winecfg>Utiliser Winecfg</a> sur le Wiki de WINE pour plus d’informations.</p></div><div class=sect4><h5 id=applications>11.5.3.1. Applications<a class=anchor href=#applications></a></h5><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-config-1.png alt="wine config 1"></div></div><div class=paragraph><p>L’onglet <em>Applications</em> permet d’associer des programmes avec une version particulière de Windows®.
Au premier démarrage de WINE, cet onglet contiendra simplement une seule entrée: <em>Default Settings</em>.
Cela correspond à toutes les configurations par défaut du préfixe, cette entrée (comme l’implique le bouton <em>Remove application</em> désactivé) ne peut être pas supprimée du préfixe.</p></div><div class=paragraph><p>Mais, des applications additionnelles peuvent être ajoutées en suivant le procédé ci-dessous:</p></div><div class="olist arabic"><ol class=arabic><li><p>Cliquez sur le bouton <em>Add application</em>;</p></li><li><p>Utilisez la fenêtre qui apparaît alors pour sélectionner l’exécutable du programme voulu;</p></li><li><p>Sélectionnez la version de Windows® qui sera utilisée pour le programme sélectionné.</p></li></ol></div></div><div class=sect4><h5 id=libraries>11.5.3.2. Bibliothèques (onglet <em>Libraries</em>)<a class=anchor href=#libraries></a></h5><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-config-2.png alt="wine config 2"></div></div><div class=paragraph><p>WINE fourni par défaut un ensemble de bibliothèques open source reproduisant les mêmes fonctionnalités que leurs équivalent Windows®.
Cependant, comme vu précédemment dans ce chapitre, le projet WINE fait en sorte de s’adapter au rythme des mise à jour de ces bibliothèques.
De ce fait, les versions fournies avec WINE peuvent ne pas disposer de certaines fonctionnalités attendues par les programmes Windows® les plus récents.</p></div><div class=paragraph><p>Il est toutefois possible, grâce à <code>winecfg</code>, de remplacer spécifiquement les bibliothèques de bases de WINE, tout particulièrement si une installation de Windows® est disponible sur la machine hôte.
Pour chaque dépendance ayant besoin d’être remplacée, il suffit de procéder comme indiqué en dessous:</p></div><div class="olist arabic"><ol class=arabic><li><p>Ouvrez le menu déroulant <em>New override for library</em> et sélectionnez la bibliothèque à remplacer;</p></li><li><p>Cliquez sur le bouton <em>Add</em>;</p></li><li><p>Le nouveau remplacement apparaîtra dans la liste <em>Existing overrides</em>, notez les mentions <em>native, builtin</em> entre parenthèses;</p></li><li><p>Cliquez pour sélectionner une bibliothèque;</p></li><li><p>Cliquez sur le bouton <em>Edit</em>;</p></li><li><p>Servez-vous de la fenêtre de dialogue pour sélectionner la bibliothèque à utiliser à la place de celle intégrée par défaut dans WINE.</p></li></ol></div><div class=paragraph><p>Faites attention à bien sélectionner un fichier qui correspond à la version de la bibliothèque intégrée à WINE, dans le cas contraire, les programmes pourraient ne pas fonctionner comme attendu.</p></div></div><div class=sect4><h5 id=graphics>11.5.3.3. Configuration graphique (onglet <em>Graphics</em>)<a class=anchor href=#graphics></a></h5><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-config-3.png alt="wine config 3"></div></div><div class=paragraph><p>L’onglet <em>Graphics</em> fournit des options permettant à la fenêtre du programme lancé via WINE de fonctionner avec des performances optimales sous FreeBSD:</p></div><div class=ulist><ul><li><p>Capture automatique de la souris lorsqu’il s’agit d’une fenêtre en plein écran;</p></li><li><p>Autoriser le gestionnaire de fenêtre de FreeBSD à prendre en charge la décoration des fenêtres, comme la barre de titre des applications WINE par exemple;</p></li><li><p>Autoriser le gestionnaire de fenêtre de FreeBSD à contrôler les fenêtres des applications WINE, cela concerne les fonctionnalités telles que redimensionner une fenêtre;</p></li><li><p>Créer un bureau virtuel émulé dans lequel seront lancés tous les programmes WINE.
Une fois cette option cochée, il est possible de définir la taille de ce bureau virtuel via les zones de saisie en face de <em>Desktop size</em>;</p></li><li><p>Définir la définition de l’écran pour les programmes lancés via WINE.</p></li></ul></div></div><div class=sect4><h5 id=desktop-integration>11.5.3.4. Intégration avec l’environnement de bureau (onglet <em>Desktop Integration</em>)<a class=anchor href=#desktop-integration></a></h5><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-config-4.png alt="wine config 4"></div></div><div class=paragraph><p>Cet onglet permet la configuration des éléments suivants:</p></div><div class=ulist><ul><li><p>Les paramètres de thème et d’aspect visuel pour les programmes lancés via WINE;</p></li><li><p>Si le sous-système WINE doit gérer les associations MIME (utilisé pour déterminer quelle application ouvre tel type de fichier particulier) de manière interne ou non;</p></li><li><p>La correspondance des répertoires de la machine FreeBSD hôte avec les répertoires utiles au sein de l’environnement Windows®.
Afin de changer les associations présentes par défaut, sélectionnez l’élément voulu et cliquez sur <em>Browse</em>, puis sélectionnez un répertoire dans la fenêtre qui apparaît.</p></li></ul></div></div><div class=sect4><h5 id=drives>11.5.3.5. Disques (onglet <em>Drives</em>)<a class=anchor href=#drives></a></h5><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-config-5.png alt="wine config 5"></div></div><div class=paragraph><p>L’onglet <em>Drives</em> permet de créer un lien d’un répertoire du système hôte FreeBSD vers une lettre de lecteurs de l’environnement Windows®.
Les valeurs par défaut devraient être familières, car elles affichent le contenu de <span class=filename>dosdevices/</span> dans le préfixe WINE courant.
Les changements effectués dans cet onglet se répercuteront dans <span class=filename>dosdevices</span>, et les liens correctement formatés présents dans ce répertoire apparaîtront dans cet onglet également.</p></div><div class=paragraph><p>Pour créer une nouvelle entrée, par exemple pour un CD-ROM (monté dans <span class=filename>/mnt/cdrom</span>), il suffit réaliser les étapes suivantes:</p></div><div class="olist arabic"><ol class=arabic><li><p>Cliquez sur le bouton <em>Add</em>;</p></li><li><p>Dans la nouvelle fenêtre, choisissez une lettre de lecteur disponible;</p></li><li><p>Cliquez sur <em>OK</em>;</p></li><li><p>Remplissez la zone de saisie <em>Path</em> soit en tapant le chemin vers la ressource, soit en cliquant sur <em>Browse</em> pour sélectionner la ressource en question.</p></li></ol></div><div class=paragraph><p>Par défaut, WINE détecte le type de ressource liée, mais cela peut être changé manuellement si besoin.
Voir <a href=https://wiki.winehq.org/Wine_User%27s_Guide#Drive_Settings>la section correspondante dans le Wiki de WINE</a> pour plus de détails sur les options avancées.</p></div></div><div class=sect4><h5 id=audio>11.5.3.6. Audio<a class=anchor href=#audio></a></h5><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-config-6.png alt="wine config 6"></div></div><div class=paragraph><p>Cet onglet comprend des options configurable afin de router le son depuis les programmes Windows® vers le système de son natif de FreeBSD, notamment:</p></div><div class=ulist><ul><li><p>La sélection du pilote;</p></li><li><p>La sélection du périphérique audio par défaut;</p></li><li><p>Un test audio.</p></li></ul></div></div><div class=sect4><h5 id=about>11.5.3.7. A propos (onglet <em>About</em>)<a class=anchor href=#about></a></h5><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/wine-config-7.png alt="wine config 7"></div></div><div class=paragraph><p>Le dernier onglet contient des informations à propos du projet WINE, comme un lien vers le site Web.
Cet onglet contient par ailleurs des champs de saisies pour les informations de l’utilisateur (complètement optionnel), bien que ces informations ne soient envoyées absolument nulle part au contraire d’autres systèmes d’exploitation.</p></div></div></div></div><div class=sect2><h3 id=wine-management-guis>11.6. Interfaces graphiques de gestion de WINE<a class=anchor href=#wine-management-guis></a></h3><div class=paragraph><p>Bien que WINE soit fourni avec <code>winecfg</code>, un outil de configuration par interface graphique, ce dernier sert surtout à: configurer dans les grandes ligne un préfixe WINE existant.
Cependant, il existe des applications plus avancées qui pourront assister les installations de certaines applications de même qu’optimiser leur environnement WINE lié.
La section qui suit, inclut une sélection des outils de ce type les plus populaires.</p></div><div class=sect3><h4 id=winetricks>11.6.1. Winetricks<a class=anchor href=#winetricks></a></h4><div class=paragraph><p>Le programme <code>winetricks</code> est un assistant multiplate-forme et complet pour WINE.
Il n’est pas développé par le projet WINE, mais est maintenu par un groupe de contributeurs sur <a href=https://github.com/Winetricks/winetricks>Github</a>.
Il contient "recettes" automatisées pour faire fonctionner un certain nombre d’applications communes sous WINE, en optimisant à la fois les paramètres et en installant certaines DLL automatiquement.</p></div><div class=sect4><h5 id=installing-winetricks>11.6.1.1. Installer winetricks<a class=anchor href=#installing-winetricks></a></h5><div class=paragraph><p>Pour installer winetricks sur FreeBSD en version pré-compilée, utilisez la commande suivante (notez que cela nécessite que le paquet i386-wine ou bien i386-wine-devel soit installé, par conséquent ils seront installés automatiquement avec d’autres dépendances):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install i386-wine winetricks</span></code></pre></div></div><div class=paragraph><p>Pour compiler <code>winetricks</code> depuis les sources, tapez les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/i386-wine</span>
<span class=c># make install</span>
<span class=c># cd /usr/ports/emulators/winetricks</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>Si une installation manuelle est requise, référez-vous la page suivante pour des instructions: <a href=https://github.com/Winetricks/winetricks>Github</a>.</p></div></div><div class=sect4><h5 id=using-winetricks>11.6.1.2. Utiliser winetricks<a class=anchor href=#using-winetricks></a></h5><div class=paragraph><p>Lancer <code>winetricks</code> avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% winetricks</code></pre></div></div><div class=paragraph><p>Notez qu’un préfixe WINE en 32 bits doit être présent pour lancer effectivement <code>winetricks</code>.
Lancer <code>winetricks</code> aura pour effet de faire apparaître une fenêtre proposant un certain nombre de choix, comme celle-ci:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-run-1.png alt="winetricks run 1"></div></div><div class=paragraph><p>Sélectionner soit <em>Install an application</em>, soit <em>Install a benchmark</em>, ou encore <em>Install a game</em> affichera une liste avec une liste d’options prises en charge, comme ci-dessous pour les applications:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-run-2.png alt="winetricks run 2"></div></div><div class=paragraph><p>Sélectionner un ou plusieurs éléments et cliquer sur <em>OK</em> démarrera automatiquement leur(s) processus d’installation.
Au début, certains messages qui ont l’air d’être des erreurs peuvent apparaître, mais il s’agit en fait d’informations et d’alertes mentionnant la manière de contourner certains problèmes éventuels pour certaines applications:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-app-install-1.png alt="winetricks app install 1"></div></div><div class=paragraph><p>Une fois ces messages contournés, l’installation des applications en question sera effectivement lancée:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-app-install-2.png alt="winetricks app install 2"></div></div><div class=paragraph><p>Une fois l’installation terminée, le nouveau logiciel Windows® devrait être disponible depuis le menu de l’environnement de bureau (comme ici, avec l’environnement de bureau LXQT):</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-menu-1.png alt="winetricks menu 1"></div></div><div class=paragraph><p>Pour supprimer l’application, lancez de nouveau <code>winetricks</code> et sélectionnez <em>Run an uninstaller</em>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-uninstall-1.png alt="winetricks uninstall 1"></div></div><div class=paragraph><p>Une fenêtre Windows® apparaîtra pour lister tous les programmes et composants installés au sein de ce préfixe.
Choisissez l’application à supprimer, puis cliquez sur le bouton <em>Modify/Remove</em>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-uninstall-2.png alt="winetricks uninstall 2"></div></div><div class=paragraph><p>Cela lancera l’installateur interne de l’application en question, qui devrait également comprendre une option pour la désinstallation:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/winetricks-uninstall-3.png alt="winetricks uninstall 3"></div></div></div></div><div class=sect3><h4 id=homura>11.6.2. Homura<a class=anchor href=#homura></a></h4><div class=paragraph><p>Homura est une application qui ressemble à <code>winetricks</code>, mais ce dernier s’inspire surtout de <a href=https://lutris.net/>Lutris</a>, qui est un système axé sur le jeu vidéo pour les plateformes Linux.
Bien que cela soit centré sur le jeu vidéo, il y a aussi des applications n’étant pas des jeux qui sont disponibles pour l’installation au sein d’Homura.</p></div><div class=sect4><h5 id=installing-homura>11.6.2.1. Installer Homura<a class=anchor href=#installing-homura></a></h5><div class=paragraph><p>Pour installer la version compilée d’Homura, tapez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install homura</span></code></pre></div></div><div class=paragraph><p>Homura est aussi disponible via le catalogue de logiciels portés de FreeBSD.
Cependant, au contraire de WINE ou <code>winetricks</code>, il se trouve dans la section <em>games</em> plutôt que dans la section <em>emulators</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/games/homura</span>
<span class=c># make install</span></code></pre></div></div></div><div class=sect4><h5 id=using-homura>11.6.2.2. Utiliser Homura<a class=anchor href=#using-homura></a></h5><div class=paragraph><p>L’utilisation d’Homura est relativement similaire à celle de <code>winetricks</code>.
Lorsque vous le lancez pour la première fois, via une ligne de commande (ou via un lanceur de votre environnement de bureau):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% Homura</code></pre></div></div><div class=paragraph><p>Cela devrait afficher le message d’accueil du programme.
Cliquez sur <em>OK</em> pour continuer.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-launch-1.png alt="homura launch 1"></div></div><div class=paragraph><p>Le logiciel proposera la création d’un raccourci dans le menu des environnements de bureaux compatibles:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-run-2.png alt="homura run 2"></div></div><div class=paragraph><p>En fonction de la configuration de la machine FreeBSD hôte, il se peut qu’Homura affiche un message vous incitant à rapidement installer les pilotes natifs pour votre carte graphique.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-run-3.png alt="homura run 3"></div></div><div class=paragraph><p>La fenêtre principale de l’application devrait désormais apparaître, elle correspond plus ou moins à une sorte de menu principal avec toutes ses options.
Nombre de ces éléments sont identiques à ceux trouvés dans <code>winetricks</code>, néanmoins, Homura en propose également des nouveaux, comme une option utile pour ouvrir le répertoire des données (<em>Open Homura Folder</em>) ou de lancer un programme particulier au sein du préfixe (<em>Run a executable in prefix</em>).</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-1.png alt="homura install 1"></div></div><div class=paragraph><p>Pour choisir une application prise en charge et l’installer, sélectionnez <em>Installation</em>, puis cliquez sur <em>OK</em>.
Cela affichera une liste d’applications qu’Homura pourra installer automatiquement.
Choisissez-en une, puis cliquez sur <em>OK</em> pour en commencer l’installation.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-2.png alt="homura install 2"></div></div><div class=paragraph><p>Homura commencera d’abord par télécharger l’application en question.
Dans un environnement de bureau le prenant en charge, une notification est susceptible d’apparaître.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-3.png alt="homura install 3"></div></div><div class=paragraph><p>De plus, le programme se chargera de générer un nouveau préfixe pour l’application.
Une fenêtre standard de WINE devrait apparaître avec ce message:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-4.png alt="homura install 4"></div></div><div class=paragraph><p>Ensuite, Homura se chargera d’installer tous les prérequis pour ledit programme.
Ce qui peut impliquer le téléchargement et l’extraction d’un certain nombre de fichiers, les détails de ces actions apparaîtront dans une fenêtre comme ceci:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-5.png alt="homura install 5"></div></div><div class=paragraph><p>Les paquets téléchargés seront automatiquement extraits et installés en fonction des besoins.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-6.png alt="homura install 6"></div></div><div class=paragraph><p>L’installation peut se solder par une simple notification de bureau ou un message dans le terminal, en fonction de la manière dont Homura a été lancé.
Mais dans tous les cas, Homura devrait de nouveau afficher son écran principal.
Afin de vérifier si l’installation a effectivement été menée à bien, choisissez <em>Launcher</em>, puis cliquez sur <em>OK</em>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-7.png alt="homura install 7"></div></div><div class=paragraph><p>Cela affichera une liste des programmes installés.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-install-8.png alt="homura install 8"></div></div><div class=paragraph><p>Pour lancer le nouveau programme, sélectionnez le depuis la liste, puis cliquez sur <em>OK</em>.
Afin de procéder à la désinstallation d’une application, choisissez <em>Uninstallation</em> depuis le menu principal, ce qui devrait afficher une liste similaire.
Choisissez un programme à supprimer, puis cliquez sur <em>OK</em>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/wine/homura-uninstall-1.png alt="homura uninstall 1"></div></div></div></div><div class=sect3><h4 id=running-multiple-management-guis>11.6.3. Utiliser plusieurs outils graphiques de gestion<a class=anchor href=#running-multiple-management-guis></a></h4><div class=paragraph><p>Il est à noter que l’installation d’un outil n’exclut pas l’utilisation d’un autre.
Il est totalement possible, et même intéressant, d’avoir plusieurs outils installés en même temps, comme ils offrent le support de différents programmes.</p></div><div class=paragraph><p>Cependant, assurez-vous au préalable qu’ils n’accèdent pas au même préfixe WINE.
Chacun de ces logiciels applique des solutions de contournement et appliquent des changements aux registres en fonction de problèmes connus au sein de WINE afin de permettre la bonne exécution d’un programme.
Utiliser <code>wintricks</code> et Homura sur le même préfixe WINE pourrait compromettre ces changements et rendre ainsi certaines applications instables.</p></div></div></div><div class=sect2><h3 id=wine-in-multi-user-os-installations>11.7. WINE sur un système FreeBSD avec plusieurs utilisateurs<a class=anchor href=#wine-in-multi-user-os-installations></a></h3><div class=sect3><h4 id=issues-with-using-a-common-wine-prefix>11.7.1. Problèmes avec l’utilisation d’un préfixe WINE commun<a class=anchor href=#issues-with-using-a-common-wine-prefix></a></h4><div class=paragraph><p>Comme la plupart des systèmes d’exploitation de type UNIX®, FreeBSD est conçu de sorte que plusieurs utilisateurs puissent être connectés et peuvent travailler sur la même machine en même temps.
D’un autre côté, Windows® est aussi un système multi-utilisateurs, mais dans le sens où il peut y avoir plusieurs comptes utilisateur sur un même système.
Mais, l’objectif est qu’un seul utilisateur à la fois se serve de la machine physique (ordinateur portable ou fixe).</p></div><div class=paragraph><p>Les récentes versions grand public de Windows® ont amélioré l’utilisation du système dans le cas d’un scénario multi-utilisateurs.
Mais le système reste largement structuré pour une utilisation mono-utilisateur.
De plus, les mesures prises par le projet WINE afin de créer un environnement compatible Windows® impliquent, contrairement à aux applications FreeBSD (y compris WINE lui-même), qu’il s’approchera d’un environnement mono-utilisateur.</p></div><div class=paragraph><p>Ce qui veut dire, dans cette optique, que chaque utilisateur devra gérer son propre ensemble de configurations, ce qui est potentiellement une bonne chose.
Cela dit, il peut être avantageux d’installer certaines applications une seule fois, notamment les plus lourdes, comme les suites de bureautique ou les jeux vidéo.
Deux raisons évidentes pour vouloir procéder ainsi: la maintenance (les mises à jour ne devront être effectuées qu’une seule fois) et l’efficacité en termes d’espace disque (pas de duplications de fichiers).</p></div><div class=paragraph><p>Il existe deux stratégies dans le but de minimiser l’impact de plusieurs utilisateurs WINE sur le système.</p></div></div><div class=sect3><h4 id=installing-applications-to-a-common-drivesettings>11.7.2. Installer des applications sur un disque dur commun<a class=anchor href=#installing-applications-to-a-common-drivesettings></a></h4><div class=paragraph><p>Comme montré dans la section sur la configuration de WINE, ce dernier fourni la possibilité d’intégrer des disques supplémentaires à un préfixe donné.
De cette manière, les applications peuvent être installées à un endroit commun, alors que les utilisateurs pourront toujours avoir un préfixe avec leurs configurations propres (selon le programme).
C’est un bon choix, s’il y a peu d’applications devant être partagées entre les utilisateurs, et s’il y a des programmes qui n’ont besoin que de configurations minimes de leur préfixe pour leur permettre de fonctionner.</p></div><div class=paragraph><p>Les étapes pour procéder comme ceci sont les suivantes:</p></div><div class="olist arabic"><ol class=arabic><li><p>Premièrement, mettre en place un répertoire partagé sur le système avec lequel seront stockés les fichiers, comme <span class=filename>/mnt/windows-drive_d/</span>.
Créer un nouveau dossier, cela est détaillé dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=mkdir&amp;sektion=1&amp;format=html">mkdir(1)</a>.</p></li><li><p>Puis, définir les permissions pour ce nouveau répertoire afin d’autoriser l’accès uniquement aux utilisateurs voulus.
Une manière de procéder est de créer un nouveau groupe, "windows" par exemple, ajouter les utilisateurs en question à ce groupe (voir la sous-section sur les groupes dans la section <a href=./#users-groups>Gestion des comptes et des utilisateurs</a> de ce manuel), puis définir les permissions du répertoire sur <code>770</code> (la section sur les <a href=./#permissions>permissions</a> sous FreeBSD illustre ce processus).</p></li><li><p>Enfin, ajouter ce répertoire au préfixe de l’utilisateur en utilisant <code>winecfg</code> comme décrit plus haut, dans la section sur la configuration de WINE.</p></li></ol></div><div class=paragraph><p>Une fois ceci terminé, les applications pourrons être installées à cet emplacement, et ensuite être lancées en utilisant la lettre de lecteur assignée (ou bien en utilisant le chemin standard façon UNIX®.
Cependant, comme noté plus haut, un seul utilisateur devrait utiliser ces applications (qui pourraient accéder à des fichiers dans leur répertoire d’installation) à la fois.
Il se peut que certaines applications présentent un comportement inattendu lorsqu’elles seront exécutées par un utilisateur qui n’en n’est pas le propriétaire, malgré le fait que ce dernier appartienne bien au groupe ayant les permissions "lecture/écriture/exécution" pour tout le répertoire.</p></div></div><div class=sect3><h4 id=using-a-common-installation-of-wine>11.7.3. Utiliser une installation commune de WINE<a class=anchor href=#using-a-common-installation-of-wine></a></h4><div class=paragraph><p>Si jamais beaucoup d’applications doivent être partagées, ou bien qu’elles nécessitent des réglages spéciaux pour fonctionner correctement, une autre approche peut être requise.
Dans cette méthode, un autre utilisateur est créé tout spécialement dans le but de stocker les préfixes WINE et les applications installées.
Chaque utilisateur voulu sera autorisé à lancer les programmes en tant que ce nouvel utilisateur en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a>.
Cela a pour résultat, que ces utilisateurs peuvent désormais lancer une application WINE comme ils le feraient en temps normal, cela agira simplement comme si cette dernière était lancée par l’utilisateur nouvellement crée, et donc utilisera le préfixe centralisé contenant les configurations ainsi que les programmes.
Pour parvenir à cela, il faut suivre les étapes suivantes:</p></div><div class=paragraph><p>Créez un nouvel utilisateur avec la commande suivante en tant que <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser</span></code></pre></div></div><div class=paragraph><p>Entrez le nom d’utilisateur (par exemple <em>windows</em>) et le nom complet ("Microsoft Windows").
Ensuite acceptez les options par défauts pour les questions restantes.
Puis, installez l’utilitaire <code>sudo</code> en version pré-compilé avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install sudo</span></code></pre></div></div><div class=paragraph><p>Une fois l’installation terminée, éditez <span class=filename>/etc/sudoers</span> comme ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre># User alias specification

# define which users can run the wine/windows programs
User_Alias WINDOWS_USERS = user1,user2

# define which users can administrate (become root)
User_Alias ADMIN = user1

# Cmnd alias specification

# define which commands the WINDOWS_USERS may run
Cmnd_Alias WINDOWS = /usr/bin/wine,/usr/bin/winecfg

# Defaults
Defaults:WINDOWS_USERS env_reset
Defaults:WINDOWS_USERS env_keep += DISPLAY
Defaults:WINDOWS_USERS env_keep += XAUTHORITY
Defaults    !lecture,tty_tickets,!fqdn

# User privilege specification
root    ALL=(ALL) ALL

# Members of the admin user_alias, defined above, may gain root privileges
ADMIN ALL=(ALL) ALL

# The WINDOWS_USERS may run WINDOWS programs as user windows without a password
WINDOWS_USERS ALL = (windows) NOPASSWD: WINDOWS</pre></div></div><div class=paragraph><p>Cela permet aux utilisateurs nommés dans la section <em>User_Alias</em> de lancer les programmes listés à la section <em>Cmnd Alias</em> en utilisant les ressources listées dans la section <em>Defaults</em> (sur l’affichage en cours d’utilisation) comme s’il s’agissait de l’utilisateur listé dans la dernière ligne du fichier.
Autrement dit, les utilisateurs désignés comme <em>WINDOWS_USERS</em> peuvent lancer les applications WINE et <code>winecfg</code> comme étant l’utilisateur <em>windows</em>.
De plus, cette configuration signifie que les utilisateurs membres de ce groupe n’auront pas à entrer le mot de passe pour l’utilisateur <em>windows</em>.</p></div><div class=paragraph><p>Ensuite, il faut donner l’accès à l’affichage pour l’utilisateur <em>windows</em>, sachant que c’est sous cet utilisateur que les programmes WINE seront lancés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xhost +local:windows</code></pre></div></div><div class=paragraph><p>C’est une commande qui devrait être ajoutée à la liste des commandes lancées à la connexion ou au démarrage de l’environnement de bureau.
Une fois que tout ceci est prêt, un utilisateur configuré comme un de <code>WINDOW_USERS</code> dans <span class=filename>sudoers</span> peut lancer les programmes en utilisant le préfixe en commun avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sudo</span> <span class=nt>-u</span> windows wine program.exe</code></pre></div></div><div class=paragraph><p>Il faut noter cela dit, que si plusieurs utilisateurs accèdent à cet environnement partagé en même temps, cela présente toujours un risque.
Cependant, il faut aussi garder en tête que cet environnement partagé peut contenir plusieurs préfixes WINE.
De cette manière, un administrateur peut créer, tester et vérifier un ensemble de programmes, chacun dans son propre préfixe.
Dans le même temps, un utilisateur peut jouer à un jeu pendant qu’un autre utilise une suite bureautique sans pour autant multiplier des installations redondantes.</p></div></div></div><div class=sect2><h3 id=wine-on-os-faq>11.8. WINE sur FreeBSD Foire Aux Questions<a class=anchor href=#wine-on-os-faq></a></h3><div class=paragraph><p>La section suivante détaille les questions posées fréquemment, les trucs et astuces, ou bien les problèmes souvent rencontrés avec WINE sur FreeBSD, avec leurs réponses respectives.</p></div><div class=sect3><h4 id=basic-installation-and-usage>11.8.1. Installation et utilisation basique<a class=anchor href=#basic-installation-and-usage></a></h4><div class=sect4><h5 id=how-to-install-32-bit-and-64-bit-wine-on-the-same-system>11.8.1.1. Comment installer la version 32 bits et la versions 64 bits sur le même système?<a class=anchor href=#how-to-install-32-bit-and-64-bit-wine-on-the-same-system></a></h5><div class=paragraph><p>Comme déjà mentionné, les paquets wine et i386-wine entrent en conflit s’ils sont installés normalement sur le même système.
Néanmoins, plusieurs types d’installations peuvent être mis en place en utilisant des mécanismes comme chroots/jails, ou en compilant WINE directement depuis les sources (hors catalogue de logiciels portés de FreeBSD).</p></div></div><div class=sect4><h5 id=can-dos-programs-be-run-on-wine>11.8.1.2. Peut-on utiliser un programme DOS sous WINE ?<a class=anchor href=#can-dos-programs-be-run-on-wine></a></h5><div class=paragraph><p>Théoriquement oui, car ce sont des programmes en interfaces console comme nous l’avons vu plus haut.
Cela dit, il existe une méthode plus adaptée à cela, il suffit d’utiliser <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/dosbox/>DOSBox</a>.
Bien sûr, cela ne coûte rien d’essayer.
Créez simplement un nouveau préfixe WINE, installez le programme et si cela ne marche pas, supprimez le préfixe.</p></div></div><div class=sect4><h5 id=should-the-wine-devel-packageport-be-installed-to-use-the-development-version-of-wine-instead-of-stable>11.8.1.3. Est-ce que le paquet <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/wine-devel/>emulators/wine-devel</a> doit être installé pour pouvoir utiliser la version en développement de WINE à la place de la version stable?<a class=anchor href=#should-the-wine-devel-packageport-be-installed-to-use-the-development-version-of-wine-instead-of-stable></a></h5><div class=paragraph><p>Oui, cette version installe la version développement de WINE.
Comme avec les versions 32 et 64 bits de WINE, la version développement ne peux pas être installée en même temps que la version stable sans mesures additionnelles.</p></div><div class=paragraph><p>Notez qu’il existait aussi une version "Staging" de WINE, contenant les mises à jour les plus récentes du projet.
Cette version était disponible dans le catalogue de logiciels portés de FreeBSD, mais a depuis été supprimée.
Cette version est toujours compilable depuis les sources cela dit.</p></div></div></div><div class=sect3><h4 id=install-optimization>11.8.2. Optimisation de l’installation<a class=anchor href=#install-optimization></a></h4><div class=sect4><h5 id=how-should-windows-hardware-graphics-drivers-be-handled>11.8.2.1. Comment les pilotes (de carte graphique par exemple) Windows® sont pris en charge?<a class=anchor href=#how-should-windows-hardware-graphics-drivers-be-handled></a></h5><div class=paragraph><p>Les pilotes de périphériques se chargent de transférer des commandes depuis une application vers le matériel de la machine.
WINE émule un environnement Windows®, ce qui inclut les pilotes, qui utilisent ensuite les pilotes natifs de FreeBSD pour effectuer ce transfert.
Il n’est pas recommandé d’installer des pilotes Windows®, car WINE est conçu de manière à interagir avec les pilotes du système hôte.
Si par exemple, des pilotes de cartes graphiques améliorent ses performances, veuillez plutôt installer la version FreeBSD et non leur équivalent Windows®.</p></div></div><div class=sect4><h5 id=is-there-a-way-to-make-windows-fonts-look-better>11.8.2.2. Est-il possible d’améliorer l’apparence des polices de caractères Windows®?<a class=anchor href=#is-there-a-way-to-make-windows-fonts-look-better></a></h5><div class=paragraph><p>Un utilisateur sur le forum FreeBSD propose cette configuration pour régler l’apparence des polices Windows® qui sont par défaut légèrement pixélisées.</p></div><div class=paragraph><p>Selon <a href=https://forums.freebsd.org/threads/make-wine-ui-fonts-look-good.68273/>ce post sur le forum FreeBSD</a>, ajouter ce qui suit au fichier <span class=filename>.config/fontconfig/fonts.conf</span> devrait ajouter de l’anti-crenélage et rendre le texte plus lisible.</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&gt;&#34;

&lt;fontconfig&gt;

  &lt;!-- antialias all fonts --&gt;
  &lt;match target=&#34;font&#34;&gt;
    &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;&lt;bool&gt;true&lt;/bool&gt;&lt;/edit&gt;&gt;
    &lt;edit name=&#34;hinting&#34; mode=&#34;assign&#34;&gt;&lt;bool&gt;true&lt;/bool&gt;&lt;/edit&gt;&gt;
    &lt;edit name=&#34;hintstyle&#34; mode=&#34;assign&#34;&gt;&lt;const&gt;hintslight&lt;/const&gt;&lt;/edit&gt;&gt;
    &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;&lt;const&gt;rgb&lt;/const&gt;&lt;/edit&gt;&gt;
  &lt;/match&gt;
&lt;/fontconfig&gt;</pre></div></div></div><div class=sect4><h5 id=does-having-windows-installed-elsewhere-on-a-system-help-wine-operate>11.8.2.3. Installer Windows® ailleurs sur le système peut-il aider WINE à fonctionner?<a class=anchor href=#does-having-windows-installed-elsewhere-on-a-system-help-wine-operate></a></h5><div class=paragraph><p>C’est possible, en fonction de l’application devant être exécutée.
Comme mentionné dans la section sur <code>winecfg</code>, certaines DLLs intégrées par défaut avec WINE et d’autres bibliothèques peuvent être remplacés en fournissant le chemin de versions alternatives.
Si la partition ou le disque Windows® est montée et accessible pour l’utilisateur sous FreeBSD, il est alors possible de remplacer certaines DLL de WINE par les versions natives du système Windows®, diminuant potentiellement le risque de fonctionnement inattendus de certaines applications.</p></div></div></div><div class=sect3><h4 id=application-specific>11.8.3. Spécifique à une application<a class=anchor href=#application-specific></a></h4><div class=sect4><h5 id=where-is-the-best-place-to-see-if-application-x-works-on-wine>11.8.3.1. Quel est le meilleur endroit pour savoir si une application fonctionne sous WINE?<a class=anchor href=#where-is-the-best-place-to-see-if-application-x-works-on-wine></a></h5><div class=paragraph><p>La première étape pour savoir si une application est compatible doit être le site <a href=https://appdb.winehq.org/>WINE AppDB</a>.
Il s’agit d’un site qui répertorie les programmes fonctionnant ou non sous WINE sur toutes les plateformes supportées, et les solutions pour les faire fonctionner, solutions qui sont souvent applicables sur d’autres plateformes.</p></div></div><div class=sect4><h5 id=is-there-anything-that-will-help-games-run-better>11.8.3.2. Y a-t-il quelque chose permettant à un jeu vidéo de mieux fonctionner?<a class=anchor href=#is-there-anything-that-will-help-games-run-better></a></h5><div class=paragraph><p>Peut-être.
Beaucoup de jeux Windows® se basent sur DirectX, une surcouche graphique propriétaire de Microsoft.
Cependant, il existe des projets open source qui tentent d’implémenter une prise en charge pour cette technologie.</p></div><div class=paragraph><p>Le projet <em>dxvk</em>, est une tentative d’implémenter DirectX en utilisant le sous-système graphique Vulkan compatible avec FreeBSD.
Bien que ce système soit avant tout conçu pour fonctionner pour la version Linux de WINE; il est apparemment possible d’utiliser ce système sur FreeBSD <a href=https://forums.freebsd.org/threads/what-about-gaming-on-freebsd.723/page-9>selon certains utilisateurs du forum FreeBSD</a>.</p></div><div class=paragraph><p>De plus, des initiatives sont en cours pour intégrer <a href=https://www.freshports.org/emulators/wine-proton/>WINE Proton</a>.
Cela devrait amener la version de Valve, développeur de la plateforme de jeux vidéo Steam, sur FreeBSD.
Proton est une version de WINE spécialement conçue pour que nombre de jeux Windows® puissent tourner avec un minimum de manipulation de la part de l’utilisateur.</p></div></div><div class=sect4><h5 id=is-there-anywhere-freebsd-wine-users-gather-to-exchange-tips-and-tricks>11.8.3.3. Où les utilisateurs de WINE sous FreeBSD se ressemblent pour échanger des conseils et astuces?<a class=anchor href=#is-there-anywhere-freebsd-wine-users-gather-to-exchange-tips-and-tricks></a></h5><div class=paragraph><p>Il existe pas mal d’endroits où les utilisateurs FreeBSD discutent de problèmes liés à WINE, qui peuvent être utilisés pour rechercher des solutions:</p></div><div class=ulist><ul><li><p><a href=https://forums.freebsd.org/>Le forum FreeBSD</a>, tout particulièrement les sections <em>Installation and Maintenance of Ports or Packages</em> ou <em>Emulation and virtualization</em>.</p></li><li><p><a href=https://wiki.freebsd.org/IRC/Channels>Les canaux IRC de FreeBSD</a>, dont #freebsd (pour un support général), #freebsd-games, ou autres.</p></li><li><p><a href=https://discord.gg/2CCuhCt>Le serveur discord: The BSD World</a>, notamment les canaux <em>bsd-desktop</em>, <em>bsd-gaming</em>, <em>bsd-wine</em>, et autres.</p></li></ul></div></div></div><div class=sect3><h4 id=other-os-resources>11.8.4. Les ressource provenant d’autres systèmes d’exploitation<a class=anchor href=#other-os-resources></a></h4><div class=paragraph><p>Il existe un certain nombre de ressources relatives au fonctionnement de WINE sous d’autres systèmes d’exploitation qui peuvent cependant s’avérer utiles pour les utilisateurs de FreeBSD:</p></div><div class=ulist><ul><li><p><a href=https://wiki.winehq.org/>Le Wiki de WINE</a> sur lequel se trouve des tonnes d’informations relatives à l’utilisation de WINE, qui sont bien souvent applicables à tous les systèmes d’exploitation pris en charge par WINE;</p></li><li><p>De plus, la documentation d’autre systèmes d’exploitation peut aussi s’avérer utile comme <a href=https://wiki.archlinux.org/index.php/wine>la page WINE</a> sur le Wiki de la distribution Arch Linux, bien que certaines applications tierces (i.e., "companion applications") ne soient bien évidemment pas disponibles sous FreeBSD;</p></li><li><p>Enfin, Codeweavers (le développeur d’une version commerciale de WINE) est un contributeur actif au projet WINE. Souvent, les réponses aux questions <a href=https://www.codeweavers.com/support/forums>sur leur forum</a> peuvent également être utiles pour dépanner des problèmes avec la version open source de WINE.</p></li></ul></div></div></div></div></div><h1 id=system-administration class=sect0>Partie III: Administration Système<a class=anchor href=#system-administration></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Les chapitres restant couvrent tous les aspects de l’administration système de FreeBSD. Chaque chapitre débute en décrivant ce qui sera appris à la lecture du chapitre, et détaille également ce que le lecteur est sensé connaître avant de l’aborder.</p></div><div class=paragraph><p>Ces chapitres sont conçus pour être consultés dès qu’une information est nécessaire. Il n’est pas nécessaire de les lire suivant un ordre particulier, ni tous les lire avant de pouvoir utiliser FreeBSD.</p></div></div></div><div class=sect1><h2 id=config-tuning>Chapitre 12. Configuration et optimisation<a class=anchor href=#config-tuning></a></h2><div class=sectionbody><div class=sect2><h3 id=config-synopsis>12.1. Synopsis<a class=anchor href=#config-synopsis></a></h3><div class=paragraph><p>La configuration correcte d’un système peut sensiblement réduire la quantité de travail impliquée dans la maintenance et la mise à jour. Ce chapitre décrit certains des aspects de la configuration des systèmes FreeBSD.</p></div><div class=paragraph><p>Ce chapitre décrira également certains paramètres qui peuvent être modifiés pour configurer un système FreeBSD pour des performances optimales.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Les bases de la configuration du fichier <span class=filename>rc.conf</span> et des fichiers de démarrage <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Comment configurer et tester une carte réseau.</p></li><li><p>Comment configurer des hôtes virtuels sur vos périphériques réseau.</p></li><li><p>Comment utiliser les divers fichiers de configuration du répertoire <span class=filename>/etc</span>.</p></li><li><p>Comment optimiser FreeBSD en utilisant les variables <code>sysctl</code>.</p></li><li><p>Comment optimiser les performances des disques et modifier les limitations du noyau.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les fondements d’UNIX® et de FreeBSD (<a href=./#basics>Quelques bases d’UNIX</a>).</p></li><li><p>Etre familier avec la configuration et la compilation du noyau (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=configtuning-core-configuration>12.2. Configuration principale<a class=anchor href=#configtuning-core-configuration></a></h3><div class=paragraph><p>L’emplacement principal pour les données de configuration du système est le fichier <span class=filename>/etc/rc.conf</span>. Ce fichier contient une large gamme d’informations de configuration, principalement utilisées au démarrage du système pour configurer ce dernier. Son nom le sous-entend; c’est l’information de configuration pour les fichiers <span class=filename>rc*</span>.</p></div><div class=paragraph><p>Un administrateur devrait ajouter des entrées dans le fichier <span class=filename>rc.conf</span> pour remplacer les valeurs par défaut du fichier <span class=filename>/etc/defaults/rc.conf</span>. Les fichiers de valeurs par défaut ne devraient pas être copiés directement tels quels dans <span class=filename>/etc</span> - ils contiennent des valeurs par défaut, et non pas des exemples. Tout changement spécifique au système devrait être fait dans le fichier <span class=filename>rc.conf</span>.</p></div><div class=paragraph><p>Un certain nombre de stratégies peuvent être appliquées dans le cas d’applications en grappe pour séparer la configuration d’un site de celle d’un système afin de réduire le travail d’administration. L’approche recommandée est de placer la configuration propre au site dans le fichier <span class=filename>/etc/rc.conf.local</span>. Par exemple:</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div></li><li><p><span class=filename>/etc/rc.conf.local</span>:</p><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div></li></ul></div><div class=paragraph><p>Le fichier <span class=filename>rc.conf</span> peut être distribué à l’ensemble des systèmes en utilisant <code>rsync</code> ou un programme semblable, tandis que le fichier <span class=filename>rc.conf.local</span> reste unique.</p></div><div class=paragraph><p>Mettre à jour le système en employant <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> ou <code>make world</code> n’écrasera pas le fichier <span class=filename>rc.conf</span>, les informations de configuration du système ne seront donc pas perdues.</p></div><div class=paragraph><p>Le fichier de configuration <span class=filename>/etc/rc.conf</span> est analysé par <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Cela permet aux administrateurs système d’ajouter un certain niveau de logique à ce fichier, ce qui peut aider à créer des scénaris de configuration complexes. Veuillez consulter <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> pour plus d’information sur ce sujet.</p></div></div><div class=sect2><h3 id=configtuning-appconfig>12.3. Configuration des applications<a class=anchor href=#configtuning-appconfig></a></h3><div class=paragraph><p>Généralement, les applications installées ont leurs propres fichiers de configuration, avec leur propre syntaxe, etc…​ Il est important que ces fichiers soient séparés du système de base, de sorte qu’ils soient facilement localisables et gérables par les outils de gestion des logiciels installés.</p></div><div class=paragraph><p>Ces fichiers sont généralement installés dans le répertoire <span class=filename>/usr/local/etc</span>. Dans le cas où une application possède un grand nombre de fichiers de configuration, un sous-répertoire sera créé pour les héberger.</p></div><div class=paragraph><p>Normalement, quand un logiciel porté ou pré-compilé est installé, des exemples de fichiers de configuration sont également installés. Ces derniers sont généralement identifiés par un suffixe ".default". Si aucun fichier de configuration n’existe pour l’application, on les créera en copiant les fichiers <span class=filename>.default</span>.</p></div><div class=paragraph><p>Par exemple, considérez le contenu du répertoire <span class=filename>/usr/local/etc/apache</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</pre></div></div><div class=paragraph><p>Les tailles des fichiers indiquent que seul le fichier <span class=filename>srm.conf</span> a été modifié. Une mise à jour, plus tard, du logiciel Apache ne devrait pas écraser le fichier modifié.</p></div></div><div class=sect2><h3 id=configtuning-starting-services>12.4. Démarrer des services<a class=anchor href=#configtuning-starting-services></a></h3><div class=paragraph><p>Nombreux sont les utilisateurs qui choisissent d’installer des logiciels tierce partie sous FreeBSD à partir du catalogue des logiciels portés. Dans de nombreuses situations, il peut être nécessaire de configurer le logiciel de manière à ce qu’il soit lancé au démarrage du système. Des services comme <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> sont deux exemples de logiciels parmi tant d’autres qui peuvent être lancés à l’initialisation du système. Cette section explique les procédures disponibles pour démarrer certains logiciels tierce partie.</p></div><div class=paragraph><p>Sous FreeBSD, la plupart des services offerts, comme <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, sont lancés par l’intermédiaire des procédures de démarrage du système. Ces procédures peuvent varier en fonction de la version de FreeBSD, ou du fournisseur; cependant, l’aspect le plus important à considérer est que leur configuration de démarrage peut être gérée à l’aide de procédures de démarrage simples.</p></div><div class=sect3><h4 id=_configuration_étendue_des_applications>12.4.1. Configuration étendue des applications<a class=anchor href=#_configuration_étendue_des_applications></a></h4><div class=paragraph><p>Maintenant que FreeBSD dispose du système <span class=filename>rc.d</span>, la configuration du démarrage des applications est plus simple, et propose plus de possibilités. En utilisant les mots clés présentés dans la section sur le système <a href=#configtuning-rcd>rc.d</a>, les applications peuvent désormais être paramétrées pour démarrer après certains services, par exemple le DNS, des paramètres supplémentaires peuvent être passés par l’intermédiaire de <span class=filename>rc.conf</span> au lieu d’utiliser des paramètres fixes dans les procédures de démarrage, etc. Une procédure de base pourra ressembler à ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Cette procédure s’assurera que l’application utility sera lancée après le le service <code>DAEMON</code>. Elle fournie également une méthode de suivi du PID, ou encore ID (identifiant) de processus.</p></div><div class=paragraph><p>Cette application pourra alors avoir la ligne suivante la concernant dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Cette méthode permet également une manipulation plus aisée des arguments en ligne de commande, l’inclusion des fonctions offertes par défaut dans <span class=filename>/etc/rc.subr</span>, offre une compatibilité avec l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> et fournie une configuration plus aisée par l’intermédiaire du fichier <span class=filename>rc.conf</span>.</p></div></div><div class=sect3><h4 id=_utiliser_des_services_pour_démarrer_dautres_services>12.4.2. Utiliser des services pour démarrer d’autres services<a class=anchor href=#_utiliser_des_services_pour_démarrer_dautres_services></a></h4><div class=paragraph><p>Certains services, comme les serveurs POP3, IMAP, etc., peuvent être démarrés en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. Cela implique d’installer le service à partir du catalogue des logiciels portés et avec une ligne de configuration ajoutée au fichier <span class=filename>/etc/inetd.conf</span>, ou en décommentant une des lignes de configuration déjà présentes. L’utilisation d’inetd et sa configuration sont décrits en profondeur dans la section concernant <a href=./#network-inetd>inetd</a>.</p></div><div class=paragraph><p>Dans certains cas, il peut être plus approprié d’utiliser le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> pour démarrer des services. Cette approche présente un certain nombre d’avantages parce que <code>cron</code> exécute ces processus sous les privilèges du propriétaire de la table <span class=filename>crontab</span>. Cela permet aux utilisateurs normaux de lancer et maintenir certaines applications.</p></div><div class=paragraph><p>L’utilitaire <code>cron</code> offre une fonction unique, <code>@reboot</code>, qui peut être utilisée en remplacement de la date d’exécution. Cela provoquera l’exécution de la tâche quand <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> est lancé, normalement lors de l’initialisation du système.</p></div></div></div><div class=sect2><h3 id=configtuning-cron>12.5. Configuration de l’utilitaire <code>cron</code><a class=anchor href=#configtuning-cron></a></h3><div class=paragraph><p>Un des utilitaires les plus importants de FreeBSD est <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. L’utilitaire <code>cron</code> tourne en arrière plan et contrôle constamment le fichier <span class=filename>/etc/crontab</span>. L’utilitaire <code>cron</code> consulte également le répertoire <span class=filename>/var/cron/tabs</span>, à la recherche de nouveaux fichiers <span class=filename>crontab</span>. Ces fichiers <span class=filename>crontab</span> conservent les informations sur les tâches que <code>cron</code> est censé exécuter à des moments donnés.</p></div><div class=paragraph><p>L’utilitaire <code>cron</code> utilise deux types différents de fichiers de configuration, le fichier <span class=filename>crontab</span> système et les <span class=filename>crontab</span>s des utilisateurs. Ces deux formats diffèrent à partir du sixième champ. Dans le fichier <span class=filename>crontab</span> système, <code>cron</code> exécutera la commande en tant que l’utilisateur indiqué dans le sixième champ. Dans le fichier <span class=filename>crontab</span> d’un utilisateur, toutes les commandes sont exécutées sous l’utilisateur qui a créé ce fichier <span class=filename>crontab</span>, aussi le sixième champ est le dernier champ; c’est un aspect sécurité important. Le dernier champ est toujours la commande à exécuter.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les fichiers <span class=filename>crontab</span> utilisateur permettent aux utilisateurs de planifier l’exécution de tâches sans avoir besoin des privilèges du super-utilisateur <code>root</code>. Les commandes contenues dans le fichier <span class=filename>crontab</span> d’un utilisateur s’exécutent avec les privilèges de l’utilisateur auquel appartient ce fichier.</p></div><div class=paragraph><p>Le super-utilisateur <code>root</code> peut posséder un fichier <span class=filename>crontab</span> utilisateur comme tout autre utilisateur. Ce fichier est différent de <span class=filename>/etc/crontab</span> (le <span class=filename>crontab</span> système). Etant donné que le fichier <span class=filename>crontab</span> système invoque les commandes spécifiées en tant que <code>root</code>, il n’y a généralement pas besoin d’un fichier <span class=filename>crontab</span> utilisateur pour <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Examinons le fichier <span class=filename>/etc/crontab</span> (fichier <span class=filename>crontab</span> système):</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
#<i class=conum data-value=1></i><b>(1)</b>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
HOME=/var/log
#
#
#minute	heure	date	mois	jour	utilisateur	commande <i class=conum data-value=3></i><b>(3)</b>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Comme pour la plupart des fichiers de configuration de FreeBSD, le caractère <code>#</code> indique un commentaire. Un commentaire peut être ajouté dans le fichier comme rappel de ce que fait une action bien précise et pourquoi elle est effectuée. Les commentaires ne peuvent être situés sur la même ligne qu’une commande ou sinon ils seront interprétés comme faisant partie de la commande; ils doivent se trouver sur une nouvelle ligne. Les lignes vides sont ignorées.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Tout d’abord, les variables d’environnement doivent être définies. Le caractère égal (<code>=</code>) est utilisé pour définir tout paramètre concernant l’environnement, comme dans notre exemple où il a été utilisé pour les variables <code>SHELL</code>, <code>PATH</code>, et <code>HOME</code>. Si la ligne concernant l’interpréteur de commande est omise, <code>cron</code> utilisera celui par défaut, qui est <code>sh</code>. Si la variable <code>PATH</code> est omise, il n’y aura pas de valeur par défaut utilisée et l’emplacement des fichiers devra être absolu. Si <code>HOME</code> est omise, <code>cron</code> utilisera le répertoire personnel de l’utilisateur qui l’invoque.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Cette ligne définie un total de sept champs. Sont listés ici les valeurs <code>minute</code>, <code>heure</code>, <code>date</code>, <code>mois</code>, <code>jour</code>, <code>utilisateur</code>, et <code>commande</code>. Ces champs sont relativement explicites. <code>minute</code> représente l’heure en minute à laquelle la commande sera exécutée. L’option <code>heure</code> est semblable à l’option <code>minute</code>, mais en heures. Le champ <code>date</code> précise le jour dans le mois. <code>mois</code> est similaire à <code>heure</code> et <code>minute</code> mais désigne le mois. L’option <code>jour</code> représente le jour de la semaine. Tous ces champs doivent être des valeurs numériques, et respecter un format horaire de vingt quatre heures. Le champ <code>utilisateur</code> est spécial, et n’existe que dans le fichier <span class=filename>/etc/crontab</span>. Ce champ précise sous quel utilisateur sera exécutée la commande. Le dernier champ désigne la commande à exécuter.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Cette dernière ligne définie les valeurs discutées ci-dessus. Nous avons ici <code>*/5</code> suivi de plusieurs caractères <code>\*</code>. Ces caractères <code>*</code> signifient "premier-dernier", et peuvent être interprétés comme voulant dire à <em>chaque</em> instance. Aussi, d’après cette ligne, il apparaît que la commande <code>atrun</code> sera invoquée par l’utilisateur <code>root</code> toutes les cinq minutes indépendamment du jour ou du mois. Pour plus d’informations sur la commande <code>atrun</code>, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=atrun&amp;sektion=8&amp;format=html">atrun(8)</a>. N’importe quel nombre d’indicateur peut être passé à ces commandes; cependant, les commandes qui s’étendent sur de multiples lignes doivent être "cassées" avec le caractère, contre-oblique <code>\</code>, de continuation de lignes.</td></tr></tbody></table></div><div class=paragraph><p>Ceci est la configuration de base pour chaque fichier <span class=filename>crontab</span>, bien qu’il y ait une différence dans celui présenté ici. Le sixième champ, où est précisé le nom d’utilisateur, n’existe que dans le fichier système <span class=filename>/etc/crontab</span>. Ce champ devrait être omis pour les fichiers <span class=filename>crontab</span> d’utilisateur.</p></div><div class=sect3><h4 id=configtuning-installcrontab>12.5.1. Installer un fichier crontab<a class=anchor href=#configtuning-installcrontab></a></h4><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Ne pas utiliser la procédure décrite ci-dessous pour éditer et installer le fichier <span class=filename>crontab</span> système. Utilisez directement votre éditeur: l’utilitaire <code>cron</code> remarquera le changement au niveau de ce fichier et utilisera immédiatement la nouvelle version. Consultez <a href=https://docs.freebsd.org/fr/books/faq/#ROOT-NOT-FOUND-CRON-ERRORS>cette entrée de la FAQ</a> pour plus d’information.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour installer un fichier <span class=filename>crontab</span> utilisateur fraîchement rédigé, tout d’abord utilisez votre éditeur favori pour créer un fichier dans le bon format, ensuite utilisez l’utilitaire <code>crontab</code>. L’usage le plus typique est:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># crontab fichier-crontab</span></code></pre></div></div><div class=paragraph><p>Dans cet exemple, <span class=filename>fichier-crontab</span> est le nom d’un fichier <span class=filename>crontab</span> qui a été précédemment créé.</p></div><div class=paragraph><p>Il existe également une option pour afficher les fichiers <span class=filename>crontab</span> installés, passez simplement le paramètre <code>-l</code> à <code>crontab</code> et lisez ce qui est affiché.</p></div><div class=paragraph><p>Pour les utilisateurs désirant créer leur fichier crontab à partir de zéro, sans utiliser de modèle, l’option <code>crontab -e</code> est disponible. Cela invoquera l’éditeur par défaut avec un fichier vide. Quand le fichier est sauvegardé, il sera automatiquement installé par la commande <code>crontab</code>.</p></div><div class=paragraph><p>Afin d’effacer le fichier <span class=filename>crontab</span> utilisateur complètement, utiliser la commande <code>crontab</code> avec l’option <code>-r</code>.</p></div></div></div><div class=sect2><h3 id=configtuning-rcd>12.6. Utilisation du système <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> sous FreeBSD<a class=anchor href=#configtuning-rcd></a></h3><div class=paragraph><p>En 2002, le système <span class=filename>rc.d</span> de NetBSD pour l’initialisation du système a été intégré à FreeBSD. Les utilisateurs noteront les fichiers présents dans le répertoire <span class=filename>/etc/rc.d</span>. Plusieurs de ces fichiers sont destinés aux services de base qui peuvent être contrôlés avec les options <code>start</code>, <code>stop</code>, et <code>restart</code>. Par exemple, <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> peut être relancé avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd restart</span></code></pre></div></div><div class=paragraph><p>Cette procédure est similaire pour d’autres services. Bien sûr, les services sont généralement lancés automatiquement au démarrage dès qu’ils sont spécifiés dans le fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Par exemple, activer le "daemon" de translation d’adresses au démarrage est aussi simple que d’ajouter la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Si une ligne <code>natd_enable="NO"</code> est déjà présente, modifiez alors le <code>NO</code> par <code>YES</code>. Les procédures rc chargeront automatiquement les autres services dépendants lors du prochain redémarrage comme décrit ci-dessous.</p></div><div class=paragraph><p>Comme le système <span class=filename>rc.d</span> est à l’origine destiné pour lancer/arrêter les services au démarrage/à l’arrêt du système, les options standards <code>start</code>, <code>stop</code> et <code>restart</code> ne seront effectives que si les variables appropriées sont positionnées dans le fichier <span class=filename>/etc/rc.conf</span>. Par exemple, la commande <code>sshd restart</code> ci-dessus ne fonctionnera que si <code>sshd_enable</code> est fixée à <code>YES</code> dans <span class=filename>/etc/rc.conf</span>. Pour lancer, arrêter ou redémarrer un service indépendemment des paramétrages du fichier <span class=filename>/etc/rc.conf</span>, les commandes doivent être précédées par "one". Par exemple pour redémarrer <code>sshd</code> indépendemment du paramétrage du fichier <span class=filename>/etc/rc.conf</span>, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd onerestart</span></code></pre></div></div><div class=paragraph><p>Il est facile de contrôler si un service est activé dans le fichier <span class=filename>/etc/rc.conf</span> en exécutant la procédure <span class=filename>rc.d</span> appropriée avec l’option <code>rcvar</code>. Ainsi, un administrateur peut contrôler que <code>sshd</code> est réellement activé dans <span class=filename>/etc/rc.conf</span> en exécutant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd rcvar</span>
<span class=c># sshd</span>
<span class=nv>$sshd_enable</span><span class=o>=</span>YES</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La seconde ligne (<code># sshd</code>) est la sortie de la commande <code>sshd</code> et non pas une console <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour déterminer si un service est actif, une option appelée <code>status</code> est disponible. Par exemple pour vérifier que <code>sshd</code> a réellement été lancé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>Dans certains cas, il est également possible de recharger un service avec l’option <code>reload</code>. Le système tentera d’envoyer un signal à un service individuel, le forçant à recharger ses fichiers de configuration. Dans la plupart des cas cela signifie envoyer un signal <code>SIGHUP</code> au service. Le support de cette fonctionnalité n’est pas disponible pour chaque service.</p></div><div class=paragraph><p>Le système <span class=filename>rc.d</span> n’est pas uniquement utilisée pour les services réseaux, elle participe à la majeure partie de l’initialisation du système. Prenez par exemple le fichier <span class=filename>bgfsck</span>. Quand cette procédure est exécutée, il affichera le message suivant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Donc ce fichier est utilisé pour les vérifications du système de fichiers en arrière plan, qui sont uniquement effectuées lors de l’initialisation du système.</p></div><div class=paragraph><p>De nombreux services système dépendent d’autres services pour fonctionner correctement. Par exemple, NIS et les autres services basés sur les RPCs peuvent échouer s’ils sont lancés après le lancement du service <code>rpcbind</code> (portmapper). Pour résoudre ce problème, l’information concernant les dépendances et autres méta-données est inclue dans les commentaires au début de chaque procédure de démarrage. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> est alors utilisé pour analyser ces commentaires lors de l’initialisation du système en vue de déterminer l’ordre dans lequel les services système seront invoqués pour satisfaire les dépendances.</p></div><div class=paragraph><p>Les mots suivants doivent être présents en tête de tous les fichiers de démarrage (ils sont nécessaires pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> active les procédures de démarrages):</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: indique les services que fournit ce fichier.</p></li></ul></div><div class=paragraph><p>Les mots clés suivants peuvent être ajoutés au début de chaque fichier de démarrage. Ils ne sont pas strictement nécessaires, mais sont utiles comme aide pour <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>:</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: liste les fichiers dont dépend ce service. Ce fichier sera exécuté <em>après</em> les services indiqués.</p></li><li><p><code>BEFORE</code>: liste les services qui dépendent du service présent. Ce fichier sera exécuté <em>avant</em> les services indiqués.</p></li></ul></div><div class=paragraph><p>En utilisant avec soin ces mots clés pour chaque fichier de démarrage, un administrateur dispose d’un niveau de contrôle très fin de l’ordre d’exécution des procédures de démarrage sans les inconvénients des "runlevels" comme sur d’autres systèmes d’exploitation UNIX®.</p></div><div class=paragraph><p>Des informations supplémentaires concernant le système <span class=filename>rc.d</span> peuvent être trouvées dans les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Si vous êtes intéressé par l’écriture de vos propres procédures <span class=filename>rc.d</span> ou pour l’amélioration des procédures existantes, vous trouverez <a href=https://docs.freebsd.org/en/articles/rc-scripting/>cette article</a> utile.</p></div></div><div class=sect2><h3 id=config-network-setup>12.7. Configuration des cartes réseaux<a class=anchor href=#config-network-setup></a></h3><div class=paragraph><p>De nos jours il est impossible de penser à un ordinateur sans penser connexion à un réseau. Installer et configurer une carte réseau est une tâche classique pour tout administrateur FreeBSD.</p></div><div class=sect3><h4 id=_déterminer_le_bon_pilote_de_périphérique>12.7.1. Déterminer le bon pilote de périphérique<a class=anchor href=#_déterminer_le_bon_pilote_de_périphérique></a></h4><div class=paragraph><p>Avant de commencer, vous devez connaître le modèle de la carte dont vous disposez, le circuit qu’elle utilise, et si c’est une carte PCI ou ISA. FreeBSD supporte une large variété de cartes PCI et ISA. Consultez la liste de compatibilité matérielle pour votre version de FreeBSD afin de voir si votre carte est supportée.</p></div><div class=paragraph><p>Une fois que vous êtes sûrs que votre carte est supportée, vous devez déterminer le bon pilote de périphérique pour la carte. Les fichiers <span class=filename>/usr/src/sys/conf/NOTES</span> et <span class=filename>/usr/src/sys/arch/conf/NOTES</span> vous donneront la liste des pilotes de périphériques pour cartes réseaux avec des informations sur les cartes/circuits supportés. Si vous avez des doutes au sujet du bon pilote, lisez la page de manuel du pilote. La page de manuel vous donnera plus d’information sur le matériel supporté et même les éventuels problèmes qui pourront apparaître.</p></div><div class=paragraph><p>Si vous possédez une carte courante, la plupart du temps vous n’aurez pas à chercher trop loin pour trouver un pilote. Les pilotes pour les cartes réseaux courantes sont présents dans le noyau <span class=filename>GENERIC</span>, aussi votre carte devrait apparaître au démarrage, comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>Dans cet exemple, nous voyons que deux cartes utilisant le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a> sont présentes sur le système.</p></div><div class=paragraph><p>Si le pilote de votre carte n’est pas présent dans le noyau <span class=filename>GENERIC</span>, vous devrez charger le module approprié pour pouvoir utiliser votre carte. Cela peut être effectué de deux manières différentes:</p></div><div class=ulist><ul><li><p>La méthode la plus simple est de charger le module pour votre carte réseau avec <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>, ou automatiquement au démarrage du système en ajoutant la ligne appropriée au fichier <span class=filename>/boot/loader.conf</span>. Tous les pilotes de cartes réseau ne sont pas disponibles sous forme de modules; les cartes ISA sont un bon exemple de périphériques pour lesquels les modules n’existent pas.</p></li><li><p>Alternativement, vous pouvez compiler en statique le support pour votre carte dans votre noyau. Consultez <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> et la page de manuel du pilote de périphérique pour savoir ce qu’il faut ajouter au fichier de configuration de votre noyau. Pour plus d’information sur la recompilation de votre noyau, veuillez lire le <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>. Si votre carte a été détectée au démarrage par votre noyau (<span class=filename>GENERIC</span>) vous n’avez pas à compiler un nouveau noyau.</p></li></ul></div><div class=sect4><h5 id=config-network-ndis>12.7.1.1. Utilisation des pilotes NDIS de Windows®<a class=anchor href=#config-network-ndis></a></h5><div class=paragraph><p>Malheureusement il y a toujours de nombreux fabricants qui ne fournissent pas à la communauté des logiciels libres les informations concernant les pilotes pour leurs cartes considérant de telles informations comme des secrets industriels. Par conséquent, il ne reste aux développeurs de FreeBSD et d’autres systèmes d’exploitation libres que deux choix: développer les pilotes en passant par un long et pénible processus de "reverse engineering" ou utiliser les pilotes binaires existants disponibles pour la plateforme Microsoft® Windows®. La plupart des développeurs, y compris ceux impliqués dans FreeBSD, ont choisi cette dernière approche.</p></div><div class=paragraph><p>Grâce aux contributions de Bill Paul (wpaul), il existe un support "natif" pour la spécification d’interface des pilotes de périphérique réseau (Network Driver Interface Specification-NDIS). Le NDISulator FreeBSD (connu également sous le nom de Project Evil) prend un pilote binaire réseau Windows® et lui fait penser qu’il est en train de tourner sous Windows®. Etant donné que le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> utilise un binaire Windows®, il ne fonctionne que sur les systèmes i386™ et amd64. Les périphériques PCI, CardBus, PCMCIA (PC-Card), et USB sont supportés.</p></div><div class=paragraph><p>Pour utiliser le NDISulator, trois choses sont nécessaires:</p></div><div class="olist arabic"><ol class=arabic><li><p>les sources du noyau;</p></li><li><p>le pilote binaire Windows® XP (extension <span class=filename>.SYS</span>);</p></li><li><p>le fichier de configuration du pilote Windows® XP (extension <span class=filename>.INF</span>).</p></li></ol></div><div class=paragraph><p>Recherchez les fichiers spécifiques à votre carte. Généralement, ils peuvent être trouvés sur les CDs livrés avec la carte ou sur le site du fabricant. Dans les exemples qui suivent nous utiliseront les fichiers <span class=filename>W32DRIVER.SYS</span> et <span class=filename>W32DRIVER.INF</span>.</p></div><div class=paragraph><p>Le type de pilote doit correspondre à la version de FreeBSD. Pour FreeBSD/i386, utiliser un pilote Windows® 32bits. Pour FreeBSD/amd64, un pilote Windows® 64bits est nécessaire.</p></div><div class=paragraph><p>L’étape suivante est de compiler le pilote binaire dans un module chargeable du noyau. En tant que <code>root</code>, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> est interactif, il sollicitera l’utilisateur pour d’éventuelles informations complémentaires si nécessaire. Un nouveau module noyau est créé dans le répertoire courant. Utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> pour charger le nouveau module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER_SYS.ko</span></code></pre></div></div><div class=paragraph><p>Avec le module généré, vous devez également charger les modules <span class=filename>ndis.ko</span> et <span class=filename>if_ndis.ko</span>. Cela devrait être fait automatiquement quand vous chargez un module qui dépend de <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>. Si vous désirez les charger manuellement, utilisez les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>La première commande charge le pilote d’interface NDIS, la seconde charge l’interface réseau.</p></div><div class=paragraph><p>Contrôlez maintenant la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> à la recherche d’une quelconque erreur au chargement. Si tout s’est bien passé, vous devriez obtenir une sortie ressemblant à ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>A partir de là vous pouvez traiter le périphérique <span class=filename>ndis0</span> comme n’importe quelle interface réseau (par exemple <span class=filename>dc0</span>).</p></div><div class=paragraph><p>Vous pouvez configurer le système pour charger les modules NDIS au démarrage du système de la même manière que pour n’importe quel autre module. Tout d’abord, copiez le module généré, <span class=filename>W32DRIVER_SYS.ko</span>, dans le répertoire <span class=filename>/boot/modules</span>. Ajoutez ensuite la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect3><h4 id=_configuration_de_la_carte_réseau>12.7.2. Configuration de la carte réseau<a class=anchor href=#_configuration_de_la_carte_réseau></a></h4><div class=paragraph><p>Une fois que le bon pilote de périphérique pour la carte réseau est chargé, la carte doit être configurée. Comme beaucoup d’autres choses, la carte aura pu être configurée à l’installation par sysinstall.</p></div><div class=paragraph><p>Pour afficher la configuration des interfaces réseaux de votre système, entrer la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>Dans cet exemple, les périphériques suivants ont été affichés:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: La première interface Ethernet</p></li><li><p><span class=filename>dc1</span>: La seconde interface Ethernet</p></li><li><p><span class=filename>lo0</span>: L’interface "en boucle" ("loopback")</p></li></ul></div><div class=paragraph><p>FreeBSD utilise le nom du pilote de périphérique suivi par un chiffre représentant l’ordre dans lequel la carte est détectée au démarrage du noyau pour nommer la carte. Par exemple <span class=filename>sis2</span> serait la troisième carte sur le système utilisant le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a>.</p></div><div class=paragraph><p>Dans cet exemple, le périphérique <span class=filename>dc0</span> est actif et en fonctionnement. Les indicateurs importants sont:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> signifie que la carte est configurée et prête.</p></li><li><p>La carte possède une adresse Internet (<code>inet</code>) (dans ce cas-ci <code>192.168.1.3</code>).</p></li><li><p>Elle a un masque de sous-réseau valide (<code>netmask</code>; <code>0xffffff00</code> est équivalent à <code>255.255.255.0</code>).</p></li><li><p>Elle a une adresse de diffusion valide (dans ce cas-ci <code>192.168.1.255</code>).</p></li><li><p>L’adresse MAC de la carte (<code>ether</code>) est <code>00:a0:cc:da:da:da</code></p></li><li><p>La sélection du média est sur le mode d’autosélection (<code>media: Ethernet autoselect (100baseTX full-duplex)</code>). Nous voyons que <span class=filename>dc1</span> a été configurée pour utiliser un matériel de type <code>10baseT/UTP</code>. Pour plus d’information sur le type de matériel disponible pour un pilote de périphérique, référez-vous à sa page de manuel.</p></li><li><p>La liaison (<code>status</code>) est <code>active</code>, i.e. la porteuse est détectée. Pour <span class=filename>dc1</span>, nous lisons <code>status: no carrier</code>. Cela est normal lorsqu’aucun câble n’est branché à la carte.</p></li></ol></div><div class=paragraph><p>Si le résultat de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> est similaire à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active</code></pre></div></div><div class=paragraph><p>cela indiquerait que la carte n’a pas été configurée.</p></div><div class=paragraph><p>Pour configurer votre carte, vous avez besoin des privilèges de l’utilisateur <code>root</code>. La configuration de la carte réseau peut être faite à partir de la ligne de commande avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> mais vous aurez à répéter cette opération à chaque redémarrage du système. Le fichier <span class=filename>/etc/rc.conf</span> est l’endroit où ajouter la configuration de la carte réseau.</p></div><div class=paragraph><p>Ouvrez le fichier <span class=filename>/etc/rc.conf</span> dans votre éditeur favori. Vous devez ajouter une ligne pour chaque carte réseau présente sur le système, par exemple dans notre cas, nous avons ajouté ces lignes:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Vous devez remplacer <span class=filename>dc0</span>, <span class=filename>dc1</span>, et ainsi de suite, avec le périphérique correspondant pour vos cartes, et les adresses avec celles désirées. Vous devriez lire les pages de manuel du pilote de périphérique et d’<a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> pour plus de détails sur les options autorisées et également la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> pour plus d’information sur la syntaxe de <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Si vous avez configuré le réseau à l’installation, des lignes concernant la/les carte(s) réseau pourront être déjà présentes. Contrôler à deux fois le fichier <span class=filename>/etc/rc.conf</span> avant d’y ajouter des lignes.</p></div><div class=paragraph><p>Vous devrez également éditer le fichier <span class=filename>/etc/hosts</span> pour ajouter les noms et les adresses IP des diverses machines du réseau local, si elles ne sont pas déjà présentes. Pour plus d’information référez-vous à la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> et au fichier <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>S’il n’y a pas de serveur DHCP et qu’un accès à Internet est nécessaire, configurez manuellement la passerelle par défaut et le serveur de noms:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;your_default_router&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver your_DNS_server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_test_et_dépannage>12.7.3. Test et dépannage<a class=anchor href=#_test_et_dépannage></a></h4><div class=paragraph><p>Une fois les modifications nécessaires du fichier <span class=filename>/etc/rc.conf</span> effectuées, vous devrez redémarrer votre système. Cela permettra la prise en compte de la ou les modifications au niveau des interfaces, et permettra de vérifier que le système redémarre sans erreur de configuration. Sinon, une autre méthode pour faire prendre en compte les modifications au niveau de la gestion du réseau consiste à utiliser la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si une passerelle par défaut a été configurée dans <span class=filename>/etc/rc.conf</span>, lancez également cette commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Une fois que le système a été redémarré, vous testez les interfaces réseau.</p></div><div class=sect4><h5 id=_tester_la_carte_ethernet>12.7.3.1. Tester la carte Ethernet<a class=anchor href=#_tester_la_carte_ethernet></a></h5><div class=paragraph><p>Pour vérifier qu’une carte Ethernet est configurée correctement, vous devez essayer deux choses. Premièrement, "pinguer" l’interface, puis une autre machine sur le réseau local.</p></div><div class=paragraph><p>Tout d’abord testons l’interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=paragraph><p>Nous devons maintenant "pinguer" une autre machine sur le réseau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Vous pourrez utiliser le noms de la machine à la place de <code>192.168.1.2</code> si vous avez configuré le fichier <span class=filename>/etc/hosts</span>.</p></div></div><div class=sect4><h5 id=_dépannage>12.7.3.2. Dépannage<a class=anchor href=#_dépannage></a></h5><div class=paragraph><p>Le dépannage de matériels ou de logiciels est toujours une tâche relativement pénible, mais qui peut être rendue plus aisée en vérifiant en premier lieu certaines choses élémentaires. Votre câble réseau est-il branché? Avez-vous correctement configuré les services réseau? Le coupe-feu est-il bien configuré? Est-ce que la carte réseau est supportée par FreeBSD? Consultez toujours les notes concernant le matériel avant d’envoyer un rapport de bogue. Mettez à jour votre version de FreeBSD vers la dernière version STABLE. Consultez les archives des listes de diffusion, et faites même des recherches sur l’Internet.</p></div><div class=paragraph><p>Si la carte fonctionne mais les performances sont mauvaises, une lecture de la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a> peut valoir la peine. Vous pouvez également vérifier la configuration du réseau puisque des paramètres réseau incorrects peuvent donner lieu à des connexions lentes.</p></div><div class=paragraph><p>Certains utilisateurs peuvent voir apparaître un ou deux messages <code>device timeout</code>, ce qui est normal pour certaines cartes. Si ces messages se multiplient, assurez-vous que la carte n’est pas en conflit avec un autre périphérique. Contrôlez à deux fois les câbles de connexion. Peut-être que vous avez juste besoin d’une autre carte.</p></div><div class=paragraph><p>Parfois, des utilisateurs sont confrontés à des messages d’erreur <code>watchdog timeout</code>. La première chose à faire dans ce cas est de vérifier votre câble réseau. De nombreuses cartes demandent un slot PCI supportant le "Bus Mastering". Sur certaines cartes mère anciennes, seul un slot PCI le permet (la plupart du temps le slot 0). Consultez la documentation de la carte réseau et de la carte mère pour déterminer si cela peut être à l’origine du problème.</p></div><div class=paragraph><p>Les messages <code>No route to host</code> surviennent si le système est incapable de router un paquet vers la machine de destination. Cela peut arriver s’il n’y a pas de route par défaut de définie, ou si le câble réseau est débranché. Vérifiez la sortie de la commande <code>netstat -nr</code> et assurez-vous qu’il y a une route valide en direction de la machine que vous essayez d’atteindre. Si ce n’est pas le cas, lisez la <a href=./#advanced-networking>Administration réseau avancée</a>.</p></div><div class=paragraph><p>Les messages d’erreur <code>ping: sendto: Permission denied</code> sont souvent dus à un coupe-feu mal configuré. Si <code>ipfw</code> est activé dans le noyau mais qu’aucune règle n’a été définie, alors la politique par défaut est de refuser tout trafic, même les requêtes "ping"! Lisez <a href=./#firewalls>Firewalls</a> pour plus d’informations.</p></div><div class=paragraph><p>Parfois les performances de la carte ne sont pas bonnes, ou en dessous de la moyenne. Dans ce cas il est recommandé de passer la sélection du média du mode <code>autoselect</code> au mode adéquat. Alors que cela fonctionne généralement pour la plupart du matériel, il se peut que cela ne résolve pas le problème pour tout de monde. Encore une fois, contrôlez les paramétrages réseau et consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>.</p></div></div></div></div><div class=sect2><h3 id=configtuning-virtual-hosts>12.8. Hôtes virtuels<a class=anchor href=#configtuning-virtual-hosts></a></h3><div class=paragraph><p>Une utilisation très courante de FreeBSD est l’hébergement de sites virtuels, où un serveur apparaît pour le réseau comme étant plusieurs serveurs différents. Ceci est possible en assignant plusieurs adresses réseau à une interface.</p></div><div class=paragraph><p>Une interface réseau donnée possède une adresse "réelle", et peut avoir n’importe quel nombre d’adresses "alias". Ces alias sont normalement ajoutés en plaçant les entrées correspondantes dans le fichier <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Une entrée d’alias pour l’interface <span class=filename>fxp0</span> ressemble à:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>Notez que les entrées d’alias doivent commencer avec alias0 et continuer en ordre croissant, (par exemple, _alias1, _alias2, et ainsi de suite). Le processus de configuration s’arrêtera au premier nombre absent.</p></div><div class=paragraph><p>Le calcul des masques de réseau est important, mais heureusement assez simple. Pour une interface donnée, il doit y avoir une adresse qui représente correctement le masque de réseau de votre réseau. Tout autre adresse appartenant à ce réseau devra avoir un masque de réseau avec chaque bit à <code>1</code> (exprimé soit sous la forme <code>255.255.255.255</code> soit <code>0xffffffff</code>).</p></div><div class=paragraph><p>Par exemple, considérez le cas où l’interface <span class=filename>fxp0</span> est connectée à deux réseaux, le réseau <code>10.1.1.0</code> avec un masque de réseau de <code>255.255.255.0</code> et le réseau <code>202.0.75.16</code> avec un masque de <code>255.255.255.240</code>. Nous voulons que le système apparaisse de <code>10.1.1.1</code> jusqu’à <code>10.1.1.5</code> et à <code>202.0.75.17</code> jusqu’à <code>202.0.75.20</code>. Comme noté plus haut, seule la première adresse dans un intervalle réseau donné (dans ce cas, <code>10.0.1.1</code> et <code>202.0.75.17</code>) devrait avoir un masque de sous-réseau réel; toutes les autres adresses (<code>10.1.1.2</code> à <code>10.1.1.5</code> et <code>202.0.75.18</code> jusqu’à <code>202.0.75.20</code>) doivent être configurées avec un masque de sous-réseau de <code>255.255.255.255</code>.</p></div><div class=paragraph><p>Les entrées suivantes du fichier <span class=filename>/etc/rc.conf</span> configurent la carte correctement pour cet arrangement:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div></div><div class=sect2><h3 id=configtuning-configfiles>12.9. Fichiers de configuration<a class=anchor href=#configtuning-configfiles></a></h3><div class=sect3><h4 id=_organisation_du_répertoire_etc>12.9.1. Organisation du répertoire <span class=filename>/etc</span><a class=anchor href=#_organisation_du_répertoire_etc></a></h4><div class=paragraph><p>Il existe un certain nombre de répertoires dans lesquels se trouvent les informations de configuration. Ceux-ci incluent:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Information de configuration générique du système; les données ici sont spécifiques au système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Version par défaut des fichiers de configuration du système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration de <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, et autres fichiers de configuration d’agent de transmission du courrier électronique.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration pour les programmes PPP utilisateur et intégré au noyau.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emplacement par défaut pour les données de <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. Normalement <span class=filename>named.conf</span> et les fichiers de zone sont stockés dans ce répertoire.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de configuration pour les applications installées. Peut contenir des sous-répertoires pour chaque application.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Procédures de lancement/d’arrêt pour les applications installées.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers de bases de données automatiquement générés, spécifiques au système, comme la base de données des logiciels installés, la base de données de localisation des fichiers, et ainsi de suite.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_nom_dhôtes>12.9.2. Nom d’hôtes<a class=anchor href=#_nom_dhôtes></a></h4><div class=sect4><h5 id=_etcresolv_conf>12.9.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h5><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> gère comment le résolveur de FreeBSD accède au système de nom de domaine d’Internet (DNS).</p></div><div class=paragraph><p>Les entrées la plus classiques du fichier <span class=filename>resolv.conf</span> sont:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’adresse IP du serveur de noms auquel le résolveur devrait envoyer ses requêtes. Les serveurs sont sollicités dans l’ordre listé avec un maximum de trois.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Liste de recherche pour la résolution de nom de machine. Ceci est normalement déterminé par le domaine de l’hôte local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le nom du domaine local.</p></td></tr></tbody></table><div class=paragraph><p>Un fichier <span class=filename>resolv.conf</span> typique:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Seule une des options <code>search</code> et <code>domain</code> devrait être utilisée.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous utilisez DHCP, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> réécrit habituellement <span class=filename>resolv.conf</span> avec l’information reçue du serveur DHCP.</p></div></div><div class=sect4><h5 id=_etchosts>12.9.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h5><div class=paragraph><p><span class=filename>/etc/hosts</span> est une simple base de données texte, une réminiscence des débuts d’Internet. Il travaille en conjonction avec les serveurs DNS et NIS pour fournir les correspondances nom vers adresse IP. Les ordinateurs locaux reliés par l’intermédiaire d’un réseau local peuvent être ajoutés dans ce fichier pour une résolution de noms simple plutôt que de configurer un serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. De plus <span class=filename>/etc/hosts</span> peut être utilisé pour fournir un enregistrement local de correspondances de nom, réduisant ainsi le besoin de requêtes vers l’extérieur pour les noms auxquels on accède couramment.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> suit le format simple suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet address] [official hostname] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>Par exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> pour plus d’informations.</p></div></div></div><div class=sect3><h4 id=_configuration_des_fichiers_de_trace>12.9.3. Configuration des fichiers de trace<a class=anchor href=#_configuration_des_fichiers_de_trace></a></h4><div class=sect4><h5 id=_syslog_conf>12.9.3.1. <span class=filename>syslog.conf</span><a class=anchor href=#_syslog_conf></a></h5><div class=paragraph><p><span class=filename>syslog.conf</span> est le fichier de configuration du programme <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>. Il indique quel type de messages <code>syslog</code> sera enregistré dans des fichiers de traces particuliers.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> pour plus d’informations.</p></div></div><div class=sect4><h5 id=_newsyslog_conf>12.9.3.2. <span class=filename>newsyslog.conf</span><a class=anchor href=#_newsyslog_conf></a></h5><div class=paragraph><p><span class=filename>newsyslog.conf</span> est le fichier de configuration de <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a>, un programme qui est normalement programmé <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> pour s’exécuter périodiquement. <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> détermine quand les fichiers de traces doivent être archivés ou réorganisés. <span class=filename>logfile</span> devient <span class=filename>logfile.0</span>, <span class=filename>logfile.0</span> devient à son tour <span class=filename>logfile.1</span>, et ainsi de suite. D’autre part, les fichiers de traces peuvent être archivés dans le format <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, ils se nommeront alors: <span class=filename>logfile.0.gz</span>, <span class=filename>logfile.1.gz</span>, et ainsi de suite.</p></div><div class=paragraph><p><span class=filename>newsyslog.conf</span> indique quels fichiers de traces doivent être gérés, combien doivent être conservés, et quand ils doivent être modifiés. Les fichiers de traces peuvent être réorganisés et/ou archivés quand ils ont soit atteint une certaine taille, soit à une certaine période/date.</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> pour plus d’informations.</p></div></div></div><div class=sect3><h4 id=configtuning-sysctlconf>12.9.4. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h4><div class=paragraph><p><span class=filename>sysctl.conf</span> ressemble à <span class=filename>rc.conf</span>. Les valeurs sont fixées sous la forme <code>variable=value</code>. Les valeurs spécifiées sont positionnées après que le système soit passé dans le mode multi-utilisateurs. Toutes les variables ne sont pas paramétrables dans ce mode.</p></div><div class=paragraph><p>Pour désactiver l’enregistrement des signaux fatals de fin de processus et empêcher les utilisateurs de voir les processus lancés par les autres, les variables suivantes peuvent être paramétrées dans <span class=filename>sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div></div><div class=sect2><h3 id=configtuning-sysctl>12.10. Optimisation avec <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#configtuning-sysctl></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> est une interface qui vous permet d’effectuer des changements de paramétrage sur un système FreeBSD en fonctionnement. Cela comprend de nombreuses options avancées de la pile TCP/IP et du système de mémoire virtuelle qui peuvent améliorer dramatiquement les performances pour un administrateur système expérimenté. Plus de cinq cent variables système peuvent être lues et modifiées grâce à <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> remplit deux fonctions: lire et modifier les paramétrages du système.</p></div><div class=paragraph><p>Pour afficher toutes les variables lisibles:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>Pour lire une variable particulière, par exemple, <code>kern.maxproc</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>Pour fixer une variable particulière, utilisez la syntaxe intuitive <em>variable</em>=<em>valeur</em> :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>Les valeurs des variables sysctl sont généralement des chaînes de caractères, des nombres, ou des booléens (un variable booléenne étant <code>1</code> pour oui ou un <code>0</code> pour non).</p></div><div class=paragraph><p>Si vous voulez fixer automatiquement certaines variables à chaque démarrage de la machine, ajoutez-les au fichier <span class=filename>/etc/sysctl.conf</span>. Pour plus d’information consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> et la <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect3><h4 id=sysctl-readonly>12.10.1. Variables <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> en lecture seule<a class=anchor href=#sysctl-readonly></a></h4><div class=paragraph><p>Dans certains cas, il peut être nécessaire de modifier des variables <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> en lecture seule. Bien que cela soit parfois inévitable, cela ne peut être fait qu’au (re)démarrage de la machine.</p></div><div class=paragraph><p>Par exemple sur certains modèles d’ordinateurs portables le périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> ne sondera pas le système à la recherche des zones mémoires, et échouera avec des erreurs du type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>Des cas comme le précédent demandent généralement la modification de paramètres <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> par défaut qui sont en lecture seule. Pour palier à ces situations un utilisateur peut placer un paramétrage ("OID"-Object IDentifier) <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> dans le fichier local <span class=filename>/boot/loader.conf.local</span>. Les paramétrages par défaut se trouvent dans le fichier <span class=filename>/boot/defaults/loader.conf</span>.</p></div><div class=paragraph><p>Pour corriger le problème précédent, il faudrait que l’utilisateur ajoute la ligne <code>hw.pci.allow_unsupported_io_range=1</code> dans le fichier précédemment indiqué. Désormais le périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> devrait fonctionner normalement.</p></div></div></div><div class=sect2><h3 id=configtuning-disk>12.11. Optimiser les disques<a class=anchor href=#configtuning-disk></a></h3><div class=sect3><h4 id=_les_variables_sysctl>12.11.1. Les variables sysctl<a class=anchor href=#_les_variables_sysctl></a></h4><div class=sect4><h5 id=_vfs_vmiodirenable>12.11.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h5><div class=paragraph><p>La variable sysctl <code>vfs.vmiodirenable</code> peut être positionnée soit à 0 (désactivée) soit à 1 (activée); elle est a 1 par défaut. Cette variable spécifie comment les répertoires sont cachés par le système. La plupart des répertoires sont petits, utilisant juste un simple fragment du système de fichiers (typiquement 1KO) et moins dans le cache en mémoire (typiquement 512 octets). Avec cette variable désactivée (à 0), le cache en mémoire ne cachera qu’un nombre fixe de répertoires même si vous disposez d’une grande quantité de mémoire. Activée (à 1), cette variable sysctl permet au cache en mémoire d’utiliser le cache des pages de mémoire virtuelle pour cacher les répertoires, rendant toute la mémoire disponible pour cacher les répertoires. Cependant, la taille minimale de l’élément mémoire utilisé pour cacher un répertoire est une page physique (typiquement 4KO) plutôt que 512 octets. Nous recommandons de conserver de cette option activée si vous faites fonctionner des services qui manipulent un grand nombre de fichiers. De tels services peuvent être des caches web, d’importants systèmes de courrier électronique, et des systèmes serveurs de groupe de discussion. Conserver cette option activée ne réduira généralement pas les performances même avec la mémoire gaspillée mais vous devriez faire des expériences pour le déterminer.</p></div></div><div class=sect4><h5 id=_vfs_write_behind>12.11.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h5><div class=paragraph><p>La variable sysctl <code>vfs.write_behind</code> est positionnée par défaut à <code>1</code> (activée). Elle demande au système de fichiers d’effectuer les écritures lorsque des grappes complètes de données ont été collectées, ce qui se produit généralement lors de l’écriture séquentielle de gros fichiers. L’idée est d’éviter de saturer le cache tampon avec des tampons sales quand cela n’améliorera pas les performances d’E/S. Cependant, cela peut bloquer les processus et dans certaines conditions vous pouvez vouloir désactiver cette fonction.</p></div></div><div class=sect4><h5 id=_vfs_hirunningspace>12.11.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h5><div class=paragraph><p>La variable sysctl <code>vfs.hirunningspace</code> détermine combien d’opérations d’écriture peuvent être mises en attente à tout moment au niveau des contrôleurs disques du système. La valeur par défaut est normalement suffisante mais sur les machines avec de nombreux disques, vous pouvez vouloir l’augmenter jusqu’à quatre ou cinq <em>méga-octets</em>. Notez que fixer une valeur trop élevée (dépassant la limite d’écriture du cache tampon) peut donner lieu à de très mauvaises performances. Ne fixez pas cette valeur à une valeur élevée arbitraire! Des valeurs d’écriture élevées peuvent ajouter des temps de latence aux opérations d’écriture survenant au même moment.</p></div><div class=paragraph><p>Il existent d’autres variables sysctl relatives aux caches tampons et aux pages VM. Nous ne recommandons pas de modifier ces valeurs, le système VM effectue un très bon travail d’auto-optimisation.</p></div></div><div class=sect4><h5 id=_vm_swap_idle_enabled>12.11.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h5><div class=paragraph><p>La variable <code>vm.swap_idle_enabled</code> est utile dans le cas de systèmes multi-utilisateurs importants où il y a beaucoup d’utilisateurs s’attachant et quittant le système et de nombreux processus inactifs. De tels systèmes tendent à générer une pression assez importante et continue sur les réserves de mémoire libres. Activer cette fonction et régler l’hystéresis de libération de l’espace de pagination (en secondes d’inactivité) par l’intermédiaire des variables <code>vm.swap_idle_threshold1</code> et <code>vm.swap_idle_threshold2</code>, vous permet de diminuer la priorité des pages mémoire associées avec les processus inactifs plus rapidement qu’avec l’algorithme normal de libération. Cela aide le "daemon" de libération des pages. N’activez cette option que si vous en besoin, parce que la concession que vous faites est d’utiliser l’espace de pagination pour les pages mémoire plus tôt qu’à l’accoutumé, consommant par conséquent plus d’espace de pagination et de bande passante disque. Sur un petit système, cette option aura un effet limité mais dans le cas d’un système important qui fait appel à l’espace de pagination de façon modérée, cette option permettra au système VM de transférer l’ensemble des processus de et vers la mémoire aisément.</p></div></div><div class=sect4><h5 id=_hw_ata_wc>12.11.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h5><div class=paragraph><p>FreeBSD 4.3 a flirté avec la désactivation du cache en écriture des disques IDE. Cela réduisit la bande passante en écriture des disques IDE mais fut considéré comme nécessaire en raison de sérieux problèmes de cohérence de données introduits par les fabricants de disques durs. Le problème est que les disques IDE mentent sur le moment où une écriture est réellement terminée. Avec le cache en écriture IDE activé, les disques durs IDE non seulement n’écriront pas les données dans l’ordre, mais parfois retarderont l’écriture de certains blocs indéfiniment sous une charge disque importante. Un crash ou une coupure secteur pourra être à l’origine de sérieuses corruptions du système de fichiers. Par précaution le paramétrage par défaut de FreeBSD fut modifié. Malheureusement, le résultat fut une telle perte de performances que nous avons réactivé le cache en écriture après cette version de FreeBSD. Vous devriez contrôler la valeur par défaut sur votre système en examinant la variable sysctl <code>hw.ata.wc</code>. Si le cache en écriture des disques IDE est désactivé, vous pouvez le réactiver en positionnant la variable à 1. Cela doit être fait à partir du chargeur au démarrage. Tenter de le faire après le démarrage du noyau n’aura aucun effet.</p></div><div class=paragraph><p>Pour plus d’informations, veuillez consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect4><h5 id=_scsi_delay_kern_cam_scsi_delay>12.11.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h5><div class=paragraph><p>L’option de configuration du noyau <code>SCSI_DELAY</code> peut être utilisée pour réduire le temps de démarrage du système. Le délai par défaut est important et peut être responsable de plus de <code>15</code> secondes d’attente lors du processus de démarrage. Réduire ce délai à <code>5</code> secondes est généralement suffisant (tout particulièrement avec les disques modernes). L’option de démarrage <code>kern.cam.scsi_delay</code> devrait être utilisée. Cette option de démarrage et celle de configuration du noyau acceptent des valeurs en <em>millisecondes</em> et <em>non pas</em> en <em>secondes</em>.</p></div></div></div><div class=sect3><h4 id=soft-updates>12.11.2. Les "Soft Updates"<a class=anchor href=#soft-updates></a></h4><div class=paragraph><p>Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> peut être utilisé pour régler finement un système de fichiers. Ce programme dispose de nombreuses options différentes, mais pour l’instant nous nous intéresserons uniquement à l’activation et la désactivation des "Soft Updates", ce qui fait avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>Un système de fichiers ne peut être modifié avec <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> tant qu’il est monté. Un bon moment pour activer les "Soft Updates" est avant que les partitions ne soient montées en mode mono-utilisateur.</p></div><div class=paragraph><p>Les "Soft Updates" améliorent de façon drastique les performances sur les méta-données, principalement la création et la suppression de fichier, par l’utilisation d’un cache mémoire. Nous recommandons d’activer les "Soft Updates" sur tous vos systèmes de fichiers. Il y a deux inconvénients aux "Soft Updates" que vous devez connaître: tout d’abord, les "Soft Updates" garantissent la cohérence du système de fichiers en cas de crash mais pourront facilement être en retard de quelques secondes (voir même une minute!) dans la mise à jour du disque. Si votre système plante il se peut que vous perdiez plus de travail que dans d’autres cas. Deuxièmement, les "Soft Updates" retardent la libération des blocs du système de fichiers. Si vous avez un système de fichiers (comme le système de fichiers racine) qui est presque plein, effectuer une mise à jour majeure, comme un <code>make installworld</code>, peut mener à un manque d’espace sur le système de fichiers et faire échouer la mise à jour.</p></div><div class=sect4><h5 id=_plus_de_détails_à_propos_des_soft_updates>12.11.2.1. Plus de détails à propos des "Soft Updates"<a class=anchor href=#_plus_de_détails_à_propos_des_soft_updates></a></h5><div class=paragraph><p>Il y a deux approches traditionnelles pour écrire les méta-données d’un système de fichiers sur le disque (mise à jour des méta-données et mise à jour des éléments sans données comme les inodes ou les répertoires).</p></div><div class=paragraph><p>Historiquement, le comportement par défaut était d’écrire les mises à jour des méta-données de façon synchrone. Si un répertoire a été modifié, le système attendait jusqu’à ce que le changement soit effectivement écrit sur le disque. Les tampons des données de fichier (contenu du fichier) passaient par le cache mémoire et étaient copiés sur le disque plus tard de façon asynchrone. L’avantage de cette implémentation est qu’elle est effectuée sans risque. S’il y a un problème durant une mise à jour, les méta-données sont toujours dans un état consistant. Un fichier est soit créé complètement soit pas du tout. Si les blocs de données d’un fichier n’ont pas trouvé leur chemin du cache mémoire vers le disque au moment du crash, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> est capable de s’en apercevoir et de réparer le système de fichiers en fixant la taille du fichier à 0. De plus, l’implémentation est claire et simple. L’inconvénient est que la modification des méta-données est lente. Un <code>rm -r</code>, par exemple, touche à tous les fichiers dans un répertoire séquentiellement, mais chaque modification du répertoire (effacement d’un fichier) sera écrite de façon synchrone sur le disque. Cela comprend les mises à jour du répertoire lui-même, de la table des inodes, et éventuellement celles sur des blocs indirects alloués par le fichier. Des considérations semblables s’appliquent à la création d’importantes hiérarchies ((<code>tar -x</code>).</p></div><div class=paragraph><p>Le deuxième cas est la mise à jour asynchrone des méta-données. C’est le comportement par défaut de Linux/ext2fs et de l’usage de <code>mount -o async</code> pour l’UFS des systèmes BSD. Toutes les mises à jour des méta-données passent également par l’intermédiaire d’un cache mémoire, c’est à dire, qu’elles seront mélangées aux mises à jour des données du contenu du fichier. L’avantage de cette implémentation est qu’il n’y a pas besoin d’attendre jusqu’à l’écriture sur le disque de chaque mise à jour de méta-données, donc toutes les opérations qui sont à l’origine d’une grande quantité de mise à jour de méta-données fonctionnent bien plus rapidement que dans le cas synchrone. De plus, l’implémentation est toujours claire et simple, il y a donc peu de risque qu’un bogue se cache dans le code. L’inconvénient est qu’il n’y a aucune garantie du tout sur la cohérence du système de fichiers. S’il y a un problème durant une opération qui met à jour une grande quantité de méta-données (comme une coupure secteur, ou quelqu’un appuyant sur le bouton reset), le système de fichiers sera laissé dans un état imprévisible. Il n’y a aucune opportunité d’examiner l’état du système de fichiers quand le système est à nouveau relancé; les blocs de données d’un fichier pourraient déjà avoir été inscrits sur le disque alors que la mise à jour de la table des inodes ou du répertoire associé n’a pas été faite. Il est en fait impossible d’implémenter un <code>fsck</code> qui est capable de nettoyer le chaos résultant (parce que l’information nécessaire n’est pas disponible sur le disque). Si le système de fichiers a été endommagé irrémédiablement, le seul choix est de le recréer avec <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> et de récupérer les données à partir de sauvegardes.</p></div><div class=paragraph><p>La solution commune pour ce problème fut d’implémenter une <em>région de trace</em>, dont on fait souvent référence sous le terme de <em>journalisation</em>, bien que ce terme ne soit pas toujours utilisé de façon cohérente et est occasionnellement utilisé pour d’autres formes de transaction avec trace. Les mises à jour des méta-données sont toujours écrites de façon synchrone, mais seulement sur une petite région du disque. Elles seront plus tard déplacées vers leur emplacement correct. Parce que la région de trace est une petite région contiguë sur le disque, il n’y a pas de grandes distances de déplacement pour les têtes des disques, même durant les opérations importantes, donc ces opérations sont plus rapides que les mises à jour synchrones. De plus la complexité de l’implémentation est relativement limitée, donc le risque de présence de bogues est faible. Un inconvénient est que toutes les méta-données sont écrites deux fois (une fois dans la région de trace et une fois sur l’emplacement correct) donc pour un fonctionnement normal, une baisse des performances pourra en résulter. D’autre part, dans le cas d’un crash, toutes les opérations sur les méta-données en attente peuvent rapidement être annulées ou complétées à partir de la zone de trace après le redémarrage du système, ayant pour résultat un démarrage rapide du système de fichiers.</p></div><div class=paragraph><p>Kirk McKusick, le développeur du FFS de Berkeley, a résolu le problème avec les "Soft Updates": toutes les mises à jour des méta-données sont conservées en mémoire et inscrites sur le disque selon une séquence ordonnée ("mise à jour ordonnée des méta-données"). Ceci a pour effet, dans le cas d’un nombre d’opérations sur les méta-données important, que les dernières mises à jour sur un élément "attrapent" les premières si ces dernières sont encore en mémoire et n’ont pas encore été inscrites sur le disque. Donc toutes les opérations sur, par exemple, un répertoire sont généralement effectuées en mémoire avant que la mise à jour ne soit écrite sur le disque (les blocs de données sont ordonnés en fonction de leur position de sorte à ce qu’ils ne soient pas sur le disque avant leur méta-données). Si le système crash, cela provoque un "retour dans les traces" implicite: toutes les opérations qui n’ont pas trouvé leur chemin vers le disque apparaissent comme si elles n’avaient jamais existé. Un état cohérent du système de fichiers est maintenu et apparaît comme étant celui de 30 ou 60 secondes plus tôt. L’algorithme utilisé garantie que toutes les ressources utilisées soient marquées avec leur bons "bitmaps": blocs et inodes. Après un crash, les seules erreurs d’allocation de ressources qui apparaissent sont les ressources qui ont été marquées comme "utilisées" et qui sont en fait "libre". <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> reconnaît cette situation, et libère les ressources qui ne sont plus utilisées. On peut ignorer sans risque l’état "sale" d’un système de fichiers après un crash en forçant son montage avec <code>mount -f</code>. Afin de libérer les ressources qui peuvent être inutilisées, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> doit être exécuté plus tard. C’est l’idée qu’il y a derrière le "<em>background fsck</em>" (fsck en tâche de fond): au démarrage du système, seule un "<em>snapshot</em>" (photographie) du système de fichiers est prise. La commande <code>fsck</code> peut être exécutée plus tard sur ce système de fichiers. Tous les systèmes de fichiers peuvent être montés "sales", donc le système passe en mode multi-utilisateurs. Ensuite, les <code>fsck</code> en tâche de fond seront programmés pour tous les systèmes de fichiers pour lesquels c’est nécessaire, pour libérer les ressources qui peuvent être inutilisées (les systèmes qui n’utilisent pas les "Soft Updates" ont toujours besoin du <code>fsck</code> en avant plan).</p></div><div class=paragraph><p>L’avantage est que les opérations sur les méta-données sont presque aussi rapides que les mises à jour asynchrones (i.e. plus rapide qu’avec le "<em>logging</em>" - traçage, qui doit écrire les méta-données deux fois). Les inconvénients sont la complexité du code (impliquant un haut risque de bogues dans une zone qui est hautement sensible en raison de risque perte de données utilisateur), et une plus grande consommation en mémoire. De plus il y a quelques particularités que l’on peut rencontrer lors de l’utilisation. Après un crash, l’état du système apparaît être en quelque sorte "plus vieux". Dans des situations où l’approche synchrone classique aurait donné lieu à des fichiers de taille nulle restant après le <code>fsck</code>, ces fichiers n’existent pas du tout avec un système de fichiers utilisant les "Soft Updates" parce que ni les méta-données ni les contenus de fichiers n’ont jamais été inscrits sur le disque. L’espace disque n’est pas rendu tant que les mises à jour n’ont pas été inscrites sur le disque, ce qui peut se produire quelques temps après l’exécution de <code>rm</code>. Cela peut être à l’origine de problèmes quand on installe une grande quantité de données sur un système de fichiers qui ne dispose pas de suffisamment d’espace pour contenir tous les fichiers deux fois.</p></div></div></div></div><div class=sect2><h3 id=configtuning-kernel-limits>12.12. Optimisation des limitations du noyau<a class=anchor href=#configtuning-kernel-limits></a></h3><div class=sect3><h4 id=file-process-limits>12.12.1. Limitations sur les fichiers et les processus<a class=anchor href=#file-process-limits></a></h4><div class=sect4><h5 id=kern-maxfiles>12.12.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h5><div class=paragraph><p>Le paramètre <code>kern.maxfiles</code> peut être augmenté ou diminué en fonction des besoins du système. Cette variable indique le nombre maximal de descripteurs de fichier sur votre système. Quand la table de descripteurs de fichier est pleine, le message <code>file: table is full</code> s’affichera régulièrement dans le tampon des messages système, qui peut être visualisé avec la commande <code>dmesg</code>.</p></div><div class=paragraph><p>Chaque fichier ouvert, chaque "socket", ou chaque emplacement en pile utilise un descripteur de fichier. Un serveur important peut facilement demander plusieurs milliers de descripteurs de fichiers, en fonction du type et du nombre de services s’exécutant en même temps.</p></div><div class=paragraph><p>Sous les anciennes versions de FreeBSD, la valeur par défaut de <code>kern.maxfile</code> est fixée par l’option <code>maxusers</code> dans votre fichier de configuration du noyau. <code>kern.maxfiles</code> augmente proportionnellement avec la valeur de <code>maxusers</code>. Quand vous compilez un noyau sur mesure, il est bon de paramétrer cette option en fonction de l’utilisation de votre système. Ce nombre fixe la plupart des limites pré-définies du noyau. Même si une machine de production pourra ne pas avoir en réalité 256 utilisateurs connectés simultanément, les ressources requises pourront être semblables pour un serveur web important.</p></div><div class=paragraph><p>La variable <code>kern.maxusers</code> est automatiquement ajustée au démarrage en fonction de la quantité de mémoire disponible dans le système, sa valeur peut être connue durant le fonctionnement du système en examinant la valeur de la variable sysctl en lecture seule: <code>kern.maxusers</code>. Certains systèmes auront besoin de valeurs plus élevées ou plus faibles pour <code>kern.maxusers</code> et pourront donc la fixer au chargement du système; des valeurs de 64, 128, ou 256 ne sont pas inhabituelles. Nous recommandons de ne pas dépasser 256 à moins que vous ayez besoin d’un grand nombre de descripteurs de fichiers; plusieurs des variables dont la valeur par défaut dépend de <code>kern.maxusers</code> peuvent être fixées individuellement au démarrage ou en fonctionnement dans le fichier <span class=filename>/boot/loader.conf</span> (voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> ou le fichier <span class=filename>/boot/defaults/loader.conf</span> pour des exemples) ou comme décrit en d’autres endroits dans ce document.</p></div><div class=paragraph><p>Sous les anciennes versions, le système auto-ajuste ce paramètre pour vous si vous le fixez explicitement à <code>0</code>. En paramétrant cette option, vous devrez fixer <code>maxusers</code> à 4 au moins, en particulier si vous utilisez le système X Window ou compilez des logiciels. La raison de cela est que la valeur la plus importante que dimensionne <code>maxusers</code> est le nombre maximal de processus, qui est fixé à <code>20 + 16 * maxusers</code>, donc si vous positionnez <code>maxusers</code> à 1, alors vous ne pouvez avoir que 36 processus en simultanés, comprenant les 18, environ, que le système lance au démarrage et les 15, à peu près, que vous créerez probablement au démarrage du système X Window. Même une tâche simple comme la lecture d’une page de manuel lancera jusqu’à neuf processus pour la filtrer, la décompresser, et l’afficher. Fixer <code>maxusers</code> à 64 autorisera jusqu’à 1044 processus simultanés, ce qui devrait suffire dans la plupart des cas. Si, toutefois, vous obtenez le message d’erreur tant redouté quand vous tentez d’exécuter un nouveau programme, ou gérez un serveur avec un grand nombre d’utilisateurs en simultanés (comme <code>ftp.FreeBSD.org</code>), vous pouvez toujours augmenter cette valeur et recompiler le noyau.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>maxusers</code> ne limite <em>pas</em> le nombre d’utilisateurs qui pourront ouvrir une session sur votre machine. Cette valeur dimensionne simplement différentes tables à des valeurs raisonnables en fonction du nombre maximal d’utilisateur que vous aurez vraisemblablement sur votre système et combien de processus chacun d’entre eux pourra utiliser.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_kern_ipc_somaxconn>12.12.1.2. <code>kern.ipc.somaxconn</code><a class=anchor href=#_kern_ipc_somaxconn></a></h5><div class=paragraph><p>La variable sysctl <code>kern.ipc.somaxconn</code> limite la taille de la file d’attente acceptant les nouvelles connexions TCP. La valeur par défaut de <code>128</code> est généralement trop faible pour une gestion robuste des nouvelles connexions dans un environnement de serveur web très chargé. Pour de tels environnements, il est recommandé d’augmenter cette valeur à <code>1024</code> ou plus. Le "daemon" en service peut de lui-même limiter la taille de la file d’attente (e.g. <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, ou Apache) mais disposera, la plupart du temps, d’une directive dans son fichier de configuration pour ajuster la taille de la file d’attente. Les files d’attentes de grandes tailles sont plus adaptées pour éviter les attaques par déni de service ().</p></div></div></div><div class=sect3><h4 id=nmbclusters>12.12.2. Limitations réseau<a class=anchor href=#nmbclusters></a></h4><div class=paragraph><p>L’literal du noyau <code>NMBCLUSTERS</code> fixe la quantité de "Mbuf";s disponibles pour le système. Un serveur à fort trafic avec un nombre faible de "Mbuf";s sous-emploiera les capacités de FreeBSD. Chaque "cluster" représente approximativement 2 Ko de mémoire, donc une valeur de 1024 représente 2 mégaoctets de mémoire noyau réservée pour les tampons réseau. Un simple calcul peut être fait pour déterminer combien sont nécessaires. Si vous avez un serveur web qui culmine à 1000 connexions simultanées, et que chaque connexion consomme un tampon de réception de 16Ko et un tampon d’émission de 16 Ko, vous avez approximativement besoin de 32 Mo de tampon réseau pour couvrir les besoin du serveur web. Un bon principe est de multiplier ce nombre par 2, soit 2x32 Mo / 2 Ko = 64 Mo / 2 Ko =32768. Nous recommandons des valeurs comprises entre 4096 et 32768 pour les machines avec des quantités de mémoire plus élevées. Vous ne devriez, dans aucun circonstance, spécifier de valeur élevée arbitraire pour ce paramètre étant donné que cela peut être à l’origine d’un plantage au démarrage. L’option <code>-m</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> peut être utilisée pour observer l’utilisation des "clusters".</p></div><div class=paragraph><p>La variable <code>kern.ipc.nmbclusters</code> configurable au niveau du chargeur est utilisée pour ajuster cela au démarrage. Seules les anciennes versions de FreeBSD vous demanderont d’utiliser l’option de configuration du noyau <code>NMBCLUSTERS</code>.</p></div><div class=paragraph><p>Pour les serveurs chargés qui font une utilisation intensive de l’appel système <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a>, il peut être nécessaire d’augmenter le nombre de tampons <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> par l’intermédiaire de l’option de configuration du noyau <code>NSFBUFS</code> ou en fixant sa valeur dans le fichier <span class=filename>/boot/loader.conf</span> (consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> pour plus de détails). Un indicateur de la nécessité d’ajuster ce paramètre est lorsque des processus sont dans l’état <code>sfbufa</code>. La variable sysctl <code>kern.ipc.nsfbufs</code> est un aperçu en lecture seule de la variable du noyau. Ce paramètre s’ajuste de façon optimale avec <code>kern.maxusers</code>, il peut être cependant nécessaire de l’ajuster en fonction des besoins.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Même si une "socket" a été marquée comme étant non-bloquante, un appel de <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> sur la "socket" non-bloquante peut résulter en un blocage de l’appel <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> jusqu’à ce que suffisamment de <code>struct sf_buf</code> soient libérées.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_net_inet_ip_portrange>12.12.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h5><div class=paragraph><p>Les variables <code>net.inet.ip.portrange.*</code> contrôlent les intervalles de ports automatiquement alloués aux "socket"s TCP et UDP. Il y a trois intervalles: un intervalle bas, un intervalle par défaut, et intervalle un haut. La plupart des programmes réseau utilisent l’intervalle par défaut qui est contrôlé par <code>net.inet.ip.portrange.first</code> et <code>net.inet.ip.portrange.last</code>, qui ont pour valeur par défaut respectivement 1024 et 5000. Ces intervalles de ports sont utilisés pour les connexions sortantes, et il est possible de se trouver à court de ports dans certaines conditions. Cela arrive le plus souvent quand votre système fait tourner un proxy web très chargé. L’intervalle de ports n’est pas un problème quand vous exécutez des serveurs qui ne gèrent principalement que des connexions entrantes, comme un server web classique, ou qui ont un nombre de connexions sortantes limitées comme un relai de messagerie. Pour les cas où vous risquez d’être à court de ports, il est recommandé d’augmenter légèrement <code>net.inet.ip.portrange.last</code>. Une valeur de <code>10000</code>, <code>20000</code> ou <code>30000</code> doit être suffisante. Vous devriez également penser au problème du coupe-feu lors du changement de l’intervalle des ports. Certains coupes-feu peuvent bloquer de grands intervalles de ports (en général les ports inférieurs) et s’attendent à ce que les systèmes utilisent les intervalles supérieurs pour les connexions sortantes - pour cette raison il n’est pas conseillé de diminuer <code>net.inet.ip.portrange.first</code>.</p></div></div><div class=sect4><h5 id=_le_produit_délai_bande_passante_tcp>12.12.2.2. Le produit délai-bande passante TCP<a class=anchor href=#_le_produit_délai_bande_passante_tcp></a></h5><div class=paragraph><p>La limitation du produit délai-bande passante TCP est semblable au TCP/Vegas sous NetBSD. Elle peut être activée en positionnant à <code>1</code> la variable <code>net.inet.tcp.inflight.enable</code>. Le système tentera alors de calculer le produit délai-bande passante pour chaque connexion et limitera la quantité de données en attente à la quantité juste nécessaire au maintient d’un flux de sortie optimal.</p></div><div class=paragraph><p>Cette fonctionnalité est utile si vous diffusez des données par l’intermédiaire de modems, de connexions Ethernet Gigabit, ou même de liaisons hauts débits WAN (ou toute autre liaison avec un produit délai-bande passante élevé), tout particulièrement si vous utilisez également le dimensionnement des fenêtres d’émission ou que vous avez configuré une fenêtre d’émission importante. Si vous activez cette option, vous devriez également vous assurer que <code>net.inet.tcp.inflight.debug</code> est positionnée à <code>0</code> (désactive le débogage), et pour une utilisation en production, fixer <code>net.inet.tcp.inflight.min</code> à au moins <code>6144</code> peut être bénéfique. Notez, cependant, que fixer des minima élevés peut désactiver la limitation de bande passante selon la liaison. La fonction de limitation diminue la quantité de données accumulées dans les files d’attente intermédiaire de routage et de commutation, et diminue également la quantité de données présentes dans les files d’attente de l’interface de la machine locale. Avec moins de paquets dans les files d’attente, les connexions interactives, tout particulièrement sur des modems lents, seront en mesure de fonctionner avec des <em>temps d’aller-retour</em> plus faible. Mais cette fonctionnalité n’affecte que la transmission de données (transmission côté serveur). Ceci n’a aucun effet sur la réception de données (téléchargement).</p></div><div class=paragraph><p>Modifier <code>net.inet.tcp.inflight.stab</code> n’est <em>pas</em> recommandé. Ce paramètre est fixé par défaut à la valeur 20, représentant au maximum 2 paquets ajoutés à la fenêtre de calcul du produit délai-bande passante. La fenêtre supplémentaire est nécessaire pour stabiliser l’algorithme et améliorer la réponse aux changements de conditions, mais il peut en résulter des temps de "ping" plus élevés sur les liaisons lentes (mais cependant inférieurs à ce que vous obtiendriez sans l’algorithme de limitation). Dans de tels cas, vous pouvez essayer de réduire ce paramètre à 15, 10, ou 5, et vous pouvez avoir à réduire le paramètre <code>net.inet.tcp.inflight.min</code> (par exemple à 3500) pour obtenir l’effet désiré. Ces paramètres ne doivent être réduits qu’en dernier ressort.</p></div></div></div><div class=sect3><h4 id=_mémoire_virtuelle>12.12.3. Mémoire virtuelle<a class=anchor href=#_mémoire_virtuelle></a></h4><div class=sect4><h5 id=_kern_maxvnodes>12.12.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h5><div class=paragraph><p>Un vnode est la représentation interne d’un fichier ou d’un répertoire. Augmenter le nombre de vnodes disponibles pour le système d’exploitation diminue les accès disque. Cela est normalement géré par le système d’exploitation et n’a pas besoin d’être modifié. Dans certains cas où les accès aux disques sont un goulot d’étranglement pour le système et que ce dernier est à cours de vnodes, ce nombre aura besoin d’être augmenté. La quantité de RAM libre et inactive sera prise en compte.</p></div><div class=paragraph><p>Pour connaître le nombre de vnodes actuellement utilisés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>Pour connaître le maximum de vnodes utilisables:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>Si l’utilisation actuelle des vnodes est proche du maximum, augmenter de 1000 <code>kern.maxvnodes</code> est probablement une bonne idée. Gardez un oeil sur le nombre <code>vfs.numvnodes</code>. S’il approche à nouveau le maximum, <code>kern.maxvnodes</code> devra être augmenté de manière plus conséquente. Une modification dans votre utilisation de la mémoire devrait être visible dans <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. Une plus grande quantité de mémoire devrait être annoncée comme active.</p></div></div></div></div><div class=sect2><h3 id=adding-swap-space>12.13. Ajouter de l’espace de pagination<a class=anchor href=#adding-swap-space></a></h3><div class=paragraph><p>Peu importe comment vous l’avez pensé, parfois un système ne fonctionne pas comme prévu. Si vous trouvez que vous avez besoin de plus d’espace de pagination, il est assez simple d’en rajouter. Vous avez trois manières d’augmenter votre espace de pagination: ajouter un nouveau disque dur, activer la pagination sur NFS, et créer un fichier de pagination sur une partition existante.</p></div><div class=paragraph><p>Pour des informations sur comment chiffrer l’espace de pagination, quelles options existent pour mener à bien cette tâche et pourquoi on devrait le faire, veuillez vous référer à la <a href=./#swap-encrypting>Chiffrage de l’espace de pagination</a> du Manuel.</p></div><div class=sect3><h4 id=new-drive-swap>12.13.1. Espace de pagination sur un nouveau disque dur ou une partition existante<a class=anchor href=#new-drive-swap></a></h4><div class=paragraph><p>Ajouter un nouveau disque pour l’espace de pagination donne de meilleures performances qu’utiliser une partition sur un disque existant. La configuration des partitions et des disques durs est expliquée dans la <a href=./#disks-adding>Ajouter des disques</a> tandis que la <a href=./#configtuning-initial>Choix du partitionnement</a> aborde l’organisation des partitions et les problèmes relatifs à la taille de la partition de l’espace de pagination.</p></div><div class=paragraph><p>Utiliser la commande <code>swapon</code> pour ajouter une partition de pagination au système. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Il est possible d’utiliser n’importe quelle partition actuellement non-montée, même si cette dernière contient des données. Utiliser <code>swapon</code> sur une partition contenant des données écrasera et effacera ces données. Assurez-vous que la partition à utiliser comme espace de pagination est bien celle prévue à cet effet avant d’exécuter <code>swapon</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour ajouter cette partition de pagination automatiquement au démarrage, ajouter une entrée au fichier <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>Consulter <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> pour plus d’explications sur les entrées du fichier <span class=filename>/etc/fstab</span>. Plus d’informations sur <code>swapon</code> sont disponibles dans <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>.</p></div></div><div class=sect3><h4 id=nfs-swap>12.13.2. Espace de pagination sur NFS<a class=anchor href=#nfs-swap></a></h4><div class=paragraph><p>L’espace de pagination sur NFS n’est recommandé que si vous n’avez pas de disque dur local sur lequel avoir l’espace de pagination; la pagination sur NFS sera limitée par la bande passante du réseau et sera un fardeau supplémentaire pour le serveur NFS.</p></div></div><div class=sect3><h4 id=create-swapfile>12.13.3. Fichiers de pagination<a class=anchor href=#create-swapfile></a></h4><div class=paragraph><p>Vous pouvez créer un fichier d’une taille spécifique pour l’utiliser comme fichier de pagination. Dans notre exemple nous utiliserons un fichier de 64MO appelé <span class=filename>/usr/swap0</span>. Vous pouvez, bien sûr, utiliser le nom de votre choix.</p></div><div class=exampleblock><div class=title>Exemple 15. Créer un fichier de pagination sous FreeBSD</div><div class=content><div class="olist arabic"><ol class=arabic><li><p>Le noyau <span class=filename>GENERIC</span> inclut déjà le pilote de disque mémoire (<a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>) nécessaire à cette opération. Lors de la compilation d’un noyau sur mesures, assurez-vous d’inclure la ligne suivante dans le fichier de configuration:</p><div class="literalblock programlisting"><div class=content><pre>device   md</pre></div></div><div class=paragraph><p>Pour plus d’information sur la compilation du noyau, veuillez vous réferer à la <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>.</p></div></li><li><p>Créez un fichier de pagination (<span class=filename>/usr/swap0</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</span></code></pre></div></div></li><li><p>Fixez les bonnes permissions sur <span class=filename>/usr/swap0</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Activez le fichier de pagination dans <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>swapfile=&#34;/usr/swap0&#34;   # Set to name of swapfile if aux swapfile desired.</pre></div></div></li><li><p>Redémarrez la machine ou activez directement le fichier de pagination:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /usr/swap0 -u 0  swapon /dev/md0</span></code></pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=acpi-overview>12.14. Gestion de l’énergie et des ressources<a class=anchor href=#acpi-overview></a></h3><div class=paragraph><p>Il est important d’utiliser les ressources matérielles d’une manière efficace. Avant l’apparition de l’ACPI, il était difficile pour les systèmes d’exploitation de gérer l’utilisation de l’alimentation et la température d’un système. Le matériel était géré par le BIOS et donc l’utilisateur avait moins de contrôle et de visibilité sur le paramétrage de la gestion de l’énergie. Une configuration limitée était accessible via l'<em>Advanced Power Management (APM)</em>. La gestion de l’énergie et des ressources est un des éléments clés d’un système d’exploitation moderne. Par exemple, vous pourrez vouloir qu’un système d’exploitation surveille certaines limites (et éventuellement vous alerte), au cas où la température de votre système augmente de façon inattendue.</p></div><div class=paragraph><p>Dans cette section, nous fournirons une information complète au sujet de l’ACPI. Il sera fait référence à des documents supplémentaires en fin de section pour plus de détails.</p></div><div class=sect3><h4 id=acpi-intro>12.14.1. Qu’est-ce que l’ACPI?<a class=anchor href=#acpi-intro></a></h4><div class=paragraph><p>L'"interface de configuration et d’alimentation avancée" (ACPI, Advanced Configuration and Power Interface) est une norme créée par un ensemble de constructeurs pour fournir une interface standard à la gestion des ressources et de l’énergie. C’est un élément clé dans le contrôle et la configuration par le système d’exploitation de de la gestion d’énergie, i.e., il permet plus de contrôle et flexibilité au système d’exploitation. Les systèmes modernes ont "repoussé" les limites des interfaces "Plug and Play" antérieures à l’apparition de l’ACPI. L’ACPI est le descendant direct de l’APM (Advanced Power Management - gestion avancée de l’énergie).</p></div></div><div class=sect3><h4 id=acpi-old-spec>12.14.2. Les imperfections de la gestion avancée de l’énergie (APM)<a class=anchor href=#acpi-old-spec></a></h4><div class=paragraph><p>Le système de <em>gestion avancée de l’énergie (APM)</em> gère l’utilisation de l’énergie par un système en fonction de son activité. Le BIOS APM est fourni par le fabricant (du système) et est spécifique à la plateforme matérielle. Un pilote APM au niveau du système d’exploitation gère l’accès à l'<em>interface logicielle APM</em> qui autorise la gestion des niveaux de consommation. L’APM devrait être toujours utilisé pour les systèmes fabriqués en ou avant 2000.</p></div><div class=paragraph><p>L’APM présente quatre problèmes majeurs. Tout d’abord la gestion de l’énergie est effectuée par le BIOS (spécifique au constructeur), et le système d’exploitation n’en a aucune connaissance. Un exemple de ce problème, est lorsque l’utilisateur fixe des valeurs pour le temps d’inactivité d’un disque dur dans le BIOS APM, qui une fois dépassé, provoque l’arrêt du disque (par le BIOS) sans le consentement du système d’exploitation. Deuxièmement, la logique de l’APM est interne au BIOS, et agit indépendamment du système d’exploitation. Cela signifie que les utilisateurs ne peuvent corriger les problèmes de leur BIOS APM qu’en flashant un nouveau BIOS; c’est une opération dangereuse, qui si elle échoue peut laisser le système dans un état irrécupérable. Troisièmement, l’APM est une technologie spécifique au constructeur, ce qui veut dire qu’il y a beaucoup de redondances (duplication des efforts) et de bogues qui peuvent être trouvées dans le BIOS d’un constructeur, et qui peuvent ne pas être corrigées dans d’autres BIOS. Et pour terminer, le dernier problème est le fait que le BIOS APM n’a pas suffisamment d’espace pour implémenter une politique sophistiquée de gestion de l’énergie, ou une politique qui peut s’adapter parfaitement aux besoins de la machine.</p></div><div class=paragraph><p>Le <em>BIOS Plug and Play (PNPBIOS)</em> n’était pas fiable dans de nombreuses situations. Le PNPBIOS est une technologie 16 bits, le système d’exploitation doit utiliser une émulation 16 bits afin de faire l'"interface" avec les méthodes PNPBIOS.</p></div><div class=paragraph><p>Le pilote APM FreeBSD est documenté dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a>.</p></div></div><div class=sect3><h4 id=acpi-config>12.14.3. Configurer l’ACPI<a class=anchor href=#acpi-config></a></h4><div class=paragraph><p>Le pilote <span class=filename>acpi.ko</span> est par défaut chargé par le <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> au démarrage et ne devrait <em>pas</em> être compilé dans le noyau. La raison derrière cela est que les modules sont plus facile à manipuler, par exemple pour passer à une autre version du module <span class=filename>acpi.ko</span> sans avoir à recompiler le noyau. Cela présente l’avantage de rendre les tests aisés. Une autre raison est que lancer l’ACPI après qu’un système ait terminé son lancement donne souvent lieu à des dysfonctionnements. Si des problèmes surviennent, vous pouvez désactiver l’ACPI. Ce pilote ne devrait et ne peut être déchargé car le bus système l’utilise pour différentes intéraction avec le matériel. L’ACPI peut être déactivé en ajoutant <code>hint.acpi.0.disabled="1"</code> dans le fichier <span class=filename>/boot/loader.conf</span> ou directement à l’invite du chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’ACPI et l’APM ne peuvent coexister et devraient être utilisé séparément. Le dernier chargé s’arrêtera s’il détecte l’autre en fonctionnement.</p></div></td></tr></tbody></table></div><div class=paragraph><p>L’ACPI peut être utilisé pour mettre en veille un système avec <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a>, les options <code>-s</code> et <code>1-5</code>. La plupart des utilisateurs n’auront besoin que de <code>1</code> ou <code>3</code> (système suspendu en RAM). L’option <code>5</code> provoquera un arrêt de l’alimentation par logiciel, effet identique à un:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># halt -p</span></code></pre></div></div><div class=paragraph><p>D’autres options sont disponibles via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Consultez les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> pour plus d’informations.</p></div></div></div><div class=sect2><h3 id=ACPI-debug>12.15. Utiliser et déboguer l’ACPI sous FreeBSD<a class=anchor href=#ACPI-debug></a></h3><div class=paragraph><p>L’ACPI est une nouvelle méthode de recherche des périphériques, de gestion de l’énergie, et fourni un accès standardisé à différents matériels gérés auparavant par le BIOS. Des progrès ont été fait vers un fonctionnement de l’ACPI sur tous les systèmes, mais des bogues dans le "bytecode" du <em>langage machine ACPI</em> (<em>ACPI Machine Language</em>-AML), des imperfections dans les sous-systèmes du noyau FreeBSD, et des bogues dans l’interpréteur ACPI-CA d’Intel® continuent d’apparaître.</p></div><div class=paragraph><p>Ce document est destiné à vous permettre d’aider les développeurs du système ACPI sous FreeBSD à identifier la cause originelle des problèmes que vous observez et à déboguer et développer une solution. Merci de lire ce document et nous espérons pouvoir résoudre les problèmes de votre système.</p></div><div class=sect3><h4 id=ACPI-submitdebug>12.15.1. Soumettre des informations de débogage<a class=anchor href=#ACPI-submitdebug></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Avant de soumettre un problème, assurez-vous d’utiliser la dernière version de votre BIOS, et si elle est disponible, la dernière version du firmware du contrôleur utilisé.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour ceux désirant soumettre directement un problème, veuillez faire parvenir les informations suivantes à la liste <a href=mailto:freebsd-acpi@FreeBSD.org>freebsd-acpi@FreeBSD.org</a>:</p></div><div class=ulist><ul><li><p>Description du comportement défectueux, en ajoutant le type et le modèle du système et tout ce qui peut causer l’apparition du bogue. Notez également le plus précisément possible quand le bogue a commencé à se manifester s’il est nouveau.</p></li><li><p>La sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> après un <code>boot -v</code>, y compris tout message généré lors de la manifestation du bogue.</p></li><li><p>La sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> après un <code>boot -v</code> avec l’ACPI désactivé, si cette désactivation corrige le problème.</p></li><li><p>La sortie de <code>sysctl hw.acpi</code>. C’est également un bon moyen de déterminer quelles fonctionnalités sont offertes par votre système.</p></li><li><p>Une URL où peut être trouvé votre <em>code source ACPI</em> (ACPI Source Language-ASL). N’envoyez pas directement l’ASL sur la liste de diffusion, ce fichier peut être très gros. Vous pouvez générer une copie de votre ASL en exécutant la commande suivante:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>(Remplacez <em>name</em> par votre nom d’utilisateur et <em>system</em> par celui du constructeur/modèle. Par exemple: <span class=filename>njl-FooCo6000.asl</span>)</p></div></li></ul></div><div class=paragraph><p>La plupart des développeurs lisent la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a> mais soumettez également les problèmes rencontrés à la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a> afin d’être sûr qu’ils seront vus. Soyez patient, nous avons tous un travail à plein temps qui nous attend ailleurs. Si votre bogue n’est pas immédiatement apparent, nous vous demanderons probablement de soumettre un PR par l’intermédiaire de <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. Quand vous remplirez un PR, veillez à inclure les mêmes informations que celles précisées précédemment. Cela nous aidera à cerner et à résoudre le problème. N’envoyez pas de PR sans avoir contacté auparavant la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a> étant donné que nous utilisons les PRs comme pense-bêtes de problèmes existants, et non pas comme mécanisme de rapport. Il se peut que votre problème puisse avoir déjà été signalé par quelqu’un d’autre.</p></div></div><div class=sect3><h4 id=ACPI-background>12.15.2. Information de fond<a class=anchor href=#ACPI-background></a></h4><div class=paragraph><p>L’ACPI est présent sur tous les ordinateurs modernes compatibles avec l’une des architectures ia32 (x86), ia64 (Itanium), et amd64 (AMD). La norme complète définit des fonctionnalités comme la gestion des performances du CPU, des contrôles des niveaux d’énergie, des zones de températures, divers systèmes d’utilisation des batteries, des contrôleurs intégrés, et l’énumération du bus. La plupart des systèmes n’implémentent pas l’intégralité des fonctionnalités de la norme. Par exemple, un ordinateur de bureau n’implémentera généralement que la partie énumération de bus alors qu’un ordinateur portable aura également le support de la gestion du refroidissement et de la batterie. Les ordinateurs portables disposent également des modes de mise en veille et de réveil, avec toute la complexité qui en découle.</p></div><div class=paragraph><p>Un système compatible ACPI dispose de divers composants. Les fabricants de BIOS et de circuits fournissent des tables de description (FADT) fixes en mémoire qui définissent des choses comme la table APIC (utilisée par les systèmes SMP), les registres de configuration, et des valeurs de configuration simples. De plus, est fournie une table de "bytecode" (la <em>table différenciée de description du système-Differentiated System Description Table</em> DSDT) qui spécifie sous forme d’une arborescence l’espace des noms des périphériques et des méthodes.</p></div><div class=paragraph><p>Le pilote ACPI doit analyser les tables, implémenter un interpréteur pour le "bytecode", et modifier les pilotes de périphériques et le noyau pour qu’ils acceptent des informations en provenance du sous-système ACPI. Pour FreeBSD, Intel® fourni un interpréteur (ACPI-CA) qui est partagé avec Linux et NetBSD. L’emplacement du code source de l’interpréteur ACPI-CA est <span class=filename>src/sys/contrib/dev/acpica</span>. Le code "glu" permettant à ACPI-CA de fonctionner sous FreeBSD se trouve dans <span class=filename>src/sys/dev/acpica/Osd</span>. Et enfin, les pilotes qui gèrent les différents périphériques ACPI se trouvent dans <span class=filename>src/sys/dev/acpica</span>.</p></div></div><div class=sect3><h4 id=ACPI-comprob>12.15.3. Problèmes courants<a class=anchor href=#ACPI-comprob></a></h4><div class=paragraph><p>Pour un fonctionnement correct de l’ACPI, il faut que toutes les parties fonctionnent correctement. Voici quelques problèmes courants, par ordre de fréquence d’apparition, et quelques contournements ou corrections possibles.</p></div><div class=sect4><h5 id=_problèmes_avec_la_souris>12.15.3.1. Problèmes avec la souris<a class=anchor href=#_problèmes_avec_la_souris></a></h5><div class=paragraph><p>Dans certains cas le réveil après une mise en veille sera à l’origine d’un dysfonctionnement de la souris. Une solution connue est d’ajouter la ligne <code>hint.psm.0.flags="0x3000"</code> au fichier <span class=filename>/boot/loader.conf</span>. Si cela ne fonctionne pas, pensez à envoyer un rapport de bogue comme décrit plus haut.</p></div></div><div class=sect4><h5 id=_mise_en_veilleréveil>12.15.3.2. Mise en veille/réveil<a class=anchor href=#_mise_en_veilleréveil></a></h5><div class=paragraph><p>L’ACPI dispose de trois modes de mise en veille en RAM (STR-Suspend To RAM), <code>S1</code> à <code>S3</code>, et un mode de mise en veille vers le disque dur (<code>STD</code>-Suspend To Disk), appelé <code>S4</code>. Le mode <code>S5</code> est un arrêt "soft" et est le mode dans lequel se trouve votre système quand il est branché mais pas allumé. Le mode <code>S4</code> peut être implémenté de deux manières différentes. Le mode <code>S4</code>BIOS est une mise en veille vers le disque assistée par le BIOS. Le mode <code>S4</code>OS est implémenté intégralement par le système d’exploitation.</p></div><div class=paragraph><p>Commencez par examiner la sortie de <code>sysctl hw.acpi</code> à la recherche d’éléments concernant les modes de mise en veille. Voici les résultats pour un Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Cela signifie que nous pouvons utiliser <code>acpiconf -s</code> pour tester les modes <code>S3</code>, <code>S4</code>OS, et <code>S5</code>. Si <code>s4bios</code> était égal à <code>1</code>, nous disposerions d’un support <code>S4</code>BIOS à la place de <code>S4</code>OS.</p></div><div class=paragraph><p>Quand vous testez la mise en veille et le réveil, commencez avec le mode <code>S1</code>, pour voir s’il est supporté. Ce mode doit fonctionner dans la plupart des cas puisqu’il nécessite peu de support. Le mode <code>S2</code> n’est pas implémenté, mais si vous en disposez, il est similaire au mode <code>S1</code>. La chose suivante à essayer est le mode <code>S3</code>. C’est le mode STR le plus avancé et il nécessite un support du pilote important pour réinitialiser correctement votre matériel. Si vous avez des problèmes au réveil de la machine, n’hésitez pas à contacter la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a> mais ne vous attendez pas à ce que le problème soit résolu puisqu’il y a de nombreux pilotes/matériels qui nécessitent plus de tests et de développement.</p></div><div class=paragraph><p>Un problème courant avec la mise en veille/le réveil est que de nombreux pilotes de périphériques ne sauvegardent pas, ne restaurent pas, ou ne réinitialisent pas leurs logiciel, registres ou mémoire proprement. En premier lieu pour débogguer le problème, essayez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>Ce test émule le cycle de mise en veille/réveil de tous les pilotes de périphériques sans réellement passer dans l’état <code>S3</code>. Dans certains cas, les problèmes comme la perte de l’état du périphérique, le dépassement du délai du chien de garde du périphérique, les tentatives répétées, peuvent être capturés avec cette méthode. Notez que le système n’entrera pas vraiment dans l’état <code>S3</code>, ce qui signifie que les périphériques peuvent ne pas perdre leur alimentation, et nombreux fonctionneront correctement même si les méthodes de mise en veille/réveil sont totalement absentes, contrairement au cas d’un véritable état <code>S3</code>.</p></div><div class=paragraph><p>Les cas plus difficiles nécessitent un matériel supplémentaire, tel qu’un port série et un câble pour débogguer à l’aide d’une console série, un port firewire et un câble pour l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>, et des compétences en debogguage du noyau.</p></div><div class=paragraph><p>Pour isoler le problème, retirez du noyau tous les pilotes de périphériques possibles. Si cela fonctionne, vous pouvez alors identifier le pilote fautif en chargeant les pilotes un à un jusqu’à l’apparition du problème. Généralement les pilotes binaires comme <span class=filename>nvidia.ko</span>, les pilotes d’affichage X11, ou les pilotes USB seront victimes de la plupart des problèmes tandis que ceux concernant les interfaces Ethernet fonctionneront normalement. Si vous pouvez charger/décharger les pilotes de périphériques correctement, vous pouvez automatiser cela en ajoutant les commandes appropriées dans les fichiers <span class=filename>/etc/rc.suspend</span> et <span class=filename>/etc/rc.resume</span>. Il y a un exemple en commentaire pour décharger ou charger un pilote. Essayez de fixer <code>hw.acpi.reset_video</code> à zéro (<code>0</code>) si votre affichage est corrompu après un réveil de la machine. Essayez des valeurs plus grandes ou plus faibles pour <code>hw.acpi.sleep_delay</code> pour voir si cela aide.</p></div><div class=paragraph><p>Une autre méthode est d’essayer de charger une distribution Linux récente avec le support ACPI et tester la mise en veille et le réveil sur le même matériel. Si cela fonctionne sous Linux, c’est probablement donc un problème de pilotes FreeBSD et déterminer quel pilote est responsable des dysfonctionnements nous aidera à corriger le problème. Notez que les personnes qui maintiennent l’ACPI sous FreeBSD ne s’occupe pas généralement des autres pilotes de périphériques (comme le son, le système ATA, etc.), aussi tout rapport concernant un problème de pilote devrait probablement en fin de compte être posté sur la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a> et communiqué au responsable du pilote. Si vous vous sentez une âme d’aventurier, commencez à ajouter des <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>s de débogage dans un pilote problématique pour déterminer à quel moment dans sa fonction de réveil il se bloque.</p></div><div class=paragraph><p>Enfin, essayez de désactiver l’ACPI et d’activer l’APM à la place, pour voir si la mise en veille et le réveil fonctionnent avec l’APM, tout particulièrement dans le cas de matériel ancien (antérieur à 2000). Cela prend du temps aux constructeurs de mettre en place le support ACPI et le matériel ancien aura sûrement des problèmes de BIOS avec l’ACPI.</p></div></div><div class=sect4><h5 id=_blocages_du_système_temporaires_ou_permanents>12.15.3.3. Blocages du système (temporaires ou permanents)<a class=anchor href=#_blocages_du_système_temporaires_ou_permanents></a></h5><div class=paragraph><p>La plupart des blocages système sont le résultat d’une perte d’interruptions ou d’une tempête d’interruptions. Les circuits ont beaucoup de problèmes en fonction de la manière dont le BIOS configure les interruptions avant le démarrage, l’exactitude de la table APIC (MADT), et le routage du <em>System Control Interrupt</em> (SCI).</p></div><div class=paragraph><p>Les tempêtes d’interruptions peuvent être distinguées des pertes d’interruptions en contrôlant la sortie de la commande <code>vmstat -i</code> en examinant la ligne mentionnant <code>acpi0</code>. Si le compteur s’incrémente plusieurs fois par seconde, vous êtes victime d’une tempête d’interruptions. Si le système semble bloqué, essayez de basculer sous DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> sous la console) et tapez <code>show interrupts</code>.</p></div><div class=paragraph><p>Votre plus grand espoir quand vous faites face à des problèmes d’interruptions est d’essayer de désactiver le support APIC avec la ligne <code>hint.apic.0.disabled="1"</code> dans le fichier <span class=filename>loader.conf</span>.</p></div></div><div class=sect4><h5 id=_paniques>12.15.3.4. Paniques<a class=anchor href=#_paniques></a></h5><div class=paragraph><p>Les paniques sont relativement rares dans le cas de l’ACPI et sont au sommet des priorités en matière de problèmes à corriger. Le premier point est d’isoler les étapes nécessaires à la reproduction de la panique (si possible) et d’obtenir une trace de débogage. Suivez l’aide sur l’activation de <code>options DDB</code> et la configuration d’une console série (lire la <a href=./#serialconsole-ddb>Entering the DDB Debugger from the Serial Line</a>) ou la configuration d’une partition <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>. Vous pouvez obtenir une trace de débogage sous DDB avec la commande <code>tr</code>. Si vous devez recopier à la main la trace de débogage, assurez-vous de relever les cinq dernières lignes et les cinq premières ligne de la trace.</p></div><div class=paragraph><p>Ensuite essayez d’isoler le problème en démarrant avec l’ACPI désactivé. Si cela fonctionne, vous pouvez isoler le sous-système ACPI en utilisant différentes valeurs pour l’option <code>debug.acpi.disable</code>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> pour des exemples.</p></div></div><div class=sect4><h5 id=_le_système_redémarre_après_une_mise_en_veille_ou_un_arrêt>12.15.3.5. Le système redémarre après une mise en veille ou un arrêt<a class=anchor href=#_le_système_redémarre_après_une_mise_en_veille_ou_un_arrêt></a></h5><div class=paragraph><p>Tout d’abord, essayez de fixer <code>hw.acpi.disable_on_poweroff="0"</code> dans <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>. Cela empêche l’ACPI de désactiver divers événements lors du processus d’arrêt. Certains systèmes ont besoin d’avoir cette valeur fixée à <code>1</code> (valeur par défaut) pour la même raison. Cela corrige généralement le problème d’un système démarrant spontanément après une mise en veille ou un arrêt.</p></div></div><div class=sect4><h5 id=_autres_problèmes>12.15.3.6. Autres problèmes<a class=anchor href=#_autres_problèmes></a></h5><div class=paragraph><p>Si vous rencontrez d’autres problèmes avec l’ACPI (impossible de travailler avec une station d’amarrage, périphériques non détectés, etc.), veuillez envoyer un courrier descriptif à la liste de diffusion; cependant, certains de ces problèmes peuvent être relatifs à des partie incomplètes du sous-système ACPI et qui pourront prendre du temps à être implémentées. Soyez patient et prêt à tester les correctifs que nous pourront éventuellement vous envoyer.</p></div></div></div><div class=sect3><h4 id=ACPI-aslanddump>12.15.4. ASL, <code>acpidump</code>, et IASL<a class=anchor href=#ACPI-aslanddump></a></h4><div class=paragraph><p>Le problème le plus courant est le fait que les constructeurs fournissent des "bytecodes" erronés (ou plus simplement bogués!). Cela se manifeste généralement sur la console par des messages du noyau du type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>La plupart du temps vous pouvez corriger ces problèmes en mettant à jour votre BIOS avec la dernière version disponible. La majorité des messages sur la console sont inoffensifs mais si vous avez d’autres problèmes comme l’état de la batterie qui ne fonctionne pas, ce sont de bonnes raisons pour commencer à jeter un oeil à ces problèmes dans l’AML. Le "bytecode", connu sous le nom d’AML, est compilé à partir d’un langage source appelé ASL. L’AML se trouve dans une table appelée DSDT. Pour obtenir une copie de votre ASL, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>. Vous devriez utiliser de paire les options <code>-t</code> (qui affiche le contenu des tables fixes) et <code>-d</code> (qui désassemble l’AML en ASL). Consultez la section <a href=#ACPI-submitdebug>Soumettre des informations de déboguage</a> pour un exemple de syntaxe.</p></div><div class=paragraph><p>Le tout premier test que vous pouvez effectuer est de recompiler votre ASL à la recherche d’erreurs. Les avertissements peuvent être généralement ignorés mais les erreurs sont des bogues qui normalement empêchent l’ACPI de fonctionner correctement. Pour recompiler votre ASL, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div></div><div class=sect3><h4 id=ACPI-fixasl>12.15.5. Correction de votre ASL<a class=anchor href=#ACPI-fixasl></a></h4><div class=paragraph><p>A long terme, notre objectif est que tout le monde puisse avoir un système ACPI fonctionnant sans aucune intervention de l’utilisateur. Actuellement, nous sommes toujours en train de développer des solutions pour contourner les erreurs courantes faites par les fabricants de BIOS. L’interpréteur de Microsoft® (<span class=filename>acpi.sys</span> et <span class=filename>acpiec.sys</span>) ne contrôle pas de façon stricte la conformité avec la norme, et par conséquent de nombreux fabricants de BIOS qui testent l’ACPI uniquement sous Windows® ne corrigent donc jamais leur ASL. Nous espérons poursuivre à identifier et documenter avec exactitude les comportements non-standards autorisés par l’interpréteur de Microsoft® et les reproduire de manière à permettre à FreeBSD de fonctionner sans obliger les utilisateurs à corriger leur ASL. Comme solution et pour nous aider à identifier ces comportements, vous pouvez corriger manuellement votre ASL. Si cela fonctionne pour vous, veuillez nous envoyer un <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> de l’ancien et du nouveau ASL de façon à ce que nous puissions corriger le comportement incorrect dans ACPI-CA et rendre donc inutile à l’avenir votre correctif.</p></div><div class=paragraph><p>Voici une liste des messages d’erreur courants, leur cause, et comment les corriger:</p></div><div class=sect4><h5 id=_dépendances_os>12.15.5.1. Dépendances _OS<a class=anchor href=#_dépendances_os></a></h5><div class=paragraph><p>Certains AMLs supposent que le monde n’est fait de que différentes versions de Windows®. Vous pouvez demander à FreeBSD de s’annoncer comme étant n’importe quel système d’exploitation pour voir si cela corrige les problèmes que vous pouvez rencontrer. Une manière simple de faire cela est de fixer la variable <code>hw.acpi.osname="Windows 2001"</code> dans <span class=filename>/boot/loader.conf</span> ou avec une autre chaîne de caractères que vous trouvez dans l’ASL.</p></div></div><div class=sect4><h5 id=_missing_return_statements>12.15.5.2. <code>Missing Return statements</code><a class=anchor href=#_missing_return_statements></a></h5><div class=paragraph><p>Certaines méthodes ne renvoient pas explicitement une valeur comme la norme le demande. Bien qu’ACPI-CA ne gère pas cela, FreeBSD contourne ce problème en renvoyant implicitement la valeur. Vous pouvez également ajouter des "Return statements" explicites où cela est nécessaire si vous connaissez la valeur à renvoyer. Pour forcer <code>iasl</code> à compiler l’ASL, utilisez l’option <code>-f</code>.</p></div></div><div class=sect4><h5 id=_remplacer_laml_par_défaut>12.15.5.3. Remplacer l’AML par défaut<a class=anchor href=#_remplacer_laml_par_défaut></a></h5><div class=paragraph><p>Après avoir personnalisé <span class=filename>votre.asl</span>, vous voudrez le compiler, pour cela exécutez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div><div class=paragraph><p>Vous pouvez ajouter l’option <code>-f</code> pour forcer la création de l’AML, même s’il y a des erreurs lors de la compilation. Rappelez-vous que certaines erreurs (e.g., <code>missing Return statements</code>) sont automatiquement contournées par l’interpréteur.</p></div><div class=paragraph><p><span class=filename>DSDT.aml</span> est le fichier de sortie par défaut pour <code>iasl</code>. Vous pouvez le charger à la place de la version boguée de votre BIOS (qui est toujours présent dans la mémoire flash) en éditant le fichier <span class=filename>/boot/loader.conf</span> comme suit:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Assurez-vous de bien copier votre fichier <span class=filename>DSDT.aml</span> dans le répertoire <span class=filename>/boot</span>.</p></div></div></div><div class=sect3><h4 id=ACPI-debugoutput>12.15.6. Obtenir d’ACPI une sortie de débogage<a class=anchor href=#ACPI-debugoutput></a></h4><div class=paragraph><p>Le pilote ACPI dispose d’une fonction de débogage très flexible. Elle vous permet de spécifier un ensemble de sous-systèmes ainsi que le niveau de verbosité. Les sous-systèmes que vous désirez déboguer sont indiqués sous la forme de "couches" et sont divisés en composants ACPI-CA (ACPI_ALL_COMPONENTS) et en supports matériel ACPI (ACPI_ALL_DRIVERS). La verbosité de la sortie de débogage est spécifiée par un "niveau" et des intervalles de ACPI_LV_ERROR (rapporte juste les erreurs) à ACPI_LV_VERBOSE (tout). Le "niveau" est un masque de bits séparés par des espaces, aussi de nombreuses options peuvent être fixées à la fois. Dans la pratique, vous voudrez utiliser un console série pour afficher la sortie si les informations de débogage sont si importantes qu’elles dépassent le tampon des messages de la console. Une liste complète des couches individuelles et des niveaux peut être trouvée dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div><div class=paragraph><p>L’affichage des informations de débogage n’est pas activé par défaut. Pour l’activer, ajoutez la ligne <code>options ACPI_DEBUG</code> à votre fichier de configuration du noyau si l’ACPI est compilé dans le noyau. Vous pouvez ajouter la ligne <code>ACPI_DEBUG=1</code> à votre fichier <span class=filename>/etc/make.conf</span> pour l’activer de façon globale. Si l’ACPI est sous forme de module, vous pouvez recompiler votre module <span class=filename>acpi.ko</span> comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi</span>
<span class=o>&amp;&amp;</span> make clean <span class=o>&amp;&amp;</span>
make <span class=nv>ACPI_DEBUG</span><span class=o>=</span>1</code></pre></div></div><div class=paragraph><p>Installez <span class=filename>acpi.ko</span> dans le répertoire <span class=filename>/boot/kernel</span> et indiquez le niveau et la couche désirée dans <span class=filename>loader.conf</span>. L’exemple suivant active les messages de débogage pour tous les composants ACPI-CA et tous les pilotes de matériel ACPI (CPU, LID, etc.). Il n’affichera que les messages d’erreur, c’est le niveau le moins verbeux.</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>Si l’information que vous voulez est déclenchée par un événement particulier (disons par exemple une mise en veille suivi d’un réveil), vous pouvez abandonner les modifications dans <span class=filename>loader.conf</span> et utiliser à la place <code>sysctl</code> pour indiquer la couche et le niveau après le démarrage et préparer votre système pour cet événement particulier. Les variables <code>sysctl</code> sont appelées de la même manière que dans le fichier <span class=filename>loader.conf</span>.</p></div></div><div class=sect3><h4 id=ACPI-References>12.15.7. Références<a class=anchor href=#ACPI-References></a></h4><div class=paragraph><p>Plus d’information au sujet de l’ACPI peut être trouvé aux emplacements suivants:</p></div><div class=ulist><ul><li><p>La liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a></p></li><li><p>Les archives de la liste de diffusion ACPI <a href=http://lists.freebsd.org/pipermail/freebsd-acpi/>http://lists.freebsd.org/pipermail/freebsd-acpi/</a></p></li><li><p>Les archives de l’ancienne liste de diffusion ACPI <a href=http://home.jp.FreeBSD.org/mail-list/acpi-jp/>http://home.jp.FreeBSD.org/mail-list/acpi-jp/</a></p></li><li><p>La <a href=https://uefi.org/specifications#ACPI>spécification ACPI</a></p></li><li><p>Les pages de manuel: <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li><li><p><a href=http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt>Ressource sur le débogage de la DSDT</a>. (Utilise un exemple basé sur du matériel Compaq mais qui est en général intéressant.)</p></li></ul></div></div></div></div></div><div class=sect1><h2 id=boot>Chapitre 13. Processus de démarrage de FreeBSD<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>13.1. Synopsis<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>L’action de démarrer un ordinateur et de charger le système d’exploitation est désignée sous le nom de "processus de bootstrap", ou simplement démarrage. Le processus de démarrage de FreeBSD fournit une grande flexibilité en adaptant ce qui se passe quand vous démarrez le système, vous permettant de choisir parmi les différents systèmes d’exploitation installés sur l’ordinateur, ou même parmi les différentes versions du même système d’exploitation ou du noyau installées.</p></div><div class=paragraph><p>Ce chapitre détaille les options de configuration que vous pouvez paramétrer et comment personnaliser le processus de démarrage de FreeBSD. Cela inclut tout ce qui se produit jusqu’au démarrage du noyau FreeBSD, la détection des périphériques, et le démarrage d’<a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. Si vous n’êtes pas tout à fait sûr du moment auquel cela arrive, cela se produit à l’instant où la couleur du texte passe d’un blanc lumineux au gris.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Quels sont les composants du système de démarrage de FreeBSD, et comment ils agissent les uns sur les autres.</p></li><li><p>Les options que vous pouvez passer aux composants du système de démarrage de FreeBSD pour contrôler le processus.</p></li><li><p>Les bases du système <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>x86 seulement</div><div class=paragraph><p>Ce chapitre ne décrit que le processus de démarrage de FreeBSD pour les systèmes Intel x86.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=boot-introduction>13.2. Le problème du démarrage<a class=anchor href=#boot-introduction></a></h3><div class=paragraph><p>Allumer un ordinateur et démarrer le système d’exploitation pose un intéressant dilemme. Par définition, l’ordinateur ne sait rien faire jusqu’à ce que le système d’exploitation soit lancé. Ceci inclut l’exécution des programmes à partir du disque. Donc si l’ordinateur ne peut pas exécuter de programme à partir du disque sans le système d’exploitation, et que les programmes du système d’exploitation sont sur le disque, comment le système d’exploitation est-il démarré?</p></div><div class=paragraph><p>On peut faire le parallèle avec un événement du livre Les aventures du Baron Munchausen. Le personnage tombe dans une bouche d’égout avec une partie du corps hors de la bouche, et il s’en sort en attrapant les fixations de ses bottes ("bootstraps"), et en se soulevant ainsi. Dans les premiers jours de l’informatique le terme <em>bootstrap</em> fut appliqué au mécanisme utilisé pour charger le système d’exploitation, terme qui a été raccourci en "booting" (que l’on traduit par démarrage en Français).</p></div><div class=paragraph><p>Sur l’architecture x86 c’est le BIOS ("Basic Input/Output System") qui est responsable du chargement du système d’exploitation. Pour effectuer cela, le BIOS recherche sur le disque dur le "Master Boot Record" - Secteur Principal de Démarrage (MBR), qui doit être placé à un endroit bien précis sur le disque. Le BIOS dispose de suffisamment de connaissances pour charger et exécuter le MBR, et suppose que le MBR peut alors effectuer le reste des tâches impliquées dans le chargement du système d’exploitation, probablement avec l’aide du BIOS.</p></div><div class=paragraph><p>Pour parler du code contenu dans le MBR, on fait souvent référence aux termes de <em>gestionnaire de démarrage gestionnaire d’amorce</em>, tout particulièrement quand il y a intéraction avec l’utilisateur. Dans ce cas le code de ce gestionnaire occupe un espace plus important sur la première <em>piste</em> du disque ou du système de fichier du système d’exploitation (le gestionnaire de démarrage est parfois également appelé gestionnaire de chargement ou chargeur, "boot loader", sous FreeBSD ce terme est utilisé pour une étape ultérieur du démarrage). Parmi les gestionnaire de démarrage populaire, se trouvent boot0 (également connu sous le nom de Boot Easy, le gestionnaire de démarrage standard de FreeBSD), Grub, GAG, et LILO (seul boot0 peut tenir entièrement dans l’espace du MBR.).</p></div><div class=paragraph><p>Si vous n’avez qu’un seul système d’exploitation installé sur vos disques alors le MBR PC standard sera suffisant. Ce MBR recherche la première tranche ("slice") amorçable (souvent appelée active) sur le disque, et puis exécute le code sur cette tranche pour charger le reste du système d’exploitation. Le MBR installé par <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> par défaut se comporte de cette manière. Il est basé sur <span class=filename>/boot/mbr</span>.</p></div><div class=paragraph><p>Si vous avez installé plusieurs systèmes d’exploitation sur vos disques alors vous pouvez installer un gestionnaire d’amorce différent, qui permet d’afficher une liste des différents systèmes d’exploitation, et vous permet de sélectionner celui à partir duquel démarrer. Ceci est abordé dans la sous-section suivante.</p></div><div class=paragraph><p>Le reste du système de démarrage de FreeBSD est divisé en trois étapes. La première étape est exécutée par le MBR, qui en sait juste assez pour mettre l’ordinateur dans un état spécifique et lancer la deuxième étape. La seconde étape peut en faire un peu plus, avant de lancer la troisième étape. La troisième étape termine la tâche de chargement du système d’exploitation. La tâche a été séparée en trois étapes parce que le standard PC impose des limites sur la taille des programmes qui peuvent être exécutés aux étapes une et deux. L’enchaînement des tâches permet à FreeBSD de fournir un chargeur plus flexible.</p></div><div class=paragraph><p>Le noyau est ensuite démarré et commence à sonder le système à la recherche de périphériques et les initialise. Une fois le processus de démarrage du noyau achevé, le noyau passe la main au processus <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, qui alors vérifie que les disques sont utilisables. <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> commence ensuite la configuration des ressources au niveau utilisateur, monte les systèmes de fichiers, initialise les cartes réseaux pour communiquer sur le réseau, et lance tous les processus qui sont habituellement exécutés au démarrage d’un système FreeBSD.</p></div></div><div class=sect2><h3 id=boot-blocks>13.3. Le gestionnaire de démarrage et les étapes de démarrage<a class=anchor href=#boot-blocks></a></h3><div class=sect3><h4 id=boot-boot0>13.3.1. Le gestionnaire de démarrage<a class=anchor href=#boot-boot0></a></h4><div class=paragraph><p>Le code contenu dans le MBR ou gestionnaire de démarrage ou d’amorce est parfois appelé <em>étape zéro</em> du processus de démarrage. Cette section discute de deux gestionnaires de démarrage précédemment mentionnés: boot0 et LILO.</p></div><div class=paragraph><p><strong>Le gestionnaire d’amorce boot0:</strong> Le MBR installé par l’installateur FreeBSD ou par <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> est basé sur <span class=filename>/boot/boot0</span>. (<span class=filename>boot0</span> est très simple, puisque le programme dans le ne peut pas occuper plus de 446 octets en raison de la table de partition principale et l’identifiant <code>0x55AA</code> à la fin du MBR). Si vous avez installé boot0 et plusieurs systèmes d’exploitation sur vos disques durs alors vous verrez un affichage semblable à celui-ci au démarrage:</p></div><div id=boot-boot0-example class=exampleblock><div class=title>Exemple 16. Ecran de <span class=filename>boot0</span></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</code></pre></div></div></div></div><div class=paragraph><p>D’autres systèmes d’exploitation, en particulier Windows®, sont connus pour écraser le MBR existant avec le leur. Si cela vous arrive, ou que vous désirez remplacer le MBR existant avec le MBR de FreeBSD alors utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -B -b /boot/boot0 device</span></code></pre></div></div><div class=paragraph><p>où <em>device</em> est le périphérique à partir duquel vous démarrez, comme <span class=filename>ad0</span> pour le premier disque IDE, <span class=filename>ad2</span> pour le premier disque IDE sur le second contrôleur IDE, <span class=filename>da0</span> pour le premier disque SCSI, et ainsi de suite. Ou, si vous voulez une configuration sur mesure du MBR, employez <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>.</p></div><div class=paragraph><p><strong>Le gestionnaire de démarrage LILO:</strong> Pour installer ce gestionnaire de manière à ce qu’il amorce également FreeBSD, démarrez tout d’abord Linux et ajoutez ce qui suit au fichier de configuration <span class=filename>/etc/lilo.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>other=/dev/hdXY
table=/dev/hdX
loader=/boot/chain.b
label=FreeBSD</pre></div></div><div class=paragraph><p>Dans ce qui précède, précisez la partition primaire et le disque FreeBSD en utilisant les paramètres propres à Linux, en remplaçant <em>X</em> avec la lettre correspondant au disque Linux et <em>Y</em> avec le numéro de la partition primaire Linux. Si vous utilisez un disque SCSI, vous changerez <em>/dev/hd</em> pour quelque chose de semblable à <em>/dev/sd</em>. La ligne <code>loader=/boot/chain.b</code> peut être omise si vous avez les deux systèmes d’exploitation sur le même disque. Lancez maintenant la commande <code>/sbin/lilo -v</code> pour entériner vos modifications; des messages de contrôle devraient s’afficher, vérifiant ces modifications.</p></div></div><div class=sect3><h4 id=boot-boot1>13.3.2. Etape une, <span class=filename>/boot/boot1</span>, et étape deux, <span class=filename>/boot/boot2</span><a class=anchor href=#boot-boot1></a></h4><div class=paragraph><p>Conceptuellement la première et la seconde étapes font partie du même programme, sur le même emplacement du disque. Mais en raison de contraintes d’espace elles ont été divisées en deux, mais vous les installerez toujours de paire. Elles sont copiées, à partir du fichier combiné <span class=filename>/boot/boot</span>, par l’installateur ou bsdlabel (voir plus bas).</p></div><div class=paragraph><p>On les trouve en dehors des systèmes de fichiers, sur la première piste de la tranche de démarrage, à partir du premier secteur. C’est l’endroit où <a href=#boot-boot0>boot0</a>, ou tout autre gestionnaire de démarrage s’attend à trouver le code à exécuter pour continuer le processus de démarrage. Le nombre de secteurs utilisés est facilement déterminé à partir de la taille du fichier <span class=filename>/boot/boot</span>.</p></div><div class=paragraph><p><span class=filename>boot1</span> est très simple, puisqu’il est limité à 512 octets, et en sait juste assez du <em>bsdlabel</em> de FreeBSD, qui contient l’information sur la tranche, pour trouver et lancer <span class=filename>boot2</span>.</p></div><div class=paragraph><p><span class=filename>boot2</span> est légèrement plus sophistiqué, et en connaît assez sur le système de fichiers de FreeBSD pour y trouver des fichiers, et il peut également fournir une interface simple pour sélectionner un noyau ou un chargeur à exécuter.</p></div><div class=paragraph><p>Comme le <a href=#boot-loader>chargeur</a> est beaucoup plus sophistiqué, et dispose d’une interface de configuration du démarrage facile d’emploi, <span class=filename>boot2</span> l’exécute habituellement, bien que précédemment, c’est lui qui lançait directement le noyau.</p></div><div id=boot-boot2-example class=exampleblock><div class=title>Exemple 17. Ecran de <span class=filename>boot2</span></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></div><div class=paragraph><p>Si vous avez un jour besoin de remplacer <span class=filename>boot1</span> et <span class=filename>boot2</span>, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -B diskslice</span></code></pre></div></div><div class=paragraph><p>où <em>diskslice</em> est le disque et la tranche à partir de laquelle vous démarrez, comme <span class=filename>ad0s1</span> pour la première tranche sur le premier disque IDE.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Mode dangereusement dédié</div><div class=paragraph><p>Si vous utilisez juste le nom du disque, comme <span class=filename>ad0</span>, dans la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> vous créerez un disque dangereusement dédié, sans tranches. Ce n’est presque certainement pas ce que vous voulez faire, donc vérifiez à deux fois la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> avant d’appuyer sur <kbd>Entrée</kbd>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-loader>13.3.3. Etape trois, <span class=filename>/boot/loader</span><a class=anchor href=#boot-loader></a></h4><div class=paragraph><p>Le chargeur est la dernière étape du processus de démarrage en trois temps, et il réside sur le système de fichiers, c’est habituellement le fichier <span class=filename>/boot/loader</span>.</p></div><div class=paragraph><p>Le chargeur a pour objet de fournir une méthode de configuration conviviale, en utilisant un jeu de commandes faciles d’emploi, doublé d’un interpréteur plus puissant, avec un ensemble de commandes plus complexes.</p></div><div class=sect4><h5 id=boot-loader-flow>13.3.3.1. Déroulement des opérations du chargeur<a class=anchor href=#boot-loader-flow></a></h5><div class=paragraph><p>A l’initialisation, le chargeur recherchera la console et les disques, et déterminera à partir de quel disque démarrer. Il positionnera les variables en conséquence, et un interpréteur sera lancé pour lequel l’utilisateur pourra passer des commandes par l’intermédiaire d’une procédure ou de façon interactive.</p></div><div class=paragraph><p>Le chargeur lira ensuite <span class=filename>/boot/loader.rc</span>, qui lui ira lire dans <span class=filename>/boot/defaults/loader.conf</span> les valeurs par défaut des variables à positionner et dans <span class=filename>/boot/loader.conf</span> les variantes locales de ces dernières. <span class=filename>loader.rc</span> se sert de ces variables pour charger les modules et le noyau sélectionnés.</p></div><div class=paragraph><p>Finalement, par défaut, le chargeur attend 10 secondes l’appui sur une ou plusieurs touches, et démarre le noyau s’il n’est pas interrompu. S’il est interrompu, une invite est alors affichée à l’utilisateur, un jeu de commandes simples permet à l’utilisateur de modifier des variables, charger ou décharger des modules, et enfin démarrer ou redémarrer.</p></div></div><div class=sect4><h5 id=boot-loader-commands>13.3.3.2. Commandes intégrées au chargeur<a class=anchor href=#boot-loader-commands></a></h5><div class=paragraph><p>Voici les commandes du chargeur les plus utilisées. Pour une information complète sur toutes les commandes disponibles, veuillez consulter la page <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>autoboot <em>secondes</em></dt><dd><p>Démarre le noyau si elle n’est pas interrompue dans le laps de temps donné en secondes. Elle affiche un compte à rebours, et le délai par défaut est de 10 secondes.</p></dd><dt class=hdlist1>boot [-options] [nom_du_noyau]</dt><dd><p>Démarre immédiatement le noyau dont le nom est indiqué, avec les options données, s’il y en a.</p></dd><dt class=hdlist1>boot-conf</dt><dd><p>Passe par la même configuration automatique des modules basée sur des variables comme ce qui se produit au démarrage. Cela n’a de sens que si vous utilisez <code>unload</code> en premier, et modifiez certaines variables, généralement <code>kernel</code>.</p></dd><dt class=hdlist1>help [sujet]</dt><dd><p>Affiche les messages d’aide contenus dans <span class=filename>/boot/loader.help</span>. Si le sujet donné est <code>index</code>, alors c’est la liste de tous les sujets existants qui est donnée.</p></dd><dt class=hdlist1>include <em>nom_du_fichier</em> …​</dt><dd><p>Traite le fichier dont le nom est donné. Le fichier est lu, et interprété ligne par ligne. Une erreur stoppe immédiatement le traitement.</p></dd><dt class=hdlist1>load [-t type] <em>nom_du_fichier</em></dt><dd><p>Charge le noyau, le module, ou le fichier du type donné, dont le nom est passé en paramètre. Les arguments qui suivent le nom du fichier sont passés au fichier.</p></dd><dt class=hdlist1>ls [-l] [chemin_d_accès]</dt><dd><p>Affiche la liste des fichiers du répertoire donné, ou du répertoire racine, si le chemin d’accès n’est pas précisé. Si l’option <code>-l</code> est utilisée, les tailles des fichiers seront également listées.</p></dd><dt class=hdlist1>lsdev [-v]</dt><dd><p>Liste tous les périphériques depuis lesquels il sera possible de charger des modules. Si l’option <code>-v</code> est utilisée, plus de détails seront donnés.</p></dd><dt class=hdlist1>lsmod [-v]</dt><dd><p>Affiche la liste des modules chargés. Si l’option <code>-v</code> est utilisée, plus de détails seront donnés.</p></dd><dt class=hdlist1>more <em>nom_du_fichier</em></dt><dd><p>Affiche les fichiers indiqués, avec une pause toutes <code>LINES</code> lignes.</p></dd><dt class=hdlist1>reboot</dt><dd><p>Redémarre immédiatement le système.</p></dd><dt class=hdlist1>set <em>variable</em></dt><dd><p>Positionne les variables d’environnement du chargeur.</p></dd><dt class=hdlist1>unload</dt><dd><p>Retire de la mémoire tous les modules chargés.</p></dd></dl></div></div><div class=sect4><h5 id=boot-loader-examples>13.3.3.3. Exemples d’utilisation du chargeur<a class=anchor href=#boot-loader-examples></a></h5><div class=paragraph><p>Voici quelques exemples pratiques d’utilisation du chargeur:</p></div><div class=ulist><ul><li><p>Pour simplement démarrer votre noyau habituel, mais en mode mono-utilisateur:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nt>-s</span></code></pre></div></div></li><li><p>Pour décharger votre noyau et modules habituels, puis charger votre ancien (ou un autre) noyau:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
load kernel.old</code></pre></div></div><div class=paragraph><p>Vous pouvez utiliser <span class=filename>kernel.GENERIC</span> pour faire référence au noyau générique du disque d’installation, ou <span class=filename>kernel.old</span> pour désigner votre noyau précédent (quand vous avez mis à jour ou configuré votre propre noyau, par exemple).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Utilisez ce qui suit pour charger vos modules habituels avec un autre noyau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
<span class=nb>set </span><span class=nv>kernel</span><span class=o>=</span><span class=s2>&#34;kernel.old&#34;</span>
boot-conf</code></pre></div></div></td></tr></tbody></table></div></li><li><p>Pour charger une procédure de configuration du noyau (une procédure qui automatise ce que vous faites normalement avec l’outil de configuration du noyau au démarrage):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>load <span class=nt>-t</span> userconfig_script /boot/kernel.conf</code></pre></div></div></li></ul></div></div></div></div><div class=sect2><h3 id=boot-kernel>13.4. Interaction avec le noyau au démarrage<a class=anchor href=#boot-kernel></a></h3><div class=paragraph><p>Une fois que le noyau est chargé, soit par le <a href=#boot-loader>chargeur</a> (habituellement) soit par <a href=#boot-boot1>boot2</a> (en court-circuitant le chargeur), il examine les options de démarrage s’il y en a, et adapte son comportement en conséquence.</p></div><div class=sect3><h4 id=boot-kernel-bootflags>13.4.1. Options de démarrage du noyau<a class=anchor href=#boot-kernel-bootflags></a></h4><div class=paragraph><p>Voici les options de démarrage les plus courantes:</p></div><div class=dlist><dl><dt class=hdlist1><code>-a</code></dt><dd><p>A l’initialisation du noyau, demande quel est le périphérique où se trouve le système de fichiers racine.</p></dd><dt class=hdlist1><code>-C</code></dt><dd><p>Démarre depuis le CDROM.</p></dd><dt class=hdlist1><code>-c</code></dt><dd><p>Exécute UserConfig, l’outil de configuration du noyau au démarrage.</p></dd><dt class=hdlist1><code>-s</code></dt><dd><p>Démarre en mode mono-utilisateur.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>Donne plus de détails lors du lancement du noyau.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il existe d’autres options de démarrage, lisez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> pour plus d’informations.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=device-hints>13.5. "Device Hints"-Paramétrage des périphériques<a class=anchor href=#device-hints></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>C’est une caractéristique de FreeBSD 5.0 et des versions suivantes qui n’existe pas dans les versions précédentes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Lors du démarrage du système, le chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) lira le fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>. Ce fichier stocke les informations de démarrage du noyau connues sous le nom de variables, et parfois appelées "device hints". Ces "device hints" sont utilisés par les pilotes de périphérique pour la configuration des périphériques.</p></div><div class=paragraph><p>Les "device hints" peuvent être spécifiés à l’invite du <a href=#boot-loader>chargeur</a>. Des variables peuvent être ajoutées en utilisant la commande <code>set</code>, retirées avec la commande <code>unset</code>, et affichées avec la commande <code>show</code>. Les variables positionnées dans le fichier <span class=filename>/boot/device.hints</span> peuvent être écrasées à cet endroit. Les "device hints" entrés au niveau du chargeur ne sont pas permanents et seront oubliés au prochain redémarrage.</p></div><div class=paragraph><p>Une fois le système démarré, la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a> peut être utilisée pour afficher toutes les variables.</p></div><div class=paragraph><p>La syntaxe du fichier <span class=filename>/boot/device.hints</span> est d’une variable par ligne, en utilisant le caractère "#" comme signe de mise en commentaire. Les lignes sont présentées comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hint.pilote.unité.motclé<span class=o>=</span><span class=s2>&#34;valeur&#34;</span></code></pre></div></div><div class=paragraph><p>La syntaxe à utiliser avec le chargeur est:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nb>set </span>hint.pilote.unité.motclé<span class=o>=</span>valeur</code></pre></div></div><div class=paragraph><p>où <code>pilote</code> est le pilote de périphérique, <code>unité</code> est le numéro de l’unité et <code>motclé</code> est le mot-clé correspondant à la variable. Le mot-clé pourra être une des options suivantes:</p></div><div class=ulist><ul><li><p><code>at</code>: spécifie le bus auquel le périphérique est attaché.</p></li><li><p><code>port</code>: spécifie l’adresse de départ de l’E/S à utiliser.</p></li><li><p><code>irq</code>: spécifie le numéro de la requête d’interruption à utiliser.</p></li><li><p><code>drq</code>: spécifie le numéro du canal DMA.</p></li><li><p><code>maddr</code>: spécifie l’adresse mémoire physique occupée par le périphérique.</p></li><li><p><code>flags</code>: fixe les bits des indicateurs pour le périphérique.</p></li><li><p><code>disabled</code>: si positionnée à <code>1</code> le périphérique est désactivé.</p></li></ul></div><div class=paragraph><p>Les pilotes de périphérique pourront accepter (ou nécessiter) plus de variables non listées ici, il est recommandé de lire leur page de manuel. Pour plus d’information, consultez les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div></div><div class=sect2><h3 id=boot-init>13.6. Init: Initialisation de la gestion des processus<a class=anchor href=#boot-init></a></h3><div class=paragraph><p>Une fois que le noyau a démarré, il passe le contrôle au processus utilisateur <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, qui se trouve dans <span class=filename>/sbin/init</span>, ou au programme défini dans la variable d’environnement <code>init_path</code> du chargeur.</p></div><div class=sect3><h4 id=boot-autoreboot>13.6.1. Séquence de redémarrage automatique<a class=anchor href=#boot-autoreboot></a></h4><div class=paragraph><p>La séquence de redémarrage automatique vérifie que les systèmes de fichiers sont cohérents. S’ils ne le sont pas, et que <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> ne peut pas corriger les incohérences, <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> place le système dans le <a href=#boot-singleuser>mode mono-utilisateur</a> pour que l’administrateur système règle directement le problème.</p></div></div><div class=sect3><h4 id=boot-singleuser>13.6.2. Mode mono-utilisateur<a class=anchor href=#boot-singleuser></a></h4><div class=paragraph><p>Ce mode peut être atteint depuis la <a href=#boot-autoreboot>séquence de redémarrage automatique</a>, ou quand l’utilisateur démarre avec l’option <code>-s</code> ou en positionnant la variable <code>boot_single</code> du chargeur.</p></div><div class=paragraph><p>On peut également y parvenir en appelant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> sans les options de redémarrage (<code>-r</code>) ou d’arrêt (<code>-h</code>), à partir du <a href=#boot-multiuser>mode multi-utilisateur</a>.</p></div><div class=paragraph><p>Si la <code>console</code> système est positionnée dans le mode <code>insecure</code> dans le fichier <span class=filename>/etc/ttys</span>, alors le système demande le mot de passe de <code>root</code> avant de passer en mode mono-utilisateur.</p></div><div id=boot-insecure-console class=exampleblock><div class=title>Exemple 18. Une console non sécurisée dans <span class=filename>/etc/ttys</span></div><div class=content><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Une console <code>insecure</code> (non sécurisée) signifie que vous considérez que la console n’est pas sécurisée, et vous désirez que seul quelqu’un connaissant le mot passe de <code>root</code> puisse utiliser le mode mono-utilisateur, et cela ne signifie pas que vous utilisez une console sans sécurité. Donc, si vous voulez de la sécurité, choisissez <code>insecure</code>, et non <code>secure</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-multiuser>13.6.3. Mode multi-utilisateur<a class=anchor href=#boot-multiuser></a></h4><div class=paragraph><p>Si <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> trouve vos systèmes de fichiers en état de marche, ou dès que l’utilisateur quitte le <a href=#boot-singleuser>mode mono-utilisateur</a>, le système entre dans le mode multi-utilisateur, dans lequel il commence la configuration de ses ressources.</p></div><div class=sect4><h5 id=boot-rc>13.6.3.1. Configuration des ressources (rc)<a class=anchor href=#boot-rc></a></h5><div class=paragraph><p>Le système de configuration des ressources lit les valeurs par défaut dans <span class=filename>/etc/defaults/rc.conf</span>, et les valeurs propres à la machine dans <span class=filename>/etc/rc.conf</span>, puis ensuite monte les systèmes de fichiers mentionnés dans <span class=filename>/etc/fstab</span>, démarre les services réseau, divers autres "démons" système, et enfin exécute les procédures de démarrage des logiciels installés localement.</p></div><div class=paragraph><p>La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> est une bonne référence au sujet du système de configuration des ressources, de même que la lecture des procédures de démarrage elles-mêmes.</p></div></div></div></div><div class=sect2><h3 id=boot-shutdown>13.7. Séquence d’arrêt du système<a class=anchor href=#boot-shutdown></a></h3><div class=paragraph><p>Lors de l’arrêt manuel du système, via <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> tentera d’exécuter la procédure <span class=filename>/etc/rc.shutdown</span>, et ensuite enverra à tous les processus le signal <code>TERM</code>, suivi du signal <code>KILL</code> à tous ceux qui ne se terminent pas à temps.</p></div><div class=paragraph><p>Pour éteindre une machine FreeBSD et cela sur des architectures ou des systèmes supportant la gestion par logiciel de l’énergie, utilisez simplement la commande <code>shutdown -p now</code> pour arrêter et couper l’alimentation de la machine. Pour juste redémarrer un système FreeBSD, utilisez <code>shutdown -r now</code>. Vous devez être super-utilisateur (<code>root</code>) ou un membre du groupe <code>operator</code> pour pouvoir exécuter <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>. Les commandes <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=8&amp;format=html">reboot(8)</a> peuvent également être utilisées, veuillez consulter leur page de manuel ainsi que celle de <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> pour plus d’informations.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La gestion de l’énergie nécessite d’avoir le support <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> dans son noyau ou chargé en tant que module.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=users>Chapitre 14. Gestion des comptes et des utilisateurs<a class=anchor href=#users></a></h2><div class=sectionbody><div class=sect2><h3 id=users-synopsis>14.1. Synopsis<a class=anchor href=#users-synopsis></a></h3><div class=paragraph><p>FreeBSD permet à de nombreux utilisateurs d’utiliser l’ordinateur en même temps. Evidemment, seul un de ces utilisateurs peut être assis devant l’écran et le clavier à un instant donné , mais n’importe quel nombre d’utilisateurs peut ouvrir une session par l’intermédiaire du réseau pour mener à bien son travail. Pour utiliser le système chaque utilisateur doit posséder un compte.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Les différences entre les divers comptes utilisateur sur un système FreeBSD.</p></li><li><p>Comment ajouter des comptes utilisateur.</p></li><li><p>Comment supprimer des comptes utilisateur.</p></li><li><p>Comment modifier les paramètres d’un compte, comme le nom complet de l’utilisateur, ou l’interpréteur de commandes préféré.</p></li><li><p>Comment fixer des limites par compte, pour contrôler les ressources comme la mémoire et le temps CPU auxquels les comptes et les groupes de comptes sont autorisés à accéder.</p></li><li><p>Comment utiliser les groupes pour rendre la gestion de comptes plus aisée.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les fondements d’UNIX® et de FreeBSD (<a href=./#basics>Quelques bases d’UNIX</a>).</p></li></ul></div></div><div class=sect2><h3 id=users-introduction>14.2. Introduction<a class=anchor href=#users-introduction></a></h3><div class=paragraph><p>Tout accès au système est effectué par l’intermédiaire de comptes, et tous les processus sont exécutés par des utilisateurs, la gestion des comptes et des utilisateurs est capitale sur les systèmes FreeBSD.</p></div><div class=paragraph><p>Chaque compte sur un système FreeBSD est associé avec un certain nombre d’informations utilisé pour identifier le compte.</p></div><div class=dlist><dl><dt class=hdlist1>"User name" - nom d’utilisateur</dt><dd><p>Le nom d’utilisateur comme il sera tapé à l’invite <code>login:</code>. Les noms d’utilisateur doivent être uniques sur le système; vous ne pouvez pas avoir deux utilisateurs avec le même nom d’utilisateur. Il y a un certain nombre de règles pour la création de noms d’utilisateur valides, documentées dans <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a>; vous utiliserez généralement des noms d’utilisateurs de huit lettres ou moins et en minuscules.</p></dd><dt class=hdlist1>"Password" - mot de passe</dt><dd><p>Chaque compte est associé à un mot de passe. Le mot de passe peut être vide, dans ce cas aucun mot de passe ne sera requis pour accéder au système. Ceci est une très mauvaise idée; chaque compte devrait avoir un mot de passe.</p></dd><dt class=hdlist1>"User ID (UID)" - identifiant utilisateur</dt><dd><p>L’UID est un nombre compris entre 0 et 65535, utilisé pour identifier de façon unique un utilisateur sur le système. Au niveau interne, FreeBSD utilise l’UID pour identifier les utilisateurs-toute commande qui vous permet de spécifier un utilisateur convertira le nom d’utilisateur en son UID avant de le traiter. Cela signifie que vous pouvez avoir plusieurs comptes avec des noms d’utilisateurs différents mais le même UID. En ce qui concerne FreeBSD ces comptes ne sont qu’un seul et unique utilisateur. Il est peu probable que vous ayez jamais à faire cela.</p></dd><dt class=hdlist1>"Group ID (GID)" - identifiant de groupe</dt><dd><p>Le GID est un nombre compris entre 0 et 65535, utilisé pour identifier de façon unique le groupe principal auquel appartient l’utilisateur. Les groupes sont un mécanisme pour contrôler l’accès aux ressources qui est basé sur le GID de l’utilisateur plutôt que sur son UID. Un utilisateur peut également appartenir à plus d’un groupe.</p></dd><dt class=hdlist1>"Login class" - classe de session</dt><dd><p>Les classes de session sont une extension du mécanisme de groupe qui apporte une flexibilité supplémentaire quand on adapte le système aux différents utilisateurs.</p></dd><dt class=hdlist1>"Password change time" - durée de vie d’un mot de passe</dt><dd><p>Par défaut FreeBSD n’oblige pas les utilisateurs à changer leur mot de passe régulièrement. Vous pouvez forcer cela en fonction de l’utilisateur, en obligeant certains ou tous les utilisateurs à changer leur mot de passe après qu’une certaine période de temps se soit écoulée.</p></dd><dt class=hdlist1>"Account expiry time" - date d’expiration d’un compte</dt><dd><p>Par défaut FreeBSD ne désactive pas de comptes après une certaine période. Si vous créez des comptes qui auront une durée de vie limitée, par exemple, dans une école où il existe des comptes pour les étudiants, alors vous pouvez spécifier la date d’expiration des comptes. Après la durée d’expiration écoulée le compte ne pourra plus être utilisé pour ouvrir de session sur le système, bien que les répertoires et les fichiers attachés au compte seront conservés.</p></dd><dt class=hdlist1>"User’s full name" - nom complet d’utilisateur</dt><dd><p>Le nom d’utilisateur identifie uniquement le compte sur FreeBSD, mais ne reflète pas nécessairement le nom réel de l’utilisateur. Cette information peut être associée avec le compte.</p></dd><dt class=hdlist1>"Home directory" - répertoire utilisateur</dt><dd><p>Le répertoire utilisateur est le chemin complet vers un répertoire sur le système dans lequel se retrouve l’utilisateur quand il ouvre une session sur le système. Une convention commune est de mettre tous les répertoires d’utilisateurs sous <span class=filename>/home/username</span> ou <span class=filename>/usr/home/username</span>. L’utilisateur pourra stocker ses fichiers personnel dans son répertoire utilisateur et dans tout sous-répertoire qu’il pourra y créer.</p></dd><dt class=hdlist1>"User shell" - interpréteur de commandes de l’utilisateur</dt><dd><p>L’interpréteur de commandes fournit aux utilisateurs l’environnement par défaut pour communiquer avec le système. Il existe plusieurs différents types d’interpréteurs de commandes, et les utilisateurs expérimentés auront leur préférence, qui peut se refléter dans le paramétrage de leur compte.</p></dd></dl></div><div class=paragraph><p>Il y a trois principales sortes de comptes: le <a href=#users-superuser>super-utilisateur</a>, les <a href=#users-system>utilisateurs système</a>, et les <a href=#users-user>comptes utilisateur</a>. Le compte super-utilisateur, normalement appelé <code>root</code>, est utilisé pour gérer le système sans aucune limitation de privilèges. Les utilisateurs système exécutent des services. Et enfin, les comptes utilisateur sont utilisés par de véritables utilisateurs, qui ouvrent des sessions, lisent leur courrier électronique, et ainsi de suite.</p></div></div><div class=sect2><h3 id=users-superuser>14.3. Le compte super-utilisateur<a class=anchor href=#users-superuser></a></h3><div class=paragraph><p>Le compte super-utilisateur, habituellement appelé <code>root</code>, est préconfiguré pour simplifier l’administration système, et ne devrait pas être utilisé pour des tâches quotidiennes comme l’envoi et la réception de courrier électronique, l’exploration du système, ou la programmation.</p></div><div class=paragraph><p>Cela parce que le super-utilisateur, à la différence des comptes utilisateurs ordinaires, peut agir sans aucune limite, et une mauvaise utilisation du compte super-utilisateur peut être à l’origine de résultats catastrophiques. On ne peut pas endommager par erreur le système avec un compte utilisateur, il est donc généralement préférable d’utiliser des comptes utilisateur ordinaires chaque fois que c’est possible, à moins d’avoir particulièrement besoin de droits supplémentaires.</p></div><div class=paragraph><p>Vous devriez toujours vérifier et revérifier les commandes que vous tapez en tant que super-utilisateur, parce qu’un espace en trop ou un caractère manquant peuvent signifier la perte définitive de données.</p></div><div class=paragraph><p>Donc, la première chose que vous devriez faire, après la lecture de ce chapitre, est de vous créer un compte utilisateur sans privilèges si vous n’en avez pas déjà. Cela s’applique aussi bien à une machine multi-utilisateurs qu’à une machine mono-utilisateur. Plus loin dans ce chapitre, nous expliquerons comment créer de nouveaux comptes, et comment passer d’un compte utilisateur ordinaire au compte du super-utilisateur.</p></div></div><div class=sect2><h3 id=users-system>14.4. Comptes système<a class=anchor href=#users-system></a></h3><div class=paragraph><p>Les utilisateurs système sont ceux utilisés pour exécuter des services comme le DNS, le courrier électronique, les serveurs web, et ainsi de suite. La raison de cela est la sécurité; si tous les services s’exécutaient avec les droits du super-utilisateur, ils pourraient agir sans aucune restriction.</p></div><div class=paragraph><p>Des exemples d’utilisateurs système sont <code>daemon</code>, <code>operator</code>, <code>bind</code> (pour le serveur de noms de domaine), <code>news</code>, et <code>www</code>.</p></div><div class=paragraph><p><code>nobody</code> est l’utilisateur sans privilèges générique du système. Cependant, il est important de garder à l’esprit que plus grand est le nombre de services utilisant <code>nobody</code>, plus grand sera le nombre de fichiers et de processus associés à cet utilisateur, et par conséquent plus grand sera le nombre de privilèges de cet utilisateur.</p></div></div><div class=sect2><h3 id=users-user>14.5. Comptes utilisateur<a class=anchor href=#users-user></a></h3><div class=paragraph><p>Les comptes utilisateur sont le principal moyen pour les véritables utilisateurs d’accéder au système, ces comptes isolent l’utilisateur du reste de l’environnement, empêchant les utilisateurs d’endommager le système et ou les comptes d’autres utilisateurs, tout en leur permettant de personnaliser leur environnement sans incidence pour les autres utilisateurs.</p></div><div class=paragraph><p>Chaque personne accédant à votre système ne devrait posséder que son propre et unique compte. Cela vous permet de savoir qui fait quoi, empêche un utilisateur de désorganiser l’environnement d’un autre ou de lire du courrier électronique qui ne lui est pas destiné, et ainsi de suite.</p></div><div class=paragraph><p>Chaque utilisateur peut configurer son propre environnement en fonction de ses besoins, pour utiliser d’autres interpréteurs de commandes, éditeurs, raccourcis de clavier, et langues.</p></div></div><div class=sect2><h3 id=users-modifying>14.6. Modifier des comptes<a class=anchor href=#users-modifying></a></h3><div class=paragraph><p>Il existe une variété de différentes commandes disponibles dans l’environnement UNIX® pour manipuler les comptes utilisateur. Les commandes les plus communes sont récapitulées ci-dessous, suivis par des exemples détaillés de leur utilisation.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Commande</th><th class="tableblock halign-left valign-top">Résumé</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’application en ligne de commande recommandée pour ajouter de nouveaux utilisateurs.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’application en ligne de commande recommandée pour supprimer des utilisateurs.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Un outil flexible pour modifier les informations de la base de données utilisateur.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’outil simple en ligne de commande pour changer les mots de passe utilisateur.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Un puissant et flexible outil pour modifier tous les aspects des comptes utilisateurs.</p></td></tr></tbody></table><div class=sect3><h4 id=users-adduser>14.6.1. <code>adduser</code><a class=anchor href=#users-adduser></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> est un programme simple pour ajouter de nouveaux utilisateurs. Il crée les entrées dans les fichiers système <span class=filename>passwd</span> et <span class=filename>group</span>. Il crée également le répertoire utilisateur pour le nouvel utilisateur, y copie les fichiers de configuration par défaut ("dotfiles") à partir de <span class=filename>/usr/shared/skel</span>, et peut éventuellement envoyer à l’utilisateur un courrier électronique de bienvenue.</p></div><div class=exampleblock><div class=title>Exemple 19. Ajouter un utilisateur sous FreeBSD</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser</span>
Username: jru
Full name: J. Random User
Uid <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Login group <span class=o>[</span>jru]:
Login group is jru. Invite jru into other <span class=nb>groups</span>? <span class=o>[]</span>: wheel
Login class <span class=o>[</span>default]:
Shell <span class=o>(</span>sh csh tcsh zsh nologin<span class=o>)</span> <span class=o>[</span>sh]: zsh
Home directory <span class=o>[</span>/home/jru]:
Use password-based authentication? <span class=o>[</span><span class=nb>yes</span><span class=o>]</span>:
Use an empty password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Use a random password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Enter password:
Enter password again:
Lock out the account after creation? <span class=o>[</span>no]:
Username   : jru
Password   : <span class=k>****</span>
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: <span class=nb>yes
</span>adduser: INFO: Successfully added <span class=o>(</span>jru<span class=o>)</span> to the user database.
Add another user? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: no
Goodbye!
<span class=c>#</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le mot de passe que vous tapez n’apparaît pas à l’écran, et il n’y a pas non plus d’astérisques affichés. Assurez-vous de ne pas vous tromper dans le mot de passe.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=users-rmuser>14.6.2. <code>rmuser</code><a class=anchor href=#users-rmuser></a></h4><div class=paragraph><p>Vous pouvez utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> pour supprimer complètement un utilisateur du système. <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> effectue les opérations suivantes:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Supprime les entrées appartenant à l’utilisateur de la <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> (s’il y en a).</p></li><li><p>Supprime les tâches <a href="https://man.freebsd.org/cgi/man.cgi?query=at&amp;sektion=1&amp;format=html">at(1)</a> appartenant à l’utilisateur.</p></li><li><p>Tue tous les processus appartenant à l’utilisateur.</p></li><li><p>Supprime l’utilisateur du fichier de mots de passe local.</p></li><li><p>Supprime le répertoire l’utilisateur (s’il lui appartient).</p></li><li><p>Supprime les courriers électroniques en attente pour l’utilisateur dans <span class=filename>/var/mail</span>.</p></li><li><p>Supprime tous les fichiers temporaires appartenant à l’utilisateur des zones de stockages temporaires comme <span class=filename>/tmp</span>.</p></li><li><p>Et enfin, supprime l’utilisateur de tous les groupes auxquels il appartient dans <span class=filename>/etc/group</span>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si un groupe est vide de ce fait et que le nom du groupe est le même que celui de l’utilisateur, le groupe est supprimé; c’est la réciproque de la création par <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> d’un groupe propre pour chaque utilisateur.</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> ne peut pas être employé pour supprimer des comptes super-utilisateur, car cela entraînerait presque toujours des destructions massives.</p></div><div class=paragraph><p>Par défaut, la commande travaille en mode interactif, pour garantir que vous soyez sûr de ce que vous faites.</p></div><div class=exampleblock><div class=title>Exemple 20. Suppression interactive de compte avec <code>rmuser</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rmuser jru</span>
Matching password entry:
jru:<span class=k>*</span>:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user<span class=s1>&#39;s home directory (/home/jru)? y
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user&#39;</span>s incoming mail file /var/mail/jru: <span class=k>done</span><span class=nb>.</span>
Removing files belonging to jru from /tmp: <span class=k>done</span><span class=nb>.</span>
Removing files belonging to jru from /var/tmp: <span class=k>done</span><span class=nb>.</span>
Removing files belonging to jru from /var/tmp/vi.recover: <span class=k>done</span><span class=nb>.</span>
<span class=c>#</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=users-chpass>14.6.3. <code>chpass</code><a class=anchor href=#users-chpass></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> modifie les informations de la base de données des utilisateurs comme les mots de passe, les interpréteurs de commandes, et les informations personnelles.</p></div><div class=paragraph><p>Seuls les administrateurs système, comme le super-utilisateur, peuvent modifier les informations concernant les autres utilisateurs et les mots de passe à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>.</p></div><div class=paragraph><p>Utilisé sans options, en dehors du nom facultatif de l’utilisateur, <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> ouvre un éditeur affichant les informations de l’utilisateur. Quand l’utilisateur quitte l’éditeur, la base de données utilisateur est mise à jour avec les nouvelles informations.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>On vous demandera votre mot de passe en quittant l’éditeur si vous n’êtes pas le super-utilisateur.</p></div></td></tr></tbody></table></div><div class=exampleblock><div class=title>Exemple 21. <code>chpass</code> interactif par le super-utilisateur</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Login: jru
Password: <span class=k>*</span>
Uid <span class=o>[</span><span class=c>#]: 1001</span>
Gid <span class=o>[</span><span class=c># or name]: 1001</span>
Change <span class=o>[</span>month day year]:
Expire <span class=o>[</span>month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class=paragraph><p>Un utilisateur ordinaire ne peut modifier qu’une partie de ces informations, et seulement celles qui le concernent.</p></div><div class=exampleblock><div class=title>Exemple 22. <code>chpass</code> interactif par un utilisateur ordinaire</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=chfn&amp;sektion=1&amp;format=html">chfn(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> sont juste des liens vers <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>, comme le sont <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchpass&amp;sektion=1&amp;format=html">ypchpass(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchfn&amp;sektion=1&amp;format=html">ypchfn(1)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchsh&amp;sektion=1&amp;format=html">ypchsh(1)</a>. NIS est supporté automatiquement, aussi spécifier <code>yp</code> avant la commande n’est pas nécessaire. Si cela vous semble confus, ne vous inquiétez pas, NIS sera abordé dans le chapitre <a href=./#network-servers>Serveurs réseau</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=users-passwd>14.6.4. <code>passwd</code><a class=anchor href=#users-passwd></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> est la méthode habituelle pour modifier son mot de passe, ou celui d’un autre utilisateur si vous êtes le super-utilisateur.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour prévenir des modifications accidentelles ou non autorisées, le mot de passe original doit être entré avant de pouvoir fixer un nouveau mot de passe.</p></div></td></tr></tbody></table></div><div class=exampleblock><div class=title>Exemple 23. Modifier votre mot de passe</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Exemple 24. Modifier le mot de passe d’un autre utilisateur en tant que super-utilisateur</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># passwd jru</span>
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Comme pour <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=yppasswd&amp;sektion=1&amp;format=html">yppasswd(1)</a> est juste un lien vers <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>, donc NIS fonctionnera avec l’une des deux commandes.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=users-pw>14.6.5. <code>pw</code><a class=anchor href=#users-pw></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> est un utilitaire en ligne de commande pour créer, supprimer, modifier, et lister utilisateurs et groupes. Il fonctionne comme une interface aux fichiers d’utilisateurs et de groupe. <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> possède un ensemble puissant d’options qui le rende adapté à une utilisation dans des procédures, mais les nouveaux utilisateurs pourront le trouver plus compliqué que les autres commandes présentées ici.</p></div></div></div><div class=sect2><h3 id=users-limiting>14.7. Mettre en place des restrictions pour les utilisateurs<a class=anchor href=#users-limiting></a></h3><div class=paragraph><p>Si vous avez plusieurs utilisateurs sur votre système, la possibilité de limiter leur utilisation du système peut venir à l’esprit. FreeBSD fournit plusieurs méthodes à l’administrateur système pour limiter la quantité de ressources système qu’un utilisateur peut utiliser. Ces limites sont généralement divisées en deux parties: les quotas disque, et les autres limites de ressource.</p></div><div class=paragraph><p>Les quotas limitent l’utilisation des disques par les utilisateurs, et ils fournissent un moyen de vérifier rapidement cette utilisation sans avoir à faire des calculs à chaque fois. Les quotas sont abordés dans la <a href=./#quotas>Quotas d’utilisation des disques</a>.</p></div><div class=paragraph><p>Les autres limites de ressource comprennent les moyens de limiter l’utilisation du CPU, de la mémoire, et les autres ressources qu’un utilisateur peut consommer. Elles sont définies en employant des classes de session et sont abordées ici.</p></div><div class=paragraph><p>Les classes de session sont définies dans <span class=filename>/etc/login.conf</span>. La sémantique précise sort du cadre de cette section, mais est décrite en détail dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>. Il est suffisant de dire que chaque utilisateur est assigné à une classe (<code>default</code> par défaut), et que chaque classe dispose d’un ensemble de capacités associées. La forme utilisée pour ces capacités est une paire <code>nom=valeur</code> où <em>nom</em> est un identifiant connu et <em>valeur</em> est une chaîne arbitraire dépendante du nom. Paramétrer des classes et des capacités est plutôt direct et également décrit dans <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le système ne lit normalement pas directement le fichier <span class=filename>/etc/login.conf</span>, mais plutôt la base de données <span class=filename>/etc/login.conf.db</span> qui fournit plus rapidement les réponses au système. Pour générer <span class=filename>/etc/login.conf.db</span> à partir du fichier <span class=filename>/etc/login.conf</span>, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Les limites de ressource sont différentes des capacités standards des classes en deux points. Premièrement, pour chaque limite, il existe une limite douce (actuelle) et limite dure. Une limite douce peut être ajustée par l’utilisateur ou une application, mais jamais dépasser la limite dure. Cette dernière peut être abaissée par l’utilisateur, mais jamais augmentée. Deuxièmement, la plupart des limites de ressource s’applique par processus à un utilisateur spécifique, et non pas à l’utilisateur dans sa totalité. Notez, cependant, que ces différences sont exigées par la manipulation spécifique des limites, et non pas par l’implémentation du système des capacités des classes de session utilisateur (i.e., elles ne sont <em>vraiment</em> pas un cas particulier des capacités des classes de session).</p></div><div class=paragraph><p>Sans plus attendre, ci-dessous sont présentées les limites de ressource les plus souvent utilisées (le reste, avec les autres capacités des classes de session, peut être trouvé dans <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>).</p></div><div class=dlist><dl><dt class=hdlist1><code>coredumpsize</code></dt><dd><p>La limite sur la taille du fichier core généré par un programme est, pour d’évidentes raisons, subordonnée aux autres limites sur l’utilisation du disque (e.g., <code>filesize</code>, ou les quotas de disque). Néanmoins, elle est souvent employée comme méthode moins sévère pour contrôler la consommation d’espace disque: puisque les utilisateurs ne génèrent pas de fichier core eux-mêmes, et souvent ne les suppriment pas, paramétrer cela peut leur éviter de manquer d’espace disque si un programme important (e.g., emacs) plante.</p></dd><dt class=hdlist1><code>cputime</code></dt><dd><p>C’est la quantité maximale de temps CPU qu’un processus d’un utilisateur peut consommer. Les processus la dépassant seront tués par le noyau.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>C’est une limite sur le <em>temps</em> CPU consommé, non sur le pourcentage comme affiché par certains champs de <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>. Une limite sur ce dernier est, au moment de l’écriture de ces lignes, impossible, et serait plutôt inutile: un compilateur-probablement une tâche légitime-peut aisément utiliser presque 100% du CPU pendant un certain temps.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><code>filesize</code></dt><dd><p>C’est la taille maximale du plus gros fichier qu’un utilisateur peut posséder. Contrairement aux <a href=./#quotas>quotas</a>, cette limite ne s’applique qu’aux fichiers individuellement, et non pas sur l’ensemble lui-même de tous les fichiers que possède un utilisateur.</p></dd><dt class=hdlist1><code>maxproc</code></dt><dd><p>C’est le nombre maximal de processus que peut exécuter un utilisateur en même temps. Ceci inclut les processus de premier plan et de tâche de fond. Pour d’évidentes raisons, il ne doit pas être plus grand que les limites du système spécifiées par la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>kern.maxproc</code>. Notez en outre qu’une valeur trop basse peut gêner la productivité de l’utilisateur: il est souvent utile d’ouvrir plusieurs sessions à la fois ou d’exécuter des opérations sous forme de "pipeline". Certaines tâches, comme compiler un gros programme, engendrent également de multiples processus (e.g., <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=cc&amp;sektion=1&amp;format=html">cc(1)</a>, et autres préprocesseurs).</p></dd><dt class=hdlist1><code>memorylocked</code></dt><dd><p>C’est la quantité maximale de mémoire qu’un processus peut avoir demandé de verrouiller en mémoire principale (e.g., voir <a href="https://man.freebsd.org/cgi/man.cgi?query=mlock&amp;sektion=2&amp;format=html">mlock(2)</a>). Certains programmes système critiques, comme <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a>, sont verrouillés en mémoire principale de sorte qu’en cas de dépassement de la mémoire de pagination, ils ne contribuent pas aux ennuis du système.</p></dd><dt class=hdlist1><code>memoryuse</code></dt><dd><p>C’est la quantité maximale de mémoire qu’un processus peut consommer à un instant donné. Cela inclus la mémoire principale et celle de pagination. Ce n’est pas le remède miracle pour restreindre la consommation de mémoire, mais c’est un bon début.</p></dd><dt class=hdlist1><code>openfiles</code></dt><dd><p>C’est le nombre maximal de fichiers qu’un processus peut avoir ouvert. Sous FreeBSD, des fichiers sont également employés pour représenter les sockets et les canaux IPC, par conséquent faites attention à ne fixer une valeur trop basse. La limite générale du système pour cela est définie par la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>kern.maxfiles</code>.</p></dd><dt class=hdlist1><code>sbsize</code></dt><dd><p>C’est une limite sur la quantité de mémoire réseau, et donc de "mbufs", qu’un utilisateur peut consommer. Ceci est à l’origine une réponse à une vielle attaque par refus de service en créant de nombreuses sockets, mais peut être généralement employée pour limiter les communications réseau.</p></dd><dt class=hdlist1><code>stacksize</code></dt><dd><p>C’est la taille maximale de la pile d’un processus. Seule, cela n’est pas suffisant pour limiter la quantité de mémoire que peut utiliser un programme, par conséquent, cette limite devra être utilisée en même temps que d’autres limitations.</p></dd></dl></div><div class=paragraph><p>Il y a quelques éléments à se rappeler quand on fixe des limites de ressource. Quelques astuces générales, suggestions, et commentaires divers:</p></div><div class=ulist><ul><li><p>Les processus lancés au démarrage du système par <span class=filename>/etc/rc</span> sont assignés à la classe <code>daemon</code>.</p></li><li><p>Bien que le fichier <span class=filename>/etc/login.conf</span> qui est fourni avec le système est une bonne source de valeurs raisonnables pour la plupart des limites, seul vous, l’administrateur, peut savoir ce qui est approprié à votre système. Fixer une limite trop haute peut laisser la porte ouverte aux abus, alors qu’une limite trop basse peut être un frein à la productivité.</p></li><li><p>Les utilisateurs du système X Window (X11) devraient se voir allouer plus de ressources que les autres utilisateurs. X11 par lui-même utilise beaucoup de ressources, mais il encourage également les utilisateurs à exécuter plus de programmes simultanément.</p></li><li><p>Souvenez-vous que de nombreuses limites ne s’appliquent qu’aux processus individuels, et non pas à l’utilisateur globalement. Par exemple, paramétrer <code>openfiles</code> à 50 signifie que chaque processus que l’utilisateur exécute pourra ouvrir jusqu’à 50 fichiers. Ainsi, la quantité totale de fichiers qu’un utilisateur peut ouvrir est la valeur <code>openfiles</code> multipliée par la valeur <code>maxproc</code>. Ceci s’applique également à la consommation de mémoire.</p></li></ul></div><div class=paragraph><p>Pour de plus amples informations sur les limites et les classes de session et les capacités en général, veuillez consulter les pages de manuel appropriées: <a href="https://man.freebsd.org/cgi/man.cgi?query=cap.mkdb&amp;sektion=1&amp;format=html">cap.mkdb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getrlimit&amp;sektion=2&amp;format=html">getrlimit(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div></div><div class=sect2><h3 id=users-groups>14.8. Groupes<a class=anchor href=#users-groups></a></h3><div class=paragraph><p>Un groupe est simplement une liste d’utilisateurs. Les groupes sont identifiés par leur nom et leur GID (identificateur de groupe). Dans FreeBSD (et la plupart des systèmes UNIX®), les deux éléments que le noyau utilise pour décider si un processus est autorisé à faire quelque chose sont son ID utilisateur et la liste des groupes auxquels il appartient. Différent d’un identificateur utilisateur, un processus est associé à une liste de groupes. Vous pourrez entendre faire références au "group ID" d’un utilisateur ou d’un processus; la plupart du temps on veut parler du premier groupe dans la liste.</p></div><div class=paragraph><p>La table d’équivalence nom de groupe et identificateur de groupe se trouve dans <span class=filename>/etc/group</span>. C’est un fichier texte avec quatre champs délimités par deux points. Le premier champ est le nom du groupe, le second est le mot de passe crypté, le troisième est l’ID du groupe, et le quatrième est une liste de membres séparés par des virgules. Ce fichier peut sans risque être édité à la main (en supposant, bien sûr, que vous ne faites pas d’erreur de syntaxe!). Pour une description complète de le syntaxe, voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div><div class=paragraph><p>Si vous ne voulez pas éditer <span class=filename>/etc/group</span> à la main, vous pouvez utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> pour ajouter et éditer des groupes. Par exemple, pour ajouter un groupe appelé <code>teamtwo</code> et ensuite vérifier qu’il existe bien vous pouvez utiliser:</p></div><div class=exampleblock><div class=title>Exemple 25. Ajouter un groupe en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd teamtwo</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:</code></pre></div></div></div></div><div class=paragraph><p>Le nombre <code>1100</code> ci-dessus est l’identificateur de groupe pour le groupe <code>teamtwo</code>. A cet instant <code>teamtwo</code> n’a aucun membre, et est par conséquent plutôt inutile. Changeons cela en ajoutant <code>jru</code> au groupe <code>teamtwo</code>.</p></div><div class=exampleblock><div class=title>Exemple 26. Ajouter quelqu’un dans un groupe en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -M jru</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru</code></pre></div></div></div></div><div class=paragraph><p>Le paramètre ajouté à l’option <code>-M</code> est une liste, délimitée par des virgules, d’utilisateurs qui sont membres du groupe. Des sections précédentes nous savons que le fichier des mots de passe contient également un groupe pour chaque utilisateur. Le dernier (utilisateur) est automatiquement ajouté à la liste des groupes par le système; l’utilisateur n’apparaîtra pas comme étant membre quand on utilise l’option <code>groupshow</code> avec <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>, mais apparaîtra quand l’information est demandée par l’intermédiaire de <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> ou un outil similaire. En d’autres termes, <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> manipule uniquement le fichier <span class=filename>/etc/group</span>, il n’essaiera jamais de lire des données supplémentaires à partir du fichier <span class=filename>/etc/passwd</span>.</p></div><div class=exampleblock><div class=title>Exemple 27. Utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> pour déterminer l’appartenance à un groupe</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>id </span>jru
<span class=nv>uid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nb>groups</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span>, 1100<span class=o>(</span>teamtwo<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>Comme vous pouvez le voir, <code>jru</code> est membre des groupes <code>jru</code> et <code>teamtwo</code>.</p></div><div class=paragraph><p>Pour plus d’information sur <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>, voir sa page de manuel, et pour d’information sur le format de <span class=filename>/etc/group</span>, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div></div></div></div><div class=sect1><h2 id=security>Chapitre 15. Sécurité<a class=anchor href=#security></a></h2><div class=sectionbody><div class=sect2><h3 id=security-synopsis>15.1. Synopsis<a class=anchor href=#security-synopsis></a></h3><div class=paragraph><p>Ce chapitre sera une introduction aux concepts de base de la sécurité système, à certaines règles empiriques, et à des sujets avancés sous FreeBSD. De nombreux sujets abordés ici peuvent être appliqués à la sécurité système et à l’Internet en général. L’Internet n’est plus un endroit "amical" dans lequel chacun désire être votre gentil voisin. Sécuriser votre système est impératif pour protéger vos données, la propriété intellectuelle, votre temps, et bien plus des mains des "hackers" et équivalents.</p></div><div class=paragraph><p>FreeBSD fournit un ensemble d’utilitaires et de mécanismes pour assurer l’intégrité et la sécurité de votre système et votre réseau.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Les concepts de base de la sécurité système en ce qui concerne FreeBSD.</p></li><li><p>Les différents mécanismes de chiffrement disponibles sous FreeBSD, comme DES et MD5.</p></li><li><p>Comment mettre en place une authentification par mot de passe non réutilisable.</p></li><li><p>Comment configurer l’encapsuleur TCP pour une utilisation avec inetd.</p></li><li><p>Comment configurer KerberosIV sous les versions de FreeBSD antérieures à la 5.0.</p></li><li><p>Comment configurer Kerberos5 sous FreeBSD.</p></li><li><p>Comment configurer IPsec et mettre en place un VPN entre machines FreeBSD et Windows®.</p></li><li><p>Comment configurer et utiliser OpenSSH, la version de SSH implémentée sous FreeBSD.</p></li><li><p>Ce que sont les ACLs et comment les utiliser.</p></li><li><p>Comment employer l’utilitaire Portaudit pour l’audit des logiciels tierce-partie installés à partir du catalogue des logiciels portés.</p></li><li><p>Comment utiliser les avis de sécurité de FreeBSD.</p></li><li><p>Ce qu’est la comptabilité des processus et comment l’activer sous FreeBSD.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les concepts de base de FreeBSD et d’Internet.</p></li></ul></div><div class=paragraph><p>D’autres sujets relatifs à la sécurité sont abordés par ailleurs dans ce Manuel. Par exemple, le contrôle d’accès obligatoire est présenté dans le <a href=./#mac>Mandatory Access Control</a> et les coupe-feux Internet sont développés dans le <a href=./#firewalls>Firewalls</a>.</p></div></div><div class=sect2><h3 id=security-intro>15.2. Introduction<a class=anchor href=#security-intro></a></h3><div class=paragraph><p>La sécurité est un domaine qui débute et se termine au niveau de l’administrateur système. Alors que tous les systèmes multi-utilisateurs UNIX® BSD ont des sécurités inhérentes, la mise en place et la maintenance des mécanismes supplémentaires de sécurité pour conserver des utilisateurs "honnêtes" est probablement une des tâches les plus vastes de l’administrateur système. La sécurité des machines est celle que vous voulez bien mettre en oeuvre, de plus les préoccupations en matière de sécurité sont plus que jamais en concurrence avec les besoins de confort des utilisateurs. Les systèmes UNIX® sont, en général, capables d’exécuter un nombre important de processus simultanément et plusieurs de ces processus fonctionnent en tant que serveur - cela signifiant que des entités extérieures peuvent se connecter et échanger avec ces processus. Comme les mini-ordinateurs et les gros ordinateurs d’hier deviennent aujourd’hui nos ordinateurs de bureau, et comme les ordinateurs sont désormais en réseau et reliés à Internet, la sécurité devient d’autant plus un problème majeur.</p></div><div class=paragraph><p>La sécurité système concerne également la lutte contre les diverses formes d’attaque, y compris les attaques destinées à faire planter, ou à rendre inutilisable le système, mais qui ne cherchent pas à compromettre le compte <code>root</code>. Les problèmes de sécurité peuvent être divisés en plusieurs catégories:</p></div><div class="olist arabic"><ol class=arabic><li><p>Attaques par déni de service.</p></li><li><p>Compte utilisateur compromis.</p></li><li><p>Le compte <code>root</code> compromis par l’intermédiaire de serveurs accessibles.</p></li><li><p>Le compte <code>root</code> compromis par l’intermédiaire de comptes utilisateur.</p></li><li><p>Création d’une "Backdoor" (porte dérobée).</p></li></ol></div><div class=paragraph><p>Une attaque par déni de service ("DoS") est une action qui prive la machine de ressources nécessaires à son bon fonctionnement. Généralement, les attaques par déni de service sont des mécanismes de force brute qui tentent de faire planter ou tout au moins de rendre inutilisable la machine en saturant ses serveurs ou sa pile réseau. Certaines attaques par déni de service peuvent se servir de bogues présents dans la pile réseau pour faire planter une machine avec un seul paquet. Ces problèmes ne peuvent être corrigés que par l’application d’un correctif sur le noyau. On peut souvent remédier aux attaques sur les serveurs en fixant correctement des options pour limiter la charge que provoquent ces serveurs sur le système lors de conditions critiques. Les attaques réseau par force brute sont plus difficiles à traiter. Une attaque par paquets usurpés ("spoofed-packet"), par exemple, est quasi-impossible à arrêter, à moins de déconnecter de l’Internet votre système. Elle peut ne pas être en mesure de stopper votre machine, mais elle peut saturer votre connexion Internet.</p></div><div class=paragraph><p>La compromission d’un compte utilisateur est bien plus fréquente qu’une attaque de type DoS. De nombreux administrateurs utilisent toujours sur leurs machines les versions standards des serveurs telnetd, rlogind, rshd, et ftpd. Par défaut, ces serveurs ne fonctionnent pas avec des connexions chiffrées. Cela aura pour résultat si vous disposez d’un nombre d’utilisateurs conséquent qu’un ou plusieurs de ces utilisateurs ayant l’habitude de se connecter à partir d’une machine distante (ce qui représente la manière la plus courante et la plus pratique pour ouvrir une session sur un système) auront leur mot de passe "sniffé". L’administrateur système méticuleux analysera ses journaux de connexions effectuées à partir de machines distantes à la recherche d’adresses sources suspectes même pour les ouvertures de sessions ayant réussies.</p></div><div class=paragraph><p>Il faut toujours supposer qu’une fois l’attaquant a l’accès à un compte utilisateur, il pourra s’attaquer et avoir accès au compte <code>root</code>. Cependant, la réalité est que dans un système bien sécurisé et surveillé, l’accès à un compte utilisateur ne donne pas nécessairement à l’attaquant l’accès au compte <code>root</code>. Cette distinction est importante car sans accès aux droits de <code>root</code>, l’attaquant ne peut généralement pas dissimuler ses traces et peut, dans le meilleur des cas, ne rien faire d’autre que mettre la pagaille dans les fichiers de l’utilisateur ou faire planter la machine. La compromission de comptes utilisateur est très fréquente parce que les utilisateurs n’ont pas l’habitude de prendre les précautions que prennent les administrateurs système.</p></div><div class=paragraph><p>Les administrateurs doivent garder à l’esprit qu’il existe potentiellement de nombreuses manières d’avoir accès au compte <code>root</code> sur une machine. L’attaquant peut connaître le mot de passe <code>root</code>, l’attaquant peut trouver un bogue dans un serveur tournant avec les droits de <code>root</code> et être en mesure de devenir <code>root</code> par l’intermédiaire d’une connexion réseau à ce serveur, ou l’attaquant peut connaître un bogue dans un programme suid-root qui permet de devenir <code>root</code> une fois qu’il a accédé à un compte utilisateur. Si un attaquant a trouvé un moyen de devenir <code>root</code> sur une machine, il n’aura peut-être pas besoin d’installer une "backdoor" (porte dérobée). De nombreux trous de sécurité <code>root</code> trouvés et fermés à temps demandent un travail considérable à l’attaquant pour effacer ses traces, aussi la plupart des attaquants installe des portes dérobées. Une porte dérobée offre à l’attaquant un moyen aisé d’avoir à nouveau accès aux droits de <code>root</code> sur le système, mais cela donne également à l’administrateur système intelligent un bon moyen de détecter l’intrusion. Rendre impossible à un attaquant l’installation d’une porte dérobée peut en fait être préjudiciable à votre sécurité, parce que cela ne fermera pas le trou qu’a découvert en premier lieu l’attaquant pour pénétrer sur le système.</p></div><div class=paragraph><p>Les solutions aux problèmes de sécurité devraient toujours être mises en place suivant l’approche multi-couches de "la pelure d’oignon", elles peuvent être classées comme suit:</p></div><div class="olist arabic"><ol class=arabic><li><p>Sécuriser les comptes <code>root</code> et d’administration.</p></li><li><p>Sécuriser les serveurs exécutés avec les droits de <code>root</code> et les binaires suid/sgid.</p></li><li><p>Sécuriser les comptes utilisateurs.</p></li><li><p>Sécuriser le fichier des mots de passe.</p></li><li><p>Sécuriser le noyau, les périphériques et les systèmes de fichiers.</p></li><li><p>Installer un mécanisme de détection rapide des modifications inappropriées apportées au système.</p></li><li><p>La paranoïa.</p></li></ol></div><div class=paragraph><p>La section suivante de ce chapitre abordera de manière plus approfondie les points énoncés ci-dessus.</p></div></div><div class=sect2><h3 id=securing-freebsd>15.3. Securing FreeBSD <strong>Traduction en Cours </strong><a class=anchor href=#securing-freebsd></a></h3></div><div class=sect2><h3 id=crypt>15.4. DES, MD5, et chiffrement<a class=anchor href=#crypt></a></h3><div class=paragraph><p>Chaque utilisateur d’un système UNIX® possède un mot de passe associé à son compte. Il semble évident que ces mots de passe ne doivent être connus que de l’utilisateur et du système d’exploitation. Afin de conserver ces mots de passe secrets, ils sont chiffrés avec ce que l’on appelle un "hachage irréversible", ce qui signifie que le mot de passe peut être aisément chiffré mais pas déchiffré. En d’autres mots, ce que nous vous disions précédemment n’est même pas vrai: le système d’exploitation lui-même ne connaît pas <em>vraiment</em> le mot de passe. Il ne connaît que la forme <em>chiffrée</em> du mot de passe. La seule manière d’obtenir le mot de passe en <em>clair</em> est d’effectuer une recherche par force brute de tous les mots de passe possibles.</p></div><div class=paragraph><p>Malheureusement, la seule méthode sécurisée pour chiffrer les mots de passe quand UNIX® a vu le jour était basée sur DES, le "Data Encryption Standard" (standard de chiffrement des données). C’était un problème mineur pour les utilisateurs résidants aux Etats-Unis, mais puisque le code source de DES ne pouvait être exporté en dehors des Etats-Unis, FreeBSD dû trouver un moyen de respecter la législation américaine et de rester compatible avec les autres systèmes UNIX® qui utilisaient encore DES.</p></div><div class=paragraph><p>La solution fut de séparer les bibliothèques de chiffrement de façon à ce que les utilisateurs américains puissent installer les bibliothèques DES et utiliser DES, mais que les utilisateurs internationaux disposent d’une méthode de chiffrement non restreinte à l’exportation. C’est comment FreeBSD est venu à utiliser MD5 comme méthode de chiffrement par défaut. MD5 est reconnu comme étant plus sure que DES, l’installation de DES est proposée principalement pour des raisons de compatibilité.</p></div><div class=sect3><h4 id=_identifier_votre_mécanisme_de_chiffrement>15.4.1. Identifier votre mécanisme de chiffrement<a class=anchor href=#_identifier_votre_mécanisme_de_chiffrement></a></h4><div class=paragraph><p>Avant FreeBSD 4.4 <span class=filename>libcrypt.a</span> était un lien symbolique pointant sur la bibliothèque utilisée pour le chiffrement. FreeBSD 4.4 modifia <span class=filename>libcrypt.a</span> pour fournir une bibliothèque de hachage pour l’authentification des mots de passe configurable. Actuellement la bibliothèque supporte les fonctions de hachage DES, MD5 et Blowfish. Par défaut FreeBSD utilise MD5 pour chiffrer les mots de passe.</p></div><div class=paragraph><p>Il est relativement facile d’identifier quelle méthode de chiffrement FreeBSD utilise. Examiner les mots de passe chiffrés dans le fichier <span class=filename>/etc/master.passwd</span> est une méthode. Les mots de passe MD5 sont plus longs que les mots de passe DES, et commencent par les caractères <code>$1$</code>. Les mots de passe débutant par <code>$2$</code> sont chiffrés suivant la méthode Blowfish. Les mots de passe DES n’ont pas de caractéristique particulière, mais sont plus courts que les mots de passe MD5 et utilisent un alphabet de 64 caractères qui ne contient pas le caractère <code>$</code>, aussi une chaîne relativement courte qui ne commence pas par un dollar a donc de très fortes chances d’être un mot de passe DES.</p></div><div class=paragraph><p>Le format utilisé par les nouveaux mots de passe est contrôlé par la capacité de classe de session <code>passwd_format</code> dans <span class=filename>/etc/login.conf</span>, qui prend comme valeur <code>des</code>, <code>md5</code> ou <code>blf</code>. Voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> pour plus d’information sur les capacités de classe de session.</p></div></div></div><div class=sect2><h3 id=one-time-passwords>15.5. Mots de passe non réutilisables<a class=anchor href=#one-time-passwords></a></h3><div class=paragraph><p>S/Key est un système de mots de passe non réutilisables basé sur une fonction de hachage irréversible. FreeBSD utilise le hachage MD4 pour des raisons de compatibilité mais d’autres système utilisent MD5 et DES-MAC. S/Key fait partie du système de base de FreeBSD depuis la version 1.1.5 et est aussi utilisé sur un nombre toujours plus important d’autres systèmes d’exploitation. S/Key est une marque déposée de Bell Communications Research, Inc.</p></div><div class=paragraph><p>Depuis la version 5.0 de FreeBSD, S/Key a été remplacé par la fonction équivalente OPIE ("One-time Passwords In Everything" - Mots de passe non réutilisables dans toutes les applications). OPIE utilise le hachage MD5 par défaut.</p></div><div class=paragraph><p>Il existe trois types de mots de passe dont nous parlerons dans ce qui suit. Le premier est votre mot de passe UNIX® habituel ou mot de passe Kerberos; nous appellerons "mot de passe UNIX®". Le deuxième type est le mot de passe généré par les programmes S/Key <code>key</code> ou OPIE <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> et reconnu par les programmes <code>keyinit</code> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> et l’invite de session; nous appellerons ceci un "mot de passe non réutilisable". Le dernier type de mot de passe est le mot de passe secret que vous donnez aux programmes <code>key</code>/<code>opiekey</code> (et parfois aux programmes <code>keyinit</code>/<code>opiepasswd</code>) qui l’utilisent pour générer des mots de passe non réutilisable; nous l’appellerons "mot de passe secret" ou tout simplement "mot de passe".</p></div><div class=paragraph><p>Le mot de passe secret n’a rien à voir avec votre mot de passe UNIX®; ils peuvent être identique, mais c’est déconseillé. Les mots de passe secret S/Key et OPIE ne sont pas limités à 8 caractères comme les anciens mots de passe UNIX®, ils peuvent avoir la longueur que vous désirez. Des mots de passe de six ou sept mots de long sont relativement communs. La plupart du temps, le système S/Key ou OPIE fonctionne de façon complètement indépendante du système de mot de passe UNIX®.</p></div><div class=paragraph><p>En plus du mot de passe, deux autres types de données sont importantes pour S/Key et OPIE. L’une d’elles est connue sous le nom de "germe" ("seed") ou "clé", formé de deux lettres et cinq chiffres. L’autre est ce que l’on appelle le "compteur d’itérations", un nombre compris entre 1 et 100. S/Key génère un mot de passe non réutilisable en concaténant le germe et le mot de passe secret, puis en appliquant la fonction de hachage MD4/MD5 autant de fois qu’indiqué par le compteur d’itérations, et en convertissant le résultat en six courts mots anglais. Ces six mots anglais constituent votre mot de passe non réutilisable. Le système d’authentification (principalement PAM) conserve une trace du dernier mot de passe non réutilisable utilisé, et l’utilisateur est authentifié si la valeur de hachage du mot de passe fourni par l’utilisateur est la même que celle du mot de passe précédent. Comme le hachage utilisé est irréversible, il est impossible de générer de mot de passe non réutilisable si on a surpris un de ceux qui a été utilisé avec succès; le compteur d’itérations est décrémenté après chaque ouverture de session réussie, de sorte que l’utilisateur et le programme d’ouverture de session restent en phase. Quand le compteur d’itération passe à 1, S/Key et OPIE doivent être réinitialisés.</p></div><div class=paragraph><p>Il y a trois programmes impliqués dans chacun des systèmes que nous aborderons plus bas. Les programmes <code>key</code> et <code>opiekey</code> ont pour paramètres un compteur d’itérations, un germe, et un mot de passe secret, et génère un mot de passe non réutilisable ou une liste de mots de passe non réutilisable. Les programmes <code>keyinit</code> et <code>opiepasswd</code> sont utilisés pour initialiser respectivement S/Key et OPIE, et pour modifier les mots de passe, les compteurs d’itérations, ou les germes; ils prennent pour paramètres soit un mot de passe secret, soit un compteur d’itérations, soit un germe, et un mot de passe non réutilisable. Le programme <code>keyinfo</code> ou <code>opieinfo</code> consulte le fichier d’identification correspondant (<span class=filename>/etc/skeykeys</span> ou <span class=filename>/etc/opiekeys</span>) et imprime la valeur du compteur d’itérations et le germe de l’utilisateur qui l’a invoqué.</p></div><div class=paragraph><p>Nous décrirons quatre sortes d’opérations. La première est l’utilisation du programme <code>keyinit</code> ou <code>opiepasswd</code> sur une connexion sécurisée pour initialiser les mots de passe non réutilisables pour la première fois, ou pour modifier votre mot de passe ou votre germe. La seconde opération est l’emploi des programmes <code>keyinit</code> ou <code>opiepasswd</code> sur une connexion non sécurisée, en conjonction avec <code>key</code> ou <code>opiekey</code> sur une connexion sécurisée, pour faire la même chose. La troisième est l’utilisation de <code>key</code>/<code>opiekey</code> pour ouvrir une session sur une connexion non sécurisée. La quatrième est l’emploi de <code>key</code> ou <code>opiekey</code> pour générer un certain nombre de clés qui peuvent être notées ou imprimées et emportées avec vous quand vous allez quelque part ou il n’y a aucune connexion sécurisée.</p></div><div class=sect3><h4 id=_initialisation_depuis_une_connexion_sécurisée>15.5.1. Initialisation depuis une connexion sécurisée<a class=anchor href=#_initialisation_depuis_une_connexion_sécurisée></a></h4><div class=paragraph><p>Pour initialiser S/Key pour la première fois, changer votre mot de passe, ou changer votre germe quand vous êtes attaché sous votre compte par l’intermédiaire d’une connexion sécurisée (e.g., sur la console d’une machine ou via ssh), utilisez la commande <code>keyinit</code> sans paramètres:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% keyinit
Adding unfurl:
Reminder - Only use this method <span class=k>if </span>you are directly connected.
If you are using telnet or rlogin <span class=nb>exit </span>with no password and use keyinit <span class=nt>-s</span><span class=nb>.</span>
Enter secret password:
Again secret password:

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</code></pre></div></div><div class=paragraph><p>Pour OPIE, <code>opiepasswd</code> est utilisé à la place:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>A l’invite <code>Enter new secret pass phrase:</code> ou <code>Enter secret password:</code>, vous devez entrer un mot de passe ou une phrase. Rappelez-vous que ce n’est pas le mot de passe que vous utiliserez pour ouvrir une session, mais celui utilisé pour générer vos clés non réutilisables. La ligne commençant par "ID" liste les paramètres de votre instance: votre nom d’utilisateur, la valeur de votre compteur d’itérations et votre germe. Quand vous ouvrirez une session, le système aura mémorisé ces paramètres et vous les redonnera, vous n’avez donc pas besoin de les retenir. La dernière ligne donne le mot de passe non réutilisable correspondant à ces paramètres et à votre mot de passe secret; si vous devez vous reconnectez immédiatement, c’est ce mot de passe que vous utiliseriez.</p></div></div><div class=sect3><h4 id=_initialisation_depuis_une_connexion_non_sécurisée>15.5.2. Initialisation depuis une connexion non sécurisée<a class=anchor href=#_initialisation_depuis_une_connexion_non_sécurisée></a></h4><div class=paragraph><p>Pour initialiser ou changer votre mot de passe secret par l’intermédiaire d’une connexion non sécurisée, il faudra avoir déjà une connexion sécurisée sur une machine où vous pouvez exécuter <code>key</code> ou <code>opiekey</code>; ce peut être depuis une icone sur le bureau d’un Macintosh ou depuis la ligne de commande d’une machine sûre. Il vous faudra également donner une valeur au compteur d’itération (100 est probablement une bonne valeur), et indiquer un germe ou utiliser la valeur aléatoire générée par le programme. Sur la connexion non sécurisée (vers la machine que vous initialisez), employez la commande <code>keyinit -s</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% keyinit <span class=nt>-s</span>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: 100
Enter new key <span class=o>[</span>default to17759]:
s/key 100 to 17759
s/key access password:
s/key access password:CURE MIKE BANE HIM RACY GORE</code></pre></div></div><div class=paragraph><p>Pour OPIE, vous devez utiliser <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>Pour accepter le germe par défaut (que le programme <code>keyinit</code> appelle <code>key</code>, ce qui prête à confusion), appuyez sur <kbd>Entrée</kbd>. Ensuite avant d’entrer un mot de passe d’accès, passez sur votre connexion sécurisée et donnez lui les mêmes paramètres:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key 100 to17759
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password: &lt;secret password&gt;
CURE MIKE BANE HIM RACY GORE</code></pre></div></div><div class=paragraph><p>Ou pour OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Retournez maintenant sur votre connexion non sécurisée, et copiez le mot de passe non réutilisable généré par le programme adapté.</p></div></div><div class=sect3><h4 id=_générer_un_unique_mot_de_passe_non_réutilisable>15.5.3. Générer un unique mot de passe non réutilisable<a class=anchor href=#_générer_un_unique_mot_de_passe_non_réutilisable></a></h4><div class=paragraph><p>Une fois que vous avez initialisé S/Key ou OPIE, lorsque que vous ouvrez une session, une invite de ce type apparaîtra:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
s/key 97 fw13894
Password:</code></pre></div></div><div class=paragraph><p>Ou pour OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>Les invites S/Key et OPIE disposent d’une fonction utile (qui n’est pas illustrée ici): si vous appuyez sur la touche <kbd>Entrée</kbd> lorsque l’on vous demande votre mot de passe, le programme active l’écho au terminal, de sorte que vous voyez ce que vous êtes en train de taper. Ceci est très utile si vous essayez de taper un mot de passe à la main, à partir d’un résultat imprimé par exemple.</p></div><div class=paragraph><p>A ce moment vous devez générer votre mot de passe non réutilisable pour répondre à cette invite de session. Cela doit être effectué sur une machine de confiance sur laquelle vous pouvez exécuter <code>key</code> ou <code>opiekey</code> (il y a des versions de ces programmes pour DOS, Windows et MacOS). Ces programmes ont besoin du compteur d’itérations et du germe comme paramètres. Vous pouvez les copier-coller de l’invite de session de la machine sur laquelle vous voulez ouvrir une session.</p></div><div class=paragraph><p>Sur le système sûr:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key 97 fw13894
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password:
WELD LIP ACTS ENDS ME HAAG</code></pre></div></div><div class=paragraph><p>Pour OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Maintenant que vous disposez de votre mot de passe non réutilisable vous pouvez continuer et vous connecter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login: &lt;username&gt;
s/key 97 fw13894
Password: &lt;<span class=k>return </span>to <span class=nb>enable echo</span><span class=o>&gt;</span>
s/key 97 fw13894
Password <span class=o>[</span><span class=nb>echo </span>on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ...</code></pre></div></div></div><div class=sect3><h4 id=_générer_de_multiples_mots_de_passe_non_réutilisables>15.5.4. Générer de multiples mots de passe non réutilisables<a class=anchor href=#_générer_de_multiples_mots_de_passe_non_réutilisables></a></h4><div class=paragraph><p>Il faut parfois se rendre en des endroits où vous n’avez pas accès à une machine de confiance ou à une connexion sécurisée. Dans ce cas, vous pouvez utiliser la commande <code>key</code> ou <code>opiekey</code> pour générer plusieurs mots de passe non réutilisables que vous pouvez imprimer et transporter avec vous. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key <span class=nt>-n</span> 5 30 zz99999
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password: &lt;secret password&gt;
26: SODA RUDE LEA LIND BUDD SILT
27: JILT SPY DUTY GLOW COWL ROT
28: THEM OW COLA RUNT BONG SCOT
29: COT MASH BARR BRIM NAN FLAG
30: CAN KNEE CAST NAME FOLK BILK</code></pre></div></div><div class=paragraph><p>Ou pour OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</span></code></pre></div></div><div class=paragraph><p>L’option <code>-n 5</code> demande cinq clés en séquence, l’option <code>30</code> indique quel doit être le rang de la dernière itération. Notez que les clés sont imprimées dans l’ordre <em>inverse</em> de celui où elles seront éventuellement utilisées. Si vous êtes vraiment paranoïaque, vous pouvez les recopier à la main, sinon vous pouvez les copier-coller vers la commande <code>lpr</code>. Remarquez que chaque ligne liste le compteur d’itération et le mot de passe non réutilisable; vous trouverez peut-être utile de rayer les mots de passe au fur et à mesure de leur utilisation.</p></div></div><div class=sect3><h4 id=_restreindre_lutilisation_des_mots_de_passe_unix>15.5.5. Restreindre l’utilisation des mots de passe UNIX®<a class=anchor href=#_restreindre_lutilisation_des_mots_de_passe_unix></a></h4><div class=paragraph><p>S/Key peut placer des restrictions sur l’utilisation des mots de passe UNIX® en fonction des noms de machine, d’utilisateur, de la ligne utilisée par le terminal ou de l’adresse IP de la machine connectée à distance. Ces restrictions peuvent être trouvées dans le fichier de configuration <span class=filename>/etc/skey.access</span>. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=skey.access&amp;sektion=5&amp;format=html">skey.access(5)</a> donne de plus amples informations sur le format de ce fichier et elle détaille également certains avertissements relatifs à la sécurité qu’il faut lire avant de se fier à ce fichier pour sa sécurité.</p></div><div class=paragraph><p>S’il n’y a pas de fichier <span class=filename>/etc/skey.access</span> (ce qui est le cas par défaut sur les systèmes FreeBSD 4.X), tous les utilisateurs pourront se servir de mots de passe UNIX®. Si le fichier existe, alors tous les utilisateurs devront passer par S/Key, à moins qu’ils ne soient explicitement autorisés à ne pas le faire par des instructions du fichier <span class=filename>/etc/skey.access</span>. Dans tous les cas l’usage des mots de passe UNIX® est autorisé sur la console.</p></div><div class=paragraph><p>Voici un exemple de configuration du fichier <span class=filename>skey.access</span> qui illustre les trois types d’instructions les plus courantes:</p></div><div class="literalblock programlisting"><div class=content><pre>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</pre></div></div><div class=paragraph><p>La première ligne (<code>permit internet</code>) autorise les utilisateurs dont l’adresse IP (ce qui rend vulnérable en cas d’usurpation) appartient au sous-réseau spécifié à employer les mots de passe UNIX®. Cela ne doit pas être considéré comme une mesure de sécurité, mais plutôt comme un moyen de rappeler aux utilisateurs autorisés qu’ils sont sur un réseau non sécurisé et doivent utiliser S/Key pour s’authentifier.</p></div><div class=paragraph><p>La seconde ligne (<code>permit user</code>) autorise l’utilisateur désigné, dans notre cas <code>fnord</code>, à employer n’importe quand les mots de passe UNIX®. En général, il faut se servir de cette possibilité si les personnes soit n’ont pas moyen d’utiliser le programme <code>key</code>, s’ils ont par exemple des terminaux passifs, soit s’ils sont définitivement réfractaires au système.</p></div><div class=paragraph><p>La troisième ligne (<code>permit port</code>) autorise tous les utilisateurs d’un terminal sur une liaison particulière à utiliser les mots de passe UNIX®; cela devrait être employé pour les connexions téléphoniques.</p></div><div class=paragraph><p>OPIE peut restreindre l’usage des mots de passe UNIX® sur la base de l’adresse IP lors de l’ouverture d’une session comme peut le faire S/Key. Le fichier impliqué est <span class=filename>/etc/opieaccess</span>, qui est présent par défaut sous FreeBSD 5.0 et versions suivantes. Veuillez consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> pour plus d’information sur ce fichier et certaines considérations sur la sécurité dont vous devez être au courant en l’utilisant.</p></div><div class=paragraph><p>Voici un exemple de fichier <span class=filename>opieaccess</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>Cette ligne autorise les utilisateurs dont l’adresse IP (ce qui rend vulnérable en cas d’usurpation) appartient au sous-réseau spécifié à employer les mots de passe UNIX® à tout moment.</p></div><div class=paragraph><p>Si aucune règle du fichier <span class=filename>opieaccess</span> ne correspond, le comportement par défaut est de refuser toute ouverture de session non-OPIE.</p></div></div></div><div class=sect2><h3 id=tcpwrappers>15.6. L’encapsuleur TCP ("TCP Wrappers")<a class=anchor href=#tcpwrappers></a></h3><div class=paragraph><p>Toute personne familière avec <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> a probablement entendu parlé à un moment ou à un autre de l’encapsuleur TCP ("TCP Wrappers"). Mais peu sont ceux qui semblent saisir complètement son intérêt dans un réseau. Il semble que tout le monde désire installer un coupe-feu pour contrôler les connexions réseaux. Alors qu’un coupe-feu peut avoir de nombreuses utilisations, il existe des choses qu’un coupe-feu ne peut gérer comme renvoyer un message à l’initiateur d’une connexion. L’encapsuleur TCP en est capable ainsi que bien d’autres choses. Dans les sections suivantes plusieurs fonctionnalités de l’encapsuleur TCP seront abordées, et, dès que ce sera possible, un exemple de configuration sera proposé.</p></div><div class=paragraph><p>L’encapsuleur TCP étend les capacités d’inetd au niveau du support pour chaque serveur sous son contrôle. En utilisant cette méthode il est possible d’offrir le support des ouvertures de session, de retourner des messages lors des connexions, de permettre à un "daemon" de n’accepter que les connexions internes, etc. Bien que certaines de ces fonctionnalités peuvent être obtenues par l’implémentation d’un coupe-feu, ce système ajoutera non seulement une couche supplémentaire de protection mais ira plus loin dans le contrôle que ce que peut fournir un coupe-feu.</p></div><div class=paragraph><p>Les fonctionnalités apportées par l’encapsuleur TCP ne peuvent se substituer à l’utilisation d’un bon coupe-feu. L’encapsuleur TCP peut être utilisé de paire avec un coupe-feu ou tout autre système de sécurité et il pourra alors servir comme une couche supplémentaire de protection pour le système.</p></div><div class=paragraph><p>Etant donné que ce programme est une extension à la configuration du programme inetd, le lecteur est supposé avoir pris connaissance de la section de <a href=./#network-inetd>configuration d’inetd</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bien que les programmes lancés par <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> ne soient pas tout à fait des "daemons", ils sont traditionnellement appelés "daemons". C’est le terme que nous utiliserons également dans le reste de cette section.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_configuration_initiale>15.6.1. Configuration initiale<a class=anchor href=#_configuration_initiale></a></h4><div class=paragraph><p>Le seul pré-requis à l’utilisation de l’encapsuleur TCP sous FreeBSD est de s’assurer que le serveur inetd est lancé à partir de <span class=filename>rc.conf</span> avec l’option <code>-Ww</code>; c’est la configuration par défaut. Bien évidemment une configuration correcte du fichier <span class=filename>/etc/hosts.allow</span> est également sous-entendue, mais dans le cas contraire <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> émettra des messages d’avertissement dans les journaux du système.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Contrairement à d’autres implémentations de l’encapsuleur TCP, l’emploi du fichier <span class=filename>hosts.deny</span> est obsolète. Toutes les options de configuration doivent être placées dans le fichier <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dans la configuration la plus simple, la politique de connexion aux "daemons" est soit de tout autoriser ou soit de tout bloquer en fonctions des options choisies dans <span class=filename>/etc/hosts.allow</span>. La configuration par défaut sous FreeBSD est d’autoriser les connexions à chaque "daemon" lancé à l’aide d’inetd. La modification de ce réglage par défaut sera discutée une fois que la configuration de base aura été vue.</p></div><div class=paragraph><p>Une configuration de base prend en général la forme <code>daemon : adresse : action</code>. Où <code>daemon</code> est le nom du "daemon" lancé par inetd. L'<code>adresse</code> peut être un nom de machine valide, une adresse IP ou une adresse IPv6 entre crochets ([ ]). Le champ <code>action</code> pourra avoir comme valeur <code>allow</code> ou <code>deny</code> pour autoriser ou interdire l’accès. Gardez à l’esprit que ce type de configuration fonctionne de manière à honorer la première règle sémantique correspondante, cela signifie que le fichier de configuration est parcouru à la recherche d’une règle correspondant à la requête. Quand une correspondance est trouvée, la règle est appliquée et la recherche s’arrête.</p></div><div class=paragraph><p>Plusieurs autres options existent mais elles seront exposées dans une section ultérieure. Une simple ligne de configuration peut être construite avec peu d’information. Par exemple, pour autoriser les connexions POP3 via le "daemon"<a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, les lignes suivantes doivent être ajoutées au fichier <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>Après l’ajout de cette ligne, inetd devra être redémarré. Cela sera fait en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a>, ou avec le passage du paramètre <span class=parameter>restart</span> à la commande <span class=filename>/etc/rc.d/inetd</span>.</p></div></div><div class=sect3><h4 id=_configuration_avancée>15.6.2. Configuration avancée<a class=anchor href=#_configuration_avancée></a></h4><div class=paragraph><p>L’encapsuleur TCP dispose également d’options avancées; elles permettrons plus de contrôle sur la manière dont sont gérées les connexions. Dans certains cas cela peut être une bonne idée de renvoyer un commentaire à certaines machines ou lors de connexions à certains "daemon"s. Dans d’autres cas, peut-être qu’un fichier journal pourrait être enregistré ou un courrier électronique pourrait être envoyé à l’administrateur. D’autres situations peuvent nécessiter l’utilisation d’un service uniquement pour les connexions locales. Tout cela est possible à l’aide des options de configuration connues sous le nom de <code>jokers</code>, caractères d’expansion et d’exécution de commandes externes. Les deux sections suivantes abordent ces situations.</p></div><div class=sect4><h5 id=_commandes_externes>15.6.2.1. Commandes externes<a class=anchor href=#_commandes_externes></a></h5><div class=paragraph><p>Imaginez une situation dans laquelle une connexion doit être refusée et que la raison de ce refus doit être envoyée à la personne qui a tenté d’établir cette connexion. Comment cela peut-il être mis en place? Ce type d’action est rendu possible par l’emploi de l’option <code>twist</code>. Quand une tentative de connexion est faite, <code>twist</code> sera appelée pour exécuter une commande ou une procédure d’interpréteur de commande. Un exemple est déjà présent dans le fichier <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>Cet exemple montre que le message "You are not allowed to use <code>daemon</code> from <code>hostname</code>." sera retourné pour tout "daemon" qui n’a pas été précédemment configuré dans le fichier d’accès. Cette fonction est très utile pour envoyer une réponse à l’initiateur de la connexion juste après le refus de la connexion. Notez que tout message à retourner <em>doit</em> être placé entre des guillemets <code>"</code>; il n’y a pas d’exception possible à cette règle.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Il est possible de lancer une attaque par déni de service sur le serveur si un agresseur, ou un groupe d’agresseurs sont en mesure de submerger ces "daemon"s avec des demandes de connexion.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Une autre possibilité dans ce cas est d’employer l’option <code>spawn</code>. Tout comme l’option <code>twist</code>, <code>spawn</code> interdit implicitement les connexions et peut être utilisée pour lancer une commande ou une procédure externe. Contrairement à <code>twist</code>, <code>spawn</code> n’enverra pas de réponse à la personne qui a établi la connexion. Examinons par exemple la ligne de configuration suivante:</p></div><div class="literalblock programlisting"><div class=content><pre># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d  \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>Cela interdira toute tentative de connexion à partir du domaine <code>*.example.com</code>, enregistrant simultanément dans le fichier <span class=filename>/var/log/connections.log</span> le nom de machine, l’adresse IP et le "daemon" auquel on tente d’accéder.</p></div><div class=paragraph><p>Il existe d’autres caractères de substitution en dehors de ceux déjà présentés, par exemple <code>%a</code>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> pour une liste complète.</p></div></div><div class=sect4><h5 id=_les_options_jokers>15.6.2.2. Les options jokers<a class=anchor href=#_les_options_jokers></a></h5><div class=paragraph><p>Jusqu’ici l’option <code>ALL</code> a été utilisée dans tous les exemples. Il existe d’autres options pour étendre un peu plus les fonctionnalités. Par exemple, l’option <code>ALL</code> peut être utilisée pour prendre en compte chaque instance d’un "daemon", d’un domaine ou d’une adresse IP. Un autre joker disponible est l’option <code>PARANOID</code> qui peut être employée pour prendre en compte toute machine qui fournirait une adresse IP susceptible d’être falsifiée. En d’autres termes, l’option <code>PARANOID</code> peut être utilisée pour définir l’action a effectuer dès qu’une connexion se fait à partir d’une adresse IP qui diffère de celle attachée à une machine. L’exemple suivant apporte un éclairage sur cette option:</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class=paragraph><p>Dans cet exemple, toutes les requêtes de connexion à sendmail à partir d’adresses IP différentes de celle correspondant au nom de la machine seront refusées.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Utiliser l’option <code>PARANOID</code> peut gravement paralyser les serveurs si le client ou le serveur a une configuration de DNS défectueuse. Les administrateurs sont maintenant prévenus.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour en apprendre plus sur les jokers et leurs fonctionnalités associées, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>.</p></div><div class=paragraph><p>Avant que n’importe quelle des lignes de configuration données ci-dessus ne fonctionne, la première ligne de configuration du fichier <span class=filename>hosts.allow</span> devra être dé-commentée. Cela a été noté en début de section.</p></div></div></div></div><div class=sect2><h3 id=kerberosIV>15.7. Kerberos<a class=anchor href=#kerberosIV></a></h3><div class=paragraph><p>Kerberos est un protocole réseau supplémentaire qui permet aux utilisateurs de s’authentifier par l’intermédiaire d’un serveur sécurisé. Des services comme l’ouverture de session et la copie à distance, la copie sécurisée de fichiers entre systèmes et autres fonctionnalités à haut risque deviennent ainsi considérablement plus sûrs et contrôlables.</p></div><div class=paragraph><p>Les instructions qui suivent peuvent être utilisées comme guide d’installation de Kerberos dans la version distribuée pour FreeBSD. Vous devriez cependant vous référer aux pages de manuel correspondantes pour avoir une description complète.</p></div><div class=sect3><h4 id=_installation_de_kerberos>15.7.1. Installation de Kerberos<a class=anchor href=#_installation_de_kerberos></a></h4><div class=paragraph><p>Kerberos est un composant optionnel de FreeBSD. La manière la plus simple d’installer ce logiciel est de sélectionner la distribution <code>krb4</code> ou <code>krb5</code> dans sysinstall lors de l’installation de FreeBSD. Cela installera les implémentations "eBones" (KerberosIV) ou "Heimdal" (Kerberos5) de Kerberos. Ces implémentations sont distribuées car elles sont développées en dehors des USA ou du Canada et étaient par conséquent disponibles aux utilisateurs hors de ces pays durant l’ère restrictive du contrôle des exportations de code de chiffrement à partir des USA.</p></div><div class=paragraph><p>Alternativement, l’implémentation du MIT de Kerberos est disponible dans le catalogue des logiciels portés sous <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>.</p></div></div><div class=sect3><h4 id=_créer_la_base_de_données_initiale>15.7.2. Créer la base de données initiale<a class=anchor href=#_créer_la_base_de_données_initiale></a></h4><div class=paragraph><p>Cela se fait uniquement sur le serveur Kerberos. Vérifiez tout d’abord qu’il ne traîne pas d’anciennes bases Kerberos. Allez dans le répertoire <span class=filename>/etc/kerberosIV</span> et assurez-vous qu’il ne contient que les fichiers suivants:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/kerberosIV</span>
<span class=c># ls</span>
README		krb.conf        krb.realms</code></pre></div></div><div class=paragraph><p>S’il y a d’autres fichiers (comme <span class=filename>principal.*</span> ou <span class=filename>master_key</span>), utilisez alors la commande <code>kdb_destroy</code> pour supprimer l’ancienne base de données Kerberos, ou si Kerberos ne tourne pas, effacez simplement les fichiers supplémentaires.</p></div><div class=paragraph><p>Vous devez maintenant éditer les fichiers <span class=filename>krb.conf</span> et <span class=filename>krb.realms</span> pour définir votre domaine Kerberos. Dans notre cas, le domaine sera <code>EXAMPLE.COM</code> et le serveur <code>grunt.example.com</code>. Nous éditons ou créons le fichier <span class=filename>krb.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.conf</span>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</code></pre></div></div><div class=paragraph><p>Dans notre cas les autres domaines n’ont pas besoin d’être mentionnés. Ils ne sont là que pour montrer comment une machine peut avoir connaissance de plusieurs domaines. Pour plus de simplicité, vous pouvez ne pas les inclure.</p></div><div class=paragraph><p>La première ligne indique pour quel domaine cette machine agit. Les autre lignes définissent les autres domaines/machines. Le premier élément sur une ligne est le domaine, le second le nom de la machine qui est le "centre de distribution de clés" de ce domaine. Les mots <code>admin server</code> qui suivent un nom de machine signifient que la machine est aussi serveur d’administration de la base de données. Pour plus d’explication sur cette terminologie, consultez les pages de manuel de Kerberos.</p></div><div class=paragraph><p>Nous devons maintenant ajouter <code>grunt.example.com</code> au domaine <code>EXAMPLE.COM</code> et ajouter une entrée pour mettre toutes les machines du domaine DNS <code>.example.com</code> dans le domaine Kerberos <code>EXAMPLE.COM</code>. Le fichier <span class=filename>krb.realms</span> aura alors l’allure suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.realms</span>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</code></pre></div></div><div class=paragraph><p>Encore une fois, les autres domaines n’ont pas besoin d’être mentionnés. Ils ne sont là que pour montrer comment une machine peut avoir connaissance de plusieurs domaines. Pour plus de simplicité, vous pouvez ne pas les inclure.</p></div><div class=paragraph><p>La première ligne assigne un système <em>particulier</em> au domaine désigné. Les lignes restantes montrent comment affecter par défaut les systèmes d’un sous-domaine DNS particulier à un domaine Kerberos donné.</p></div><div class=paragraph><p>Nous sommes maintenant prêt pour la création de la base de données. Il n’y a à le faire que sur le serveur Kerberos (ou Centre de Distribution de Clés). Cela se fait avec la commande <code>kdb_init</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_init</span>
Realm name <span class=o>[</span>default  ATHENA.MIT.EDU <span class=o>]</span>: EXAMPLE.COM
You will be prompted <span class=k>for </span>the database Master Password.
It is important that you NOT FORGET this password.

Enter Kerberos master key:</code></pre></div></div><div class=paragraph><p>Nous devons maintenant sauvegarder la clé pour que les serveurs sur la machine locale puissent la lire. Utilisons la commande <code>kstash</code> pour faire cela:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!</code></pre></div></div><div class=paragraph><p>Le mot de passe maître chiffré est sauvegardé dans <span class=filename>/etc/kerberosIV/master_key</span>.</p></div></div><div class=sect3><h4 id=_installer_les_services>15.7.3. Installer les services<a class=anchor href=#_installer_les_services></a></h4><div class=paragraph><p>Il faut ajouter deux entrées ("principals") à la base de données pour <em>chaque</em> système qui sera sécurisé par Kerberos. Ce sont <code>kpasswd</code> et <code>rcmd</code>. Ces deux entrées sont définies pour chaque système, chacune de leurs instances se voyant attribuer le nom du système.</p></div><div class=paragraph><p>Ces "daemons", kpasswd et rcmd permettent aux autres systèmes de changer les mots de passe Kerberos et d’exécuter des commandes comme <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>.</p></div><div class=paragraph><p>Ajoutons donc maintenant ces entrées:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: passwd
Instance: grunt

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: passwd, Instance: grunt, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> entrez RANDOM ici
Verifying password

New Password: &lt;<span class=nt>----</span> enter RANDOM here

Random password <span class=o>[</span>y] ? y

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name: rcmd
Instance: grunt

&lt;Not found&gt;, Create [y] ?

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
New Password:		&lt;---- entrez RANDOM ici
Verifying password

New Password:           &lt;---- entrez RANDOM ici

Random password [y] ?

Principal&#39;</span>s new key version <span class=o>=</span> 1
Expiration <span class=nb>date</span> <span class=o>(</span>enter yyyy-mm-dd<span class=o>)</span> <span class=o>[</span> 2000-01-01 <span class=o>]</span> ?
Max ticket lifetime <span class=o>(</span><span class=k>*</span>5 minutes<span class=o>)</span> <span class=o>[</span> 255 <span class=o>]</span> ?
Attributes <span class=o>[</span> 0 <span class=o>]</span> ?
Edit O.K.
Principal name:         &lt;<span class=nt>----</span> ne rien entrer ici permet de quitter le programme</code></pre></div></div></div><div class=sect3><h4 id=_créer_le_fichier_des_services>15.7.4. Créer le fichier des services<a class=anchor href=#_créer_le_fichier_des_services></a></h4><div class=paragraph><p>Il faut maintenant extraire les instances qui définissent les services sur chaque machine. Pour cela on utilise la commande <code>ext_srvtab</code>. Cela créera un fichier qui doit être copié ou déplacé <em>par un moyen sûr</em> dans le répertoire <span class=filename>/etc/kerberosIV</span> de chaque client Kerberos. Ce fichier doit être présent sur chaque serveur et client, et est crucial au bon fonctionnement de Kerberos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ext_srvtab grunt</span>
Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating <span class=s1>&#39;grunt-new-srvtab&#39;</span>....</code></pre></div></div><div class=paragraph><p>Cette commande ne génère qu’un fichier temporaire qui doit être renommé en <span class=filename>srvtab</span> pour que tous les serveurs puissent y accéder. Utilisez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mv&amp;sektion=1&amp;format=html">mv(1)</a> pour l’installer sur le système d’origine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grunt-new-srvtab srvtab</span></code></pre></div></div><div class=paragraph><p>Si le fichier est destiné à un client, et que le réseau n’est pas considéré comme sûr, alors copiez le fichier <span class=filename>client-new-srvtab</span> sur un support amovible et transportez-le par un moyen physiquement sûr. Assurez-vous de le renommer en <span class=filename>srvtab</span> dans le répertoire <span class=filename>/etc/kerberosIV</span> du client, et mettez-le bien en mode 600:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grumble-new-srvtab srvtab</span>
<span class=c># chmod 600 srvtab</span></code></pre></div></div></div><div class=sect3><h4 id=_renseigner_la_base_de_données>15.7.5. Renseigner la base de données<a class=anchor href=#_renseigner_la_base_de_données></a></h4><div class=paragraph><p>Nous devons maintenant créer des entrées utilisateurs dans la base de données. Tout d’abord créons une entrée pour l’utilisateur <code>jane</code>. Utilisez la commande <code>kdb_edit</code> pour cela:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance:

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: , kdc_key_ver: 1
New Password:                &lt;<span class=nt>----</span> entrez un mot de passe sûr ici
Verifying password

New Password:                &lt;<span class=nt>----</span> réentrez le mot de passe sûr là
Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:		   &lt;---- ne rien entrer ici permet de quitter le programme</span></code></pre></div></div></div><div class=sect3><h4 id=_tester_lensemble>15.7.6. Tester l’ensemble<a class=anchor href=#_tester_lensemble></a></h4><div class=paragraph><p>Il faut tout d’abord démarrer les "daemons" Kerberos. Notez que si vous avez correctement modifié votre fichier <span class=filename>/etc/rc.conf</span>, cela se fera automatiquement au redémarrage du système. Ceci n’est nécessaire que sur le serveur Kerberos. Les clients Kerberos récupéreront automatiquement les informations dont ils ont besoin via leur répertoire <span class=filename>/etc/kerberosIV</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kerberos &amp;</span>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
<span class=c># kadmind -n &amp;</span>
KADM Server KADM0.0A initializing
Please <span class=k>do </span>not use <span class=s1>&#39;kill -9&#39;</span> to <span class=nb>kill </span>this job, use a
regular <span class=nb>kill </span>instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</code></pre></div></div><div class=paragraph><p>Nous pouvons maintenant utiliser la commande <code>kinit</code> pour obtenir un "ticket d’entrée" pour l’utilisateur <code>jane</code> que nous avons créé plus haut:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Essayons de lister les informations associées avec la commande <code>klist</code> pour voir si nous avons vraiment tout ce qu’il faut:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Essayons maintenant de modifier le mot de passe en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> pour vérifier si le "daemon" kpasswd est autorisé à accéder à la base de données Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
realm EXAMPLE.COM
Old password <span class=k>for </span>jane:
New Password <span class=k>for </span>jane:
Verifying password
New Password <span class=k>for </span>jane:
Password changed.</code></pre></div></div></div><div class=sect3><h4 id=_autoriser_lutilisation_de_la_commande_su>15.7.7. Autoriser l’utilisation de la commande <code>su</code><a class=anchor href=#_autoriser_lutilisation_de_la_commande_su></a></h4><div class=paragraph><p>Kerberos permet d’attribuer à <em>chaque</em> utilisateur qui a besoin des droits du super-utilisateur son <em>propre</em> mot de passe <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Nous pouvons créer un identifiant qui est autorisé à utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> pour devenir <code>root</code>. Cela se fait en associant une instance <code>root</code> un identificateur ("principal") de base. En utilisant la commande <code>kdb_edit</code> nous pouvons créer l’entrée <code>jane.root</code> dans la base de données Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance: root

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> entrez un mot de passe SUR ici
Verifying password

New Password:    	 	 &lt;<span class=nt>----</span> réentrez le mot de passe ici

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ? 12 &lt;--- Laissez une valeur faible!
Attributes [ 0 ] ?
Edit O.K.
Principal name:		         &lt;---- ne rien entrer ici permet de quitter le programme</span></code></pre></div></div><div class=paragraph><p>Vérifions maintenant les caractéristiques associées pour voir si cela fonctionne:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kinit jane.root</span>
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane.root&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Nous devons maintenant ajouter l’utilisateur au fichier <span class=filename>.klogin</span> de <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Essayons maintenant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:</code></pre></div></div><div class=paragraph><p>et voyons quelles sont nos caractéristiques:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># klist</span>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div></div><div class=sect3><h4 id=_utiliser_dautres_commandes>15.7.8. Utiliser d’autres commandes<a class=anchor href=#_utiliser_dautres_commandes></a></h4><div class=paragraph><p>Dans l’exemple précédent, nous avons créé une entrée principale nommée <code>jane</code> avec une instance <code>root</code>. Cette entrée reposait sur un utilisateur ayant le même nom que l’entrée principale, c’est ce que fait par défaut Kerberos; une <code>entrée_principale.instance</code> de la forme <code>nom_d_utilisateur</code>. <code>root</code> autorisera <code>nom_d_utilisateur.</code> à utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> pour devenir <code>root</code> si le fichier <span class=filename>.klogin</span> du répertoire personnel de l’utilisateur <code>root</code> est correctement renseigné:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>De même, si un utilisateur a dans son répertoire des lignes de la forme:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat</span> ~/.klogin
jane@EXAMPLE.COM
jack@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Cela permet à quiconque dans le domaine <code>EXAMPLE.COM</code> s’étant authentifié en tant que <code>jane</code> ou <code>jack</code> (via <code>kinit</code>, voir plus haut) d’accéder avec <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> au compte de <code>jane</code> ou à ses fichiers sur le système (<code>grunt</code>) via <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>.</p></div><div class=paragraph><p>Par exemple, <code>jane</code> ouvre maintenant une session sur un autre système en utilisant Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
% rlogin grunt
Last login: Mon May  1 21:14:47 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div><div class=paragraph><p>Ou bien <code>jack</code> ouvre une session sur le compte de <code>jane</code> sur la même machine (<code>jane</code> ayant modifié son fichier <span class=filename>.klogin</span> comme décrit plus haut, et la personne an charge de Kerberos ayant défini une entrée principale <em>jack</em> sans instance):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
% rlogin grunt <span class=nt>-l</span> jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
Last login: Mon May  1 21:16:55 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div></div></div><div class=sect2><h3 id=kerberos5>15.8. Kerberos5 <strong>Traduction en Cours </strong><a class=anchor href=#kerberos5></a></h3></div><div class=sect2><h3 id=openssl>15.9. OpenSSL<a class=anchor href=#openssl></a></h3><div class=paragraph><p>Une des caractéristiques que de nombreux utilisateurs ignorent souvent est la présence des outils OpenSSL dans le système FreeBSD. OpenSSL fournit une couche de transport des données chiffrée par-dessus la couche de communication, lui permettant ainsi d’être liée à de nombreux services et applications réseau.</p></div><div class=paragraph><p>Les applications d’OpenSSL pourront être l’authentification chiffrée de clients de messagerie, les transactions via le Web comme les paiements par carte bancaire et bien plus encore. De nombreux logiciels portés tels que <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-ssl/>www/apache13-ssl</a>, et <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a> offriront un support pour OpenSSL lors de leur compilation.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans la plupart des cas le catalogue des logiciels portés tentera de compiler le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> à moins que la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> <code>WITH_OPENSSL_BASE</code> ne soit explicitement fixée à la valeur "yes".</p></div></td></tr></tbody></table></div><div class=paragraph><p>La version d’OpenSSL fournie avec FreeBSD supporte les protocoles de sécurité réseau <em>Secure Sockets Layer v2/v3</em> (SSLv2/SSLv3), et <em>Transport Layer Security v1</em> (TLSv1) et peut être utilisée comme bibliothèque de chiffrement d’usage général.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bien que OpenSSL supporte l’algorithme IDEA, il est désactivé par défaut en raison des problèmes de brevets aux USA. Pour l’utiliser, le texte de la licence devrait être consulté et si les termes de cette licence sont acceptables, la variable <code>MAKE_IDEA</code> doit être activée dans le fichier <span class=filename>make.conf</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Une des utilisations les plus courantes d’OpenSSL est de fournir des certificats utilisables avec des applications logicielles. Ces certificats assurent que les références de la société ou d’un individu sont valides et non frauduleuses. Si le certificat en question n’a pas été vérifié par une des nombreuses "autorité de certification" ("Certificate Authorities") ou CAs, une alerte est généralement produite. Une autorité de certification est une société, comme <a href=http://www.verisign.com>VeriSign</a>, qui signera les certificats afin de valider les références d’individus ou de sociétés. Ce processus a un coût et n’est pas obligatoire pour utiliser des certificats, cependant cela pourra mettre plus à l’aise les utilisateurs les plus paranoïaques.</p></div><div class=sect3><h4 id=_générer_des_certificats>15.9.1. Générer des certificats<a class=anchor href=#_générer_des_certificats></a></h4><div class=paragraph><p>Pour générer un certificat, la commande suivante est disponible:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.pem</span>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to <span class=s1>&#39;cert.pem&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:SOME PASSWORD
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>Notez la réponse à la question "Common Name" qui est un nom de domaine. Cette question demande l’entrée d’un serveur de noms à des fins de vérification; entrer autre chose qu’un nom de domaine produira un certificat inutilisable. D’autres options sont disponibles comme par exemple: la date d’expiration, des algorithmes de chiffrement alternatifs, etc. Une liste complète peut être obtenue en consultant la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a>.</p></div><div class=paragraph><p>Deux fichiers doivent maintenant être présents dans le répertoire dans lequel la commande a été exécutée. La demande de certificat, <span class=filename>req.pem</span>, peut être envoyée à une autorité de certification qui validera les références que vous avez saisies, signera la demande et vous retournera le certificat. Le deuxième fichier s’appellera <span class=filename>cert.pem</span> et sera la clé privée du certificat et devra être à tout prix protégée; si ce fichier tombe dans d’autres mains, il pourra être utilisé pour imiter votre identité (ou votre serveur).</p></div><div class=paragraph><p>Pour les cas où une signature d’une CA n’est pas indispensable, un certificat auto-signé peut être créé. Générez tout d’abord la clé RSA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl dsaparam -rand -genkey -out myRSA.key 1024</span></code></pre></div></div><div class=paragraph><p>Générez ensuite la clé de la CA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl gendsa -des3 -out myca.key myRSA.key</span></code></pre></div></div><div class=paragraph><p>Utilisez cette clé pour créer le certificat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key myca.key -out new.crt</span></code></pre></div></div><div class=paragraph><p>Deux fichiers devraient être présents maintenant dans le répertoire: un fichier de signature de l’autorité de certification, <span class=filename>myca.key</span>, et le certificat lui-même, <span class=filename>new.crt</span>. Ces fichiers doivent être placés dans un répertoire, de préférence sous <span class=filename>/etc</span>, qui est uniquement lisible que par <code>root</code>. Les permissions 0700 devraient convenir et peuvent être fixées à l’aide de l’utilitaire <code>chmod</code>.</p></div></div><div class=sect3><h4 id=_utilisation_des_certificats_un_exemple>15.9.2. Utilisation des certificats, un exemple<a class=anchor href=#_utilisation_des_certificats_un_exemple></a></h4><div class=paragraph><p>A quoi peuvent servir ces fichiers? Un bon exemple serait le chiffrage des connexions au MTAsendmail. Cela permettra de faire disparaître l’utilisation d’une authentification en clair pour les utilisateurs qui envoient du courrier via le MTA local.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ce n’est pas la meilleure utilisation au monde étant donné que certains clients de messagerie afficheront une erreur si le certificat n’a pas été installé localement. Reportez-vous à la documentation du logiciel pour plus d’information sur l’installation de certificats.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Les lignes suivantes doivent être ajoutées dans le fichier <span class=filename>.mc</span> local:</p></div><div class="literalblock programlisting"><div class=content><pre>dnl SSL Options
define(`confCACERT_PATH&#39;,`/etc/certs&#39;)dnl
define(`confCACERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_CERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_KEY&#39;,`/etc/certs/myca.key&#39;)dnl
define(`confTLS_SRV_OPTIONS&#39;, `V&#39;)dnl</pre></div></div><div class=paragraph><p>Où <span class=filename>/etc/certs/</span> est le répertoire à utiliser pour stocker localement les certificats et les clés. La dernière condition nécessaire étant une reconstruction du fichier <span class=filename>.cf</span>. Cela se fait facilement en tapant <code>make</code><span class=parameter>install</span> à l’intérieur du répertoire <span class=filename>/etc/mail</span>. Suivi d’un <code>make</code><span class=parameter>restart</span> qui devrait relancer le "daemon"sendmail.</p></div><div class=paragraph><p>Si tout s’est bien passé il n’y aura pas de message d’erreur dans le fichier <span class=filename>/var/log/maillog</span> et sendmail apparaîtra dans la liste des processus.</p></div><div class=paragraph><p>Comme test simple, connectez vous au serveur de messagerie à l’aide de l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to example.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.12.10/8.12.10<span class=p>;</span> Tue, 31 Aug 2004 03:41:22 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>Si la ligne "STARTTLS" apparaît dans la sortie, cela signifie alors que tout fonctionne correctement.</p></div></div></div><div class=sect2><h3 id=ipsec>15.10. IPsec<a class=anchor href=#ipsec></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Caractères de terminaison</div><div class=paragraph><p>Dans tous les exemples de cette section, et d’autres sections, vous remarquerez qu’il y aura un "^D" à la fin de certains exemples. Cela signifie qu’il faut maintenir la touche <kbd>Ctrl</kbd> enfoncée et appuyer sur la touche <kbd>D</kbd>. Un autre caractère couramment utilisé est "^C", qui signifie de maintenir enfoncé la touche <kbd>Ctrl</kbd> et d’appuyer sur <kbd>C</kbd>.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Pour d’autres documents détaillant l’implémentation d’IPsec, jetez un oeil à <a href=http://www.daemonnews.org/200101/ipsec-howto.html>http://www.daemonnews.org/200101/ipsec-howto.html</a> et <a href=http://www.freebsddiary.org/ipsec.php>http://www.freebsddiary.org/ipsec.php</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le mécanisme IPsec fournit des communications sécurisées sur couche IP ou à travers les <em>sockets</em>. Cette section explique comment l’utiliser. Pour des détails concernant l’implémentation d’IPsec, reportez-vous au <a href=https://docs.freebsd.org/fr/books/developers-handbook/#ipv6>Manuel du développeur</a>.</p></div><div class=paragraph><p>L’implémentation actuelle d’IPsec supporte le mode transport et le mode tunnel. Cependant, il y a des restrictions au mode tunnel. <a href=http://www.kame.net/newsletter/>http://www.kame.net/newsletter/</a> fournit des exemples plus exhaustifs.</p></div><div class=paragraph><p>Soyez informé que pour utiliser cette fonctionnalité, vous devez avoir les options suivantes présentes dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options          IPSEC              #IP security
options          IPSEC_ESP          #IP security (crypto; define w/IPSEC)</pre></div></div><div class=sect3><h4 id=_exemple_en_mode_transport_avec_ipv4>15.10.1. Exemple en mode transport avec IPv4<a class=anchor href=#_exemple_en_mode_transport_avec_ipv4></a></h4><div class=paragraph><p>Configurons une association de sécurité pour déployer un canal sécurisé entre la Machine A (<code>10.2.3.4</code>) et la Machine B (<code>10.6.7.8</code>). Notre exemple est un peu compliqué. De A vers B, nous n’utilisons que l’ancien AH. De B vers A, le nouvel AH et le nouvel ESP sont combinés.</p></div><div class=paragraph><p>Nous devons maintenant choisir les algorithmes correspondant à "AH"/"nouvel AH"/"ESP"/ "nouvel ESP". Reportez-vous à la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> pour connaître les noms des algorithmes. Nous utiliserons MD5 pour AH, new-HMAC-SHA1 pour le nouvel AH, et new-DES-expIV avec 8 octets IV pour le nouvel ESP.</p></div><div class=paragraph><p>La longueur de la clé dépend de chaque algorithme. Par exemple, elle doit être égale à 16 octets pour MD5, 20 pour new-HMAC-SHA1, et 8 pour new-DES-expIV. Nous choisissons maintenant "MYSECRETMYSECRET", "KAMEKAMEKAMEKAMEKAME", "PASSWORD", respectivement.</p></div><div class=paragraph><p>Définissons maintenant le SPI (<em>Security Parameter Index</em>) pour chaque protocole. Remarquez qu’il nous faut 3 SPIs pour ce canal sécurisé puisqu’il y aura trois entêtes de sécurité (une de la Machine A vers la Machine B et deux de la Machine B vers la Machine A). Notez également que les SPIs doivent être supérieurs à 256. Nous choisirions 1000, 2000 et 3000 respectivement.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	          <span class=o>(</span>1<span class=o>)</span>
	Machine A <span class=nt>------</span><span class=o>&gt;</span> Machine B

	<span class=o>(</span>1<span class=o>)</span><span class=nv>PROTO</span><span class=o>=</span>AH
		<span class=nv>ALG</span><span class=o>=</span>MD5<span class=o>(</span>RFC1826<span class=o>)</span>
		<span class=nv>KEY</span><span class=o>=</span>MYSECRETMYSECRET
		<span class=nv>SPI</span><span class=o>=</span>1000

	           <span class=o>(</span>2.1<span class=o>)</span>
	Machine A &lt;<span class=nt>------</span> Machine B
	          &lt;<span class=nt>------</span>
	           <span class=o>(</span>2.2<span class=o>)</span>

	<span class=o>(</span>2.1<span class=o>)</span>
	<span class=nv>PROTO</span><span class=o>=</span>AH
		<span class=nv>ALG</span><span class=o>=</span>new-HMAC-SHA1<span class=o>(</span>new AH<span class=o>)</span>
		<span class=nv>KEY</span><span class=o>=</span>KAMEKAMEKAMEKAMEKAME
		<span class=nv>SPI</span><span class=o>=</span>2000

	<span class=o>(</span>2.2<span class=o>)</span>
	<span class=nv>PROTO</span><span class=o>=</span>ESP
		<span class=nv>ALG</span><span class=o>=</span>new-DES-expIV<span class=o>(</span>new ESP<span class=o>)</span>
			IV length <span class=o>=</span> 8
		<span class=nv>KEY</span><span class=o>=</span>PASSWORD
		<span class=nv>SPI</span><span class=o>=</span>3000</code></pre></div></div><div class=paragraph><p>Maintenant, définissons l’association de sécurité. Exécutons <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> sur la Machine A et la Machine B:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -c</span>
    add 10.2.3.4 10.6.7.8 ah-old  1000 <span class=nt>-m</span> transport <span class=nt>-A</span> keyed-md5 <span class=s2>&#34;MYSECRETMYSECRET&#34;</span> <span class=p>;</span>
    add 10.6.7.8 10.2.3.4 ah  2000 <span class=nt>-m</span> transport <span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;KAMEKAMEKAMEKAMEKAME&#34;</span> <span class=p>;</span>
    add 10.6.7.8 10.2.3.4 esp 3000 <span class=nt>-m</span> transport <span class=nt>-E</span> des-cbc <span class=s2>&#34;PASSWORD&#34;</span> <span class=p>;</span>
    ^D</code></pre></div></div><div class=paragraph><p>En fait, la communication IPsec n’aura pas lieu avant que les entrées de politique de sécurité ne soient définies. Dans notre cas, il faut le faire sur les deux machines.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Côté A:

<span class=c># setkey -c</span>
    spdadd 10.2.3.4 10.6.7.8 any <span class=nt>-P</span> out ipsec
	ah/transport/10.2.3.4-10.6.7.8/require <span class=p>;</span>
    ^D

Côté B:

<span class=c># setkey -c</span>
    spdadd 10.6.7.8 10.2.3.4 any <span class=nt>-P</span> out ipsec
	esp/transport/10.6.7.8-10.2.3.4/require <span class=p>;</span>
    spdadd 10.6.7.8 10.2.3.4 any <span class=nt>-P</span> out ipsec
	ah/transport/10.6.7.8-10.2.3.4/require <span class=p>;</span>
    ^D

   Machine A <span class=nt>--------------------------</span><span class=o>&gt;</span> Machine E
   10.2.3.4                               10.6.7.8
      |                                     |
      <span class=o>=========</span> ancien AH keyed-md5 <span class=o>========&gt;</span>

      &lt;<span class=o>========</span> nouveau AH hmac-sha1 <span class=o>========</span>
      &lt;<span class=o>========</span> nouveau ESP des-cbc <span class=o>=========</span></code></pre></div></div></div><div class=sect3><h4 id=_exemple_en_mode_transport_avec_ipv6>15.10.2. Exemple en mode transport avec IPv6<a class=anchor href=#_exemple_en_mode_transport_avec_ipv6></a></h4><div class=paragraph><p>Un autre exemple utilisant IPv6.</p></div><div class=paragraph><p>Le mode de transport ESP est recommandé pour le port TCP numéro 110 entre la Machine-A et la Machine-B.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>              <span class=o>============</span> ESP <span class=o>============</span>
              |                           |
          Machine-A                   Machine-B
          fec0::10 <span class=nt>--------------------</span> fec0::11</code></pre></div></div><div class=paragraph><p>L’algorithme de chiffrement est blowfish-cbc avec la clé "kamekame", et l’algorithme d’authentification est hmac-sha1 avec la clé "this is the test key". Configuration de la Machine-A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -c &lt;&lt;EOF</span>
    spdadd fec0::10[any] fec0::11[110] tcp <span class=nt>-P</span> out ipsec
	esp/transport/fec0::10-fec0::11/use <span class=p>;</span>
    spdadd fec0::11[110] fec0::10[any] tcp <span class=nt>-P</span> <span class=k>in </span>ipsec
	esp/transport/fec0::11-fec0::10/use <span class=p>;</span>
    add fec0::10 fec0::11 esp 0x10001
	<span class=nt>-m</span> transport
	<span class=nt>-E</span> blowfish-cbc <span class=s2>&#34;kamekame&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    add fec0::11 fec0::10 esp 0x10002
	<span class=nt>-m</span> transport
	<span class=nt>-E</span> blowfish-cbc <span class=s2>&#34;kamekame&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    EOF</code></pre></div></div><div class=paragraph><p>et de la Machine-B:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -c &lt;&lt;EOF</span>
    spdadd fec0::11[110] fec0::10[any] tcp <span class=nt>-P</span> out ipsec
	esp/transport/fec0::11-fec0::10/use <span class=p>;</span>
    spdadd fec0::10[any] fec0::11[110] tcp <span class=nt>-P</span> <span class=k>in </span>ipsec
	esp/transport/fec0::10-fec0::11/use <span class=p>;</span>
    add fec0::10 fec0::11 esp 0x10001 <span class=nt>-m</span> transport
	<span class=nt>-E</span> blowfish-cbc <span class=s2>&#34;kamekame&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    add fec0::11 fec0::10 esp 0x10002 <span class=nt>-m</span> transport
	<span class=nt>-E</span> blowfish-cbc <span class=s2>&#34;kamekame&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    EOF</code></pre></div></div><div class=paragraph><p>Remarquez la direction de SP.</p></div></div><div class=sect3><h4 id=_exemple_en_mode_tunnel_avec_ipv4>15.10.3. Exemple en mode tunnel avec IPv4<a class=anchor href=#_exemple_en_mode_tunnel_avec_ipv4></a></h4><div class=paragraph><p>Mode tunnel entre deux passerelles de sécurité</p></div><div class=paragraph><p>Le protocole de sécurité est l’ancien mode tunnel AH, i.e. spécifié par la RFC1826, avec keyed-md5 comme algorithme d’authentification et "this is the test" comme clé.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                             <span class=o>=======</span> AH <span class=o>=======</span>
                             |                |
         Réseau-A       Passerelle-A     Passerelle-B       Réseau-B
        10.0.1.0/24 <span class=nt>----</span> 172.16.0.1 <span class=nt>-----</span> 172.16.0.2 <span class=nt>----</span> 10.0.2.0/24</code></pre></div></div><div class=paragraph><p>Configuration de la Passerelle-A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -c &lt;&lt;EOF</span>
    spdadd 10.0.1.0/24 10.0.2.0/24 any <span class=nt>-P</span> out ipsec
	ah/tunnel/172.16.0.1-172.16.0.2/require <span class=p>;</span>
    spdadd 10.0.2.0/24 10.0.1.0/24 any <span class=nt>-P</span> <span class=k>in </span>ipsec
	ah/tunnel/172.16.0.2-172.16.0.1/require <span class=p>;</span>
    add 172.16.0.1 172.16.0.2 ah-old 0x10003 <span class=nt>-m</span> any
	<span class=nt>-A</span> keyed-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>
    add 172.16.0.2 172.16.0.1 ah-old 0x10004 <span class=nt>-m</span> any
	<span class=nt>-A</span> keyed-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>

EOF</code></pre></div></div><div class=paragraph><p>Si le numéro de port n’est pas précisé comme ci-dessus, alors <code>[any]</code> est utilisé. <code>-m</code> définit le mode de SA à utiliser. <code>-m any</code> signifie tout mode de protocole de sécurité. Vous pouvez utiliser cette SA à la fois en mode transport et en mode tunnel.</p></div><div class=paragraph><p>et de la Passerelle-B:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -c &lt;&lt;EOF</span>
    spdadd 10.0.2.0/24 10.0.1.0/24 any <span class=nt>-P</span> out ipsec
	ah/tunnel/172.16.0.2-172.16.0.1/require <span class=p>;</span>
    spdadd 10.0.1.0/24 10.0.2.0/24 any <span class=nt>-P</span> <span class=k>in </span>ipsec
	ah/tunnel/172.16.0.1-172.16.0.2/require <span class=p>;</span>
    add 172.16.0.1 172.16.0.2 ah-old 0x10003 <span class=nt>-m</span> any
	<span class=nt>-A</span> keyed-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>
    add 172.16.0.2 172.16.0.1 ah-old 0x10004 <span class=nt>-m</span> any
	<span class=nt>-A</span> keyed-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>

EOF</code></pre></div></div><div class=paragraph><p>Etablir une SA regroupée entre deux passerelles de sécurité</p></div><div class=paragraph><p>On désire le mode de transport AH et le mode tunnel ESP entre Passerelle-A et Passerelle-B. Dans ce cas, on applique d’abord le mode tunnel ESP puis le mode de transport AH.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                            <span class=o>==========</span> AH <span class=o>=========</span>
                            |  <span class=o>=======</span> ESP <span class=o>=====</span>  |
                            |  |               |  |
       Réseau-A         Passerelle-A        Passerelle-B        Réseau-B
    fec0:0:0:1::/64 <span class=nt>---</span> fec0:0:0:1::1 <span class=nt>----</span> fec0:0:0:2::1 <span class=nt>---</span> fec0:0:0:2::/64</code></pre></div></div></div><div class=sect3><h4 id=_exemple_en_mode_tunnel_avec_ipv6>15.10.4. Exemple en mode tunnel avec IPv6<a class=anchor href=#_exemple_en_mode_tunnel_avec_ipv6></a></h4><div class=paragraph><p>L’algorithme de chiffrement est 3des-cbc, et l’algorithme d’authentification est hmac-sha1. L’algorithme d’authentification pour AH est hmac-md5. Configuration de la Passerelle-A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -c &lt;&lt;EOF</span>
    spdadd fec0:0:0:1::/64 fec0:0:0:2::/64 any <span class=nt>-P</span> out ipsec
	esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require
	ah/transport/fec0:0:0:1::1-fec0:0:0:2::1/require <span class=p>;</span>
    spdadd fec0:0:0:2::/64 fec0:0:0:1::/64 any <span class=nt>-P</span> <span class=k>in </span>ipsec
	esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require
	ah/transport/fec0:0:0:2::1-fec0:0:0:1::1/require <span class=p>;</span>
    add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10001 <span class=nt>-m</span> tunnel
	<span class=nt>-E</span> 3des-cbc <span class=s2>&#34;kamekame12341234kame1234&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    add fec0:0:0:1::1 fec0:0:0:2::1 ah 0x10001 <span class=nt>-m</span> transport
	<span class=nt>-A</span> hmac-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>
    add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10001 <span class=nt>-m</span> tunnel
	<span class=nt>-E</span> 3des-cbc <span class=s2>&#34;kamekame12341234kame1234&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    add fec0:0:0:2::1 fec0:0:0:1::1 ah 0x10001 <span class=nt>-m</span> transport
	<span class=nt>-A</span> hmac-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>

    EOF</code></pre></div></div><div class=paragraph><p>Etablir des SAs avec les différentes extrémités</p></div><div class=paragraph><p>On désire un mode tunnel ESP entre Machine-A et Passerelle-A. L’algorithme de chiffrement est cast128-cbc, et l’algorithme d’authentification pour ESP est hmac-sha1. Le mode de transport ESP est recommandé entre Machine-A et Machine-B. L’algorithme de chiffrement est rc5-cbc, et l’algorithme d’authentification pour ESP est hmac-md5.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>              <span class=o>==================</span> ESP <span class=o>=================</span>
              |  <span class=o>=======</span> ESP <span class=o>=======</span>                 |
              |  |                 |                 |
            Machine-A        Passerelle-A         Machine-B
          fec0:0:0:1::1 <span class=nt>----</span> fec0:0:0:2::1 <span class=nt>----</span> fec0:0:0:2::2</code></pre></div></div><div class=paragraph><p>Configuration de la Machine-A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -c &lt;&lt;EOF</span>
    spdadd fec0:0:0:1::1[any] fec0:0:0:2::2[80] tcp <span class=nt>-P</span> out ipsec
	esp/transport/fec0:0:0:1::1-fec0:0:0:2::2/use
	esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require <span class=p>;</span>
    spdadd fec0:0:0:2::1[80] fec0:0:0:1::1[any] tcp <span class=nt>-P</span> <span class=k>in </span>ipsec
	esp/transport/fec0:0:0:2::2-fec0:0:0:l::1/use
	esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require <span class=p>;</span>
    add fec0:0:0:1::1 fec0:0:0:2::2 esp 0x10001
	<span class=nt>-m</span> transport
	<span class=nt>-E</span> cast128-cbc <span class=s2>&#34;12341234&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10002
	<span class=nt>-E</span> rc5-cbc <span class=s2>&#34;kamekame&#34;</span>
	<span class=nt>-A</span> hmac-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>
    add fec0:0:0:2::2 fec0:0:0:1::1 esp 0x10003
	<span class=nt>-m</span> transport
	<span class=nt>-E</span> cast128-cbc <span class=s2>&#34;12341234&#34;</span>
	<span class=nt>-A</span> hmac-sha1 <span class=s2>&#34;this is the test key&#34;</span> <span class=p>;</span>
    add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10004
	<span class=nt>-E</span> rc5-cbc <span class=s2>&#34;kamekame&#34;</span>
	<span class=nt>-A</span> hmac-md5 <span class=s2>&#34;this is the test&#34;</span> <span class=p>;</span>

    EOF</code></pre></div></div></div></div><div class=sect2><h3 id=openssh>15.11. OpenSSH<a class=anchor href=#openssh></a></h3><div class=paragraph><p>OpenSSH est un ensemble d’outils de connexion réseau utilisés pour accéder à des machines distantes de façon sécurisée. Ils peuvent être utilisés comme remplaçants directs de <code>rlogin</code>, <code>rsh</code>, <code>rcp</code>, et <code>telnet</code>. De plus, OpenSSH peut sécuriser n’importe quelle connexion TCP/IP via un tunnel. OpenSSH chiffre tout le trafic de façon à déjouer les écoutes réseau, les prises de contrôle de connexion, et aux attaques au niveau du réseau.</p></div><div class=paragraph><p>OpenSSH est maintenu par le projet OpenBSD, et est basé sur SSH v1.2.12 avec tous les récentes corrections et mises à jour. Il est compatible avec les protocoles SSH 1 et 2. OpenSSH est présent dans le système de base depuis FreeBSD 4.0.</p></div><div class=sect3><h4 id=_les_avantages_à_utiliser_openssh>15.11.1. Les avantages à utiliser OpenSSH<a class=anchor href=#_les_avantages_à_utiliser_openssh></a></h4><div class=paragraph><p>Normalement, quand on utilise <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, les données sont envoyées sur le réseau en clair, sous forme non chiffrée. Des "renifleurs de paquets" placés n’importe où entre le client et le serveur peuvent prendre connaissance de votre nom d’utilisateur, de votre mot de passe et des données transmises lors de votre session. OpenSSH offre une variété de méthodes d’authentification et de chiffrage pour éviter ce genre de problème.</p></div></div><div class=sect3><h4 id=_activer_sshd>15.11.2. Activer sshd<a class=anchor href=#_activer_sshd></a></h4><div class=paragraph><p>Assurez-vous d’ajouter la ligne suivante à votre fichier <span class=filename>rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Cela chargera le "daemon" ssh à l’initialisation suivante du système. Alternativement, vous pouvez tout simplement exécuter le "daemon" sshd directement en tapant <code>sshd</code> sur la ligne de commande.</p></div></div><div class=sect3><h4 id=_client_ssh>15.11.3. Client SSH<a class=anchor href=#_client_ssh></a></h4><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> fonctionne de la même manière que <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
Host key not found from the list of known hosts.
Are you sure you want to <span class=k>continue </span>connecting <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>? <span class=nb>yes
</span>Host <span class=s1>&#39;example.com&#39;</span> added to the list of known hosts.
user@example.com<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>L’ouverture de session se poursuit comme si elle avait lancée par <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>. Le système SSH utilise un système d’empreinte de clé pour vérifier l’authenticité du serveur quand le client se connecte. L’utilisateur est invité à entrer <code>yes</code> uniquement à la première connexion. Lors des futures connexions, l’empreinte de la clé sauvegardé est vérifiée. Le client SSH vous avertira si l’empreinte sauvée diffère de l’empreinte reçue lors de futures tentatives de connexion. Les empreintes sont sauvées dans le fichier <span class=filename>~/.ssh/known_hosts</span>, ou <span class=filename>~/.ssh/known_hosts2</span> pour les empreintes du protocole SSH 2.</p></div><div class=paragraph><p>Par défaut, les serveurs OpenSSH sont configurés pour accepter les connexions dans les deux protocoles SSH 1 et 2. Le client peut, cependant, choisir entre les deux. Le protocole 2 est connu pour être plus robuste et plus sécurisé que son prédécesseur.</p></div><div class=paragraph><p><code>ssh</code> peut être forcé à utilisé l’un des protocole en passant l’argument <code>-1</code> ou <code>-2</code> pour le protocole 1 ou 2 respectivement.</p></div></div><div class=sect3><h4 id=_copie_sécurisée>15.11.4. Copie sécurisée<a class=anchor href=#_copie_sécurisée></a></h4><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> fonctionne de la même manière que <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>; elle copie un fichier vers ou à partir d’une machine distante à la différence qu’elle le fait d’une façon sécurisé.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp user@example.com:/COPYRIGHT COPYRIGHT</span>
user@example.com<span class=s1>&#39;s password: *******
COPYRIGHT            100% |*****************************|  4735
00:00
#</span></code></pre></div></div><div class=paragraph><p>Puisque l’empreinte a déjà été sauvée pour cette machine dans l’exemple précédent, cela se vérifie ici quand on utilise <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>.</p></div><div class=paragraph><p>Les arguments passés à <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> sont similaires à ceux de <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a>, avec le ou les fichiers en premier argument, et la destination en second. Puisque que le fichier est copié via le réseau, par l’intermédiaire de SSH, un ou plusieurs des arguments prennent la forme <code>utilisateur@machine_distante:chemin_du_fichier</code>.</p></div></div><div class=sect3><h4 id=_configuration>15.11.5. Configuration<a class=anchor href=#_configuration></a></h4><div class=paragraph><p>Les fichiers de configuration général au système pour le "daemon" et le client OpenSSH résident dans le répertoire <span class=filename>/etc/ssh</span>.</p></div><div class=paragraph><p><span class=filename>ssh_config</span> permet de paramétrer le client, tandis que <span class=filename>sshd_config</span> s’occupe de la configuration du "daemon".</p></div><div class=paragraph><p>De plus, les options <code>sshd_program</code> (<span class=filename>/usr/sbin/sshd</span> par défaut), et <code>sshd_flags</code> du fichier <span class=filename>rc.conf</span> peut fournir un niveau supplémentaire de configuration.</p></div></div><div class=sect3><h4 id=_ssh_keygen>15.11.6. ssh-keygen<a class=anchor href=#_ssh_keygen></a></h4><div class=paragraph><p>Au lieu d’utiliser des mots de passe, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> peut être employé pour générer des clés RSA pour authentifier un utilisateur:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> rsa1
Initializing random number generator...
Generating p:  .++ <span class=o>(</span>distance 66<span class=o>)</span>
Generating q:  ..............................++ <span class=o>(</span>distance 498<span class=o>)</span>
Computing the keys...
Key generation complete.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/identity<span class=o>)</span>:
Enter passphrase:
Enter the same passphrase again:
Your identification has been saved <span class=k>in</span> /home/user/.ssh/identity.
...</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> créera une paire de clés publique et privée à utiliser pour l’authentification. La clé privée est stockée dans le fichier <span class=filename>~/.ssh/identity</span>, alors que la clé publique l’est dans le fichier <span class=filename>~/.ssh/identity.pub</span>. La clé publique doit être placée dans le fichier <span class=filename>~/.ssh/authorized_keys</span> sur la machine distante pour que cela fonctionne.</p></div><div class=paragraph><p>Ceci autorisera les connexions sur la machine distante en utilisant l’authentification RSA à la place des mots de passe.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’option <code>-t rsa1</code> créera des clés RSA pour le protocole SSH 1. Si vous désirez utiliser des clés RSA avec le protocole SSH 2, vous devez employer la commande <code>ssh-keygen -t rsa</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si une phrase d’authentification est utilisée avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>, l’utilisateur se verra demandé d’entrer un mot de passe à chaque utilisation de la clé privé.</p></div><div class=paragraph><p>Une clé DSA SSH protocole 2 peut être créée pour le même objectif en utilisant la commande <code>ssh-keygen -t dsa</code>. Cela créera une paire de clés DSA pour les sessions SSH utilisant le protocole 2. La clé publique est conservée dans <span class=filename>~/.ssh/id_dsa.pub</span>, tandis que la clé privée se trouve dans <span class=filename>~/.ssh/id_dsa</span>.</p></div><div class=paragraph><p>Les clés publiques DSA sont placées dans le fichier <span class=filename>~/.ssh/authorized_keys</span> sur la machine distante.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> sont des utilitaires employés pour la gestion de multiples clés privées protégées par mots de passe.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Les divers fichiers et options peuvent être différents selon la version d’OpenSSH dont vous disposez, pour éviter les problèmes vous devez consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=security-ssh-tunneling>15.11.7. Tunnels SSH<a class=anchor href=#security-ssh-tunneling></a></h4><div class=paragraph><p>OpenSSH a la capacité de créer un tunnel pour encapsuler un autre protocole dans une session chiffrée.</p></div><div class=paragraph><p>La commande suivante demande à <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> de créer un tunnel pour telnet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>La commande <code>ssh</code> est utilisée avec les options suivantes:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Force <code>ssh</code> à utiliser la version du protocole (à ne pas utiliser si vous travaillez avec de vieux serveurs SSH).</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>N’exécute aucune commande à distance, ou mode se place en mode tunnel. Si cette option est omise <code>ssh</code> initiera une session normale.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Force <code>ssh</code> à s’exécuter en arrière-plan.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Spécifie un tunnel local de la manière <code><em>port_local:machine_distante:port_distant</em></code>.</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>Le serveur SSH distant.</p></dd></dl></div><div class=paragraph><p>Un tunnel SSH fonctionne grâce à l’allocation d’une "socket" qui écoute sur le port spécifié de la machine <code>localhost</code>. Il transfère ensuite toute connexion reçue sur la/le machine/port local(e) via la connexion SSH vers la machine et le port distants spécifiés.</p></div><div class=paragraph><p>Dans l’exemple, le port <em>5023</em> sur la machine locale transfère toute connexion sur ce port vers le port <em>23</em> de la machine distante (le <code>localhost</code> de la commande). Puisque le port <em>23</em> est celui de telnet, cela créerai une session telnet sécurisée par l’intermédiaire d’un tunnel SSH.</p></div><div class=paragraph><p>Cela peut être utilisé pour encapsuler n’importe quel nombre de protocoles TCP non sécurisé comme SMTP, POP3, FTP, etc.</p></div><div class=exampleblock><div class=title>Exemple 28. Utiliser SSH pour créer un tunnel sécurisé pour SMTP</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p>Ceci peut être utilisé en conjonction avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> et des comptes utilisateurs supplémentaires pour la création et l’accès au tunnel SSH sans trop de problème. Des clés peuvent être utilisées à la place de la saisie d’un mot de passe, et les tunnels peuvent être exécutés sous un utilisateur séparé.</p></div></div></div><div class=sect4><h5 id=_exemples_pratiques_de_tunnels_ssh>15.11.7.1. Exemples pratiques de tunnels SSH<a class=anchor href=#_exemples_pratiques_de_tunnels_ssh></a></h5><div class=sect5><h6 id=_accès_sécurisé_à_un_serveur_pop3>15.11.7.1.1. Accès sécurisé à un serveur POP3<a class=anchor href=#_accès_sécurisé_à_un_serveur_pop3></a></h6><div class=paragraph><p>Au travail, il y a un serveur SSH qui accepte les connexions de l’extérieur. Sur le même réseau d’entreprise réside un serveur de courrier électronique faisant fonctionner un serveur POP3. Le réseau ou le chemin entre chez vous et le bureau peut ou peut ne pas être complètement sûr. Pour cette raison, vous devez récupérer votre courrier électronique d’une façon sécurisée. La solution est de créer une connexion SSH vers le serveur SSH de votre entreprise, et d’utiliser ce tunnel vers le serveur de courrier.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>Quand le tunnel est configuré et fonctionne, vous pouvez demander à votre client de courrier électronique d’envoyer ses requêtes POP3 sur le port 2110 de la machine locale: <code>localhost</code>. Les connexions seront transférées de façon sécurisé à travers le tunnel jusqu’à <code>mail.example.com</code>.</p></div></div><div class=sect5><h6 id=_passer_à_travers_un_coupe_feu_restrictif>15.11.7.1.2. Passer à travers un coupe-feu restrictif<a class=anchor href=#_passer_à_travers_un_coupe_feu_restrictif></a></h6><div class=paragraph><p>Certains administrateurs réseau imposent des règles draconiennes au niveau du coupe-feu, filtrant non seulement les connexions entrantes, mais également les connexions sortantes. Il se peut que vous n’ayez accès qu’aux ports 22 et 80 de machines distantes pour SSH ou la navigation Internet.</p></div><div class=paragraph><p>Vous pouvez vouloir accéder à un autre (n’ayant peut-être aucun rapport avec votre travail) service, comme un serveur Ogg Vorbis pour écouter de la musique. Si le serveur Ogg Vorbis diffuse ("streaming") ses données à partir d’un port différent des ports 22 ou 80, vous ne serez alors pas en mesure d’y accéder.</p></div><div class=paragraph><p>La solution est de créer une connexion SSH vers une machine à l’extérieur du réseau protégé par le coupe-feu, et l’utiliser pour créer un tunnel vers le serveur Ogg Vorbis.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Vous pouvez maintenant faire pointer votre client pour la récupération du flux de données sur le port 8888 de la machine locale, qui sera transféré jusqu’au port 8000 de la machine <code>music.example.com</code>, passant ainsi outre les restrictions du coupe-feu.</p></div></div></div></div><div class=sect3><h4 id=_lectures_supplémentaires>15.11.8. Lectures supplémentaires<a class=anchor href=#_lectures_supplémentaires></a></h4><div class=paragraph><p><a href=http://www.openssh.com/>OpenSSH</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp-server&amp;sektion=8&amp;format=html">sftp-server(8)</a></p></div></div></div><div class=sect2><h3 id=fs-acl>15.12. Listes de contrôle d’accès au système de fichiers<a class=anchor href=#fs-acl></a></h3><div class=paragraph><p>Avec les améliorations des systèmes de fichiers comme les "snapshots", FreeBSD 5.0 et versions suivantes offrent une nouveauté en matière de sécurité: les listes de contrôle d’accès au système de fichiers (ACLs - "Access Control Lists").</p></div><div class=paragraph><p>Les listes de contrôle d’accès étendent le système de permission standard d’UNIX d’une manière hautement compatible (POSIX.1e). Cette caractéristique permet à un administrateur d’utiliser avantageusement un modèle de sécurité plus sophistiqué.</p></div><div class=paragraph><p>Pour activer le support ACL pour les systèmes de fichiers UFS, ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>doit être compilé dans le noyau. Si cette option n’a pas été ajoutée, un avertissement sera affiché lors d’une tentative de montage d’un système de fichiers supportant les ACLs. Cette option est présente dans le noyau <span class=filename>GENERIC</span>. Les ACLs reposent sur des attributs étendus rajoutés au système de fichiers. Les attributs étendus sont nativement supportés par la prochaine génération du système de fichiers UNIX, UFS2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Un supplément de travail d’administration est requis pour configurer les attributs étendus sous UFS1 par rapport à UFS2. Les performances des attributs étendus sous UFS2 sont sensiblement meilleures également. Il en résulte donc, que l’UFS2 est généralement recommandé par rapport à l’UFS1 pour une utilisation des listes de contrôle d’accès.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Les ACLs sont activés grâce l’option utilisée lors du montage, <code>acls</code>, qui peut être ajouté dans le fichier <span class=filename>/etc/fstab</span>. Cette option de montage peut être également automatiquement fixée d’une manière définitive en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> pour modifier l’indicateur ACL du "superblock" dans l’entête du système de fichiers. Il est en général préférable d’utiliser cet indicateur pour plusieurs raisons:</p></div><div class=ulist><ul><li><p>L’option de montage pour les ACLs ne peut être modifiée par un simple remontage (<a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <code>-u</code>), mais uniquement par un <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> complet et suivi d’un <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Cela signifie que les ACLs ne peuvent être activées sur le système de fichiers racine après le démarrage. Cela signifie également que vous ne pouvez pas modifier la disposition d’un système de fichier une fois que c’est activé.</p></li><li><p>Positionner l’indicateur du "superblock" fera que le système de fichiers sera toujours monté avec les ACLs activées même s’il n’y a pas d’entrée dans le fichier <span class=filename>fstab</span>, ou s’il y a une réorganisation des périphériques. Cela prévient le montage accidentel du système de fichiers sans les ACLs activées, ce qui peut provoquer une activation impropre des ACLs et par conséquent des problèmes de sécurité.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nous pourrions modifier le comportement des ACLs pour permettre l’activation de l’indicateur sans le besoin d’un nouveau <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> complet, mais nous considérons qu’il est préférable d’éviter un montage accidentel sans les ACLs activées, parce que vous pouvez vous "tirer facilement dans les pieds" si vous activez les ACLs, puis les désactivez, et ensuite les réactivez à nouveau sans réinitialiser les attributs étendus. En général, une fois que vous avez activé les ACLs sur un système de fichiers, elles ne devraient pas être désactivées étant donné que les protections de fichiers résultantes peuvent ne pas être compatible avec celles prévues par les utilisateurs du système, et réactiver les ACLs peut réaffecter les précédentes ACLs aux fichiers qui ont depuis eût leur permissions modifiées, avec pour résultat un comportement imprévisible.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Les systèmes de fichiers avec les ACLs activées présenteront un signe <code>+</code> au niveau de leurs permissions quand elles seront affichées. Par exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>Ici nous voyons que les répertoires <span class=filename>directory1</span>, <span class=filename>directory2</span>, et <span class=filename>directory3</span> utilisent les ACLs. Ce n’est pas le cas du répertoire <span class=filename>public_html</span>.</p></div><div class=sect3><h4 id=_utilisation_des_acls>15.12.1. Utilisation des ACLs<a class=anchor href=#_utilisation_des_acls></a></h4><div class=paragraph><p>Les ACLs peuvent être affichées par l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a>. Par exemple pour voir les ACLs sur le fichier <span class=filename>test</span>, on utilisera la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>Pour modifier le paramétrage des ACLs sur ce fichier, invoquez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a>. Intéressons-nous à la ligne:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>L’indicateur <code>-k</code> supprimera toutes les ACLs actuellement définies pour un fichier ou un système de fichiers. Une méthode plus adaptée est d’utiliser l’option <code>-b</code> étant donné qu’elle conserve les champs de base nécessaires au bon fonctionnement des ACLs.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>Dans la commande ci-dessus, l’option <code>-m</code> a été utilisée pour modifier les entrées ACL par défaut. Comme il n’y avait pas d’entrées pré-définies, puisqu’elles ont été supprimées par la commande précédente, cela restaurera les options par défaut et prendra en compte les options précisées. Prenez soin de noter que si vous ajoutez un utilisateur ou un groupe qui n’existe pas sur le système, une erreur <code>Invalid argument</code> sera affichée sur la sortie standard.</p></div></div></div><div class=sect2><h3 id=security-portaudit>15.13. Surveillance des problèmes de sécurité relatifs aux programmes tierce-partie<a class=anchor href=#security-portaudit></a></h3><div class=paragraph><p>Ces dernières années, le monde de la sécurité a fait beaucoup de progrès dans la manière d’évaluer les vulnérabilités. Le risque d’une intrusion dans le système augmente avec l’installation et la configuration d’utilitaires tierce-partie et cela pour quasiment n’importe quel système d’exploitation disponible aujourd’hui.</p></div><div class=paragraph><p>L’évaluation des vulnérabilités est un facteur clé de la politique de sécurité, alors que FreeBSD publie des avis pour le système de base, faire de même pour les programmes tierce-partie dépasse les capacités du projet FreeBSD. Il existe un moyen d’atténuer les vulnérabilités des logiciels tierce-partie et de prévenir les administrateurs des problèmes de sécurité connus. Un outil FreeBSD connu sous le nom de Portaudit existe dans cet unique but.</p></div><div class=paragraph><p>Le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portaudit/>ports-mgmt/portaudit</a> consulte une base de données, mise à jour et maintenue par l’équipe de sécurité de FreeBSD et les développeurs des logiciels portés, à la recherche de problèmes de sécurité connus.</p></div><div class=paragraph><p>Pour utiliser Portaudit, ce dernier doit être installé à partir du catalogue des logiciels portés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portaudit &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>Lors du processus d’installation, les fichiers de configuration de <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> seront mis à jour, autorisant l’ajout des résultats de Portaudit dans l’exécution quotidienne du rapport de sécurité. Assurez-vous que les rapports de sécurité quotidiens, qui sont envoyés au compte messagerie de <code>root</code>, sont bien lus. Pas plus de configuration ne sera nécessaire.</p></div><div class=paragraph><p>Après l’installation, un administrateur peut mettre à jour la base de données et afficher les vulnérabilités connues des logiciels installés en invoquant la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -Fda</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La base de données sera automatiquement mise à jour lors de l’exécution de <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>, cela rendant par conséquent facultative la commande précédente. Elle n’est requise que pour les exemples qui vont suivre.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour contrôler à n’importe quel moment les programmes tierce-partie installés à partir du catalogue des logiciels portés, un administrateur n’aura qu’à exécuter la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -a</span></code></pre></div></div><div class=paragraph><p>Portaudit produira pour les logiciels vulnérables quelque chose comme ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>En faisant pointer un navigateur Web sur l’URL proposée, un administrateur pourra obtenir plus d’information au sujet de la vulnérabilité en question. Cela comprendra les versions affectées, listées par version du logiciel porté FreeBSD, ainsi que des liens vers d’autres sites Web pouvant contenir des avis de sécurité.</p></div><div class=paragraph><p>En résumé, Portaudit est un outil puissant et extrêmement utile quand il est employé conjointement avec le logiciel Portupgrade.</p></div></div><div class=sect2><h3 id=security-advisories>15.14. Avis de sécurité de FreeBSD<a class=anchor href=#security-advisories></a></h3><div class=paragraph><p>Comme plusieurs systèmes d’exploitation destinés à la production, FreeBSD publie des "Avis de sécurité". Ces avis sont généralement envoyés aux listes de diffusion traitant de la sécurité et ajoutés dans l’errata une fois seulement que les versions correspondantes ont été corrigées. Cette section aura pour objectif d’expliquer ce qu’est un avis, comment le comprendre, et quelles mesures sont à prendre pour appliquer des correctifs à un système.</p></div><div class=sect3><h4 id=_a_quoi_ressemble_un_avis_de_sécurité>15.14.1. A quoi ressemble un avis de sécurité?<a class=anchor href=#_a_quoi_ressemble_un_avis_de_sécurité></a></h4><div class=paragraph><p>Les avis de sécurité de FreeBSD ressemblent à celui présenté ci-dessous qui provient de la liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>liste de diffusion des avis de sécurité pour FreeBSD</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem <i class=conum data-value=1></i><b>(1)</b>

Category:       core <i class=conum data-value=2></i><b>(2)</b>
Module:         sys <i class=conum data-value=3></i><b>(3)</b>
Announced:      2003-09-23 <i class=conum data-value=4></i><b>(4)</b>
Credits:        Person@EMAIL-ADDRESS <i class=conum data-value=5></i><b>(5)</b>
Affects:        All releases of FreeBSD <i class=conum data-value=6></i><b>(6)</b>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39) <i class=conum data-value=7></i><b>(7)</b>
FreeBSD only:   NO <i class=conum data-value=8></i><b>(8)</b>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.freebsd.org/security/.

I.   Background <i class=conum data-value=9></i><b>(9)</b>

II.  Problem Description <i class=conum data-value=10></i><b>(10)</b>

III. Impact <i class=conum data-value=11></i><b>(11)</b>

IV.  Workaround <i class=conum data-value=12></i><b>(12)</b>

V.   Solution <i class=conum data-value=13></i><b>(13)</b>

VI.  Correction details <i class=conum data-value=14></i><b>(14)</b>

VII. References <i class=conum data-value=15></i><b>(15)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Le champ <code>Topic</code> indique exactement quel est le problème. C’est basiquement une introduction à l’avis de sécurité en tant que tel et mentionne l’utilitaire contenant la vulnérabilité.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Le champ <code>Category</code> fait référence à la partie du système affectée qui peut être une parmi <code>core</code>, <code>contrib</code>, ou <code>ports</code>. La catégorie <code>core</code> signifie que la vulnérabilité affecte un composant système du système d’exploitation FreeBSD. La catégorie <code>contrib</code> précise que la vulnérabilité affecte du logiciel contribué au projet FreeBSD, comme sendmail. Et enfin la catégorie <code>ports</code> indique que la vulnérabilité affecte un logiciel du catalogue des logiciels portés.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Le champ <code>Module</code> fait référence à l’emplacement du composant, par exemple <code>sys</code>. Dans notre exemple, nous voyons que le module <code>sys</code> est affecté, par conséquent, cette vulnérabilité concerne un composant utilisé dans le noyau.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Le champ <code>Announced</code> reflète la date à laquelle l’avis de sécurité a été publié, ou annoncé au monde entier. Cela signifie que l’équipe de sécurité a vérifié que le problème existait vraiment et qu’un correctif a été ajouté au référentiel des sources de FreeBSD.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Le champ <code>Credits</code> donne le crédit de la découverte du problème à la personne ou l’organisation qui a constaté et rapporté le problème.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Le champ <code>Affects</code> explique quelles versions de FreeBSD sont affectées par cette vulnérabilité. Pour le noyau, un coup d’oeil rapide à la sortie de la commande <code>ident</code> sur les fichiers affectés aidera à déterminer la révision. Pour les logiciels portés, le numéro de version est listé après le nom du logiciel dans <span class=filename>/var/db/pkg</span>. Si le système ne se synchronise pas avec le référentiel CVS FreeBSD et ne recompile pas les sources quotidiennement, il y a des chances qu’il soit affecté par le problème.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Le champ <code>Corrected</code> indique la date, l’heure, le fuseau horaire, et la version de publication qui a été corrigée.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Le champ <code>FreeBSD only</code> précise si cette vulnérabilité affecte juste FreeBSD, ou si elle concerne d’autres systèmes d’exploitation également.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Le champ <code>Background</code> donne une information précise sur ce qu’est l’utilitaire affecté. La plupart du temps, ce champ indique pourquoi l’utilitaire existe sous FreeBSD, son rôle, et quelques informations sur la naissance de l’utilitaire.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>Le champ <code>Problem Description</code> explique en profondeur le problème de sécurité. Cela peut comprendre des informations sur le code défectueux, ou même comment l’utilitaire pourrait être utilisé pour ouvrir un faille de sécurité.</td></tr><tr><td><i class=conum data-value=11></i><b>11</b></td><td>Le champ <code>Impact</code> décrit l’impact sur le système du problème de sécurité. Par exemple, cela peut aller de l’attaque par refus de service, au gain de droits supplémentaires par les utilisateurs, en passant par l’obtention des droits de super-utilisateur par l’attaquant.</td></tr><tr><td><i class=conum data-value=12></i><b>12</b></td><td>Le champ <code>Workaround</code> offre une solution de contournement possible pour les administrateurs qui ne sont pas en mesure de mettre à jour le système. Cela pouvant être due à des contraintes de temps, à une disponibilité réseau, ou une tout autre raison. Cependant, la sécurité ne devrait pas être prise à la légère, et un système affecté devrait soit être corrigé soit implémenter une solution de contournement du problème de sécurité.</td></tr><tr><td><i class=conum data-value=13></i><b>13</b></td><td>Le champ <code>Solution</code> donne les instructions sur l’application de correctifs sur le système affecté. C’est une méthode pas à pas vérifiée et testée pour obtenir un système corrigé et fonctionnant de manière sécurisée.</td></tr><tr><td><i class=conum data-value=14></i><b>14</b></td><td>Le champ <code>Correction Details</code> liste la branche CVS ou la version de publication avec les points remplacés par des caractères souligné. Il donne également le numéro de révision des fichiers affectés sur chaque branche.</td></tr><tr><td><i class=conum data-value=15></i><b>15</b></td><td>Le champ <code>References</code> donne en général d’autres sources d’informations. Cela peut être des URLs web, des ouvrages, des listes de diffusions, et des forums de discussion.</td></tr></tbody></table></div></div></div><div class=sect2><h3 id=security-accounting>15.15. Comptabilité des processus<a class=anchor href=#security-accounting></a></h3><div class=paragraph><p>La comptabilité des processus est une mesure de sécurité avec laquelle un administrateur peut suivre l’utilisation des ressources du système, leur répartition entre les utilisateurs, surveiller le système et avoir un suivi minimal des commandes exécutées par un utilisateur.</p></div><div class=paragraph><p>Ce système possède des avantages et des inconvénients. Un de ses avantages est qu’une intrusion pourra être remontée jusqu’à son point d’entrée. Un des inconvénients est la quantité de journaux générée par cette comptabilité et l’espace disque que cela peut demander. Cette section guidera l’administrateur au travers des bases de la comptabilité des processus.</p></div><div class=sect3><h4 id=_activer_et_utiliser_la_comptabilité_des_processus>15.15.1. Activer et utiliser la comptabilité des processus<a class=anchor href=#_activer_et_utiliser_la_comptabilité_des_processus></a></h4><div class=paragraph><p>Avant de pouvoir utiliser la comptabilité des processus, il faut l’activer. Cela se fait en exécutant les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/account/acct</span>

<span class=c># accton /var/account/acct</span>

<span class=c># echo &#39;accounting_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Une fois activée, les statistiques concernant le CPU, les commandes, etc. commenceront à être comptabilisée. Tous les journaux de comptabilisation des processus sont dans un format directement illisible pour l’utilisateur, ils pourront être examinés à l’aide de l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>. Si elle est utilisée sans paramètre, la commande <code>sa</code> affichera les informations relatives au nombre d’appels par utilisateur, le temps écoulé en minutes, la durée totale des temps CPU et utilisateur en minutes, le nombre moyen des opérations d’E/S, etc.</p></div><div class=paragraph><p>Pour afficher les informations sur les commandes utilisées, on emploiera l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>. La commande <code>lastcomm</code> peut être employée pour afficher les commandes tapées par les utilisateurs sur des terminaux (<a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>) spécifiques; par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls</span>
	trhodes ttyp1</code></pre></div></div><div class=paragraph><p>imprimera toute utilisation de la commande <code>ls</code> par l’utilisateur <code>trhodes</code> sur le terminal <code>ttyp1</code>.</p></div><div class=paragraph><p>De nombreuses autres options utiles existent et sont détaillées dans les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=jails>Chapitre 16. Jails<a class=anchor href=#jails></a></h2><div class=sectionbody><div class=sect2><h3 id=jails-synopsis>16.1. Synopsis<a class=anchor href=#jails-synopsis></a></h3><div class=paragraph><p>Ce chapitre expliquera ce que sont les environnements jail (prisons) et comment les utiliser. Les environnements jail, souvent présentés comme une amélioration et un remplacement des <em>environnements chrootés</em> sont des outils très puissants pour les administrateurs système, mais certaines de leurs fonctionnalités de base peuvent être également utiles aux utilisateurs avancés.</p></div><div class=paragraph><p>Après avoir lu ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Ce qu’est un environnement jail, et quelle utilité il peut avoir sur une installation FreeBSD.</p></li><li><p>Comment construire, démarrer et arrêter un environnement jail.</p></li><li><p>Les bases de l’administration d’un environnement jail, de l’intérieur et de l’extérieur de l’environnement.</p></li></ul></div><div class=paragraph><p>D’autres sources d’information utiles concernant les environnements jail sont:</p></div><div class=ulist><ul><li><p>La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. C’est la référence pour l’emploi de l’utilitaire <code>jail</code> - l’outil d’administration qui peut être utilisé sous FreeBSD pour démarrer, arrêter, et contrôler les environnements jail FreeBSD.</p></li><li><p>Les listes de diffusion et leurs archives. Les archives de la <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>liste de diffusion pour les questions d’ordre général à propos de FreeBSD</a> et d’autres listes hébergées par le <a href=https://lists.freebsd.org>serveur des listes de diffusion FreeBSD</a> contiennent déjà quantité d’information sur les environnements jail. Il sera toujours conseillé de chercher dans les archives ou de poster une nouvelle question sur la liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a>.</p></li></ul></div></div><div class=sect2><h3 id=jails-terms>16.2. Termes relatifs aux environnements jail<a class=anchor href=#jails-terms></a></h3><div class=paragraph><p>Pour faciliter la compréhension des parties du système FreeBSD relatives aux jails, leurs mécanismes internes et la manière dont ils interagissent avec le reste de FreeBSD, les termes suivants seront utilisés tout au long de ce chapitre:</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (commande)</dt><dd><p>Un appel système FreeBSD, qui modifie le répertoire racine d’un processus et de tout ses descendants.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (environnement)</dt><dd><p>Environnement des processus pour lesquels l’emplacement de la racine du système de fichier a été modifiée ("chrootée"). Cela comprend les ressources comme la partie du système de fichiers qui est visible, les identifiants utilisateur et groupe qui sont disponibles, les interfaces réseaux et autres mécanismes IPC, etc.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> (commande)</dt><dd><p>L’utilitaire système d’administration qui permet le lancement de processus à l’intérieur d’un environnement jail.</p></dd><dt class=hdlist1>hôte (système, processus, utilisateur, etc.)</dt><dd><p>Le système de contrôle d’un environnement jail. Le système hôte a accès à toutes les ressources matérielles disponibles, et peut contrôler des processus à l’extérieur et à l’intérieur d’un environnement jail. Une des différences importantes entre le système hôte et l’environnement jail est que les limitations qui s’appliquent aux processus du super-utilisateur à l’intérieur de l’environnement jail ne s’appliquent pas aux processus du système hôte.</p></dd><dt class=hdlist1>hébergé (système, processus, utilisateur, etc.)</dt><dd><p>Un processus, un utilisateur ou toute autre entité, dont l’accès aux ressources est limité par un environnement jail FreeBSD.</p></dd></dl></div></div><div class=sect2><h3 id=jails-intro>16.3. Introduction<a class=anchor href=#jails-intro></a></h3><div class=paragraph><p>Comme l’administration système est une tâche difficile et déroutante, de nombreux outils ont été développés pour rendre la vie de l’administrateur plus simple. Ces outils apportent pour la plupart des améliorations dans la manière dont sont installés, configurés et maintenus les systèmes. Une partie des tâches dévolues à l’administrateur est la sécurisation du système, de façon à ce que le système puisse se consacrer aux tâches qui lui sont confiées sans toutefois mettre en péril sa propre sécurité.</p></div><div class=paragraph><p>Un de ces outils pouvant être employé pour augmenter la sécurisation d’un système FreeBSD sont les environnements <em>jail</em>. Les environnements jail ont été introduits sous FreeBSD 4.X par Poul-Henning Kamp &lt;<a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>>, mais ils ont été fortement améliorés sous FreeBSD 5.X pour en faire des sous-systèmes flexibles et puissants. Des développements sont toujours en cours pour l’amélioration de leur utilité, performances, fiabilité et sécurité.</p></div><div class=sect3><h4 id=jails-what>16.3.1. Qu’est-ce qu’un environnement jail?<a class=anchor href=#jails-what></a></h4><div class=paragraph><p>Les systèmes BSD disposent de l’environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> depuis l’époque de 4.2BSD. L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> peut être employé pour changer le répertoire racine d’un ensemble de processus, créant ainsi un environnement sécurisé et séparé du reste du système. Les processus créés dans l’environnement chrooté ne peuvent accéder aux fichiers et aux ressources extérieures à cet environnement. Pour cette raison, si un attaquant compromet un service tournant dans un environnement chrooté, cela ne devrait pas lui permettre de compromettre l’intégralité du système. L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> est parfait pour des tâches simples qui ne demandent pas trop de flexibilité ou de fonctionnalités avancées et complexes. Depuis l’apparition du concept d’environnement chrooté, de nombreuses manières de s’échapper de ces environnements ont été découvertes, et bien que cela ait été corrigé dans les versions récentes du noyau FreeBSD, il est clair que l’environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> n’est pas la solution idéale pour la sécurisation des services. Un nouveau sous-système devait être implémenté.</p></div><div class=paragraph><p>Ceci est une des raisons principales à l’origine du développement de l’environnement <em>jail</em>.</p></div><div class=paragraph><p>Les environnements jail améliorent de plusieurs manières le concept d’environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a>. Dans un environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> traditionnel, les processus ne sont limités que dans la partie du système de fichiers à laquelle ils ont accès. Le reste des ressources système (comme l’ensemble des utilisateurs système, les processus en cours d’exécution, ou le réseau) est partagé par les processus de l’environnement chrooté et les processus du système hôte. L’environnement jail étend ce modèle en virtualisant non seulement l’accès au système de fichiers mais également l’ensemble des utilisateurs, la partie réseau du noyau FreeBSD et quelques autres éléments du système. Un ensemble plus complet de contrôles fins pour optimiser l’accès à un environnement jail est décrit dans la <a href=#jails-tuning>Optimisation et administration</a>.</p></div><div class=paragraph><p>Un environnement jail est caractérisé par quatre éléments:</p></div><div class=ulist><ul><li><p>Une arborescence de répertoires - le point d’accès à l’environnement jail. Une fois à l’intérieur de l’environnement jail, un processus ne peut s’échapper hors de cette arborescence. Les traditionnels problèmes de sécurité qui grèvent l’architecture <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> d’origine n’affecteront pas les environnements jail FreeBSD.</p></li><li><p>Un nom de machine - le nom de machine qui sera utilisé à l’intérieur de l’environnement jail. Les environnements jails sont principalement utilisés pour l’hébergement de services réseaux, par conséquent choisir un nom évocateur pour chaque environnement peut être d’une grande aide pour l’administrateur système.</p></li><li><p>Une adresse IP - elle sera assignée à l’environnement jail et ne peut, en aucun cas, être modifiée pendant toute la durée de vie de l’environnement. L’adresse IP d’un environnement jail est en général un alias d’une interface réseau existante, mais cela n’est pas forcément nécessaire.</p></li><li><p>Une commande - le chemin d’accès d’un exécutable à exécuter à l’intérieur de l’environnement jail. Il est relatif au répertoire racine de l’environnement jail, et peut beaucoup varier, en fonction du type d’environnement jail mis en oeuvre.</p></li></ul></div><div class=paragraph><p>En dehors de cela les environnements jail peuvent avoir leur propre ensemble d’utilisateurs et leur propre utilisateur <code>root</code>. Naturellement les pouvoirs de l’utilisateur <code>root</code> sont limités à l’environnement jail et, du point de vue du système hôte, l’utilisateur <code>root</code> de l’environnement jail n’est pas un utilisateur omnipotent. De plus, l’utilisateur <code>root</code> d’un environnement jail n’est pas autorisé à effectuer des opérations critiques au niveau du système en dehors de son environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Plus d’information au sujet des possibilités et des restrictions de l’utilisateur <code>root</code> sera donnée dans la <a href=#jails-tuning>Optimisation et administration</a> ci-après.</p></div></div></div><div class=sect2><h3 id=jails-build>16.4. Création et contrôle de l’environnement jail<a class=anchor href=#jails-build></a></h3><div class=paragraph><p>Certains administrateurs divisent les environnements jail en deux catégories: les environnements jails "complets", qui ressemblent à un véritable système FreeBSD, et les environnements jails de "service", qui sont dédiés à une application ou un seul service, et tournant éventuellement avec des privilèges. Cette séparation est juste conceptuelle et n’affecte pas la création de l’environnement jail. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> est très claire quant à la procédure de création d’un environnement jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setenv D /here/is/the/jail</span>
<span class=c># mkdir -p $D </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># cd /usr/src</span>
<span class=c># make world DESTDIR=$D </span><i class=conum data-value=2></i><b>(2)</b>
<span class=c># cd etc/ [9]</span>
<span class=c># make distribution DESTDIR=$D </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># mount_devfs devfs $D/dev </span><i class=conum data-value=4></i><b>(4)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Sélectionner un emplacement pour l’environnement est le meilleur point de départ. C’est l’endroit où l’environnement jail se trouvera dans le système de fichiers de la machine hôte. Un bon choix peut être <span class=filename>/usr/jail/jailname</span>, où <em>jailname</em> est le nom de machine identifiant l’environnement jail. Le système de fichiers <span class=filename>/usr/</span> dispose généralement de suffisamment d’espace pour le système de fichiers de l’environnement jail, qui est pour les environnements "complets", essentiellement, une copie de chaque fichier présent dans une installation par défaut du système de base de FreeBSD.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Cette commande peuplera l’arborescence du répertoire choisi comme emplacement pour l’environnement jail avec les binaires, les bibliothèques, les pages de manuel, etc. nécessaires. Tout sera fait selon le style FreeBSD habituel - en premier lieu tout est compilé, puis ensuite installé à l’emplacement voulu.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>La cible <code>distribution</code> pour make installe tous les fichiers de configuration nécessaires. Ou pour faire simple, cette commande installe tous les fichiers installables du répertoire <span class=filename>/usr/src/etc/</span> vers le répertoire <span class=filename>/etc</span> de l’environnement jail: <span class=filename>$D/etc/</span>.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Le montage du système de fichiers <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> à l’intérieur d’un environnement jail n’est pas requis. Cependant, toutes, ou presque toutes les applications nécessitent l’accès à au moins un périphérique, en fonction du rôle de l’application. Il est vraiment important de contrôler l’accès aux périphériques depuis l’intérieur d’un environnement jail, comme un mauvais paramétrage pourrait permettre à quelqu’un de malintentionné de faire de "mauvaises" choses dans l’environnement jail. Le contrôle sur <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> est géré par l’intermédiaire d’un ensemble de règles qui est décrit dans les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a>.</td></tr></tbody></table></div><div class=paragraph><p>Une fois l’environnement jail installé, il peut être lancé en employant l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Cet outil requiert obligatoirement quatre arguments qui sont décrits dans la <a href=#jails-what>Qu’est-ce qu’un environnement jail?</a>. D’autres arguments peuvent également être utilisés, pour par exemple exécuter le processus avec les droits d’un utilisateur particulier. L’argument <code><em>command</em></code> dépend du type d’environnement; pour un <em>système virtuel</em>, <span class=filename>/etc/rc</span> est un bon choix puisque la séquence de démarrage d’un véritable système FreeBSD sera dupliquée. Pour un environnement jail de type <em>service</em>, cela dépendra du service ou de l’application qui sera exécuté dans l’environnement jail.</p></div><div class=paragraph><p>Les environnements jails sont souvent lancés au démarrage de la machine et le système <span class=filename>rc</span> de FreeBSD propose une méthode simple pour cela.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Une liste des environnements jail autorisés à être lancés au démarrage du système devrait être ajoutée au fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;   # Utiliser NO pour désactiver le lancement des environnements jail
jail_list=&#34;www&#34;     # Liste des noms des environnements jail séparés par une espace</pre></div></div></li><li><p>Pour chaque environnement listé dans <code>jail_list</code>, un ensemble de paramètres <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, qui décrivent l’environnement jail, devrait être ajouté:</p><div class="literalblock programlisting"><div class=content><pre>jail_www_rootdir=&#34;/usr/jail/www&#34;     # le répertoire racine de l&#39;environnement jail
jail_www_hostname=&#34;www.example.org&#34;  # le nom de machine de l&#39;environnement jail
jail_www_ip=&#34;192.168.0.10&#34;           # son adresse IP
jail_www_devfs_enable=&#34;YES&#34;          # monter devfs dans l&#39;environnement jail
jail_www_devfs_ruleset=&#34;www_ruleset&#34; # les règles devfs à appliquer à l&#39;environnement jail</pre></div></div><div class=paragraph><p>Le démarrage par défaut des environnements jails, configuré dans <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, exécutera la procédure <span class=filename>/etc/rc</span> de l’environnement jail, ce qui suppose que l’environnement est un système virtuel complet. Pour les environnements jail de service, la commande de démarrage par défaut de l’environnement devrait être modifiée en configurant correctement l’option <code>jail<em>jailname</em>exec_start</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour une liste complète des options disponibles, veuillez consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=paragraph><p>La procedure <span class=filename>/etc/rc.d/jail</span> peut être utilisée pour démarrer ou arrêter un environnement jail à la main si une entrée pour l’environnement existe dans le fichier <span class=filename>rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/jail start www</span>
<span class=c># /etc/rc.d/jail stop www</span></code></pre></div></div><div class=paragraph><p>Il n’existe pas pour le moment de méthode propre pour arrêter un environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. C’est dû au fait que les commandes normalement employées pour arrêter proprement un système ne peuvent être utilisées à l’intérieur d’un environnement jail. La meilleur façon d’arrêter un environnement jail est de lancer la commande suivante à l’intérieur de l’environnement ou en utilisant le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> depuis l’extérieur de l’environnement:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/rc.shutdown</span></code></pre></div></div><div class=paragraph><p>Plus d’information à ce sujet peut être trouvé dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>.</p></div></div><div class=sect2><h3 id=jails-tuning>16.5. Optimisation et administration<a class=anchor href=#jails-tuning></a></h3><div class=paragraph><p>Il existe plusieurs options qui peuvent être configurées pour n’importe quel environnement jail, et de nombreuses manières de combiner un système FreeBSD hôte avec des environnements jail pour donner naissance à des applications haut-niveau. Cette section présente:</p></div><div class=ulist><ul><li><p>Certaines des options disponibles pour l’optimisation du fonctionnement et des restrictions de sécurité implémentées par une installation jail.</p></li><li><p>Des applications de haut niveau pour la gestion des environnements jail, qui sont disponibles dans le catalogue des logiciels portés, et peuvent être utilisées pour implémenter des environnements jail complets.</p></li></ul></div><div class=sect3><h4 id=jails-tuning-utilities>16.5.1. Outils systèmes pour l’optimisation d’un environnement jail sous FreeBSD<a class=anchor href=#jails-tuning-utilities></a></h4><div class=paragraph><p>L’optimisation de la configuration d’un environnement jail se fait principalement par le paramétrage de variables <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Une sous-catégorie spécifique de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> existe pour toutes les options pertinentes: la hiérarchie <code>security.jail.*</code> d’options du noyau FreeBSD. Ci-dessous est donnée une liste des principales variables relatives aux environnements jail avec leur valeur par défaut. Leurs noms sont explicites, mais pour plus d’information, veuillez vous référer aux pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=ulist><ul><li><p><code>security.jail.set_hostname_allowed: 1</code></p></li><li><p><code>security.jail.socket_unixiproute_only: 1</code></p></li><li><p><code>security.jail.sysvipc_allowed: 0</code></p></li><li><p><code>security.jail.enforce_statfs: 2</code></p></li><li><p><code>security.jail.allow_raw_sockets: 0</code></p></li><li><p><code>security.jail.chflags_allowed: 0</code></p></li><li><p><code>security.jail.jailed: 0</code></p></li></ul></div><div class=paragraph><p>Ces variables peuvent être utilisées par l’administrateur du <em>système hôte</em> pour ajouter ou retirer certaines limitations imposées par défaut à l’utilisateur <code>root</code>. Notez que certaines limitations ne peuvent être retirées. L’utilisateur <code>root</code> n’est pas autorisé à monter ou démonter des systèmes de fichiers à partir d’un environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. L’utilisateur <code>root</code> d’un environnement jail ne peut charger ou modifier des règles <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>, paramétrer des règles de pare-feu, ou effectuer des tâches d’administration qui nécessitent la modification de données du noyau, comme le paramétrage du niveau de sécurité <code>securelevel</code> du noyau.</p></div><div class=paragraph><p>Le système de base de FreeBSD contient un ensemble d’outils basiques pour afficher les informations au sujet des environnements jail actifs, pour s’attacher à un environnement jail pour lancer des commandes d’administration. Les commandes <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> font partie du système de base de FreeBSD et peuvent être utilisées pour effectuer les tâches simples suivantes:</p></div><div class=ulist><ul><li><p>Afficher une liste des environnements jail actifs et leur identifiant (JID), leur adresse IP, leur nom de machine et leur emplacement.</p></li><li><p>S’attacher à un environnement jail actif, à partir de son système hôte, et exécuter une commande à l’intérieur de l’environnement ou effectuer des tâches d’administration à l’intérieur de environnement lui-même. C’est tout particulièrement utile quand l’utilisateur <code>root</code> veut arrêter proprement un environnement. L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> peut également être employé pour lancer un interpréteur de commandes dans un environnement jail pour faire de l’administration; par exemple:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 1 tcsh</span></code></pre></div></div></li></ul></div></div><div class=sect3><h4 id=jails-tuning-admintools>16.5.2. Outils d’administration haut niveau du catalogue des logiciels portés de FreeBSD<a class=anchor href=#jails-tuning-admintools></a></h4><div class=paragraph><p>Parmi les nombreux utilitaires tierce-partie pour l’administration des environnements jail, un des plus complet et utile est <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/jailutils/>sysutils/jailutils</a>. C’est un ensemble de petites applications qui aident à la gestion des environnements <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Veuillez consulter sa page Web pour plus d’information.</p></div></div></div></div></div><div class=sect1><h2 id=mac>Chapitre 17. Mandatory Access Control <strong>Traduction en Cours </strong><a class=anchor href=#mac></a></h2><div class=sectionbody><div class=sect2><h3 id=mac-synopsis>17.1. Synopsis<a class=anchor href=#mac-synopsis></a></h3></div><div class=sect2><h3 id=mac-glossary>17.2. Key Terms in this Chapter<a class=anchor href=#mac-glossary></a></h3></div><div class=sect2><h3 id=mac-initial>17.3. Explanation of MAC<a class=anchor href=#mac-initial></a></h3></div><div class=sect2><h3 id=mac-understandlabel>17.4. Understanding MAC Labels<a class=anchor href=#mac-understandlabel></a></h3></div><div class=sect2><h3 id=mac-modules>17.5. Module Configuration<a class=anchor href=#mac-modules></a></h3></div><div class=sect2><h3 id=mac-bsdextended>17.6. The MAC bsdextended Module<a class=anchor href=#mac-bsdextended></a></h3></div><div class=sect2><h3 id=mac-ifoff>17.7. The MAC ifoff Module<a class=anchor href=#mac-ifoff></a></h3></div><div class=sect2><h3 id=mac-portacl>17.8. The MAC portacl Module<a class=anchor href=#mac-portacl></a></h3></div><div class=sect2><h3 id=mac-labelingpolicies>17.9. MAC Policies with Labeling Features<a class=anchor href=#mac-labelingpolicies></a></h3></div><div class=sect2><h3 id=mac-partition>17.10. The MAC partition Module<a class=anchor href=#mac-partition></a></h3></div><div class=sect2><h3 id=mac-mls>17.11. The MAC Multi-Level Security Module<a class=anchor href=#mac-mls></a></h3></div><div class=sect2><h3 id=mac-biba>17.12. The MAC Biba Module<a class=anchor href=#mac-biba></a></h3></div><div class=sect2><h3 id=mac-lomac>17.13. The MAC LOMAC Module<a class=anchor href=#mac-lomac></a></h3></div><div class=sect2><h3 id=mac-implementing>17.14. Implementing a Secure Environment with MAC<a class=anchor href=#mac-implementing></a></h3></div><div class=sect2><h3 id=MAC-examplehttpd>17.15. Another Example: Using MAC to Constrain a Web Server<a class=anchor href=#MAC-examplehttpd></a></h3></div><div class=sect2><h3 id=mac-troubleshoot>17.16. Troubleshooting the MAC Framework<a class=anchor href=#mac-troubleshoot></a></h3></div></div></div><div class=sect1><h2 id=audit>Chapitre 18. Audit des événements relatifs à la sécurité du système<a class=anchor href=#audit></a></h2><div class=sectionbody><div class=sect2><h3 id=audit-synopsis>18.1. Synopsis<a class=anchor href=#audit-synopsis></a></h3><div class=paragraph><p>FreeBSD dispose d’un support pour l’audit d’événements relatifs à la sécurité du système. L’audit d’événements permet un enregistrement fiable et configurable d’une grande variété d’événements système en rapport avec la sécurité, parmi lesquels les ouvertures de session, les modifications de la configuration, et les accès aux fichiers et au réseau. Ces enregistrements ou journaux peuvent être d’une très grande aide pour la surveillance d’un système, pour la détection d’intrusion, et les analyses post-mortem. FreeBSD implémente l’API et le format de fichiers BSM (<em>Basic Security Module</em>) publiés par Sun™ qui sont interopérables avec les implémentations d’audits de Solaris™ de Sun™ et de Mac OS® X d’Apple®.</p></div><div class=paragraph><p>Ce chapitre se concentre sur l’installation et la configuration de l’audit des événements. Il explique les stratégies utilisées pour l’audit, et propose un exemple de configuration.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Ce qu’est l’audit d’événements et comment cela fonctionne.</p></li><li><p>Comment configurer l’audit d’événements sous FreeBSD pour les utilisateurs et les processus.</p></li><li><p>Comment lire une trace d’audit en utilisant les outils de réduction et de lecture.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les fondements d’UNIX® et de FreeBSD (<a href=./#basics>Quelques bases d’UNIX</a>).</p></li><li><p>Etre familier avec la configuration et la compilation du noyau (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li><li><p>Avoir quelques notions de sécurité et savoir comment les appliquer à FreeBSD (<a href=./#security>Sécurité</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>La fonctionnalité d’audit connaît des limitations. Tous les événements systèmes en rapport avec la sécurité ne peuvent pas être soumis à un audit, et que certains mécanismes d’ouverture de session, comme les gestionnaires de procédures de connexions basés sur Xorg et des "démons" tiers, ne permettent pas une configuration correcte de l’audit pour les ouvertures de session utilisateur.</p></div><div class=paragraph><p>Le système d’audit des événements permet la génération d’enregistrements détaillés de l’activité du système. Sur un système occupé, un fichier journal d’audit peut être très important quand le système est configuré pour un haut niveau de détail, dépassant plusieurs gigaoctets par semaine sur certaines configurations. Les administrateurs système devraient prendre en compte les besoins en espace disque associés avec les configurations d’audit à haut niveau de détail. Par exemple, il peut être recommandé de dédier un système de fichiers à <span class=filename>/var/audit</span> de manière à ce que les autres systèmes de fichiers ne soient pas affectés si le système de fichiers pour les audits est plein.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=audit-inline-glossary>18.2. Mots-clés<a class=anchor href=#audit-inline-glossary></a></h3><div class=paragraph><p>Les termes suivants sont relatifs à l’audit des événements:</p></div><div class=ulist><ul><li><p><em>événement</em>: un événement pouvant être audité est n’importe quel événement pouvant faire l’objet d’un suivi par le système d’audit. La création d’un fichier, la mise en place d’une connection réseau, ou une ouverture de session sont des exemples d’événements relatifs à la sécurité. Les événements sont considérés soit comme "attribuables", quand on peut les relier à un utilisateur authentifié, soit "non-attribuables" quand on ne peut pas les relier à un utilisateur authentifié. Des événements comme ceux qui apparaissent avant l’authentification durant le processus d’ouverture de session, tels que les tentatives avec un mauvais mot de passe, sont des exemples d’événements non-attribuables.</p></li><li><p><em>classe</em>: désigne à l’aide d’un nom particulier des ensembles d’événements en rapport les uns avec les autres et sont utilisées dans les expressions de sélection des événements. Les classes d’événement généralement utilisées sont la "création de fichiers" (fc) l'"exécution" (ex) et l'"ouverture/fermeture de session" (lo).</p></li><li><p><em>enregistrement</em>: une entrée du fichier de trace d’audit décrivant un événement relatif à la sécurité. Les enregistrements contiennent le type d’événement, des informations sur l’auteur (l’utilisateur) de l’action, la date et l’heure, des informations sur tout objet ou argument en relation avec l’action, et une condition de succès ou d’échec.</p></li><li><p><em>trace d’audit</em>: un fichier journal consistant en une série d’enregistrements décrivant les événements relatifs à la sécurité. Les traces sont organisées de manière chronologiques par rapport à l’horaire de fin des événements. Seuls les processus autorisés peuvent ajouter des enregistrements aux fichiers journaux d’audit.</p></li><li><p><em>expression de sélection</em>: une chaîne de caractères contenant une liste de préfixes et de classes d’événement d’audit utilisés pour désigner des événements.</p></li><li><p><em>préselection</em>: le processus par lequel le système identifie quels événements intéressent l’administrateur. La configuration de la présélection utilise une série d’expressions de sélection pour déterminer quelles classes d’événement sont à auditer et pour quels utilisateurs, ainsi que le paramétrage global qui s’applique aux processus authentifiés et non-authentifiés.</p></li><li><p><em>réduction</em>: le processus par lequel les enregistrements de traces d’audit existantes sont sélectionnés pour être conservés, imprimés ou analysés. Ou encore le processus qui supprime de la trace d’audit les enregistrements non-désirés. En utilisant le principe de réduction, les administrateurs peuvent mettre en place des stratégies pour la conservation des données d’audit. Par exemple, les traces d’audit détaillées peuvent être conservées pendant un mois, mais passé ce délai, les traces seront réduites afin de ne préserver pour archivage que les informations relatives aux ouvertures de sessions.</p></li></ul></div></div><div class=sect2><h3 id=audit-config>18.3. Configuration de l’audit<a class=anchor href=#audit-config></a></h3><div class=paragraph><p>Le support pour l’audit des événements est installé avec le système de base de FreeBSD. Le support présent dans le noyau <span class=filename>GENERIC</span> par défaut, et <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> peut être activé en ajoutant la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>auditd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Puis, le daemon d’audit peut être lancé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service auditd start</span></code></pre></div></div><div class=paragraph><p>Les utilisateurs préférant compiler un noyau sur mesure doivent ajouter la ligne suivante dans le fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options     AUDIT</pre></div></div><div class=sect3><h4 id=_expressions_de_sélection_des_événements>18.3.1. Expressions de sélection des événements<a class=anchor href=#_expressions_de_sélection_des_événements></a></h4><div class=paragraph><p>Les expressions de sélection sont utilisées à plusieurs endroits dans la configuration du système d’audit pour déterminer quels événements doivent être suivis. Les expressions contiennent une liste de classes d’événements devant correspondre. Les expressions de sélection sont évaluées de gauche à droite, et deux expressions sont combinées en ajoutant l’une à la suite de l’autre.</p></div><div class=paragraph><p><a href=#event-selection>Classes d’événements par défaut</a> résume les classes d’événements présentes par défaut</p></div><table id=event-selection class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 4. Classes d’événements par défaut</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Classe</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Action</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>tout</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>correspond à toutes les classes d’événements.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>aa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>authentification et autorisation</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ad</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>administration</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Actions d’administration du système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>application</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Action définie par l’application.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>fermeture de fichiers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les utilisations de l’appel système <code>close</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ex</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>exécution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les exécutions de programmes. L’audit des arguments en ligne de commande et des variables d’environnement est contrôlé par via <a href="https://man.freebsd.org/cgi/man.cgi?query=audit_control&amp;sektion=5&amp;format=html">audit_control(5)</a> en utilisant les paramètres <code>argv</code> et <code>envv</code> pour l’entrée <code>policy</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>accès à aux attributs des fichiers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>enregistre l’accès aux attributs des objets comme <a href="https://man.freebsd.org/cgi/man.cgi?query=stat&amp;sektion=1&amp;format=html">stat(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pathconf&amp;sektion=2&amp;format=html">pathconf(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>création de fichiers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements ayant pour résultat la création d’un fichier.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>suppression de fichiers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements pour lesquels une suppression de fichier a lieu.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>modification des attributs d’un fichier</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements lors desquels une modification des attributs d’un fichier intervient, comme l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=flock&amp;sektion=2&amp;format=html">flock(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fr</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lecture de fichiers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements qui donnent lieu à la lecture de données, l’ouverture de fichiers pour la lecture.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fw</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>écriture de fichiers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements qui donnent lieu à l’écriture de données ou à l’écriture ou la modification de fichiers.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>io</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ioctl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre l’utilisation de l’appel système <code>ioctl</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ip</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ipc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les différentes utilisations de communication inter-processus, dont les utilisations des tubes POSIX et les opérations IPC Système V.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>login_logout</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les ouvertures et fermeture de session (<a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=logout&amp;sektion=1&amp;format=html">logout(1)</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>na</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>non attributable</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements non-attribuables.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>no</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>classe invalide</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ne correspond à aucun des événements surveillés.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nt</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>réseau</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements relatifs au réseau, comme l’utilisation des fonctions <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>autre</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements divers.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>pc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>processus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les opérations sur les processus, comme l’utilisation des fonctions <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>.</p></td></tr></tbody></table><div class=paragraph><p>Ces classes d’événement peuvent être personnalisées en modifiant les fichiers de configuration <span class=filename>audit_class</span> et <span class=filename>audit_event</span>.</p></div><div class=paragraph><p>Chaque classe d’audit peut être combinée avec un préfixe indiquant si les opérations réussies/échouées sont sélectionnées, et si l’entrée ajoute ou supprime une sélection pour la classe ou le type concerné. <a href=#event-prefixes>Prefixes pour les classes d’audit</a> résume les préfixes disponibles.</p></div><table id=event-prefixes class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 5. Prefixes pour les classes d’audit</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Prefixe</th><th class="tableblock halign-left valign-top">Action</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements réussis de cette classe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enregistre les événements de cette classe qui ont échoué.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N’enregistre ni les événements réussis ni les échecs de cette classe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ne pas enregistrer les événements réussis de cette classe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ne pas enregistrer les événements de cette classe qui ont échoué.</p></td></tr></tbody></table><div class=paragraph><p>Si aucun préfixe n’est présent, les succès et le échecs de l’événement seront enregistrés.</p></div><div class=paragraph><p>L’exemple suivant d’expression de sélection permet la sélection des ouvertures et fermetures de session réussies ou échouées, et uniquement les exécutions ayant réussies:</p></div><div class="literalblock programlisting"><div class=content><pre>lo,+ex</pre></div></div></div><div class=sect3><h4 id=_fichiers_de_configuration>18.3.2. Fichiers de configuration<a class=anchor href=#_fichiers_de_configuration></a></h4><div class=paragraph><p>Les fichiers de configuration suivants pour l’audit d’événements en rapport avec la sécurité se trouvent dans le répertoire <span class=filename>/etc/security</span>.</p></div><div class=ulist><ul><li><p><span class=filename>audit_class</span>: contient les définitions des classes d’audit.</p></li><li><p><span class=filename>audit_control</span>: contrôle les caractéristiques du système d’audit comme les classes d’audit par défaut, l’espace disque minimal à conserver sur le volume réservé aux journaux, la taille maximale des traces d’audit.</p></li><li><p><span class=filename>audit_event</span>: les noms et la description des événements systèmes audités ainsi qu’une liste de classes auxquelles appartiennent chaque événement.</p></li><li><p><span class=filename>audit_user</span>: les classes d’événement à auditer pour des utilisateurs spécifiques, qui s’ajoutent aux paramètres généraux fixés par défaut à l’ouverture de session.</p></li><li><p><span class=filename>audit_warn</span>: une procédure modifiable utilisée par <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> pour générer des messages d’alerte lors des situations exceptionnelles comme un espace disque faible pour les fichiers journaux d’audit ou quand il y a eu rotation de ces fichiers journaux.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Les fichiers de configuration de l’audit devraient être modifiés et gérés avec prudence étant donné que des erreurs dans la configuration pourraient donner lieu à un enregistrement incorrect des événements.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dans la plupart des cas, les administrateurs ne devront modifier que <span class=filename>audit_control</span> et <span class=filename>audit_user</span>. Le premier contrôle les propriétés et les stratégies au niveau du système et le second peut être utilisé pour affiner l’audit pour chaque utilisateur.</p></div><div class=sect4><h5 id=audit-auditcontrol>18.3.2.1. Le fichier <span class=filename>audit_control</span><a class=anchor href=#audit-auditcontrol></a></h5><div class=paragraph><p>Un certain nombre de paramètres par défaut pour le système d’audit sont spécifiés dans le fichier <span class=filename>audit_control</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dir:/var/audit
dist:off
flags:lo,aa
minfree:5
naflags:lo,aa
policy:cnt,argv
filesz:2M
expire-after:10M</pre></div></div><div class=paragraph><p>L’option <code>dir</code> est utilisée pour déclarer un ou plusieurs répertoires dans lesquels seront stockés les fichiers journaux. Si l’on mentionne plus d’un répertoire, ces derniers seront utilisés dans l’ordre à mesure qu’ils se remplissent. Il est classique de configurer le système d’audit pour le stockage des fichiers journaux sur un système de fichiers dédié, afin d’éviter toute interférence entre le système d’audit et d’autres systèmes si le système de fichiers est plein.</p></div><div class=paragraph><p>Si le champ <code>dist</code> est fixé à <code>on</code> ou <code>yes</code>, des liens matériel seront créés pour tous les fichiers de trace d’audit de <span class=filename>/var/audit/dist</span>.</p></div><div class=paragraph><p>Le champ <code>flags</code> fixe le masque général de présélection utilisé par défaut pour les événements attribuables. Dans l’exemple ci-dessus, les ouvertures et fermetures de sessions réussies ou échouées ainsi que les authentifications et autorisations sont enregistrées pour tous les utilisateurs.</p></div><div class=paragraph><p>L’option <code>minfree</code> définit le pourcentage minimal d’espace libre du système de fichiers sur lequel les traces d’audit sont stockées.</p></div><div class=paragraph><p>L’entrée <code>naflags</code> indique les classes à surveiller pour les événements non-attribués, comme les processus d’ouverture et de fermeture de session et les authentifications et autorisations.</p></div><div class=paragraph><p>L’entrée <code>policy</code> donne une liste d’indicateurs de stratégie contrôlant divers aspect du comportement de l’audit séparés par une virgule. L’indicateur <code>cnt</code> indique que le système devrait continuer à fonctionner en dépit d’un échec dans l’audit (l’emploi de cet indicateur est hautement recommandé). L’autre indicateur <code>argv</code>, provoque l’audit des arguments passés à l’appel système <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> lors de l’audit de l’exécution des commandes.</p></div><div class=paragraph><p>L’entrée <code>filez</code> indique la taille maximale en octets autorisée pour un fichier de trace avant qu’il soit interrompu et que le système provoque sa rotation. La valeur par défaut, <code>0</code>, désactive la rotation automatique des journaux. Si la taille de fichier est inférieure à 512K, elle sera ignorée et un message sera généré.</p></div><div class=paragraph><p>Le champ <code>expire-after</code> indique quand un fichier de trace expirera et sera supprimé.</p></div></div><div class=sect4><h5 id=audit-audituser>18.3.2.2. Le fichier <span class=filename>audit_user</span><a class=anchor href=#audit-audituser></a></h5><div class=paragraph><p>L’administrateur peut spécifier des exigences supplémentaires qu niveau de l’audit pour des utilisateurs spécifiques dans le fichier <span class=filename>audit_user</span>. Chaque ligne paramètre l’audit pour un utilisateur par l’intermédiaire de deux champs: le champ <code>alwaysaudit</code>, qui indique l’ensemble des événements qui devraient toujours être surveillés pour l’utilisateur, le champ, <code>neveraudit</code>, indique un ensemble d’événements qui ne devrait jamais être audité pour cet utilisateur.</p></div><div class=paragraph><p>L’exemple suivant d’entrées permet le suivi des ouvertures et fermetures de sessions et l’exécution de commandes avec succès de l’utilisateur <code>root</code>, et audite la création de fichiers et l’exécution de commandes avec succès pour l’utilisateur <code>www</code>. Si utilisé avec le fichier <span class=filename>audit_control</span> par défaut, l’entrée <code>lo</code> pour <code>root</code> est redondante, et les événements relatifs aux ouvertures et aux fermetures de sessions seront également enregistrés pour l’utilisateur <code>www</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>root:lo,+ex:no
www:fc,+ex:no</pre></div></div></div></div></div><div class=sect2><h3 id=audit-administration>18.4. Travailler avec les traces d’audit<a class=anchor href=#audit-administration></a></h3><div class=paragraph><p>Etant donné que les traces d’audit sont stockées sous le format binaire BSM ("Basic Security Module"), plusieurs outils sont disponibles pour modifier ou convertir en texte ces fichiers de trace. Pour convertir les fichiers de trace en en texte simple, utiliser la commande <code>praudit</code>. Pour réduire le fichier de trace en vue d’une analyse, d’un archivage, ou d’une impression, utiliser la commande <code>auditreduce</code>. Cet utilitaire supporte une variété de paramètres de sélection, parmi lesquels le type d’événement, la classe de l’événement, l’utilisateur, la date ou l’heure de l’événement, et le chemin d’accès ou l’objet sur lequel on agit.</p></div><div class=paragraph><p>Par exemple, pour afficher sous forme de texte brut l’intégralité du contenu du fichier journal d’audit précisé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /var/audit/AUDITFILE</span></code></pre></div></div><div class=paragraph><p>Où <em>AUDITFILE</em> est le journal à afficher.</p></div><div class=paragraph><p>Les traces d’audit consistent en une série d’enregistrements constitués de champs que la commande <code>praudit</code> affiche de manière séquentielle, un par ligne. Chaque champ est spécifique, comme <code>header</code> (l’entête de l’enregistrement), ou <code>path</code> (le chemin d’accès). Ce qui suit est un exemple d’événement <code>execve</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec
exec arg,finger,doug
path,/usr/bin/finger
attribute,555,root,wheel,90,24918,104944
subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
return,success,0
trailer,133</pre></div></div><div class=paragraph><p>Cet audit représente un appel réussi à <code>execve</code>, lors de l’exécution de la commande <code>finger doug</code>. Le champ <code>exec arg</code> contient la ligne de commande présentée par l’interpréteur de commandes au noyau. Le champ <code>path</code> contient le chemin d’accès à l’exécutable comme le voit le noyau. Le champ <code>attribute</code> décrit le binaire et précise les permissions sur le fichier. Le champ <code>subject</code> conserve l’identifiant (ID) de l’utilisateur audité, les identifiants groupe et utilisateur effectifs, les identifiants groupe et utilisateur réels, l’ID du processus, l’ID de la session, l’ID du port, et l’adresse correspondant à la session. Notez que l’ID de l’utilisateur pour l’audit diffère de l’ID réel de l’utilisateur étant donné que l’utilisateur <code>robert</code> est passé en <code>root</code> avant l’exécution de la commande, mais l’audit se fait par rapport à l’utilisateur authentifié original. Le champ <code>return</code> indique la réussite de l’exécution et le champ <code>trailer</code> termine l’enregistrement.</p></div><div class=paragraph><p>Le format de sortie XML est également supporté et peut être sélectionné en utilisant l’argument <code>-x</code>.</p></div><div class=paragraph><p>Comme les journaux d’audit peuvent être très gros, un sous-ensemble d’enregistrements peut être sélectionné en utilisant <code>auditreduce</code>. Cet exemple sélectionne tous les enregistrements produits pour l’utilisateur <code>trhodes</code> et stockés dans le fichier <em>AUDITFILE</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># auditreduce -u trhodes /var/audit/AUDITFILE | praudit</span></code></pre></div></div><div class=paragraph><p>Les membres du groupe <code>audit</code> sont autorisés à lire les traces d’audit présentes dans le répertoire <span class=filename>/var/audit</span>. Par défaut, ce groupe est vide, par conséquent seul l’utilisateur <code>root</code> peut lire les traces d’audit. Des utilisateurs peuvent être ajoutés au groupe <code>audit</code> afin de déléguer les droits de lecture des audits. Comme la possibilité de suivre le contenu des fichiers journaux de l’audit donne un aperçu significatif du comportement des utilisateurs et des processus, il est donc recommandé de déléguer avec prudence les droits de lecture des audits.</p></div><div class=sect3><h4 id=_surveillance_en_direct_à_laide_de_tubes_daudit>18.4.1. Surveillance en direct à l’aide de tubes d’audit<a class=anchor href=#_surveillance_en_direct_à_laide_de_tubes_daudit></a></h4><div class=paragraph><p>Les tubes ("pipes") d’audit sont des pseudo-périphériques "clonables" qui autorisent aux applications l’accès au flux d’enregistrement des audits en cours. C’est de tout premier intérêt pour les auteurs d’applications de détection des intrusions et de surveillance du système. Cependant, le tube d’audit est un moyen pratique pour l’administrateur pour autoriser la surveillance en direct sans avoir à faire face aux problèmes de permissions ou de rotation des fichiers journaux interrompant le flux des enregistrements des événements. Pour suivre le flux des enregistrements de l’audit en cours:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /dev/auditpipe</span></code></pre></div></div><div class=paragraph><p>Par défaut, les fichiers spéciaux de périphériques correspondant aux tubes d’audit ne sont accessibles qu’à l’utilisateur <code>root</code>. Pour les rendre accessibles aux membres du groupe <code>audit</code>, ajoutez une règle <code>devfs</code> au fichier <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;auditpipe*&#39; mode 0440 group audit</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> pour plus d’information sur la configuration du système de fichiers devfs.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Il est relativement simple de produire un effet de boucle sans fin, dans lequel la consultation de chaque événement enregistré par le système d’audit provoque la génération de nouveaux événements d’audit. Par exemple, si toutes les entrées/sorties réseau sont surveillées, et que <code>praudit</code> est exécuté depuis une session SSH, alors un flux continu d’événements sera généré suivant une fréquence importante, chaque événement affiché générant un autre événement. Pour cette raison, il est recommandé d’exécuter <code>praudit</code> sur un tube par l’intermédiaire de sessions sans surveillance précise des entrées/sorties.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_rotation_et_compression_des_fichiers_de_trace_daudit>18.4.2. Rotation et compression des fichiers de trace d’audit<a class=anchor href=#_rotation_et_compression_des_fichiers_de_trace_daudit></a></h4><div class=paragraph><p>Les traces d’audit sont écrites par le noyau, et sont gérées par le "démon" d’audit, <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a>. Les administrateurs ne devraient donc pas tenter d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> ou tout autre outil pour assurer la rotation directe des journaux d’audit. A la place, l’utilitaire <code>audit</code> devrait être employé pour stopper l’audit, reconfigurer le système d’audit et effectuer la rotation des journaux. La commande suivante provoque la création d’un nouveau fichier journal d’audit par le "démon" et signale au noyau d’utiliser le nouveau fichier pour les enregistrements. L’ancien fichier journal sera fermé et renommé et pourra, à partir de cet instant, être manipulé par l’administrateur:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># audit -n</span></code></pre></div></div><div class=paragraph><p>Si <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> ne tourne pas, cette commande échouera et un message d’erreur sera généré.</p></div><div class=paragraph><p>Ajouter la ligne suivante au fichier <span class=filename>/etc/crontab</span> provoquera cette rotation toutes les douze heures:</p></div><div class="literalblock programlisting"><div class=content><pre>0     */12       *       *       *       root    /usr/sbin/audit -n</pre></div></div><div class=paragraph><p>La modification sera prise en compte une fois que aurez sauvegardé le fichier <span class=filename>/etc/crontab</span>.</p></div><div class=paragraph><p>La rotation automatique du fichier d’une trace d’audit basée sur la taille du fichier est possible à l’aide de l’option <code>filesz</code> de <span class=filename>audit_control</span> comme décrit dans <a href=#audit-auditcontrol>Le fichier <span class=filename>audit_control</span></a>.</p></div></div><div class=sect3><h4 id=_compresser_les_traces_daudit>18.4.3. Compresser les traces d’audit<a class=anchor href=#_compresser_les_traces_daudit></a></h4><div class=paragraph><p>Les fichiers de trace d’audit peuvent devenir très gros, il est souvent désirable de les compresser ou sinon de les archiver une fois qu’ils ont été fermés par le "démon" d’audit. La procédure <span class=filename>audit_warn</span> peut être employée pour effectuer des opérations personnalisées pour une variété d’événements relatifs à l’audit, y compris l’arrêt propre des traces d’audit lors de leur rotation. Par exemple, ce qui suit peut être ajouté au fichier <span class=filename>/etc/security/audit_warn</span> pour compresser les traces d’audit à leur fermeture:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Compression des fichiers de trace d&#39;audit à leur fermeture.
#
if [ &#34;$1&#34; = closefile ]; then
        gzip -9 $2
fi</pre></div></div><div class=paragraph><p>D’autres activités d’archivage pourront inclure la copie des fichiers de trace vers un serveur central, la suppression d’anciennes traces, ou la réduction des traces pour supprimer les enregistrements inutiles. Cette procédure ne sera exécutée que lorsque les fichiers de trace d’audit auront été proprement arrêtés, et ne sera pas exécutée sur les traces interrompues en cours d’utilisation suite à un arrêt incorrect du système.</p></div></div></div></div></div><div class=sect1><h2 id=disks>Chapitre 19. Stockage des données<a class=anchor href=#disks></a></h2><div class=sectionbody><div class=sect2><h3 id=disks-synopsis>19.1. Synopsis<a class=anchor href=#disks-synopsis></a></h3><div class=paragraph><p>Ce chapitre couvre l’utilisation des disques sous FreeBSD. Cela comprend les disques mémoire, les disques réseau, les périphériques standards de stockage SCSI/IDE, et les périphériques utilisant l’interface USB.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>La terminologie qu’utilise FreeBSD pour décrire l’organisation des données sur un disque physique (les partitions et les tranches).</p></li><li><p>Comment ajouter des disques durs supplémentaires sur votre système.</p></li><li><p>Comment configurer FreeBSD pour l’utilisation de périphériques de stockage USB.</p></li><li><p>Comment configurer des systèmes de fichiers virtuels, comme les disques mémoires.</p></li><li><p>Comment utiliser les quotas pour limiter l’usage de l’espace disque.</p></li><li><p>Comment chiffrer des disques pour les sécuriser contre les attaques.</p></li><li><p>Comment créer et graver des CDs et DVDs sous FreeBSD.</p></li><li><p>Les différents supports disponibles pour les sauvegardes.</p></li><li><p>Comment utiliser les programmes de sauvegarde disponibles sous FreeBSD.</p></li><li><p>Comment faire des sauvegardes sur disquettes.</p></li><li><p>Ce que sont les "snapshots" (instantanés) de systèmes de fichiers et comment les utiliser efficacement.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Savoir comment configurer et installer un nouveau noyau FreeBSD (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=disks-naming>19.2. Noms des périphériques<a class=anchor href=#disks-naming></a></h3><div class=paragraph><p>Ce qui suit est une liste des périphériques de stockage physiques, et des noms de périphériques associés.</p></div><table id=disk-naming-physical-table class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 6. Conventions de nom pour les disques physiques</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Type de disque</th><th class="tableblock halign-left valign-top">Nom du périphérique</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Disques durs IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Lecteurs de CDROMs IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Disques durs SCSI et périphériques de stockage USB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Lecteurs de CDROMs SCSI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mcd</code> pour les CD-ROMs Mitsumi, <code>scd</code> pour les CD-ROMs Sony</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Lecteurs de disquette</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Lecteurs de bande SCSI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Lecteurs de bande IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ast</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Disques flash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fla</code> pour les périphériques Flash DiskOnChip®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Disques RAID</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>aacd</code> pour l’AdvancedRAID Adaptec®, <code>mlxd</code> et <code>mlyd</code> pour les Mylex®, <code>amrd</code> le MegaRAID® d’AMI, <code>idad</code> pour le Smart RAID de Compaq, <code>twed</code> pour le 3ware® RAID.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disks-adding>19.3. Ajouter des disques<a class=anchor href=#disks-adding></a></h3><div class=paragraph><p>Supposons que nous voulions ajouter un second disque SCSI à une machine qui n’a pour l’instant qu’un seul disque. Commençons par arrêter l’ordinateur et installer le disque en suivant les instructions données par le constructeur de l’ordinateur, du contrôleur et du disque. Comme il y a de nombreuses façon de procéder, ces détails dépassent le cadre de ce document.</p></div><div class=paragraph><p>Ouvrons maintenant une session sous le compte <code>root</code>. Après avoir installé le disque, consultez le fichier <span class=filename>/var/run/dmesg.boot</span> pour vérifier que le nouveau disque a été reconnu. Dans notre exemple, le disque que nous venons d’ajouter sera le périphérique <span class=filename>da1</span> et nous le monterons sur le répertoire <span class=filename>/1</span> (si vous ajoutez un disque IDE, le nom de périphérique sera <span class=filename>ad1</span>).</p></div><div class=paragraph><p>FreeBSD tourne sur des ordinateurs compatibles IBM-PC, il doit tenir compte des partitions PC BIOS. Ces dernières sont différentes des partitions BSD traditionnelles. Un disque PC peut avoir jusqu’à quatre partitions. Si le disque va être réservé uniquement à FreeBSD, vous pouvez utiliser le mode <em>dédié</em>. Sinon, FreeBSD devra utiliser une des partitions PC BIOS. FreeBSD appelle les partitions PC BIOS <em>tranches</em> ("slices") pour les distinguer des partitions BSD traditionnelles. Vous pouvez aussi des tranches sur un disque dédié à FreeBSD, mais utilisé sur une machine où un autre système d’exploitation est également installé. C’est une bonne manière pour éviter de perturber l’utilitaire <code>fdisk</code> des autres système d’exploitation différents de FreeBSD.</p></div><div class=paragraph><p>Dans le cas d’une tranche, le disque ajouté deviendra le périphérique <span class=filename>/dev/da1s1e</span>. Ce qui se lit: disque SCSI, numéro d’unité 1 (second disque SCSI), tranche 1 (partition PC BIOS 1), et partition BSD <span class=filename>e</span>. Dans le cas du mode dédié, le disque sera ajouté en tant que <span class=filename>/dev/da1e</span>.</p></div><div class=paragraph><p>En raison de l’utilisation d’entiers codés sur 32 bits pour stocker le nombre de secteurs, <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> est limité à 2^32-1 secteurs par disque ou 2TB dans la plupart des cas. Le format <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> n’autorise pas de secteur au delà de 2^32-1 et une largeur de plus de 2^32-1, limitant donc les partitions à 2TB et les disques à 4TB en général. Le format <a href="https://man.freebsd.org/cgi/man.cgi?query=sunlabel&amp;sektion=8&amp;format=html">sunlabel(8)</a> est limité à 2^32-1 secteur par partition et 8 partitions pour un total de 16TB d’espace. Pour des disques plus importants, les partitions <a href="https://man.freebsd.org/cgi/man.cgi?query=gpt&amp;sektion=8&amp;format=html">gpt(8)</a> peuvent être utilisées.</p></div><div class=sect3><h4 id=_utiliser_sysinstall8>19.3.1. Utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a><a class=anchor href=#_utiliser_sysinstall8></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Naviguer dans sysinstall</p><div class=paragraph><p>Vous pouvez utiliser <code>sysinstall</code> et ses menus simples d’emploi pour partitionner et libeller le nouveau disque. Ouvrez une session sous le compte super-utilisateur <code>root</code> ou utilisez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Lancez <code>sysinstall</code> et sélectionnez <span class=guimenuitem>Configure</span>. A l’intérieur du menu <span class=guimenuitem>FreeBSD Configuration Menu</span>, descendez et sélectionnez l’option <span class=guimenuitem>Fdisk</span>.</p></div></li><li><p>L’éditeur de partition fdisk</p><div class=paragraph><p>Une fois dans l’utilitaire fdisk, nous pouvons taper <kbd>A</kbd> pour utiliser tout le disque pour FreeBSD. Lorsque l’on vous demande si vous voulez garder la possibilité de pouvoir coopérer avec d’autres systèmes d’exploitation ("remain cooperative with any future possible operating systems"), répondez par l’affirmative (<code>YES</code>). Enregistrez les modifications sur le disque avec <kbd>W</kbd>. Quittez maintenant l’éditeur fdisk en tapant <kbd>q</kbd>. La prochaine question concernera le secteur de démarrage ("Master Boot Record"). Comme vous ajoutez un disque à un système déjà opérationnel, choisissez <b class=button>None</b>.</p></div></li><li><p>L’éditeur de label du disque</p><div class=paragraph><p>Ensuite, vous devez quitter puis relancer sysinstall. Suivez les instructions précédentes, en choisissant cette fois l’option <span class=guimenuitem>Label</span>. Vous entrerez dans l’éditeur de label du disque (<code>Disk Label Editor</code>). C’est là que vous allez créer les partitions BSD traditionnelles. Un disque peut avoir jusqu’à huit partitions, libellées de <code>a</code> à <code>h</code>. Certains de ces labels ont des significations particulières. La partition <code>a</code> est la partition racine (<span class=filename>/</span>). Seul votre disque système (e.g., celui à partir duquel vous démarrez) doit avoir une partition <code>a</code>. La partition <code>b</code> est utilisée pour la pagination, vous pouvez avoir plusieurs disques avec des partitions de pagination. La partition <code>c</code> désigne la totalité du disque en mode dédié, ou toute la tranche FreeBSD dans le cas contraire. Les autres partitions sont à usage général.</p></div><div class=paragraph><p>L’éditeur de label de sysinstall définit par défaut la partition <code>e</code> comme première partition qui n’est ni racine, ni de pagination. Dans l’éditeur de label, créez un seul système de fichiers avec l’option <kbd>C</kbd>. Quand on vous demande si ce sera un système de fichiers (FS) ou une partition de pagination, choisissez <code>FS</code> et indiquez un point de montage (e.g., <span class=filename>/mnt</span>). Lorsque vous ajoutez un disque sur un système déjà installé, sysinstall ne créera pas d’entrées dans <span class=filename>/etc/fstab</span>, donc le nom que vous donnez au point de montage n’a pas d’importance.</p></div><div class=paragraph><p>Vous pouvez maintenant écrire le nouveau label sur le disque et y créer un système de fichiers. Faites-le en tapant <kbd>W</kbd>. Ignorez les erreurs de sysinstall disant que la nouvelle partition ne peut être montée. Quittez maintenant l’éditeur de label et sysinstall.</p></div></li><li><p>Dernière étape</p><div class=paragraph><p>La dernière étape consiste à éditer le fichier <span class=filename>/etc/fstab</span> pour y ajouter une entrée pour votre nouveau disque.</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=_utiliser_les_utilitaires_en_ligne_de_commande>19.3.2. Utiliser les utilitaires en ligne de commande<a class=anchor href=#_utiliser_les_utilitaires_en_ligne_de_commande></a></h4><div class=sect4><h5 id=_utiliser_les_tranches_slices>19.3.2.1. Utiliser les tranches - "slices"<a class=anchor href=#_utiliser_les_tranches_slices></a></h5><div class=paragraph><p>Cette configuration permettra de faire fonctionner correctement votre disque dure avec d’autres systèmes d’exploitation qui pourraient être installé sur votre machine, et ne perturbera pas les utilitaires <code>fdisk</code> de ces autres systèmes d’exploitation. C’est la méthode recommandée pour l’installation de nouveau disques. N’utilisez le mode <em>dédié</em> que si vous avez une bonne raison de le faire!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 bs=1k count=1</span>
<span class=c># fdisk -BI da1 #Initialize your new disk</span>
<span class=c># bsdlabel -B -w da1s1 auto #Label it.</span>
<span class=c># bsdlabel -e da1s1 # Edit the disklabel just created and add any partitions.</span>
<span class=c># mkdir -p /1</span>
<span class=c># newfs /dev/da1s1e # Repeat this for every partition you created.</span>
<span class=c># mount /dev/da1s1e /1 # Mount the partition(s)</span>
<span class=c># vi /etc/fstab # Add the appropriate entry/entries to your /etc/fstab.</span></code></pre></div></div><div class=paragraph><p>Si vous avez un disque IDE, remplacez <span class=filename>da</span> par <span class=filename>ad</span>.</p></div></div><div class=sect4><h5 id=_mode_dédié>19.3.2.2. Mode dédié<a class=anchor href=#_mode_dédié></a></h5><div class=paragraph><p>Si le nouveau disque n’est pas destiné a être partagé avec un autre système d’exploitation, vous pouvez utiliser le mode <em>dédié</em>. Rappelez-vous que ce mode peut perturber les systèmes d’exploitation Microsoft; cependant, ils ne toucheront pas au disque. OS/2® d’IBM, au contraire, "s’approprie" toute partition qu’il trouve et ne reconnaît pas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 bs=1k count=1</span>
<span class=c># bsdlabel -Bw da1 auto</span>
<span class=c># bsdlabel -e da1				# create the `e&#39; partition</span>
<span class=c># newfs -d0 /dev/da1e</span>
<span class=c># mkdir -p /1</span>
<span class=c># vi /etc/fstab				# add an entry for /dev/da1e</span>
<span class=c># mount /1</span></code></pre></div></div><div class=paragraph><p>Un autre méthode est:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 count=2</span>
<span class=c># bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin</span>
<span class=c># newfs /dev/da1e</span>
<span class=c># mkdir -p /1</span>
<span class=c># vi /etc/fstab					# add an entry for /dev/da1e</span>
<span class=c># mount /1</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=raid>19.4. RAID<a class=anchor href=#raid></a></h3><div class=sect3><h4 id=raid-soft>19.4.1. RAID logiciel<a class=anchor href=#raid-soft></a></h4><div class=sect4><h5 id=ccd>19.4.1.1. Configuration du pilote de disque concaténé (CCD - "Concatenated Disk Driver")<a class=anchor href=#ccd></a></h5><div class=paragraph><p>Quand il est question du choix d’une solution de stockage de masse les critères de choix les plus importants à considérer sont la vitesse, la fiabilité, et le coût. Il est plutôt rare de pouvoir réunir ces trois critères; normalement un périphérique de stockage rapide et fiable est coûteux, et pour diminuer les coûts la vitesse ou la fiabilité doivent être sacrifiées.</p></div><div class=paragraph><p>A la conception du système décrit plus bas, le coût a été choisi comme facteur le plus important, suivi de la vitesse, et enfin la fiabilité. La vitesse de transfert des données est limitée par le réseau. Et tandis que la fiabilité est très importante, le disque CCD décrit ci-dessous est destiné au stockage de données en ligne qui sont déjà complètement sauvegardées sur CD-Rs et qui peuvent être facilement remplacées.</p></div><div class=paragraph><p>Définir vos propres besoins est la première étape dans le choix d’une solution de stockage de masse. Si vos critères de choix privilégient la vitesse ou la fiabilité par rapport au coût, votre solution diférera du système décrit dans cette section.</p></div><div class=sect5><h6 id=ccd-installhw>19.4.1.1.1. Installation du matériel<a class=anchor href=#ccd-installhw></a></h6><div class=paragraph><p>En plus du disque système IDE, trois disques Western Digital de 30Go, 5400 trs/min IDE forment le coeur du disque CCD décrit ci-dessous donnant approximativement 90Go de stockage en ligne. La solution idéale serait d’avoir pour chaque disque IDE son propre câble et contrôleur IDE, mais pour minimiser les coûts, des contrôleur IDE supplémentaires n’ont pas été utilisés. Aussi, les disques ont été configuré de telle façon que chaque contrôleur IDE ait un disque maître et un disque esclave.</p></div><div class=paragraph><p>Au redémarrage, le BIOS a été configuré pour détecter automatiquement les disques attachés. FreeBSD les a d’ailleurs détectés au redémarrage:</p></div><div class="literalblock programlisting"><div class=content><pre>ad0: 19574MB WDC WD205BA [39770/16/63] at ata0-master UDMA33
ad1: 29333MB WDC WD307AA [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB WDC WD307AA [59598/16/63] at ata1-master UDMA33
ad3: 29333MB WDC WD307AA [59598/16/63] at ata1-slave UDMA33</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si FreeBSD ne détecte pas les disques, assurez-vous que vous avez correctement placé les cavaliers. La plupart des disques IDE disposent également d’un cavalier "Cable Select". Ce n’est <em>pas</em> le cavalier de configuration maître/esclave. Consultez la documentation du disque pour identifier le cavalier correct.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ensuite, réfléchissez sur la manière de les intégrer au système de fichiers. Vous devriez faire des recherches sur <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> (<a href=./#vinum-vinum>Le gestionnaire de volume Vinum</a>) et <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>. Dans cette configuration particulière, <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> a été choisi.</p></div></div><div class=sect5><h6 id=ccd-setup>19.4.1.1.2. Configuration du CCD<a class=anchor href=#ccd-setup></a></h6><div class=paragraph><p>Le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> vous permet de prendre plusieurs disques identiques et les concaténer en un seul système de fichiers logique. Afin d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>, vous avez besoin d’un noyau avec le support <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>. Ajoutez la ligne suivante à votre fichier de configuration de noyau, recompilez, et installez le noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device   ccd</pre></div></div><div class=paragraph><p>Le support <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> peut également chargé sous la forme d’un module noyau.</p></div><div class=paragraph><p>Pour configurer <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>, vous devez tout d’abord utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> pour labéliser les disques:</p></div><div class="literalblock programlisting"><div class=content><pre>bsdlabel -w ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto</pre></div></div><div class=paragraph><p>Cela a créé un label de disque <span class=filename>ad1c</span>, <span class=filename>ad2c</span> et <span class=filename>ad3c</span> qui s’étend sur l’intégralité du disque.</p></div><div class=paragraph><p>L’étape suivante est de modifier le type de label de disque. Vous pouvez utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> pour éditer les disques:</p></div><div class="literalblock programlisting"><div class=content><pre>bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3</pre></div></div><div class=paragraph><p>Cela ouvre le label de disque actuel de chaque disque dans l’éditeur fixé par la variable d’environnement <code>EDITOR</code>, généralement, <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>.</p></div><div class=paragraph><p>Un label de disque non modifié ressemblera à quelque chose comme ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</pre></div></div><div class=paragraph><p>Ajoutez une nouvelle partition <code>e</code> pour être utilisé par <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>. Cela peut être une copie de la partition <code>c</code> mais le type de système de fichiers (<code>fstype</code>) doit être <code>4.2BSD</code>. Le label de disque devait ressembler à:</p></div><div class="literalblock programlisting"><div class=content><pre>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</pre></div></div></div><div class=sect5><h6 id=ccd-buildingfs>19.4.1.1.3. Création du système de fichiers<a class=anchor href=#ccd-buildingfs></a></h6><div class=paragraph><p>Maintenant que tous les disques sont labélisés, vous devez construire le <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>. Pour cela, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a>, avec des options semblables à ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig ccd0. 32. 0. /dev/ad1e. /dev/ad2e /dev/ad3e</pre></div></div><div class=ulist><ul><li><p>L’utilisation et la signification de chaque option est données ci-dessous:</p></li><li><p>Le premier argument est le périphérique à configurer, dans ce cas, <span class=filename>/dev/ccd0c</span>. La partie <span class=filename>/dev/</span> est optionnelle.</p></li><li><p>L’entrelacement ("interleave") du système de fichiers. L’entrelacement définit la taille d’une bande de blocs disque, de 512 octets chacune normalement. Donc un entrelacement de 32 serait d’une largeur de 16384 octets.</p></li><li><p>Paramètres pour <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a>. Si vous désirez activer les miroirs disque, vous pouvez spécifier un indicateur à cet endroit. Cette configuration ne fournit pas de miroir pour <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>, aussi l’indicateur est a 0 (zéro).
Les derniers arguments de <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> sont les périphériques à placer dans le disque concaténé. Utilisez le chemin complet pour chaque périphérique.</p></li></ul></div><div class=paragraph><p>Après avoir utilisé <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> le <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> est configuré. Un système de fichiers peut être créé. Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> pour les options disponibles, ou lancez simplement:</p></div><div class="literalblock programlisting"><div class=content><pre>newfs /dev/ccd0c</pre></div></div></div><div class=sect5><h6 id=ccd-auto>19.4.1.1.4. Automatiser la procédure<a class=anchor href=#ccd-auto></a></h6><div class=paragraph><p>Généralement, vous voudrez monter le <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> à chaque redémarrage. Pour cela, vous devez le configurer avant toute chose. Ecrivez votre configuration actuelle dans <span class=filename>/etc/ccd.conf</span> en utilisant la commande suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig -g  /etc/ccd.conf</pre></div></div><div class=paragraph><p>Lors du démarrage, la procédure <code>/etc/rc</code> exécute <code>ccdconfig -C</code> si <span class=filename>/etc/ccd.conf</span> existe. Cela configure automatiquement le <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> de façon à pouvoir être monté.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous démarrez en mode mono-utilisateur, avant que vous ne puissiez monter le <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>, vous devez utiliser la commande suivante pour configurer l’unité:</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig -C</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Pour monter automatiquement le <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> placez une entrées pour le <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> dans <span class=filename>/etc/fstab</span>, il sera ainsi monté au démarrage:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ccd0c              /media       ufs     rw      2       2</pre></div></div></div></div><div class=sect4><h5 id=vinum>19.4.1.2. Le gestionnaire de volume Vinum<a class=anchor href=#vinum></a></h5><div class=paragraph><p>Le gestionnaire de volume Vinum est un pilote de périphérique de gestion de disques virtuels. Il sépare le disque matériel de l’interface de périphérique bloc et organise les données de telle façon qu’il en résulte une amélioration de la flexibilité, des performances et de la fiabilité, comparé à la vision traditionnelle sous forme partitionnée du stockage disque. <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> implémente les modèles RAID-0, RAID-1 et RAID-5, individuellement ou combinés.</p></div><div class=paragraph><p>Voir le <a href=./#vinum-vinum>Le gestionnaire de volume Vinum</a> pour plus d’information au sujet de <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a>.</p></div></div></div><div class=sect3><h4 id=raid-hard>19.4.2. RAID Matériel<a class=anchor href=#raid-hard></a></h4><div class=paragraph><p>FreeBSD supporte également de nombreux contrôleurs RAID. Ces périphériques peuvent contrôler un système RAID sans nécessiter l’utilisation d’un logiciel spécifique pour FreeBSD pour gérer l’unité.</p></div><div class=paragraph><p>En utilisant son propre BIOS, la carte contrôle la plupart des opérations disque. Ce qui suit est une description rapide d’une configuration utilisant un contrôleur Promise IDERAID. Quand cette carte est installée et le système redémarré, une invite s’affichera posant quelques questions. Suivez les instructions à l’écran pour atteindre l’écran de configuration de la carte. A partir de là, vous avez la possibilité de combiner tous les disques attachés. En faisant cela, les disques apparaîtront sous la forme d’un unique disque sous FreeBSD. D’autres niveaux RAID peuvent être configurés en conséquence.</p></div></div><div class=sect3><h4 id=_reconstruire_une_unité_ata_raid1>19.4.3. Reconstruire une unité ATA RAID1<a class=anchor href=#_reconstruire_une_unité_ata_raid1></a></h4><div class=paragraph><p>FreeBSD vous permet de remplacer à chaud un disque défectueux dans une unité. Cela doit être fait avant redémarrage.</p></div><div class=paragraph><p>Vous verrez probablement dans <span class=filename>/var/log/messages</span> ou dans la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> quelque chose comme:</p></div><div class="literalblock programlisting"><div class=content><pre>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)
status=59 error=40
ar0: WARNING - mirror lost</pre></div></div><div class=paragraph><p>En utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=atacontrol&amp;sektion=8&amp;format=html">atacontrol(8)</a>, recherchez de plus amples informations:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol list</span>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

<span class=c># atacontrol status ar0</span>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</code></pre></div></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Vous devrez détacher le canal ATA avec le disque défectueux de façon à pouvoir le retirer sans risque:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol detach ata3</span></code></pre></div></div></li><li><p>Remplacer le disque.</p></li><li><p>Rattacher le canal ATA:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol attach ata3</span>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</code></pre></div></div></li><li><p>Rajouter le disque de rechange à l’unité:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol addspare ar0 ad6</span></code></pre></div></div></li><li><p>Recontruire l’unité:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol rebuild ar0</span></code></pre></div></div></li><li><p>Il est possible de contrôler l’avancée de la procédure en utilisant la commande suivante:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | tail -10</span>
<span class=o>[</span>output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

<span class=c># atacontrol status ar0</span>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</code></pre></div></div></li><li><p>Attendre jusqu’à la fin de cette opération.</p></li></ol></div></div></div></div></div><div class=sect2><h3 id=usb-disks>19.5. Périphériques de stockage USB<a class=anchor href=#usb-disks></a></h3><div class=paragraph><p>De nombreuses solutions de stockage externes utilisent, de nos jours, le bus série universel ("Universal Serial Bus"-USB): disques durs, clés USB, graveurs de CDs, etc. FreeBSD fournit un support pour ces périphériques.</p></div><div class=sect3><h4 id=_configuration_2>19.5.1. Configuration<a class=anchor href=#_configuration_2></a></h4><div class=paragraph><p>Le pilote de périphériques USB de stockage de masse, <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>, fournit le support pour les périphériques de stockage USB. Si vous utilisez le noyau <span class=filename>GENERIC</span>, vous n’avez rien à modifier à votre configuration. Si vous utilisez un noyau personnalisé, assurez-vous que les lignes suivantes sont présentent dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device da
device pass
device uhci
device ohci
device usb
device umass</pre></div></div><div class=paragraph><p>Le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> utilise le sous-système SCSI pour accéder aux périphériques de stockage USB, votre périphérique USB sera vu par le système comme étant un périphérique SCSI. En fonction du contrôleur USB présent sur votre carte mère, vous n’avez besoin qu’une des lignes <code>device uhci</code> et <code>device ohci</code>, cependant avoir les deux lignes dans votre configuration du noyau est sans danger. N’oubliez pas de compiler et d’installer le nouveau noyau si vous y avez effectué des modifications.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si votre périphérique USB est un graveur de CD ou de DVD, le pilote de périphérique SCSI CD-ROM, <a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=4&amp;format=html">cd(4)</a>, doit être ajouté au noyau via la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>device cd</pre></div></div><div class=paragraph><p>Puisque le graveur est vu comme un disque SCSI, le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> ne devrait pas être employé dans la configuration du noyau.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le support pour les contrôleurs USB 2.0 est fourni avec FreeBSD vous devez cependant ajouter:</p></div><div class="literalblock programlisting"><div class=content><pre>device ehci</pre></div></div><div class=paragraph><p>à votre fichier de configuration pour bénéficier du support USB 2.0. Notez que les pilotes <a href="https://man.freebsd.org/cgi/man.cgi?query=uhci&amp;sektion=4&amp;format=html">uhci(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=ohci&amp;sektion=4&amp;format=html">ohci(4)</a> sont toujours nécessaires si vous désirez le support de l’USB 1.X.</p></div></div><div class=sect3><h4 id=_test_de_la_configuration>19.5.2. Test de la configuration<a class=anchor href=#_test_de_la_configuration></a></h4><div class=paragraph><p>La configuration est prête à être testée: branchez votre périphérique USB, et dans le tampon des messages du système (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>), le disque devrait apparaître de cette manière:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 <span class=nv>dp</span><span class=o>=</span>0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB <span class=o>(</span>258048 512 byte sectors: 64H 32S/T 126C<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Bien évidement, le modèle, le fichier spécial de périphérique (<span class=filename>da0</span>) et d’autres détails peuvent être différents en fonction de votre configuration.</p></div><div class=paragraph><p>Comme le périphérique USB est vu comme étant un périphérique SCSI, la commande <code>camcontrol</code> peut être employée pour lister les périphériques de stockage USB attachés au système:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 <span class=o>(</span>da0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Si le disque dispose d’un système de fichiers, vous devriez pouvoir le monter. La <a href=#disks-adding>Ajouter des disques</a> vous aidera à formater et créer des partitions sur le disque USB si nécessaire.</p></div><div class=paragraph><p>Pour rendre ce périphérique montable par un utilisateur normal, un certain nombre de paramétrages sont nécessaires. Tout d’abord, les entrées de périphériques qui sont créées lors de la connexion d’un périphérique USB doivent être accessibles à l’utilisateur. Une solution est de faire en sorte que tous les utilisateurs de ces périphériques soient membres du groupe <code>operator</code>. Cela se fait à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>. Ensuite, quand ces entrées de périphériques sont créées, le groupe <code>operator</code> doit pouvoir y accéder en lecture et en écriture. Pour cela, les lignes suivantes sont ajoutées à <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[localrules=1]
add path &#39;da*&#39; mode 0660 group operator</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>S’il y a déjà des disques SCSI dans le système, on doit procéder légèrement différemment. Par exemple, si le système contient déjà des disques <span class=filename>da0</span> à <span class=filename>da2</span> attachés au système, changez la seconde ligne pour:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Les disques déjà présents n’appartiendront pas au groupe <code>operator</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Vous devez également activer votre ensemble de règles <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> dans votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;localrules&#34;</pre></div></div><div class=paragraph><p>Le noyau doit être ensuite configuré pour autoriser les utilisateurs habituels à monter des systèmes de fichiers. La méthode la plus simple est d’ajouter la ligne suivante au fichier <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.usermount=1</pre></div></div><div class=paragraph><p>Notez que ce paramétrage ne prendra effet qu’au prochain redémarrage. Il est également possible d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> pour fixer cette variable.</p></div><div class=paragraph><p>La dernière étape est de créer un répertoire où le système de fichiers sera monté. Ce répertoire doit appartenir à l’utilisateur qui montera le système de fichiers. Une méthode adaptée et la création par <code>root</code> d’un sous-répertoire <span class=filename>/mnt/$USER</span> appartenant à l’utilisateur en question (remplacez <em>$USER</em> par le nom d’utilisateur de cet utilisateur):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt/$USER</span>
<span class=c># chown $USER:$USER /mnt/$USER</span></code></pre></div></div><div class=paragraph><p>Supposez qu’une clé USB soit branchée et qu’un périphérique <span class=filename>/dev/da0s1</span> apparaît. Comme ce type de périphériques est en général livré préformaté avec un système de fichiers de type FAT, on pourra le monter de cette manière:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mount <span class=nt>-t</span> msdosfs <span class=nt>-m</span> 644 <span class=nt>-M</span> 755 /dev/da0s1 /mnt/<span class=nv>$USER</span></code></pre></div></div><div class=paragraph><p>Si vous débranchez le périphérique (le disque doit être démonté auparavant), vous devriez voir dans les messages du système quelque chose comme:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub0 port 1 <span class=o>(</span>addr 2<span class=o>)</span> disconnected
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: lost device
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: removing device entry
GEOM: destroy disk da0 <span class=nv>dp</span><span class=o>=</span>0xc2d74850
umass0: detached</code></pre></div></div></div><div class=sect3><h4 id=_lectures_supplémentaires_2>19.5.3. Lectures supplémentaires<a class=anchor href=#_lectures_supplémentaires_2></a></h4><div class=paragraph><p>En plus des sections <a href=#disks-adding>Ajouter des disques</a> et <a href=./#mount-unmount>Monter et démonter des systèmes de fichiers</a>, la lecture de différentes pages de manuel peut être également utile: <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=usbdevs&amp;sektion=8&amp;format=html">usbdevs(8)</a>.</p></div></div></div><div class=sect2><h3 id=creating-cds>19.6. Création et utilisation de supports optiques (CDs)<a class=anchor href=#creating-cds></a></h3><div class=sect3><h4 id=_introduction_3>19.6.1. Introduction<a class=anchor href=#_introduction_3></a></h4><div class=paragraph><p>Les CDs se différencient des disques conventionnels par de nombreuses caractéristiques. Au départ, ils n’étaient pas inscriptible par l’utilisateur. Ils sont conçu pour être lut de façon continue sans délai pour déplacer la tête de lecture entre les pistes. Ils sont également plus facile à déplacer entre systèmes que les supports de même taille à cette époque.</p></div><div class=paragraph><p>Les CDs possèdent des pistes, mais cela fait référence à un ensemble de données qui peuvent être lues de façon continue et non pas à une particularité physique du disque. Pour produire un CD sous FreeBSD, il faut préparer les fichiers de données qui vont constituer les pistes sur le CD, puis écrire les pistes sur le CD.</p></div><div class=paragraph><p>Le système de fichiers ISO 9660 a été conçu pour gérer ces différences. Malheureusement il incorpore des limites du système de fichiers qui semblaient normale alors. Mais heureusement, il fournit un mécanisme d’extension qui permet au CDs proprement gravés de passer outre ces limites tout en restant lisibles par les systèmes qui ne supportent pas ces extensions.</p></div><div class=paragraph><p>Le logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> comprend <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, un programme que vous pouvez utiliser pour produire un fichier de données contenant un système de fichiers ISO 9660. Il dispose d’options pour le support de diverses extensions, et est décrit ci-dessous.</p></div><div class=paragraph><p>L’outil a utiliser pour graver un CD varie en fonction du type de graveur de CD: ATAPI ou autre. Les graveurs ATAPI utilisent le programme <code>burncd</code> qui fait partie du système de base. Les graveurs SCSI ou USB devraient utiliser l’utilitaire <code>cdrecord</code> du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> port. Il est également possible d’utiliser <code>cdrecord</code> et d’autres outils pour lecteurs SCSI sur du matériel ATAPI avec le <a href=#atapicam>module ATAPI/CAM</a>.</p></div><div class=paragraph><p>Si vous voulez un programme de gravure de CD avec une interface graphique, vous devriez jeter un oeil à X-CD-Roast ou K3b. Ces outils sont disponibles sous une version pré-compilée ou à partir des logiciels portés <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> et <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a>. X-CD-Roast et K3b nécessitent le <a href=#atapicam>module ATAPI/CAM</a> avec des périphériques ATAPI.</p></div></div><div class=sect3><h4 id=mkisofs>19.6.2. mkisofs<a class=anchor href=#mkisofs></a></h4><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, qui fait partie du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, produit un système de fichiers ISO 9660 qui est une image de l’arborescence des répertoires dans un système de fichiers UNIX®. L’utilisation la plus simple est:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o fichierimage.iso /chemin/vers/arborescence</span></code></pre></div></div><div class=paragraph><p>Cette commande créera un <em>fichierimage.iso</em> contenant un système de fichiers ISO 9660 qui est une copie de l’arborescence <em>/chemin/vers/arborescence</em>. Durant le processus de création, les noms de fichiers seront modifiés de façon à respecter les limitations de la norme ISO 9660, et rejettera les fichiers ayant des noms non acceptables pour un système de fichiers ISO.</p></div><div class=paragraph><p>De nombreuses options sont disponibles pour passer outre ces restrictions. En particulier, <code>-R</code> qui autorise les extensions Rock Ridge communes aux systèmes UNIX®, <code>-J</code> qui active les extensions Joliet utilisées par les systèmes Microsoft, et <code>-hfs</code> peut être utilisé pour créer des systèmes de fichiers HFS utilisés par Mac OS®.</p></div><div class=paragraph><p>Pour des CDs qui sont destinés à n’être utilisé que sur des systèmes FreeBSD, l’option <code>-U</code> peut être utilisée pour désactiver toutes les restrictions au niveau des noms de fichiers. Quand elle est utilisée avec l’option <code>-R</code>, cela produit une image de système de fichiers qui est identique à l’arborescence FreeBSD d’origine, cependant ce système de fichiers pourra violer la norme ISO 9660 de nombreuses façon.</p></div><div class=paragraph><p>La dernière option d’usage général est l’option <code>-b</code>. Elle est utilisée pour indiquer l’emplacement de l’image de démarrage à utiliser dans la création d’un CD démarrable "El Torito". Cette option prend en argument le chemin vers une image de démarrage à partir de la racine de l’arborescence qui va être copiée sur le CD. Par défaut, <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> créé une image ISO dans un mode appelé "émulation de disquette", et s’attend donc à une image de démarrage de 1200, 1440 ou 2880 Ko en taille. Certains chargeurs, comme celui utilisé par les disques d’installation de FreeBSD, n’utilisent pas ce mode d’émulation, dans ce cas l’option <code>-no-emul-boot</code> devrait être utilisée. Aussi, si <span class=filename>/tmp/monboot</span> contient un système FreeBSD avec une image de démarrage dans <span class=filename>/tmp/monboot/boot/cdboot</span>, vous pourrez produire l’image d’un système de fichiers ISO 9660 dans <span class=filename>/tmp/bootable.iso</span> de cette façon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/monboot</span></code></pre></div></div><div class=paragraph><p>Cela étant fait, si vous avez le pilote <span class=filename>md</span> configuré dans votre noyau, vous pouvez monter le système de fichiers avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>A ce moment vous pouvez vérifier que <span class=filename>/mnt</span> et <span class=filename>/tmp/monboot</span> sont identique.</p></div><div class=paragraph><p>Il existe de nombreuses autres options que vous pouvez utiliser avec <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> pour régler finement son comportement. En particulier: les modifications d’une organisation ISO 9660 et la création de disques Joliet et HFS. Voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> pour plus de détails.</p></div></div><div class=sect3><h4 id=burncd>19.6.3. burncd<a class=anchor href=#burncd></a></h4><div class=paragraph><p>Si vous disposez d’un graveur de CD ATAPI, vous pouvez utiliser la commande <code>burncd</code> pour graver une image ISO sur un CD. <code>burncd</code> fait partie du système de base, installé sous <span class=filename>/usr/sbin/burncd</span>. Son utilisation est très simple, car il dispose de peu d’options:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f cddevice data fichierimage.iso fixate</span></code></pre></div></div><div class=paragraph><p>Gravera une copie de <em>fichierimage.iso</em> sur <em>cddevice</em>. Le périphérique par défaut est <span class=filename>/dev/acd0</span>. Consultez <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> pour les options pour fixer la vitesse d’écriture, éjecter le CD après gravure, et graver des données audios.</p></div></div><div class=sect3><h4 id=cdrecord>19.6.4. cdrecord<a class=anchor href=#cdrecord></a></h4><div class=paragraph><p>Si vous n’avez pas de graveur de CD ATAPI, vous devrez utiliser <code>cdrecord</code> pour graver vos CDs. <code>cdrecord</code> ne fait pas partie du système de base; vous devez l’installer soit à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> ou de la version pré-compilée appropriée. Des modifications du système de base peuvent provoquer le dysfonctionnement des versions binaires de ce programme, et donner lieu à une production de "dessous de bouteille". Vous devrez par conséquent soit mettre à jour le logiciel porté quand vous mettez à jour votre système, soit si vous <a href=./#stable>suivez la branche -STABLE</a>, mettre à jour le logiciel porté lorsqu’une nouvelle version est disponible.</p></div><div class=paragraph><p>Bien que <code>cdrecord</code> dispose de nombreuses options, l’usage de base est même plus simple qu’avec <code>burncd</code>. La gravure d’une image ISO 9660 se fait avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device fichierimage.iso</span></code></pre></div></div><div class=paragraph><p>La partie délicate dans l’utilisation de <code>cdrecord</code> est la recherche de la valeur à utiliser pour l’option <code>dev</code>. Pour déterminer le bon paramètre à utiliser, utilisez l’indicateur <code>-scanbus</code> de <code>cdrecord</code>, qui produira des résultats du type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
Cdrecord-Clone 2.01 <span class=o>(</span>i386-unknown-freebsd7.0<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2004 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.1&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>Cela donne la valeur <code>dev</code> appropriée pour les périphériques listés. Recherchez votre graveur de CD dans la liste, et utilisez les trois chiffres séparés par une virgule comme valeur pour <code>dev</code>. Dans notre cas le périphérique de gravure est 1,5,0, donc l’entrée appropriée serait <code>dev=1,5,0</code>. Il existe des manières plus simple de spécifier cette valeur, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> pour des détails. C’est également la documentation à consulter pour des informations sur la gravure de pistes audios, le contrôle de la vitesse, et d’autres choses.</p></div></div><div class=sect3><h4 id=duplicating-audiocds>19.6.5. Dupliquer des CDs Audio<a class=anchor href=#duplicating-audiocds></a></h4><div class=paragraph><p>Vous pouvez dupliquer un CD audio en effectuant l’extraction des données audio du CD vers un ensemble de fichiers, puis graver ces fichiers sur un CD vierge. Le processus est légèrement différent entre lecteurs ATAPI et SCSI.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Lecteurs SCSI</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Utiliser <code>cdda2wav</code> pour effectuer l’extraction audio.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-v255</span> <span class=nt>-D2</span>,0 <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div></li><li><p>Utiliser <code>cdrecord</code> pour graver les fichiers <span class=filename>.wav</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span>  <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Assurez-vous que <em>2,0</em> est choisi correctement, comme décrit dans <a href=#cdrecord>cdrecord</a>.</p></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Lecteurs ATAPI</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Le pilote CD ATAPI rend disponible chaque piste sous la forme <span class=filename>/dev/acddtnn</span>, où <em>d</em> est le numéro de lecteur, et <em>nn</em> est le numéro de la piste écrit sur deux digits décimaux. Donc la première piste sur le premier lecteur est <span class=filename>/dev/acd0t01</span>, la seconde est <span class=filename>/dev/acd0t02</span>, la troisième <span class=filename>/dev/acd0t03</span>, et ainsi de suite.</p><div class=paragraph><p>Assurez-vous que les fichiers appropriés existent sous <span class=filename>/dev</span>. Si ces entrées sont absentes, forcez le système à lire le disque à nouveau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0 of=/dev/null count=1</span></code></pre></div></div></li><li><p>Extraire chaque piste en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a>. Vous devez également préciser une taille de bloc durant l’extraction des fichiers.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0t01 of=piste1.cdr bs=2352</span>
<span class=c># dd if=/dev/acd0t02 of=piste2.cdr bs=2352</span>
...</code></pre></div></div></li><li><p>Graver les fichiers récupérés en utilisant <code>burncd</code>. Vous devez spécifier que ce sont des fichiers audio, et que <code>burncd</code> devra fermer le disque une fois terminé.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd0 audio piste1.cdr piste2.cdr ... fixate</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=imaging-cd>19.6.6. Dupliquer des CDs de données<a class=anchor href=#imaging-cd></a></h4><div class=paragraph><p>vous pouvez copier un CD de données vers un fichier image équivalent au fichier créé avec <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, et vous pouvez l’utiliser pour dupliquer n’importe quel CD de données. L’exemple présenté ici suppose que votre lecteur de CDROM est les périphérique <span class=filename>acd0</span>. Remplacez-le avec le périphérique correct.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0 of=fichier.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>Vous disposez maintenant d’une image, vous pouvez la graver comme décrit plus haut.</p></div></div><div class=sect3><h4 id=mounting-cd>19.6.7. Utiliser des CDs de données<a class=anchor href=#mounting-cd></a></h4><div class=paragraph><p>Maintenant que vous avez créé une CDROM de données standard, vous voulez probablement le monter et lire les données présentes. Par défaut, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> suppose que le système de fichier à monter est de type <code>UFS</code>. Si vous essayez quelque chose comme:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>vous obtiendrez une erreur du type <code>Incorrect super block</code>, et pas de montage. Le CDROM n’est pas un système de fichiers de type <code>UFS</code>, aussi toute tentative de montage de ce type échouera. Vous devez juste préciser à <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> que le système de fichiers est du type <code>ISO9660</code>, et tout fonctionnera. Cela se fait en spécifiant l’option <code>-t cd9660</code> option à <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Par exemple, si vous désirez monter un CDROM, contenu dans le lecteur <span class=filename>/dev/cd0</span>, sous <span class=filename>/mnt</span>, vous devrez exécuter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Notez que votre nom de lecteur (<span class=filename>/dev/cd0</span> dans cet exemple) pourra être différent, en fonction de l’interface utilisée par votre lecteur de CDROM. De plus l’option <code>-t cd9660</code> ne fait qu’exécuter la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>. L’exemple précédent pourrait être réduit à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Vous pouvez généralement utiliser des CDROMs de données de n’importe quelle provenance de cette façon. Les disques avec certaines extensions ISO 9660 pourront se comporter de façon étrange, cependant. Par exemple, les disques Joliet conservent tous les noms de fichiers en utilisant des caractères Unicodes sur 2 octets. Le noyau FreeBSD ne comprend pas l’Unicode, mais le pilote CD9660 de FreeBSD est en mesure de convertir au vol les caractères Unicode. Si des caractères non-anglais apparaissent sous la forme de points d’interrogation, vous devrez préciser la table de caractères locale que vous utilisez avec l’option <code>-C</code>. Pour plus d’information, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour pouvoir effectuer cette conversion de caractères à l’aide de l’option <code>-C</code>, le module <span class=filename>cd9660_iconv.ko</span> devra être chargé. Cela peut être fait soit en ajoutant au fichier <span class=filename>loader.conf</span> la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>cd9660_iconv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>puis en redémarrant la machine, soit en chargeant directement le module avec <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Occasionnellement, vous pourrez obtenir le message <code>Device not configured</code> (périphérique non configuré) lors d’une tentative de montage d’un CDROM. Cela veut généralement dire que le lecteur de CDROM pense qu’il n’y a pas de disque dans le lecteur, ou que le lecteur n’est pas visible sur le bus. Cela peut demander plusieurs secondes à un lecteur de CDROM de s’apercevoir qu’il a été chargé, soyez donc patient.</p></div><div class=paragraph><p>Parfois, un lecteur de CDROM SCSI peut être manquant parce qu’il n’a pas eu suffisamment de temps pour répondre à la réinitialisation du bus. Si vous avez un lecteur de CDROM SCSI, veuillez ajouter l’option suivante à la configuration de votre noyau et <a href=./#kernelconfig-building>recompiler votre noyau</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>Ceci demande à votre bus SCSI une pause de 15 seconds au démarrage, pour donner à votre lecteur de CDROM une chance de répondre la réinitialisation du bus.</p></div></div><div class=sect3><h4 id=rawdata-cd>19.6.8. Graver des CDs de données brutes<a class=anchor href=#rawdata-cd></a></h4><div class=paragraph><p>Il est possible de graver directement un fichier sur CD, sans créer de système de fichiers ISO 9660. Certaines personnes le font dans le cas de sauvegardes. Cela est beaucoup plus rapide que de graver un CD standard:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</span></code></pre></div></div><div class=paragraph><p>Afin de récupérer les données gravées sur un tel CD, vous devez lire les données à partir du fichier spécial de périphériques en mode caractère:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/acd1</span></code></pre></div></div><div class=paragraph><p>Vous ne pouvez monter ce disque comme vous le feriez avec un CDROM classique. Un tel CDROM ne pourra être lu sous un autre système d’exploitation en dehors de FreeBSD. Si vous voulez être en mesure de monter le CD, ou d’en partager les données avec un autre système d’exploitation, vous devez utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> comme décrit plus haut.</p></div></div><div class=sect3><h4 id=atapicam>19.6.9. Utilisation du pilote de périphérique ATAPI/CAM<a class=anchor href=#atapicam></a></h4><div class=paragraph><p>Ce pilote permet d’accéder aux périphériques ATAPI (lecteurs de CD-ROM, graveurs CD-RW, lecteur de DVD etc…​) par l’intermédiaire du sous-système SCSI, et autorise l’utilisation d’applications comme <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a>.</p></div><div class=paragraph><p>Pour utiliser ce pilote, vous devrez ajouter la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>puis redémarrez votre machine.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous préférez compiler en statique dans le noyau le support <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a>, vous devrez ajouter au fichier de configuration du noyau la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Vous avez également besoin des lignes suivantes dans votre fichier de configuration:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata
device scbus
device cd
device pass</pre></div></div><div class=paragraph><p>qui devraient être déjà présentes. Puis recompilez, installez votre nouveau noyau, et enfin redémarrez votre machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Lors du démarrage, votre graveur devrait apparaître, comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div><div class=paragraph><p>Le lecteur doit être accessible via le nom de périphérique <span class=filename>/dev/cd0</span>, par exemple pour monter un CD-ROM sous <span class=filename>/mnt</span>, tapez juste ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>En tant que <code>root</code>, vous pouvez exécuter la commande suivante pour obtenir l’adresse SCSI du graveur:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>pass0,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Donc <code>1,0,0</code> sera l’adresse SCSI à utiliser avec <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> et tout autre application SCSI.</p></div><div class=paragraph><p>Pour plus d’information concernant ATAPI/CAM et le système SCSI, consultez les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=cam&amp;sektion=4&amp;format=html">cam(4)</a>.</p></div></div></div><div class=sect2><h3 id=creating-dvds>19.7. Création et utilisation de supports optiques (DVDs)<a class=anchor href=#creating-dvds></a></h3><div class=sect3><h4 id=_introduction_4>19.7.1. Introduction<a class=anchor href=#_introduction_4></a></h4><div class=paragraph><p>Comparé au CD, le DVD est la génération technologique suivante de support optique de stockage de données. Un DVD peut contenir plus de données qu’un CD et est de nos jour le standard pour la publication de vidéos.</p></div><div class=paragraph><p>Cinq formats physiques enregistrables peuvent être définis pour ce que nous appellerons un DVD enregistrable:</p></div><div class=ulist><ul><li><p>DVD-R: Ce fut le premier format DVD enregistrable disponible. La norme DVD-R est définie par le <a href=http://www.dvdforum.com/forum.shtml>Forum DVD</a>. Ce format n’est pas réinscriptible.</p></li><li><p>DVD-RW: C’est la version réinscriptible du standard DVD-R. Un DVD-RW peut supporter environ 1000 réécritures.</p></li><li><p>DVD-RAM: C’est également un format réinscriptible supporté par le Forum DVD. Un DVD-RAM peut être vu comme un disque dur extractible. Cependant, ce support n’est pas compatible avec la plupart des lecteurs DVD-ROM et DVD-Vidéo; seuls quelques graveurs de DVDs supportent le DVD-RAM. Consultez la <a href=#creating-dvd-ram>Utiliser un disque DVD-RAM</a> pour plus d’information sur l’utilisation d’un DVD-RAM.</p></li><li><p>DVD+RW: C’est un format réinscriptible défini par l' <a href=http://www.dvdrw.com/>Alliance DVD+RW</a>. Un DVD+RW supporte environ 1000 réécritures.</p></li><li><p>DVD+R: Ce format est la version non-réinscriptible du format DVD+RW.</p></li></ul></div><div class=paragraph><p>Un DVD enregistrable simple couche peut contenir jusqu’à 4 700 000 000 octets ce qui équivaut en fait à 4.38 Go ou 4485 Mo (1 kilo-octet représente 1024 octets).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Une différence doit être faite entre un support physique et son application. Par exemple un DVD-Vidéo est une organisation de fichiers particulière qui peut être écrite sur n’importe quel type de DVD enregistrable: DVD-R, DVD+R, DVD-RW etc. Avant de choisir le type de support, vous devez vous assurer que le graveur et le lecteur de DVD-Vidéo (lecteur de salon ou un lecteur de DVD-ROM sur un micro-ordinateur) sont compatibles avec le support.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_configuration_3>19.7.2. Configuration<a class=anchor href=#_configuration_3></a></h4><div class=paragraph><p>Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> sera utilisé pour effectuer la gravure des DVDs. Cette commande fait partie des utilitaires dvd+rw-tools (<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a>). Les outils dvd+rw-tools supportent l’ensemble des supports DVD.</p></div><div class=paragraph><p>Ces utilitaires utilisent le sous-système SCSI pour accéder aux périphériques, par conséquent le <a href=#atapicam>support ATAPI/CAM</a> doit être ajouté à votre noyau. Si votre graveur utilise l’interface USB, cet ajout est inutile et vous devriez lire la <a href=#usb-disks>Périphériques de stockage USB</a> sur la configuration de périphériques USB.</p></div><div class=paragraph><p>Vous devez également activer l’accès aux périphériques ATAPI par DMA, cela peut être fait en ajoutant la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Avant de tenter d’utiliser les utilitaires dvd+rw-tools vous devriez consulter les <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>notes de compatibilité matérielle des dvd+rw-tools</a> pour des informations concernant votre graveur de DVDs.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous désirez une interface graphique, vous devriez jeter un oeil à K3b (<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a>) qui offre une interface conviviale à <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> et à d’autres outils de gravure.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_graver_des_dvds_de_données>19.7.3. Graver des DVDs de données<a class=anchor href=#_graver_des_dvds_de_données></a></h4><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> est une interface à <a href=#mkisofs>mkisofs</a>, elle invoquera <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> pour la création du système de fichiers et effectuera la gravure des données sur le DVD. Cela signifie que vous n’avez pas besoin de créer une image des données avant le processus de gravure.</p></div><div class=paragraph><p>Pour écrire les données du répertoire <span class=filename>/path/to/data</span>, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Les options <code>-J -R</code> sont passées à <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> pour la création du système de fichiers (dans le cas présent: un système de fichiers ISO 9660 avec les extensions Joliet et Rock Ridge), consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> pour plus de détails.</p></div><div class=paragraph><p>L’option <code>-Z</code> est utilisée pour la session d’écriture initiale dans tous les cas: multi-sessions ou pas. Le périphérique correspondant au graveur, <em>/dev/cd0</em>, doit être adapté en fonction de votre configuration. Le paramètre <code>-dvd-compat</code> provoquera la fermeture du disque, rien ne pourra être écrit à la suite de l’enregistrement. En retour cela devrait donner lieu à une plus grande compatibilité avec les lecteurs de DVD-ROMs.</p></div><div class=paragraph><p>Il est également possible de graver une image de système de fichiers, par exemple pour graver l’image <em>imagefile.iso</em>, nous lancerons:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>La vitesse d’écriture devrait être détectée et positionnée automatiquement en fonction du support et du graveur utilisé. Si vous voulez forcer la vitesse de gravure, utilisez le paramètre <code>-speed=</code>. Pour plus d’informations, lisez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div></div><div class=sect3><h4 id=_graver_un_dvd_vidéo>19.7.4. Graver un DVD-Vidéo<a class=anchor href=#_graver_un_dvd_vidéo></a></h4><div class=paragraph><p>Un DVD-Vidéo est un système de fichiers particulier basé sur les spécifications IS0 9660 et micro-UDF (M-UDF). Le DVD-Vidéo présente également une arborescence de données spécifique, c’est la raison pour laquelle vous devez utiliser un programme particulier tel que <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a> pour créer le DVD.</p></div><div class=paragraph><p>Si vous disposez déjà d’une image du système de fichiers du DVD-Vidéo, gravez-la de la même façon que pour une autre image, reportez-vous aux sections précédentes pour un exemple. Si vous avez réalisé vous-même l’arborescence du DVD et que le résultat est dans, par exemple, le répertoire <span class=filename>/path/to/video</span>, la commande suivante devrait être utilisée pour graver le DVD-Vidéo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre></div></div><div class=paragraph><p>L’option <code>-dvd-video</code> sera passée à <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> et lui demandera de créer un système de fichiers de DVD-Vidéo. De plus, l’option <code>-dvd-video</code> implique l’option <code>-dvd-compat</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div></div><div class=sect3><h4 id=_utiliser_un_dvdrw>19.7.5. Utiliser un DVD+RW<a class=anchor href=#_utiliser_un_dvdrw></a></h4><div class=paragraph><p>Contrairement à un CD-RW, un DVD+RW vierge doit être formaté avant la première utilisation. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> s’en chargera automatiquement quand cela sera nécessaire, ce qui est la méthode <em>recommandée</em>. Cependant vous pouvez utiliser la commande <code>dvd+rw-format</code> pour formater le DVD+RW:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Vous devez effectuer cette opération qu’une seule fois, gardez à l’esprit que seuls des DVD+RW vierges doivent être formatés. Ensuite vous pouvez graver le DVD+RW de la manière vue dans les sections précédentes.</p></div><div class=paragraph><p>Si vous voulez graver de nouvelles données (graver un système de fichiers totalement nouveau et pas juste ajouter des données) sur un DVD+RW, vous n’avez pas besoin de l’effacer, vous avez juste à récrire sur l’enregistrement précédent (en effectuant une nouvelle session initiale), comme ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre></div></div><div class=paragraph><p>Le format DVD+RW offre la possibilité d’ajouter facilement des données à un enregistrement précédent. L’opération consiste à fusionner une nouvelle session avec la session existante, ceci n’est pas une gravure multisession, <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> <em>augmentera</em> le système de fichiers ISO 9660 présent sur le disque.</p></div><div class=paragraph><p>Par exemple, si nous voulons ajouter des données à notre DVD+RW précédent, nous devons utiliser cela:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Les mêmes options de <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> utilisées lors de la gravure de la session initiale doivent être à nouveau utilisées lors des écritures ultérieures.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vous pouvez ajouter l’option <code>-dvd-compat</code> si vous désirez une meilleure compatibilité avec les lecteurs de DVD-ROM. Dans le cas d’un DVD+RW cela ne vous empêchera pas de rajouter des données par la suite.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si pour une quelconque raison vous voulez vraiment effacer le disque, faites ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect3><h4 id=_utiliser_un_dvd_rw>19.7.6. Utiliser un DVD-RW<a class=anchor href=#_utiliser_un_dvd_rw></a></h4><div class=paragraph><p>Un DVD-RW accepte deux formats de disque: le format séquentiel incrémental et le format "restricted overwrite". Par défaut les disques DVD-RW sont fournis sous le format séquentiel.</p></div><div class=paragraph><p>Un DVD-RW vierge peut être directement gravé sans le besoin d’une opération de formatage préalable, cependant un DVD-RW non-vierge au format séquentiel doit être effacé avant de pouvoir y écrire une nouvelle session initiale.</p></div><div class=paragraph><p>Pour effacer un DVD-RW en mode séquentiel, exécutez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Une opération d’effacement complète (<code>-blank=full</code>) prendra environ une heure avec un support 1x. Un effacement rapide peut être effectué en utilisant l’option <code>-blank</code> si le DVD-RW est destiné à être enregistré suivant le mode d’écriture Disk-At-Once (DAO). Pour écrire le DVD-RW suivant le mode DAO, utilisez la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>L’option <code>-use-the-force-luke=dao</code> ne devrait pas être nécessaire puisque <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> tente de détecter les supports effacés rapidement et engage une écriture DAO.</p></div><div class=paragraph><p>En fait le mode "restricted overwrite" devrait être utilisé avec tout DVD-RW, ce format est plus flexible que le format séquentiel incrémental par défaut.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour écrire des données sur un DVD-RW en mode séquentiel, utilisez les mêmes instructions que pour tout autre format de DVD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Si vous voulez ajouter des données à votre enregistrement précédent, vous devrez utiliser la commande <code>-M</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. Cependant, si vous effectuez un ajout de données sur un DVD-RW en mode séquentiel, une nouvelle session sera créée sur le disque avec pour résultat de donner naissance à un disque multi-sessions.</p></div><div class=paragraph><p>Un DVD-RW dans le format "restricted overwrite" n’a pas besoin d’être effacé avant une nouvelle session initiale, vous avez juste à récrire sur le disque avec l’option <code>-Z</code>, ceci est similaire à un DVD+RW. Il est également possible d’augmenter un système de fichiers ISO 9660 existant écrit sur le disque de la même manière que pour un DVD+RW en utilisant l’option <code>-M</code>. Le résultat sera un DVD avec une seule session.</p></div><div class=paragraph><p>Pour faire passer un DVD-RW dans le format "restricted overwrite", la commande suivante doit être utilisée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Pour revenir au format séquentiel, utilisez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect3><h4 id=_multi_sessions>19.7.7. Multi-sessions<a class=anchor href=#_multi_sessions></a></h4><div class=paragraph><p>Très peu de lecteurs de DVD-ROMs supportent les DVDs multi-sessions, ils ne liront, dans le meilleur des cas, que la première session. Les DVD+R, DVD-R et DVD-RW en mode séquentiel peuvent accepter de multiples sessions, la notion de multiples sessions n’existe pas pour les formats DVD+RW et DVD-RW en mode "restricted overwrite".</p></div><div class=paragraph><p>Utiliser la commande suivante après une session initiale (non fermée) sur un DVD+R, DVD-R, ou DVD-RW en mode séquentiel, ajoutera une nouvelle session sur le disque:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>L’utilisation de cette ligne de commande avec un DVD+RW ou un DVD-RW en mode "restricted overwrite" aura pour effet d’ajouter les données en fusionnant la nouvelle session avec celle déjà présente. Le résultat sera un disque mono-session. C’est la méthode utilisée pour ajouter des données sur ces médias après une écriture initiale.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>De l’espace sur le médium est utilisé entre chaque session pour la fin et le début des sessions. Par conséquent, tout ajout de données devrait se faire suivant une quantité importante de données pour optimiser l’espace sur le disque. Le nombre de sessions est limité à 154 pour un DVD+R, environ 2000 pour un DVD-R, et 127 pour un DVD+R double couche.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_pour_plus_dinformations>19.7.8. Pour plus d’informations<a class=anchor href=#_pour_plus_dinformations></a></h4><div class=paragraph><p>Pour obtenir plus d’informations sur un DVD, la commande <code>dvd+rw-mediainfo /dev/cd0</code> peut être exécutée avec le disque dans le lecteur.</p></div><div class=paragraph><p>Plus d’informations sur les utilitaires dvd+rw-tools peuvent être trouvées dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, sur le <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>site Web de dvd+rw-tools</a> et dans les archives de la <a href=http://lists.debian.org/cdwrite/>liste de diffusion cdwrite</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La sortie de la commande <code>dvd+rw-mediainfo</code> sur le résultat de la gravure ou le disque posant problème est obligatoire avec tout rapport de problème. Sans cette sortie, il sera quasiment impossible de vous aider.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=creating-dvd-ram>19.7.9. Utiliser un disque DVD-RAM<a class=anchor href=#creating-dvd-ram></a></h4><div class=sect4><h5 id=_configuration_4>19.7.9.1. Configuration<a class=anchor href=#_configuration_4></a></h5><div class=paragraph><p>Les graveurs de DVD-RAM sont fournis soit avec une interface SCSI soit une interface ATAPI. Dans le cas des périphériques ATAPI, l’accès DMA doit être activé, cela peut être fait en ajoutant la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div></div><div class=sect4><h5 id=_préparer_le_disque>19.7.9.2. Préparer le disque<a class=anchor href=#_préparer_le_disque></a></h5><div class=paragraph><p>Comme précisé dans l’introduction de cette section, un DVD-RAM peut être vu comme un disque dur extractible. Comme tout autre disque dur le DVD-RAM doit être "préparé" avant la première utilisation. Dans l’exemple, l’intégralité de l’espace sur le disque sera utilisé par un système de fichiers UFS2 standard:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/acd0 count=2</span>
<span class=c># bsdlabel -Bw acd0</span>
<span class=c># newfs /dev/acd0</span></code></pre></div></div><div class=paragraph><p>Le périphérique DVD <span class=filename>acd0</span> doit être modifié en fonction de la configuration.</p></div></div><div class=sect4><h5 id=_utiliser_le_disque>19.7.9.3. Utiliser le disque<a class=anchor href=#_utiliser_le_disque></a></h5><div class=paragraph><p>Une fois les opérations précédentes effectuées sur le DVD-RAM, il peut être monté comme un disque dur classique:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/acd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Après cela, on pourra lire et écrire sur le DVD-RAM.</p></div></div></div></div><div class=sect2><h3 id=floppies>19.8. Création et utilisation de disquettes<a class=anchor href=#floppies></a></h3><div class=paragraph><p>Sauvegarder des données sur disquette est parfois utile, par exemple quand on a pas d’autre support de stockage amovible de disponible ou quand on doit transférer de petites quantités de données sur un autre ordinateur.</p></div><div class=paragraph><p>Cette section expliquera comment utiliser des disquettes sous FreeBSD. Elle couvrira principalement le formatage et l’utilisation de disquettes DOS de 3.5pouces, mais les concepts exposés sont identiques pour d’autres formats de disquettes.</p></div><div class=sect3><h4 id=_formater_des_disquettes>19.8.1. Formater des disquettes<a class=anchor href=#_formater_des_disquettes></a></h4><div class=sect4><h5 id=_le_périphérique>19.8.1.1. Le périphérique<a class=anchor href=#_le_périphérique></a></h5><div class=paragraph><p>On accède aux disquettes par l’intermédiaire d’entrées dans <span class=filename>/dev</span>, comme pour tout autre périphérique. Pour accéder directement à la disquette, utilisez simplement <span class=filename>/dev/fdN</span>.</p></div></div><div class=sect4><h5 id=_le_formatage>19.8.1.2. Le formatage<a class=anchor href=#_le_formatage></a></h5><div class=paragraph><p>Une disquette doit subir un formatage bas niveau avant d’être utilisable. Il est généralement réalisé par le constructeur, mais le formatage est une bonne manière de contrôler l’intégrité du support. Bien qu’il soit possible de forcer une plus grande (ou plus petite) capacité, 1440Ko est celle pour laquelle sont conçues la plupart des disquettes.</p></div><div class=paragraph><p>Pour effectuer un formatage bas niveau d’une disquette vous devez utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>. L’utilitaire attend le nom du périphérique en argument.</p></div><div class=paragraph><p>Notez tout message d’erreur, sachant que cela peut aider à déterminer si la disquette est bonne ou défectueuse.</p></div><div class=sect5><h6 id=_formatage_des_disquettes>19.8.1.2.1. Formatage des disquettes<a class=anchor href=#_formatage_des_disquettes></a></h6><div class=paragraph><p>Utilisez un des périphériques <span class=filename>/dev/fdN.size</span>, pour formater la disquette. Insérez une disquette 3.5pouces dans votre lecteur et tapez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_le_label_de_disque>19.8.2. Le label de disque<a class=anchor href=#_le_label_de_disque></a></h4><div class=paragraph><p>Après le formatage bas niveau du disque, vous devrez y placer un label de disque. Ce label sera détruit plus tard, mais il est nécessaire au système pour déterminer par la suite la taille et la géométrie du disque.</p></div><div class=paragraph><p>Le nouveau label de disque prendra l’intégralité du disque, et contiendra l’information correcte sur la géométrie de la disquette. Les différentes géométries possibles pour le label sont listées dans <span class=filename>/etc/disktab</span>.</p></div><div class=paragraph><p>Vous pouvez maintenant exécuter <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> de la façon suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre></div></div></div><div class=sect3><h4 id=_le_système_de_fichiers>19.8.3. Le système de fichiers<a class=anchor href=#_le_système_de_fichiers></a></h4><div class=paragraph><p>La disquette est maintenant fin prête pour un formatage haut niveau. Cette opération placera un nouveau système de fichiers sur la disquette, qui permettra à FreeBSD d’écrire et de lire sur le disque. Après la création du nouveau système de fichiers, le label disque est détruit, aussi si vous désirez reformater le disque, vous devrez recréer le label de disque à nouveau.</p></div><div class=paragraph><p>Le système de fichiers de la disquette peut soit être de l’UFS soit utiliser le système FAT. Le système FAT est généralement un meilleur choix pour les disquettes.</p></div><div class=paragraph><p>Pour placer un nouveau système de fichier sur la disquette faites ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div><div class=paragraph><p>La disquette est maintenant prête à être utilisée.</p></div></div><div class=sect3><h4 id=_utilisation_de_la_disquette>19.8.4. Utilisation de la disquette<a class=anchor href=#_utilisation_de_la_disquette></a></h4><div class=paragraph><p>Pour utiliser la disquette, montez-la avec <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>. On peut également utiliser <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> du catalogue des logiciels portés.</p></div></div></div><div class=sect2><h3 id=backups-tapebackups>19.9. Créer et utiliser les bandes magnétiques<a class=anchor href=#backups-tapebackups></a></h3><div class=paragraph><p>Les principaux types de bandes sont les 4mm, 8mm, QIC, les mini-cartouches et les DLTs.</p></div><div class=sect3><h4 id=backups-tapebackups-4mm>19.9.1. Bandes 4mm (DDS: "Digital Data Storage")<a class=anchor href=#backups-tapebackups-4mm></a></h4><div class=paragraph><p>Les bandes 4mm sont en train de remplacer les bandes QIC comme le format usuel de sauvegarde pour les stations de travail. Cette tendance s’est accélérée quand Conner a racheté Archive, un des leaders de la fabrication des lecteurs QIC, et a arrêté la production de ces derniers. Les lecteurs 4mm sont petits et silencieux mais n’ont pas la réputation de fiabilité des lecteurs 8mm. Les cartouches sont moins coûteuse et plus petites (3 x 2 x 0.5 pouces, 76 x 51 x 12 mm) que les cartouches 8mm. Les cartouches 4mm, tout comme les 8mm, ont une durée de vie faible car elles utilisent un procédé de lecture/écriture en hélice.</p></div><div class=paragraph><p>Le débit de ces lecteurs va de ~150 Ko/s à ~500 Ko/s au maximum. Leur capacité de varie de 1.3 Go à 2.0 Go. La compression matérielle, disponible sur la plupart des lecteurs, double approximativement leur capacité. Les unités multi-lecteurs peuvent avoir jusqu’à 6 lecteurs dans une seule tour avec changement automatique de bande. La capacité totale atteint 240 Go.</p></div><div class=paragraph><p>Le standard DDS-3 supporte maintenant des capacités de bande jusqu’à 12 Go (ou 24 Go compressés).</p></div><div class=paragraph><p>Les lecteurs 4mm, comme les lecteurs 8mm, utilisent un procédé de lecture/écriture en hélice. Tous les avantages et les inconvénients de ce procédé s’appliquent aux deux types de lecteurs.</p></div><div class=paragraph><p>Les bandes doivent être changées après 2000 utilisations ou 100 sauvegardes complètes.</p></div></div><div class=sect3><h4 id=backups-tapebackups-8mm>19.9.2. Bandes 8mm (Exabyte)<a class=anchor href=#backups-tapebackups-8mm></a></h4><div class=paragraph><p>Les unités de bandes 8mm sont les lecteurs de bandes SCSI les plus courant; c’est le meilleur choix de bandes amovibles. Presque chaque site dispose d’une unité Exabyte 2 Go 8mm. Les lecteurs 8mm sont fiables, pratiques et silencieux. Les cartouches sont bon marché et d’encombrement faible (4.8 x 3.3 x 0.6 pouces; 122 x 84 x 15 mm). Un des inconvénients de la bande 8mm est la durée de vie relativement courte des bandes et des têtes de lectures en raison de la grande vitesse de défilement de la bande devant les têtes.</p></div><div class=paragraph><p>Leur débit va de ~250 Ko/s à ~500 Ko/s. Leur capacité commence à 300 Mo jusqu’à 7 Go. La compression matérielle, disponible sur la plupart des lecteurs, double approximativement la capacité. Ces lecteurs sont disponibles sous forme d’unité simple ou multiple accueillant 6 lecteurs et 120 bandes. Les bandes sont changées automatiquement par l’unité. Ils peuvent gérer une capacité de stockage de plus de 840 Go.</p></div><div class=paragraph><p>Le lecteur Exabyte "Mammoth" supporte 12 Go sur une seule bande (24 Go compressé) et coûte approximativement le double d’un lecteur classique.</p></div><div class=paragraph><p>L’enregistrement des données sur la bande utilise un procédé en hélice, les têtes sont positionnées en biais par rapport à la bande (environ 6 degrés). La bande fait un angle de 270 degrés avec le cylindre sur lequel se trouvent les têtes. Ce cylindre tourne en même temps que la bande défile. Il en résulte donc une grande densité de données et des pistes très serrées qui vont de biais d’un bord à l’autre de la bande.</p></div></div><div class=sect3><h4 id=backups-tapebackups-qic>19.9.3. QIC<a class=anchor href=#backups-tapebackups-qic></a></h4><div class=paragraph><p>Les bandes et les lecteurs QIC-150 sont, peut-être, le format le plus courant. Les lecteurs QIC sont les moins chers des supports de sauvegarde "sérieux". Leur inconvénient par contre est le coût des bandes. Les bandes QIC sont chères comparées aux bandes 8mm ou 4mm, jusqu’à 5 fois le coût au Go. Mais, si une demi-douzaine de bandes vous suffit, le format QIC peut être le bon choix. QIC est le format le <em>plus</em> répandu. Chaque site dispose d’un lecteur QIC d’une densité ou d’une autre. C’est là la difficulté, il existe de nombreuses densités pour des bandes physiquement semblables (parfois même identiques). Les lecteurs QIC ne sont pas silencieux. Ces lecteurs se positionnent bruyamment avant d’enregistrer des données et ont les entend clairement lors de lecture, écriture ou recherche. Les bandes QIC sont volumineuses: 6 x 4 x 0.7 pouces (152 x 102 x 17 mm).</p></div><div class=paragraph><p>Leur débit va de ~150 Ko/s à ~500 Ko/s. Leur capacité varie de 40 Mo à 15 Go. La compression matérielle est disponible sur de nombreux lecteurs récents. Les lecteurs QIC sont de moins en moins utilisés, ils sont supplantés par les lecteurs DAT.</p></div><div class=paragraph><p>Les données sont enregistrées sur des pistes sur la bande. Les pistes sont parallèles à la bande et vont d’une extrémité à l’autre. Le nombre de piste, et par conséquent la largeur des pistes, varie avec la capacité de la bande. La plupart des nouveaux lecteurs fournissent au moins une compatibilité descendante en lecture (mais aussi en écriture). Le format QIC a une bonne réputation de sécurité des données (la mécanique est plus simple et plus robuste que les lecteurs à système en hélice).</p></div><div class=paragraph><p>Les bandes devraient être changée après 5000 sauvegardes.</p></div></div><div class=sect3><h4 id=backups-tapebackups-dlt>19.9.4. DLT<a class=anchor href=#backups-tapebackups-dlt></a></h4><div class=paragraph><p>Les DLT ont le taux de transfert le plus élevé de tous les types de lecteurs décrits ici. La bande d'1/2" (12.5mm) est contenue dans une seule cartouche (4 x 4 x 1 pouces; 100 x 100 x 25 mm). La cartouche est munie d’une trappe basculante le long d’un côté de la cartouche. Le lecteur ouvre cette trappe pour saisir l’amorce de la bande. Cette amorce comporte une découpe ovale que le lecteur utilise pour "crocheter" la bande. La bobine d’entraînement est située dans le lecteur. Tous les autres types de cartouches décrits ici (les bandes 9 pistes sont la seule exception) ont les bobines de stockage et d’entraînement dans la cartouche elle-même.</p></div><div class=paragraph><p>Leur débit est d’environ 1.5 Mo/s, trois fois celui des lecteurs 4mm, 8mm, ou QIC. La capacité d’une bande varie de 10 Go à 20 Go pour une unité simple. Les lecteurs sont disponibles en unités multi-bandes avec changeurs et multi-lecteurs contenant de 5 à 900 bandes et 1 à 20 lecteurs, fournissant une capacité de stockage allant de 50 Go à 9 TO.</p></div><div class=paragraph><p>Avec la compression, le format DLT type IV supporte jusqu’à une capacité de 70 Go.</p></div><div class=paragraph><p>Les données sont enregistrées sur la bande sur des pistes parallèles à la direction de défilement (comme pour les bandes QIC). Deux pistes sont écrites à la fois. La durée de vie des têtes de lecture/écriture est relativement longue; une fois que la bande s’arrête, il n’y a pas de déplacement des têtes par rapport à la bande.</p></div></div><div class=sect3><h4 id=_ait>19.9.5. AIT<a class=anchor href=#_ait></a></h4><div class=paragraph><p>AIT est le nouveau format de Sony, il peut supporter jusqu’à 50 Go par bande (avec compression). Les bandes contiennent un circuit mémoire qui contient un index du contenu de la bande. Cet index peut être lu rapidement par le lecteur pour déterminer l’emplacement de fichiers sur la bande, au lieu des nombreuses minutes nécessaires aux autres types de bande. Des programmes comme SAMS:Alexandria peuvent contrôler quarante ou plus ensemble de bandes AIT, communiquant directement avec le circuit mémoire de la bande pour en afficher le contenu à l’écran, déterminer quels fichiers ont été sauvegardé sur quelle bande, localiser la bonne bande, la charger, et en restaurer les données.</p></div><div class=paragraph><p>Les ensembles de ce type reviennent aux alentour des 20000 dollars, les rendant inaccessibles à l’amateur éclairé.</p></div></div><div class=sect3><h4 id=_utiliser_une_bande_neuve_pour_la_première_fois>19.9.6. Utiliser une bande neuve pour la première fois<a class=anchor href=#_utiliser_une_bande_neuve_pour_la_première_fois></a></h4><div class=paragraph><p>La première fois que vous essayez de lire ou d’écrire sur une bande vierge, l’opération échoue. Les messages affichés par la console devraient être du type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sa0<span class=o>(</span>ncr1:4:0<span class=o>)</span>: NOT READY asc:4,1
sa0<span class=o>(</span>ncr1:4:0<span class=o>)</span>:  Logical unit is <span class=k>in </span>process of becoming ready</code></pre></div></div><div class=paragraph><p>La bande ne contient pas de bloc d’identification (bloc numéro 0). Tous les lecteurs QIC depuis l’adoption du standard QIC-525 écrivent un bloc d’identification sur la bande. Il y a alors deux solutions:</p></div><div class=ulist><ul><li><p><code>mt fsf 1</code> fait écrire au lecteur un bloc d’identification sur la bande.</p></li><li><p>Utiliser le bouton en face avant pour éjecter la bande.</p><div class=paragraph><p>Ré-insérer la bande et utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> pour écrire dessus.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> produira l’erreur <code>DUMP: End of tape detected</code> et la console affichera: <code>HARDWARE FAILURE info:280 asc:80,96</code>.</p></div><div class=paragraph><p>Rembobiner la bande avec: <code>mt rewind</code>.</p></div><div class=paragraph><p>Les manipulations ultérieures sur la bande fonctionneront.</p></div></li></ul></div></div></div><div class=sect2><h3 id=backups-floppybackups>19.10. Sauvegardes sur disquettes<a class=anchor href=#backups-floppybackups></a></h3><div class=sect3><h4 id=floppies-using>19.10.1. Puis-je utiliser des disquettes pour la sauvegarde des mes données?<a class=anchor href=#floppies-using></a></h4><div class=paragraph><p>Les disquettes ne sont pas des supports adaptés à la réalisation de sauvegardes étant donné que:</p></div><div class=ulist><ul><li><p>Le support n’est pas fiable, spécialement sur de longues périodes de temps.</p></li><li><p>Les opérations de sauvegarde et de restauration sont très lentes.</p></li><li><p>Elles ont une capacité très limitée (le jour où l’on pourra sauvegarder l’intégralité d’un disque dur sur une douzaine de disquette n’est pas encore arrivé).</p></li></ul></div><div class=paragraph><p>Cependant, si vous n’avez pas d’autres méthodes pour sauvegarder vos données alors les disquettes sont mieux que pas de sauvegardes du tout.</p></div><div class=paragraph><p>Si vous devez utiliser les disquettes, alors assurez-vous que vous en utiliser des disquettes de bonne qualité. Les disquettes qui traînent sur le bureau depuis quelques années sont un mauvais choix. Idéalement utilisez de des disquettes neuves en provenance d’un fabricant renommé.</p></div></div><div class=sect3><h4 id=floppies-creating>19.10.2. Alors, comment je sauvegarde mes données sur disquettes?<a class=anchor href=#floppies-creating></a></h4><div class=paragraph><p>La meilleur façon de sauvegarder sur disquette est d’utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> avec l’option <code>-M</code> (volume multiple), qui autorise la répartition des sauvegardes sur plusieurs disquettes.</p></div><div class=paragraph><p>Pour sauvegarder tous les fichiers du répertoire courant et des sous-répertoires (en tant que <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mcvf /dev/fd0 *</span></code></pre></div></div><div class=paragraph><p>Quand la première disquette est pleine <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> vous réclamera d’introduire le volume suivant (parce que <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> est indépendant du support il parle en terme de volume; dans notre contexte cela signifie disquette).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Prepare volume 2 <span class=k>for</span> /dev/fd0 and hit <span class=k>return</span>:</code></pre></div></div><div class=paragraph><p>Cette opération est répétée (avec incrémentation du numéro de volume) jusqu’à ce que les fichiers spécifiés soient sauvegardés.</p></div></div><div class=sect3><h4 id=floppies-compress>19.10.3. Puis-je sauvegarder mes sauvegardes?<a class=anchor href=#floppies-compress></a></h4><div class=paragraph><p>Malheureusement, <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> ne permettra pas l’utilisation de l’option <code>-z</code> pour les archives multi-volumes. Vous pourrez, bien sûr, utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> sur tous les fichiers, les archiver avec <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> sur disquettes, puis décompresser les fichiers avec <a href="https://man.freebsd.org/cgi/man.cgi?query=gunzip&amp;sektion=1&amp;format=html">gunzip(1)</a>!</p></div></div><div class=sect3><h4 id=floppies-restoring>19.10.4. Comment puis-je restaurer mes sauvegardes?<a class=anchor href=#floppies-restoring></a></h4><div class=paragraph><p>Pour restaurer une archive complète utiliser:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mxvf /dev/fd0</span></code></pre></div></div><div class=paragraph><p>Vous pouvez utiliser deux manières pour restaurer uniquement certains fichiers. Tout d’abord, vous pouvez commencer avec la première disquette et utiliser:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mxvf /dev/fd0 nomdufichier</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> vous demandera d’insérer les disquettes suivantes jusqu’à trouver le fichier recherché.</p></div><div class=paragraph><p>Alternativement, si vous savez sur quelle disquette le fichier se trouve alors vous pouvez simplement insérer cette disquette et utiliser la commande précédente. Notez que si le premier fichier sur la disquette est la suite d’un fichier de la précédente disquette alors <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> vous avertira qu’il ne peut le restaurer, même si vous ne le voulez pas!</p></div></div></div><div class=sect2><h3 id=backup-strategies>19.11. Stratégies de sauvegarde<a class=anchor href=#backup-strategies></a></h3><div class=paragraph><p>La première chose a faire lors de la mise en place d’un plan de sauvegarde est de s’assurer que l’ensemble des problèmes suivants sera couvert:</p></div><div class=ulist><ul><li><p>Panne d’un disque</p></li><li><p>Suppression accidentelle de fichiers</p></li><li><p>Corruption aléatoire de fichiers</p></li><li><p>Destruction complète de la machine (par exemple suite à un incendie), avec destruction des sauvegardes stockées sur le même site.</p></li></ul></div><div class=paragraph><p>Il est parfaitement possible que certains systèmes utilisent une technique différente pour chacun des problèmes évoqués ci-dessus. En dehors des systèmes personnels avec des données peu importantes, il est peu probable qu’une seule technique puisse répondre à l’ensemble de ces risques.</p></div><div class=paragraph><p>Quelques-unes des techniques à notre disposition sont:</p></div><div class=ulist><ul><li><p>Des archives de tout le système, sauvegardées sur un support fiable et à l’extérieur du site. C’est une protection réelle contre tous les problèmes précédemment cités, mais cette méthode est lente et peu pratique lors des restaurations. Vous pouvez conserver des copies de ces sauvegardes sur site et/ou en ligne, mais il y aura toujours des difficultés lors de la restauration des fichiers, en particulier pour les utilisateurs sans droits.</p></li><li><p>Instantané de systèmes de fichiers. Cet outil n’est vraiment utile que dans le cas d’une suppression accidentelle de fichiers, mais il l’est <em>vraiment</em> dans ce cas; de plus cette méthode est rapide et simple à employer.</p></li><li><p>Copies de l’intégralité des systèmes de fichiers et/ou des disques (par une utilisation régulière de <a href="https://man.freebsd.org/cgi/man.cgi?query=rsync&amp;sektion=1&amp;format=html">rsync(1)</a> sur l’intégralité de la machine par exemple). C’est le procédé en général le plus utile dans le cas des réseaux avec des besoins spécifiques. Dans le cas d’une protection contre les pannes disques, cette méthode est normalement inférieure à un système RAID. Pour la restauration de fichiers supprimés accidentellement, c’est comparable aux instantanés UFS, c’est plus une question de préférence.</p></li><li><p>RAID. Réduit ou évite les périodes où le système est inutilisable quand un disque tombe en panne. Avec l’inconvénient d’avoir à faire face à des pannes disques plus fréquentes (parce que vous utilisez plus de disques), mais avec cependant une moindre urgence.</p></li><li><p>Le contrôle des empreintes de fichiers. L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a> est très utile dans ce cas. Bien que cela ne soit pas une technique de sauvegarde des données, ce contrôle aidera à garantir que vous serez averti quand vous devrez ressortir vos sauvegardes. C’est tout particulièrement important dans le cas de sauvegardes hors site, et ces empreintes devraient être vérifiées régulièrement.</p></li></ul></div><div class=paragraph><p>Il est relativement simple de trouver d’autres solutions, nombreuses sont celles qui sont des variations des techniques présentées ci-dessus. Des besoins spécifiques conduiront généralement à des solutions spécifiques (par exemple sauvegarder une base de données durant son utilisation demande une étape intermédiaire spécifique au logiciel de base de données). L’important est de connaître les dangers contre lesquels vous désirez vous protéger, et comment vous ferez face à chacun d’entre eux.</p></div></div><div class=sect2><h3 id=backup-basics>19.12. Sauvegardes<a class=anchor href=#backup-basics></a></h3><div class=paragraph><p>Les trois principaux programmes de sauvegarde sont: <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>.</p></div><div class=sect3><h4 id=_dump_et_restore>19.12.1. Dump et Restore<a class=anchor href=#_dump_et_restore></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> sont les programmes de sauvegarde traditionnels d’UNIX®. Ils opèrent sur le disque comme sur une suite de blocs disque, en dessous du niveau d’abstraction que constituent les fichiers, liens et répertoires créés par les systèmes de fichiers. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> sauvegarde l’intégralité d’un système de fichiers d’un périphérique. Il est incapable de sauvegarder seulement une partie d’un système de fichiers ou une arborescence de répertoires s’étalant sur plus d’un système de fichiers. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> n’écrit pas de fichiers ou des répertoires sur la bande, mais écrit plutôt les blocs de données brutes dont sont constitués les fichiers et les répertoires.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> sur votre répertoire racine, vous ne sauvegarderez pas <span class=filename>/home</span>, <span class=filename>/usr</span> ou beaucoup d’autres répertoires puisque que ces derniers sont généralement des points de montages pour d’autres systèmes de fichiers ou des liens symboliques vers ces systèmes de fichiers.</p></div></td></tr></tbody></table></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> a quelques particularités datant de ses débuts sous la version 6 d’ATT UNIX (circa 1975). Les paramètres par défaut conviennent aux bandes 9 pistes (6250 bpi), et non aux supports à haute densité d’aujourd’hui (jusqu’à 62182 ftpi). Il faut surcharger ces valeurs par défaut sur la ligne de commande pour utiliser la capacité des bandes actuelles.</p></div><div class=paragraph><p>Il est également possible de sauvegarder les données par l’intermédiaire d’un réseau sur un lecteur de bande se trouvant sur une autre ordinateur à l’aide des commandes <code>rdump</code> et <code>rrestore</code>. Ces deux programmes utilisent <a href="https://man.freebsd.org/cgi/man.cgi?query=rcmd&amp;sektion=3&amp;format=html">rcmd(3)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=ruserok&amp;sektion=3&amp;format=html">ruserok(3)</a> pour accéder à l’unité de bandes distante. Cependant, l’utilisateur effectuant une sauvegarde doit être présent dans le fichier <span class=filename>.rhosts</span> sur la machine distante. Les arguments de <a href="https://man.freebsd.org/cgi/man.cgi?query=rdump&amp;sektion=8&amp;format=html">rdump(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=rrestore&amp;sektion=8&amp;format=html">rrestore(8)</a> doivent être compatibles avec une utilisation sur la machine distante. Quand on sauvegarde une machine FreeBSD sur un lecteur Exabyte installé sur un ordinateur Sun appelé <code>komodo</code>, utilisez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</span></code></pre></div></div><div class=paragraph><p>Attention: il y a des conséquences pour la sécurité à utiliser l’authentification <span class=filename>.rhosts</span>. Evaluez soigneusement votre situation.</p></div><div class=paragraph><p>Il est également possible d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> d’une façon plus sécurisée sur <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>.</p></div><div class=exampleblock><div class=title>Exemple 29. Utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> sur ssh</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
          targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>Ou en utilisant une fonction interne de <code>dump</code>, positionner la variable d’environnement <code>RSH</code>:</p></div><div class=exampleblock><div class=title>Exemple 30. Utiliser <code>dump</code> sur ssh avec la variable <code>RSH</code> positionnée</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_tar>19.12.2. <code>tar</code><a class=anchor href=#_tar></a></h4><div class=paragraph><p>Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> date aussi de la Version 6 d’ATT UNIX (circa 1975). <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> travaille en coopération avec le système de fichiers; il permet d’écrire des fichiers et des répertoires sur bandes. <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> ne supporte pas toutes les options permises par <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>, mais ne demande pas l’inhabituelle concaténation de commandes qu’utilise <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a></p></div><div class=paragraph><p>Sous FreeBSD 5.3 et versions suivantes, GNU <code>tar</code> et la version par défaut <code>bsdtar</code> sont disponibles. La version GNU peut être invoquée avec la commande <code>gtar</code>. Elle supporte les sauvegardes sur des périphériques distants et cela avec la même syntaxe que <a href="https://man.freebsd.org/cgi/man.cgi?query=rdump&amp;sektion=8&amp;format=html">rdump(8)</a>. Pour sauvegarder avec <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> sur une unité Exabyte connectée sur une machine Sun appelée <code>komodo</code>, utilisez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/bin/gtar cf komodo:/dev/nsa8 . 2&gt;&amp;1</span></code></pre></div></div><div class=paragraph><p>La même opération peut être effectuée avec <code>bsdtar</code> en utilisant un tuyau et <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> pour envoyer les données sur un lecteur de bande distant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cf - . | rsh hostname dd of=tape-device obs=20b</span></code></pre></div></div><div class=paragraph><p>Si vous êtes inquiet au sujet de la sécurité de sauvegardes par réseau, vous devriez utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> à la place de <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>.</p></div></div><div class=sect3><h4 id=_cpio>19.12.3. <code>cpio</code><a class=anchor href=#_cpio></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> est le programme UNIX® original pour l’échange de fichiers par bandes magnétiques. <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> dispose d’options (parmi beaucoup d’autres) pour intervertir les octets, utiliser de nombreux différents formats, et envoyer les données à d’autres programmes. Cette dernière caractéristique fait de <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> un excellent choix pour les supports d’installation. <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> ne sait pas parcourir une arborescence de répertoires et il faut lui passer la liste des fichiers via <span class=filename>stdin</span>.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> ne supporte pas les sauvegardes par le réseau. Vous pouvez utiliser un tuyau et <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> pour envoyer les données sur un lecteur de bande distant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for f in directory_list; do</span>
find <span class=nv>$f</span> <span class=o>&gt;&gt;</span> backup.list
<span class=k>done</span>
<span class=c># cpio -v -o --format=newc &lt; backup.list | ssh user@host &#34;cat &gt; backup_device&#34;</span></code></pre></div></div><div class=paragraph><p>Où <em>directory_list</em> est la liste des répertoires que vous désirez sauvegarder, <em>user</em>@<em>host</em> est l’ensemble utilisateur/nom de machine qui effectuera les sauvegardes, et <em>backup_device</em> représente l’unité où seront écrites les sauvegardes (e.g., <span class=filename>/dev/nsa0</span>).</p></div></div><div class=sect3><h4 id=_pax>19.12.4. <code>pax</code><a class=anchor href=#_pax></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> est la réponse IEEE/POSIX® à <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>. Au fil des ans les différentes versions de <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> sont devenues légèrement incompatibles. Aussi, plutôt que de batailler pour les standardiser entièrement, POSIX® a défini un nouvel utilitaire d’archivage. <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> tente de lire et d’écrire nombre des divers formats <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>, en plus de ses propres nouveaux formats. Son ensemble de commandes ressemble plus à celui de <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> qu’à celui de <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>.</p></div></div><div class=sect3><h4 id=backups-programs-amanda>19.12.5. Amanda<a class=anchor href=#backups-programs-amanda></a></h4><div class=paragraph><p>Amanda (Advanced Maryland Network Disk Archiver-Système Avancé d’Archivage de Disques en Réseau du Maryland) est un système d’archivage client/serveur plutôt qu’un simple programme. Un serveur Amanda archivera sur une seule unité de bandes un nombre quelconque d’ordinateurs disposant de clients Amanda et un accès réseau au serveur Amanda. Un problème classique sur les sites qui ont de nombreux disques volumineux est que le temps nécessaire pour sauvegarder directement les données sur la bande dépasse le temps alloué à cette tâche. Amanda résout ce problème. Amanda peut utiliser un "disque intermédiaire" pour sauvegarder plusieurs systèmes de fichiers à la fois. Amanda des "jeux d’archive": un ensemble de bandes utilisé pour une période donnée pour créer une sauvegarde complète de tous les systèmes de fichiers listé dans le fichier de configuration d’Amanda. Le "jeu d’archive" contient également les sauvegardes nocturnes incrémentales (ou différentielles) de tous les systèmes de fichiers. Pour restaurer une système de fichiers endommagé, il faut la sauvegarde complète la plus récente et les sauvegardes incrémentales.</p></div><div class=paragraph><p>Le fichier de configuration permet un contrôle en finesse des sauvegardes et du trafic réseau qu’Amanda génère. Amanda utilisera n’importe quel des programmes de sauvegarde décrits plus haut pour écrire les données sur bande. Amanda est disponible sous forme de logiciel porté ou de logiciel pré-compilé, il n’est pas installé par défaut.</p></div></div><div class=sect3><h4 id=_ne_rien_faire>19.12.6. Ne rien faire<a class=anchor href=#_ne_rien_faire></a></h4><div class=paragraph><p>"Ne rien faire" n’est pas un logiciel, mais c’est la stratégie de sauvegarde la plus utilisée. Il n’y a aucun investissement initial. Il n’y a pas de de planification des sauvegardes à suivre. Juste dire non. Si quelque chose arrive à vos données, souriez et débrouillez-vous!</p></div><div class=paragraph><p>Si votre temps et vos données ne valent pas grand chose, alors "Ne rien faire" est le programme de sauvegarde le mieux adapté à votre ordinateur. Mais prenez garde, UNIX® est un outil utile, et vous pouvez vous rendre compte au bout de six mois que vous disposez d’une collection de fichiers qui vous sont utiles.</p></div><div class=paragraph><p>"Ne rien faire" est la bonne méthode de sauvegarde pour <span class=filename>/usr/obj</span> et les autres répertoires qui peuvent facilement être recréés par votre ordinateur. Un exemple est les fichiers qui constituent la version HTML ou PostScript® de ce manuel. Ces fichiers ont été générés à partir de fichiers SGML. Faire des sauvegardes des fichiers HTML ou PostScript® n’est pas nécessaire. Les fichiers source SGML sont sauvegardés régulièrement.</p></div></div><div class=sect3><h4 id=_quel_est_le_meilleur_programme_de_sauvegarde>19.12.7. Quel est le meilleur programme de sauvegarde?<a class=anchor href=#_quel_est_le_meilleur_programme_de_sauvegarde></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> <em>Point.</em> Elizabeth D. Zwicky a soumis à rude épreuve tous les programmes de sauvegarde dont nous avons parlé. Le choix de <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> s’impose pour préserver toutes vos données et les particularités des systèmes de fichiers UNIX®. Elizabeth a créé des systèmes de fichiers avec une grande variété de particularités inhabituelles (et quelques unes pas tellement inhabituelles) et a testé chacun des programmes en faisant une sauvegarde et une restauration de ces systèmes de fichiers. Parmi les spécificités testées: fichiers avec des trous, fichiers avec des trous et des blocs de caractères "null", fichiers dont les noms comportent des caractères inhabituels, les fichiers illisibles ou impossible à modifier, les périphériques, fichiers dont la taille change pendant la sauvegarde, fichiers créés ou détruits en cours de sauvegarde et bien plus. Elle a présenté les résultats de ces tests au LISA V en Octobre 1991. Voir les <a href=http://berdmann.dyndns.org/zwicky/testdump.doc.html>tests d’endurance des programmes de sauvegarde et d’archivage</a>.</p></div></div><div class=sect3><h4 id=_procédure_de_restauration_durgence>19.12.8. Procédure de restauration d’urgence<a class=anchor href=#_procédure_de_restauration_durgence></a></h4><div class=sect4><h5 id=_avant_le_désastre>19.12.8.1. Avant le désastre<a class=anchor href=#_avant_le_désastre></a></h5><div class=paragraph><p>Il y a quatre étapes à mettre en oeuvre en prévision d’un désastre éventuel.</p></div><div class=paragraph><p>Tout d’abord, imprimez le label de chacun de vos disques (par exemple <code>bsdlabel da0 | lpr</code>), votre table des systèmes de fichiers (<span class=filename>/etc/fstab</span>) et tous les messages de démarrage, en deux exemplaires.</p></div><div class=paragraph><p>Deuxièmement, vérifiez que vos disquettes de démarrage et de reprise d’urgence (<span class=filename>boot.flp</span> et <span class=filename>fixit.flp</span>) incluent tous vos périphériques. La méthode la plus simple pour vérifier est de redémarrer avec la disquette de démarrage dans le lecteur et contrôler les messages de démarrage. Si tous vos périphériques sont listés et opérationnels, passez à la troisième étape.</p></div><div class=paragraph><p>Sinon, vous devez créer deux disquettes de démarrage sur-mesure avec un noyau qui puisse monter tous vos disques et accéder à votre unité de bandes. Ces disquettes doivent contenir: <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, et le programme de sauvegarde que vous utilisez. L’édition de liens de ces programmes doit être statique. Si vous utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, la disquette doit contenir <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>.</p></div><div class=paragraph><p>Troisièmement, faites régulièrement des sauvegardes sur bandes. Toutes les modifications effectuées après votre dernière sauvegarde peuvent irrémédiablement perdues. Protégez vos bandes de sauvegarde en écriture.</p></div><div class=paragraph><p>Quatrièmement, testez les disquettes (soit <span class=filename>boot.flp</span> et <span class=filename>fixit.flp</span> soit les deux disquettes sur-mesure que vous avez créées à la seconde étape) et vos bandes de sauvegarde. Prenez note de la procédure. Conservez ces notes avec la disquette de démarrage, les impressions et les bandes de sauvegarde. Vous serez si préoccupé quand vous devrez restaurer que ces notes peuvent vous éviter de détruire vos bandes de sauvegarde (Comment? Au lieu de <code>tar xvf /dev/sa0</code>, vous pourriez taper accidentellement <code>tar cvf /dev/sa0</code>, ce qui écraserait votre bande de sauvegarde).</p></div><div class=paragraph><p>Par mesure de sécurité, créez une disquette de démarrage et deux bandes de sauvegarde à chaque fois. Conservez-les dans un lieu éloigné. Un endroit éloigné n’est PAS le sous-sol du même bâtiment. Un certain nombre de compagnies du World Trade Center l’ont appris à leurs dépends. Un endroit éloigné doit être physiquement séparé de vos ordinateurs et de vos disques par une distance significative.</p></div><div class=exampleblock><div class=title>Exemple 31. Procédure de création d’une disquette de démarrage</div><div class=content><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo &#34;Bad floppy, please use a new one&#34;
	 exit 1
fi

# place boot blocks on the floppy
#
bsdlabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat &amp;lt;&amp;lt; EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI - A kernel to get FreeBSD onto a disk.
#
machine         &#34;i386&#34;
cpu             &#34;I486_CPU&#34;
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port &#34;IO_FD1&#34; bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port &#34;IO_KBD&#34; tty irq 1 vector scintr
device          npx0	at isa? port &#34;IO_NPX&#34; irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out&#39;s
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init &gt; /mnt/sbin/init
gzip -c -best /sbin/fsck &gt; /mnt/sbin/fsck
gzip -c -best /sbin/mount &gt; /mnt/sbin/mount
gzip -c -best /sbin/halt &gt; /mnt/sbin/halt
gzip -c -best /sbin/restore &gt; /mnt/sbin/restore

gzip -c -best /bin/sh &gt; /mnt/bin/sh
gzip -c -best /bin/sync &gt; /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat &amp;lt; /mnt/etc/fstab &amp;lt;&amp;lt;EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat &amp;lt; /mnt/etc/passwd &amp;lt;&amp;lt;EOM
root:*:0:0:Charlie &amp;amp;:/root:/bin/sh
EOM

cat &amp;lt; /mnt/etc/master.passwd &amp;lt;&amp;lt;EOM
root::0:0::0:0:Charlie &amp;amp;:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo &#34;The floppy has been unmounted and is now ready.&#34;</pre></div></div></div></div></div><div class=sect4><h5 id=_après_le_désastre>19.12.8.2. Après le désastre<a class=anchor href=#_après_le_désastre></a></h5><div class=paragraph><p>La question cruciale est: votre matériel a-t-il survécu? Vous avez régulièrement fait des sauvegardes, vous n’avez donc pas besoin de vous inquiéter pour les fichiers et les programmes.</p></div><div class=paragraph><p>Si le matériel a subi des dégâts, remplacez tout d’abord ce qui a été endommagé avant de tenter d’utiliser l’ordinateur.</p></div><div class=paragraph><p>Si votre matériel est en état, contrôlez vos disquettes. Si vous utilisez une disquette de démarrage personnalisée, démarrez en mode mono-utilisateur (tapez <code>-s</code> à l’invite <code>boot:</code>). Sautez le paragraphe suivant.</p></div><div class=paragraph><p>Si vous utilisez les disquettes <span class=filename>boot.flp</span> et <span class=filename>fixit.flp</span>, continuez à lire. Mettre la disquette <span class=filename>boot.flp</span> dans le premier lecteur et démarrez l’ordinateur. Le menu d’installation d’origine s’affiche à l’écran. Choisissez l’option <span class=guimenuitem>Fixit—​Repair mode with CDROM or floppy.</span>. Insérez la disquette <span class=filename>fixit.flp</span> quand on vous la demande. <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> et les autres programmes dont vous avez besoin sont situés dans le répertoire <span class=filename>/mnt2/rescue</span> (<span class=filename>/mnt2/stand</span> pour les versions de FreeBSD antérieures à la 5.2).</p></div><div class=paragraph><p>Restaurez chaque système de fichiers séparément.</p></div><div class=paragraph><p>Essayez <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> (e.g. <code>mount /dev/da0a /mnt</code>) sur la partition racine de votre premier disque. Si le label du disque est endommagé, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> pour repartitionner et libeller le disque conformément au label que vous avez imprimé et mis de côté. Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> pour recréer les systèmes de fichiers. Remontez la partition racine de la disquette en lecture/écriture (<code>mount -u -o rw /mnt</code>). Utilisez votre programme de restauration et vos bandes de sauvegardes pour restaurer les données de ce système de fichiers (e.g. <code>restore vrf /dev/sa0</code>). Démontez le système de fichiers (e.g. <code>umount /mnt</code>). Répétez l’opération pour chacun des systèmes de fichiers endommagés.</p></div><div class=paragraph><p>Une fois que le système fonctionne à nouveau, faites une sauvegarde sur de nouvelles bandes. Ce qui a causé la panne ou la perte de données peut se reproduire. Une heure de perdue maintenant peut vous épargner d’autres ennuis plus tard.</p></div></div></div></div><div class=sect2><h3 id=disks-virtual>19.13. Systèmes de fichiers réseaux, en mémoire et sauvegardés sur fichier<a class=anchor href=#disks-virtual></a></h3><div class=paragraph><p>En plus des disques que vous introduisez physiquement dans votre ordinateur: disquettes, CD, disques durs, et ainsi de suite; d’autres formes de disques sont gérées par FreeBSD - les <em>disques virtuels</em>.</p></div><div class=paragraph><p>Ceux-ci comprennent les systèmes de fichiers réseaux comme le <a href=./#network-nfs>NFS</a> et Coda, les systèmes de fichiers en mémoire et les systèmes de fichiers sauvegardé dans un fichier.</p></div><div class=paragraph><p>En fonction de la version de FreeBSD que vous utilisez, vous devrez utiliser des outils différents pour la création et l’utilisation de systèmes de fichiers en mémoire ou sauvegardé dans un fichier.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> pour allouer de façon transparente pour l’utilisateur les fichiers spéciaux de périphériques.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=disks-mdconfig>19.13.1. Système de fichiers sauvegardé dans un fichier<a class=anchor href=#disks-mdconfig></a></h4><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> est utilisé pour configurer et activer les disques mémoires, <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>, sous FreeBSD. Pour utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>, vous devez charger le module <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> ou en ajouter le support dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> supporte trois sortes de disques virtuels en mémoire: les disques mémoire alloués avec <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>, les disques mémoires utilisant un fichier ou l’espace de pagination comme espace disque. Une des utilisations possibles est le montage d’images de disquettes ou de CDs conservées sous forme de fichier.</p></div><div class=paragraph><p>Pour monter l’image d’un système de fichiers:</p></div><div class=exampleblock><div class=title>Exemple 32. Utilisation de <code>mdconfig</code> pour monter une image d’un système de fichiers</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f diskimage -u 0</span>
<span class=c># mount /dev/md0 /mnt</span></code></pre></div></div></div></div><div class=paragraph><p>Pour créer l’image d’un nouveau système de fichiers avec <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>:</p></div><div class=exampleblock><div class=title>Exemple 33. Création d’un nouveau disque sauvegardé sur fichier avec <code>mdconfig</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdconfig -a -t vnode -f newimage -u 0</span>
<span class=c># bsdlabel -w md0 auto</span>
<span class=c># newfs md0a</span>
/dev/md0a: 5.0MB <span class=o>(</span>10224 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2720, 5280, 7840
<span class=c># mount /dev/md0a /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>Si vous ne préciser pas de numéro d’unité avec l’option <code>-u</code>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> utilisera le mécanisme d’allocation automatique de <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> pour sélectionner un périphérique libre. Le nom de l’unité allouée s’affichera sur la sortie standard comme par exemple <span class=filename>md4</span>. Pour plus de détails concernant <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>, référez-vous à la page de manuel.</p></div><div class=paragraph><p>L’outil <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> est très utile, cependant son utilisation demande de nombreuses lignes de commandes pour créer un système de fichiers sauvegardé sur fichier. FreeBSD vient avec un outil appelé <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>, ce programme configure un disque <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>, y ajoute dessus un système de fichiers UFS en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>, et le monte avec <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Par exemple, si vous désirez créer et monter la même image de système de fichiers que précédemment, tapez simplement ce qui suit:</p></div><div class=exampleblock><div class=title>Exemple 34. Création et montage d’un disque sauvegardé sur fichier avec <code>mdmfs</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdmfs -F newimage -s 5m md0 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>Si vous utilisez l’option <code>md</code> sans numéro d’unité, <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> utilisera la fonction automatique de sélection d’unité de <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> pour choisir un périphérique non utilisé. Pour plus de détails au sujet de <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>, référez-vous à la page de manuel.</p></div></div><div class=sect3><h4 id=disks-md-freebsd5>19.13.2. Système de fichiers en mémoire<a class=anchor href=#disks-md-freebsd5></a></h4><div class=paragraph><p>Pour un système de fichiers en mémoire la "sauvegarde sur l’espace de pagination" devrait être normalement utilisée. Utiliser l’espace de pagination ne signifie pas que le disque en mémoire sera par défaut sur l’espace de pagination, mais plutôt que le disque mémoire sera alloué sur une zone de mémoire qui pourra être sauvegardée sur l’espace de pagination si nécessaire. Il est également possible de créer un disque en mémoire dont la mémoire est allouée à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>, mais ce type de configuration, tout particulièrement dans le cas de disques de grande taille, peut donner lieu à une panique du système si le noyau se trouve à cours de mémoire.</p></div><div class=exampleblock><div class=title>Exemple 35. Création d’un disque mémoire avec <code>mdconfig</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t swap -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2752, 5344, 7936
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre></div></div></div></div><div class=exampleblock><div class=title>Exemple 36. Création d’un disque mémoire avec <code>mdmfs</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -s 5m md2 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</code></pre></div></div></div></div></div><div class=sect3><h4 id=_détacher_un_disque_mémoire_du_système>19.13.3. Détacher un disque mémoire du système<a class=anchor href=#_détacher_un_disque_mémoire_du_système></a></h4><div class=paragraph><p>Quand un système de fichiers en mémoire ou sauvegardé dans un fichier n’est pas utilisé, vous devriez rendre au système toutes les ressources. La première chose à faire est de démonter le système de fichiers, ensuite utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> pour détacher le disque du système et rendre les ressources.</p></div><div class=paragraph><p>Par exemple pour détacher et libérer toutes les ressources utilisées par <span class=filename>/dev/md4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Il est possible d’afficher des informations sur les périphériques <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> configurés en utilisant la commande <code>mdconfig -l</code>.</p></div></div></div><div class=sect2><h3 id=snapshots>19.14. Instantané ("Snapshot") d’un système de fichiers<a class=anchor href=#snapshots></a></h3><div class=paragraph><p>FreeBSD en association avec les <a href=./#soft-updates>Soft Updates</a> offre une nouvelle caractéristique: les instantanés de systèmes de fichiers ("file system snapshots").</p></div><div class=paragraph><p>Les instantanés permettent à un utilisateur de créer des images d’un système de fichiers précis, et de les traiter comme un fichier. Les instantanés doivent être créés dans le système de fichiers sur lequel on veut effectuer l’opération, et un utilisateur ne pourra pas créer plus de 20 instantanés par système de fichiers. Les instantanés actifs sont enregistrés dans le superbloc, ils sont donc conservés durant les opérations de démontage et de remontage lors des redémarrages du système. Quand un instantané n’est plus requis, il peut être supprimé avec la commande standard <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. Les instantanés peuvent être supprimés dans n’importe quel ordre, cependant tout l’espace utilisé pourra ne pas être à nouveau disponible car un autre instantané réclamera éventuellement les blocs libérés.</p></div><div class=paragraph><p>L’indicateur inaltérable <code>snapshot</code> est positionné lors de la création initiale de l’instantané. La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> fait une exception pour les fichiers d’instantanés puisqu’elle autorise leur suppression.</p></div><div class=paragraph><p>Les instantanés sont créés avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Pour placer un instantané de <span class=filename>/var</span> dans le fichier <span class=filename>/var/snapshot/snap</span> utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>Alternativement, vous pouvez utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> pour créer un instantané:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>Les fichiers d’instantanés peuvent être localisés sur un système de fichiers (e.g. <span class=filename>/var</span>) en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Une fois un instantané créé, ce dernier pourra avoir de nombreux usages:</p></div><div class=ulist><ul><li><p>Certains administrateurs utiliseront un instantané pour des besoins de sauvegarde, car l’instantané peut être transféré sur CD ou bande.</p></li><li><p>Un contrôle d’intégrité du système fichiers, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, pourra être effectué sur l’instantané. En supposant que le système de fichiers était propre quand il a été monté, vous devriez toujours obtenir un résultat positif (et non différent). C’est essentiellement que effectue le processus de <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> en tâche de fond ("background <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>").</p></li><li><p>Lancer l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> sur l’instantané. Une image cohérente du système de fichiers avec les paramètres temporels de l’instantané sera produite. <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> peut également à partir d’un instantané, créer une image et puis supprimer l’instantané en une seule fois en utilisant l’indicateur <code>-L</code> dans la ligne de commande.</p></li><li><p>Monter l’instantané comme une image figée du système de fichiers. Pour monter l’instantané <span class=filename>/var/snapshot/snap</span> lancer:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>Vous pouvez maintenant parcourir l’arborescence de votre système de fichiers <span class=filename>/var</span> figé monter sous <span class=filename>/mnt</span>. Tout sera au départ dans le même état que lors de la création de l’instantané. La seule exception est que les instantanés antérieurs apparaîtront sous la forme de fichiers vides. Quand l’utilisation d’un instantané est terminée, il peut être démonté avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Pour plus d’informations sur les <code>softupdates</code> et les instantanés de systèmes de fichiers, et également de la documentation technique, vous pouvez consulter le site Web de Marshall Kirk McKusick à l’adresse <a href=http://www.mckusick.com/>http://www.mckusick.com/</a></p></div></div><div class=sect2><h3 id=quotas>19.15. Quotas d’utilisation des disques<a class=anchor href=#quotas></a></h3><div class=paragraph><p>Les quotas sont une option du système d’exploitation qui vous permet de limiter la quantité d’espace disque et/ou le nombre de fichiers auxquels ont droit un utilisateur ou tous les utilisateurs d’un même groupe, sur un système de fichiers donné. On les utilise la plupart du temps sur les systèmes en temps partagé où il est souhaitable de limiter la quantité de ressources allouée à un utilisateur ou à un groupe. Cela évitera qu’un utilisateur ou un groupe d’utilisateur consomme tout l’espace disque.</p></div><div class=sect3><h4 id=_configurer_votre_système_pour_pouvoir_utiliser_les_quotas_dutilisation_des_disques>19.15.1. Configurer votre système pour pouvoir utiliser les quotas d’utilisation des disques<a class=anchor href=#_configurer_votre_système_pour_pouvoir_utiliser_les_quotas_dutilisation_des_disques></a></h4><div class=paragraph><p>Avant d’essayer de mettre en place des quotas disque, il est nécessaire de s’assurer que le noyau est configuré pour les quotas. Cela se fait en ajoutant la ligne suivante dans votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Cette option n’est pas activée par défaut dans le noyau <span class=filename>GENERIC</span> de base, vous devrez donc configurer, compiler et installer un noyau sur-mesure pour utiliser les quotas disque. Reportez-vous au chapitre <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a> pour plus d’informations sur la configuration du noyau.</p></div><div class=paragraph><p>Ensuite vous devrez activer les quotas disques dans le fichier <span class=filename>/etc/rc.conf</span>. Pour cela, ajoutez la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>enable_quotas=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Pour un contrôle plus fin des quotas au démarrage du système, il existe une variable supplémentaire de configuration. Normalement au démarrage, l’intégrité des quotas sur chaque système de fichiers est vérifiée par le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>. Ce programme s’assure que les données de la base de données des quotas correspondent bien aux données présentes sur le système de fichiers. C’est un processus consommateur en temps qui affectera considérablement la durée de démarrage du système. Si vous désirez passer cette étape, une variable dans <span class=filename>/etc/rc.conf</span> est prévue à cet effet:</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Vous devez enfin éditer le fichier <span class=filename>/etc/fstab</span> pour activer les quotas système de fichiers par système de fichiers. C’est là que vous pouvez soit activer les quotas par utilisateur ou par groupe soit les pour les deux sur tous vos systèmes de fichiers.</p></div><div class=paragraph><p>Pour activer les quotas par utilisateur sur un système de fichiers, ajouter l’option <code>userquota</code> dans le champ d’options sur l’entrée de <span class=filename>/etc/fstab</span> pour le système de fichiers sur lequel vous voulez activer les quotas. Par exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>De même, pour activer les quotas par groupe, utilisez l’option <code>groupquota</code> à la place de <code>userquota</code>. Pour activer à la fois les quotas par utilisateur et par groupe, modifiez l’entrée de la façon suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>Par défaut, les fichiers où sont définis les quotas dans le répertoire racine du système de fichiers sous les noms <span class=filename>quota.user</span> et <span class=filename>quota.group</span>, respectivement pour les quotas utilisateur et les quotas par groupe. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> pour plus d’information. Bien que la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> indique que vous pouvez spécifier un autre emplacement pour ces fichiers, cela n’est pas recommandé parce que les divers utilitaires qui gèrent les quotas ne semblent pas les prendre correctement en compte.</p></div><div class=paragraph><p>A ce point vous devriez redémarrer votre système avec votre nouveau noyau. La procédure <span class=filename>/etc/rc</span> exécutera automatiquement les commandes nécessaires pour créer les fichiers de quotas initiaux pour tous les quotas que vous avez définis dans <span class=filename>/etc/fstab</span>, vous n’avez donc pas besoin de créer à la main de fichiers de quotas vides.</p></div><div class=paragraph><p>Vous ne devriez pas avoir à exécuter les commandes <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a>, ou <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a> manuellement. Cependant, vous pouvez lire leur page de manuel pour vous familiariser avec leur rôle.</p></div></div><div class=sect3><h4 id=_définir_les_quotas>19.15.2. Définir les quotas<a class=anchor href=#_définir_les_quotas></a></h4><div class=paragraph><p>Une fois que vous avez activé les quotas sur votre système, assurez-vous que cela fonctionne correctement. Une manière simple de le faire est d’exécuter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>Vous devriez obtenir une ligne résumant l’utilisation disque avec les quotas actuellement définis pour chaque système de fichiers sur lesquels il y a des quotas.</p></div><div class=paragraph><p>Vous êtes maintenant prêt à définir les quotas avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div><div class=paragraph><p>Vous disposez de différentes options pour instaurer les quotas d’espace disque alloué à un utilisateur ou à un groupe, et le nombre de fichiers qu’ils peuvent créer. Vous pouvez baser les limitations sur l’espace disque alloué (quotas en nombre de blocs) ou sur le nombre de fichiers (quotas en inode) ou les deux. Ces options peuvent être divisées en deux catégories: les limites strictes ou souples.</p></div><div class=paragraph><p>Une limite stricte ne peut être dépassée. Une fois qu’un utilisateur atteint sa limite stricte, il ne pourra plus rien allouer sur le système de fichiers en question. Par exemple, si l’utilisateur a droit à une limite stricte de 500 Ko sur un système de fichiers et en utilise 490 Ko, il ne pourra allouer que 10 Ko supplémentaires. Une tentative d’allouer 11 Ko échouerait.</p></div><div class=paragraph><p>Une limite souple peut être dépassée pour une période de temps restreinte. C’est ce que l’on appelle le délai de grâce, qui est d’une semaine par défaut. Si un utilisateur dépasse cette limite au delà du délai de grâce, cette limite devient stricte, et plus aucune allocation ne sera possible. Quand l’utilisateur redescend en dessous de la limite souple, le délai de grâce est à nouveau réaccordé.</p></div><div class=paragraph><p>Ce qui suit est un exemple de ce que vous pourrez voir en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>. Quand vous invoquez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>, vous vous retrouvez dans l’éditeur défini par la variable d’environnement <code>EDITOR</code>, ou sous vi si la variable d’environnement <code>EDITOR</code> n’est pas positionnée, ce qui vous permet d’éditer les quotas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</pre></div></div><div class=paragraph><p>Vous verrez normalement deux lignes pour chaque système de fichiers sur lequel il y a des quotas. Une ligne pour les quotas de blocs, et une autre pour la limite d’inode. Modifiez simplement les valeurs que vous voulez mettre à jour. Par exemple, pour augmenter la limite de blocs accordée à cet utilisateur de 50 pour la limite souple et de 75 pour la limite stricte à 500 pour la limite souple et 600 pour la limite stricte, modifiez:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</pre></div></div><div class=paragraph><p>en:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>Les nouveaux quotas seront en service dès que vous quitterez l’éditeur.</p></div><div class=paragraph><p>Il est parfois souhaitable de définir des quotas pour une plage d’UIDs (identifiants utilisateur). Cela peut être réalisé avec l’option <code>-p</code> de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>. Définissez d’abord les quotas pour un seul utilisateur, et puis exécutez <code>edquota -p protouser startuid-enduid</code>. Par exemple, si l’utilisateur <code>test</code> dispose des quotas désirés, la commande suivante peut être utilisée pour appliquer ces quotas pour les UIDs de 10000 à 19999:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>Pour plus d’informations consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div></div><div class=sect3><h4 id=_consulter_les_quotas_et_lutilisation_des_disques>19.15.3. Consulter les quotas et l’utilisation des disques<a class=anchor href=#_consulter_les_quotas_et_lutilisation_des_disques></a></h4><div class=paragraph><p>Vous pouvez soit utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> soit la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> pour consulter les quotas et l’utilisation des disques. La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> peut être employée pour connaître les quotas et l’utilisation des disques pour un utilisateur et un groupe. Un utilisateur ne peut consulter que ses propres quotas et ceux d’un groupe auquel il appartient. Seul le super-utilisateur peut consulter les quotas et l’usage disque de tous les utilisateurs et groupes. La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> permet d’obtenir un résumé de tous les quotas et l’utilisation disque pour les systèmes de fichiers sur lesquels il y a des quotas.</p></div><div class=paragraph><p>Ce qui suit est un extrait de la sortie de la commande <code>quota -v</code> pour un utilisateur pour lequel on a défini des quotas sur deux systèmes de fichiers.</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>Sur le système de fichiers <span class=filename>/usr</span> dans l’exemple ci-dessus, l’utilisateur occupe 15 Ko de plus que la limite de 50 Ko qui lui est allouée et dispose d’un délai de grâce de 5 jours. Notez l’astérisque <code>*</code> qui indique que l’utilisateur dépasse actuellement son quota.</p></div><div class=paragraph><p>Normalement les systèmes de fichiers sur lesquels l’utilisateur n’occupe pas d’espace n’apparaissent pas dans la sortie de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a>, même s’il a des quotas sur ces systèmes de fichiers. L’option <code>-v</code> listera ces systèmes de fichiers, comme <span class=filename>/usr/var</span> dans l’exemple ci-dessus.</p></div></div><div class=sect3><h4 id=_quotas_avec_nfs>19.15.4. Quotas avec NFS<a class=anchor href=#_quotas_avec_nfs></a></h4><div class=paragraph><p>Les quotas sont gérés par le sous-système de gestion des quotas sur le serveur NFS. Le démon <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> fournit les informations sur les quotas à la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> des clients NFS, permettant aux utilisateurs sur ces machines de consulter l’utilisation des quotas qui leur sont alloués.</p></div><div class=paragraph><p>Activez <code>rpc.rquotad</code> dans <span class=filename>/etc/inetd.conf</span> de la façon suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>Puis redémarrez <code>inetd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></div></div><div class=sect2><h3 id=disks-encrypting>19.16. Chiffrer les partitions d’un disque<a class=anchor href=#disks-encrypting></a></h3><div class=paragraph><p>FreeBSD offre d’excellentes protections contre un accès non autorisé aux données par l’intermédiaire du réseau. Les permissions sur les fichiers et le contrôle d’accès obligatoire - "Mandatory Access Control" (MAC) (voir <a href=./#mac>Mandatory Access Control</a>) empêchent l’accès aux données pour des tiers non autorisés quand le système d’exploitation est actif et l’ordinateur en fonctionnement. Cependant, des permissions renforcés sont inutiles si l’attaquant a un accès physique à un ordinateur et peut simplement déplacer le disque dur sur un autre système pour copier et analyser les données sensibles.</p></div><div class=paragraph><p>Indépendamment de la manière dont une personne malveillante s’est trouvé en possession d’un disque dur ou a arrêté un ordinateur, le chiffrage de disque basé sur GEOM (gbde) ("GEOM Based Disk Encryption") et le système de chiffrage <code>geli</code> de FreeBSD sont en mesure de protéger les données des systèmes de fichiers contre des attaquants très motivés et aux ressources importantes. A la différence des méthodes de chiffrage lourdes qui chiffrent uniquement les fichiers individuels, gbde et <code>geli</code> chiffrent de manière transparente l’intégralité du système de fichiers. Aucun texte en clair ne touche les plateaux du disque.</p></div><div class=sect3><h4 id=_chiffrage_des_disques_avec_gbde>19.16.1. Chiffrage des disques avec gbde<a class=anchor href=#_chiffrage_des_disques_avec_gbde></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Devenir <code>root</code></p><div class=paragraph><p>La configuration de gbde requiert les privilèges du super-utilisateur.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su -
Password:</code></pre></div></div></li><li><p>Ajouter le support <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> au fichier de configuration du noyau</p><div class=paragraph><p>Ajoutez la ligne suivante à votre fichier de configuration du noyau:</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>Recompilez le noyau comme décrit dans <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>.</p></div><div class=paragraph><p>Redémarrez avec le nouveau noyau.</p></div></li><li><p>Au lieu de recompiler le noyau, on peut utiliser <code>kldload</code> pour charger le support <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_bde</span></code></pre></div></div></li></ol></div></div></div><div class=sect4><h5 id=_préparation_du_disque_dur_chiffré>19.16.1.1. Préparation du disque dur chiffré<a class=anchor href=#_préparation_du_disque_dur_chiffré></a></h5><div class=paragraph><p>L’exemple suivant suppose que vous ajoutez un nouveau disque dur à votre système et qui contiendra une seule partition chiffrée. Cette partition sera montée sous <span class=filename>/private</span>. gbde peut également être utilisé pour chiffrer les répertoires <span class=filename>/home</span> et <span class=filename>/var/mail</span>, mais cela demande une configuration plus complexe qui dépasse le cadre de cette introduction.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ajouter le nouveau disque</p><div class=paragraph><p>Installez le nouveau disque comme expliqué dans <a href=#disks-adding>Ajouter des disques</a>. Pour les besoins de cet exemple, une nouvelle partition disque a été ajoutée en tant que <span class=filename>/dev/ad4s1c</span>. Les périphériques du type <span class=filename>/dev/ad0s1*</span> représentent les partitions FreeBSD standards sur le système exemple.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Créer un répertoire pour héberger les fichiers de verrouillage de GBDE</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>Le fichier de verrouillage de gbde contient l’information nécessaire à gbde pour accéder aux partitions chiffrées. Sans accès au fichier de verrouillage, gbde sera incapable de déchiffrer les données contenues sur la partition chiffrée sans une aide manuelle significative ce qui n’est pas supporté par le logiciel. Chaque partition chiffrée utilise un fichier de verrouillage propre.</p></div></li><li><p>Initialiser la partition gbde</p><div class=paragraph><p>Une partition gbde doit être initialisée avant d’être utilisable. Cette initialisation doit être effectuée une seule fois:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> lancera votre éditeur, vous permettant de fixer diverses options de configuration dans un gabarit. Pour une utilisation de UFS1 ou UFS2, fixez l’option <code>sector_size</code> à 2048:</p></div><div class="literalblock programlisting"><div class=content><pre>$FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# La taille d&#39;un secteur est la plus petite unité de donnée
# qui peut être lue ou écrite.
# Une valeur trop petite diminue les performances et l&#39;espace
# disponible.
# Une valeur trop grande peut empêcher des systèmes de
# fichiers de fonctionner correctement.  512 est la valeur minimale
# et sans risque.  Pour l&#39;UFS, utiliser la taille d&#39;un fragment
#
sector_size     =       2048
[...]</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> vous demandera de taper deux fois la phrase d’authentification qui devra être utilisée pour sécuriser les données. La phrase d’authentification doit être la même dans les deux cas. La capacité de gbde à protéger vos données dépend de la qualité de la phrase d’authentification que vous avez choisie.</p></div><div class=paragraph><p>La commande <code>gbde init</code> crée un fichier de verrouillage pour votre partition gbde qui dans cet exemple est stocké sous <span class=filename>/etc/gbde/ad4s1c</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Les fichiers de verrouillage de gbde <em>doivent</em> être conservés de pair avec le contenu des partitions chiffrées. Alors que la suppression seule d’un fichier de verrouillage ne peut empêcher une personne déterminée de déchiffrer une partition gbde, sans le fichier de verrouillage, le propriétaire légitime sera incapable d’accéder aux données de la partition chiffrée sans beaucoup de travail ce qui est totalement non supporté par <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> et son concepteur.</p></div></td></tr></tbody></table></div></li><li><p>Attacher la partition chiffrée au noyau</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p>On vous demandera de fournir la phrase d’authentification que vous avez choisie lors de l’initialisation de la partition chiffrée. Le nouveau périphérique chiffré apparaîtra dans <span class=filename>/dev</span> en tant que <span class=filename>/dev/nom_périphérique.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Créer un système de fichiers sur le périphérique chiffré</p><div class=paragraph><p>Une fois que le périphérique chiffré a été attaché au noyau, vous pouvez créer un système de fichiers sur le périphérique. Pour créer un système de fichiers sur le périphérique, utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. Puisqu’il est plus rapide d’initialiser un nouveau système de fichiers UFS2 qu’un nouveau système UFS1, l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> avec l’option <code>-O2</code> est recommandé.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U -O2 /dev/ad4s1c.bde</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> peut être effectuée sur une partition gbde attachée qui est identifiée par une extension <span class=filename>*.bde</span> au niveau du nom de périphérique.</p></div></td></tr></tbody></table></div></li><li><p>Monter la partition chiffrée</p><div class=paragraph><p>Créez un point de montage pour le système de fichiers chiffré.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span></code></pre></div></div><div class=paragraph><p>Montez le système de fichiers chiffré.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Vérifiez que le système de fichiers chiffré est disponible</p><div class=paragraph><p>Le système de fichiers chiffré devrait être visible par <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> et prêt à être utilisé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div></div><div class=sect4><h5 id=_montage_des_systèmes_de_fichiers_chiffrés>19.16.1.2. Montage des systèmes de fichiers chiffrés<a class=anchor href=#_montage_des_systèmes_de_fichiers_chiffrés></a></h5><div class=paragraph><p>Après chaque démarrage, tout système de fichiers chiffré doit être rattaché au noyau, contrôlé pour les erreurs, et monté, avant que les systèmes de fichiers ne puissent être utilisés. Les commandes nécessaires doivent être exécutées en tant que <code>root</code>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Attacher la partition gdbe au noyau</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p>On vous demandera de fournir la phrase d’authentification que vous avez choisie lors de l’initialisation de la partition gbde chiffrée.</p></div></li><li><p>Contrôler les erreurs du système de fichiers</p><div class=paragraph><p>Puisque les systèmes de fichiers chiffrés ne peuvent être encore listés dans le fichier <span class=filename>/etc/fstab</span> pour un montage automatique, on doit donc contrôler les systèmes de fichiers pour d’éventuelles erreurs en exécutant manuellement <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> avant le montage.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p -t ffs /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Monter le système de fichiers chiffré</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div><div class=paragraph><p>Le système de fichiers est maintenant disponible à l’utilisation.</p></div></li></ol></div></div></div><div class=sect5><h6 id=_montage_automatique_de_partitions_chiffrées>19.16.1.2.1. Montage automatique de partitions chiffrées<a class=anchor href=#_montage_automatique_de_partitions_chiffrées></a></h6><div class=paragraph><p>Il est possible de créer une procédure pour automatiquement attacher, contrôler, et monter une partition chiffrée, mais pour des raisons de sécurité la procédure ne devrait pas contenir le mot de passe <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>. A la place, il est recommandé que de telles procédures soient exécutées manuellement tout en fournissant le mot de passe via la console ou <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>.</p></div><div class=paragraph><p>Comme autre possibilité, une procédure <span class=filename>rc.d</span> est fournie. Des arguments peuvent être passés à cette procédure par l’intermédiaire de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>,, par exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;</pre></div></div><div class=paragraph><p>Cela impose la saisie de la phrase d’authentification gbde au démarrage. Après avoir entré la phrase d’authentification correctement, la partition chiffrée gbde sera montée automatiquement. Cela peut être très utile quand gbde est utilisé sur des ordinateurs portables.</p></div></div></div><div class=sect4><h5 id=_les_protections_cryptographiques_utilisées_par_gbde>19.16.1.3. Les protections cryptographiques utilisées par gbde<a class=anchor href=#_les_protections_cryptographiques_utilisées_par_gbde></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> chiffre la partie utile des secteurs en utilisant le chiffrage AES 128 bits en mode CBC. Chaque secteur sur le disque est chiffré avec une clé AES différente. Pour plus d’informations sur l’architecture cryptographique de gbde, y compris comment les clés pour chaque secteur sont des dérivés de la phrase d’authentification donnée par l’utilisateur, voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div></div><div class=sect4><h5 id=_problèmes_de_compatibilité>19.16.1.4. Problèmes de compatibilité<a class=anchor href=#_problèmes_de_compatibilité></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> est incompatible avec les périphériques gbde-chiffrés. Tous les périphériques <span class=filename>*.bde</span> doivent être détachés du noyau avant de lancer <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> ou ce dernier plantera durant son processus initial de recherche des périphériques. Pour détacher le périphérique chiffré utilisé dans notre exemple, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div><div class=paragraph><p>Notez également qu’étant donné que <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=4&amp;format=html">vinum(4)</a> n’utilise pas le sous-système <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a>, vous ne pouvez utiliser gbde avec des volumes vinum.</p></div></div></div><div class=sect3><h4 id=disks-encrypting-geli>19.16.2. Chiffrage des disques avec <code>geli</code><a class=anchor href=#disks-encrypting-geli></a></h4><div class=paragraph><p>Depuis FreeBSD 6.0, une nouvelle classe GEOM pour le chiffrage des données est disponible: <code>geli</code>. Cette classe est développée par Paweł Jakub Dawidek &lt;<a href=mailto:pjd@FreeBSD.org>pjd@FreeBSD.org</a>>. L’outil <code>geli</code> est différent de <code>gbde</code>; il offre des fonctionnalités différentes et utilise une méthode différente pour chiffrer les données.</p></div><div class=paragraph><p>Les caractéristiques les plus importantes de <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> sont:</p></div><div class=ulist><ul><li><p>Utilisation du système <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a> - quand du matériel destiné au chiffrement est disponible dans la machine, <code>geli</code> l’utilisera automatiquement.</p></li><li><p>Support de plusieurs algorithmes de chiffrement (actuellement AES, Blowfish, et 3DES).</p></li><li><p>Permettre le chiffrage de la partition racine. La phrase d’authentification utilisée pour accéder à la partition racine chiffrée sera demandée au démarrage du système.</p></li><li><p>Permettre l’emploi de deux clés indépendantes (par exemple une "clé utilisateur" et une "clé entreprise").</p></li><li><p><code>geli</code> est rapide-il effectue un simple chiffrement de secteur à secteur.</p></li><li><p>Permettre la sauvegarde et la restauration des clés principales. Quand un utilisateur doit détruire ses clés, il sera possible d’accéder à nouveau aux données en restaurant les clés à partir de la sauvegarde.</p></li><li><p>Permettre d’attacher un disque avec une clé aléatoire à usage unique - utile pour les partitions de pagination et les systèmes de fichiers temporaires.</p></li></ul></div><div class=paragraph><p>Plus de caractéristiques concernant <code>geli</code> peuvent être trouvées dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></div><div class=paragraph><p>Les points suivants décriront comment activer le support pour <code>geli</code> dans le noyau FreeBSD et expliqueront comment créer et utiliser un <em>provider</em> (ou partition) chiffré <code>geli</code>.</p></div><div class=paragraph><p>Afin de pouvoir employer <code>geli</code>, vous devez utiliser FreeBSD 6.0-RELEASE ou une version ultérieure. Les privilèges du super-utilisateur seront également nécessaire puisque il faudra effectuer des modifications au niveau du noyau.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ajouter le support <code>geli</code> au noyau</p><div class=paragraph><p>Ajoutez les lignes suivantes au fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options GEOM_ELI
device crypto</pre></div></div><div class=paragraph><p>Recompilez le noyau comme décrit dans la <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>.</p></div><div class=paragraph><p>Sinon, le module <code>geli</code> peut être chargé au démarrage. Ajoutez la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_eli_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Le système <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> devrait désormais être supporté par le noyau.</p></div></li><li><p>Générer la clé principale</p><div class=paragraph><p>L’exemple suivant décrira la méthode pour générer un fichier clé qui sera utilisé comme partie de la clé principale pour le <em>provider</em> chiffré monté sous le répertoire <span class=filename>/private</span>. Le fichier clé fournira des données aléatoires qui seront employées pour chiffrer la clé principale. La clé principale sera également protégée par une phrase d’authentification. La taille des secteurs du <em>provider</em> sera de 4Ko. De plus, sera décrit comment attacher au système le <em>provider</em> geli, créer un système de fichiers dessus, utiliser ce système de fichiers et enfin comment le détacher.</p></div><div class=paragraph><p>Il est recommandé d’utiliser une taille de secteur plus grande (comme 4Ko) pour de meilleures performances.</p></div><div class=paragraph><p>La clé principale sera protégée avec une phrase d’authentification et la source de données pour le fichier clé sera <span class=filename>/dev/random</span>. La taille des secteurs de <span class=filename>/dev/da2.eli</span>, partition que nous appelons <em>provider</em>, sera de 4Ko.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class=c># geli init -s 4096 -K /root/da2.key /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre></div></div><div class=paragraph><p>Il n’est pas obligatoire d’utiliser la phrase d’authentification et le fichier clé; chacune de ces méthodes de sécurisation de la clé principale peut être utilisée séparément.</p></div><div class=paragraph><p>Si à la place du fichier clé un "-" est passé, l’entrée standard sera utilisée. Cet exemple montre comment on peut utiliser plus d’un fichier clé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre></div></div></li><li><p>Attacher le <em>provider</em> avec la clé générée</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre></div></div><div class=paragraph><p>Le nouveau périphérique sera appelé <span class=filename>/dev/da2.eli</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre></div></div></li><li><p>Créer le nouveau système de fichiers</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class=c># newfs /dev/da2.eli</span>
<span class=c># mount /dev/da2.eli /private</span></code></pre></div></div><div class=paragraph><p>Le système de fichiers chiffré devrait être maintenant visible par <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> et disponible à l’utilisation:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre></div></div></li><li><p>Démonter et détacher le <em>provider</em></p><div class=paragraph><p>Une fois l’utilisation de la partition chiffrée achevée et que la partition <span class=filename>/private</span> n’est plus nécessaire, il est prudent de penser à démonter et détacher la partition <code>geli</code> chiffrée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /private</span>
<span class=c># geli detach da2.eli</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Plus d’information sur l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> peut être trouvée dans sa page de manuel.</p></div><div class=sect4><h5 id=_utiliser_la_procédure_rc_d_de_geli>19.16.2.1. Utiliser la procédure <span class=filename>rc.d</span> de <span class=filename>geli</span><a class=anchor href=#_utiliser_la_procédure_rc_d_de_geli></a></h5><div class=paragraph><p>La commande <span class=filename>geli</span> est fournie avec une procédure <span class=filename>rc.d</span> qui peut être employée pour simplifier l’utilisation de <code>geli</code>. Un exemple de configuration de <code>geli</code> à l’aide de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> sera:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-p -k /root/da2.key&#34;</pre></div></div><div class=paragraph><p>Ces lignes configureront <span class=filename>/dev/da2</span> comme <em>provider</em> <code>geli</code> avec une clé principale <span class=filename>/root/da2.key</span>, de plus <code>geli</code> n’utilisera pas de phrase d’authentification pour attacher le <em>provider</em> (notez que ceci n’est utilisable que si l’option <code>-P</code> a été passée durant la phase <code>geli init</code>). Le système détachera du noyau le <em>provider</em> <code>geli</code> avant l’arrêt du système.</p></div><div class=paragraph><p>Plus d’information sur la configuration du système <span class=filename>rc.d</span> est fournie dans la section <a href=./#configtuning-rcd>rc.d</a> de ce Manuel.</p></div></div></div></div><div class=sect2><h3 id=swap-encrypting>19.17. Chiffrage de l’espace de pagination<a class=anchor href=#swap-encrypting></a></h3><div class=paragraph><p>Sous FreeBSD, le chiffrement de l’espace de pagination est simple à mettre en place et est possible depuis FreeBSD 5.3-RELEASE. En fonction de la version de FreeBSD utilisée, différentes options sont disponibles et la configuration peut légèrement varier. Depuis FreeBSD 6.0-RELEASE, les systèmes de chiffrage <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> peuvent être utilisé à cet effet. Avec les versions antérieures, seul <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> est disponible. Les deux systèmes utilisent la procédure <a href=./#configtuning-rcd>rc.d</a> nommée <span class=filename>encswap</span>.</p></div><div class=paragraph><p>La section précédente, <a href=#disks-encrypting>Chiffrer les partitions d’un disque</a>, contient une courte explication sur les différents systèmes de chiffrage.</p></div><div class=sect3><h4 id=_pourquoi_lespace_de_pagination_devrait_être_chiffré>19.17.1. Pourquoi l’espace de pagination devrait être chiffré?<a class=anchor href=#_pourquoi_lespace_de_pagination_devrait_être_chiffré></a></h4><div class=paragraph><p>Comme pour le chiffrage des partitions d’un disque, chiffrer l’espace de pagination a pour but la protection des informations sensibles. Imaginez une application qui, par exemple, traite des mots de passe. Tant que ces mots de passe résident en mémoire tout va pour le mieux. Cependant, si le système d’exploitation commence à transférer des pages mémoires vers l’espace de pagination en vue de libérer de la mémoire pour d’autres applications, les mots de passe peuvent être écrits en clair sur les plateaux du disque et seront faciles à récupérer par une personne malveillante. Chiffrer l’espace de pagination peut être une solution contre ce scénario.</p></div></div><div class=sect3><h4 id=_préparation>19.17.2. Préparation<a class=anchor href=#_préparation></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour le reste de cette section, <span class=filename>ad0s1b</span> sera la partition réservée à l’espace de pagination.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Jusqu’ici l’espace de pagination n’a jamais été chiffré. Il est fort possible qu’il y ait déjà des mots de passe ou toute autre donnée sensible de présents en clair sur les plateaux du disque. Afin d’y remédier, les données de la partition de pagination doivent être écrasées avec des données aléatoires:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/ad0s1b bs=1m</span></code></pre></div></div></div><div class=sect3><h4 id=_chiffrer_de_lespace_de_pagination_avec_gbde8>19.17.3. Chiffrer de l’espace de pagination avec <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a><a class=anchor href=#_chiffrer_de_lespace_de_pagination_avec_gbde8></a></h4><div class=paragraph><p>Si FreeBSD 6.0-RELEASE ou une version plus récente est utilisée, le suffixe <code>.bde</code> doit être ajouté au nom de périphérique sur la ligne du fichier <span class=filename>/etc/fstab</span> correspondant à cet espace de pagination:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0</pre></div></div><div class=paragraph><p>Pour les systèmes antérieurs à FreeBSD 6.0-RELEASE, la ligne suivante doit également être ajoutée à <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_swap_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_chiffrage_de_lespace_de_pagination_avec_geli8>19.17.4. Chiffrage de l’espace de pagination avec <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a><a class=anchor href=#_chiffrage_de_lespace_de_pagination_avec_geli8></a></h4><div class=paragraph><p>La procédure pour le chiffrage de l’espace de pagination avec <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> est similaire à celle pour l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>. Le suffixe <code>.eli</code> doit être ajouté au nom de périphérique sur la ligne du fichier <span class=filename>/etc/fstab</span> correspondant à cet espace de pagination:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0</pre></div></div><div class=paragraph><p>Par défaut, <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> utilise l’algorithme AES avec une longueur de clé de 256bits.</p></div><div class=paragraph><p>Les valeurs par défaut peuvent être modifiées en utilisant l’option <code>geli_swap_flags</code> dans le fichier <span class=filename>/etc/rc.conf</span>. La ligne suivante demande à la procédure rc.d <span class=filename>encswap</span> de créer des partitions de pagination en utilisant l’algorithme Blowfish avec une clé de 128 bits de longueur, une taille de secteur de 4 kilo-octets et avec l’option "detach on last close" (détacher après démontage de la partition) activée:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_swap_flags=&#34;-a blowfish -l 128 -s 4096 -d&#34;</pre></div></div><div class=paragraph><p>Veuillez vous référer à la description de la commande <code>onetime</code> dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> pour une liste des options possibles.</p></div></div><div class=sect3><h4 id=_vérifier_que_cela_fonctionne>19.17.5. Vérifier que cela fonctionne<a class=anchor href=#_vérifier_que_cela_fonctionne></a></h4><div class=paragraph><p>Une fois que le système a été redémarré, le fonctionnement correct de l’espace de pagination peut être vérifié en utilisant la commande <code>swapinfo</code>.</p></div><div class=paragraph><p>Si <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> est utilisé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%</code></pre></div></div><div class=paragraph><p>Si <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> est utilisé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%</code></pre></div></div></div></div></div></div><div class=sect1><h2 id=geom>Chapitre 20. GEOM: architecture modulaire de gestion des disques<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=GEOM-synopsis>20.1. Synopsis<a class=anchor href=#GEOM-synopsis></a></h3><div class=paragraph><p>Ce chapitre couvre l’utilisation des disques via le système GEOM sous FreeBSD. Cela comprend les utilitaires principaux de contrôle des niveaux RAID qui utilisent GEOM pour la configuration. Ce chapitre n’abordera pas en profondeur la manière dont GEOM gère et contrôle les E/S, les systèmes sous-jacents, ou le code utilisé. Ces informations sont fournies par la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a> et ses nombreuses références. Ce chapitre n’est pas non plus un guide de référence sur les configurations RAID. Seuls les niveaux de RAID supportés par GEOM seront abordés.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Quel type de support RAID est disponible avec GEOM.</p></li><li><p>Comment utiliser les utilitaires de base pour configurer, gérer et manipuler les différents niveaux de RAID.</p></li><li><p>Comment dupliquer, entrelacer, et connecter à distance des disques via le système GEOM.</p></li><li><p>Comment dépanner les disques attachés au système GEOM.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre comment FreeBSD gère les disques (<a href=./#disks>Stockage des données</a>).</p></li><li><p>Savoir comment configurer et installer un nouveau noyau FreeBSD (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=GEOM-intro>20.2. Introduction à GEOM<a class=anchor href=#GEOM-intro></a></h3><div class=paragraph><p>GEOM autorise l’accès et le contrôle de classes - secteur principaux de démarrage ("Master Boot Records"), labels BSD, etc. - par l’intermédiaire d’interfaces, ou de fichiers spéciaux du répertoire <span class=filename>/dev</span>. En supportant plusieurs configurations RAID logicielles, GEOM offrira un accès transparent au système d’exploitation et à ses utilitaires.</p></div></div><div class=sect2><h3 id=GEOM-striping>20.3. RAID0 - "Striping"<a class=anchor href=#GEOM-striping></a></h3><div class=paragraph><p>Le "striping" (ou entrelacement) est utilisé pour combiner plusieurs disques en un seul volume de stockage. Dans de nombreux cas, cette configuration est réalisée à l’aide de contrôleurs matériels. Le sous-système GEOM offre le support pour le niveau RAID0, également connu sous le nom de "striping".</p></div><div class=paragraph><p>Dans un système RAID0, les données sont divisées en blocs répartis sur l’ensemble des disques de la "grappe". Au lieu de devoir attendre l’écriture de 256k sur un disque, un système RAID0 peut écrire en simultané 64k sur quatre disques différents, offrant alors des performances d’accès supérieures. Ces performances peuvent être encore améliorées en utilisant plusieurs contrôleurs de disques.</p></div><div class=paragraph><p>Chaque disque d’une bande ("stripe") RAID0 doit avoir la même taille, puisque les requêtes d’E/S sont entrelacées de manière à lire ou écrire sur plusieurs disques en parallèle.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Illustration de l’entrelacement de disques"></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Création d’un système entrelacé à partir de disques ATA non formatés</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Chargez le module <span class=filename>geom_stripe</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Assurez-vous de l’existence d’un point de montage. Si ce volume doit devenir une partition racine, utilisez alors un autre point de montage comme <span class=filename>/mnt</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt</span></code></pre></div></div></li><li><p>Déterminez les noms de périphériques pour les disques qui seront entrelacé, et créez le nouveau périphérique entrelacé. Par exemple, pour entrelacer deux disques ATA non utilisés et non partitionnés, par exemple <span class=filename>/dev/ad2</span> et <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span></code></pre></div></div></li><li><p>Créez un label standard, également connu sous le nom de table des partitions, sur le nouveau volume et installez le code d’amoraçage par défaut:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>Cette opération doit avoir créé deux autres périphériques dans le répertoire <span class=filename>/dev/stripe</span> en plus du périphérique <span class=filename>st0</span>: <span class=filename>st0a</span> et <span class=filename>st0c</span>. A ce stade, un système de fichiers peut être créé sur <span class=filename>st0a</span> en utilisant la commande <code>newfs</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Des nombres défileront à l’écran, l’opération sera s’achèvera après quelques secondes. Le volume a été créé et est prêt à être monté.</p></div></li></ol></div></div></div><div class=paragraph><p>Pour monter manuellement une grappe de disques entrelacés fraîchement créée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div><div class=paragraph><p>Pour monter automatiquement au démarrage ce système de fichiers entrelacé, ajoutez les informations concernant ce volume dans le fichier <span class=filename>/etc/fstab</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;/dev/stripe/st0a /mnt ufs rw 2 2&#34; \</span>
    <span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div><div class=paragraph><p>Le module <span class=filename>geom_stripe</span> doit également être automatiquement chargé lors de l’initialisation du système en ajoutant une ligne au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_stripe_load=&#34;YES&#34;&#39;  /boot/loader.conf</span></code></pre></div></div></div><div class=sect2><h3 id=GEOM-mirror>20.4. RAID1 - "mirroring"<a class=anchor href=#GEOM-mirror></a></h3><div class=paragraph><p>Le "mirroring" est une technologie utilisée par de nombreuses entreprises et beaucoup de particuliers pour sauvegarder les données sans interruption des activités. Quand un miroir existe, cela signifie que le disque B est une copie du disque A. Ou, autre cas, que les disques C+D sont une copie des disques A+B. Indépendamment de la configuration des disques, l’aspect important est que les données d’un disque ou d’une partition sont dupliquées. Ultérieurement, ces données pourront être plus facilement restaurées, sauvegardées sans interrompre le système ou les accès, et pourront même être stockées physiquement de manière sure.</p></div><div class=paragraph><p>Pour commencer, vérifiez que le système dispose de deux disques de taille identique, cet exemple suppose que ce sont des disques SCSI (<a href="https://man.freebsd.org/cgi/man.cgi?query=da&amp;sektion=4&amp;format=html">da(4)</a>).</p></div><div class=paragraph><p>Installez FreeBSD sur le premier disque avec uniquement deux partitions. Une partition sera la partition de pagination d’une taille double à celle de la RAM et l’espace restant sera alloué au système de fichiers racine (<span class=filename>/</span>). Il est possible d’avoir des partitions séparées pour les autres points de montage, cependant cela augmentera énormément le niveau de difficulté en raison des modifications manuelles nécessaires des paramètres de <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>.</p></div><div class=paragraph><p>Redémarrez et attendez l’initialisation complète du système. Ensuite, ouvrez une session sous l’utilisateur <code>root</code>.</p></div><div class=paragraph><p>Créez le périphérique <span class=filename>/dev/mirror/gm</span> et liez-le avec <span class=filename>/dev/da1</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -vnb round-robin gm0 /dev/da1</span></code></pre></div></div><div class=paragraph><p>Le système devrait répondre par:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Metadata value stored on /dev/da1.
Done.</code></pre></div></div><div class=paragraph><p>Initialisez GEOM, cela devrait charger le module du noyau <span class=filename>/boot/kernel/geom_mirror.ko</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cette commande devrait créer le fichier spécial de périphérique <span class=filename>gm0</span> sous le répertoire <span class=filename>/dev/mirror</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Installez un label <code>fdisk</code> et un code de d’amorce génériques sur le nouveau périphérique <span class=filename>gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -vBI /dev/mirror/gm0</span></code></pre></div></div><div class=paragraph><p>Installez maintenant un label générique <code>bsdlabel</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/mirror/gm0s1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>S’il existe plusieurs "slices" et plusieurs partitions, il faudra modifier les paramètres des deux commandes précédentes. Elles doivent correspondre aux tailles des partitions et "slices" sur l’autre disque.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Utilisez l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> pour créer un système de fichiers UFS sur le périphérique <span class=filename>gm0s1a</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span></code></pre></div></div><div class=paragraph><p>Le système devrait alors afficher un certain nombre d’informations et de nombres. C’est bon signe. Contrôlez l’affichage à la recherche de messages d’erreur et montez le périphérique sur le point de montage <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Transférez maintenant toutes les données du disque de démarrage vers ce nouveau système de fichiers. Dans notre exemple nous utilisons à cet effet les commandes <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>, cependant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> conviendrait également.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -L -0 -f- / |(cd /mnt &amp;&amp; restore -r -v -f-)</span></code></pre></div></div><div class=paragraph><p>Cela doit être effectué pour chaque système de fichiers. Placez simplement le système de fichiers approprié au bon endroit quand vous exécutez la commande précédente.</p></div><div class=paragraph><p>Editez ensuite le fichier <span class=filename>/mnt/etc/fstab</span> et supprimez ou mettez en commentaires le fichier de pagination . Modifiez les autres paramètres du système de fichiers pour utiliser le nouveau disque comme présenté l’exemple suivant:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
#/dev/da0s2b             none            swap    sw              0       0
/dev/mirror/gm0s1a       /               ufs     rw              1       1</pre></div></div><div class=paragraph><p>Créez maintenant un fichier <span class=filename>boot.config</span> sur la partition racine actuelle et celle nouvellement créée. Ce fichier "aidera" le BIOS à déterminer correctement sur quel disque démarrer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;1:da(1,a)/boot/loader&#34; &gt; /boot.config</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;1:da(1,a)/boot/loader&#34; &gt; /mnt/boot.config</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nous l’avons ajouter sur les deux partitions racines afin d’assurer un démarrage correct. Si pour une raison quelconque le système ne pourrait le lire à partir de la nouvelle partition racine, une version de secours est disponible.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Assurez-vous que le module <span class=filename>geom_mirror.ko</span> sera chargé au démarrage du système en lançant la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_mirror_load=&#34;YES&#34;&#39;  /mnt/boot/loader.conf</span></code></pre></div></div><div class=paragraph><p>Redémarrez le système:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Si tout s’est bien passé, le système a dû démarrer à partir du périphérique <span class=filename>gm0s1a</span> et une invite d’ouverture de session doit être affichée. En cas de problème, consultez la section suivante consacrée au dépannage. Ajoutez maintenant le disque <span class=filename>da0</span> au périphérique <span class=filename>gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror configure -a gm0</span>
<span class=c># gmirror insert gm0 /dev/da0</span></code></pre></div></div><div class=paragraph><p>L’option <code>-a</code> demande à <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> d’utiliser une synchronisation automatique, c’est à dire dupliquer automatiquement toute écriture disque. La page de manuel explique comment reconstruire et remplacer les disques, avec la différence qu’elle utilise <span class=filename>data</span> à la place de <span class=filename>gm0</span>.</p></div><div class=sect3><h4 id=_dépannage_2>20.4.1. Dépannage<a class=anchor href=#_dépannage_2></a></h4><div class=sect4><h5 id=_le_système_refuse_de_démarrer>20.4.1.1. Le système refuse de démarrer<a class=anchor href=#_le_système_refuse_de_démarrer></a></h5><div class=paragraph><p>Si le démarrage du système s’interrompt à une invite semblable à:</p></div><div class="literalblock programlisting"><div class=content><pre>ffs_mountroot: can&#39;t find rootvp
Root mount failed: 6
mountroot</pre></div></div><div class=paragraph><p>Redémarrez la machine à l’aide du bouton de mise en marche ou de "reset". Au menu de démarrage, sélectionnez la sixième option (6). Le système basculera alors vers une invite du chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>). Chargez manuellement le module du noyau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK? load geom_mirror
OK? boot</code></pre></div></div><div class=paragraph><p>Si cela fonctionne, cela signifie que pour une raison quelconque le module n’a pas été correctement chargé. Ajoutez la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_MIRROR</pre></div></div><div class=paragraph><p>dans le fichier de configuration du noyau, recompilez-le puis réinstallez-le. Cela devrait corriger le problème.</p></div></div></div></div><div class=sect2><h3 id=geom-ggate>20.5. Périphériques réseau "GEOM Gate"<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>GEOM supporte l’utilisation de périphériques distants, comme les disques durs, les CD-ROMs, les fichiers, etc. via l’utilisation des outils "gate". Ce mécanisme est semblable à NFS.</p></div><div class=paragraph><p>Pour commencer, un fichier d’export doit être créé. Ce fichier précise qui est autorisé à accéder aux ressources partagées et quel niveau d’accès est offert. Par exemple, pour partager la quatrième tranche du premier disque SCSI, le fichier <span class=filename>/etc/gg.exports</span> suivant est adapté:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.0/24 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Cette ligne autorisera l’accès au système de fichiers présent sur la partition <span class=filename>da0s4d</span> à toutes les machines du réseau local.</p></div><div class=paragraph><p>Pour exporter ce périphérique, assurez-vous tout d’abord qu’il n’est pas déjà monté et lancez le "démon" <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Maintenant pour monter le périphérique sur la machine cliente, tapez les commandes suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>A partir d’ici, on peut accéder au périphérique par l’intermédiaire du point de montage <span class=filename>/mnt</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il est à noter que toutes ces opérations échoueront si le disque est déjà monté soit sur la machine serveur soit sur tout autre machine du réseau.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quand le périphérique n’est plus utilisé, il peut être démonté sans risque avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> de la même manière que pour tout autre disque.</p></div></div><div class=sect2><h3 id=geom-glabel>20.6. Ajouter un label à un disque<a class=anchor href=#geom-glabel></a></h3><div class=paragraph><p>Lors de l’initialisation du système, le noyau FreeBSD créé les fichiers spéciaux de périphériques à mesure que les périphériques sont détectés. Cette méthode de détection des périphériques soulève quelques problèmes, par exemple que se passe-t-il si un nouveau disque est ajouté par l’intermédiaire de l’interface USB? Il est très probable qu’un disque flash se verra proposer le nom de périphérique <span class=filename>da0</span> et le périphérique original <span class=filename>da0</span> déplacé en <span class=filename>da1</span>. Cela sera à l’origine de problèmes de montage des systèmes de fichiers s’ils sont listés dans <span class=filename>/etc/fstab</span>, en fait cela pourra tout simplement empêcher le démarrage du système.</p></div><div class=paragraph><p>Une solution à ce problème est d'"enchaîner" les périphériques SCSI afin que tout nouveau périphérique ajouté sur la carte SCSI se voit assigné un numéro de périphérique non-utilisé. Mais qu’en est-il des périphériques USB qui peuvent remplacer le premier disque SCSI? Cela se produit parce que les périphériques USB sont en général détectés avant la carte SCSI. Une solution est de brancher ces périphériques qu’après le démarrage du système. Une autre méthode serait de n’utiliser qu’un seul disque ATA et de ne jamais lister de périphériques SCSI dans le fichier <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>Une meilleure solution existe. En employant l’utilitaire <code>glabel</code>, un administrateur ou un utilisateur peut attribuer un label à chacun de ses disques et utiliser ces labels dans <span class=filename>/etc/fstab</span>. Comme <code>glabel</code> conserve le label sur le dernier secteur du support concerné, le label persistera après redémarrage du système. En utilisant ce label comme un véritable périphérique, le système de fichiers pourra toujours être monté indépendamment du fichier spécial de périphérique utilisé pour y accéder.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cela se fait sans préciser qu’un label sera permanent. L’utilitaire <code>glabel</code> peut être utilisé pour créer des labels persistants et des labels éphémères. Seul le label persistant sera conservé après redémarrage du système. Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> pour plus d’information sur les différences entre labels.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_types_et_exemples_de_labels>20.6.1. Types et exemples de labels<a class=anchor href=#_types_et_exemples_de_labels></a></h4><div class=paragraph><p>Il existe deux types de label, un label générique et un label de système de fichiers. La différence entre les labels est le système d’auto-détection associé avec les labels permanents, et le fait que ce type de label sera persistant après redémarrage du système. A ces labels est attribué un sous-répertoire spécifique de <span class=filename>/dev</span> dont le nom sera basé sur le type de système de fichiers. Par exemple, les labels de systèmes de fichiers UFS2 seront créés dans le répertoire <span class=filename>/dev/ufs2</span>.</p></div><div class=paragraph><p>Un label générique disparaîtra au redémarrage suivant. Ces labels seront créés dans le répertoire <span class=filename>/dev/label</span> et sont parfaits pour faire des expériences.</p></div><div class=paragraph><p>Les labels permanents peuvent être placés sur le système de fichiers en utilisant les utilitaires <code>tunefs</code> ou <code>newfs</code>. Pour créer un label permanent pour un système de fichier UFS2 sans endommager de données, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Si le système de fichiers est plein, cette opération pourra entraîner une corruption des données; si le système de fichiers est plein, alors la première chose à faire sera de supprimer les fichiers inutiles et non pas l’ajout de labels.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Un nouveau label devrait désormais apparaître dans <span class=filename>/dev/ufs2</span> et pourra être ajouté à <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs2/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le système de fichiers ne doit pas être monté lors de l’utilisation de <code>tunefs</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le système de fichiers peut, maintenant, être normalement monté:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>La commande suivante peut être employée pour supprimer le label:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>A partir de cet instant, aussi longtemps que le module du noyau <span class=filename>geom_label.ko</span> est chargé au démarrage avec <span class=filename>/boot/loader.conf</span> ou que l’option <code>GEOM_LABEL</code> est présente dans le noyau, le fichier spécial de périphérique peut changer sans effet négatif pour le système.</p></div><div class=paragraph><p>Les systèmes de fichiers peuvent également être créés avec un label par défaut en utilisant l’option <code>-L</code> avec <code>newfs</code>. Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> pour plus d’information.</p></div></div></div></div></div><div class=sect1><h2 id=zfs>Chapitre 21. The Z File System (ZFS) <strong>Traduction en Cours </strong><a class=anchor href=#zfs></a></h2><div class=sectionbody><div class=sect2><h3 id=zfs-differences>21.1. What Makes ZFS Different<a class=anchor href=#zfs-differences></a></h3></div><div class=sect2><h3 id=zfs-quickstart>21.2. Quick Start Guide<a class=anchor href=#zfs-quickstart></a></h3></div><div class=sect2><h3 id=zfs-zpool>21.3. <code>zpool</code> Administration<a class=anchor href=#zfs-zpool></a></h3></div><div class=sect2><h3 id=zfs-zfs>21.4. <code>zfs</code> Administration<a class=anchor href=#zfs-zfs></a></h3></div><div class=sect2><h3 id=zfs-zfs-allow>21.5. Delegated Administration<a class=anchor href=#zfs-zfs-allow></a></h3></div><div class=sect2><h3 id=zfs-links>21.6. Additional Resources<a class=anchor href=#zfs-links></a></h3></div><div class=sect2><h3 id=zfs-term>21.7. ZFS Features and Terminology<a class=anchor href=#zfs-term></a></h3></div></div></div><div class=sect1><h2 id=filesystems>Chapitre 22. Autres systèmes de fichiers<a class=anchor href=#filesystems></a></h2><div class=sectionbody><div class=sect2><h3 id=filesystems-synopsis>22.1. Synopsis<a class=anchor href=#filesystems-synopsis></a></h3><div class=paragraph><p>Les systèmes de fichiers sont partie intégrante de n’importe quel système d’exploitation. Ils permettent aux utilisateurs de lire et stocker des fichiers, de donner accès aux données, et rendre utiles les disques durs. Les systèmes d’exploitation diffèrent par leur système de fichiers natifs. Traditionnellement, le système de fichiers natif de FreeBSD était l'<em>Unix File System</em> UFS qui a été modernisé sous le nom UFS2. Depuis la version FreeBSD 7.0, le système de fichiers Z ou <em>Z File System</em> (ZFS) est également disponible en tant que système de fichiers natif. Consultez <a href=./#zfs>The Z File System (ZFS)</a> pour plus d’information.</p></div><div class=paragraph><p>En plus de ses systèmes de fichiers natifs, FreeBSD supporte une multitude d’autres systèmes de fichiers donnant ainsi un accès local aux données d’autres systèmes d’exploitation, comme les données présentes sur des périphériques USB, les disques flash et des disques durs. Cela comprend également le support pour le système de fichiers étendu de Linux® ou <em>Extended File System</em> (EXT).</p></div><div class=paragraph><p>Il y a différents niveaux de support de FreeBSD pour les différents systèmes de fichiers. Certains nécessitent le chargement d’un module du noyau et d’autres l’installation d’un ensemble d’outils. Le support de certains systèmes de fichiers est complet en lecture et en écriture alors que pour d’autres il est limité à la lecture.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>La différence entre les systèmes de fichiers natifs et supportés.</p></li><li><p>Quels systèmes de fichiers sont supporté par FreeBSD.</p></li><li><p>Comment activer, configurer, accéder, et utiliser des systèmes de fichiers non-natifs.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devez:</p></div><div class=ulist><ul><li><p>Comprendre UNIX® et les <a href=./#basics>bases de FreeBSD</a>.</p></li><li><p>Etre familier avec les bases de la <a href=./#kernelconfig>configuration et compilation du noyau</a>.</p></li><li><p>Etre à l’aise avec <a href=./#ports>l’installation de logiciels</a> sous FreeBSD.</p></li><li><p>Avoir quelques connaissances sur les <a href=./#disks>disques</a>, les stockage de données, et les noms de périphériques sous FreeBSD.</p></li></ul></div></div><div class=sect2><h3 id=filesystems-linux>22.2. Systèmes de fichiers Linux®<a class=anchor href=#filesystems-linux></a></h3><div class=paragraph><p>FreeBSD offre un support intégré pour plusieurs systèmes de fichiers Linux®. Cette section montre comment charger le support et comment monter les systèmes de fichiers Linux® supportés.</p></div><div class=sect3><h4 id=_ext2>22.2.1. ext2<a class=anchor href=#_ext2></a></h4><div class=paragraph><p>Le support du noyau pour les systèmes de fichiers ext2 est disponible depuis FreeBSD 2.2. Sous FreeBSD 8.X et versions antérieures, le code était sous licence GPL. Depuis FreeBSD 9.0, le code a été récrit et est désormais sous licence BSD.</p></div><div class=paragraph><p>Le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> permet au noyau FreeBSD de lire et écrire sur les systèmes de fichiers ext2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ce pilote peut également être utilisé pour accéder à des systèmes de fichiers ext3 et ext4. Le système de fichiers <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> supporte complètement l’écriture et la lecture de systèmes de fichiers ext4 à partir de FreeBSD 12.0-RELEASE. De plus, les attributs étendus et les ACLs sont également supportés, mais ce n’est pas le cas de la journalisation et du chiffrement. A partir de FreeBSD 12.1-RELEASE, le support DTrace sera aussi disponible. Les versions de FreeBSD antérieures peuvent accéder à de l’ext4 en lecture et en écriture en utilisant <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/fusefs-ext2/>sysutils/fusefs-ext2</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour accéder à un système de fichiers ext, tout d’abord chargez le module du noyau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ext2fs</span></code></pre></div></div><div class=paragraph><p>Puis, montez le volume ext en indiquant son nom de partition sous FreeBSD et un point de montage. Cette exemple monte <span class=filename>/dev/ad1s1</span> sur <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t ext2fs /dev/ad1s1 /mnt</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=vinum-vinum>Chapitre 23. Le gestionnaire de volume Vinum<a class=anchor href=#vinum-vinum></a></h2><div class=sectionbody><div class=sect2><h3 id=vinum-synopsis>23.1. Synopsis<a class=anchor href=#vinum-synopsis></a></h3><div class=paragraph><p>Peu importe les disques dont vous disposez, ils seront toujours limités:</p></div><div class=ulist><ul><li><p>Ils pourront être trop petits.</p></li><li><p>Ils pourront être trop lents.</p></li><li><p>Ils pourront être peu fiables.</p></li></ul></div></div><div class=sect2><h3 id=vinum-intro>23.2. Les disques sont trop petits<a class=anchor href=#vinum-intro></a></h3><div class=paragraph><p><em>Vinum</em> est un <em>gestionnaire de volume</em>, un pilote de disque virtuel qui permet de résoudre ces trois problèmes. Regardons-les plus en détails. De nombreuses solutions à ces problèmes ont été proposées et implémentées:</p></div><div class=paragraph><p>Les disques deviennent de plus en plus gros, mais tout comme les besoins en stockage. Vous vous apercevrez souvent que vous avez besoin d’un système de fichiers plus grand que les disques que vous avez à votre disposition. Bien évidemment, ce problème n’est plus aussi aigu qu’il l’était il y a de cela dix ans, mais il existe toujours. Certains systèmes l’ont résolu en créant un périphérique abstrait qui stocke ses données sur plusieurs disques.</p></div></div><div class=sect2><h3 id=_les_goulots_détranglement_daccès_aux_données>23.3. Les goulots d’étranglement d’accès aux données<a class=anchor href=#_les_goulots_détranglement_daccès_aux_données></a></h3><div class=paragraph><p>Les systèmes modernes ont fréquemment besoin d’accéder aux données d’une manière hautement concourante. Par exemple, d’importants serveurs FTP ou HTTP peuvent supporter des milliers de sessions concourantes et avoir de multiple connexions à 100 Mbit/s vers le monde extérieur, et cela bien au-delà du taux de transfert soutenu de la plupart des disques.</p></div><div class=paragraph><p>Les disques actuels peuvent effectuer des transfert séquentiels de données jusqu’à une vitesse de 70 MO/s, mais ce chiffre a peu d’importance dans un environnement où plusieurs processus indépendants accèdent à un disque, où l’on pourra n’atteindre qu’une fraction de cette valeur. Dans de tels cas il est plus intéressant de voir le problème du point de vue du sous-système des disques: le paramètre important est la charge que provoque un transfert sur le sous-système, en d’autres termes le temps d’occupation du disque impliqué dans le transfert.</p></div><div class=paragraph><p>Dans n’importe quel transfert, le disque doit tout d’abord positionner les têtes de lecture, attendre le passage du premier secteur sous la tête de lecture, puis effectuer le transfert. Ces actions peuvent être considérées comme étant atomiques: cela n’a aucun sens de les interrompre.</p></div><div class=paragraph><p><a id=vinum-latency></a>Considérons un transfert typique d’environ 10 KO: la génération actuelle de disques hautes performances peuvent positionner leurs têtes en environ 3.5 ms. Les disques les plus véloces tournent à 15000 tr/minute, donc le temps de latence moyen de rotation (un demi-tour) est de 2 ms. A 70 MO/s, le transfert en lui-même prend environ 150 μs, presque rien comparé au temps de positionnement. Dans un tel cas, le taux de transfert effectif tombe à un peu plus de 1 MO/s et est clairement hautement dépendant de la taille du transfert.</p></div><div class=paragraph><p>La solution classique et évidente à ce goulot d’étranglement est "plus de cylindres": plutôt que d’utiliser un gros disque, on utilise plusieurs disques plus petits avec le même espace de stockage. Chaque disque est en mesure d’effectuer un transfert indépendamment des autres, aussi le taux de sortie augmente d’un facteur proche du nombre de disques utilisés.</p></div><div class=paragraph><p>L’amélioration du taux réel de sortie est, naturellement, inférieure au nombre de disques impliqués: bien que chaque disque soit capable de transférer en parallèle, il n’y a aucun moyen de s’assurer que les requêtes sont distribuées équitablement entre les disques. Inévitablement la charge d’un disque sera plus importante que celle d’un autre.</p></div><div class=paragraph><p>La répartition de la charge sur les disques dépend fortement de la manière dont les données sont partagées entre les disques. Dans la discussion suivant, il sera pratique de penser au stockage disque en tant qu’un grand nombre de secteurs qui sont adressables par l’intermédiaire d’un nombre, plutôt que comme les pages d’un livre. La méthode la plus évidente est de diviser le disque virtuel en groupes de secteurs consécutifs de taille égale aux disques physiques individuels et de les stocker de cette manière, plutôt que de les prendre comme un gros livre et de le déchirer en petites sections. Cette méthode est appelée <em>concaténation</em> et a pour avantage que les disques n’ont pas besoin d’avoir de rapport spécifique au niveau de leur taille respective. Cela fonctionne bien quand l’accès au disque virtuel est réparti de façon identique sur son espace d’adressage. Quand l’accès est limité à une petite zone, l’amélioration est moins marquée. <a href=#vinum-concat>Organisation par concaténation</a> décrit la séquence dans laquelle les unités sont assignées dans une organisation par concaténation.</p></div><div id=vinum-concat class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-concat.png alt="vinum concat"></div><div class=title>Figure 61. Organisation par concaténation</div></div><div class=paragraph><p>Une organisation alternative est de diviser l’espace adressable en composants plus petits, de même taille et de les stocker séquentiellement sur différents périphériques. Par exemple, les 256 premiers secteurs peuvent être stockés sur le premier disque, les 256 secteurs suivants sur le disque suivant et ainsi de suite. Après avoir atteint le dernier disque, le processus se répète jusqu’à ce que les disques soient pleins. Cette organisation est appelée <em>striping</em> (découpage en bande ou segmentation) ou RAID-0.</p></div><div class=paragraph><p>La segmentation exige légèrement plus d’effort pour localiser les données, et peut causer une charge additionnelle d’E/S quand un transfert est réparti sur de multiples disques, mais il peut également fournir une charge plus constante sur les disques. <a href=#vinum-striped>Organisation segmentée</a> illustre l’ordre dans lequel les unités de stockage sont assignées dans une organisation segmentée.</p></div><div id=vinum-striped class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-striped.png alt="vinum striped"></div><div class=title>Figure 62. Organisation segmentée</div></div></div><div class=sect2><h3 id=_intégrité_des_données>23.4. Intégrité des données<a class=anchor href=#_intégrité_des_données></a></h3><div class=paragraph><p>Le dernier problème avec les disques actuels est qu’ils ne sont pas fiables. Bien que la fiabilité des disques s’est énormément améliorée depuis quelques années, ils sont toujours le composant principal d’un serveur le plus susceptible de tomber en panne. Et quand cela arrive, les résultats peuvent être catastrophiques: remplacer un disque en panne et restaurer les données peut prendre plusieurs jours.</p></div><div class=paragraph><p>La méthode originelle d’approche de ce problème fut le mode <em>miroir</em>, en conservant deux copies des données sur un matériel différent. Depuis l’avènement de la technologie RAID, cette technique est également nommée RAID niveau 1 ou RAID-1. Toute opération d’écriture sur le volume écrit sur les deux unités; une lecture peut être acquittée par l’une ou l’autre, aussi si l’un des disque tombe en panne, les données sont toujours accessibles sur l’autre disque.</p></div><div class=paragraph><p>Le mode miroir présente deux problèmes:</p></div><div class=ulist><ul><li><p>Le prix. Il demande au moins deux fois autant d’espace disque qu’une solution non-redondante.</p></li><li><p>L’impact sur la performance. Les écritures doivent être effectuées sur les deux disques, elles prennent donc deux fois plus de bande passante que sur un volume sans miroir. Les lectures de souffrent pas de baisse de performance: elles semblent même plus rapides.</p></li></ul></div><div class=paragraph><p>Une alternative est l’utilisation de la <em>parité</em>, implémentée sous les niveaux RAID 2, 3, 4 et 5. De ces niveaux RAID-5 est le plus intéressant. Comme implémenté dans Vinum, c’est une variante de l’organisation segmentée qui dédie un bloc de chaque segment à la parité des autres blocs. Comme implémenté dans Vinum, un volume RAID-5 est identique à un volume segmenté, sauf qu’il implémente RAID-5 en incluant un bloc de parité dans chaque unité. Comme l’exige RAID-5, l’emplacement de ce bloc de parité varie d’une unité à l’autre. Le nombre de blocs de données indique le nombre relatif de blocs.</p></div><div id=vinum-raid5-org class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-raid5-org.png alt="vinum raid5 org"></div><div class=title>Figure 63. Organisation RAID-5</div></div><div class=paragraph><p>Comparé au mode miroir, RAID-5 a pour avantage de demander un espace de stockage significativement plus faible. L’accès en lecture est semblable à celui de l’organisation segmentée, mais l’accès en écriture est bien plus lent, approximativement 25% des performances en lecture. Si un disque tombe en panne, l’ensemble peut continuer à fonctionner dans un mode dégradé: une lecture sur un disque restant accessible se poursuit normalement, mais une lecture du disque perdu est recalculée à partir du bloc correspondant sur l’ensemble des disques restants.</p></div></div><div class=sect2><h3 id=vinum-objects>23.5. Objets Vinum<a class=anchor href=#vinum-objects></a></h3><div class=paragraph><p>Afin de résoudre ces problèmes, Vinum implémente une hiérarchie d’objets à quatre niveaux:</p></div><div class=ulist><ul><li><p>L’objet le plus visible est le disque virtuel, appelé <em>volume</em>. Les volumes ont essentiellement les mêmes propriétés qu’un disque UNIX™, bien qu’il y ait quelques différences mineures. Ils n’ont aucune limitation de taille.</p></li><li><p>Les volumes sont composés de <em>plexes</em>, chacune d’entre elles représente l’ensemble de l’espace d’adressable d’un volume. Ce niveau dans la hiérarchie permet ainsi la redondance. Pensez aux plexes comme différents disques dans un ensemble miroir, chacun contenant les mêmes données.</p></li><li><p>Comme Vinum existe dans le système de stockage disque d’UNIX™, il serait possible d’utiliser les partitions UNIX™ pour construire des blocs pour des plexes à disques multiples, mais en fait cela ne serait pas suffisamment flexible: les disques UNIX™ ne peuvent avoir qu’un nombre limités de partitions. Au lieu de cela Vinum subdivise une simple partition UNIX™ (le <em>disque</em>) en zones contiguës appelées <em>sous-disques</em>, qui sont utilisés comme bloc pour construire les plexes.</p></li><li><p>Les sous-disques résident sur le <em>disque</em> Vinum, en fait les partitions UNIX™. Les disques Vinum peuvent contenir un nombre quelconque de sous-disque. A l’exception d’une petite zone au début du disque, qui est utilisée pour stocker les informations de configuration et d’état, l’intégralité du disque est disponible pour le stockage des données.</p></li></ul></div><div class=paragraph><p>Les sections suivantes décrivent la façon dont ces objets fournissent les fonctionnalités requises pour Vinum.</p></div><div class=sect3><h4 id=_considérations_sur_la_taille_des_volumes>23.5.1. Considérations sur la taille des volumes<a class=anchor href=#_considérations_sur_la_taille_des_volumes></a></h4><div class=paragraph><p>Les plexes peuvent comprendre de multiple sous-disques répartis sur tous les disques dans la configuration Vinum. Par conséquent, la taille d’un disque ne limite pas la taille d’une plex, et donc d’un volume.</p></div></div><div class=sect3><h4 id=_stockage_de_données_redondant>23.5.2. Stockage de données redondant<a class=anchor href=#_stockage_de_données_redondant></a></h4><div class=paragraph><p>Vinum implémente le mode miroir en attachant de multiples plexes à un volume. Un volume peut contenir entre une et huit plexes.</p></div><div class=paragraph><p>Bien qu’une plex représente les données complètes d’un volume, il est possible que des parties de la représentation soient physiquement manquantes, soit en raison de la mise en place (en définissant un sous-disque comme ne faisant pas partie de la plex) ou par accident (en raison de la panne d’un disque). Tant qu’au moins une plex peut fournir les données de l’intégralité de la plage d’adresse d’un volume, le volume est totalement fonctionnel.</p></div></div><div class=sect3><h4 id=_problèmes_de_performance>23.5.3. Problèmes de performance<a class=anchor href=#_problèmes_de_performance></a></h4><div class=paragraph><p>Vinum implémente la concaténation et la segmentation au niveau de la plex:</p></div><div class=ulist><ul><li><p>Une <em>plex concaténée</em> utilise alternativement l’espace d’adresse de chaque sous-disque.</p></li><li><p>Une <em>plex segmentée</em> segmente les données sur chaque sous-disque. Les sous-disques doivent avoir la même taille, et il doit y avoir au moins deux sous-disques pour distinguer la plex d’une plex concaténée.</p></li></ul></div></div><div class=sect3><h4 id=_quelle_organisation_de_plex>23.5.4. Quelle organisation de plex?<a class=anchor href=#_quelle_organisation_de_plex></a></h4><div class=paragraph><p>La version de Vinum fournie avec FreeBSD 12.0 implémente deux type de plexes:</p></div><div class=ulist><ul><li><p>Les plexes concaténées sont les plus flexibles: elles peuvent contenir un nombre quelconque de de sous-disques, et les sous-disques peuvent être de taille différentes. La plex peut être étendue en ajoutant des sous-disques supplémentaires. Elles demandent moins de temps CPU que les plexes segmentées, bien que la différence en charge CPU ne soit pas mesurable. D’autre part, elles sont plus susceptibles d’échauffement, là où un disque est très actif et les autres sont au repos.</p></li><li><p>Le plus grand avantage des plexes segmentées (RAID-0) est qu’elles réduisent les problèmes d’échauffement: en choisissant tailles de segments optimales (environ 256 KO), vous pouvez également réduire la charge des disques. Les inconvénients de cette approche sont un code (infimement) plus complexe et des restrictions sur les sous-disques: ils doivent être de la même taille, et agrandir une plex en ajoutant de nouveaux sous-disques est si complexe que Vinum ne l’implémente pas actuellement. Vinum impose une restriction triviale supplémentaire: une plex segmentée doit avoir au moins deux sous-disques, puisque sinon elle ne serait distinguable d’une plex concaténée.</p></li></ul></div><div class=paragraph><p><a href=#vinum-comparison>Organisations de plex Vinum</a> résume les avantages et inconvénients de chaque type d’organisation de plex.</p></div><table id=vinum-comparison class="tableblock frame-all grid-all stretch"><caption class=title>Tableau 7. Organisations de plex Vinum</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Type de plex</th><th class="tableblock halign-left valign-top">Nombre minimal de sous-disques</th><th class="tableblock halign-left valign-top">Possibilité d’ajout de sous-disques</th><th class="tableblock halign-left valign-top">Doivent être de même taille</th><th class="tableblock halign-left valign-top">Application</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>concaténée</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>oui</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>non</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Stockage de grandes quantités de données avec le maximum de flexibilité en terme de placement et des performances modérées</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>segmentée</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>non</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>oui</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Haute performance combinée avec un accès hautement concourant</p></td></tr></tbody></table></div></div><div class=sect2><h3 id=vinum-examples>23.6. Quelques exemples<a class=anchor href=#vinum-examples></a></h3><div class=paragraph><p>Vinum maintient une <em>base de données de configuration</em> qui décrit les objets connus pour un système individuel. Initialement, l’utilisateur créé la base de données de configuration à partir d’un ou plusieurs fichiers de configuration avec l’aide de l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a>. Vinum conserve une copie de sa base de données de configuration sur chaque tranche (que Vinum nomme <em>device</em>) sous son contrôle. Cette base données est mise à jour à chaque changement d’état, aussi un redémarrage reconstitue exactement l’état de chaque objet Vinum.</p></div><div class=sect3><h4 id=_le_fichier_de_configuration>23.6.1. Le fichier de configuration<a class=anchor href=#_le_fichier_de_configuration></a></h4><div class=paragraph><p>Le fichier de configuration décrit les objets Vinum. La définition d’un simple volume pourrait être:</p></div><div class="literalblock programlisting"><div class=content><pre>    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</pre></div></div><div class=paragraph><p>Ce fichier décrit quatre objets Vinum:</p></div><div class=ulist><ul><li><p>La ligne <em>drive</em> une partition disque (<em>drive</em>) et son emplacement relatif par rapport au matériel sous-jacent. On lui donne le nom symbolique <em>a</em>. Cette séparation entre le nom symbolique et le nom du périphérique permet aux disques d’être déplacés d’un emplacement à un autre sans confusion possible.</p></li><li><p>La ligne <em>volume</em> décrit un volume. Le seul attribut nécessaire est le nom, dans notre cas <em>myvol</em>.</p></li><li><p>La ligne <em>plex</em> définit une plex. Le seul paramètre requit est l’organisation, dans ce cas <em>concat</em>. Aucun nom n’est nécessaire: le système génère automatiquement un nom à partir du nom de volume en ajoutant le suffixe <em>.px</em>, où <em>x</em> est le nombre de plexes dans le volume. Donc cette plex sera appelée <em>myvol.p0</em>.</p></li><li><p>La ligne <em>sd</em> décrit un sous-disque. Les spécifications minimales sont le nom du disque sur lequel le stocker et la taille du sous-disque. Comme pour les plexes, aucun nom n’est nécessaire: le système assignera automatiquement des noms dérivés du nom de la plex en ajoutant le suffixe <em>.sx</em>, où <em>x</em> est le nombre de sous-disques dans la plex. Donc Vinum donnera le nom <em>myvol.p0.s0</em> à ce sous-disque.</p></li></ul></div><div class=paragraph><p>Après avoir traité ce fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> affiche ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>      #  vinum - create config1
      Configuration summary
      Drives:         1 (4 configured)
      Volumes:        1 (4 configured)
      Plexes:         1 (8 configured)
      Subdisks:       1 (16 configured)

	D a                     State: up       Device /dev/da3h        Avail: 2061/2573 MB (80%)

	V myvol                 State: up       Plexes:       1 Size:        512 MB

	P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB

	S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB</pre></div></div><div class=paragraph><p>Cette sortie affiche une brève liste du format <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a>. Elle est représentée graphiquement dans <a href=#vinum-simple-vol>Un simple volume Vinum</a>.</p></div><div id=vinum-simple-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-simple-vol.png alt="vinum simple vol"></div><div class=title>Figure 64. Un simple volume Vinum</div></div><div class=paragraph><p>Cette figure, et celles qui suivent, représentent un volume qui contient les plexes, qui à leur tour contiennent les sous-disques. Dans cet exemple trivial, le volume contient une plex, et la plex contient un sous-disque.</p></div><div class=paragraph><p>Ce volume particulier ne présente aucun avantage spécifique par rapport à une partition de disque conventionnelle. Il contient une seule plex, donc il n’est pas redondant. La plex contient un seul sous-disque, il n’y a donc pas de différence dans l’organisation du stockage des données par rapport à une partition de disque conventionnelle. Les sections suivantes présenteront diverses méthodes de configuration plus intéressantes.</p></div></div><div class=sect3><h4 id=_robustesse_accrue_le_mode_miroir>23.6.2. Robustesse accrue: le mode miroir<a class=anchor href=#_robustesse_accrue_le_mode_miroir></a></h4><div class=paragraph><p>La robustesse d’un volume peut être augmentée par le mode miroir. Quand on implémente un volume en mode miroir, il est important de s’assurer que les sous-disques de chaque plex sont sur des disques différents, de sorte qu’une panne disque ne mette hors service les deux plexes. La configuration suivante place en mode miroir un volume:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive b device /dev/da4h
	volume mirror
      plex org concat
        sd length 512m drive a
	  plex org concat
	    sd length 512m drive b</pre></div></div><div class=paragraph><p>Dans cet exemple, il n’était pas nécessaire de spécifier une définition de disque <em>a</em> à nouveau, puisque Vinum garde trace de tous les objets dans sa base de données de configuration. Après le traitement de cette définition, la configuration ressemble à:</p></div><div class="literalblock programlisting"><div class=content><pre>	Drives:         2 (4 configured)
	Volumes:        2 (4 configured)
	Plexes:         3 (8 configured)
	Subdisks:       3 (16 configured)

	D a                     State: up       Device /dev/da3h        Avail: 1549/2573 MB (60%)
	D b                     State: up       Device /dev/da4h        Avail: 2061/2573 MB (80%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
	S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
	S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB</pre></div></div><div class=paragraph><p><a href=#vinum-mirrored-vol>Un volume Vinum en mode miroir</a> présente la structure sous forme graphique.</p></div><div id=vinum-mirrored-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-mirrored-vol.png alt="vinum mirrored vol"></div><div class=title>Figure 65. Un volume Vinum en mode miroir</div></div><div class=paragraph><p>Dans cet exemple, chaque plex contient un espace d’adressage de 512 MO. Comme dans l’exemple précédent, chaque plex contient seulement un seul sous-disque.</p></div></div><div class=sect3><h4 id=_optimiser_les_performances>23.6.3. Optimiser les performances<a class=anchor href=#_optimiser_les_performances></a></h4><div class=paragraph><p>Le volume en mode miroir de l’exemple précédent est plus résistant aux pannes qu’un volume sans miroir, mais ses performances sont moindres: chaque écriture sur le volume demande d’écrire sur les deux disques, utilisant alors une plus grande proportion de la bande passante disque totale. Des considérations sur les performances demandent une approche différente: à la place d’un miroir, les données sont segmentées sur autant de disques que possible. La configuration suivante montre un volume avec une plex segmentée sur quatre disques:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive c device /dev/da5h
	drive d device /dev/da6h
	volume stripe
	plex org striped 512k
	  sd length 128m drive a
	  sd length 128m drive b
	  sd length 128m drive c
	  sd length 128m drive d</pre></div></div><div class=paragraph><p>Comme précédemment, il n’est pas nécessaire de définir les disques qui sont déjà connus de Vinum. Après traitement de cette définition, la configuration ressemble à:</p></div><div class="literalblock programlisting"><div class=content><pre>	Drives:         4 (4 configured)
	Volumes:        3 (4 configured)
	Plexes:         4 (8 configured)
	Subdisks:       7 (16 configured)

    D a                     State: up       Device /dev/da3h        Avail: 1421/2573 MB (55%)
    D b                     State: up       Device /dev/da4h        Avail: 1933/2573 MB (75%)
    D c                     State: up       Device /dev/da5h        Avail: 2445/2573 MB (95%)
    D d                     State: up       Device /dev/da6h        Avail: 2445/2573 MB (95%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
    V striped               State: up       Plexes:       1 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
    P striped.p1            State: up       Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB
    S striped.p0.s0         State: up       PO:        0  B Size:        128 MB
    S striped.p0.s1         State: up       PO:      512 kB Size:        128 MB
    S striped.p0.s2         State: up       PO:     1024 kB Size:        128 MB
    S striped.p0.s3         State: up       PO:     1536 kB Size:        128 MB</pre></div></div><div id=vinum-striped-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-striped-vol.png alt="vinum striped vol"></div><div class=title>Figure 66. Un volume Vinum segmenté</div></div><div class=paragraph><p>Ce volume est représenté sur <a href=#vinum-striped-vol>Un volume Vinum segmenté</a>. La couleur des segments indique leur position dans l’espace d’adresses de la plex: le segment le plus clair vient en premier, le plus sombre en dernier.</p></div></div><div class=sect3><h4 id=_robustesse_et_performances>23.6.4. Robustesse et performances<a class=anchor href=#_robustesse_et_performances></a></h4><div class=paragraph><p><a id=vinum-resilience></a>Avec suffisamment de matériel, il est possible de créer des volumes qui présenteront une robustesse et des performances accrues comparés aux partitions UNIX™ standards. Un fichier de configuration pourrait être:</p></div><div class="literalblock programlisting"><div class=content><pre>	volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</pre></div></div><div class=paragraph><p>Les sous-disques de la seconde plex sont décalés de deux disques par rapport à ceux de la première plex: cela aide à s’assurer que les écritures ne vont pas sur les même sous-disques même si un transfert s’effectue sur les deux disques.</p></div><div class=paragraph><p><a href=#vinum-raid10-vol>Un volume Vinum en mode miroir segmenté</a> représente la structure de ce volume.</p></div><div id=vinum-raid10-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-raid10-vol.png alt="vinum raid10 vol"></div><div class=title>Figure 67. Un volume Vinum en mode miroir segmenté</div></div></div></div><div class=sect2><h3 id=_appellation_des_objets>23.7. Appellation des objets<a class=anchor href=#_appellation_des_objets></a></h3><div class=paragraph><p>Comme décrit précédemment, Vinum assigne des noms par défaut aux plexes et aux sous-disques, bien qu’ils peuvent être imposés. Ne pas conserver les noms par défaut n’est pas recommandé: une expérience avec le gestionnaire de volume VERITAS, qui autorise les noms arbitraires pour les objets, a montré que cette flexibilité n’apporte pas d’avantage significatif, et peut être à l’origine de confusion.</p></div><div class=paragraph><p>Les noms pourront contenir tout caractère non vide, mais il est recommandé de se cantonner aux lettres, chiffres ou le caractère souligné. Les noms de volumes, plexes et sous-disques peuvent contenir jusqu’à 64 caractères, et le nom des disques 32 caractères.</p></div><div class=paragraph><p>On assigne à chaque objet Vinum un fichier spécial de périphérique dans la hiérarchie <span class=filename>/dev/vinum</span>. La configuration présentée plus haut aurait fait à Vinum créer les fichiers spéciaux de périphérique suivants:</p></div><div class=ulist><ul><li><p>Les périphériques de contrôle <span class=filename>/dev/vinum/control</span> et <span class=filename>/dev/vinum/controld</span>, qui sont respectivement utilisés par <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a>et le "daemon" Vinum.</p></li><li><p>Les entrées des périphériques en mode bloc et caractères par chaque volume. Ce sont les périphériques principaux utilisés par Vinum. Les noms de périphériques en mode bloc sont le nom du volume, alors que les noms de périphériques en mode caractère suivent la tradition BSD de faire précéder le nom de la lettre <em>r</em>. Donc la configuration précédent inclurait les périphériques en mode bloc <span class=filename>/dev/vinum/myvol</span>, <span class=filename>/dev/vinum/mirror</span>, <span class=filename>/dev/vinum/striped</span>, <span class=filename>/dev/vinum/raid5</span> et <span class=filename>/dev/vinum/raid10</span>, et les périphériques en mode caractères <span class=filename>/dev/vinum/rmyvol</span>, <span class=filename>/dev/vinum/rmirror</span>, <span class=filename>/dev/vinum/rstriped</span>, <span class=filename>/dev/vinum/rraid5</span> et <span class=filename>/dev/vinum/rraid10</span>. Un problème évident apparaît ici: il est possible d’avoir deux volumes appelés <em>r</em> et <em>rr</em>, mais il y aurait un conflit lors de la création du fichier spécial de périphérique <span class=filename>/dev/vinum/rr</span>: c’est le périphérique en mode caractère du volume <em>r</em> ou le périphérique en mode bloc du volume <em>rr</em>? Actuellement Vinum ne résout pas ce conflit: le premier volume défini obtiendra le nom.</p></li><li><p>Un répertoire <span class=filename>/dev/vinum/drive</span> avec des entrées pour chaque disque. Ces entrées sont en fait des liens symboliques vers les fichiers spéciaux de périphérique de disque correspondants.</p></li><li><p>Un répertoire <span class=filename>/dev/vinum/volume</span> avec des entrées pour chaque volume. Il contient des sous-répertoires pour chaque plex, qui à leur tour contiennent des sous-répertoires pour leurs sous-disques.</p></li><li><p>Les répertoires <span class=filename>/dev/vinum/plex</span>, <span class=filename>/dev/vinum/sd</span>, et <span class=filename>/dev/vinum/rsd</span>, qui contiennent les fichiers spéciaux de périphérique en mode bloc pour chaque plex et les fichiers spéciaux de périphérique en mode bloc et caractère pour chaque sous-disque.</p></li></ul></div><div class=paragraph><p>Par exemple, considérons le fichier de configuration suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive drive1 device /dev/sd1h
	drive drive2 device /dev/sd2h
	drive drive3 device /dev/sd3h
	drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4</pre></div></div><div class=paragraph><p>Après traitement de ce fichier, <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> crée la structure suivante dans <span class=filename>/dev/vinum</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>	brwx------  1 root  wheel   25, 0x40000001 Apr 13 16:46 Control
	brwx------  1 root  wheel   25, 0x40000002 Apr 13 16:46 control
	brwx------  1 root  wheel   25, 0x40000000 Apr 13 16:46 controld
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 drive
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 plex
	crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 rs64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rsd
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rvol
	brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 sd
	drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 vol

	/dev/vinum/drive:
    total 0
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive1 - /dev/sd1h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive2 - /dev/sd2h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive3 - /dev/sd3h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive4 - /dev/sd4h

    /dev/vinum/plex:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0

    /dev/vinum/rsd:
    total 0
    crwxr-xr--  1 root  wheel   91, 0x20000002 Apr 13 16:46 s64.p0.s0
    crwxr-xr--  1 root  wheel   91, 0x20100002 Apr 13 16:46 s64.p0.s1
    crwxr-xr--  1 root  wheel   91, 0x20200002 Apr 13 16:46 s64.p0.s2
    crwxr-xr--  1 root  wheel   91, 0x20300002 Apr 13 16:46 s64.p0.s3

    /dev/vinum/rvol:
    total 0
    crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 s64

    /dev/vinum/sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3

    /dev/vinum/vol:
    total 1
    brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
    drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 s64.plex

    /dev/vinum/vol/s64.plex:
    total 1
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0
    drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 s64.p0.sd

    /dev/vinum/vol/s64.plex/s64.p0.sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3</pre></div></div><div class=paragraph><p>Bien qu’il soit recommandé de ne pas donner de nom spécifique aux plexes et sous-disques, les disques Vinum doivent avoir un nom. Cela rend possible de déplacer un disque à un emplacement différent et qu’il soit toujours reconnu automatiquement. Les noms de disques peuvent avoir jusqu’à 32 caractères.</p></div><div class=sect3><h4 id=_création_de_systèmes_de_fichiers>23.7.1. Création de systèmes de fichiers<a class=anchor href=#_création_de_systèmes_de_fichiers></a></h4><div class=paragraph><p>Les volumes apparaissent pour le système comme des disques, avec une seule exception. Contrairement aux disques UNIX™, Vinum ne partitionne pas les volumes, qui ne contiennent donc pas de table de partitionnement. Cela a demandé de modifier certains utilitaires disque, en particulier <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>, qui auparavant tentait d’interpréter la dernière lettre du nom de volume Vinum comme un identifiant de partition. Par exemple, un disque peut avoir un nom comme <span class=filename>/dev/ad0a</span>$ ou <span class=filename>/dev/da2h</span>. Ces noms représentent respectivement la première partition (<span class=filename>a</span>) sur le premier (0) disque IDE (<span class=filename>ad</span>) la la huitième partition (<span class=filename>h</span>) sur le troisième (2) disque SCSI (<span class=filename>da</span>). En revanche, un volume Vinum pourra être appelé <span class=filename>/dev/vinum/concat</span>, un nom qui n’a pas de relation avec un nom de partition.</p></div><div class=paragraph><p>Normalement, <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> interprète le nom du disque et se plaint s’il ne peut le comprendre. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/vinum/concat</span>
newfs: /dev/vinum/concat: can<span class=s1>&#39;t figure out file system partition</span></code></pre></div></div><div class=paragraph><p>Afin de créer un système de fichiers sur ce volume, utilisez l’option <code>-v</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -v /dev/vinum/concat</span></code></pre></div></div></div></div><div class=sect2><h3 id=vinum-config>23.8. Configuration de Vinum<a class=anchor href=#vinum-config></a></h3><div class=paragraph><p>Le noyau <span class=filename>GENERIC</span> ne contient pas le support Vinum. Il est possible de compiler un noyau spécial qui inclut vinum, mais cela n’est pas recommandé. La méthode standard de lancement de Vinum est d’utiliser un module du noyau (kld). Vous n’avez même pas besoin d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> pour Vinum: quand vous lancez <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a>, il contrôle si le module a été chargé ou non, si ce n’est pas le cas, il le charge automatiquement.</p></div><div class=sect3><h4 id=_démarrage>23.8.1. Démarrage<a class=anchor href=#_démarrage></a></h4><div class=paragraph><p>Vinum stocke l’information de configuration sur les tranches des disques sous la même forme que dans les fichiers de configuration. En lisant à partir de la base de données de configuration, Vinum reconnaît un certain nombre de mots clés qui ne sont pas autorisés dans les fichiers de configuration. Par exemple, une configuration de disque pourrait contenir le texte suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</pre></div></div><div class=paragraph><p>Ici les différences évidentes sont la présence d’une information explicite sur l’emplacement et le nom (les deux sont également autorisés, mais leur utilisation est déconseillée à l’utilisateur) et de l’information sur les états (qui ne sont pas disponibles à l’utilisateur). Vinum ne stocke pas d’informations au sujet des disques dans la configuration: il localise les disques en recherchant les disques configurés pour les partitions dans le label Vinum. Cela permet à Vinum d’identifier correctement les disques même s’ils ont un identifiant de disque UNIX™ différent.</p></div><div class=sect4><h5 id=_démarrage_automatique>23.8.1.1. Démarrage automatique<a class=anchor href=#_démarrage_automatique></a></h5><div class=paragraph><p>Afin de lancer automatiquement Vinum au démarrage du système, assurez-vous d’avoir la ligne suivante dans votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>start_vinum=&#34;YES&#34;		# set to YES to start vinum</pre></div></div><div class=paragraph><p>Si vous n’avez pas de fichier <span class=filename>/etc/rc.conf</span>, créez en un avec cette ligne. Cela provoquera le chargement du module Vinum au démarrage du système, et le lancement de tout objet mentionné dans la configuration. Cela est fait avant de monter les systèmes de fichiers, il est donc possible d’utiliser automatiquement <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> sur des systèmes de fichiers puis de les monter sur des volumes Vinum.</p></div><div class=paragraph><p>quand vous démarrez avec la commande <code>vinum start</code>, Vinum lit la base de données de configuration à partir d’un des disques Vinum. Dans des circonstances normales, chaque disque contient une copie identique de la base de données de configuration, il importe donc peu quel disque est lu. Après un crash, Vinum doit déterminer quel disque a été mis à jour le plus récemment et lire la configuration à partir de ce disque. Il met ensuite à jour la configuration si nécessaire à partir de disques progressivement de plus en plus anciens.</p></div></div></div></div></div></div><div class=sect1><h2 id=virtualization>Chapitre 24. Virtualisation<a class=anchor href=#virtualization></a></h2><div class=sectionbody><div class=sect2><h3 id=virtualization-synopsis>24.1. Synopsis<a class=anchor href=#virtualization-synopsis></a></h3><div class=paragraph><p>Un logiciel de virtualisation permet l’exécution simultanée de plusieurs systèmes d’exploitation sur la même machine. De tels logiciels pour PCs impliquent l’utilisation d’un système d’exploitation hôte qui exécute le logiciel de virtualisation et qui supporte un certain nombre de systèmes d’exploitation invités.</p></div><div class=paragraph><p>Après avoir lu ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>La différence entre un système d’exploitation hôte et un système d’exploitation invité.</p></li><li><p>Comment installer FreeBSD sur un ordinateur Apple® Macintosh® à base Intel®.</p></li><li><p>Comment installer FreeBSD sur Linux® avec Xen™.</p></li><li><p>Comment installer FreeBSD sur Microsoft® Windows® avec Virtual PC.</p></li><li><p>Comment optimiser un système FreeBSD pour obtenir les meilleures performances en virtualisation.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez</p></div><div class=ulist><ul><li><p>Comprendre les fondements d’UNIX® et de FreeBSD (<a href=./#basics>Quelques bases d’UNIX</a>).</p></li><li><p>Savoir comment installer FreeBSD (<a href=./#bsdinstall>Installer FreeBSD</a>).</p></li><li><p>Savoir comment configurer votre connexion au réseau (<a href=./#advanced-networking>Administration réseau avancée</a>).</p></li><li><p>Savoir comment installer des logiciels tierce-partie (<a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li></ul></div></div><div class=sect2><h3 id=virtualization-guest>24.2. FreeBSD comme système d’exploitation invité<a class=anchor href=#virtualization-guest></a></h3><div class=sect3><h4 id=virtualization-guest-parallels>24.2.1. Parallels sur Mac OS®<a class=anchor href=#virtualization-guest-parallels></a></h4><div class=paragraph><p>Parallels Desktop pour Mac® est un logiciel commercial pour les ordinateurs Apple® Mac® à base Intel® tournant sous Mac OS® 10.4.6 our versions supérieures. FreeBSD est totalement supporté en tant que système d’exploitation invité. Une fois que Parallels a été installé sur Mac OS® X, l’utilisateur doit configurer une machine virtuelle et installer le système d’exploitation invité qu’il désire.</p></div><div class=sect4><h5 id=virtualization-guest-parallels-install>24.2.1.1. Installer FreeBSD sur Parallels/Mac OS® X<a class=anchor href=#virtualization-guest-parallels-install></a></h5><div class=paragraph><p>La première étape pour installer FreeBSD sur Mac OS® X/Parallels est de créer une machine virtuelle pour l’installation de FreeBSD. Sélectionnez <span class=guimenuitem>FreeBSD</span> comme <b class=menuref>Système d’exploitation invité</b> quand on vous le demandera:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd1.png alt="parallels freebsd1"></div></div><div class=paragraph><p>Et choisissez une taille de disque dur et de mémoire vive en fonction de l’utilisation que vous projetez pour votre FreeBSD virtuel. 4Go de disque et 512Mo de RAM conviennent pour la plupart des utilisations de FreeBSD sous Parallels:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd2.png alt="parallels freebsd2"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd3.png alt="parallels freebsd3"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd4.png alt="parallels freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd5.png alt="parallels freebsd5"></div></div><div class=paragraph><p>Sélectionnez le type de réseau et une carte réseau:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd6.png alt="parallels freebsd6"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd7.png alt="parallels freebsd7"></div></div><div class=paragraph><p>Sauvegardez et achevez la configuration:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd8.png alt="parallels freebsd8"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd9.png alt="parallels freebsd9"></div></div><div class=paragraph><p>Une fois votre machine virtuelle créée, vous devrez y installer FreeBSD. Le meilleur moyen est d’utiliser un CDROM FreeBSD officiel ou une image ISO récupérée sur un site FTP officiel. Quand vous avez l’image ISO adéquate sur votre système de fichiers Mac® ou un CDROM dans le lecteur de CD du Mac®, cliquez sur l’icône disque située dans le coin droit en bas de votre fenêtre Parallels. Une fenêtre s’ouvrira pour vous permettre d’associer le lecteur de CDROM de votre machine virtuelle avec un fichier ISO ou le véritable lecteur de CDROM de votre ordinateur.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd11.png alt="parallels freebsd11"></div></div><div class=paragraph><p>Dès que vous avez effectué cette association, redémarrez votre machine virtuelle FreeBSD en cliquant sur l’icône de redémarrage. Parallels redémarrera avec un BIOS particulier qui vérifiera si vous disposez d’un CDROM tout comme le ferait un BIOS classique.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd10.png alt="parallels freebsd10"></div></div><div class=paragraph><p>Dans notre cas il trouvera le disque d’installation de FreeBSD et lancera une installation normale avec sysinstall comme décrit dans le <a href=./#bsdinstall>Installer FreeBSD</a>. Vous pouvez installer X11 mais ne tentez pas de le configurer pour le moment.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd12.png alt="parallels freebsd12"></div></div><div class=paragraph><p>Quand l’installation est terminée, redémarrez votre machine virtuelle FreeBSD.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd13.png alt="parallels freebsd13"></div></div></div><div class=sect4><h5 id=virtualization-guest-parallels-configure>24.2.1.2. Configurer FreeBSD sur Mac OS® X/Parallels<a class=anchor href=#virtualization-guest-parallels-configure></a></h5><div class=paragraph><p>Après avoir installé avec succès FreeBSD sur Mac OS® X avec Parallels, il reste plusieurs points à configurer pour optimiser le système virtuel.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Paramétrer les variables du chargeur</p><div class=paragraph><p>L’étape la plus importante est la diminution du paramètre <code>kern.hz</code> afin de réduire l’utilisation du CPU de FreeBSD sous l’environnement Parallels. Pour cela, il faut ajouter la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Sans ce paramétrage, un système d’exploitation invité FreeBSD inactif sous Parallels utilisera environ 15% du CPU sur un iMac® à mono-processeur. Après ce changement l’utilisation du processeur sera plus proche d’un petit 5%.</p></div></li><li><p>Créer un nouveau fichier de configuration du noyau</p><div class=paragraph><p>Vous pouvez retirer tous les pilotes de périphériques SCSI, FireWire et USB. Parallels fournit une carte réseau virtuelle utilisant le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a>, aussi tous les autres pilotes réseau exceptés <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> peuvent être retirés du noyau.</p></div></li><li><p>Configuration du réseau</p><div class=paragraph><p>La configuration réseau la plus simple utilise DHCP pour connecter votre machine virtuelle sur le même réseau local que votre machine Mac® hôte. Cette configuration se fait en ajoutant la ligne <code>ifconfig_ed0="DHCP"</code> au fichier <span class=filename>/etc/rc.conf</span>. Des configurations réseau plus avancées sont décrites dans le <a href=./#advanced-networking>Administration réseau avancée</a>.</p></div></li></ol></div></div></div></div></div><div class=sect3><h4 id=virtualization-guest-xen>24.2.2. FreeBSD avec Xen™ sur Linux<a class=anchor href=#virtualization-guest-xen></a></h4><div class=paragraph><p>L’hyperviseur Xen™ est un logiciel libre de para-virtualisation qui est supporté par l’entreprise commerciale XenSource. Les systèmes d’exploitation invités sont appelés domaines domU, et le système d’exploitation hôte est appelé dom0. La première étape pour faire tourner un FreeBSD virtuel sous Linux® est d’installer Xen™ pour le domaine dom0 Linux®. Le système d’exploitation hôte sera une distribution Linux® Slackware.</p></div><div class=sect4><h5 id=xen-slackware-dom0>24.2.2.1. Configuration de Xen™ 3 sur un dom0 Linux®<a class=anchor href=#xen-slackware-dom0></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Télécharger Xen™ 3.0 auprès de XenSource</p><div class=paragraph><p>Récupérez l’archive <a href=http://bits.xensource.com/oss-xen/release/3.0.4-1/src.tgz/xen-3.0.4_1-src.tgz>xen-3.0.4_1-src.tgz</a> auprès de <a href=http://www.xensource.com/>http://www.xensource.com/</a>.</p></div></li><li><p>Extraire l’archive</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd xen-3.0.4_1-src</span>
<span class=c># KERNELS=&#34;linux-2.6-xen0 linux-2.6-xenU&#34; make world</span>
<span class=c># make install</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pour recompiler le noyau pour le domaine dom0:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd xen-3.0.4_1-src/linux-2.6.16.33-xen0</span>
  <span class=c># make menuconfig</span>
  <span class=c># make</span>
  <span class=c># make install</span></code></pre></div></div><div class=paragraph><p>D’anciennes versions de Xen™ peuvent nécessiter l’utilisation de la commande <code>make ARCH=xen menuconfig</code></p></div></td></tr></tbody></table></div></li><li><p>Ajouter une entrée au menu de Grub (menu.lst)</p><div class=paragraph><p>Editez <span class=filename>/boot/grub/menu.lst</span> et ajoutez les lignes suivantes:</p></div><div class="literalblock programlisting"><div class=content><pre>title Xen-3.0.4
root (hd0,0)
kernel /boot/xen-3.0.4-1.gz dom0_mem=262144
module /boot/vmlinuz-2.6.16.33-xen0 root=/dev/hda1 ro</pre></div></div></li><li><p>Redémarrer votre ordinateur sous Xen™</p><div class=paragraph><p>Tout d’abord, éditez <span class=filename>/etc/xen/xend-config.sxp</span>, et ajoutez la ligne suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>(network-script &#39;network-bridge netdev=eth0&#39;)</pre></div></div><div class=paragraph><p>Nous pouvons maintenant lancer Xen™:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/init.d/xend start</span>
<span class=c># /etc/init.d/xendomains start</span></code></pre></div></div><div class=paragraph><p>Notre domaine dom0 fonctionne:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xm list</span>
Name                                      ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                   0   256     1     r-----  54452.9</code></pre></div></div></li></ol></div></div></div></div><div class=sect4><h5 id=_domaine_domu_freebsd_7_current>24.2.2.2. Domaine domU FreeBSD 7-CURRENT<a class=anchor href=#_domaine_domu_freebsd_7_current></a></h5><div class=paragraph><p>Téléchargez le noyau pour domU FreeBSD pour Xen™ 3.0 et l’image disque auprès de <a href=http://www.fsmware.com/>http://www.fsmware.com/</a></p></div><div class=ulist><ul><li><p><a href=http://www.fsmware.com/xenofreebsd/7.0/download/kernel-current>kernel-current</a></p></li><li><p><a href=http://www.fsmware.com/xenofreebsd/7.0/download/mdroot-7.0.bz2>mdroot-7.0.bz2</a></p></li><li><p><a href=http://www.fsmware.com/xenofreebsd/7.0/download/config/xmexample1.bsd>xmexample1.bsd</a></p></li></ul></div><div class=paragraph><p>Placez le fichier de configuration <span class=filename>xmexample1.bsd</span> dans le répertoire <span class=filename>/etc/xen/</span> et modifiez les entrées relatives à l’emplacement du noyau et de l’image disque. Cela devrait donner quelque chose comme:</p></div><div class="literalblock programlisting"><div class=content><pre>kernel = &#34;/opt/kernel-current&#34;
memory = 256
name = &#34;freebsd&#34;
vif = [ &#39;&#39; ]
disk = [ &#39;file:/opt/mdroot-7.0,hda1,w&#39; ]
#on_crash    = &#39;preserve&#39;
extra = &#34;boot_verbose&#34;
extra += &#34;,boot_single&#34;
extra += &#34;,kern.hz=100&#34;
extra += &#34;,vfs.root.mountfrom=ufs:/dev/xbd769a&#34;</pre></div></div><div class=paragraph><p>Le fichier <span class=filename>mdroot-7.0.bz2</span> doit être décompressé.</p></div><div class=paragraph><p>Ensuite, la section __xen_guest du fichier <span class=filename>kernel-current</span> doit être modifiée pour y ajouter le paramètre VIRT_BASE dont a besoin Xen™ 3.0.3:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># objcopy kernel-current -R __xen_guest</span>
<span class=c># perl -e &#39;print &#34;LOADER=generic,GUEST_OS=freebsd,GUEST_VER=7.0,XEN_VER=xen-3.0,BSD_SYMTAB,VIRT_BASE=0xC0000000\x00&#34;&#39; &gt; tmp</span>
<span class=c># objcopy kernel-current --add-section __xen_guest=tmp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># objdump -j __xen_guest -s kernel-current</span>

kernel-current:     file format elf32-i386

Contents of section __xen_guest:
 0000 4c4f4144 45523d67 656e6572 69632c47  <span class=nv>LOADER</span><span class=o>=</span>generic,G
 0010 55455354 5f4f533d 66726565 6273642c  <span class=nv>UEST_OS</span><span class=o>=</span>freebsd,
 0020 47554553 545f5645 523d372e 302c5845  <span class=nv>GUEST_VER</span><span class=o>=</span>7.0,XE
 0030 4e5f5645 523d7865 6e2d332e 302c4253  <span class=nv>N_VER</span><span class=o>=</span>xen-3.0,BS
 0040 445f5359 4d544142 2c564952 545f4241  D_SYMTAB,VIRT_BA
 0050 53453d30 78433030 30303030 3000      <span class=nv>SE</span><span class=o>=</span>0xC0000000.</code></pre></div></div><div class=paragraph><p>Nous sommes maintenant prêt à créer et lancer notre domU:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xm create /etc/xen/xmexample1.bsd -c</span>
Using config file <span class=s2>&#34;/etc/xen/xmexample1.bsd&#34;</span><span class=nb>.</span>
Started domain freebsd
WARNING: loader<span class=o>(</span>8<span class=o>)</span> metadata is missing!
Copyright <span class=o>(</span>c<span class=o>)</span> 1992-2006 The FreeBSD Project.
Copyright <span class=o>(</span>c<span class=o>)</span> 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
The Regents of the University of California. All rights reserved.
FreeBSD 7.0-CURRENT <span class=c>#113: Wed Jan  4 06:25:43 UTC 2006</span>
    kmacy@freebsd7.gateway.2wire.net:/usr/home/kmacy/p4/freebsd7_xen3/src/sys/i386-xen/compile/XENCONF
WARNING: DIAGNOSTIC option enabled, expect reduced performance.
Xen reported: 1796.927 MHz processor.
Timecounter <span class=s2>&#34;ixen&#34;</span> frequency 1796927000 Hz quality 0
CPU: Intel<span class=o>(</span>R<span class=o>)</span> Pentium<span class=o>(</span>R<span class=o>)</span> 4 CPU 1.80GHz <span class=o>(</span>1796.93-MHz 686-class CPU<span class=o>)</span>
  Origin <span class=o>=</span> <span class=s2>&#34;GenuineIntel&#34;</span>  Id <span class=o>=</span> 0xf29  Stepping <span class=o>=</span> 9
  <span class=nv>Features</span><span class=o>=</span>0xbfebfbff&lt;FPU,VME,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,CMOV,PAT,PSE36,CLFLUSH,
  DTS,ACPI,MMX,FXSR,SSE,SSE2,SS,HTT,TM,PBE&gt;
  <span class=nv>Features2</span><span class=o>=</span>0x4400&lt;CNTX-ID,&lt;b14&gt;&gt;
real memory  <span class=o>=</span> 265244672 <span class=o>(</span>252 MB<span class=o>)</span>
avail memory <span class=o>=</span> 255963136 <span class=o>(</span>244 MB<span class=o>)</span>
xc0: &lt;Xen Console&gt; on motherboard
cpu0 on motherboard
Timecounters tick every 10.000 msec
<span class=o>[</span>XEN] Initialising virtual ethernet driver.
xn0: Ethernet address: 00:16:3e:6b:de:3a
<span class=o>[</span>XEN]
Trying to mount root from ufs:/dev/xbd769a
WARNING: / was not properly dismounted
Loading configuration files.
No suitable dump device was found.
Entropy harvesting: interrupts ethernet point_to_point kickstart.
Starting file system checks:
/dev/xbd769a: 18859 files, 140370 used, 113473 free <span class=o>(</span>10769 frags, 12838 blocks, 4.2% fragmentation<span class=o>)</span>
Setting <span class=nb>hostname</span>: demo.freebsd.org.
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
	  inet6 ::1 prefixlen 128
	  inet6 fe80::1%lo0 prefixlen 64 scopeid 0x2
	  inet 127.0.0.1 netmask 0xff000000
Additional routing options:.
Mounting NFS file systems:.
Starting syslogd.
/etc/rc: WARNING: Dump device does not exist.  Savecore not run.
ELF ldconfig path: /lib /usr/lib /usr/lib/compat /usr/X11R6/lib /usr/local/lib
a.out ldconfig path: /usr/lib/aout /usr/lib/compat/aout /usr/X11R6/lib/aout
Starting usbd.
usb: Kernel module not available: No such file or directory
Starting <span class=nb>local </span>daemons:.
Updating motd.
Starting sshd.
Initial i386 initialization:.
Additional ABI support: linux.
Starting cron.
Local package initialization:.
Additional TCP options:.
Starting background file system checks <span class=k>in </span>60 seconds.

Sun Apr  1 02:11:43 UTC 2007

FreeBSD/i386 <span class=o>(</span>demo.freebsd.org<span class=o>)</span> <span class=o>(</span>xc0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>Le domaine domU devrait exécuter le noyau FreeBSD 7.0-CURRENT:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># uname -a</span>
FreeBSD demo.freebsd.org 7.0-CURRENT FreeBSD 7.0-CURRENT <span class=c>#113: Wed Jan  4 06:25:43 UTC 2006</span>
kmacy@freebsd7.gateway.2wire.net:/usr/home/kmacy/p4/freebsd7_xen3/src/sys/i386-xen/compile/XENCONF  i386</code></pre></div></div><div class=paragraph><p>Le réseau peut maintenant être configuré sur le domaine domU. Le domaine domU FreeBSD utilisera une interface spécifique appelée <span class=filename>xn0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig xn0 10.10.10.200 netmask 255.0.0.0</span>
<span class=c># ifconfig</span>
xn0: <span class=nv>flags</span><span class=o>=</span>843&lt;UP,BROADCAST,RUNNING,SIMPLEX&gt; mtu 1500
    inet 10.10.10.200 netmask 0xff000000 broadcast 10.255.255.255
    ether 00:16:3e:6b:de:3a
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
      inet6 ::1 prefixlen 128
      inet6 fe80::1%lo0 prefixlen 64 scopeid 0x2
      inet 127.0.0.1 netmask 0xff000000</code></pre></div></div><div class=paragraph><p>Sur le domaine dom0 Slackware, des interfaces réseaux relatives à Xen™ devraient apparaître:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span>
eth0      Link encap:Ethernet  HWaddr 00:07:E9:A0:02:C2
          inet addr:10.10.10.130  Bcast:0.0.0.0  Mask:255.0.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:815 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1400 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:204857 <span class=o>(</span>200.0 KiB<span class=o>)</span>  TX bytes:129915 <span class=o>(</span>126.8 KiB<span class=o>)</span>

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:99 errors:0 dropped:0 overruns:0 frame:0
          TX packets:99 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:9744 <span class=o>(</span>9.5 KiB<span class=o>)</span>  TX bytes:9744 <span class=o>(</span>9.5 KiB<span class=o>)</span>

peth0     Link encap:Ethernet  HWaddr FE:FF:FF:FF:FF:FF
          UP BROADCAST RUNNING NOARP  MTU:1500  Metric:1
          RX packets:1853349 errors:0 dropped:0 overruns:0 frame:0
          TX packets:952923 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:2432115831 <span class=o>(</span>2.2 GiB<span class=o>)</span>  TX bytes:86528526 <span class=o>(</span>82.5 MiB<span class=o>)</span>
          Base address:0xc000 Memory:ef020000-ef040000

vif0.1    Link encap:Ethernet  HWaddr FE:FF:FF:FF:FF:FF
          UP BROADCAST RUNNING NOARP  MTU:1500  Metric:1
          RX packets:1400 errors:0 dropped:0 overruns:0 frame:0
          TX packets:815 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:129915 <span class=o>(</span>126.8 KiB<span class=o>)</span>  TX bytes:204857 <span class=o>(</span>200.0 KiB<span class=o>)</span>

vif1.0    Link encap:Ethernet  HWaddr FE:FF:FF:FF:FF:FF
          UP BROADCAST RUNNING NOARP  MTU:1500  Metric:1
          RX packets:3 errors:0 dropped:0 overruns:0 frame:0
          TX packets:2 errors:0 dropped:157 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:140 <span class=o>(</span>140.0 b<span class=o>)</span>  TX bytes:158 <span class=o>(</span>158.0 b<span class=o>)</span>

xenbr1    Link encap:Ethernet  HWaddr FE:FF:FF:FF:FF:FF
          UP BROADCAST RUNNING NOARP  MTU:1500  Metric:1
          RX packets:4 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:112 <span class=o>(</span>112.0 b<span class=o>)</span>  TX bytes:0 <span class=o>(</span>0.0 b<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brctl show</span>
bridge name     bridge <span class=nb>id           </span>STP enabled         interfaces
xenbr1          8000.feffffffffff   no                  vif0.1
                                                        peth0
                                                        vif1.0</code></pre></div></div></div></div><div class=sect3><h4 id=virtualization-guest-virtualpc>24.2.3. Virtual PC sur Windows®<a class=anchor href=#virtualization-guest-virtualpc></a></h4><div class=paragraph><p>Virtual PC pour Windows® est un logiciel Microsoft® librement téléchargeable. Consultez la page concernant la <a href=http://www.microsoft.com/windows/downloads/virtualpc/sysreq.mspx>configuration minimale requise</a>. Une fois Virtual PC installé sous Microsoft® Windows®, l’utilisateur doit configurer une machine virtuelle puis installer le système d’exploitation invité désiré.</p></div><div class=sect4><h5 id=virtualization-guest-virtualpc-install>24.2.3.1. Installer FreeBSD sous Virtual PC/Microsoft® Windows®<a class=anchor href=#virtualization-guest-virtualpc-install></a></h5><div class=paragraph><p>La première étape de l’installation de FreeBSD sous Microsoft® Windows®/Virtual PC est la création d’une nouvelle machine virtuelle pour permettre l’installation de FreeBSD. Sélectionnez <span class=guimenuitem>Create a virtual machine</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd1.png alt="virtualpc freebsd1"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd2.png alt="virtualpc freebsd2"></div></div><div class=paragraph><p>Puis sélectionnez <span class=guimenuitem>Other</span> pour <span class=guimenuitem>Operating system</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd3.png alt="virtualpc freebsd3"></div></div><div class=paragraph><p>Choisissez ensuite une quantité raisonnable d’espace disque et de mémoire en fonction de vos projets pour cette installation de FreeBSD. 4Go d’espace de disque et 512Mo de mémoire vive conviennent pour la plupart des utilisateurs de FreeBSD sous Virtual PC:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd4.png alt="virtualpc freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd5.png alt="virtualpc freebsd5"></div></div><div class=paragraph><p>Sauvegardez et poursuivez la configuration:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd6.png alt="virtualpc freebsd6"></div></div><div class=paragraph><p>Sélectionnez votre machine virtuelle FreeBSD, cliquez sur <b class=menuref>Settings</b>, puis précisez le type de réseau et l’interface réseau:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd7.png alt="virtualpc freebsd7"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd8.png alt="virtualpc freebsd8"></div></div><div class=paragraph><p>Une fois votre machine virtuelle FreeBSD créée, vous devrez y installer FreeBSD. La meilleure manière étant d’utiliser un CDROM FreeBSD officiel ou une image ISO téléchargée depuis un site FTP officiel. Quand vous avez l’image ISO appropriée sur votre système de fichiers Windows® ou sur un CDROM dans votre lecteur de CD, double-cliquez sur votre machine virtuelle FreeBSD pour démarrer. Puis cliquez sur <b class=menuref>CD</b> et sélectionnez <b class=menuref>Capture ISO Image…​</b> dans la fenêtre Virtual PC. Une fenêtre apparaîtra et vous permettra d’associer le lecteur de CDROM de votre machine virtuelle avec une image ISO ou votre lecteur de CDROM réel.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd9.png alt="virtualpc freebsd9"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd10.png alt="virtualpc freebsd10"></div></div><div class=paragraph><p>L’association avec votre CDROM source effectuée, redémarrez votre machine virtuelle FreeBSD en cliquant sur <b class=menuref>Action</b> puis sur <b class=menuref>Reset</b>. Virtual PC redémarrera, son BIOS vérifiera tout d’abord que vous disposez d’un CDROM comme le ferait n’importe quel BIOS normal.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd11.png alt="virtualpc freebsd11"></div></div><div class=paragraph><p>Dans ce cas, le support d’installation FreeBSD sera trouvé et une installation classique basée sur sysinstall débutera comme décrit dans le <a href=./#bsdinstall>Installer FreeBSD</a>. Vous pouvez installez X11 mais ne tentez pas pour le moment de le configurer.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd12.png alt="virtualpc freebsd12"></div></div><div class=paragraph><p>Quand vous avez achevé l’installation, pensez à éjecter le CDROM ou l’image ISO. Enfin, redémarrez dans votre machine virtuelle FreeBSD fraîchement installée.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd13.png alt="virtualpc freebsd13"></div></div></div><div class=sect4><h5 id=virtualization-guest-virtualpc-configure>24.2.3.2. Configuration de FreeBSD sous Microsoft® Windows®/Virtual PC<a class=anchor href=#virtualization-guest-virtualpc-configure></a></h5><div class=paragraph><p>Après avoir installé avec succès FreeBSD sur Microsoft® Windows® avec Virtual PC, il reste plusieurs points à configurer pour optimiser le système virtuel.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Paramétrer les variables du chargeur</p><div class=paragraph><p>L’étape la plus importante est la diminution du paramètre <code>kern.hz</code> afin de réduire l’utilisation du CPU de FreeBSD sous l’environnement Virtual PC. Pour cela, il faut ajouter la ligne suivante au fichier <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Sans ce paramétrage, un système d’exploitation invité FreeBSD inactif sous Virtual PC utilisera environ 40% du CPU pour un micro-ordinateur monoprocesseur. Après ce changement l’utilisation du processeur sera plus proche d’un petit 3%.</p></div></li><li><p>Créer un nouveau fichier de configuration du noyau</p><div class=paragraph><p>Vous pouvez retirer tous les pilotes de périphériques SCSI, FireWire, et USB. Virtual PC fournit une interface réseau virtuelle utilisant le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a>, aussi tous les autres pilotes réseau en dehors de <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> peuvent être supprimés du noyau.</p></div></li><li><p>Configuration du réseau</p><div class=paragraph><p>La configuration réseau la plus simple utilise DHCP pour connecter votre machine virtuelle sur le même réseau local que votre machine Mac® hôte. Cette configuration se fait en ajoutant la ligne <code>ifconfig_de0="DHCP"</code> au fichier <span class=filename>/etc/rc.conf</span>. Des configurations réseau plus avancées sont présentées dans le <a href=./#advanced-networking>Administration réseau avancée</a>.</p></div></li></ol></div></div></div></div></div><div class=sect3><h4 id=virtualization-guest-vmware>24.2.4. VMware sur Windows®/Mac®/Linux®<a class=anchor href=#virtualization-guest-vmware></a></h4><div class=paragraph><p>Cette section n’est pas encore écrite.</p></div></div></div><div class=sect2><h3 id=virtualization-host>24.3. FreeBSD comme système d’exploitation hôte<a class=anchor href=#virtualization-host></a></h3><div class=paragraph><p>Actuellement, FreeBSD en tant que système d’exploitation hôte n’est officiellement supporté par aucun logiciel de virtualisation, de nombreuses personnes utilisent d’anciennes versions de VMware pour cela. Des efforts sont actuellement déployés pour faire fonctionner Xen™ en tant qu’environnement hôte sur FreeBSD.</p></div></div></div></div><div class=sect1><h2 id=l10n>Chapitre 25. Localisation - Utilisation et configuration de l’I18N/L10N<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-synopsis>25.1. Synopsis<a class=anchor href=#l10n-synopsis></a></h3><div class=paragraph><p>FreeBSD est un projet à très large audience avec des utilisateurs et des contributeurs provenant du monde entier. Ce chapitre discute des fonctions d’internationalisation et de localisation de FreeBSD qui permettent aux non-anglophones de travailler. Il y a de nombreux aspects de l’implémentation i18n au niveau système et application, et quand ce sera possible nous renverrons le lecteur à des sources de documentation plus spécifiques.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Comment les différentes langues et "locales" sont codées sur les systèmes d’exploitation modernes.</p></li><li><p>Comment paramétrer les "locales" pour votre interpréteur de commandes.</p></li><li><p>Comment configurer la console pour d’autres langues que l’anglais.</p></li><li><p>Comment employer le système X Window efficacement avec différentes langues.</p></li><li><p>Où trouver plus d’informations sur l’écriture d’applications conformes à la norme i18n.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Savoir comment installer des logiciels tiers (<a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li></ul></div></div><div class=sect2><h3 id=l10n-basics>25.2. Les bases<a class=anchor href=#l10n-basics></a></h3><div class=sect3><h4 id=_quest_ce_que_i18nl10n>25.2.1. Qu’est-ce que I18N/L10N?<a class=anchor href=#_quest_ce_que_i18nl10n></a></h4><div class=paragraph><p>Les développeurs ont raccourci le terme internationalisation en I18N, en comptant le nombre de lettres entre la première et la dernière du mot internationalisation. L10N utilise le même principe, et provient du mot "localisation". Combinées ensemble, les méthodes I18N/L10N, les protocoles, et les applications conformes permettent aux utilisateurs d’utiliser la langue de leur choix.</p></div><div class=paragraph><p>Les applications I18N sont programmées en utilisant des kits I18N par dessous les bibliothèques. Cela permet aux développeurs d’écrire un simple fichier et traduire les menus et textes affichés dans chaque langue. Nous encourageons fortement les programmeurs à suivre cette convention.</p></div></div><div class=sect3><h4 id=_pourquoi_devrais_je_employer_li18nl10n>25.2.2. Pourquoi devrais-je employer l’I18N/L10N?<a class=anchor href=#_pourquoi_devrais_je_employer_li18nl10n></a></h4><div class=paragraph><p>I18N/L10N est utilisé à chaque fois que vous désirez afficher, entrer, ou traiter des données dans des langues autres que l’anglais.</p></div></div><div class=sect3><h4 id=_quelles_sont_les_langues_supportées_par_li18n>25.2.3. Quelles sont les langues supportées par l’I18N?<a class=anchor href=#_quelles_sont_les_langues_supportées_par_li18n></a></h4><div class=paragraph><p>I18N et L10N ne sont pas spécifiques à FreeBSD. Actuellement, on peut choisir parmi la plupart des langues principales du monde, y compris mais pas seulement: le chinois, l’allemand, le japonais, le coréen, le français, le russe, le vietnamien et d’autres.</p></div></div></div><div class=sect2><h3 id=using-localization>25.3. Utiliser la localisation<a class=anchor href=#using-localization></a></h3><div class=paragraph><p>Dans toute sa splendeur, I18N n’est pas spécifique à FreeBSD et est une convention. Nous vous encourageons à aider FreeBSD à suivre cette convention.</p></div><div class=paragraph><p>Le paramétrage des "locales" est basé sur trois termes principaux: le code de la langue, le code du pays, et le codage des caractères. Les noms de "locales" sont construits à partir de ces trois éléments comme suit:</p></div><div class="literalblock programlisting"><div class=content><pre>CodeLangue_CodePays.CodageCaractères</pre></div></div><div class=sect3><h4 id=_codage_de_la_langue_et_du_pays>25.3.1. Codage de la langue et du pays<a class=anchor href=#_codage_de_la_langue_et_du_pays></a></h4><div class=paragraph><p>Afin de localiser un système FreeBSD pour une langue spécifique (ou tout autre UNIX® supportant l’I18N), l’utilisateur doit déterminer les codes spécifiques pour le pays et la langue (les codes pays indiquent aux applications quelle variation d’une langue donnée utiliser). De plus, les navigateurs Web, les serveurs SMTP/POP, les serveurs Web…​ agissent en fonction de ces codes. Ce qui suit est un exemple de codes langue/pays:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Code langue/pays</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>en_US</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Anglais - Etats Unis</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ru_RU</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Russe pour la Russie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>zh_TW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Chinois traditionnel pour Taiwan</p></td></tr></tbody></table></div><div class=sect3><h4 id=_codage_des_caractères>25.3.2. Codage des caractères<a class=anchor href=#_codage_des_caractères></a></h4><div class=paragraph><p>Certaines langues utilisent les codages non-ASCII sur 8 bits ou codent des caractères sur plusieurs octets, voir <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a> pour plus de détails. Les vieilles applications ne les reconnaissent pas ou les remplacent à tord par des caractères de contrôle. Les applications récentes reconnaissent normalement les caractères 8 bits. En fonction de l’implémentation, les utilisateurs devront peut être compiler une application avec le support des caractères sur 8 bits ou multi-octets, ou la configurer correctement. Afin d’accepter l’usage et le traitement de tels caractères, le <a href=https://www.FreeBSD.org/ports/>catalogue des logiciels portés de FreeBSD</a> fournit pour certains programmes une version dans chaque langue. Référez-vous à la documentation I18N de chaque logiciel porté respectif.</p></div><div class=paragraph><p>Spécifiquement, l’utilisateur doit consulter la documentation de l’application pour décider de comment la configurer correctement ou comment passer les valeurs correctes à la procédure configure, au <span class=filename>Makefile</span> ou au compilateur.</p></div><div class=paragraph><p>Quelques éléments à garder à l’esprit sont:</p></div><div class=ulist><ul><li><p>Les jeux de caractères au codage simple des caractères de la bibliothèque C (voir <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a>), par exemple ISO8859-1, ISO8859-15, KOI8-R, et CP437.</p></li><li><p>Les codages étendus ou multi-octets, e.g. EUC, Big5.</p></li></ul></div><div class=paragraph><p>Vous pouvez contrôler la liste des jeux de caractères actuellement actifs dans le <a href=http://www.iana.org/assignments/character-sets>registre de l’IANA</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD utilise à la place un codage des "locales" compatible avec X11.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_applications_i18n>25.3.3. Applications I18N<a class=anchor href=#_applications_i18n></a></h4><div class=paragraph><p>Dans le système de logiciels portés et pré-compilés de FreeBSD, les applications I18N ont été nommées avec <code>I18N</code> dans leur nom pour une identification aisée. Cependant, elles ne supportent pas toujours la langue désirée.</p></div></div><div class=sect3><h4 id=setting-locale>25.3.4. Configurer les "locales"<a class=anchor href=#setting-locale></a></h4><div class=paragraph><p>Généralement il est suffisant d’exporter le nom de la "locale" grâce à la variable <code>LANG</code> sous l’interpréteur de commandes utilisé lors de la session. Cela pourra être fait dans le fichier <span class=filename>~/.login_conf</span> de l’utilisateur ou le fichier de configuration de l’interpréteur de commandes de l’utilisateur (<span class=filename>~/.profile</span>, <span class=filename>~/.bashrc</span>, <span class=filename>~/.cshrc</span>). Il n’est pas nécessaire de configurer toutes les autres variables de localisation comme <code>LC_CTYPE</code>, <code>LC_CTIME</code>. Veuillez consulter la documentation de FreeBSD spécifique à votre langue pour plus d’informations.</p></div><div class=paragraph><p>Vous devrez configurer les deux variables d’environnement suivantes dans vos fichiers de configuration:</p></div><div class=ulist><ul><li><p><code>LANG</code> pour la famille de fonctions POSIX® <a href="https://man.freebsd.org/cgi/man.cgi?query=setlocale&amp;sektion=3&amp;format=html">setlocale(3)</a></p></li><li><p><code>MM_CHARSET</code> pour le jeu de caractères MIME des applications</p></li></ul></div><div class=paragraph><p>Cela comprend la configuration de l’interpréteur de commandes, la configuration spécifique des applications, et celle de X11.</p></div><div class=sect4><h5 id=_méthodes_de_configuration_des_locales>25.3.4.1. Méthodes de configuration des "locales"<a class=anchor href=#_méthodes_de_configuration_des_locales></a></h5><div class=paragraph><p>Il existe deux méthodes pour configurer les "locales", elles sont décrites ci-dessous. La première (celle qui est recommandée) est d’assigner les variables d’environnement dans une <a href=#login-class>classe de session</a>, et la seconde est d’ajouter le paramétrage des variables d’environnement dans les <a href=#startup-file>fichiers d’initialisation</a> de l’interpréteur de commandes du système.</p></div><div class=sect5><h6 id=login-class>25.3.4.1.1. Méthode utilisant les classes de session utilisateur<a class=anchor href=#login-class></a></h6><div class=paragraph><p>Cette méthode permet d’assigner une fois pour toute les variables d’environnement nécessaires pour le nom des "locales" et le jeu de caractères MIME et cela pour toutes les sessions au lieu de le faire à chaque nouvelle session par l’intermédiaire de la configuration des fichiers d’initialisation de l’interpréteur de commandes. La <a href=#usr-setup>configuration au niveau utilisateur</a> peut être faite par l’utilisateur lui-même et la <a href=#adm-setup>configuration au niveau administrateur</a> demande les privilèges de super-utilisateur.</p></div><div class=sect6><h7 id=usr-setup>25.3.4.1.1.1. Configuration au niveau utilisateur<a class=anchor href=#usr-setup></a></h7><div class=paragraph><p>Voici un exemple minimal d’un fichier <span class=filename>.login_conf</span> dans le répertoire personnel d’un utilisateur, fichier qui a les deux variables fixées pour le codage Latin-1:</p></div><div class="literalblock programlisting"><div class=content><pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre></div></div><div class=paragraph><p>Voici un exemple de fichier <span class=filename>.login_conf</span> qui fixe les variables pour le chinois traditionnel dans le codage BIG-5. Notez les nombreuses variables supplémentaires paramétrées parce que certains logiciels ne respectent pas les variables des "locales" correctement pour le chinois, le japonais, et le coréen.</p></div><div class="literalblock programlisting"><div class=content><pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:setenv=LC_ALL=zh_TW.Big:\
	:setenv=LC_COLLATE=zh_TW.Big5:\
	:setenv=LC_CTYPE=zh_TW.Big5:\
	:setenv=LC_MESSAGES=zh_TW.Big5:\
	:setenv=LC_MONETARY=zh_TW.Big5:\
	:setenv=LC_NUMERIC=zh_TW.Big5:\
	:setenv=LC_TIME=zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=gcin&#34;: #Set gcin as the XIM Input Server</pre></div></div><div class=paragraph><p>Voir la <a href=#adm-setup>configuration au niveau administrateur</a> et la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> pour plus de détails.</p></div></div></div><div class=sect5><h6 id=adm-setup>25.3.4.1.2. Configuration au niveau administrateur<a class=anchor href=#adm-setup></a></h6><div class=paragraph><p>Vérifiez que que la classe de session d’utilisateur dans <span class=filename>/etc/login.conf</span> fixe la bonne langue. Soyez sûr que ces paramètres apparaissent dans <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nom_langue:intitulé_comptes:\
	:charset=jeu_caractères_MIME:\
	:lang=nom_locale:\
	:tc=default:</pre></div></div><div class=paragraph><p>Donc si l’on reste sur notre exemple précédent utilisant le Latin-1, cela donnera quelque chose comme:</p></div><div class="literalblock programlisting"><div class=content><pre>german:German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre></div></div><div class=paragraph><p>Avant de modifier les classes de session des utilisateurs, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class=paragraph><p>pour rendre visible à l’intégralité du système la nouvelle configuration du fichier <span class=filename>/etc/login.conf</span>.</p></div></div><div class=sect5><h6 id=_modifier_les_classes_de_session_avec_vipw8>25.3.4.1.3. Modifier les classes de session avec <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a><a class=anchor href=#_modifier_les_classes_de_session_avec_vipw8></a></h6><div class=paragraph><p>Utilisez <code>vipw</code> pour ajouter de nouveaux utilisateurs, et créer une entrée ressemblant à celle-ci:</p></div><div class="literalblock programlisting"><div class=content><pre>utilisateur:mot_de_passe:1111:11:langue:0:0:Nom d&#39;utilisateur:/home/utilisateur:/bin/sh</pre></div></div></div><div class=sect5><h6 id=_modifier_les_classes_de_session_avec_adduser8>25.3.4.1.4. Modifier les classes de session avec <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a><a class=anchor href=#_modifier_les_classes_de_session_avec_adduser8></a></h6><div class=paragraph><p>Utilisez <code>adduser</code> pour ajouter de nouveaux utilisateurs, et faites ce qui suit:</p></div><div class=ulist><ul><li><p>Paramétrez <code>defaultclass = langue</code> dans <span class=filename>/etc/adduser.conf</span>. Gardez à l’esprit que vous devez dans ce cas entrer une classe par <code>default</code> (défaut) pour tous les utilisateurs d’autres langues.</p></li><li><p>Une variante est d’entrer la langue spécifiée à chaque fois que <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> affiche</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter login class: default <span class=o>[]</span>:</code></pre></div></div></li><li><p>Une autre alternative est d’employer ce qui suit pour chaque utilisateur de langue différente que vous désirez ajouter:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -class langue</span></code></pre></div></div></li></ul></div></div><div class=sect5><h6 id=_modifier_les_classes_de_session_avec_pw8>25.3.4.1.5. Modifier les classes de session avec <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a><a class=anchor href=#_modifier_les_classes_de_session_avec_pw8></a></h6><div class=paragraph><p>Si vous utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> pour ajouter de nouveaux utilisateurs, appelez la fonction de cette manière:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd nom_utilisateur -L langue</span></code></pre></div></div></div><div class=sect5><h6 id=startup-file>25.3.4.1.6. Méthode utilisant les fichiers d’initialisation de l’interpréteur de commandes<a class=anchor href=#startup-file></a></h6><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cette méthode n’est pas recommandée parce qu’elle demande une configuration différente pour chaque interpréteur de commandes choisi. Utilisez la <a href=#login-class>méthode utilisant les classes de session utilisateur</a> à la place.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour ajouter le nom de la "locale" et le jeu de caractère MIME, positionnez juste les deux variables d’environnement comme montré ci-dessous dans les fichiers d’initialisation de l’interpréteur de commandes <span class=filename>/etc/profile</span> et/ou <span class=filename>/etc/csh.login</span>. Nous utiliserons la langue allemande comme exemple ci-dessous:</p></div><div class=paragraph><p>Dans <span class=filename>/etc/profile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre></div></div><div class=paragraph><p>Ou dans <span class=filename>/etc/csh.login</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre></div></div><div class=paragraph><p>Alternativement, vous pouvez ajouter les instructions précédentes à <span class=filename>/usr/shared/skel/dot.profile</span> (similaire à ce qui fut utilisé dans <span class=filename>/etc/profile</span> ci-dessus), ou <span class=filename>/usr/shared/skel/dot.login</span> (similaire à ce qui fut utilisé dans <span class=filename>/etc/csh.login</span> ci-dessus).</p></div><div class=paragraph><p>Pour X11:</p></div><div class=paragraph><p>Dans <span class=filename>$HOME/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG</pre></div></div><div class=paragraph><p>Ou:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1</pre></div></div><div class=paragraph><p>En fonction de votre interpréteur de commandes (vois ci-dessus).</p></div></div></div></div><div class=sect3><h4 id=setting-console>25.3.5. Configuration de la console<a class=anchor href=#setting-console></a></h4><div class=paragraph><p>Pour tous les ensembles de jeu de caractères utilisés par la bibliothèque C, positionnez les bonnes polices de caractères pour la console dans <span class=filename>/etc/rc.conf</span> pour la langue en question avec:</p></div><div class="literalblock programlisting"><div class=content><pre>font8x16=nom_police
font8x14=nom_police
font8x8=nom_police</pre></div></div><div class=paragraph><p>Le <em>nom_police</em> provient ici du répertoire <span class=filename>/usr/shared/syscons/fonts</span>, sans le suffixe <span class=filename>.fnt</span>.</p></div><div class=paragraph><p>Vérifiez également que vous avez paramétré les bonnes tables de clavier et de correspondance d’affichage pour votre jeu de caractères C par l’intermédiaire de <code>sysinstall</code> (<span class=filename>/stand/sysinstall</span> sous les versions de FreeBSD antérieures à la 5.2). Une fois dans sysinstall, sélectionnez <span class=guimenuitem>Configure</span>, puis <span class=guimenuitem>Console</span>. Alternativement, vous pouvez ajouter ce qui suit au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>scrnmap=table_correspondance_affichage
keymap=nom_table_clavier
keychange=&#34;numéro_touche_fonction séquence&#34;</pre></div></div><div class=paragraph><p>La <em>table_correspondance_affichage</em> ici provient du répertoire <span class=filename>/usr/shared/syscons/scrnmaps</span> sans le suffixe <span class=filename>.scm</span>. Une table de correspondance d’affichage avec une police de correspondance est généralement nécessaire pour passer de 8 à 9 bits la matrice de caractère d’une carte VGA dans une zone pseudo-graphique, i.e., déplacer les lettres en dehors de cette zone si la police d’écran utilise une colonne de 8 bits.</p></div><div class=paragraph><p>Si vous avez le "daemon" moused activé par défaut grâce à la ligne suivante dans votre <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>moused_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>alors lisez les informations sur le curseur de souris dans le paragraphe suivant.</p></div><div class=paragraph><p>Par défaut le curseur du pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> de la console occupe la zone d’adresses 0xd0-0xd3 dans le jeu de caractères. Si votre langue utilise cette zone, vous devez déplacer la zone du curseur en dehors. Pour effectuer cela sous FreeBSD, ajoutez la ligne suivante dans <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div><div class=paragraph><p>Le <em>nom_table_clavier</em> provient ici du répertoire <span class=filename>/usr/shared/syscons/keymaps</span> sans le suffixe <span class=filename>.kbd</span>. Si vous n’êtes pas sûr de la table de clavier à utiliser, vous pouvez employer <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a> pour tester la table sans avoir à redémarrer.</p></div><div class=paragraph><p>Le <code>keychange</code> est généralement utilisé pour programmer les touches de fonction pour correspondre avec le type de terminal sélectionné parce que les séquences de touches de fonction ne peuvent être définies dans la table de clavier.</p></div><div class=paragraph><p>Soyez également sûr de configurer le type de console correct dans le fichier <span class=filename>/etc/ttys</span> pour toutes les entrées <code>ttyv*</code>. Les correspondances actuellement pré-définies sont:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Jeu de caractères</th><th class="tableblock halign-left valign-top">Type de terminal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-1 ou ISO8859-15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l7</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25r</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25u</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CP437 (jeu de caractères VGA par défaut)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>US-ASCII</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25w</code></p></td></tr></tbody></table><div class=paragraph><p>Pour les langues au caractères étendus ou multi-octets, utilisez le logiciel porté adéquat de votre répertoire <span class=filename>/usr/ports/langue</span>. Certains logiciels apparaissent comme utilisant la console alors que le système lui voit un vtty série, par conséquent vous devez réserver suffisamment de vttys pour X11 et la console pseudo-série. Voici une liste partielle des applications pour utiliser d’autres langues sous la console:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Langue</th><th class="tableblock halign-left valign-top">Emplacement</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinois traditionnel (BIG-5)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/big5con/>chinese/big5con</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonais</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-16dot/>japanese/kon2-16dot</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/japanese/mule_freewnn/>japanese/mule_freewnn</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Coréen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/han/>korean/han</a></p></td></tr></tbody></table></div><div class=sect3><h4 id=_configuration_dx11>25.3.6. Configuration d’X11<a class=anchor href=#_configuration_dx11></a></h4><div class=paragraph><p>Bien qu’X11 ne fasse pas partie du projet FreeBSD, nous avons inclus quelques éléments d’informations ici pour les utilisateurs de FreeBSD. Pour plus de détails, référez-vous au <a href=http://www.x.org/>site Web d’Xorg</a> ou à celui du serveur X11 que vous utilisez.</p></div><div class=paragraph><p>Dans le fichier <span class=filename>~/.Xresources</span>, vous pouvez en plus adapter les paramètres I18N spécifiques des applications (e.g., polices de caractères, menus, etc…​).</p></div><div class=sect4><h5 id=_affichage_des_polices_de_caractères>25.3.6.1. Affichage des polices de caractères<a class=anchor href=#_affichage_des_polices_de_caractères></a></h5><div class=paragraph><p>Installez le serveur Xorg (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-servers/xorg-server/>x11-servers/xorg-server</a>) ou le serveur XFree86™ (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-servers/XFree86-4-Server/>x11-servers/XFree86-4-Server</a>), puis installez les polices de caractères TrueType® de la langue concernée. Un paramétrage correct des "locales" devrait vous permettre de visualiser les menus dans la langue que vous avez choisie etc.</p></div></div><div class=sect4><h5 id=_saisie_de_caractères_non_anglais>25.3.6.2. Saisie de caractères non-anglais<a class=anchor href=#_saisie_de_caractères_non_anglais></a></h5><div class=paragraph><p>Le protocole "X11 Input Method" - méthode de saisie pour X11 (XIM) est un nouveau standard pour tous les clients X11. Toutes les applications X11 devraient être écrites en tant que clients XIM qui reçoivent les entrées de serveurs de saisie XIM. Il existe différents serveurs XIM disponibles pour différentes langues.</p></div></div></div><div class=sect3><h4 id=_configuration_de_limprimante>25.3.7. Configuration de l’imprimante<a class=anchor href=#_configuration_de_limprimante></a></h4><div class=paragraph><p>Certains jeux de caractères de la bibliothèque C sont généralement codés en dur dans les imprimantes. Les jeux de caractères étendus ou multi-octets demandent une configuration spéciale et nous recommandons d’utiliser apsfilter. Vous pouvez également convertir le document en format PostScript® ou PDF en utilisant des convertisseurs spécifiques à la langue.</p></div></div><div class=sect3><h4 id=_noyau_et_systèmes_de_fichiers>25.3.8. Noyau et systèmes de fichiers<a class=anchor href=#_noyau_et_systèmes_de_fichiers></a></h4><div class=paragraph><p>Le système de fichiers rapide de FreeBSD (FFS) est complètement sur 8 bits, et peut donc être utilisé avec n’importe quel jeu de caractères de la bibliothèque C (voir <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a>), mais il n’y a aucun jeu de caractères de stocké dans le système de fichiers; i.e., c’est du 8 bits brut et le système ne sait rien sur l’ordre du codage. Officiellement, le FFS ne supporte encore aucun jeu de caractères étendus ou multi-octets. Cependant, certains jeux de caractères étendus ou multi-octets disposent de correctifs indépendants pour FFS activant un tel support. Ce sont seulement des solutions temporaires non portables ou des "bidouilles" et nous avons décidé de ne pas les inclure dans l’arborescence des sources. Référez-vous aux sites Internet des langues respectives pour plus d’informations et pour les correctifs.</p></div><div class=paragraph><p>Le support FreeBSD du système fichiers MS-DOS® a la capacité paramétrable de faire la conversion entre jeux de caractères MS-DOS®, Unicode et les jeux de caractères choisis pour le système de fichiers FreeBSD. Voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> pour plus de détails.</p></div></div></div><div class=sect2><h3 id=l10n-compiling>25.4. Compiler des programmes I18N<a class=anchor href=#l10n-compiling></a></h3><div class=paragraph><p>De nombreux logiciels ont été portés pour FreeBSD avec le support I18N. Certains d’entre eux sont identifiés avec -I18N dans le nom du logiciel porté. Ces derniers et beaucoup d’autres programmes intègrent le support I18N et ne nécessitent aucune considération spéciale.</p></div><div class=paragraph><p>Cependant, certaines applications comme MySQL nécessitent d’avoir un fichier <span class=filename>Makefile</span> configuré avec le jeu de caractères spécifiques. Ceci est en général fait dans le <span class=filename>Makefile</span> ou effectué en passant une valeur à configure dans les sources.</p></div></div><div class=sect2><h3 id=lang-setup>25.5. Localiser FreeBSD pour des langues spécifiques<a class=anchor href=#lang-setup></a></h3><div class=sect3><h4 id=ru-localize>25.5.1. Russe (codage KOI8-R)<a class=anchor href=#ru-localize></a></h4><div class=paragraph><p>Pour plus d’informations sur le codage KOI8-R, consultez les <a href=http://koi8.pp.ru/>Références KOI8-R (Jeu de caractères russes pour Internet)</a>.</p></div><div class=sect4><h5 id=_configuration_des_locales>25.5.1.1. Configuration des "locales"<a class=anchor href=#_configuration_des_locales></a></h5><div class=paragraph><p>Ajoutez les lignes suivantes dans votre fichier <span class=filename>~/.login_conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>me:My Account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre></div></div><div class=paragraph><p>Voir plus haut dans ce chapitre pour des exemples de configuration des <a href=#setting-locale>"locales"</a>.</p></div></div><div class=sect4><h5 id=_configuration_de_la_console>25.5.1.2. Configuration de la console<a class=anchor href=#_configuration_de_la_console></a></h5><div class=ulist><ul><li><p>Ajoutez la ligne suivante à votre fichier <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div></li><li><p>Ajoutez également les paramétres suivants dans <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;</pre></div></div></li><li><p>Pour chaque entrée <code>ttyv*</code> dans <span class=filename>/etc/ttys</span>, utilisez <code>cons25r</code> comme type de terminal.</p></li></ul></div><div class=paragraph><p>Voir plus haut dans ce chapitre pour des exemples de configuration de la <a href=#setting-console>console</a>.</p></div></div><div class=sect4><h5 id=_configuration_de_limprimante_2>25.5.1.3. Configuration de l’imprimante<a class=anchor href=#_configuration_de_limprimante_2></a></h5><div class=paragraph><p>Comme la plupart des imprimantes avec un jeu de caractères russes ont un "code page" matériel CP866, un filtre de sortie spécial pour la conversion du KOI8-R vers le CP866 est nécessaire. Un tel filtre est installé par défaut sous <span class=filename>/usr/libexec/lpr/ru/koi2alt</span>. Une entrée de <span class=filename>/etc/printcap</span> pour imprimante russe devra ressembler à:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> pour plus de détails.</p></div></div><div class=sect4><h5 id=_système_de_fichiers_ms_dos_et_noms_de_fichiers_russes>25.5.1.4. Système de fichiers MS-DOS® et noms de fichiers russes<a class=anchor href=#_système_de_fichiers_ms_dos_et_noms_de_fichiers_russes></a></h5><div class=paragraph><p>L’exemple suivant d’entrée du fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> active le support des noms de fichiers russes sur les systèmes de fichiers MS-DOS® montés:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0s2      /dos/c  msdos   rw,-Wkoi2dos,-Lru_RU.KOI8-R 0 0</pre></div></div><div class=paragraph><p>L’option <code>-L</code> la "locale" utilisée, et <code>-W</code> fixe la table de conversion de caractères. Pour utiliser l’option <code>-W</code> assurez-vous de monter <span class=filename>/usr</span> avant la partition MS-DOS®, car en effet les tables de conversion sont situées dans le répertoire <span class=filename>/usr/libdata/msdosfs</span>. Pour plus d’informations, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>.</p></div></div><div class=sect4><h5 id=_configuration_de_x11>25.5.1.5. Configuration de X11<a class=anchor href=#_configuration_de_x11></a></h5><div class="olist arabic"><ol class=arabic><li><p>Effectuez tout d’abord la configuration des <a href=#setting-locale>"locales"</a> comme décrit plus haut dans ce chapitre.</p></li><li><p>Si vous utilisez Xorg, installez le paquetage <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/xorg-fonts-cyrillic/>x11-fonts/xorg-fonts-cyrillic</a>.</p><div class=paragraph><p>Contrôlez la section <code>"Files"</code> de votre fichier <span class=filename>/etc/X11/xorg.conf</span>. Les lignes suivantes doivent être ajoutées <em>avant</em> toute autre entrée <code>FontPath</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath   &#34;/usr/X11R6/lib/X11/fonts/cyrillic/misc&#34;
FontPath   &#34;/usr/X11R6/lib/X11/fonts/cyrillic/75dpi&#34;
FontPath   &#34;/usr/X11R6/lib/X11/fonts/cyrillic/100dpi&#34;</pre></div></div><div class=paragraph><p>Si vous utilisez un mode vidéo haute résolution, intervertissez les lignes 75 dpi et 100 dpi.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Consultez le catalogue des logiciels portés pour plus de fontes cyrilliques.</p></div></td></tr></tbody></table></div></li><li><p>Pour mettre en service un clavier russe, ajoutez ce qui suit à la section <code>"Keyboard"</code> de votre fichier <span class=filename>xorg.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre></div></div><div class=paragraph><p>Vérifiez également que <code>XkbDisable</code> est désactivé (mis en commentaire).</p></div><div class=paragraph><p>Pour l’option <code>grp:caps_toggle</code> le passage de russe à latin se fera par l’intermédiaire de <kbd>Right Alt</kbd>, pour <code>grp:ctrl_shift_toggle</code>, le passage se fera à l’aide de la séquence <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Shift</kbd></span>. L’ancienne fonctionnalitée de la touche <kbd>CapsLock</kbd> est toujours disponible via <span class=keyseq><kbd>Shift</kbd>+<kbd>CapsLock</kbd></span> (en mode latin uniquement). Pour l’option <code>grp:toggle</code> le passage du russe au latin se fera par l’intermédiaire de la touche <kbd>Right Alt</kbd>. L’option <code>grp:caps_toggle</code> ne fonctionne pas sous Xorg pour une raison inconnue.</p></div><div class=paragraph><p>Si vous disposez de touches "Windows®" sur votre clavier, et que vous constatez que certaines touches non-alphabétiques ne sont pas appariées correctement en mode russe, ajoutez la ligne suivante à votre fichier <span class=filename>xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le clavier russe XKB peut ne pas fonctionner avec des applications non localisées.</p></div></td></tr></tbody></table></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>localisées. Pour être un minimum localisée, une application devrait appeler la fonction <code>XtSetLanguageProc (NULL, NULL, NULL);</code> assez tôt dans le programme.</p></div><div class=paragraph><p>Consulter <a href=http://koi8.pp.ru/xwin.html>KOI8-R pour X Window</a> pour plus d’instructions sur la localisation des applications pour X11.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_localisation_du_chinois_traditionnel_pour_taiwan>25.5.2. Localisation du chinois traditionnel pour Taiwan<a class=anchor href=#_localisation_du_chinois_traditionnel_pour_taiwan></a></h4><div class=paragraph><p>Le projet FreeBSD taiwanais dispose d’un guide sur FreeBSD en chinois à l’adresse <a href=http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/>http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/</a> utilisant de nombreuses applications du répertoire <span class=filename>chinese</span> du catalogue des logiciels portés. Le rédacteur du guide sur FreeBSD en chinois est Shen Chuan-Hsing <a href=mailto:statue@freebsd.sinica.edu.tw>statue@freebsd.sinica.edu.tw</a>.</p></div><div class=paragraph><p>Chuan-Hsing Shen <a href=mailto:statue@freebsd.sinica.edu.tw>statue@freebsd.sinica.edu.tw</a> a créé la <a href=http://netlab.cse.yzu.edu.tw/~statue/cfc/>collection FreeBSD chinoise (CFC)</a> de logiciels en utilisant le document <code>zh-L10N-tut</code> taiwanais. Les logiciels pré-compilés et les fichiers de procédures sont disponibles à l’adresse <a href=ftp://freebsd.csie.nctu.edu.tw/pub/taiwan/CFC/>ftp://freebsd.csie.nctu.edu.tw/pub/taiwan/CFC/</a>.</p></div></div><div class=sect3><h4 id=_localisation_pour_la_langue_allemande_valable_également_pour_tous_les_langues_respectant_le_standard_iso_8859_1>25.5.3. Localisation pour la langue allemande (valable également pour tous les langues respectant le standard ISO 8859-1)<a class=anchor href=#_localisation_pour_la_langue_allemande_valable_également_pour_tous_les_langues_respectant_le_standard_iso_8859_1></a></h4><div class=paragraph><p>Slaven Rezic <a href=mailto:eserte@cs.tu-berlin.de>eserte@cs.tu-berlin.de</a> a rédigé un guide sur l’utilisation des "umlauts" sur une machine FreeBSD. Le guide est écrit en allemand et est disponible sur <a href=http://user.cs.tu-berlin.de/~eserte/FreeBSD/doc/umlaute/umlaute.html>http://user.cs.tu-berlin.de/~eserte/FreeBSD/doc/umlaute/umlaute.html</a>.</p></div></div><div class=sect3><h4 id=_localisation_pour_le_japonais_et_le_coréen>25.5.4. Localisation pour le japonais et le coréen<a class=anchor href=#_localisation_pour_le_japonais_et_le_coréen></a></h4><div class=paragraph><p>Pour le japonais, référez-vous à <a href=http://www.jp.FreeBSD.org/>http://www.jp.FreeBSD.org/</a>, et pour le coréen à <a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a>.</p></div></div><div class=sect3><h4 id=_documentation_freebsd_dans_dautres_langues_que_langlais>25.5.5. Documentation FreeBSD dans d’autres langues que l’anglais<a class=anchor href=#_documentation_freebsd_dans_dautres_langues_que_langlais></a></h4><div class=paragraph><p>Certains contributeurs à FreeBSD ont traduit des parties de la documentation FreeBSD dans d’autres langues. Les traductions sont disponibles grâce à des liens sur le <a href=https://www.FreeBSD.org/>site principal</a> ou dans <span class=filename>/usr/shared/doc</span>.</p></div></div></div></div></div><div class=sect1><h2 id=updating-upgrading>Chapitre 26. Mise à jour de FreeBSD<a class=anchor href=#updating-upgrading></a></h2><div class=sectionbody><div class=sect2><h3 id=updating-upgrading-synopsis>26.1. Synopsis<a class=anchor href=#updating-upgrading-synopsis></a></h3><div class=paragraph><p>FreeBSD est en constant développement entre deux versions. Certains utilisateurs préfèrent utiliser les versions publiées officiellement alors que d’autres voudront rester à jour avec les tous derniers développements. Mêmes les versions officielles sont souvent mises à jour avec les correctifs de problèmes critiques et de sécurité. Indépendamment de la version utilisée, FreeBSD fournit tous les outils nécessaires à la mise à jour de votre système, et permet également des mises à jour aisées entre versions. Ce chapitre vous aidera à décider si vous voulez suivre les développements, ou vous en tenir aux versions publiées. Les outils de base pour le maintien à jour de votre système seront également présentés.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Quels utilitaires peuvent être employés pour mettre à jour le système et le catalogue des logiciels portés.</p></li><li><p>Comment maintenir votre système à jour avec freebsd-update, CVSup, CVS, ou CTM.</p></li><li><p>Comment comparer l’état d’un système installé avec une copie de confiance.</p></li><li><p>La différence entre les deux branches de développement: FreeBSD-STABLE et FreeBSD-CURRENT.</p></li><li><p>Comment recompiler et réinstaller l’intégralité du système de base avec la commande <code>make buildworld</code> (etc.).</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Correctement configurer votre connexion réseau (<a href=./#advanced-networking>Administration réseau avancée</a>).</p></li><li><p>Savoir comment installer des logiciels tiers (<a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Tout au long de ce chapitre, la commande <code>cvsup</code> sera utilisée pour récupérer et mettre à jour les sources de FreeBSD. Pour l’utiliser, vous devrez installer un logiciel porté ou pré-compilé tel que <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup-without-gui/>net/cvsup-without-gui</a>. Si vous utilisez FreeBSD 6.2-RELEASE ou une version ultérieure, vous pouvez remplacer cette commande par <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a>, qui fait désormais partie du système de base.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=updating-upgrading-freebsdupdate>26.2. Mise à jour de FreeBSD<a class=anchor href=#updating-upgrading-freebsdupdate></a></h3><div class=paragraph><p>Appliquer des correctifs de sécurité est une part importante de la maintenance de logiciels informatiques tout particulièrement dans le cas du système d’exploitation. Pendant très longtemps sous FreeBSD, ce processus n’était pas aisé. Les correctifs devaient être appliqués au code source, le code ensuite recompilé sous forme de binaires, et enfin les binaires devaient être ré-installés.</p></div><div class=paragraph><p>Ce processus n’est plus de mise comme FreeBSD dispose désormais d’un utilitaire appelé simplement <code>freebsd-update</code>. Cet utilitaire fournit deux fonctions distinctes. Tout d’abord, il permet l’application de mises à jour de correction et de sécurité sur le système de base de FreeBSD sans nécessiter une compilation et une ré-installation. En second lieu, l’utilitaire supporte les mises à jour mineures et majeures des versions publiées.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les mise à jour binaires sont disponibles pour toutes les architectures actuellement supportées par l’équipe de sécurité. Avant de mettre à jour vers une nouvelle version, les annonces concernant la version devront être passées en revue sachant qu’elles peuvent contenir des informations importantes au sujet de cette version. Ces annonces peuvent être consultées à l’adresse suivante: <a href=http://www.FreeBSD.org/releases/>http://www.FreeBSD.org/releases/</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>S’il existe une table <code>crontab</code> utilisant <code>freebsd-update</code>, elle doit être désactivée avant de démarrer les opérations qui vont suivre.</p></div><div class=sect3><h4 id=freebsdupdate-config-file>26.2.1. Le fichier de configuration<a class=anchor href=#freebsdupdate-config-file></a></h4><div class=paragraph><p>Certains utilisateurs peuvent souhaiter adapter le fichier de configuration par défaut <span class=filename>/etc/freebsd-update.conf</span>, permettant un meilleur contrôle du processus. Les options sont très bien documentées, mais les suivantes demandent un peu plus d’explication:</p></div><div class="literalblock programlisting"><div class=content><pre># Composants du système de base qui doivent être maintenus à jour.
Components src world kernel</pre></div></div><div class=paragraph><p>Ce paramètre contrôle quelles sont les parties de FreeBSD qui seront mises à jour. Par défaut on met à jour le code source, l’intégralité du système de base et le noyau. Les composants sont les mêmes que ceux disponibles durant l’installation, par exemple, ajouter <code>world/games</code> ici permettrait d’appliquer les correctifs relatifs aux jeux. Utiliser <code>src/bin</code> permettrait la mise à jour du code source du répertoire <span class=filename>src/bin</span>.</p></div><div class=paragraph><p>La meilleure option est de laisser telle quelle la configuration par défaut car la modifier pour ajouter des éléments particuliers demandera à l’utilisateur de lister chaque élément qu’il désire mettre à jour. Cela pourrait avoir des conséquences désastreuses puisque le code source et les binaires peuvent à terme ne plus être en phase.</p></div><div class="literalblock programlisting"><div class=content><pre># Les chemins d&#39;accès commençant par quelque chose correspondant à une
# entrée de type IgnorePaths seront ignorés.
IgnorePaths</pre></div></div><div class=paragraph><p>Ajoute les chemins d’accès comme <span class=filename>/bin</span> ou <span class=filename>/sbin</span> pour préserver intacts ces répertoires durant le processus de mise à jour. Cette option peut être utilisée pour empêcher <code>freebsd-update</code> d’écraser des modifications locales.</p></div><div class="literalblock programlisting"><div class=content><pre># Les chemins d&#39;accès qui commencent par quelque chose correspondant à
# une entrée de type UpdateIfUnmodified seront mis à jour que si le
# contenu du fichier n&#39;a pas été modifié par l&#39;utilisateur (à moins
# que les modifications ne soient fusionnées; voir plus bas).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</pre></div></div><div class=paragraph><p>Met à jour les fichiers de configuration dans les répertoires désignés seulement s’ils n’ont pas été modifiés. Tout changement effectué par l’utilisateur invalidera automatiquement la mise à jour de ces fichiers. Il existe une autre option <code>KeepModifiedMetadata</code> qui indiquera à <code>freebsd-update</code> de sauvegarder les changements durant la fusion.</p></div><div class="literalblock programlisting"><div class=content><pre># Quand on met à jour vers une nouvelle version de FreeBSD, les fichiers
# correspondant à une entrée de type MergeChanges verront leurs
# différences locales fusionnées avec le fichier de la nouvelle
# version de FreeBSD.
MergeChanges /etc/ /var/named/etc/</pre></div></div><div class=paragraph><p>Liste des répertoires avec des fichiers de configuration que <code>freebsd-update</code> devrait tenter de fusionner. Le processus de fusion des fichiers est l’application d’une série de correctifs <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> similaires à ceux de <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> avec cependant moins d’options, les fusions sont soit acceptées, ouvrant un éditeur, soit abandonnées par <code>freebsd-update</code>. En cas de doute, sauvegardez <span class=filename>/etc</span> et acceptez les fusions. Consultez la section sur <a href=#mergemaster><code>mergemaster</code></a> pour plus d’information sur la commande <code>mergemaster</code>.</p></div><div class="literalblock programlisting"><div class=content><pre># Répertoire dans lequel stocker les mise à jour téléchargées et les
# fichiers temporaires utilisés par la mise à jour de FreeBSD.
# WorkDir /var/db/freebsd-update</pre></div></div><div class=paragraph><p>Ce répertoire est l’endroit où tous les correctifs et les fichiers temporaires seront placés. Dans les cas où l’utilisateur effectue une mise à jour de version, cet emplacement doit disposer d’au moins un gigaoctet d’espace disponible.</p></div><div class="literalblock programlisting"><div class=content><pre># Lors de mises à jour entre versions de FreeBSD, doit-on lire la liste
# de composants de manière stricte (StrictComponents yes)
# ou tout simplement comme une liste de composants qui *pourraient*
# être installés et pour lesquels la mise à jour de FreeBSD devrait
# déterminer lesquels sont effectivement installés et les mettre à
# jour (StrictComponents no)?
# StrictComponents no</pre></div></div><div class=paragraph><p>Cette option fixée à <code>yes</code>, <code>freebsd-update</code> supposera que la liste de composants est complète et n’essaiera pas d’effectuer des modifications en dehors de cette liste. Concrètement, <code>freebsd-update</code> tentera de mettre à jour chaque fichier appartenant à la liste de composants.</p></div></div><div class=sect3><h4 id=freebsdupdate-security-patches>26.2.2. Correctifs de sécurité<a class=anchor href=#freebsdupdate-security-patches></a></h4><div class=paragraph><p>Les correctifs de sécurité sont stockés sur une machine distante et peuvent être téléchargés et installés en utilisant la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update fetch</span>
<span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Si des correctifs ont été appliqués au noyau le système devra être redémarré. Si tout s’est bien passé le système est corrigé et <code>freebsd-update</code> pourra être exécuté chaque nuit via un processus <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. Une entrée dans le fichier <span class=filename>/etc/crontab</span> devrait être suffisante pour accomplir cette tâche:</p></div><div class="literalblock programlisting"><div class=content><pre>@daily                                  root    freebsd-update cron</pre></div></div><div class=paragraph><p>Cette entrée indique qu’une fois par jour, l’utilitaire <code>freebsd-update</code> sera exécuté. De cette manière, en employant l’option <code>cron</code>, <code>freebsd-update</code> vérifiera seulement l’existence de mises à jour. Si des correctifs existent, il seront automatiquement téléchargés sur le disque local mais non-appliqués. L’utilisateur <code>root</code> sera contacté par courrier électronique, il pourra ainsi les installer manuellement.</p></div><div class=paragraph><p>Si quelque s’est mal passé, <code>freebsd-update</code> a la capacité d’annuler le dernier ensemble de changements avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update rollback</span></code></pre></div></div><div class=paragraph><p>Une fois la commande achevée, le système devra être redémarré si le noyau ou un de ses modules ont été modifiés. Cela permettra à FreeBSD de charger en mémoire les nouveaux binaires.</p></div><div class=paragraph><p>L’utilitaire <code>freebsd-update</code> peut mettre à jour uniquement et automatiquement le noyau <code>GENERIC</code>. Si un noyau personnalisé est utilisé, il devra être recompilé et réinstallé après que la commande <code>freebsd-update</code> ait achevé l’installation du reste des mises à jour. Cependant <code>freebsd-update</code> détectera et mettra à jour le noyau <code>GENERIC</code> dans <span class=filename>/boot/GENERIC</span> (s’il existe), et cela même si ce n’est pas le noyau actuel (qui tourne) du système.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>C’est toujours une bonne idée de conserver une copie du noyau <code>GENERIC</code> dans <span class=filename>/boot/GENERIC</span>. Cela sera utile pour diagnostiquer une variété de problèmes, et lors des mises à jour utilisant <code>freebsd-update</code> comme décrit dans la <a href=#freebsdupdate-upgrade>Mises à jour mineures et majeures</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A moins que la configuration par défaut présente dans <span class=filename>/etc/freebsd-update.conf</span> n’ait été modifiée, <code>freebsd-update</code> installera les sources du noyau mises à jour avec le reste des mises à jour. La recompilation et la réinstallation d’un noyau personnalisé peuvent effectuées de la manière classique.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les mises à jour distribuées via <code>freebsd-update</code>, n’impliquent pas toujours le noyau. Il ne sera pas nécessaire de recompiler votre noyau personnalisé si les sources du noyau n’ont pas été modifiées par l’exécution de <code>freebsd-update install</code>. Cependant <code>freebsd-update</code> met toujours à jour le fichier <span class=filename>/usr/src/sys/conf/newvers.sh</span>. Le niveau ou la version de correctifs (comme indiqué par le nombre <code>-p</code> rapporté par <code>uname -r</code>) est obtenu à partir de ce fichier. Recompiler votre noyau personnalisé, même si rien d’autre n’a changé, permettra à la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> de rapporter précisément le niveau de correctifs du système. C’est particulièrement utile quand on gère de multiples systèmes, car cela permet une évaluation rapide des mises à jour présentes sur chacun d’eux.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=freebsdupdate-upgrade>26.2.3. Mises à jour mineures et majeures<a class=anchor href=#freebsdupdate-upgrade></a></h4><div class=paragraph><p>Ce processus supprimera les anciens fichiers objets et bibliothèques qui rendent inutilisables la plupart des applications tierce-partie. Il est recommandé que tous les logiciels portés soient supprimés et réinstallés ou mis à jour ultérieurement en utilisant l’outil <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a>. La plupart des utilisateurs voudront lancer une compilation test à l’aide de la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -af</span></code></pre></div></div><div class=paragraph><p>Cela garantira que tout sera réinstallé correctement. Notez que fixer la variable d’environnement <code>BATCH</code> à <code>yes</code> répondra <code>yes</code> à toute question lors de ce processus, supprimant ainsi la nécessité d’une intervention humaine durant le processus de compilation.</p></div><div class=paragraph><p>Si un noyau personnalisé est utilisé, le processus de mise à jour est un peu plus complexe. Une copie du noyau <code>GENERIC</code> est nécessaire et devrait être placée dans le répertoire <span class=filename>/boot/GENERIC</span>. Si le noyau <code>GENERIC</code> n’est pas présent sur le système, il peut être obtenu en utilisant une des méthodes suivantes:</p></div><div class=ulist><ul><li><p>Si un noyau personnalisé a déjà été compilé, le noyau présent dans <span class=filename>/boot/kernel.old</span> est en fait le noyau <code>GENERIC</code>. Renommer ce répertoire en <span class=filename>/boot/GENERIC</span>.</p></li><li><p>En supposant qu’un accès physique à la machine est possible, une copie du noyau <code>GENERIC</code> peut être installé à partir d’un CD-ROM. Insérer votre disque d’installation et utiliser les commandes suivantes:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cd /cdrom/X.Y-RELEASE/kernels</span>
<span class=c># ./install.sh GENERIC</span></code></pre></div></div><div class=paragraph><p>Remplacer <span class=filename>X.Y-RELEASE</span> avec la version que vous utilisez. Le noyau <code>GENERIC</code> sera installé par défaut dans <span class=filename>/boot/GENERIC</span>.</p></div></li><li><p>En dehors de ce qui précède le noyau <code>GENERIC</code> peut être recompilé et installé à partir des sources:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># env DESTDIR=/boot/GENERIC make kernel</span>
<span class=c># mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</span>
<span class=c># rm -rf /boot/GENERIC/boot</span></code></pre></div></div><div class=paragraph><p>Pour que ce noyau soit pris en compte comme <code>GENERIC</code> par <code>freebsd-update</code>, le fichier de configuration <code>GENERIC</code> devra ne pas avoir été modifié. Il est également suggéré qu’il soit compilé sans aucune option particulière (de préférence avec un fichier <span class=filename>/etc/make.conf</span> vide).</p></div></li></ul></div><div class=paragraph><p>Redémarrer avec le noyau <code>GENERIC</code> n’est pas nécessaire à ce stade.</p></div><div class=paragraph><p>Les mises à jour de versions majeures et mineures peuvent être effectuées en passant à la commande <code>freebsd-update</code> la version vers laquelle on désire mettre à jour, par exemple, la commande suivante effectuera la mise à jour vers FreeBSD 8.1:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -r 8.1-RELEASE upgrade</span></code></pre></div></div><div class=paragraph><p>La commande <code>freebsd-update</code> analysera le fichier de configuration et le système afin de récupérer les informations nécessaires à la mise à jour du système. A l’écran s’affichera quels sont les composants détectés et quels sont ceux qui n’ont pas été détectés. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature <span class=k>for </span>8.0-RELEASE from update1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD <span class=k>do </span>not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable <span class=o>(</span>y/n<span class=o>)</span>? y</code></pre></div></div><div class=paragraph><p>A ce niveau <code>freebsd-update</code> tentera de télécharger tous les fichiers nécessaires à la mise à jour. Dans certains cas l’utilisateur sera interrogé sur ce qu’il faut installer ou sur comment procéder à certaines actions.</p></div><div class=paragraph><p>Si un noyau personnalisé est utilisé, l’étape précédente produira un avertissement semblable au suivant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>WARNING: This system is running a <span class=s2>&#34;MYKERNEL&#34;</span> kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running <span class=s2>&#34;/usr/sbin/freebsd-update install&#34;</span></code></pre></div></div><div class=paragraph><p>Cet avertissement peut sans risque être ignoré à ce niveau. Le noyau <span class=filename>GENERIC</span> mis à jour sera utilisé comme une étape intermédiaire dans le processus de mise à jour.</p></div><div class=paragraph><p>Une fois l’ensemble des correctifs téléchargé sur le système local, ils seront appliqués. Ce processus peut prendre plus ou moins de temps en fonction de la vitesse et de la charge de la machine. Les fichiers de configuration seront fusionnés - cette partie du processus demande l’intervention de l’utilisateur car un fichier peut être automatiquement fusionné ou en cas de besoin un éditeur peut apparaître sur l’écran pour une fusion manuelle. Les résultats des fusions réussies seront affichés au fur et à mesure que se déroule l’opération. Un échec ou une fusion ignorée provoqueront l’arrêt du processus. Certains utilisateurs peuvent vouloir conserver une sauvegarde du répertoire <span class=filename>/etc</span> et fusionner plus tard à la main les fichiers importants comme <span class=filename>master.passwd</span> ou <span class=filename>group</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le système n’a pas encore été réellement modifié, les fusions et l’application des correctifs ont lieu dans un autre répertoire. Quand tous les correctifs ont été appliqués avec succès, que tous les fichiers de configuration ont été fusionnés et que le processus s’est déroulé sans problème, les modifications devront être appliquées définitivement au système par l’utilisateur.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Une fois les opérations précédentes achevées, la mise à jour peut être appliquée en utilisant la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Le noyau et les modules seront corrigés les premiers. A ce moment la machine doit être obligatoirement redémarrée. Si le système utilisait un noyau personnalisé, utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=nextboot&amp;sektion=8&amp;format=html">nextboot(8)</a> pour indiquer le noyau <span class=filename>/boot/GENERIC</span> (qui a été mis à jour) pour le prochain démarrage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nextboot -k GENERIC</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Avant de redémarrer sur le noyau <code>GENERIC</code>, assurez-vous qu’il contient tous les pilotes nécessaires pour que votre système démarre correctement (et se connecte au réseau, si la mise à jour de la machine se fait à distance). En particulier, si le noyau précédemment utilisé contient des fonctions généralement fournies par des modules, faites en sorte de charger temporairement ces modules avec le noyau <span class=filename>GENERIC</span> à l’aide de <span class=filename>/boot/loader.conf</span>. Vous pouvez également avoir intérêt à désactiver les services non-indispensables, les montages réseaux ou disques, etc. avant que le processus de mise à jour ne soit achevé.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La machine doit maintenant être redémarrée avec le noyau mis à jour:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Une fois la machine de nouveau active, <code>freebsd-update</code> devra être lancée à nouveau. L’état du processus de mise à jour a été sauvegardé, et donc <code>freebsd-update</code> ne recommencera pas au début, mais supprimera les anciens fichiers objet et bibliothèques partagées. Afin de poursuivre les opérations, taper la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En fonction d’un changement ou non de numérotation d’une ou plusieurs bibliothèques, il pourra y avoir deux phases d’installation au lieu de trois.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Tous les logiciels tierce-partie doivent être maintenant recompilés et réinstallés. Cela est nécessaire comme certains logiciels peuvent dépendre de bibliothèques qui ont été supprimées lors du processus de mise à jour. La commande <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> peut être employée pour automatiser la chose. Les commandes suivantes peuvent être utilisées pour initier le processus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -f ruby</span>
<span class=c># rm /var/db/pkg/pkgdb.db</span>
<span class=c># portupgrade -f ruby18-bdb</span>
<span class=c># rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</span>
<span class=c># portupgrade -af</span></code></pre></div></div><div class=paragraph><p>Une fois cela effectué, terminer le processus de mise à jour avec un dernier appel à <code>freebsd-update</code>. Taper la commande suivante pour régler les derniers détails:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Si le noyau <code>GENERIC</code> a été utilisé temporairement, il est temps de compiler et d’installer un nouveau noyau personnalisé suivant la méthode habituelle.</p></div><div class=paragraph><p>Redémarrer la machine avec la nouvelle version de FreeBSD. Le processus de mise à jour est terminé.</p></div></div><div class=sect3><h4 id=freebsdupdate-system-comparison>26.2.4. Comparaison de l’état du système<a class=anchor href=#freebsdupdate-system-comparison></a></h4><div class=paragraph><p>L’utilitaire <code>freebsd-update</code> peut être utilisé pour comparer l’état du système FreeBSD installé avec une copie de confiance. Cette fonctionnalité inspecte la version actuelle des utilitaires système, des bibliothèques et des fichiers de configuration. Pour lancer la comparaison, utiliser la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update IDS &gt;&gt; outfile.ids</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Bien que le nom de la commande soit IDS, elle ne devrait en aucun cas être considérée comme un système de détection d’intrusion du type de <a class=package href=https://cgit.freebsd.org/ports/tree/security/snort/>security/snort</a>. Etant donné que <code>freebsd-update</code> stocke des données sur le disque, le risque de modification des données est évident. Alors que cette possibilité peut être minimisée en utilisant le paramétrage <code>kern.securelevel</code> et en stockant les données <code>freebsd-update</code> sur un système de fichiers en lecture seule quand elles ne sont pas utilisées, une bien meilleure solution serait de comparer le système avec un disque sécurisé comme un DVD ou un disque USB conservé à l’extérieur.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Le système sera analysé, et une liste de fichiers ainsi que la valeur de leur empreinte numérique <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a>, celle de la version d’origine et celle de la version actuellement installée, seront affichés. C’est pour cela que cet affichage est copié dans le fichier <span class=filename>outfile.ids</span>. L’affichage défile trop rapidement une comparaison visuelle et remplira rapidement le tampon de la console.</p></div><div class=paragraph><p>Ces lignes sont également très longues mais le format de sortie peut être facilement passé par une analyse syntaxique. Par exemple, pour obtenir une liste des fichiers qui diffèrent avec ceux de la version d’origine, utiliser la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat outfile.ids | awk &#39;{ print $1 }&#39; | more</span>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</code></pre></div></div><div class=paragraph><p>La sortie de cette commande a été tronquée, bien plus de fichiers sont concernés. Certains de ces fichiers sont naturellement modifiés, le fichier <span class=filename>/etc/passwd</span> a été modifié en raison de l’ajout d’utilisateurs au système. Dans certains cas, d’autres fichiers apparaîtrons, comme les modules du noyau, qui diffèrent puisque <code>freebsd-update</code> peut les avoir mis à jour. Pour exclure des fichiers ou des répertoires spécifiques, ajoutez-les au paramètre <code>IDSIgnorePaths</code> dans le fichier <span class=filename>/etc/freebsd-update.conf</span>.</p></div><div class=paragraph><p>Ce système peut prendre part à une méthode de mise à jour élaboré, en dehors de ce qui a été présenté précédemment.</p></div></div></div><div class=sect2><h3 id=updating-upgrading-portsnap>26.3. Portsnap: un outil de mise à jour du catalogue des logiciels portés<a class=anchor href=#updating-upgrading-portsnap></a></h3><div class=paragraph><p>Le système de base de FreeBSD dispose également d’un utilitaire pour la mise à jour du catalogue des logiciels portés: <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a>. Lors de son exécution, il se connectera sur un site distant, contrôlera la clé de sécurité et téléchargera une nouvelle copie du catalogue des logiciels portés. La clé est utilisée pour vérifier l’intégrité de tous les fichiers téléchargés, s’assurant qu’ils n’ont pas été modifiés au vol. Pour récupérer les tout derniers fichiers du catalogue des logiciels portés, utiliser la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching snapshot metadata... <span class=k>done</span><span class=nb>.</span>
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. <span class=k>done</span><span class=nb>.</span>
Applying metadata patches... <span class=k>done</span><span class=nb>.</span>
Fetching 3 metadata files... <span class=k>done</span><span class=nb>.</span>
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. <span class=k>done</span><span class=nb>.</span>
Applying patches... <span class=k>done</span><span class=nb>.</span>
Fetching 133 new ports or files... <span class=k>done</span>.</code></pre></div></div><div class=paragraph><p>Cet exemple nous montre que <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> a trouvé et contrôlé plusieurs mises à jour pour les données actuelles du catalogue. Est également indiqué si l’utilitaire a été précédemment exécuté, si cela avait été une première exécution, le catalogue aurait été tout simplement téléchargé.</p></div><div class=paragraph><p>Lorsque <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> termine avec succès une opération de récupération (<code>fetch</code>), le catalogue des logiciels portés et ses mises à jour sont présents sur le système. A la première exécution de <code>portsnap</code> vous devez utiliser la commande <code>extract</code> pour installer les fichiers téléchargés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
...</code></pre></div></div><div class=paragraph><p>Pour mettre à jour un catalogue des logiciels portés déjà installé utilisez la commande <code>portsnap update</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap update</span></code></pre></div></div><div class=paragraph><p>Le processus est maintenant terminé et les applications peuvent être installées ou mises à jour à l’aide du catalogue à jour.</p></div><div class=paragraph><p>Les opérations <code>fetch</code> et <code>extract</code> ou <code>update</code> peuvent être exécutées à la suite comme montré dans l’exemple suivant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch update</span></code></pre></div></div><div class=paragraph><p>Cette commande téléchargera la dernière version du catalogue des logiciels portés et mettra à jour votre version locale située dans <span class=filename>/usr/ports</span>.</p></div></div><div class=sect2><h3 id=updating-upgrading-documentation>26.4. Updating the Documentation Set <strong>Traduction en Cours </strong><a class=anchor href=#updating-upgrading-documentation></a></h3><div class=sect3><h4 id=updating-installed-documentation>26.4.1. Updating Documentation from Source<a class=anchor href=#updating-installed-documentation></a></h4></div><div class=sect3><h4 id=doc-ports-install-package>26.4.2. Updating Documentation from Ports<a class=anchor href=#doc-ports-install-package></a></h4></div></div><div class=sect2><h3 id=current-stable>26.5. Suivre une branche de développement<a class=anchor href=#current-stable></a></h3><div class=paragraph><p>Il existe deux branches de développement de FreeBSD: FreeBSD-CURRENT et FreeBSD-STABLE. Cette section détaillera un peu chacune d’elles et décrira comment garder à jour votre système avec chaque arborescence respective. FreeBSD-CURRENT sera tout d’abord traité, suivit de FreeBSD-STABLE.</p></div><div class=sect3><h4 id=current>26.5.1. Se synchroniser avec la version -CURRENT de FreeBSD<a class=anchor href=#current></a></h4><div class=paragraph><p>En lisant ces lignes, gardez à l’esprit que FreeBSD-CURRENT représente "les tout derniers" développement de FreeBSD. On attend des utilisateurs de FreeBSD-CURRENT un degré élevé de compétences techniques, et devraient être capables de résoudre des problèmes système compliqués par eux-mêmes. Si vous êtes nouveau à FreeBSD, pensez à deux fois avant de l’installer.</p></div><div class=sect4><h5 id=_quest_ce_que_freebsd_current>26.5.1.1. Qu’est-ce que FreeBSD-CURRENT?<a class=anchor href=#_quest_ce_que_freebsd_current></a></h5><div class=paragraph><p>FreeBSD-CURRENT est la toute dernière version des sources de FreeBSD en cours de développement. Cela inclut des évolutions en cours, des modifications expérimentales, et des mécanismes de transition qui feront ou ne feront pas partie de la prochaine version officielle du logiciel. Bien que de nombreux développeurs de FreeBSD compilent les sources de FreeBSD-CURRENT quotidiennement, il arrive que celles-ci ne soient pas compilables pendant une certaine période de temps. Ces problèmes sont résolus aussi rapidement que possible, mais que FreeBSD-CURRENT soit à l’origine d’un désastre ou de l’apport d’une nouvelle fonctionnalité attendue peut parfois dépendre que du moment auquel vous avez chargé le code source.</p></div></div><div class=sect4><h5 id=_qui_a_besoin_de_freebsd_current>26.5.1.2. Qui a besoin de FreeBSD-CURRENT?<a class=anchor href=#_qui_a_besoin_de_freebsd_current></a></h5><div class=paragraph><p>FreeBSD-CURRENT est mis à disposition pour 3 types de personnes:</p></div><div class="olist arabic"><ol class=arabic><li><p>Les membres de la communauté FreeBSD qui travaillent activement sur une partie de l’arborescence des sources et pour qui rester constamment à jour est une nécessité absolue.</p></li><li><p>Les membres de la communauté FreeBSD qui participent activement aux tests et sont disposés à passer du temps à résoudre les problèmes pour garantir que FreeBSD-CURRENT reste aussi saine que possible. Il y a également ceux qui désirent faire des suggestions dans certains domaines sur les modifications à faire et la direction générale que prend FreeBSD, et soumettent des correctifs pour les implémenter.</p></li><li><p>Ceux qui veulent simplement garder un oeil sur les évolutions, ou utiliser les dernières sources comme référence (e.g. pour les <em>lire</em>, et non pour les utiliser). Ces personnes font parfois des remarques ou contribuent au code.</p></li></ol></div></div><div class=sect4><h5 id=_quest_ce_que_nest_pas_freebsd_current>26.5.1.3. Qu’est-ce que <em>n’est pas</em> FreeBSD-CURRENT?<a class=anchor href=#_quest_ce_que_nest_pas_freebsd_current></a></h5><div class="olist arabic"><ol class=arabic><li><p>Un raccourci pour se procurer des pré-versions parce que vous avez entendu dire qu’il y a de nouvelles fonctionnalités géniales et que vous voulez être le premier du coin à les avoir. Etre le premier à avoir la nouvelle fonctionnalité signifie être le premier à avoir les nouveaux bogues également.</p></li><li><p>Une moyen rapide d’avoir des corrections de bogues. N’importe quelle version de FreeBSD-CURRENT apportera probablement de nouveaux bogues comme elle corrigera ceux déjà présents.</p></li><li><p>Nous ne le "supportons officiellement" en aucun cas. Nous faisons du mieux que nous pouvons pour aider les personnes qui font vraiment partie des trois groupes "légitimes" à qui s’adresse FreeBSD-CURRENT, mais nous n’avons tout simplement "pas le temps" de fournir un support technique. Ce n’est pas parce que nous sommes des personnes détestables qui n’aiment pas aider les autres (nous ne ferions pas FreeBSD si tel était le cas), nous ne pouvons simplement pas répondre à des centaines de messages par jour <em>et</em> travailler sur FreeBSD! Entre améliorer FreeBSD et répondre à de nombreuses questions sur le code expérimental, les développeurs optent pour le premier choix.</p></li></ol></div></div><div class=sect4><h5 id=_utiliser_freebsd_current>26.5.1.4. Utiliser FreeBSD-CURRENT<a class=anchor href=#_utiliser_freebsd_current></a></h5><div class="olist arabic"><ol class=arabic><li><p>Inscrivez-vous à la <a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a> et la <a href=https://lists.FreeBSD.org/subscription/svn-src-head>messages SVN de modification pour l’arbre pour head/-current</a>. Ce n’est pas seulement une bonne idée, c’est <em>indispensable</em>. Si vous n’êtes pas sur la liste <em><a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a></em>, vous ne verrez pas les commentaires qui sont faits sur l’état courant du système et vous vous retrouverez probablement confrontés à de nombreux problèmes que d’autres ont déjà identifiés et résolus. Encore plus grave, vous manqueriez des bulletins importants potentiellement critiques pour la bonne santé de votre système.</p><div class=paragraph><p>La liste <a href=https://lists.FreeBSD.org/subscription/svn-src-head>messages SVN de modification pour l’arbre pour head/-current</a> vous permettra de voir les courriers de trace des soumissions de toutes les modifications dès qu’elles sont faites et des informations pertinentes sur les éventuels effets de bord.</p></div><div class=paragraph><p>Pour vous inscrire à ces listes, ou à une autre, rendez vous à <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> et cliquez sur la liste à laquelle vous désirez vous inscrire. Des instructions sur le reste de la procédure sont alors données. Si vous êtes intéressé par le suivi des modifications appliquées à l’ensemble de l’arborescence des sources, nous vous recommandons de vous inscrire à <a href=https://lists.FreeBSD.org/subscription/svn-src-all>messages SVN de modification concernant l’intégrélité de l’arbre src (en dehors des arbres "user" et "projects")</a>.</p></div></li><li><p>Récupérez les sources sur un <a href=./#mirrors>site miroir</a> FreeBSD. Vous pouvez le faire de deux manières:</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Utilisez le programme <a href=./#cvsup>cvsup</a> avec le fichier <span class=filename>supfile</span> nommé <span class=filename>standard-supfile</span> disponible dans le répertoire <span class=filename>/usr/shared/examples/cvsup</span>. C’est la méthode recommandée, puisqu’elle permet de récupérer la totalité des sources la première fois et par la suite uniquement ce qui a été modifié. De nombreuses personnes exécutent <code>cvsup</code> depuis <code>cron</code> et maintiennent ainsi automatiquement à jour leurs sources. Vous devez personnaliser l’exemple de <span class=filename>supfile</span> précédent, et configurer <a href=./#cvsup>cvsup</a> pour votre environnement.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le fichier d’exemple <span class=filename>standard-supfile</span> est destiné au suivi d’une branche de sécurité FreeBSD spécifique et non pas à celui de FreeBSD-CURRENT. Vous devrez éditer ce fichier et remplacer la ligne suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>*default release=cvs tag=RELENG_X_Y</pre></div></div><div class=paragraph><p>Par celle-ci:</p></div><div class="literalblock programlisting"><div class=content><pre>*default release=cvs tag=.</pre></div></div><div class=paragraph><p>Pour une explication détaillée des étiquettes utilisables, veuillez vous référer à la section <a href=./#cvs-tags>Etiquettes CVS</a> de ce manuel.</p></div></td></tr></tbody></table></div></li><li><p>Utilisez CTM. Si vous disposez d’une mauvaise connexion (connexions chères ou seulement un accès au courrier électronique) CTM est une bonne solution. Cependant, c’est une source de problèmes et peut donner lieu à des fichiers endommagés. C’est pourquoi cette méthode est rarement utilisée, ce qui augmente les chances que cela ne fonctionne pas pendant d’assez longue périodes. Nous recommandons d’utiliser CVSup à tous ceux disposant d’un modem 9600 bps ou d’une connexion plus rapide.</p></li></ol></div></li><li><p>Si vous récupérez les sources pour compiler un système opérationnel, et pas simplement pour les lire, alors récupérez <em>tout</em> FreeBSD-CURRENT, et pas uniquement certaines portions. La raison de cela est que diverses parties des sources dépendent de modifications effectuées ailleurs, et si vous essayez de compiler juste une partie des source, il est quasiment certain que vous aurez des problèmes.</p></li><li><p>Avant de compiler FreeBSD-CURRENT, lisez attentivement le <span class=filename>Makefile</span> dans <span class=filename>/usr/src</span>. Vous devriez au moins la première fois <a href=#makeworld>installer un nouveau noyau et recompiler le système</a>, comme étape nécessaire à votre processus de mise à jour. La lecture de la <a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a> et du fichier <span class=filename>/usr/src/UPDATING</span> vous tiendra au courant des autres procédures de transition qui sont parfois nécessaires lorsque nous préparons la prochaine version.</p></li><li><p>Participez! Si vous utilisez FreeBSD-CURRENT, nous aimerions savoir ce que vous en pensez, tout particulièrement si vous avez des améliorations à nous suggérer ou des corrections de bogues à nous soumettre. Les suggestions accompagnées de code sont accueillies avec enthousiasme!</p></li></ol></div></div></div><div class=sect3><h4 id=stable>26.5.2. Se synchroniser avec la version -STABLE de FreeBSD<a class=anchor href=#stable></a></h4><div class=sect4><h5 id=_quest_ce_que_freebsd_stable>26.5.2.1. Qu’est-ce que FreeBSD-STABLE?<a class=anchor href=#_quest_ce_que_freebsd_stable></a></h5><div class=paragraph><p>FreeBSD-STABLE est notre branche de développement à partir de laquelle sont extraites les versions majeures. Les modifications sur cette branche se font à une allure différente, et en supposant généralement qu’elles ont été tout d’abord testées sur FreeBSD-CURRENT. Cela reste cependant <em>toujours</em> une branche de développement, et cela signifie qu’à certains moments, les sources de FreeBSD-STABLE pourront être ou pas utilisables pour une quelconque raison. C’est tout simplement une autre branche de mise au point, et non pas une ressource pour l’utilisateur final.</p></div></div><div class=sect4><h5 id=_qui_a_besoin_de_freebsd_stable>26.5.2.2. Qui a besoin de FreeBSD-STABLE?<a class=anchor href=#_qui_a_besoin_de_freebsd_stable></a></h5><div class=paragraph><p>Si vous désirez suivre ou contribuer au processus de développement de FreeBSD, tout particulièrement si cela a rapport avec la prochaine version de FreeBSD, alors vous devriez penser à suivre FreeBSD-STABLE.</p></div><div class=paragraph><p>Bien qu’il soit vrai que les correctifs de sécurité vont également dans la branche FreeBSD-STABLE, vous n’avez pas <em>besoin</em> de suivre FreeBSD-STABLE pour cela. Chaque rapport de sécurité concernant FreeBSD explique comment corriger le problème sur les versions affectées , et suivre intégralement une branche de développement juste pour des raisons de sécurité apportera également de nombreux changements non désirés.</p></div><div class=paragraph><p>Bien que nous tentons de nous assurer que la branche FreeBSD-STABLE soit compilable et constamment stable, cela ne peut être garanti. De plus, alors que le code est développé sous FreeBSD-CURRENT avant de l’inclure dans FreeBSD-STABLE, le nombre de personnes utilisant FreeBSD-STABLE est plus nombreux que celui utilisant FreeBSD-CURRENT, aussi il est inévitable que des bogues et des problèmes pourront parfois apparaître sous FreeBSD-STABLE alors qu’ils n’existaient pas sous FreeBSD-CURRENT.</p></div><div class=paragraph><p>Pour ces raisons, nous ne recommandons <em>pas</em> de suivre aveuglément FreeBSD-STABLE, et il est tout particulièrement important que vous ne mettiez pas à jour des serveurs de production sous FreeBSD-STABLE sans avoir tout d’abord testé le code dans votre environnement de travail.</p></div><div class=paragraph><p>Si vous ne disposez pas des ressources pour faire cela alors nous recommandons que vous utilisiez la version de FreeBSD la plus récente, et que vous utilisiez le mécanisme de mise à jour binaire pour passer d’une version à une autre.</p></div></div><div class=sect4><h5 id=_utiliser_freebsd_stable>26.5.2.3. Utiliser FreeBSD-STABLE<a class=anchor href=#_utiliser_freebsd_stable></a></h5><div class="olist arabic"><ol class=arabic><li><p>Inscrivez-vous à à la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>liste de diffusion à propos de la branche FreeBSD-STABLE;</a>. Vous serez tenu au courant des dépendances de compilation qui peuvent apparaître dans la branche FreeBSD-STABLE ou de tout autre problème demandant une attention particulière. Les développeurs publieront également des annonces sur cette liste lorsqu’ils envisagent une correction ou modification controversée, offrant la possibilité aux utilisateurs de répondre s’ils ont des questions à soulever en rapport avec la modification proposée.</p><div class=paragraph><p>Inscrivez-vous à la liste SVN correspondant à la branche que vous suivez. Par exemple, si vous suivez la branche 7-STABLE, inscrivez-vous à la liste <a href=https://lists.FreeBSD.org/subscription/svn-src-stable-7>svn-src-stable-7</a>. Cela vous permettra de lire les courriers de trace des soumissions de toutes les modifications dès qu’elles sont faites et des informations pertinentes sur les éventuels effets de bord.</p></div><div class=paragraph><p>Pour vous inscrire à ces listes, ou à une autre, rendez vous à <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> et cliquez sur la liste à laquelle vous désirez vous inscrire. Des instructions sur le reste de la procédure sont alors données. Si vous êtes intéressé par le suivi des modifications appliquées à l’ensemble de l’arborescence des sources, nous vous recommandons de vous inscrire à <a href=https://lists.FreeBSD.org/subscription/svn-src-all>messages SVN de modification concernant l’intégrélité de l’arbre src (en dehors des arbres "user" et "projects")</a>.</p></div></li><li><p>Si vous installez un nouveau système et vous voulez qu’il utilise le dernier instantané publié tous les mois à partir de la branche FreeBSD-STABLE, consultez la page sur les <a href=https://www.FreeBSD.org/snapshots/>instantanés</a> pour plus d’information. D’autre part, vous pouvez installer la version FreeBSD-STABLE la plus récente à partir des <a href=./#mirrors>sites miroirs</a> et suivre les instructions ci-dessous pour mettre à jour votre système avec les sources FreeBSDstable; les plus récentes.</p><div class=paragraph><p>Si vous faites tourner une version précédente de FreeBSD et que vous désirez mettre à jour via les sources vous pouvez aisément le faire à partir d’un <a href=./#mirrors>site miroir</a> FreeBSD. Cela peut être fait de deux manières:
.. Utilisez le programme <a href=./#cvsup>cvsup</a> avec le fichier <span class=filename>supfile</span> nommé <span class=filename>stable-supfile</span> disponible dans le répertoire <span class=filename>/usr/shared/examples/cvsup</span>. C’est la méthode recommandée, puisqu’elle permet de récupérer la totalité des sources la première fois et par la suite uniquement ce qui a été modifié. De nombreuses personnes exécutent <code>cvsup</code> depuis <code>cron</code> et maintiennent ainsi automatiquement à jour leurs sources. Vous devez personnaliser l’exemple de <span class=filename>supfile</span> précédent, et configurer <a href=./#cvsup>cvsup</a> pour votre environnement.
.. Utilisez CTM. Si vous ne disposez pas d’une connexion Internet rapide et peu coûteuse, c’est la méthode que vous devriez penser à utiliser.</p></div></li><li><p>Avant tout, si vous avez besoin d’un accès rapide à la demande aux sources et que la bande passante n’est pas un problème, utilisez <code>cvsup</code> ou <code>ftp</code>. Sinon, utilisez CTM.</p></li><li><p>Avant de compiler FreeBSD-STABLE, lisez attentivement le <span class=filename>Makefile</span> dans <span class=filename>/usr/src</span>. Vous devriez au moins la première fois <a href=#makeworld>installer un nouveau noyau et recompiler le système</a>, comme étape nécessaire à votre processus de mise à jour. La lecture de la <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>liste de diffusion à propos de la branche FreeBSD-STABLE;</a> et du fichier <span class=filename>/usr/src/UPDATING</span> vous tiendra au courant des autres procédures de transition qui sont parfois nécessaires lorsque nous préparons la prochaine version.</p></li></ol></div></div></div></div><div class=sect2><h3 id=synching>26.6. Synchroniser vos sources<a class=anchor href=#synching></a></h3><div class=paragraph><p>Il existe différentes façons d’utiliser une connexion Internet (ou le courrier électronique) pour garder à jour les sources de n’importe quelle partie, ou de l’ensemble, du projet FreeBSD, selon ce qui vous intéresse. Les principaux services que nous fournissons sont le <a href=./#anoncvs>CVS anonyme</a>, <a href=./#cvsup>CVSup</a>, et <a href=./#ctm>CTM</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Alors qu’il est possible de mettre à jour seulement certaines parties de l’arbre des sources, la seule procédure de mise à jour supportée est celle consistant à mettre à jour l’intégralité de l’arborescence et de recompiler les sources des applicatifs de base-"userland" (i.e., tous les programmes qui tournent dans l’espace utilisateur, comme ceux des répertoires <span class=filename>/bin</span> et <span class=filename>/sbin</span>) et du noyau. Ne mettre à jour qu’une partie des sources, uniquement le noyau, ou seul le "userland" mènera souvent à des problèmes. Ces problèmes pourront aller d’erreurs de compilation à des paniques du noyau ou même des corruptions de données.</p></div></td></tr></tbody></table></div><div class=paragraph><p>CVS anonyme et CVSup utilisent une méthode de mise à jour pilotée par le client-<em>pull</em>. Dans le cas de CVSup, l’utilisateur (ou une procédure <code>cron</code>) appelle le programme <code>cvsup</code>, qui interagit avec un serveur <code>cvsupd</code> distant, pour mettre à jour vos fichiers. Les mises à jour que vous recevez sont les plus récentes, et vous ne les recevez seulement lorsque vous le désirez. Vous pouvez aisément restreindre vos mises à jour aux fichiers ou répertoires particuliers qui vous intéressent. Les mises à jour sont générées à la volée par le serveur, en fonction de ce que vous avez déjà et de ce que vous voulez. CVS anonyme est plus simpliste que CVSup, car ce n’est qu’une extension de CVS qui permet de récupérer des modifications directement d’une archive CVS distante. Pour cela, CVSup est bien plus efficace mais CVS anonyme est plus facile à utiliser.</p></div><div class=paragraph><p>CTM, à l’inverse, ne compare pas interactivement les sources dont vous disposez avec celles qui sont sur l’archive de référence. Au lieu de cela, une procédure qui identifie les modifications intervenues depuis qu’elle a été exécutée pour la dernière fois, est lancée plusieurs fois par jour sur la machine CTM de référence (maître), les modifications détectées sont compressées, affectées d’un numéro de séquence et encodées pour pouvoir être envoyées par courrier électronique (en ASCII imprimable uniquement). Une fois reçus, ces "deltas CTM" peuvent être passés à l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=ctm_rmail&amp;sektion=1&amp;format=html">ctm_rmail(1)</a> qui décodera, contrôlera et appliquera automatiquement les modifications à l’exemplaire des sources de l’utilisateur. Cette méthode est beaucoup plus efficace que CVSup et consomme beaucoup moins de ressources sur notre serveur, parce que c’est un modèle piloté par le serveur-<em>push</em> plutôt que par l’utilisateur-<em>pull</em>.</p></div><div class=paragraph><p>Il y a, bien sûr, quelques contreparties. Si vous effacez par inadvertance des parties de votre archive, CVSup s’en apercevra et vous reconstruira les parties endommagées. CTM ne le fera pas, et si vous effacez des parties de votre l’arborescence des sources (et que vous n’avez pas fait de sauvegarde) alors vous devrez repartir de zéro (à partir du plus récent "delta de base" CVS) et tout reconstituer avec CTM ou CVS anonyme, effacer les parties endommagées et resynchroniser.</p></div></div><div class=sect2><h3 id=makeworld>26.7. Recompiler le système<a class=anchor href=#makeworld></a></h3><div class=paragraph><p>Une fois que vous avez synchronisé votre arborescence des sources avec une version donnée de FreeBSD (FreeBSD-STABLE, FreeBSD-CURRENT, et ainsi de suite) vous pouvez alors utiliser cette arborescence des sources pour recompiler le système.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Faites une sauvegarde</div><div class=paragraph><p>On n’insistera jamais assez sur l’importance de faire une sauvegarde de votre système <em>avant</em> tout autre chose. Bien qu’il soit facile de "refaire le monde" (recompiler FreeBSD), si vous suivez ces instructions, vous ferez inévitablement des erreurs à un moment ou un autre, ou d’autres feront des erreurs au niveau de l’arborescence des sources qui empêcheraient votre système de redémarrer.</p></div><div class=paragraph><p>Assurez-vous que vous avez bien fait une sauvegarde. Ayez une disquette de maintenance, ou un CD démarrable à portée de la main. Vous ne l’utiliserez probablement pas, mais prudence est mère de sûreté!</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>S’abonner à la bonne liste de diffusion</div><div class=paragraph><p>Les branches FreeBSD-STABLE et FreeBSD-CURRENT sont, par nature, <em>en développement</em>. Les personnes qui participent à FreeBSD sont des humains, et des erreurs se produisent occasionnellement.</p></div><div class=paragraph><p>Ces erreurs sont parfois bénignes, provocant simplement l’affichage d’un nouveau message d’avertissement par votre système. Elles peuvent aussi être catastrophiques, et empêcher votre système de redémarrer ou détruire vos systèmes de fichiers (ou pire).</p></div><div class=paragraph><p>Quand de tels problèmes se produisent, un avertissement "heads up" est posté sur la liste de diffusion appropriée, décrivant la nature du problème et quels systèmes sont concernés. Un message "all clear" est posté quand le problème est résolu.</p></div><div class=paragraph><p>Si vous tentez de suivre FreeBSD-STABLE ou FreeBSD-CURRENT et que vous ne lisez pas la <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>liste de diffusion à propos de la branche FreeBSD-STABLE;</a> ou la <a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a>, vous allez au devant d’ennuis.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>N’utilisez pas la commande <code>make world</code></div><div class=paragraph><p>De nombreuses anciennes documentations préconisent d’utiliser la commande <code>make world</code>. Cette commande n’effectue pas un certain nombre d’étapes importantes et ne devrait être utilisée que si vous êtes sûr de ce que vous faites. Dans presque tout les cas <code>make world</code> n’est pas une bonne chose à faire, et la procédure décrite dans la suite de ce document devrait être utilisée à la place.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_la_méthode_générique_de_mise_à_jour_du_système>26.7.1. La méthode générique de mise à jour du système<a class=anchor href=#_la_méthode_générique_de_mise_à_jour_du_système></a></h4><div class=paragraph><p>Pour mettre à jour votre système, vous devriez consulter <span class=filename>/usr/src/UPDATING</span> pour toute opération préliminaire nécessaire en fonction de la version de vos sources et ensuite utiliser la procédure suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildworld</span>
<span class=c># make buildkernel</span>
<span class=c># make installkernel</span>
<span class=c># shutdown -r now</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans quelques rares cas, il est nécessaire de lancer un <code>mergemaster -p</code> avant l’étape <code>buildworld</code>. Ces cas sont décrits dans le fichier <span class=filename>UPDATING</span>. Généralement, vous pouvez omettre cette opération si vous ne mettez pas à jour d’une version majeure de FreeBSD à une autre.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Une fois l’opération <code>installkernel</code> terminée avec succès, vous devrez démarrer en mode mono-utilisateur (en utilisant par exemple la commande <code>boot -s</code> à l’invite du chargeur). Exécutez ensuite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a -t ufs</span>
<span class=c># mergemaster -p</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># mergemaster</span>
<span class=c># reboot</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Lisez les explications supplémentaires</div><div class=paragraph><p>La séquence décrite ci-dessus n’est qu’un court résumé pour vous aider à démarrer. Vous devriez cependant lire les sections suivantes afin de comprendre clairement chaque étape, tout particulièrement si vous désirez utiliser une configuration du noyau personnalisée.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_lire_usrsrcupdating>26.7.2. Lire <span class=filename>/usr/src/UPDATING</span><a class=anchor href=#_lire_usrsrcupdating></a></h4><div class=paragraph><p>Avant tout autre chose, lisez <span class=filename>/usr/src/UPDATING</span> (ou le fichier équivalent en fonction de l’endroit où se trouve vos sources). Ce fichier devrait contenir les informations importantes au sujet des problèmes que vous pourriez rencontrer, ou indique l’ordre dans lequel vous devriez exécuter certaines commandes. Si le fichier <span class=filename>UPDATING</span> contredit quelque chose d’écrit ici, <span class=filename>UPDATING</span> prime sur tout le reste.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>La lecture du fichier <span class=filename>UPDATING</span> n’est pas un substitut à l’abonnement à la liste de diffusion correcte, comme décrit précédemment. Ces deux prérequis sont complémentaires, et non pas exclusifs.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_contrôler_etcmake_conf>26.7.3. Contrôler <span class=filename>/etc/make.conf</span><a class=anchor href=#_contrôler_etcmake_conf></a></h4><div class=paragraph><p>Contrôlez les fichiers <span class=filename>/usr/shared/examples/etc/make.conf</span> et <span class=filename>/etc/make.conf</span>. Le premier contient des paramètres par défaut - la plupart étant placés en commentaires. Pour les utiliser quand vous recompilez votre système à partir des sources, rajoutés-les au fichier <span class=filename>/etc/make.conf</span>. Gardez à l’esprit que tout ce que vous ajoutez au fichier <span class=filename>/etc/make.conf</span> est utilisé chaque fois que vous invoquez la commande <code>make</code>, il est donc bon de s’assurer que les valeurs par défaut sont appropriées à votre système.</p></div><div class=paragraph><p>Un utilisateur typique voudra probablement copier les lignes <code>CFLAGS</code> et <code>NO_PROFILE</code> se trouvant dans <span class=filename>/usr/shared/examples/etc/make.conf</span> vers <span class=filename>/etc/make.conf</span> et les décommenter.</p></div><div class=paragraph><p>Examinez les autres définitions (<code>COPTFLAGS</code>, <code>NOPORTDOCS</code> et ainsi de suite) et décidez si elles vous conviennent.</p></div></div><div class=sect3><h4 id=_mettre_à_jour_les_fichiers_dans_etc>26.7.4. Mettre à jour les fichiers dans <span class=filename>/etc</span><a class=anchor href=#_mettre_à_jour_les_fichiers_dans_etc></a></h4><div class=paragraph><p>Le répertoire <span class=filename>/etc</span> contient la plupart des informations de configuration de votre système, ainsi que les procédures de démarrage. Certaines de ces procédures changent d’une version à l’autre de FreeBSD.</p></div><div class=paragraph><p>Certains fichiers de configuration sont également utilisés en permanence par le système. En particulier <span class=filename>/etc/group</span>.</p></div><div class=paragraph><p>Il est arrivé que la phase d’installation <code>make installworld</code> ait besoin que certains utilisateurs et groupes existent. Il y a de fortes chances qu’ils n’aient pas été définis avant la mise à jour. C’est une source de problèmes. Dans certains cas <code>make buildworld</code> contrôlera si ces utilisateurs ou groupes existent.</p></div><div class=paragraph><p>Un exemple de cela fut l’addition de l’utilisateur <code>smmsp</code>. Le processus d’installation échouait quand <code>mtree</code> tentait de créer <span class=filename>/var/spool/clientmqueue</span>.</p></div><div class=paragraph><p>La solution est d’exécuter <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> dans le mode pré-"buildworld" en ajoutant l’option <code>-p</code>. Cela effectuera la comparaison uniquement des fichiers essentiels pour le succès de la procédure <code>buildworld</code> ou <code>installworld</code>. Si votre vieille version de <code>mergemaster</code> ne supporte pas l’option <code>-p</code>, utilisez la nouvelle version présente dans l’arborescence des sources quand vous l’exécutez pour la première fois:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/mergemaster</span>
<span class=c># ./mergemaster.sh -p</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Si vous êtes particulièrement paranoïaque, vous pouvez contrôler votre système afin de voir quels fichiers appartiennent au groupe que vous renommez ou effacez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find / -group GID -print</span></code></pre></div></div><div class=paragraph><p>affichera les fichiers appartenant au groupe <em>GID</em> (qui peut être soit un nom de groupe ou un identifiant numérique de groupe).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=makeworld-singleuser>26.7.5. Passer en mode mono-utilisateur<a class=anchor href=#makeworld-singleuser></a></h4><div class=paragraph><p>Il vaut mieux recompiler le système en mode mono-utilisateur. En dehors du fait que cela sera légèrement plus rapide, la réinstallation va modifier un grand nombre de fichiers systèmes importants, tous les binaires de base du système, les bibliothèques, les fichiers d’include et ainsi de suite. Les modifier sur un système en fonctionnement (en particulier s’il y a des utilisateurs connectés à ce moment là), c’est aller au devant de problèmes.</p></div><div class=paragraph><p>Une autre méthode consiste à compiler le système en mode multi-utilisateurs, et passer dans le mode mono-utilisateur pour l’installation. Si vous désirez utiliser cette méthode, conservez les étapes suivantes pour le moment où la compilation sera terminée. Vous pouvez reporter le passage en mode mono-utilisateur jusqu’à l’exécution de <code>installkernel</code> ou <code>installworld</code>.</p></div><div class=paragraph><p>En tant que super-utilisateur, vous pouvez exécuter la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown now</span></code></pre></div></div><div class=paragraph><p>sur un système en fonctionnement, pour passer en mode mono-utilisateur.</p></div><div class=paragraph><p>Ou bien, redémarrer le système, et à l’invite de démarrage, sélectionnez l’option "single user". Le système démarrera alors en mode mono-utilisateur. A l’invite de l’interpréteur de commandes, exécutez alors:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p</span>
<span class=c># mount -u /</span>
<span class=c># mount -a -t ufs</span>
<span class=c># swapon -a</span></code></pre></div></div><div class=paragraph><p>Cela effectue une vérification des systèmes de fichiers, remonte <span class=filename>/</span> en mode lecture/écriture, et monte tous les autres systèmes de fichiers UFS listés dans le fichier <span class=filename>/etc/fstab</span>, puis active la pagination.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si votre horloge CMOS est réglée sur l’heure locale et non pas sur le fuseau GMT (cela est vrai si la sortie de la commande <code>date</code> ne donne pas l’heure et le fuseau correct), vous aurez également peut-être besoin d’exécuter la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adjkerntz -i</span></code></pre></div></div><div class=paragraph><p>Cela permettra de s’assurer que vos paramètres de fuseaux horaires sont correctement configurés - sans cela, vous risquez de faire face, plus tard, à des problèmes.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_effacer_usrobj>26.7.6. Effacer <span class=filename>/usr/obj</span><a class=anchor href=#_effacer_usrobj></a></h4><div class=paragraph><p>Au fur et à mesure que les différentes parties du système sont recompilées, elles sont placées dans des répertoires qui (par défaut) sont sous <span class=filename>/usr/obj</span>. Les répertoires sont agencés comme sous <span class=filename>/usr/src</span>.</p></div><div class=paragraph><p>Vous pouvez accélérer le processus <code>make buildworld</code>, et également vous éviter d’éventuels problèmes de dépendances en effaçant ce répertoire.</p></div><div class=paragraph><p>Certains fichiers dans <span class=filename>/usr/obj</span> peuvent avoir l’indicateur immuable positionné (consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> pour plus d’informations) qui doit être retiré en premier.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/obj</span>
<span class=c># chflags -R noschg *</span>
<span class=c># rm -rf *</span></code></pre></div></div></div><div class=sect3><h4 id=updating-upgrading-compilebase>26.7.7. Recompiler le système de base<a class=anchor href=#updating-upgrading-compilebase></a></h4><div class=sect4><h5 id=_enregistrer_la_sortie>26.7.7.1. Enregistrer la sortie<a class=anchor href=#_enregistrer_la_sortie></a></h5><div class=paragraph><p>C’est une bonne idée d’enregistrer la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> dans un fichier. Si quelque chose se passe mal, vous aurez une trace des messages d’erreur. Même si cela ne vous aide pas à diagnostiquer ce qui n’a pas fonctionné, cela peut aider les autres si vous postez votre problème sur une des listes de diffusion de FreeBSD.</p></div><div class=paragraph><p>La méthode la plus aisée pour faire cela est d’utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=script&amp;sektion=1&amp;format=html">script(1)</a>, avec en paramètre le nom du fichier où enregistrer les résultats. Vous devez faire cela immédiatement juste avant de recompiler le système, et taper <code>exit</code> une fois que c’est terminé.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># script /var/tmp/mw.out</span>
Script started, output file is /var/tmp/mw.out
<span class=c># make TARGET</span>
… compile, compile, compile …
<span class=c># exit</span>
Script <span class=k>done</span>, …</code></pre></div></div><div class=paragraph><p>Si vous le faites, <em>n’enregistrez pas</em> le résultat dans <span class=filename>/tmp</span>. Ce répertoire peut être vidé au prochain redémarrage du système. Un meilleur endroit de sauvegarde est <span class=filename>/var/tmp</span> (comme dans l’exemple précédent) ou dans le répertoire utilisateur de <code>root</code>.</p></div></div><div class=sect4><h5 id=make-buildworld>26.7.7.2. Compiler le nouveau système<a class=anchor href=#make-buildworld></a></h5><div class=paragraph><p>Vous devez être dans le répertoire <span class=filename>/usr/src</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div><div class=paragraph><p>(à moins, bien sûr, que votre code source ne soit ailleurs, auquel cas vous devrez aller dans le répertoire correspondant).</p></div><div class=paragraph><p>Pour recompiler le système, on utilise la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>. Cette commande lit ses instructions dans le fichier <span class=filename>Makefile</span>, qui décrit comment devraient être reconstruits les programmes qui constituent FreeBSD, dans quel ordre, et ainsi de suite.</p></div><div class=paragraph><p>Le format général de la ligne de commande que vous taperez sera la suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -x -DVARIABLE cible</span></code></pre></div></div><div class=paragraph><p>Dans cet exemple, <code>-<em>x</em></code> est une option que vous passez à <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>. Reportez-vous à la page de manuel pour un exemple d’options que vous pouvez passer.</p></div><div class=paragraph><p><code>-D_VARIABLE_</code> transmet un variable au fichier <span class=filename>Makefile</span>. Le comportement du <span class=filename>Makefile</span> est défini par ces variables. Ce sont les mêmes variables que l’on trouve dans <span class=filename>/etc/make.conf</span>, et c’est un autre moyen de les positionner.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -DNO_PROFILE cible</span></code></pre></div></div><div class=paragraph><p>est une autre manière de dire qu’il ne faut pas compiler les bibliothèques profilées et correspond à la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>NO_PROFILE=    true	#    Avoid compiling profiled libraries</pre></div></div><div class=paragraph><p>dans <span class=filename>/etc/make.conf</span>.</p></div><div class=paragraph><p><em>cible</em> indique à <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> ce que vous voulez faire. Chaque <span class=filename>Makefile</span> définit un certain nombre de "cibles", et votre choix de cible détermine ce qui se passe.</p></div><div class=paragraph><p>Certaines cibles listées dans le fichier <span class=filename>Makefile</span>, ne doivent pas être employées. Ce sont des étapes intermédiaires utilisées par le processus de recompilation pour décomposer les étapes importantes de la recompilation du système en sous-étapes.</p></div><div class=paragraph><p>La plupart du temps, vous n’aurez pas besoin de passer de paramètres à <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, et votre commande ressemblera à ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make cible</span></code></pre></div></div><div class=paragraph><p>Où <em>cible</em> sera une des nombreuses options de compilation. La première cible devrait toujours être <code>buildworld</code>.</p></div><div class=paragraph><p>Comme leurs noms l’indiquent, <code>buildworld</code> reconstruit la nouvelle arborescence dans <span class=filename>/usr/obj</span>, et <code>installworld</code>, une autre cible, l’installe sur la machine.</p></div><div class=paragraph><p>Disposer d’options séparées est très utile pour deux raisons. Tout d’abord cela vous permet de recompiler en toute sûreté en sachant qu’aucun composant du système actuel ne sera affecté. La compilation est "autonome". En raison de cela vous pouvez exécuter <code>buildworld</code> sur une machine en mode multi-utilisateurs sans redouter d’effets fâcheux. Il est néanmoins recommandé de toujours exécuter l’étape <code>installworld</code> en mode mono-utilisateur.</p></div><div class=paragraph><p>En second lieu, cela vous permet d’utiliser des systèmes montés par NFS pour mettre à jour plusieurs machines de votre réseau. Si vous avez trois machines <code>A</code>, <code>B</code> et <code>C</code> que vous voulez mettre à jour, exécutez <code>make buildworld</code> et <code>make installworld</code> sur <code>A</code>. <code>B</code> et <code>C</code> doivent ensuite monter par NFS <span class=filename>/usr/src</span> et <span class=filename>/usr/obj</span> depuis <code>A</code>, et vous pouvez alors exécuter <code>make installworld</code> pour installer le système recompilé sur <code>B</code> et <code>C</code>.</p></div><div class=paragraph><p>Bien que la cible <code>world</code> existe toujours, vous êtes fortement encouragé à ne pas l’utiliser.</p></div><div class=paragraph><p>Exécutez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildworld</span></code></pre></div></div><div class=paragraph><p>Il est possible de passer l’option <code>-j</code> à <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> ce qui lui permettra d’exécuter plusieurs processus simultanément. C’est particulièrement utile sur une machine avec plusieurs processeurs. Cependant, comme la compilation est plus gourmande en E/S plutôt qu’en CPU, c’est également utile sur des machines mono-processeur.</p></div><div class=paragraph><p>Typiquement sur une machine mono-processeur, vous exécuteriez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -j4 buildworld</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> pourra exécuter jusqu’à 4 processus simultanément. Des constatations empiriques postées sur les listes de diffusion montrent que c’est en général ce qui apporte le plus de gain en performances.</p></div><div class=paragraph><p>Si vous avez une machine multi-processeurs et que vous avez configuré un noyau SMP, essayez des valeurs entre 6 et 19 et voyez quel bénéfice vous en tirez.</p></div></div><div class=sect4><h5 id=_durée>26.7.7.3. Durée<a class=anchor href=#_durée></a></h5><div class=paragraph><p>De nombreux facteurs influencent la durée de compilation, mais les machines récentes devraient mettrent seulement de une à deux heures pour compiler l’arborescence FreeBSD-STABLE, sans modification ni raccourcis durant le processus. Une arborescence FreeBSD-CURRENT nécessitera un peu plus de temps.</p></div></div></div><div class=sect3><h4 id=_compiler_et_installer_un_nouveau_noyau>26.7.8. Compiler et installer un nouveau noyau<a class=anchor href=#_compiler_et_installer_un_nouveau_noyau></a></h4><div class=paragraph><p>Pour tirer pleinement parti de votre nouveau système, vous devrez recompiler le noyau. C’est pratiquement indispensable, parce que certaines structures mémoires peuvent avoir changées, et des programmes comme <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> ne fonctionneront pas tant que le système et le noyau n’utilisent pas les mêmes versions de code source.</p></div><div class=paragraph><p>La manière la plus simple et la plus sûre est de compiler et installer un noyau basé sur le noyau <span class=filename>GENERIC</span>. Alors que le noyau <span class=filename>GENERIC</span> peut ne pas comporter les pilotes de périphériques nécessaires pour votre système, il devrait contenir tout ce qui est nécessaire pour faire démarrer votre système en mode mono-utilisateur. C’est une bonne façon de tester le fonctionnement de votre nouveau système. Après avoir démarré à partir du noyau <span class=filename>GENERIC</span> et vérifié que votre système fonctionne vous pouvez alors compiler un nouveau noyau basé sur votre fichier de configuration normal du noyau.</p></div><div class=paragraph><p>Sur FreeBSD, il est important de <a href=#make-buildworld>recompiler le système</a> avant de compiler un nouveau noyau.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous désirez compiler un noyau personnalisé, et que vous avez déjà un fichier de configuration, utilisez juste <code>KERNCONF=<em>MONNOYAU</em></code> comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildkernel KERNCONF=MONNOYAU</span>
<span class=c># make installkernel KERNCONF=MONNOYAU</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Notez que si vous avez augmenté la variable <code>kern.securelevel</code> à une valeur supérieure à 1 <em>et</em> que vous avez positionné l’indicateur <code>noschg</code> ou similaire sur votre noyau, il sera intéressant de passer en mode mono-utilisateur pour utiliser <code>installkernel</code>. Sinon vous devriez être en mesure d’exécuter ces commandes à partir du mode multi-utilisateur sans problèmes. Voir la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> pour plus de détails à propos de <code>kern.securelevel</code> et la page <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> pour des informations sur les différents indicateurs de fichiers.</p></div></div><div class=sect3><h4 id=_redémarrer_en_mode_mono_utilisateur>26.7.9. Redémarrer en mode mono-utilisateur<a class=anchor href=#_redémarrer_en_mode_mono_utilisateur></a></h4><div class=paragraph><p>Vous devriez redémarrer en mode mono-utilisateur pour tester le fonctionnement du nouveau noyau. Pour cela suivez les instructions de <a href=#makeworld-singleuser>Passer en mode mono-utilisateur</a>.</p></div></div><div class=sect3><h4 id=make-installworld>26.7.10. Installer les nouveaux binaires système<a class=anchor href=#make-installworld></a></h4><div class=paragraph><p>Si vous avez compilé une version de FreeBSD assez récente pour avoir utilisé <code>make buildworld</code> alors vous devriez utiliser maintenant <code>installworld</code> pour installer les nouveaux binaires système.</p></div><div class=paragraph><p>Lancez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installworld</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous spécifiez des variables sur la ligne de commande de <code>make buildworld</code>, vous devez utiliser les mêmes variables avec la commande <code>make installworld</code>. Cela ne reste pas forcément vrai pour d’autres options; par exemple, <code>-j</code> ne doit jamais être utilisée avec <code>installworld</code>.</p></div><div class=paragraph><p>Par exemple, si vous exécutez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -DNO_PROFILE buildworld</span></code></pre></div></div><div class=paragraph><p>vous devrez ensuite installer les résultats avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -DNO_PROFILE installworld</span></code></pre></div></div><div class=paragraph><p>sinon il essayera d’installer les bibliothèques profilées qui n’ont pas été recompilées à l’étape <code>make buildworld</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_mettre_à_jour_les_fichiers_non_modifiés_par_make_installworld>26.7.11. Mettre à jour les fichiers non modifiés par <code>make installworld</code><a class=anchor href=#_mettre_à_jour_les_fichiers_non_modifiés_par_make_installworld></a></h4><div class=paragraph><p>La recompilation du système ne mettra pas à jour certains répertoires (en particulier, <span class=filename>/etc</span>, <span class=filename>/var</span> et <span class=filename>/usr</span>) avec les fichiers nouveaux ou modifiés.</p></div><div class=paragraph><p>La manière la plus simple de mettre à jour ces fichiers est d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>, bien qu’il soit possible de le faire manuellement si vous le désirez. Indépendamment de la manière que vous choisissez, assurez-vous de faire une sauvegarde du répertoire <span class=filename>/etc</span> au cas où quelque chose se passerait mal.</p></div><div class=sect4><h5 id=mergemaster>26.7.11.1. <code>mergemaster</code><a class=anchor href=#mergemaster></a></h5><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> est une procédure Bourne qui vous aidera à déterminer les différences entre vos fichiers de configuration dans le répertoire <span class=filename>/etc</span>, et les fichiers de configuration dans l’arborescence des sources <span class=filename>/usr/src/etc</span>. C’est la solution recommandée pour maintenir à jour les fichiers de configuration du système avec ceux situés dans l’arborescence des sources.</p></div><div class=paragraph><p>Pour commencer, tapez simplement <code>mergemaster</code> à l’invite, et observez-le travailler. <code>mergemaster</code> commencera à constituer une arborescence temporaire, à partir de <span class=filename>/</span>, et la remplira avec divers fichiers de configuration. Ces fichiers sont alors comparés avec ceux actuellement installés sur votre système. A ce point, les fichiers qui diffèrent seront affichés dans le format <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>, avec le signe <code>+</code> représentant les lignes modifiées ou ajoutées, et le <code>-</code> représentant les lignes qui seront soit complètement supprimées, soit remplacées avec une nouvelle ligne. Voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> pour plus d’informations au sujet de la syntaxe <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> et comment sont affichées les différences.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> vous affichera ensuite chaque fichier présentant des différences, et vous aurez à ce moment-là le choix de soit supprimer le nouveau fichier (le fichier temporaire), soit d’installer le fichier temporaire non modifié, soit de fusionner le fichier temporaire et le fichier actuellement installé, soit enfin de revoir les résultats de l’opération <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>.</p></div><div class=paragraph><p>Choisir de supprimer le fichier temporaire indiquera à <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> que nous désirons conserver notre fichier actuel intacte, et effacera la nouvelle version. Cette option n’est pas recommandée, à moins que vous ne voyez aucune raison de modifier le fichier actuel. Vous pouvez obtenir de l’aide à n’importe quel moment en tapant <kbd>?</kbd> à l’invite de <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>. Si l’utilisateur choisit de passer un fichier, il sera présenté à nouveau une fois que tous les autres fichiers auront été traités.</p></div><div class=paragraph><p>Choisir d’installer un fichier temporaire intact remplacera le fichier actuel avec le nouveau. Pour la plupart des fichiers non modifiées, c’est la meilleure option.</p></div><div class=paragraph><p>Choisir de fusionner le fichier, vous affichera un éditeur de texte, et le contenu des deux fichiers. Vous pouvez maintenant les fusionner en les visionnant côte à côte sur l’écran, et en sélectionnant des parties des deux fichiers pour créer un fichier final. Quand les fichiers sont comparés côte à côte, la touche <kbd>l</kbd> sélectionnera le contenu de gauche et la touche <kbd>r</kbd> sélectionnera celui de droite. Le résultat final sera un fichier constitué des deux parties, qui peut alors être installé. Cette option est habituellement utilisée pour les fichiers où les des paramètres ont été modifiés par l’utilisateur.</p></div><div class=paragraph><p>Choisir de revoir les résultats de l’opération <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> vous affichera les différences entre fichiers tout comme la fait <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> avant de vous demander un choix.</p></div><div class=paragraph><p>Après que <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> en ait terminé avec les fichiers système, il vous proposera de nouvelles opérations. <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> vous demandera si vous désirez reconstruire le fichier des mots de passe et terminera en vous proposant de supprimer les fichiers temporaires restants.</p></div></div><div class=sect4><h5 id=_mise_à_jour_manuelle>26.7.11.2. Mise à jour manuelle<a class=anchor href=#_mise_à_jour_manuelle></a></h5><div class=paragraph><p>Si vous désirez faire la mise à jour manuellement, vous ne pouvez cependant pas vous contenter de copier les fichiers de <span class=filename>/usr/src/etc</span> dans <span class=filename>/etc</span> pour que cela fonctionne. Certains de ces fichiers doivent d’abord être "installés". En effet le répertoire <span class=filename>/usr/src/etc</span> "n’est pas" une copie de ce que devrait contenir votre répertoire <span class=filename>/etc</span>. De plus, il a des fichiers qui doivent être dans <span class=filename>/etc</span> et qui ne sont pas dans <span class=filename>/usr/src/etc</span>.</p></div><div class=paragraph><p>Si vous utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> (comme recommandé), vous pouvez passer cette section et aller directement à la <a href=#updating-upgrading-rebooting>section suivante</a>.</p></div><div class=paragraph><p>La façon la plus simple de procéder est d’installer les fichiers dans un nouveau répertoire, puis de passer en revue les différences.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Sauvegardez votre répertoire <span class=filename>/etc</span> actuel</div><div class=paragraph><p>Bien qu’en principe rien ne sera modifié automatiquement dans ce répertoire, prudence est mère de sûreté. Copiez donc votre répertoire <span class=filename>/etc</span> dans un endroit sûr. Quelque chose du genre:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp -Rp /etc /etc.old</span></code></pre></div></div><div class=paragraph><p>conviendra; l’option <code>-R</code> fait une copie récursive, <code>-p</code> préserve la date, les autorisations des fichiers et ainsi de suite.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Vous devez créer un ensemble de répertoires provisoires pour y installer les fichiers du répertoire <span class=filename>/etc</span> et autres. <span class=filename>/var/tmp/root</span> est un bon choix, il y a un certain nombre de sous-répertoires à créer également:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/root</span>
<span class=c># cd /usr/src/etc</span>
<span class=c># make DESTDIR=/var/tmp/root distrib-dirs distribution</span></code></pre></div></div><div class=paragraph><p>Cela va créer l’arborescence nécessaire et y installera les fichiers. Un grand nombre des sous-répertoires créés dans <span class=filename>/var/tmp/root</span> sont vides et devront être supprimés. La façon la plus simple de le faire est:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /var/tmp/root</span>
<span class=c># find -d . -type d | xargs rmdir 2&gt;/dev/null</span></code></pre></div></div><div class=paragraph><p>Ceci supprimera tous les répertoires vides (la sortie d’erreur standard est redirigée vers <span class=filename>/dev/null</span> pour empêcher les avertissements à propos des répertoires non vides).</p></div><div class=paragraph><p><span class=filename>/var/tmp/root</span> contient maintenant tous les fichiers à installer à l’endroit requis sous <span class=filename>/</span>. Vous devez maintenant examiner chacun de ces fichiers pour déterminer en quoi ils diffèrent de vos propres fichiers.</p></div><div class=paragraph><p>Notez que certains des fichiers qui seront installés dans <span class=filename>/var/tmp/root</span> commencent par un ".". Au moment où sont écrites ces lignes, les seuls fichiers concernés sont les fichiers d’initialisation des interpréteurs de commandes dans <span class=filename>/var/tmp/root/</span> et <span class=filename>/var/tmp/root/root/</span>, mais il pourrait y en avoir d’autres (cela dépend de quand vous lirez ces lignes). Assurez-vous d’utiliser la commande <code>ls -a</code> pour ne pas les oublier.</p></div><div class=paragraph><p>La manière la plus simple de procéder est d’utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> pour comparer les deux fichiers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diff /etc/shells /var/tmp/root/etc/shells</span></code></pre></div></div><div class=paragraph><p>Cela vous indiquera les différences entre votre fichier <span class=filename>/etc/shells</span> et le nouveau fichier <span class=filename>/var/tmp/root//etc/shells</span>. A partir de là, décidez si vous aller reporter les modifications que vous y avez apportée ou si vous allez simplement recopier le nouveau fichier.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Donnez au nouveau répertoire racine (<span class=filename>/var/tmp/root</span>) un nom qui inclue une date, pour pouvoir facilement comparer les différentes versions</div><div class=paragraph><p>Si vous recompilez fréquemment votre système, cela signifie que vous devez également souvent mettre à jour le répertoire <span class=filename>/etc</span>, ce qui peut rapidement devenir une corvée.</p></div><div class=paragraph><p>Vous pouvez accélérer le processus en conservant une copie du dernier ensemble de fichiers modifiés que vous avez reportés dans <span class=filename>/etc</span>. La procédure suivante présente une façon de faire.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Recompilez le système comme à l’accoutumé. Au moment de mettre à jour <span class=filename>/etc</span> et les autre répertoires, donnez au répertoire cible un nom basé sur la date du jour. Si vous faisiez cela le 14 février 1998, vous pourriez procéder comme suit:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/root-19980214</span>
<span class=c># cd /usr/src/etc</span>
<span class=c># make DESTDIR=/var/tmp/root-19980214 \</span>
    distrib-dirs distribution</code></pre></div></div></li><li><p>Reporter les modifications depuis ce répertoire comme décrit plus haut.</p><div class=paragraph><p><em>Ne supprimez pas</em> le répertoire <span class=filename>/var/tmp/root-19980214</span> quand vous aurez terminé.</p></div></li><li><p>Quand vous récupérez la dernière version des sources et la recompilerez, suivez l’étape 1. Vous aurez alors un nouveau répertoire, qui pourrait s’appeler <span class=filename>/var/tmp/root-19980221</span> (si vous faites une mise à jour chaque semaine).</p></li><li><p>Vous pouvez maintenant voir les modifications intervenues d’une semaine à l’autre en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> pour afficher les différences entre tous les fichiers deux répertoires:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /var/tmp</span>
<span class=c># diff -r root-19980214 root-19980221</span></code></pre></div></div><div class=paragraph><p>Généralement, il y aura beaucoup moins de différences qu’entre <span class=filename>/var/tmp/root-19980221/etc</span> et <span class=filename>/etc</span>. Comme il y a beaucoup moins de différences, il est beaucoup plus facile de les reporter dans le répertoire <span class=filename>/etc</span>.</p></div></li><li><p>Vous pouvez maintenant supprimer le plus ancien des deux répertoires <span class=filename>/var/tmp/root-*</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm -rf /var/tmp/root-19980214</span></code></pre></div></div></li><li><p>Répétez l’opération chaque fois que vous devez reporter des modifications dans <span class=filename>/etc</span>.</p></li></ol></div></div></div><div class=paragraph><p>Vous pouvez utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=date&amp;sektion=1&amp;format=html">date(1)</a> pour automatiser la génération des noms de répertoires:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/root-`date &#34;+%Y%m%d&#34;`</span></code></pre></div></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=updating-upgrading-rebooting>26.7.12. Redémarrer<a class=anchor href=#updating-upgrading-rebooting></a></h4><div class=paragraph><p>Vous en avez terminé. Après avoir vérifié que tout semble être en place, vous pouvez alors redémarrez votre système. Un simple <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> devrait suffire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div></div><div class=sect3><h4 id=_cest_fini>26.7.13. C’est fini<a class=anchor href=#_cest_fini></a></h4><div class=paragraph><p>Vous devriez maintenant avoir mis à jour avec succès votre système FreeBSD. Félicitations.</p></div><div class=paragraph><p>Si les choses se sont légèrement mal passées, il est facile de recompiler un élément particulier du système. Par exemple, si vous avez accidentellement effacé <span class=filename>/etc/magic</span> lors de la mise à jour de <span class=filename>/etc</span>, la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=file&amp;sektion=1&amp;format=html">file(1)</a> ne fonctionnerait plus. Dans ce cas, la solution serait d’exécuter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.bin/file</span>
<span class=c># make all install</span></code></pre></div></div></div><div class=sect3><h4 id=_questions>26.7.14. Questions<a class=anchor href=#_questions></a></h4></div><div class=sect3><h4 id=_dois_je_refaire_le_monde_à_chaque_évolution>26.7.15. Dois-je refaire le monde à chaque évolution?<a class=anchor href=#_dois_je_refaire_le_monde_à_chaque_évolution></a></h4><div class=paragraph><p>Il n’y a pas de réponse toute faite à cette question, tout dépend de la nature des évolutions. Par exemple, si vous venez juste d’exécuter CVSup, et que les fichiers suivants on été mis à jour:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>src/games/cribbage/instr.c
src/games/sail/pl_main.c
src/release/sysinstall/config.c
src/release/sysinstall/media.c
src/shared/mk/bsd.port.mk</code></pre></div></div><div class=paragraph><p>cela ne vaut probablement pas la peine de recompiler tout le système. Vous pouvez tout simplement aller dans les sous-répertoires appropriés, exécuter <code>make all install</code>, et c’est à peu près tout. Mais s’il y a des évolutions importantes, par exemple sur <span class=filename>src/lib/libc/stdlib</span> alors vous devrez soit refaire le monde, ou recompiler au moins toutes les parties du système qui sont liées statiquement (de même que tout ce vous pourriez avoir ajouté qui y serait lié statiquement).</p></div><div class=paragraph><p>C’est à vous de voir. Vous préférerez peut-être recompiler votre système tous les quinze jours, et laisser les modifications s’empiler pendant quinze jours. Ou bien vous préférerez ne recompiler que ce qui a changé et vous faire confiance pour tout ce qui en dépend.</p></div><div class=paragraph><p>Et, bien sûr, cela dépend de la fréquence avec laquelle vous voulez faire vos mises à jour, et de si vous suivez la branche FreeBSD-STABLE ou FreeBSD-CURRENT.</p></div></div><div class=sect3><h4 id=_ma_compilation_échoue_avec_de_nombreuses_erreurs_signal_11_signal_11_ou_tout_autre_numéro_de_signal_que_sest_il_passé>26.7.16. Ma compilation échoue avec de nombreuses erreurs "signal 11" signal 11 (ou tout autre numéro de signal). Que s’est-il passé?<a class=anchor href=#_ma_compilation_échoue_avec_de_nombreuses_erreurs_signal_11_signal_11_ou_tout_autre_numéro_de_signal_que_sest_il_passé></a></h4><div class=paragraph><p>Cela indique généralement un problème matériel. (Re)compiler le système est un bon moyen de mettre votre matériel sous pression, et mettra souvent en évidence des défaillances de la mémoire vive. Elles se manifestent normalement d’elles-mêmes, la compilation échouant lors de la réception de mystérieux signaux.</p></div><div class=paragraph><p>Un bon indicateur de cet état de fait, est que vous pouvez relancer la compilation et qu’elle échouera en un endroit différent.</p></div><div class=paragraph><p>Dans ce cas, vous ne pouvez guère faire autre chose que d’intervertir les différents composants de votre matériel pour déterminer lequel est en cause.</p></div></div><div class=sect3><h4 id=_puis_je_effacer_usrobj_après_avoir_fini>26.7.17. Puis-je effacer /usr/obj après avoir fini?<a class=anchor href=#_puis_je_effacer_usrobj_après_avoir_fini></a></h4><div class=paragraph><p>Une réponse courte est oui.</p></div><div class=paragraph><p><span class=filename>/usr/obj</span> contient tous les fichiers objets générés à la compilation. Normalement, une des premières étapes de <code>make buildworld</code> est de supprimer ce répertoire et de repartir à zéro. Dans ce cas, conserver le répertoire <span class=filename>/usr/obj</span> après avoir terminé ne sert pas à grand chose, alors que vous économiseriez pas mal d’espace disque (actuellement environ 340 MO).</p></div><div class=paragraph><p>Cependant, si vous savez ce que vous faites, vous pouvez faire en sorte que <code>make buildworld</code> saute cette étape. Cela rendra les compilations ultérieures plus rapides, puisque la plupart des sources n’auront pas besoin d’être recompilées. Le revers de la médaille est que des problèmes subtils de dépendance peuvent se manifester, provoquant l’échec de votre compilation de manière étrange. Cela génère fréquemment du bruit sur les listes de diffusion de FreeBSD, quand quelqu’un se plaint que sa mise à jour a échoué, sans réaliser que c’est parce qu’il a tenté de brûler les étapes.</p></div></div><div class=sect3><h4 id=_une_recompilation_interrompue_peut_elle_être_reprise>26.7.18. Une recompilation interrompue peut-elle être reprise?<a class=anchor href=#_une_recompilation_interrompue_peut_elle_être_reprise></a></h4><div class=paragraph><p>Tout dépend de jusqu’où vous êtes aller avant de rencontrer un problème.</p></div><div class=paragraph><p><em>En général</em> (et ceci n’est pas une règle absolue) <code>make buildworld</code> crée de nouveaux exemplaires des outils indispensables (comme <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>) et des bibliothèques système. Ces outils et bibliothèques sont ensuite installés. Puis ils sont utilisés pour se reconstruire eux-mêmes, et installés de nouveau. L’intégralité du système (y compris maintenant les programmes utilisateurs classiques, comme <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a>) est alors recompilé avec les nouveaux fichiers système.</p></div><div class=paragraph><p>Si vous êtes à cette dernière étape, et que vous le savez (parce que vous avez consulté les résultats que vous avez enregistrés) alors vous pouvez (sans trop de risque) faire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>… fix the problem …
<span class=c># cd /usr/src</span>
<span class=c># make -DNO_CLEAN all</span></code></pre></div></div><div class=paragraph><p>Cela ne détruira pas les résultats du travail qu’à déjà effectué <code>make buildworld</code>.</p></div><div class=paragraph><p>Si vous voyez le message:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>--------------------------------------------------------------</span>
Building everything..
<span class=nt>--------------------------------------------------------------</span></code></pre></div></div><div class=paragraph><p>dans les comptes-rendus de <code>make buildworld</code> alors cette façon de procéder est probablement bonne.</p></div><div class=paragraph><p>Si vous ne voyez pas ce message, ou que vous doutez de vous, alors prudence est mère de sûreté, et il vaut mieux tout reprendre depuis le début.</p></div></div><div class=sect3><h4 id=_comment_puis_je_accélérer_la_compilation_du_système>26.7.19. Comment puis-je accélérer la compilation du système?<a class=anchor href=#_comment_puis_je_accélérer_la_compilation_du_système></a></h4><div class=ulist><ul><li><p>Passez en mode mono-utilisateur.</p></li><li><p>Mettez les répertoires <span class=filename>/usr/src</span> et <span class=filename>/usr/obj</span> sur des systèmes de fichiers et des disques différents. Si possible, installez ces disques sur des contrôleurs différents.</p></li><li><p>Encore mieux, mettez ces systèmes de fichiers sur plusieurs disques utilisant le système <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> (pilote de disques concaténés).</p></li><li><p>Ne compilez pas les bibliothèques profilées (mettez "NO_PROFILE=true" dans le fichier <span class=filename>/etc/make.conf</span>). Vous n’en avez certainement pas besoin.</p></li><li><p>Egalement dans <span class=filename>/etc/make.conf</span>, positionnez <code>CFLAGS</code> à quelque chose comme <code>-O -pipe</code>. L’optimisation <code>-O2</code> est bien plus lente, et la différence d’optimisation entre <code>-O</code> et <code>-O2</code> est en général négligeable. <code>-pipe</code> demande au compilateur d’utiliser des tuyaux à la place de fichiers temporaires, ce qui économise des accès disque (mais utilise plus de mémoire).</p></li><li><p>Passez l’option <code>-j<em>n</em></code> à <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> pour permettre l’exécution de plusieurs processus en parallèle. Cela améliore généralement les choses, que vous ayez une machine mono- ou multi-processeurs.</p></li><li><p>Le système de fichiers qui contient <span class=filename>/usr/src</span> peut être monté (ou remonté) avec l’option <code>noatime</code>. Cela empêche l’enregistrement des dates d’accès aux fichiers par le système de fichiers. Vous n’avez de toute façon probablement pas besoin de cette information.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o noatime /usr/src</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Cet exemple suppose que <span class=filename>/usr/src</span> constitue à lui seul un système de fichiers. Si ce n’est pas le cas (s’il fait partie de <span class=filename>/usr</span> par exemple) vous devez alors indiquer le point de montage de ce système de fichiers, et non <span class=filename>/usr/src</span>.</p></div></td></tr></tbody></table></div></li><li><p>Le système de fichiers où se trouve <span class=filename>/usr/obj</span> peut être monté (ou remonté) avec l’option <code>async</code>. Les écritures sur le disque se feront alors de façon asynchrone. En d’autres termes, le programme reprend immédiatement la main, et l’écriture des données sur le disque se fait quelques secondes plus tard. Cela permet le groupement des écritures sur le disque, et le gain en performance peut être spectaculaire.</p><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Gardez à l’esprit que cette option rend votre système de fichiers plus fragile. Avec cette option, les risques ne sont accrus qu’en cas de coupure d’alimentation, le système de fichiers soit irrécupérable quand la machine redémarrera.</p></div><div class=paragraph><p>S’il n’y a que <span class=filename>/usr/obj</span> sur ce système de fichiers, ce n’est alors pas un problème. Si vous avez d’autres données importantes sur ce système de fichiers, assurez-vous que vos sauvegardes soient à jour avant d’activer cette option.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o async /usr/obj</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Comme auparavant, si <span class=filename>/usr/obj</span> ne constitue pas un système de fichiers en soit, remplacez-le dans l’exemple par le nom du point de montage approprié.</p></div></td></tr></tbody></table></div></li></ul></div></div><div class=sect3><h4 id=_que_faire_si_quelque_chose_se_passe_mal>26.7.20. Que faire si quelque chose se passe mal?<a class=anchor href=#_que_faire_si_quelque_chose_se_passe_mal></a></h4><div class=paragraph><p>Soyez absolument sûr que votre environnement ne contient pas des restes de compilation précédentes. Cela est plutôt simple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags -R noschg /usr/obj/usr</span>
<span class=c># rm -rf /usr/obj/usr</span>
<span class=c># cd /usr/src</span>
<span class=c># make cleandir</span>
<span class=c># make cleandir</span></code></pre></div></div><div class=paragraph><p>En effet, <code>make cleandir</code> doit vraiment être exécutée deux fois.</p></div><div class=paragraph><p>Ensuite relancez l’ensemble du processus, en commençant avec <code>make buildworld</code>.</p></div><div class=paragraph><p>Si vous avez toujours des problèmes, envoyez l’erreur et le résultat de la commande <code>uname -a</code> à la <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>liste de diffusion pour les questions d’ordre général à propos de FreeBSD</a>. Tenez-vous prêt à répondre à d’autres concernant votre configuration!</p></div></div></div><div class=sect2><h3 id=small-lan>26.8. Suivre les mises à jour pour plusieurs machines<a class=anchor href=#small-lan></a></h3><div class=paragraph><p>Si vous avez plusieurs machines dont vous voulez maintenir à jour l’arborescence des sources, alors faire télécharger et recompiler à chacune d’entre elles les sources semble un gaspillage de ressources: espace disque, bande passante réseau, et cycles CPU. C’est en effet bien le cas, et la solution est d’avoir une machine qui fait la majeure partie du travail, pendant que le reste des machines montent ce travail par NFS. Cette section décrit une façon de le faire.</p></div><div class=sect3><h4 id=small-lan-preliminaries>26.8.1. Préliminaires<a class=anchor href=#small-lan-preliminaries></a></h4><div class=paragraph><p>Premièrement, identifiez un ensemble de machines qui va utiliser le même ensemble de binaires, que nous appellerons un <em>ensemble de compilation</em>. Chaque machine peut avoir un noyau personnalisé, mais elles exécuteront les mêmes binaires utilisateur du système de base. Dans cet ensemble de machine, choisissez une machine qui sera la <em>machine de compilation</em>. Cela sera la machine sur laquelle le monde et le noyau seront compilés. Idéalement, cela devrait être une machine rapide avec un CPU suffisamment disponible pour exécuter la commande <code>make buildworld</code> et <code>make buildkernel</code>. Vous voudrez également utiliser une <em>machine de test</em>, qui testera les mises à jour logicielles avant d’être utilisées en production. Cela <em>doit</em> être une machine que vous pouvez vous permettre d’avoir hors service pour une longue période. Cela peut être la machine de compilation, mais cela n’est pas obligatoire.</p></div><div class=paragraph><p>Toutes les machines de cet ensemble de compilation doivent monter <span class=filename>/usr/obj</span> et <span class=filename>/usr/src</span> à partir de la même machine, et du même point de montage. Idéalement, ces derniers sont sur deux disques différents sur la machine de compilation, mais peuvent également être montés par NFS sur cette machine. Si vous avez plusieurs ensembles de compilation, <span class=filename>/usr/src</span> devrait être sur une machine de compilation, et monté par NFS sur les autres.</p></div><div class=paragraph><p>Finalement assurez-vous que <span class=filename>/etc/make.conf</span> et <span class=filename>/etc/src.conf</span> sur toutes les machines de l’ensemble de compilation sont en accord avec la machine de compilation. Cela signifie que la machine de compilation doit compiler toutes les parties du système de base que toute machine de l’ensemble de compilation va installer. De plus, chaque machine de compilation devra avoir son nom de noyau défini avec <code>KERNCONF</code> dans <span class=filename>/etc/make.conf</span>, et la machine de compilation devrait tous les lister dans <code>KERNCONF</code>, en listant son noyau en premier. La machine de compilation doit avoir les fichiers de configuration des noyaux de chaque machine dans <span class=filename>/usr/src/sys/arch/conf</span> si elle va compiler leur noyau.</p></div></div><div class=sect3><h4 id=_le_système_de_base>26.8.2. Le système de base<a class=anchor href=#_le_système_de_base></a></h4><div class=paragraph><p>Maintenant que tout est configuré, vous êtes fin prêt pour tout compiler. Compilez le noyau et le monde sur la machine de compilation comme décrit dans la <a href=#make-buildworld>Compiler le nouveau système</a>, mais n’installez rien. La compilation une fois terminée, allez sur la machine de test, et installez le noyau que vous venez juste de compiler. Si la machine monte <span class=filename>/usr/src</span> et <span class=filename>/usr/obj</span> via NFS, quand vous redémarrez en mode mono-utilisateur vous devrez activer le réseau et monter ces répertoires. La méthode la plus simple est de démarrer en mode multi-utilisateur, puis exécutez <code>shutdown now</code> pour passer en mode mono-utilisateur. Une fois à ce niveau, vous pouvez installer le nouveau noyau et monde puis exécuter <code>mergemaster</code> comme vous le feriez habituellement. Une fois cela effectué, redémarrez pour retourner en mode multi-utilisateur pour cette machine.</p></div><div class=paragraph><p>Après que vous soyez certain que tout fonctionne correctement sur la machine de test, utilisez la même procédure pour installer le nouvel ensemble logiciel sur chacune des autres machines de l’ensemble de compilation.</p></div></div><div class=sect3><h4 id=_les_logiciels_portés>26.8.3. Les logiciels portés<a class=anchor href=#_les_logiciels_portés></a></h4><div class=paragraph><p>La même idée peut être utilisée pour le catalogue des logiciels portés. La première étape critique est de monter <span class=filename>/usr/ports</span> depuis la même machine vers toutes les machines de l’ensemble de compilation. Vous pouvez alors configurer correctement <span class=filename>/etc/make.conf</span> pour partager les archives. Vous devrez faire pointer <code>DISTDIR</code> sur un répertoire de partage commun dans lequel peut écrire n’importe quel utilisateur utilisé pour correspondance de l’utilisateur <code>root</code> par vos montages NFS. Chaque machine devrait faire pointer <code>WRKDIRPREFIX</code> sur une répertoire de compilation local. Et enfin, si vous projetez de compiler et distribuer des logiciels précompilés, vous devriez fixer <code>PACKAGES</code> sur un répertoire similaire à <code>DISTDIR</code>.</p></div></div></div></div></div><div class=sect1><h2 id=dtrace>Chapitre 27. DTrace<a class=anchor href=#dtrace></a></h2><div class=sectionbody><div class=sect2><h3 id=dtrace-synopsis>27.1. Synopsis<a class=anchor href=#dtrace-synopsis></a></h3><div class=paragraph><p>DTrace, également désigné sous le nom de système de trace dynamique, a été développé par Sun™ comme outil de localisation de problèmes de performance sur des systèmes de production et d’avant-production. Ce n’est, en aucune manière, un outil de débogage, mais un outil pour l’analyse système en temps réel pour localiser les problèmes de performance et autres.</p></div><div class=paragraph><p>DTrace est un outil de profilage remarquable, avec une impressionnante multitude de fonctions pour diagnostiquer des problèmes système. Il peut également être utilisé avec des scripts pré-écrits pour pouvoir profiter de ses capacités. Les utilisateurs peuvent écrire leurs propres utilitaires en employant le langage de DTrace, D, leur permettant ainsi de personnaliser leur profilage en fonction de leurs besoins.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Ce qu’est DTrace et quelles fonctionnalités il offre.</p></li><li><p>Les différences entre la version DTrace de Solaris™ et celle fournie par FreeBSD.</p></li><li><p>Comment activer et utiliser DTrace sur FreeBSD.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les fondements d’UNIX® et de FreeBSD (<a href=./#basics>Quelques bases d’UNIX</a>).</p></li><li><p>Etre familier avec la configuration/compilation du noyau (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li><li><p>Avoir une certaine connaissance concernant la sécurité et ses liens avec FreeBSD (<a href=./#security>Sécurité</a>).</p></li><li><p>Comprendre comment obtenir et recompiler les sources de FreeBSD (<a href=./#updating-upgrading>Mise à jour de FreeBSD</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Cette fonction est considérée comme expérimentale. Quelques options peuvent être absentes et d’autres ne fonctionneront peut-être pas du tout. A terme, cette fonction sera prête pour une utilisation en production, et cette documentation sera modifiée pour en tenir compte.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=dtrace-implementation>27.2. Des différences de mise en oeuvre<a class=anchor href=#dtrace-implementation></a></h3><div class=paragraph><p>Bien que DTrace sous FreeBSD soit très semblable à DTrace sous Solaris™, des différences existent et devraient être expliquées avant de continuer. La différence principale que les utilisateurs remarqueront est que sur FreeBSD, DTrace doit être spécialement activé. Il y a des options de noyau et des modules qui doivent être activés pour que DTrace fonctionne correctement. Ces options seront expliquées plus tard.</p></div><div class=paragraph><p>Il existe une option de noyau, <code>DDB_CTF</code>, qui est employée pour activer la prise en charge du chargement des données CTF depuis les modules de noyau et du noyau lui-même. CTF est le format Compact C de Solaris™, qui encapsule une forme réduite d’information de débogage, semblable à DWARF et ses vénérables tables de symboles. Ces données CTF sont ajoutées aux fichiers binaires par les outils de compilation <code>ctfconvert</code> et <code>ctfmerge</code>. L’utilitaire <code>ctfconvert</code> analyse les sections de débogage ELFDWARF crées par le compilateur et <code>ctfmerge</code> fusionne les sections ELFCTF qui sont sous forme objet vers soit des fichiers executables, soit des bibliothèques partagées. Plus d’informations sur comment activer cela pour le noyau et FreeBSD est à venir.</p></div><div class=paragraph><p>Quelques fournisseurs différents existent pour FreeBSD par rapport à Solaris™. Le plus notable est le fournisseur <code>dtmalloc</code>, qui permet le traçage de la fonction <code>malloc()</code> par type dans le noyau FreeBSD.</p></div><div class=paragraph><p>Seul l’utilisateur <code>root</code> peut utiliser DTrace sur FreeBSD. Ceci est lié aux différences de sécurité, Solaris™ dispose de quelques contrôles de sécurité de bas niveau qui n’existent pas encore sur FreeBSD. Ainsi <span class=filename>/dev/dtrace/dtrace</span> est strictement limité uniquement à l’utilisateur <code>root</code>.</p></div><div class=paragraph><p>Pour terminer, le logiciel DTrace est sous la licence de Sun™, CDDL. La <code>Common Development and Distribution License</code> est disponibles sous FreeBSD, voir le fichier <span class=filename>/usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE</span> ou vous pouvez le consulter sur Internet à <a href=http://www.opensolaris.org/os/licensing>http://www.opensolaris.org/os/licensing</a>.</p></div><div class=paragraph><p>Cette licence signifie qu’un noyau avec les options DTrace est toujours sous licence BSD; cependant, la licence CDDL est appliquée lorsque les modules sont distribués sous format binaire, ou quand les fichiers binaires sont chargés.</p></div></div><div class=sect2><h3 id=dtrace-enable>27.3. Activer la prise en charge de DTrace<a class=anchor href=#dtrace-enable></a></h3><div class=paragraph><p>Pour activer DTrace, il faut ajouter les lignes suivantes au fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_HOOKS
options         DDB_CTF</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les utilisateurs de l’architecture AMD64 devraient ajouter la ligne suivante à leur fichier de configuration de noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_FRAME</pre></div></div><div class=paragraph><p>Cette option active la fonction FBT. DTrace fonctionnera sans cette option, mais il y aura des restrictions sur le traçage des limites des fonctions.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Les sources doivent être recompilées et installées avec les options CTF. Pour faire cela, recompiler les sources de FreeBSD en utilisant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>

<span class=c># make WITH_CTF=1 kernel</span></code></pre></div></div><div class=paragraph><p>Le système aura besoin d’être redémarré.</p></div><div class=paragraph><p>Après avoir redémarré et avoir laissé charger en mémoire le noyau, le support de l’interpréteur de commandes Korn devra être ajouté. Ceci est necessaire car la boîte à outils DTrace possède quelques utilitaires écrits en <code>ksh</code>. Il faut installer <a class=package href=https://cgit.freebsd.org/ports/tree/shells/ksh93/>shells/ksh93</a>. Il est également possible de faire fonctionner ces outils avec <a class=package href=https://cgit.freebsd.org/ports/tree/shells/pdksh/>shells/pdksh</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/shells/mksh/>shells/mksh</a>.</p></div><div class=paragraph><p>Finalement, récupérer la boîte à outils DTrace la plus récente. La version actuelle est disponible à l’adresse <a href=http://www.opensolaris.org/os/community/dtrace/>http://www.opensolaris.org/os/community/dtrace/</a>. Un système d’installation est inclu dans l’archive; cependant, cette installation n’est pas obligatoire pour utiliser les outils fournis.</p></div></div><div class=sect2><h3 id=dtrace-using>27.4. Utiliser DTrace<a class=anchor href=#dtrace-using></a></h3><div class=paragraph><p>Avant d’utiliser DTrace, il faut que le périphérique DTrace existe. Pour charger le périphérique, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload dtraceall</span></code></pre></div></div><div class=paragraph><p>Le système devrait maintenant supporter DTrace. Pour afficher toutes les sondes, l’administrateur peut maintenant executer la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dtrace -l | more</span></code></pre></div></div><div class=paragraph><p>Toutes les données sortantes de cette commande sont passées à l’utilitaire <code>more</code>, pour empêcher qu’elles saturent l’écran. A ce niveau, DTrace peut être considéré comme fonctionnel. On est maintenant prêt à passer en revue l’ensemble des outils disponibles.</p></div><div class=paragraph><p>La boîte à outils est une collection de scripts prêts à fonctionner avec DTrace pour rassembler des informations systèmes. Il y a des scripts pour vérifier les fichiers ouvertes, la mémoire, l’usage du CPU et beaucoup plus. Il faut extraire les scripts avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gunzip -c DTracetoolkit* | tar xvf -</span></code></pre></div></div><div class=paragraph><p>Aller dans ce répértoire en utilisant <code>cd</code> et changer les permissions de tous les fichiers, les fichiers avec les noms en miniscules, à <code>755</code>.</p></div><div class=paragraph><p>Chacun de ces scripts devra avoir son contenu modifié. Ceux qui font référence à <span class=filename>/usr/bin/ksh</span> devront pointer sur <span class=filename>/usr/local/bin/ksh</span>, les autres qui utilisent <span class=filename>/usr/bin/sh</span> devront être modifiés pour qu’ils utilisent <span class=filename>/bin/sh</span>, et finalement ceux qui utilisent <span class=filename>/usr/bin/perl</span>, devront pointer sur <span class=filename>/usr/local/bin/perl</span>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>A ce point il est prudent de rappeler au lecteur que le support de DTrace sous FreeBSD <em>n’est pas complet</em> et est encore <em>expérimental</em>. Un bon nombre de ces scripts ne fonctionneront pas, soit parce qu’ils sont trop spécifiques à Solaris™, soit parce qu’ils utilisent des sondes qui ne sont pas encore supportées.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Au moment de l’écriture de ces lignes, seuls deux des scripts de la boîte à outils DTrace sont totalement supportés sous FreeBSD: les outils <span class=filename>hotkernel</span> et <span class=filename>procsystime</span>. Ce sont ces deux outils que nous détaillerons dans la suite de cette section.</p></div><div class=paragraph><p>L’outil <span class=filename>hotkernel</span> est censé identifier quel fonction utilise le plus de temps noyau. Fonctionnant normalement, il affichera une liste comparable à la suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./hotkernel</span>
Sampling... Hit Ctrl-C to end.</code></pre></div></div><div class=paragraph><p>L’administrateur système doit utiliser la combinaison de touches <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span> pour arrêter le processus. Le script affichera une liste de fonctions du noyau et des informations de temps, et les triera dans l’ordre croissant du temps consommé:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kernel<span class=sb>`</span>_thread_lock_flags                                   2   0.0%
0xc1097063                                                  2   0.0%
kernel<span class=sb>`</span>sched_userret                                        2   0.0%
kernel<span class=sb>`</span>kern_select                                          2   0.0%
kernel<span class=sb>`</span>generic_copyin                                       3   0.0%
kernel<span class=sb>`</span>_mtx_assert                                          3   0.0%
kernel<span class=sb>`</span>vm_fault                                             3   0.0%
kernel<span class=sb>`</span>sopoll_generic                                       3   0.0%
kernel<span class=sb>`</span>fixup_filename                                       4   0.0%
kernel<span class=sb>`</span>_isitmyx                                             4   0.0%
kernel<span class=sb>`</span>find_instance                                        4   0.0%
kernel<span class=sb>`</span>_mtx_unlock_flags                                    5   0.0%
kernel<span class=sb>`</span>syscall                                              5   0.0%
kernel<span class=sb>`</span>DELAY                                                5   0.0%
0xc108a253                                                  6   0.0%
kernel<span class=sb>`</span>witness_lock                                         7   0.0%
kernel<span class=sb>`</span>read_aux_data_no_wait                                7   0.0%
kernel<span class=sb>`</span>Xint0x80_syscall                                     7   0.0%
kernel<span class=sb>`</span>witness_checkorder                                   7   0.0%
kernel<span class=sb>`</span>sse2_pagezero                                        8   0.0%
kernel<span class=sb>`</span>strncmp                                              9   0.0%
kernel<span class=sb>`</span>spinlock_exit                                       10   0.0%
kernel<span class=sb>`</span>_mtx_lock_flags                                     11   0.0%
kernel<span class=sb>`</span>witness_unlock                                      15   0.0%
kernel<span class=sb>`</span>sched_idletd                                       137   0.3%
0xc10981a5                                              42139  99.3%</code></pre></div></div><div class=paragraph><p>Ce script fonctionnera aussi avec des modules de noyau. Pour utiliser ce fonction, exécutez le script avec l’option <code>-m</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./hotkernel -m</span>
Sampling... Hit Ctrl-C to end.
^C
MODULE                                                  COUNT   PCNT
0xc107882e                                                  1   0.0%
0xc10e6aa4                                                  1   0.0%
0xc1076983                                                  1   0.0%
0xc109708a                                                  1   0.0%
0xc1075a5d                                                  1   0.0%
0xc1077325                                                  1   0.0%
0xc108a245                                                  1   0.0%
0xc107730d                                                  1   0.0%
0xc1097063                                                  2   0.0%
0xc108a253                                                 73   0.0%
kernel                                                    874   0.4%
0xc10981a5                                             213781  99.6%</code></pre></div></div><div class=paragraph><p>Le script <span class=filename>procsystime</span> capture et affiche le temps consommé en appels système pour un PID ou un processus donné. Dans l’exemple suivant, un nouvel exemplaire de <span class=filename>/bin/csh</span> a été lancé. L’outil <span class=filename>procsystime</span> a été exécuté et laissé en attente pendant que quelques commandes été tapées sur les autres incarnations de <code>csh</code>. Voici le résultat de ce test:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./procsystime -n csh</span>
Tracing... Hit Ctrl-C to end...
^C

Elapsed Times <span class=k>for </span>processes csh,

         SYSCALL          TIME <span class=o>(</span>ns<span class=o>)</span>
          getpid               6131
       sigreturn               8121
           close              19127
           fcntl              19959
             dup              26955
         setpgid              28070
            <span class=nb>stat              </span>31899
       setitimer              40938
           wait4              62717
       sigaction              67372
     sigprocmask             119091
    gettimeofday             183710
           write             263242
          execve             492547
           ioctl             770073
           vfork            3258923
      sigsuspend            6985124
            <span class=nb>read         </span>3988049784</code></pre></div></div><div class=paragraph><p>Comme indiqué, l’appel système <code>read()</code> semble prendre le plus de temps en nanosecondes, alors que l’appel système <code>getpid()</code> prend très peu de temps.</p></div></div><div class=sect2><h3 id=dtrace-language>27.5. Le langage D<a class=anchor href=#dtrace-language></a></h3><div class=paragraph><p>La boîte à outils DTrace comprend plusieurs scripts écrits dans le langage spécifique de DTrace. Ce langage est appelé le "langage D" dans la documentation de Sun™, et est très proche du C++. Une étude en profondeur de ce langage sort du cadre de ce document. Il est abordé de manière très détaillée à l’adresse <a href=http://wikis.sun.com/display/DTrace/Documentation>http://wikis.sun.com/display/DTrace/Documentation</a>.</p></div></div></div></div><h1 id=network-communication class=sect0>Partie IV: Réseau<a class=anchor href=#network-communication></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>FreeBSD est un des systèmes d’exploitation les plus utilisé pour les serveurs réseau à hautes performances. Les chapitres de cette partie abordent:</p></div><div class=ulist><ul><li><p>les communications série</p></li><li><p>PPP et PPP sur Ethernet</p></li><li><p>le courrier électronique</p></li><li><p>l’exécution de serveurs réseau</p></li><li><p>les coupe-feux</p></li><li><p>d’autres sujets réseau avancés</p></li></ul></div><div class=paragraph><p>Ces chapitres sont destinés à être lus quand une information est nécessaire. Il n’est pas utile de les lire suivant un ordre particulier, ni de tous les lire avant de pouvoir utiliser FreeBSD dans un environnement réseau.</p></div></div></div><div class=sect1><h2 id=serialcomms>Chapitre 28. Serial Communications <strong>Traduction en Cours </strong><a class=anchor href=#serialcomms></a></h2><div class=sectionbody><div class=sect2><h3 id=serial-synopsis>28.1. Synopsis<a class=anchor href=#serial-synopsis></a></h3></div><div class=sect2><h3 id=serial>28.2. Introduction<a class=anchor href=#serial></a></h3><div class=sect3><h4 id=serial-terminology>28.2.1. Terminology<a class=anchor href=#serial-terminology></a></h4></div><div class=sect3><h4 id=serial-cables-ports>28.2.2. Cables and Ports<a class=anchor href=#serial-cables-ports></a></h4><div class=sect4><h5 id=term-cables>28.2.2.1. Cables<a class=anchor href=#term-cables></a></h5><div class=sect5><h6 id=term-cables-null>28.2.2.1.1. Null-modem Cables<a class=anchor href=#term-cables-null></a></h6></div></div></div></div><div class=sect2><h3 id=term>28.3. Terminals<a class=anchor href=#term></a></h3><div class=sect3><h4 id=term-uses>28.3.1. Uses and Types of Terminals<a class=anchor href=#term-uses></a></h4></div><div class=sect3><h4 id=term-config>28.3.2. Configuration<a class=anchor href=#term-config></a></h4><div class=sect4><h5 id=term-etcttys>28.3.2.1. Adding an Entry to <span class=filename>/etc/ttys</span><a class=anchor href=#term-etcttys></a></h5></div><div class=sect4><h5 id=term-hup>28.3.2.2. Force <code>init</code> to Reread <span class=filename>/etc/ttys</span><a class=anchor href=#term-hup></a></h5></div></div><div class=sect3><h4 id=term-debug>28.3.3. Troubleshooting Your Connection<a class=anchor href=#term-debug></a></h4></div></div><div class=sect2><h3 id=dialup>28.4. Dial-in Service<a class=anchor href=#dialup></a></h3></div><div class=sect2><h3 id=dialout>28.5. Dial-out Service<a class=anchor href=#dialout></a></h3></div><div class=sect2><h3 id=serialconsole-setup>28.6. Setting Up the Serial Console<a class=anchor href=#serialconsole-setup></a></h3><div class=sect3><h4 id=serialconsole-tips>28.6.1. Tips for the Serial Console<a class=anchor href=#serialconsole-tips></a></h4><div class=sect4><h5 id=serialconsole-ddb>28.6.1.1. Entering the DDB Debugger from the Serial Line<a class=anchor href=#serialconsole-ddb></a></h5></div></div></div></div></div><div class=sect1><h2 id=ppp-and-slip>Chapitre 29. PPP et SLIP<a class=anchor href=#ppp-and-slip></a></h2><div class=sectionbody><div class=sect2><h3 id=ppp-and-slip-synopsis>29.1. Synopsis<a class=anchor href=#ppp-and-slip-synopsis></a></h3><div class=paragraph><p>FreeBSD dispose de nombreuses façons pour relier un ordinateur à un autre. Pour mettre en place un réseau ou établir une connexion Internet par l’intermédiaire d’un modem, ou pour autoriser d’autres à le faire par votre intermédiaire, il est nécessaire d’utiliser PPP ou SLIP. Ce chapitre décrit la configuration en détail de ces services de communication par modem.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous saurez:</p></div><div class=ulist><ul><li><p>Comment configurer PPP en mode utilisateur.</p></li><li><p>Comment configurer PPP intégré au noyau.</p></li><li><p>Comment configurer PPPoE (PPP sur Ethernet).</p></li><li><p>Comment configurer PPPoA (PPP sur ATM).</p></li><li><p>Comment configurer et utiliser un client et un serveur SLIP.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Etre familier avec la terminologie réseau de base.</p></li><li><p>Comprendre les bases, le but d’une connexion entrante par modem, et PPP et/ou SLIP.</p></li></ul></div><div class=paragraph><p>Vous pouvez vous demander quelle est la principale différence entre PPP en mode utilisateur et PPP intégré au noyau. La réponse est simple: PPP en mode utilisateur traite les données entrantes et sortantes en dehors du noyau. C’est coûteux en terme de copie de donnée entre le noyau et l’espace utilisateur mais permet l’implémentation de plus de fonctionnalités PPP. PPP en mode utilisateur utilise le périphérique <span class=filename>tun</span> pour communiquer avec le monde extérieur alors que PPP intégré au noyau utilise le périphérique <span class=filename>ppp</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans ce chapitre, le programme utilisateur PPP sera simplement appelé ppp, à moins qu’il faille explicitement faire la distinction entre lui et d’autres logiciels PPP comme pppd. Sauf indications contraires, toutes les commandes mentionnées dans ce chapitre doivent être exécutées par le super-utilisateur <code>root</code>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=userppp>29.2. Using User PPP <strong>Traduction en Cours </strong><a class=anchor href=#userppp></a></h3></div><div class=sect2><h3 id=ppp>29.3. Utiliser PPP intégré au noyau<a class=anchor href=#ppp></a></h3><div class=sect3><h4 id=_configurer_ppp_intégré_au_noyau>29.3.1. Configurer PPP intégré au noyau<a class=anchor href=#_configurer_ppp_intégré_au_noyau></a></h4><div class=paragraph><p>Avant de configurer PPP sur votre machine, vérifiez que <code>pppd</code> est bien dans le répertoire <span class=filename>/usr/sbin</span> et que le répertoire <span class=filename>/etc/ppp</span> existe.</p></div><div class=paragraph><p>La commande <code>pppd</code> peut fonctionner selon deux modes:</p></div><div class="olist arabic"><ol class=arabic><li><p>Comme "client" - si vous désirez connecter votre machine au monde extérieur via une liaison PPP série ou un modem.</p></li><li><p>Comme "serveur" - si votre machine est sur le réseau, et sert à y connecter d’autres ordinateurs avec PPP.</p></li></ol></div><div class=paragraph><p>Dans les deux cas, vous devrez renseigner un fichier d’options (<span class=filename>/etc/ppp/options</span> ou <span class=filename>~/.ppprc</span> si vous avez plus d’un utilisateur sur votre machine utilisant PPP).</p></div><div class=paragraph><p>Vous aurez également besoin d’un logiciel "modem/série" (de préférence <a class=package href=https://cgit.freebsd.org/ports/tree/comms/kermit/>comms/kermit</a>), pour appeler et établir la connexion avec la machine distante.</p></div></div><div class=sect3><h4 id=_utiliser_pppd_comme_client>29.3.2. Utiliser <code>pppd</code> comme client<a class=anchor href=#_utiliser_pppd_comme_client></a></h4><div class=paragraph><p>Le fichier <span class=filename>/etc/ppp/options</span> suivant pourrait être utilisé pour se connecter à la liaison PPP d’un concentrateur Cisco:</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts         # contrôle de flux matériel
modem           # liaison par modem
noipdefault     # adresse IP affectée par le serveur PPP distant
                # si la machine distante ne vous donne pas d&#39;adresse
                # IP lors de la négociation IPCP, retirez cette option
passive         # attendre les paquets LCP
domain ppp.foo.com      # mettre ici votre nom de domaine

:remote_ip    # mettre ici l&#39;adresse IP de la machine PPP distante
                # elle servira à router des paquets via la liaison PPP
                # si vous n&#39;avez pas précisé l&#39;option noipdefault
                # changez cette ligne en ip_locale:ip_distante

defaultroute    # mettre cette ligne si vous voulez que le serveur PPP soit
                # votre routeur par défaut</pre></div></div><div class=paragraph><p>Pour se connecter:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Appelez la machine distante en utilisant kermit (ou un autre programme pour modem), puis entrez votre nom d’utilisateur et mot de passe (ou ce qu’il faut pour activer PPP sur la machine distante).</p></li><li><p>Quittez kermit (sans raccrocher la ligne).</p></li><li><p>Entrez la commande suivante:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/src/usr.sbin/pppd.new/pppd /dev/tty01 19200</span></code></pre></div></div><div class=paragraph><p>Assurez-vous d’utiliser la vitesse et le nom de périphérique adéquats.</p></div></li></ol></div></div></div><div class=paragraph><p>Votre ordinateur est maintenant connecté via PPP. Si la connexion échoue, vous pouvez ajouter l’option <code>debug</code> au fichier <span class=filename>/etc/ppp/options</span>, et consulter les messages sur la console pour tracer le problème.</p></div><div class=paragraph><p>La procédure <span class=filename>/etc/ppp/pppup</span> ci-dessous effectuera automatiquement ces trois étapes:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;arrêt de pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;arrêt de kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p><span class=filename>/etc/ppp/kermit.dial</span> est une procédure kermit qui appelle et fournit toutes les informations d’authentification nécessaires à la machine distante (un exemple d’une telle procédure est donné à la fin de ce document).</p></div><div class=paragraph><p>Utilisez la procédure <span class=filename>/etc/ppp/pppdown</span> suivante pour terminer la session PPP et vous déconnecter:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;arrêt de pppd, PID=&#39; ${pid}
        kill -TERM ${pid}
fi

ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;arrêt de kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

/sbin/ifconfig ppp0 down
/sbin/ifconfig ppp0 delete
kermit -y /etc/ppp/kermit.hup
/etc/ppp/ppptest</pre></div></div><div class=paragraph><p>Vérifiez si <code>pppd</code> tourne toujours en lançant la procédure <span class=filename>/usr/etc/ppp/ppptest</span>, qui devrait ressembler à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`ps ax| grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;pppd actif: PID=&#39; ${pid-NONE}
else
        echo &#39;Pas de pppd en cours d&#39;exécution.&#39;
fi
set -x
netstat -n -I ppp0
ifconfig ppp0</pre></div></div><div class=paragraph><p>Pour raccrocher la ligne, exécutez <span class=filename>/etc/ppp/kermit.hup</span>, qui devrait contenir:</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01	; mettre ici le périphérique pour votre modem
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
echo \13
exit</pre></div></div><div class=paragraph><p>Voici une autre méthode qui utilise <code>chat</code> au lieu de <code>kermit</code>.</p></div><div class=paragraph><p>Les deux fichiers suivants suffisent à établir une connexion avec <code>pppd</code>.</p></div><div class=paragraph><p><span class=filename>/etc/ppp/options</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/cuaa1 115200

crtscts		# contrôle de flux matériel
modem		# liaison par modem
connect &#34;/usr/bin/chat -f /etc/ppp/login.chat.script&#34;
noipdefault	# adresse IP affectée par le serveur PPP distant
	        # si la machine distante ne vous donne pas d&#39;adresse
	        # IP lors de la négociation IPCP, retirer cette option
passive	        # attendre les paquets LCP
domain your.domain	# mettre ici votre nom de domaine

:	        # mettre ici l&#39;adresse IP de la machine PPP distante
	        # elle servira à router des paquets via la liaison PPP
	        # si vous n&#39;avez pas précisé l&#39;option noipdefault
	        # modifier cette ligne en ip_locale:ip_distante

defaultroute	# mettre cette ligne si vous voulez que le serveur PPP soit
	        # votre routeur par défaut</pre></div></div><div class=paragraph><p><span class=filename>/etc/ppp/login.chat.script</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ce qui suit doit être tapé sur une seule ligne.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ABORT BUSY ABORT &#39;NO CARRIER&#39; &#34;&#34; AT OK ATDTnuméro_de_téléphone
  CONNECT &#34;&#34; TIMEOUT 10 ogin:-\\r-ogin: nom_d_utilisateur
  TIMEOUT 5 sword: mot_de_passe</pre></div></div><div class=paragraph><p>Une fois que ces fichiers sont installés et correctement modifiés, tout ce dont vous avez besoin de faire est de lancer <code>pppd</code>, comme suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pppd</span></code></pre></div></div></div><div class=sect3><h4 id=_utiliser_pppd_comme_serveur>29.3.3. Utiliser <code>pppd</code> comme serveur<a class=anchor href=#_utiliser_pppd_comme_serveur></a></h4><div class=paragraph><p>Le contenu du fichier <span class=filename>/etc/ppp/options</span> devrait être semblable à ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts                         # contrôle de flux matériel
netmask 255.255.255.0           # masque de sous-réseau (facultatif)
192.114.208.20:192.114.208.165  # adresses IP des machines locales et distantes
                                # l&#39;adresse locale ne doit pas être la même que
                                # celle que vous avez assignée à l&#39;interface
                                # Ethernet (ou autre) de la machine.
                                # l&#39;adresse IP de la machine distante est
                                # l&#39;adresse IP qui lui sera affectée
domain ppp.foo.com              # votre nom de domaine
passive                         # attendre LCP
modem                           # liaison modem</pre></div></div><div class=paragraph><p>La procédure <span class=filename>/etc/ppp/pppserv</span> ci-dessous demandera à pppd de se comporter comme un serveur:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;arrêt de pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;arrêt de kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

# réinitialiser l&#39;interface ppp
ifconfig ppp0 down
ifconfig ppp0 delete

# activer le mode réponse automatique
kermit -y /etc/ppp/kermit.ans

# lancer ppp
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p>Utilisez cette procédure <span class=filename>/etc/ppp/pppservdown</span> pour arrêter le serveur:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;arrêt de pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;arrêt de kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi
ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.noans</pre></div></div><div class=paragraph><p>La procédure kermit ci-dessous (<span class=filename>/etc/ppp/kermit.ans</span>) activera ou désactivera le mode réponse automatique de votre modem:</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
inp 5 OK
echo \13
out ATS0=1\13   ; remplacer cela par ATS0=0\13 si vous voulez désactiver
                ; le mode réponse automatique
inp 5 OK
echo \13
exit</pre></div></div><div class=paragraph><p>Une procédure nommée <span class=filename>/etc/ppp/kermit.dial</span> est utilisée pour appeler et s’authentifier sur la machine distante. Vous devrez l’adapter à vos besoins. Mettez-y votre nom d’utilisateur et votre mot de passe; vous devrez également modifier les entrées en fonctions des réponses que vous envoient votre modem et la machine distante.</p></div><div class="literalblock programlisting"><div class=content><pre>;
; mettre ici la liaison série à laquelle est raccordé le modem:
;
set line /dev/tty01
;
; mettre ici la vitesse du modem:
;
set speed 19200
set file type binary            ; transfert 8 bits
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none
set modem hayes
set dial hangup off
set carrier auto                ; puis SET CARRIER si nécessaire,
set dial display on             ; puis SET DIAL si nécessaire,
set input echo on
set input timeout proceed
set input case ignore
def \%x 0                       ; compteur d&#39;ouverture de session
goto slhup

:slcmd                          ; mettre le modem en mode commande
echo Put the modem in command mode.
clear                           ; vider le tampon d&#39;entrée
pause 1
output +++                      ; séquence d&#39;échappement Hayes
input 1 OK\13\10                ; attendre OK
if success goto slhup
output \13
pause 1
output at\13
input 1 OK\13\10
if fail goto slcmd              ; si le modem ne répond pas OK, réessayer

:slhup                          ; raccrocher la ligne
clear                           ; vider le tampon d&#39;entrée
pause 1
echo Hanging up the phone.
output ath0\13                  ; commande Hayes pour raccrocher
input 2 OK\13\10
if fail goto slcmd              ; si pas de réponse OK, passer le modem en mode commande

:sldial                         ; composer le numéro
pause 1
echo Dialing.
output atdt9,550311\13\10       ; mettre ici le numéro de téléphone
assign \%x 0                    ; mettre le compteur à zéro

:look
clear                           ; vider le tampon d&#39;entrée
increment \%x                   ; compter les secondes
input 1 {CONNECT }
if success goto sllogin
reinput 1 {NO CARRIER\13\10}
if success goto sldial
reinput 1 {NO DIALTONE\13\10}
if success goto slnodial
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if  \%x 60 goto look
else goto slhup

:sllogin                        ; ouverture de session
assign \%x 0                    ; mettre le compteur à zéro
pause 1
echo Looking for login prompt.

:slloop
increment \%x                   ; compter les secondes
clear                           ; vider le tampon d&#39;entrée
output \13
;
; put your expected login prompt here:
;
input 1 {Username: }
if success goto sluid
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if  \%x 10 goto slloop         ; essayer 10 fois d&#39;obtenir une invite de session
else goto slhup                 ; raccrocher et recommencer après 10 échecs

:sluid
;
; mettre ici votre nom d&#39;utilisateur:
;
output nom-d-utilisateur-ppp\13
input 1 {Password: }
;
; mettre ici votre mot de passe:
;
output mot-de-passe-ppp\13
input 1 {Entering SLIP mode.}
echo
quit

:slnodial
echo \7Pas de tonalité.  Vérifiez votre ligne téléphonique!\7
exit 1

; local variables:
; mode: csh
; comment-start: &#34;; &#34;
; comment-start-skip: &#34;; &#34;
; end:</pre></div></div></div></div><div class=sect2><h3 id=pppoe>29.4. Utiliser PPP sur Ethernet (PPPoE)<a class=anchor href=#pppoe></a></h3><div class=paragraph><p>Cette section décrit comment configurer PPP sur Ethernet (PPPoE).</p></div><div class=sect3><h4 id=_configuration_du_noyau_2>29.4.1. Configuration du noyau<a class=anchor href=#_configuration_du_noyau_2></a></h4><div class=paragraph><p>Il n’est plus du tout nécessaire de configurer le noyau pour utiliser PPPoE. Si le support netgraph nécessaire n’est pas compilé dans le noyau, il sera chargé dynamiquement par ppp.</p></div></div><div class=sect3><h4 id=_renseigner_ppp_conf>29.4.2. Renseigner <span class=filename>ppp.conf</span><a class=anchor href=#_renseigner_ppp_conf></a></h4><div class=paragraph><p>Voici un exemple de fichier <span class=filename>ppp.conf</span> opérationnel:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set log Phase tun command # vous pouvez détailler plus les traces si vous le désirez
  set ifaddr 10.0.0.1/0 10.0.0.2/0

nom_du_fournisseur_d&#39;accès:
  set device PPPoE:xl1 # remplacez xl1 par votre périphérique Ethernet
  set authname VOTRENOMDUTILISATEUR
  set authkey VOTREMOTDEPASSE
  set dial
  set login
  add default HISADDR</pre></div></div></div><div class=sect3><h4 id=_exécuter_ppp>29.4.3. Exécuter ppp<a class=anchor href=#_exécuter_ppp></a></h4><div class=paragraph><p>En tant que <code>root</code>, vous pouvez lancer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -ddial nom_du_fournisseur_d&#39;accès</span></code></pre></div></div></div><div class=sect3><h4 id=_lancer_ppp_au_démarrage>29.4.4. Lancer ppp au démarrage<a class=anchor href=#_lancer_ppp_au_démarrage></a></h4><div class=paragraph><p>Ajoutez ce qui suit à votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;	# si vous voulez activer NAT pour votre réseau local, sinon NO
ppp_profile=&#34;nom_du_fournisseur_d&#39;accès&#34;</pre></div></div></div><div class=sect3><h4 id=_utilisation_dune_étiquette_de_service_pppoe>29.4.5. Utilisation d’une étiquette de service PPPoE<a class=anchor href=#_utilisation_dune_étiquette_de_service_pppoe></a></h4><div class=paragraph><p>Parfois il sera nécessaire d’utiliser une étiquette de service pour établir votre connexion. Les étiquettes de service sont employées pour faire la distinction entre différents serveurs PPPoE attachés à un réseau donné.</p></div><div class=paragraph><p>Vous devez avoir l’information concernant l’étiquette de service dans la documentation fournie par votre fournisseur d’accès. Si vous ne pouvez la trouver, contactez le support technique de votre fournisseur d’accès Internet.</p></div><div class=paragraph><p>En dernier ressort, vous pourrez essayer la méthode suggérée par le programme <a href=http://www.roaringpenguin.com/pppoe/>Roaring Penguin PPPoE</a> qui peut-être trouvé dans le <a href=./#ports>catalogue des logiciels portés</a>. Gardez cependant à l’esprit, que cela peut déprogrammer votre modem et le rendre inutilisable, aussi réfléchissez à deux fois avant de le faire. Installez simplement le logiciel fourni avec le modem par votre fournisseur d’accès. Ensuite accédez au menu <b class=menuref>Système</b> du programme. Le nom de votre profil devrait y figurer. C’est habituellement le nom du <em>FAI</em>.</p></div><div class=paragraph><p>Le nom du profil (étiquette de service) sera utilisé dans l’entrée de configuration PPPoE dans le fichier <span class=filename>ppp.conf</span> dans la partie fournisseur d’accès de la commande <code>set device</code> (voir la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> pour plus de détails). Cela devrait ressembler à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>set device PPPoE:xl1:FAI</pre></div></div><div class=paragraph><p>N’oubliez pas de changer <em>xl1</em> pour le périphérique correct correspondant à votre carte Ethernet.</p></div><div class=paragraph><p>N’oubliez pas de changer <em>FAI</em> par le profil que vous avez déterminé ci-dessus.</p></div><div class=paragraph><p>Pour une information supplémentaire, consultez:</p></div><div class=ulist><ul><li><p><a href=http://renaud.waldura.com/doc/freebsd/pppoe/>Cheaper Broadband with FreeBSD on DSL</a> par Renaud Waldura.</p></li><li><p><a href=http://www.ruhr.de/home/nathan/FreeBSD/tdsl-freebsd.html>Nutzung von T-DSL und T-Online mit FreeBSD</a> par Udo Erdelhoff (en allemand).</p></li></ul></div></div><div class=sect3><h4 id=ppp-3com>29.4.6. PPPoE avec un modem ADSL 3Com® HomeConnect™ Dual Link<a class=anchor href=#ppp-3com></a></h4><div class=paragraph><p>Ce modem ne respecte pas la <a href=http://www.faqs.org/rfcs/rfc2516.html>RFC 2516</a> (<em>A Method for transmitting PPP over Ethernet (PPPoE)</em>, rédigée par L. Mamakos, K. Lidl, J. Evarts, D. Carrel, D. Simone, et R. Wheeler). Au lieu de cela des codes différents pour les types de paquets sont utilisés pour les frames Ethernet. Veuillez vous plaindre auprès de <a href=http://www.3com.com/>3Com</a> si vous pensez que le modem devrait respecter la spécification PPPoE.</p></div><div class=paragraph><p>Afin de permettre à FreeBSD de communiquer avec ce périphérique, un paramètre sysctl doit être configuré. Cela peut être effectué de manière automatique au démarrage en renseignant le fichier <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.graph.nonstandard_pppoe=1</pre></div></div><div class=paragraph><p>ou peut être paramétré pour prendre immédiatement effet avec la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.graph.nonstandard_pppoe=1</span></code></pre></div></div><div class=paragraph><p>Malheureusement, parce que c’est un paramétrage concernant l’intégralité du système, il n’est pas possible de communiquer en même temps avec un client ou un serveur PPPoE normal et un modem ADSL 3Com® HomeConnect™.</p></div></div></div><div class=sect2><h3 id=pppoa>29.5. Utiliser PPP sur ATM (PPPoA)<a class=anchor href=#pppoa></a></h3><div class=paragraph><p>Ce qui suit décrit comment configurer PPP sur ATM (PPPoA). PPPoA est très populaire parmi les fournisseurs d’accès DSL européens.</p></div><div class=sect3><h4 id=_utiliser_pppoa_avec_le_modem_alcatel_speedtouch_usb>29.5.1. Utiliser PPPoA avec le modem Alcatel SpeedTouch™ USB<a class=anchor href=#_utiliser_pppoa_avec_le_modem_alcatel_speedtouch_usb></a></h4><div class=paragraph><p>Le support PPPoA pour ce périphérique est fourni sous la forme d’un logiciel porté sous FreeBSD car le "firmware" est distribué sous l’<a href=http://www.speedtouchdsl.com/disclaimer_lx.htm>accord de licence d’Alcatel</a> et ne peut être redistribué librement avec le système de base de FreeBSD.</p></div><div class=paragraph><p>Pour installer le logiciel, utilisez simplement le <a href=./#ports>catalogue des logiciels portés</a>. Installez le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/pppoa/>net/pppoa</a> et suivez les instructions fournies avec.</p></div><div class=paragraph><p>Comme de nombreux périphériques, le modem USB Alcatel SpeedTouch™ a besoin de charger un "firmware" à partir de l’ordinateur hôte pour opérer correctement. Il est possible d’automatiser ce processus sous FreeBSD de manière à ce que ce transfert ait lieu dès que le périphérique est branché dans un port USB. L’information suivante peut être ajoutée au fichier <span class=filename>/etc/usbd.conf</span> pour autoriser ce transfert automatique de "firmware". Ce fichier doit être édité en tant que super-utilisateur.</p></div><div class="literalblock programlisting"><div class=content><pre>device &#34;Alcatel SpeedTouch USB&#34;
    devname &#34;ugen[0-9]+&#34;
    vendor 0x06b9
    product 0x4061
    attach &#34;/usr/local/sbin/modem_run -f /usr/local/libdata/mgmt.o&#34;</pre></div></div><div class=paragraph><p>Pour activer le "daemon" USB, usbd, ajoutez la ligne suivante dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>usbd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Il est également possible de paramétrer ppp pour se connecter au démarrage. Pour cela ajoutez les lignes suivantes au fichier <span class=filename>/etc/rc.conf</span>. Encore une fois, vous devrez être attaché sous l’utilisateur <code>root</code> pour effectuer ces ajouts.</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_profile=&#34;adsl&#34;</pre></div></div><div class=paragraph><p>Pour que cela fonctionne correctement, vous devrez utiliser le fichier d’exemple <span class=filename>ppp.conf</span> qui est fourni avec le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/pppoa/>net/pppoa</a>.</p></div></div><div class=sect3><h4 id=_utiliser_mpd>29.5.2. Utiliser mpd<a class=anchor href=#_utiliser_mpd></a></h4><div class=paragraph><p>Vous pouvez utiliser mpd pour vous connecter à différents services, en particulier aux services PPTP. Vous trouverez mpd dans le catalogue des logiciels portés, <a class=package href=https://cgit.freebsd.org/ports/tree/net/mpd/>net/mpd</a>. De nombreux modems ADSL demandent à ce qu’un tunnel PPTP soit créé entre le modem et l’ordinateur, le SpeedTouch™ Home d’Alcatel en fait partie.</p></div><div class=paragraph><p>Vous devez tout d’abord installer le logiciel porté, ensuite vous pouvez configurer mpd selon vos besoins et les paramètres propres au fournisseur d’accès. Le logiciel porté place un ensemble de fichiers de configuration très bien commentés dans le répertoire <span class=filename>PREFIX/etc/mpd/</span>. Notez qu’ici <em>PREFIX</em> représente le répertoire dans lequel les logiciels portés sont installés, par défaut le répertoire <span class=filename>/usr/local/</span>. Un guide complet pour la configuration de mpd est disponible dans le format HTML, une fois que le logiciel a été installé. Il se trouve dans le répertoire <span class=filename>PREFIX/shared/doc/mpd/</span>. Voici un exemple de configuration pour se connecter à un service ADSL à l’aide de mpd. La configuration est séparée en deux fichiers, le premier est <span class=filename>mpd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <i class=conum data-value=1></i><b>(1)</b>
    set bundle password password <i class=conum data-value=2></i><b>(2)</b>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Le nom d’utilisateur utilisé pour vous identifier auprès de votre FAI.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Le mot de passe utilisé pour vous identifier auprès de votre FAI.</td></tr></tbody></table></div><div class=paragraph><p>Le fichier <span class=filename>mpd.links</span> contient les informations concernant la liaison, ou les liaisons, que vous souhaitez établir. En exemple de fichier <span class=filename>mpd.links</span> accompagnant l’exemple précédent est donné ci-dessous:</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <i class=conum data-value=1></i><b>(1)</b>
    set pptp peer 10.0.0.138 <i class=conum data-value=2></i><b>(2)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>L’adresse IP de la machine FreeBSD à partir de laquelle vous utiliserez mpd.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>L’adresse IP de votre modem ADSL. Pour le SpeedTouch™ Home d’Alcatel cette adresse est par défaut <code>10.0.0.138</code>.</td></tr></tbody></table></div><div class=paragraph><p>Il est possible d’initialiser aisément une connexion en tapant la commande suivante en tant que <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpd -b adsl</span></code></pre></div></div><div class=paragraph><p>Vous pouvez voir quel est l’état de votre connexion à l’aide de la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig ng0
ng0: <span class=nv>flags</span><span class=o>=</span>88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt; mtu 1500
     inet 216.136.204.117 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>L’utilisation de mpd est la méthode recommandée de connexion à un service ADSL sous FreeBSD.</p></div></div><div class=sect3><h4 id=_utiliser_pptpclient>29.5.3. Utiliser pptpclient<a class=anchor href=#_utiliser_pptpclient></a></h4><div class=paragraph><p>Il est également possible d’utiliser FreeBSD pour se connecter à d’autres service PPPoA en utilisant <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a>.</p></div><div class=paragraph><p>Pour utiliser <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a> pour vous connecter à un service DSL, installez le logiciel porté ou le paquetage correspondant et éditez votre fichier <span class=filename>/etc/ppp/ppp.conf</span>. Vous aurez besoin des droits de super-utilisateur pour effectuer ces deux opérations. Un exemple de fichier <span class=filename>ppp.conf</span> est donné plus bas. Pour plus d’information sur les options du fichier <span class=filename>ppp.conf</span>, consultez la page de manuel de ppp, <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <i class=conum data-value=1></i><b>(1)</b>
 set authkey password <i class=conum data-value=2></i><b>(2)</b>
 set ifaddr 0 0
 add default HISADDR</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Le nom d’utilisateur de votre compte chez le fournisseur d’accès DSL.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Le mot de passe de votre compte.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Etant donné que vous devez mettre le mot de passe de votre compte en clair dans le fichier <span class=filename>ppp.conf</span>, vous devez vous assurer que personne d’autre ne puisse lire le contenu de ce fichier. La série de commandes suivante s’assurera que ce fichier n’est lisible que par <code>root</code>. Référez-vous aux pages de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a> pour plus d’informations.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:wheel /etc/ppp/ppp.conf</span>
<span class=c># chmod 600 /etc/ppp/ppp.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Cela créera un tunnel pour une session PPP vers votre routeur DSL. Les modems DSL Ethernet ont une adresse IP pour le réseau local pré-configurée à laquelle vous vous connectez. Dans le cas du modem SpeedTouch™ Home d’Alcatel cette adresse est <code>10.0.0.138</code>. La documentation de votre routeur devrait mentionner quelle adresse utilise votre périphérique. Pour créer le tunnel et démarrer une session PPP exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pptp address adsl</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Vous pourrez ajouter un "et commercial" ("") à la fin de la commande précédente car sinon pptp ne vous rendra pas la main.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Un périphérique virtuel de tunnel (<span class=filename>tun</span>) sera créé pour la communication entre les processus pptp et ppp. Une fois retourné à l’invite, ou que le processus pptp a confirmé la connexion, vous pouvez examiner le tunnel de cette manière:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig tun0
tun0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
        inet 216.136.204.21 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffff00
        Opened by PID 918</code></pre></div></div><div class=paragraph><p>Si vous n’êtes pas en mesure de vous connecter, vérifiez la configuration de votre routeur qui est généralement accessible par telnet ou avec un navigateur web. Si le problème persiste, vous devrez examiner la sortie de la commande <code>pptp</code> et le contenu du fichier de trace de ppp, <span class=filename>/var/log/ppp.log</span> à la recherche d’indices.</p></div></div></div><div class=sect2><h3 id=slip>29.6. Utiliser SLIP<a class=anchor href=#slip></a></h3><div class=sect3><h4 id=slipc>29.6.1. Configurer un client SLIP<a class=anchor href=#slipc></a></h4><div class=paragraph><p>Ce qui suit décrit une manière de configurer une machine FreeBSD pour utiliser SLIP sur un réseau où les noms de machine sont statiques. Si le nom de machine est affecté dynamiquement (votre adresse change à chaque connexion), vous devrez probablement utiliser une méthode plus sophistiquée.</p></div><div class=paragraph><p>Tout d’abord, déterminez sur quel port série votre modem est connecté. De nombreuses personnes utilisent un lien symbolique, comme <span class=filename>/dev/modem</span>, pour pointer vers le nom réel du périphérique, <span class=filename>/dev/cuaaN</span> (ou <span class=filename>/dev/cuadN</span> sous FreeBSD 6.X). Ceci vous permet de faire abstraction du véritable nom du périphérique même si vous déplacez le modem vers un autre port. Cela évite le côté pénible de devoir modifier un certain nombre de fichiers dans le répertoire <span class=filename>/etc</span> et les fichiers <span class=filename>.kermrc</span> pour l’ensemble du système!</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/dev/cuaa0</span> (ou <span class=filename>/dev/cuad0</span> sous FreeBSD 6.X) représente <span class=filename>COM1</span>, <span class=filename>cuaa1</span> (ou <span class=filename>/dev/cuad1</span>) <span class=filename>COM2</span>, etc.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Assurez-vous d’avoir dans votre fichier de configuration du noyau ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>device   sl</pre></div></div><div class=paragraph><p>Sous FreeBSD 4.X, utilisez à la place la ligne suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device   sl      1</pre></div></div><div class=paragraph><p>Cette configuration fait partie du noyau <span class=filename>GENERIC</span>, aussi cela ne devrait pas être un problème à moins que vous ne l’ayez effacée.</p></div><div class=sect4><h5 id=_ce_que_vous_naurez_à_faire_quune_seule_fois>29.6.1.1. Ce que vous n’aurez à faire qu’une seule fois<a class=anchor href=#_ce_que_vous_naurez_à_faire_quune_seule_fois></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ajoutez votre machine, la passerelle et les serveurs de noms de domaines à votre fichier <span class=filename>/etc/hosts</span>. Le notre ressemble à ceci:</p><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost loghost
136.152.64.181          water.CS.Example.EDU water.CS water
136.152.64.1            inr-3.CS.Example.EDU inr-3 slip-gateway
128.32.136.9            ns1.Example.EDU ns1
128.32.136.12           ns2.Example.EDU ns2</pre></div></div></li><li><p>Assurez-vous que <code>hosts</code> apparaît avant <code>bind</code> dans votre fichier <span class=filename>/etc/host.conf</span> sous les versions de FreeBSD antérieures à 5.0. Depuis FreeBSD 5.0, le système utilise à la place le fichier <span class=filename>/etc/nsswitch.conf</span>, vérifiez que <code>files</code> est avant <code>dns</code> dans la ligne <code>hosts</code> de ce fichier. Sans ces paramètres, il peut se passer des choses bizarres.</p></li><li><p>Editez le fichier <span class=filename>/etc/rc.conf</span>.</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Définissez votre nom de machine en éditant la ligne:</p><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;myname.my.domain&#34;</pre></div></div><div class=paragraph><p>Le nom Internet complet de la machine doit être utilisé ici.</p></div></li><li><p>Ajoutez <span class=filename>sl0</span> à la liste des interfaces réseau en modifiant la ligne:</p><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0&#34;</pre></div></div><div class=paragraph><p>en:</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 sl0&#34;</pre></div></div></li><li><p>Définissez les paramètres de configuration de <span class=filename>sl0</span> en ajoutant une ligne:</p><div class="literalblock programlisting"><div class=content><pre>ifconfig_sl0=&#34;inet ${hostname} slip-gateway netmask 0xffffff00 up&#34;</pre></div></div></li><li><p>Indiquez la passerelle par défaut en modifiant la ligne:</p><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;NO&#34;</pre></div></div><div class=paragraph><p>en:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;slip-gateway&#34;</pre></div></div></li></ol></div></li><li><p>Créez un fichier <span class=filename>/etc/resolv.conf</span> qui contient:</p><div class="literalblock programlisting"><div class=content><pre>domain CS.Example.EDU
nameserver 128.32.136.9
nameserver 128.32.136.12</pre></div></div><div class=paragraph><p>Comme vous pouvez le voir, ceci définit les serveurs de noms de domaines. Bien entendu, les noms de domaines et les adresses dépendront de votre environnement.</p></div></li><li><p>Donnez des mots de passe pour les utilisateurs <code>root</code> et <code>toor</code> (et à tous les autres comptes qui n’auraient pas de mot de passe).</p></li><li><p>Redémarrez votre machine et vérifiez qu’elle a bien le nom voulu.</p></li></ol></div></div></div></div><div class=sect4><h5 id=_etablir_une_connexion_slip>29.6.1.2. Etablir une connexion SLIP<a class=anchor href=#_etablir_une_connexion_slip></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Téléphonez, tapez <code>slip</code> à l’invite, puis entrez votre nom de machine et votre mot de passe. Ce que vous devez entrer dépend de votre environnement. Si vous utilisez Kermit, vous pouvez essayer une procédure comme celle-ci:</p><div class="literalblock programlisting"><div class=content><pre># configuration kermit
set modem hayes
set line /dev/modem
set speed 115200
set parity none
set flow rts/cts
set terminal bytesize 8
set file type binary
# The next macro will dial up and login
define slip dial 643-9600, input 10 =, if failure stop, -
output slip\x0d, input 10 Username:, if failure stop, -
output silvia\x0d, input 10 Password:, if failure stop, -
output ***\x0d, echo \x0aCONNECTED\x0a</pre></div></div><div class=paragraph><p>Vous devez, bien évidemment, remplacer le nom d’utilisateur et le mot de passe par les votre. Après cela vous pouvez alors entrer simplement <code>slip</code> à l’invite de Kermit pour vous connecter.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Conserver votre mot de passe en clair dans un fichier quelconque est en général une <em>mauvaise</em> idée. Faites-le à vos risques et périls.</p></div></td></tr></tbody></table></div></li><li><p>Laissez ensuite Kermit tel quel (vous pouvez le mettre en arrière-plan avec <span class=keyseq><kbd>Ctrl</kbd>+<kbd>z</kbd></span>) et en tant que <code>root</code>, tapez:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># slattach -h -c -s 115200 /dev/modem</span></code></pre></div></div><div class=paragraph><p>Si vous êtes en mesure d’envoyer un <code>ping</code> vers des machines situées de l’autre côté du routeur, c’est que vous êtes connecté! Si cela ne fonctionne pas, vous pouvez essayer l’option <code>-a</code> au lieu de <code>-c</code> en argument de <code>slattach</code>.</p></div></li></ol></div></div></div></div><div class=sect4><h5 id=_comment_couper_la_connexion>29.6.1.3. Comment couper la connexion<a class=anchor href=#_comment_couper_la_connexion></a></h5><div class=paragraph><p>Effectuez ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -INT `cat /var/run/slattach.modem.pid`</span></code></pre></div></div><div class=paragraph><p>pour tuer <code>slattach</code>. Gardez à l’esprit que vous devez avoir les droits du super-utilisateur pour faire cela. Revenez ensuite sous <code>kermit</code> (en tapant <code>fg</code> si l’avez mis en tâche de fond) et quittez-le (<kbd>q</kbd>).</p></div><div class=paragraph><p>La page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=slattach&amp;sektion=8&amp;format=html">slattach(8)</a> dit que vous devez employer la commande <code>ifconfig sl0 down</code> pour indiquer que l’interface n’est plus active, mais cela ne change apparemment rien (les diagnostics donnés par la commande <code>ifconfig sl0</code> restent identiques).</p></div><div class=paragraph><p>Il arrive que parfois que votre modem refuse de raccrocher. Dans ce cas, relancez <code>kermit</code> et quittez-le de nouveau. Cela fonctionne en général à la seconde tentative.</p></div></div><div class=sect4><h5 id=_dépannage_3>29.6.1.4. Dépannage<a class=anchor href=#_dépannage_3></a></h5><div class=paragraph><p>Si cela ne fonctionne pas, n’hésitez pas à contacter la liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-net>freebsd-net</a>. Voici les problèmes que certains ont rencontré jusqu’ici:</p></div><div class=ulist><ul><li><p>Ne pas utiliser l’option <code>-c</code> ou <code>-a</code> avec <code>slattach</code> (Cela ne devrait pas poser de problème, mais des utilisateurs ont signalé que l’utilisation de cet indicateur a résolu leur problème).</p></li><li><p>Utiliser <code>s10</code> au lieu de <code>sl0</code> (avec certaines polices de caractères, il est parfois difficile de faire la différence).</p></li><li><p>Essayez <code>ifconfig sl0</code> pour connaître la configuration de votre interface. Vous obtiendrez, par exemple:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig sl0</span>
sl0: <span class=nv>flags</span><span class=o>=</span>10&lt;POINTOPOINT&gt;
        inet 136.152.64.181 <span class=nt>--</span><span class=o>&gt;</span> 136.152.64.1 netmask ffffff00</code></pre></div></div></li><li><p>Si vous obtenez le message d’erreur <code>no route to host</code> lors de l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, il se peut qu’il y ait un problème avec votre table de routage. Vous pouvez utiliser la commande <code>netstat -r</code> pour afficher les routes actives:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -r</span>
Routing tables
Destination      Gateway            Flags     Refs     Use  IfaceMTU    Rtt    Netmasks:

<span class=o>(</span>root node<span class=o>)</span>
<span class=o>(</span>root node<span class=o>)</span>

Route Tree <span class=k>for </span>Protocol Family inet:
<span class=o>(</span>root node<span class=o>)</span> <span class=o>=&gt;</span>
default          inr-3.Example.EDU  UG          8   224515  sl0 -      -
localhost.Exampl localhost.Example. UH          5    42127  lo0 -       0.438
inr-3.Example.ED water.CS.Example.E UH          1        0  sl0 -      -
water.CS.Example localhost.Example. UGH        34 47641234  lo0 -       0.438
<span class=o>(</span>root node<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Les exemples précédents proviennent d’un système relativement chargé. La valeurs sur votre système varieront en fonction de l’activité réseau.</p></div></li></ul></div></div></div><div class=sect3><h4 id=slips>29.6.2. Configurer un serveur SLIP<a class=anchor href=#slips></a></h4><div class=paragraph><p>Ce document donne des indications pour la mise en oeuvre d’un serveur SLIP sur un système FreeBSD, ce qui signifie généralement configurer votre système pour ouvrir automatiquement une connexion à l’ouverture d’une session depuis un client SLIP distant.</p></div><div class=sect4><h5 id=slips-prereqs>29.6.2.1. Prérequis<a class=anchor href=#slips-prereqs></a></h5><div class=paragraph><p>Cette section est très technique, il vous faut donc quelques connaissances de base. On supposera que vous connaissez le protocole réseau TCP/IP et, en particulier, l’adressage des réseaux et des noeuds, les masques de sous-réseau, les sous-réseaux, le routage et les protocoles de routage tels que RIP. Ce sont les concepts que vous devez maîtriser pour configurer les services SLIP sur un serveur de connexions, et si ce n’est pas le cas, veuillez lire <em>TCP/IP Network Administration</em> de Craig Hunt chez O’Reilly Associates, Inc. (ISBN 0-937175-82-X), ou les ouvrages de Douglas Comer sur le protocole TCP/IP.</p></div><div class=paragraph><p>On suppose également que vous avez déjà installé vos modems et configuré les fichiers systèmes appropriés pour permettre l’ouverture de session via vos modems. Si vous ne l’avez pas encore fait reportez-vous à la <a href=./#dialup>Dial-in Service</a> pour des informations sur la configuration des connexions entrantes. Vous pouvez aussi consulter les pages de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> pour plus d’information sur le pilote du port série et <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> en ce qui concerne la configuration du système pour qu’il autorise les connexions en provenance de modems, et peut-être la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> pour des informations sur le paramétrage des ports série (comme <code>clocal</code> pour les interfaces série directement connectées).</p></div></div><div class=sect4><h5 id=_rapide_vue_densemble>29.6.2.2. Rapide vue d’ensemble<a class=anchor href=#_rapide_vue_densemble></a></h5><div class=paragraph><p>Une configuration typique d’utilisation de FreeBSD comme serveur SLIP fonctionne de la manière suivante: un utilisateur SLIP appelle votre serveur SLIP FreeBSD et ouvre une session sous un identifiant utilisateur SLIP particulier qui lance <span class=filename>/usr/sbin/sliplogin</span> comme interpréteur de commandes. Le programme <code>sliplogin</code> consulte le fichier <span class=filename>/etc/sliphome/slip.hosts</span> à la recherche d’une ligne correspondant à cet utilisateur particulier, et s’il la trouve, connecte la ligne série à une interface SLIP disponible et lance ensuite la procédure <span class=filename>/etc/sliphome/slip.login</span> pour configurer cette interface SLIP.</p></div><div class=sect5><h6 id=_un_exemple_douverture_de_session_sur_un_serveur_slip>29.6.2.2.1. Un exemple d’ouverture de session sur un serveur SLIP<a class=anchor href=#_un_exemple_douverture_de_session_sur_un_serveur_slip></a></h6><div class=paragraph><p>Par exemple, si <code>Shelmerg</code> était un identifiant utilisateur SLIP, l’entrée pour <code>Shelmerg</code> ressemblerait à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/sliplogin</pre></div></div><div class=paragraph><p>Quand <code>Shelmerg</code> ouvre une session, <code>sliplogin</code> consulte <span class=filename>/etc/sliphome/slip.hosts</span> à la recherche d’une ligne correspondant à l’identifiant de l’utilisateur correspondant; par exemple, il peut y avoir dans le fichier <span class=filename>/etc/sliphome/slip.hosts</span> la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg        dc-slip sl-helmer       0xfffffc00		  autocomp</pre></div></div><div class=paragraph><p><code>sliplogin</code> trouvera alors cette ligne, affectera la ligne série à l’interface SLIP suivante,et ensuite exécutera <span class=filename>/etc/sliphome/slip.login</span> avec les arguments suivants:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp</pre></div></div><div class=paragraph><p>Si tous se passe bien, <span class=filename>/etc/sliphome/slip.login</span> exécutera un <code>ifconfig</code> sur l’interface SLIP que s’est attribué <code>sliplogin</code> (l’interface SLIP 0, dans l’exemple ci-dessus, qui est le premier paramètre passé à <span class=filename>slip.login</span>) pour définir l’adresse IP locale (<code>dc-slip</code>), l’adresse IP de la machine distante (<code>sl-helmer</code>), le masque de sous-réseau de l’interface SLIP (<code>0xfffffc00</code>), et tout autre indicateur supplémentaire (<code>autocomp</code>). Si quelque chose se passe mal, <code>sliplogin</code> fournit en général des messages d’information via la fonctionnalité de trace du "démon"syslogd, qui les enregistre habituellement dans le fichier <span class=filename>/var/log/messages</span> (reportez-vous au pages de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> et consultez peut-être aussi le fichier <span class=filename>/etc/syslog.conf</span> pour voir ce que trace syslogd et où il enregistre ces messages.).</p></div></div></div><div class=sect4><h5 id=_configuration_du_noyau_3>29.6.2.3. Configuration du noyau<a class=anchor href=#_configuration_du_noyau_3></a></h5><div class=paragraph><p>Le noyau par défaut de FreeBSD (<span class=filename>GENERIC</span>) fourni le support SLIP (<a href="https://man.freebsd.org/cgi/man.cgi?query=sl&amp;sektion=4&amp;format=html">sl(4)</a>); dans le cas d’un noyau personnalisé, vous devez ajouter la ligne suivante à votre fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device   sl</pre></div></div><div class=paragraph><p>Sous FreeBSD 4.X, utilisez la ligne suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device   sl      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le chiffre en fin de ligne représente le nombre maximum de connexions SLIP qui peuvent cohexister. Depuis FreeBSD 5.0, le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=sl&amp;sektion=4&amp;format=html">sl(4)</a> est capable d'"auto-clonage".</p></div></td></tr></tbody></table></div><div class=paragraph><p>Par défaut, votre machine FreeBSD ne transmettra pas les paquets. Si vous désirez que votre serveur SLIP FreeBSD agisse en routeur, vous devez éditer le fichier <span class=filename>/etc/rc.conf</span> et positionner la variable <code>gateway_enable</code> à <code>YES</code>.</p></div><div class=paragraph><p>Vous devrez ensuite redémarrer pour que les nouveaux paramètres prennent effet.</p></div><div class=paragraph><p>Veuillez vous référer à la <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a> sur la configuration du noyau pour de l’aide sur ce sujet.</p></div></div><div class=sect4><h5 id=_configuration_de_sliplogin>29.6.2.4. Configuration de sliplogin<a class=anchor href=#_configuration_de_sliplogin></a></h5><div class=paragraph><p>Comme indiqué plus haut, il y a trois fichiers dans le répertoire <span class=filename>/etc/sliphome</span> qui servent à la configuration de <span class=filename>/usr/sbin/sliplogin</span> (voyez <a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a> pour avoir la page de manuel de <code>sliplogin</code>): <span class=filename>slip.hosts</span>, définit les utilisateurs SLIP et les adresses IP qui leur sont associées, <span class=filename>slip.login</span>, qui ne fait en général que configurer l’interface SLIP, et (facultatif) <span class=filename>slip.logout</span>, qui effectue le travail inverse de <span class=filename>slip.login</span> quand la connexion série est terminée.</p></div><div class=sect5><h6 id=_configuration_de_slip_hosts>29.6.2.4.1. Configuration de <span class=filename>slip.hosts</span><a class=anchor href=#_configuration_de_slip_hosts></a></h6><div class=paragraph><p><span class=filename>/etc/sliphome/slip.hosts</span> contient des lignes avec au moins quatre champs séparés par des espaces:</p></div><div class=ulist><ul><li><p>L’identifiant (ID) d’utilisateur SLIP;</p></li><li><p>L’adresse locale (locale au serveur SLIP) de la liaison SLIP;</p></li><li><p>L’adresse de l’autre extrémité de la liaison SLIP;</p></li><li><p>Le masque de sous-réseau.</p></li></ul></div><div class=paragraph><p>Les adresses locales et distantes peuvent être des noms de machines (qui seront convertis en adresses IP via <span class=filename>/etc/hosts</span> ou par le service de noms de domaines, en fonction de ce que contient le fichier <span class=filename>/etc/nsswitch.conf</span>, ou <span class=filename>/etc/host.conf</span> si vous utilisez FreeBSD 4.X), et le masque de sous-réseau peut être un nom qui sera converti en consultant le fichier <span class=filename>/etc/networks</span>. Par exemple, <span class=filename>/etc/sliphome/slip.hosts</span> contiendra:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# login local-addr      remote-addr     mask            opt1    opt2
#                                               (normal,compress,noicmp)
#
Shelmerg  dc-slip       sl-helmerg      0xfffffc00      autocomp</pre></div></div><div class=paragraph><p>La ligne se termine par une ou plusieurs options:</p></div><div class=ulist><ul><li><p><code>normal</code> - pas de compression des en-têtes;</p></li><li><p><code>compress</code> - compression des en-têtes;</p></li><li><p><code>autocomp</code> - compression des en-têtes si la machine distante l’autorise;</p></li><li><p><code>noicmp</code> - interdit les paquets ICMP (de sorte que les paquets "ping" seront ignorés au lieu de consommer votre bande passante).</p></li></ul></div><div class=paragraph><p>Le choix des adresses pour les deux extrémités des liaisons SLIP dépend du fait que vous leur dédiez un sous-réseau TCP/IP ou que vous comptiez utiliser un "proxy ARP" sur votre serveur SLIP (ce n’est pas un "vrai" proxy ARP, mais c’est la terminologie que nous utiliserons dans ce document pour le désigner). Si vous n’êtes pas sûr de la méthode à choisir ou de la façon d’assigner les adresses IP, référez-vous aux ouvrages sur le TCP/IP mentionnés à section sur les prérequis (<a href=#slips-prereqs>Prérequis</a>) et/ou consultez l’administrateur de votre réseau IP.</p></div><div class=paragraph><p>Si vous comptez utiliser un sous-réseau IP séparé pour vos clients SLIP, vous devrez définir l’adresse de sous-réseau à partir de votre réseau IP et attribuer à chacun de vos clients SLIP une adresse IP sur ce sous-réseau. Ensuite, vous devrez probablement configurer sur votre routeur IP le plus proche une route statique vers votre sous-réseau SLIP via votre serveur SLIP.</p></div><div class=paragraph><p>Sinon, si vous avez l’intention d’utiliser la méthode du "proxy ARP", vous devrez assigner à vos clients SLIP des adresses IP en provenance du sous-réseau Ethernet de votre serveur SLIP, et vous devrez également adapter vos procédures <span class=filename>/etc/sliphome/slip.login</span> et <span class=filename>/etc/sliphome/slip.logout</span> pour qu’elles utilisent <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> pour gérer les entrées proxy ARP dans la table ARP de votre serveur SLIP.</p></div></div><div class=sect5><h6 id=_configuration_de_slip_login>29.6.2.4.2. Configuration de <span class=filename>slip.login</span><a class=anchor href=#_configuration_de_slip_login></a></h6><div class=paragraph><p>Le fichier <span class=filename>/etc/sliphome/slip.login</span> ressemble généralement à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# procédure générique d&#39;ouverture de session pour
# une liaison SLIP.  sliplogin l&#39;appelle avec les paramètres:
#      1        2         3        4          5         6     7-n
# interface vitesse nom adresse-locale adresse-distante masque arg-optionnels
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6</pre></div></div><div class=paragraph><p>Ce fichier <span class=filename>slip.login</span> ne fait qu’exécuter <code>ifconfig</code> sur l’interface SLIP appropriée avec comme paramètres les adresses locales et distantes et le masque de sous-réseau de l’interface SLIP.</p></div><div class=paragraph><p>Si vous avez choisi d’utiliser la méthode du "proxy ARP" (au lieu d’affecter un sous-réseau distinct à vos clients SLIP), votre fichier <span class=filename>/etc/sliphome/slip.login</span> devra ressembler à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# procédure générique d&#39;ouverture de session pour
# une liaison SLIP.  sliplogin l&#39;appelle avec les paramètres:
#     1         2    3         4              5           6     7-n
# interface vitesse nom adresse-locale adresse-distante masque arg-optionnels
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
# répondre aux requêtes ARP concernant le client SLIP avec notre
# adresse Ethernet
/usr/sbin/arp -s $5 00:11:22:33:44:55 pub</pre></div></div><div class=paragraph><p>La ligne supplémentaire dans ce fichier <span class=filename>slip.login</span>, <code>arp -s $5 00:11:22:33:44:55 pub</code>, crée une entrée ARP dans la table ARP du serveur SLIP. Cette entrée ARP fait que le serveur SLIP répond avec sa propre adresse MAC lorsqu’un autre noeud IP du réseau Ethernet demande à dialoguer avec le client SLIP qui possède cette adresse IP.</p></div><div class=paragraph><p>Dans l’exemple donné ci-dessus, remplacez l’adresse MAC Ethernet (<code>00:11:22:33:44:55</code>) avec l’adresse MAC de la carte Ethernet de votre système, ou sinon votre "proxy ARP" ne fonctionnera jamais! Vous pouvez déterminer l’adresse MAC de votre serveur SLIP en examinant le résultat de la commande <code>netstat -i</code>; la seconde ligne doit ressembler à ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ed0   1500  Link0.2.c1.28.5f.4a         191923	0   129457     0   116</code></pre></div></div><div class=paragraph><p>Cela indique que l’adresse MAC Ethernet de ce système est <code>00:02:c1:28:5f:4a</code> - les points dans les adresses MAC que donne <code>netstat -i</code> doivent être remplacés par des ":" et il faut ajouter un zéro devant chaque valeur hexadécimale donnée sur un seul digit pour obtenir des adresses dans le format requis par <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a>; consultez la page de manuel d’<a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> pour avoir des informations complètes sur ces conventions.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quand vous créez les fichiers <span class=filename>/etc/sliphome/slip.login</span> et <span class=filename>/etc/sliphome/slip.logout</span>, le bit "exécutable" (i.e., <code>chmod 755 /etc/sliphome/slip.login /etc/sliphome/slip.logout</code>) doit être positionné, ou sinon <code>sliplogin</code> sera incapable d’exécuter la procédure.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_configuration_de_slip_logout>29.6.2.4.3. Configuration de <span class=filename>slip.logout</span><a class=anchor href=#_configuration_de_slip_logout></a></h6><div class=paragraph><p><span class=filename>/etc/sliphome/slip.logout</span> n’est pas strictement indispensable (à moins que vous n’implémentiez un "proxy ARP"), mais si vous décidez de la créer, voici un exemple de procédure <span class=filename>slip.logout</span> élémentaire:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       slip.logout

#
# procédure générique de fermeture de session pour
# une liaison SLIP.  sliplogin l&#39;appelle avec les paramètres:
#     1         2    3         4              5           6     7-n
# interface vitesse nom adresse-locale adresse-distante masque arg-optionnels
#
/sbin/ifconfig sl$1 down</pre></div></div><div class=paragraph><p>Si vous utilisez la méthode "proxy ARP", vous voudrez que <span class=filename>/etc/sliphome/slip.logout</span> supprime l’entrée ARP pour le client SLIP:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.logout

#
# procédure générique de fermeture de session pour
# une liaison SLIP.  sliplogin l&#39;appelle avec les paramètres:
#     1         2    3         4              5           6     7-n
# interface vitesse nom adresse-locale adresse-distante masque arg-optionnels
#
/sbin/ifconfig sl$1 down
# Cesser de répondre aux requêtes ARP concernant le client SLIP
/usr/sbin/arp -d $5</pre></div></div><div class=paragraph><p>La commande <code>arp -d $5</code> supprime l’entrée ARP que la procédure <span class=filename>slip.login</span> pour le "proxy ARP" a ajouté quand le client SLIP a ouvert la session.</p></div><div class=paragraph><p>Il n’est pas inutile de répéter: assurez-vous que le bit "exécutable" de la procédure <span class=filename>/etc/sliphome/slip.logout</span> a été positionné après que vous l’ayez créée (i.e., <code>chmod 755 /etc/sliphome/slip.logout</code>).</p></div></div></div><div class=sect4><h5 id=_a_propos_du_routage>29.6.2.5. A propos du routage<a class=anchor href=#_a_propos_du_routage></a></h5><div class=paragraph><p>Si vous n’utilisez pas "proxy ARP" pour router les paquets entre vos clients SLIP et le reste de votre réseau (et peut-être l’Internet), vous devrez probablement ajouter des routes statiques vers le(s) routeur(s) par défaut le(s) plus proche(s) pour router le sous-réseau de vos clients SLIP via votre serveur SLIP.</p></div><div class=sect5><h6 id=_routes_statiques>29.6.2.5.1. Routes statiques<a class=anchor href=#_routes_statiques></a></h6><div class=paragraph><p>Ajouter des routes statiques vers vos routeurs les plus proches peut être problématique (voire impossible si vous n’avez pas les autorisations pour…​). Si vous avez un réseau avec plusieurs routeurs, certains d’entre eux, tels que les Cisco et les Proteon, devront non seulement être configurés pour la route statique vers le sous-réseau SLIP, mais devront aussi savoir quelles routes statiques ils doivent annoncer aux autres routeurs, donc quelques compétences, un peu de dépannage ou de "bidouille" pourront être nécessaire pour que vos routes statiques fonctionnent.</p></div></div><div class=sect5><h6 id=_utiliser_gated>29.6.2.5.2. Utiliser GateD®<a class=anchor href=#_utiliser_gated></a></h6><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>GateD® est désormais un logiciel propriétaire et les sources ne seront donc plus disponibles (plus d’information sur le site Web de <a href=http://www.gated.org/>GateD®</a>). Cette section existe uniquement pour des raisons de compatibilité pour ceux qui utilisent encore une ancienne version.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Une alternative aux maux de tête que provoquent les routes statiques est d’installer GateD® sur votre serveur SLIP FreeBSD et de le configurer pour qu’il utilise les protocoles de routage appropriés (RIP/OSPF/BGP/EGP) pour annoncer aux autres routeurs votre sous-réseau SLIP. Vous aurez besoin de créer un fichier <span class=filename>/etc/gated.conf</span> pour configurer GateD®; voici un exemple, semblable à celui que l’auteur a utilisé sur un serveur SLIP FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# fichier de configuration de gated dc.dsu.edu; pour la version
# 3.5alpha5
# diffusion des informations RIP pour xxx.xxx.yy via l&#39;interface
# Ethernet &#34;ed&#34;
#
#
# options de trace
#
traceoptions &#34;/var/tmp/gated.output&#34; replace size 100k files 2 general ;

rip yes {
  interface sl noripout noripin ;
  interface ed ripin ripout version 1 ;
  traceoptions route ;
} ;

#
# Activer un certain nombre d&#39;informations de trace sur l&#39;interface
# au noyau:
kernel {
  traceoptions remnants request routes info interface ;
} ;

#
# Propager la route vers xxx.xxx.yy via l&#39;Ethernet interface et RIP
#

export proto rip interface ed {
  proto direct {
      xxx.xxx.yy mask 255.255.252.0 metric 1; # SLIP connections
  } ;
} ;

#
# Accepter les routes de RIP via les interfaces Ethernet &#34;ed&#34;

import proto rip interface ed {
  all ;
} ;</pre></div></div><div class=paragraph><p>L’exemple de fichier <span class=filename>gated.conf</span> ci-dessus diffuse l’information de routage concernant le sous-réseau SLIP <em>xxx.xxx.yy</em> via RIP sur l’interface Ethernet; si vous utilisez un pilote de périphérique Ethernet différent du pilote <span class=filename>ed</span>, vous devrez modifier en conséquence les références à l’interface <span class=filename>ed</span>. Ce fichier d’exemple active également les journaux sur <span class=filename>/var/tmp/gated.output</span> pour pouvoir déboguer le fonctionnement de GateD®; vous pouvez désactiver ces options de trace si GateD® fonctionne correctement pour vous. Vous devrez remplacer <em>xxx.xxx.yy</em> par l’adresse réseau de votre propre sous-réseau SLIP (assurez-vous de remplacer également le masque de sous-réseau dans la clause <code>proto direct</code>).</p></div><div class=paragraph><p>Une fois que vous avez installé et configuré GateD® sur votre système, vous devrez indiquer aux procédures de démarrage de FreeBSD de lancer GateD® à la place de routed. La manière la plus simple de faire cela est de positionner les variables <code>router</code> et <code>router_flags</code> dans le fichier <span class=filename>/etc/rc.conf</span>. Veuillez consulter la page de manuel de GateD® pour des informations sur les paramètres en ligne de commande.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=mail>Chapitre 30. Courrier électronique<a class=anchor href=#mail></a></h2><div class=sectionbody><div class=sect2><h3 id=mail-synopsis>30.1. Synopsis<a class=anchor href=#mail-synopsis></a></h3><div class=paragraph><p>Le "courrier électronique", plus connu sous le nom d’email, est une des formes de communication les plus utilisées aujourd’hui. Ce chapitre fournit une introduction sur comment faire fonctionner un serveur de courrier électronique sous FreeBSD, et comment envoyer et recevoir du courrier électronique sous FreeBSD. Cependant, cela n’est pas un document de référence, en fait de nombreux éléments importants ont été omis. Pour une couverture plus complète du sujet, le lecteur doit se référer aux nombreux ouvrages excellents listés dans l’<a href=./#bibliography>Bibliographie</a>.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Quels composants logiciel sont impliqués dans l’envoi et la réception du courrier électronique.</p></li><li><p>Où se trouvent sous FreeBSD les fichiers de configuration de base de sendmail.</p></li><li><p>La différence entre boîtes aux lettres distantes et boîtes aux lettres locale.</p></li><li><p>Comment empêcher les personnes à l’origine de courriers non sollicités (spam) d’utiliser votre serveur de courrier comme relais.</p></li><li><p>Comment installer et configurer un agent de transfert de courrier alternatif sur votre système, en remplacement de sendmail.</p></li><li><p>Comment dépanner les problèmes courants des serveurs de courrier électronique.</p></li><li><p>Comment utiliser le protocole SMTP avec UUCP.</p></li><li><p>Comment utiliser le courrier électronique avec une connexion temporaire.</p></li><li><p>Comment configurer l’authentification SMTP pour une sécurité accrue.</p></li><li><p>Comment installer et utiliser un client de messagerie, comme mutt pour envoyer et lire du courrier électronique.</p></li><li><p>Comme récupérer votre courrier électronique à partir d’un serveur POP ou IMAP distant.</p></li><li><p>Comment appliquer automatiquement des règles de filtrage au courrier entrant.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Configurer correctement votre connexion réseau (<a href=./#advanced-networking>Administration réseau avancée</a>).</p></li><li><p>Configurer correctement les informations DNS pour votre serveur de courrier (<a href=./#advanced-networking>Administration réseau avancée</a>).</p></li><li><p>Savoir comment installer des logiciels tiers (<a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li></ul></div></div><div class=sect2><h3 id=mail-using>30.2. Utilisation du courrier électronique<a class=anchor href=#mail-using></a></h3><div class=paragraph><p>Il y a cinq éléments majeurs impliqués dans un échange de courrier. Ce sont: <a href=#mail-mua>le programme utilisateur</a>, <a href=#mail-mta>le "daemon" serveur de courrier</a>, <a href=#mail-dns>le serveur DNS</a>, <a href=#mail-receive>une boîte aux lettres distante ou locale</a>, et bien sûr le <a href=#mail-host>le serveur de courrier lui-même </a>.</p></div><div class=sect3><h4 id=mail-mua>30.2.1. Le programme utilisateur<a class=anchor href=#mail-mua></a></h4><div class=paragraph><p>Cela inclut des programmes en ligne de commande comme mutt, pine, elm, et mail, et des programmes graphiques comme balsa, xfmail pour juste en nommer quelques-uns, ou quelque chose de plus "sophisticated" comme un navigateur WWW. Ces programmes transmettent simplement toutes les transactions concernant le courrier électronique au <a href=#mail-host>serveur de courrier local</a>, soit en invoquant un des <a href=#mail-mta>"daemons" serveurs</a> (Agents de transfert de courrier) disponibles, soit via TCP.</p></div></div><div class=sect3><h4 id=mail-mta>30.2.2. Le "daemon" serveur de courrier<a class=anchor href=#mail-mta></a></h4><div class=paragraph><p>FreeBSD est fourni par défaut avec sendmail, mais supporte également de nombreux autres "daemons" serveurs de courrier, parmi lesquels:</p></div><div class=ulist><ul><li><p>exim;</p></li><li><p>postfix;</p></li><li><p>qmail.</p></li></ul></div><div class=paragraph><p>Le serveur a généralement deux fonctions-il est responsable de la réception du courrier comme celle de son envoi. Il n’est cependant <em>pas</em> responsable de la récupération du courrier électronique en utilisant des protocoles comme POP ou IMAP pour lire votre courrier, il ne vous permet pas non plus la connexion à des boîtes aux lettres locales de type <span class=filename>mbox</span> ou maildir. Vous avez besoin d’un <a href=#mail-receive>"daemon"</a> supplémentaire pour cela.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Les anciennes version de sendmail ont de sérieux problèmes de sécurité qui peuvent avoir pour conséquence l’obtention d’un accès local et/ou à distance à votre machine pour une personne malveillante. Vérifiez que vous utilisez une version à jour pour éviter de tels problèmes. Vous avez cependant toujours la possibilité d’installer un autre MTA à partir du <a href=./#ports>catalogue des logiciels portés de FreeBSD</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mail-dns>30.2.3. Courrier électronique et DNS<a class=anchor href=#mail-dns></a></h4><div class=paragraph><p>Le système de noms de domaines (DNS) et son "daemon" <code>named</code> jouent un rôle important dans la transmission du courrier électronique. Afin de délivrer du courrier de votre site à un autre, le serveur recherchera le site distant dans la base de données DNS pour déterminer la machine qui recevra le courrier électronique pour le destinataire. Ce processus intervient également quand un courrier électronique est envoyé à partir d’une machine distante vers votre serveur de courrier.</p></div><div class=paragraph><p>Le DNS gère la correspondance entre nom de machine et adresse IP, et le stockage des informations spécifiques à la distribution du courrier électronique, connues sous le nom d’enregistrements MX. L’enregistrement MX ("Mail eXchanger") définit la machine, ou les machines, qui recevra le courrier pour un domaine particulier. Si vous n’avez pas d’enregistrement MX pour votre machine ou votre domaine, le courrier sera directement envoyé à votre machine à condition que vous ayez un enregistrement A faisant correspondre à votre nom de machine votre adresse IP.</p></div><div class=paragraph><p>Vous pouvez obtenir les enregistrements MX pour n’importe quel domaine en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=host&amp;sektion=1&amp;format=html">host(1)</a> est présentée ci-dessous:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% host <span class=nt>-t</span> mx FreeBSD.org
FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by mx1.FreeBSD.org</code></pre></div></div></div><div class=sect3><h4 id=mail-receive>30.2.4. Réception de courrier<a class=anchor href=#mail-receive></a></h4><div class=paragraph><p>La réception du courrier pour votre domaine se fait par le serveur de courrier. Il collectera le courrier qui est envoyé à destination de votre domaine et le stockera soit sous le format <span class=filename>mbox</span> (la méthode par défaut de stockage du courrier électronique) ou le format Maildir, en fonction de votre configuration. Une fois le courrier stocké, il peut être lu localement en utilisant des applications comme <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> ou mutt, ou lu à distance et récupéré en utilisant des protocoles tels que POP ou IMAP. Cela signifie que si vous désirez uniquement lire votre courrier électroniquement en local, vous n’avez pas besoin d’installer un serveur POP ou IMAP.</p></div><div class=sect4><h5 id=pop-and-imap>30.2.4.1. Accès aux boîtes aux lettres distantes en utilisant POP et IMAP<a class=anchor href=#pop-and-imap></a></h5><div class=paragraph><p>Pour accéder à des boîtes aux lettres distantes, vous devez avoir un accès à un serveur POP ou IMAP. Ces protocoles permettent aux utilisateurs de se connecter aisément à leurs boîtes aux lettres à partir de machines distantes. Bien que POP et IMAP permettent, tous les deux, l’accès aux boîtes aux lettres pour les utilisateurs, IMAP offre de nombreux avantages, parmi lesquels:</p></div><div class=ulist><ul><li><p>IMAP peut stocker les messages sur un serveur distant et les récupérer.</p></li><li><p>IMAP supporte les mises à jour concourantes.</p></li><li><p>IMAP peut être extrêmement utile pour les connexions lentes car il permet aux utilisateurs de récupérer la structure des messages sans les télécharger. Il peut également effectuer des tâches comme la recherche sur le serveur pour réduire les transferts de données entre clients et serveurs.</p></li></ul></div><div class=paragraph><p>Pour installer un serveur POP ou IMAP, les étapes suivantes doivent être suivies:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Choisissez un serveur IMAP ou POP correspondant à vos besoins. Les serveurs POP et IMAP suivants sont connus et sont de bons exemples:</p><div class=ulist><ul><li><p>qpopper;</p></li><li><p>teapop;</p></li><li><p>imap-uw;</p></li><li><p>courier-imap;</p></li></ul></div></li><li><p>Installez le "daemon" POP ou IMAP de votre choix à partir du catalogue des logiciels portés.</p></li><li><p>Si cela est nécessaire, modifiez le fichier <span class=filename>/etc/inetd.conf</span> pour charger le serveur POP ou IMAP.</p></li></ol></div></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Il doit être noté que POP et IMAP transmettent les données, y compris les noms d’utilisateurs et mot de passe d’authentification en clair. Cela signifie que si vous désirez sécuriser la transmission des données avec ces protocoles, vous devriez considérer l’utilisation de de tunnels <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>. L’utilisation de tels tunnels est décrite dans la <a href=./#security-ssh-tunneling>Tunnels SSH</a>.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=local>30.2.4.2. Accès aux boîtes aux lettres locales<a class=anchor href=#local></a></h5><div class=paragraph><p>Les boîtes aux lettres peuvent être accessibles localement en utilisant un client de messagerie sur le serveur où se trouve la boîte. Cela peut être fait en employant des applications telles que mutt ou <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>.</p></div></div></div><div class=sect3><h4 id=mail-host>30.2.5. Le serveur de courrier<a class=anchor href=#mail-host></a></h4><div class=paragraph><p>Le serveur de courrier est le nom donné au serveur qui est responsable de la transmission et la réception du courrier pour votre machine, et probablement votre réseau.</p></div></div></div><div class=sect2><h3 id=sendmail>30.3. Configuration de sendmail<a class=anchor href=#sendmail></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> est l’agent de transfert de courrier (Mail Transfert Agent-MTA) par défaut sous FreeBSD. Le rôle de sendmail est d’accepter le courrier en provenance des agents de courrier utilisateur (Mail User Agents-MUA) et de délivrer le courrier aux programmes de gestion du courrier définis dans son fichier de configuration. sendmail peut également accepter les connexions réseau et délivrer le courrier dans des boîtes aux lettres locales ou le transmettre à un autre programme.</p></div><div class=paragraph><p>sendmail utilise les fichiers de configuration suivants:</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Fichier</th><th class="tableblock halign-left valign-top">Fonction</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/access</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichier de la base de données d’accès de sendmail</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/aliases</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alias de boîte aux lettres</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/local-host-names</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Liste des machines pour lesquelles sendmail accepte du courrier</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailer.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuration du programme de gestion du courrier</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Table de livraison du courrier</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/sendmail.cf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichier de configuration principal de sendmail</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/virtusertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Table des domaines et utilisateurs virtuels</p></td></tr></tbody></table><div class=sect3><h4 id=_etcmailaccess>30.3.1. <span class=filename>/etc/mail/access</span><a class=anchor href=#_etcmailaccess></a></h4><div class=paragraph><p>La base de données d’accès définit quelle(s) machine(s) ou adresses IP ont accès au serveur de courrier local et quel type d’accès ils ont. Les machines peuvent être listées avec <code>OK</code>, <code>REJECT</code>, <code>RELAY</code> ou simplement transférées à la routine de gestion des erreurs sendmail avec une erreur donnée. Les machines qui sont listées avec <code>OK</code>, qui est le comportement par défaut, sont autorisées à envoyer du courrier à cette machine dès que la destination finale du courrier est la machine locale. Les machines listées avec <code>REJECT</code> se verront rejeter pour toute connexion au serveur. Les machines présentes avec l’option <code>RELAY</code> sont autorisées à envoyer du courrier à n’importe quelle destination par l’intermédiaire de ce serveur de courrier.</p></div><div class=exampleblock><div class=title>Exemple 37. Configuration de la base de données d’accès de sendmail</div><div class=content><div class="literalblock programlisting"><div class=content><pre>cyberspammer.com                550 We don&#39;t accept mail from spammers
FREE.STEALTH.MAILER@            550 We don&#39;t accept mail from spammers
another.source.of.spam          REJECT
okay.cyberspammer.com           OK
128.32                          RELAY</pre></div></div></div></div><div class=paragraph><p>Dans cet exemple nous avons cinq entrées. Les émetteurs de courrier qui correspondent à la partie gauche de la table sont affectés par l’action donnée sur la partie droite de la table. Les deux premiers exemples donnent un code d’erreur à la routine de gestion d’erreur de sendmail. Le message est affiché sur la machine distante quand un courrier électronique correspond à la partie gauche de la table. L’entrée suivante rejette le courrier en provenance d’une machine précise de l’Internet, <code>another.source.of.spam</code>. L’entrée suivante accepte les connexions à partir de la machine <code>okay.cyberspammer.com</code>, qui est plus précis que le <code>cyberspammer.com</code> de la ligne précédente. Les correspondances plus spécifiques priment sur les moins précises. La dernière entrée autorise le relais du courrier électronique en provenance de machines avec une adresse IP qui commence par <code>128.32</code>. Ces machines seront en mesure d’envoyer du courrier destiné à d’autres serveurs de courrier par l’intermédiaire de ce serveur de courrier.</p></div><div class=paragraph><p>Quand ce fichier est mis à jour, vous devez exécuter la commande <code>make</code> dans <span class=filename>/etc/mail/</span> pour mettre à jour la base de données.</p></div></div><div class=sect3><h4 id=_etcmailaliases>30.3.2. <span class=filename>/etc/mail/aliases</span><a class=anchor href=#_etcmailaliases></a></h4><div class=paragraph><p>La base de données d’alias contient une liste de boîtes aux lettres virtuelles dont le contenu sera transmis à d’autres utilisateurs, fichiers, programmes ou d’autres alias. Voici quelques exemples qui peuvent être utilisés dans <span class=filename>/etc/mail/aliases</span>:</p></div><div class=exampleblock><div class=title>Exemple 38. Exemple de base de données d’alias</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre></div></div></div></div><div class=paragraph><p>Le format du fichier est simple; le nom de la boîte aux lettres à gauche et la cible sur la droite. Le premier exemple transfère la boîte aux lettres <code>root</code> vers la boîte aux lettres <code>localuser</code>, qui est ensuite recherchée dans la base de données d’alias. Si aucune correspondance n’est trouvée alors le message est délivré à l’utilisateur locale <code>localuser</code>. L’exemple suivant montre une liste de correspondance. Un courrier envoyé à la boîte aux lettres <code>ftp-bugs</code> sera délivré aux trois boites locales <code>joe</code>, <code>eric</code>, et <code>paul</code>. Notez qu’une boîte aux lettres distante comme <code>user@exemple.com</code>/procmail pourra être spécifiée. L’exemple suivant montre comment transférer le courrier dans un fichier, dans notre cas <span class=filename>/dev/null</span>. Le dernier exemple montre l’envoi du courrier à un programme, dans le cas présent le message est écrit sur l’entrée standard de <span class=filename>/usr/local/bin/procmail</span> par l’intermédiaire d’un tube UNIX®.</p></div><div class=paragraph><p>Quand ce fichier est mis à jour, vous devez exécuter la commande <code>make</code> dans <span class=filename>/etc/mail/</span> pour mettre à jour la base de données.</p></div></div><div class=sect3><h4 id=_etcmaillocal_host_names>30.3.3. <span class=filename>/etc/mail/local-host-names</span><a class=anchor href=#_etcmaillocal_host_names></a></h4><div class=paragraph><p>C’est la liste des machines pour lesquelles <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> accepte du courrier comme s’il était destiné à la machine locale. Placez-y tous les domaines ou machines pour lesquels sendmail doit recevoir du courrier. Par exemple, si le serveur de courrier devait accepter du courrier pour le domaine <code>exemple.com</code> et la machine <code>mail.exemple.com</code>, sont <span class=filename>local-host-names</span> ressemblera à quelque chose comme ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>exemple.com
mail.exemple.com</pre></div></div><div class=paragraph><p>Quand ce fichier est mis à jour, <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> doit être relancé pour lire les changements.</p></div></div><div class=sect3><h4 id=_etcmailsendmail_cf>30.3.4. <span class=filename>/etc/mail/sendmail.cf</span><a class=anchor href=#_etcmailsendmail_cf></a></h4><div class=paragraph><p>Fichier principal de configuration de sendmail, <span class=filename>sendmail.cf</span> contrôle le comportement général de sendmail, y compris tout depuis la réécriture des adresses de courrier jusqu’à l’envoi de message de rejet aux serveurs de courrier distants. Naturellement, avec tant de différentes activités, ce fichier de configuration est relativement complexe et son étude détaillée n’est pas le but de cette section. Heureusement, ce fichier a rarement besoin d’être modifié pour les serveurs de courrier standards.</p></div><div class=paragraph><p>Le fichier de configuration principal de sendmail peut être créé à partir de macros <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> qui définissent les fonctions et le comportement de sendmail. Veuillez consulter <span class=filename>/usr/src/contrib/sendmail/cf/README</span> pour plus de détails.</p></div><div class=paragraph><p>Quand des modifications à ce fichier sont apportées, sendmail doit être redémarré pour que les changements prennent effet.</p></div></div><div class=sect3><h4 id=_etcmailvirtusertable>30.3.5. <span class=filename>/etc/mail/virtusertable</span><a class=anchor href=#_etcmailvirtusertable></a></h4><div class=paragraph><p>La table <span class=filename>virtusertable</span> fait correspondre les adresses de courrier électronique pour des domaines virtuels et les boîtes aux lettres avec des boîtes aux lettres réelles. Ces boîtes aux lettres peuvent être locales, distantes, des alias définis dans <span class=filename>/etc/mail/aliases</span> ou des fichiers.</p></div><div class=exampleblock><div class=title>Exemple 39. Exemple de correspondance de domaine virtuel de courrier</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root@exemple.com                root
postmaster@exemple.com          postmaster@noc.exemple.net
@exemple.com                    joe</pre></div></div></div></div><div class=paragraph><p>Dans l’exemple ci-dessus, nous avons une correspondance pour un domaine <code>exemple.com</code>. Ce fichier est traité jusqu’à trouver la première correspondance. Le premier élément fait correspondre <code>root@exemple.com</code> à la boîte aux lettres root locale. L’entrée suivante fait correspondre <code>postmaster@exemple.com</code> à la boîte aux lettres postmaster sur la machine <code>noc.exemple.net</code>. Et enfin, si un courrier en provenance de <code>exemple.com</code> n’a pas trouvé de correspondance, il correspondra à la dernière ligne, qui régira tous les autres messages adressés à quelqu’un du domaine <code>exemple.com</code>. La correspondance sera la boîte aux lettres locale <code>joe</code>.</p></div></div></div><div class=sect2><h3 id=mail-changingmta>30.4. Changer votre agent de transfert de courrier<a class=anchor href=#mail-changingmta></a></h3><div class=paragraph><p>Comme mentionné précédemment, FreeBSD est fournit avec sendmail comme agent de transfert du courrier (MTA - Mail Transfert Agent). Il est donc par défaut en charge de votre courrier sortant et entrant.</p></div><div class=paragraph><p>Cependant, pour une variété de raison, certains administrateurs système désirent changer le MTA de leur système. Ces raisons vont de la simple envie d’essayer un autre agent au besoin d’une fonction ou ensemble spécifique qui dépend d’un autre gestionnaire de courrier. Heureusement, quelle qu’en soit la raison, FreeBSD rend le changement aisé.</p></div><div class=sect3><h4 id=_installer_un_nouveau_mta>30.4.1. Installer un nouveau MTA<a class=anchor href=#_installer_un_nouveau_mta></a></h4><div class=paragraph><p>Vous avez un vaste choix d’agent disponible. Un bon point de départ est le <a href=./#ports>catalogue des logiciels portés de FreeBSD</a> où vous pourrez en trouver un grand nombre. Bien évidemment vous êtes libres d’utiliser n’importe quel agent de n’importe quelle origine, dès que vous pouvez le faire fonctionner sous FreeBSD.</p></div><div class=paragraph><p>Commencez par installer votre nouvel agent. Une fois ce dernier installé, il vous donne une chance de décider s’il remplit vraiment vos besoins, et vous donne l’opportunité de configurer votre nouveau logiciel avant de remplacer sendmail. Quand vous faites cela, vous devez être sûr que l’installation du nouveau logiciel ne tentera pas de remplacer des binaires du système comme <span class=filename>/usr/bin/sendmail</span>. Sinon, votre nouveau logiciel sera mis en service avant d’avoir pu le configurer.</p></div><div class=paragraph><p>Veuillez vous référer à la documentation de l’agent choisi pour de l’information sur comment configurer le logiciel que vous avez choisi.</p></div></div><div class=sect3><h4 id=_désactiver_sendmail>30.4.2. Désactiver sendmail<a class=anchor href=#_désactiver_sendmail></a></h4><div class=paragraph><p>La procédure utilisée pour lancer sendmail a changé de façon significative entre la 4.5-RELEASE et la 4.6-RELEASE. Par conséquent, la procédure utilisée pour la désactiver est légèrement différente.</p></div><div class=sect4><h5 id=_freebsd_4_5_stable_davant_le_200244_et_plus_ancienne_y_compris_4_5_release_et_précédentes>30.4.2.1. FreeBSD 4.5-STABLE d’avant le 2002/4/4 et plus ancienne (y compris 4.5-RELEASE et précédentes)<a class=anchor href=#_freebsd_4_5_stable_davant_le_200244_et_plus_ancienne_y_compris_4_5_release_et_précédentes></a></h5><div class=paragraph><p>Ajoutez:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>dans <span class=filename>/etc/rc.conf</span>. Cela désactivera le service de courrier entrant de sendmail mais si <span class=filename>/etc/mail/mailer.conf</span> (voir plus bas) n’est pas modifié, sendmail sera toujours utilisé pour envoyer du courrier électronique.</p></div></div><div class=sect4><h5 id=_freebsd_4_5_stable_daprès_le_200244_y_compris_4_6_release_et_suivantes>30.4.2.2. FreeBSD 4.5-STABLE d’après le 2002/4/4 (y compris 4.6-RELEASE et suivantes)<a class=anchor href=#_freebsd_4_5_stable_daprès_le_200244_y_compris_4_6_release_et_suivantes></a></h5><div class=paragraph><p>Afin de complètement désactiver sendmail vous devez utiliser</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NONE&#34;</pre></div></div><div class=paragraph><p>dans <span class=filename>/etc/rc.conf.</span></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Si vous désactivez le service d’envoi de courrier de sendmail de cette manière, il est important que vous le remplaciez par un système de courrier alternatif fonctionnant parfaitement. Si vous choisissez de ne pas le faire, des fonctions du système comme <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> ne seront pas en mesure de délivrer leur résultat par courrier électronique comme elles s’attendent normalement à le faire. De nombreux composants de votre système s’attendent à avoir un système compatible à sendmail en fonctionnement. Si des applications continuent à utiliser les binaires de sendmail pour essayer d’envoyer du courrier électronique après la désactivation, le courrier pourra aller dans une file d’attente inactive, et pourra n’être jamais livré.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous voulez uniquement désactiver le service de réception de courrier de sendmail vous devriez fixer</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>dans <span class=filename>/etc/rc.conf</span>. Plus d’information sur les options de démarrage de sendmail est disponible à partir de la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.sendmail&amp;sektion=8&amp;format=html">rc.sendmail(8)</a>.</p></div></div></div><div class=sect3><h4 id=_lancement_de_votre_nouvel_agent_au_démarrage>30.4.3. Lancement de votre nouvel agent au démarrage<a class=anchor href=#_lancement_de_votre_nouvel_agent_au_démarrage></a></h4><div class=paragraph><p>Vous pourrez avoir le choix entre deux méthodes pour lancer votre nouvel agent au démarrage, encore une fois en fonction de la version de FreeBSD dont vous disposez.</p></div><div class=sect4><h5 id=_freebsd_4_5_stable_davant_le_2002411_y_compris_4_5_release_et_précédentes>30.4.3.1. FreeBSD 4.5-STABLE d’avant le 2002/4/11 (y compris 4.5-RELEASE et précédentes)<a class=anchor href=#_freebsd_4_5_stable_davant_le_2002411_y_compris_4_5_release_et_précédentes></a></h5><div class=paragraph><p>Ajouter une procédure dans <span class=filename>/usr/local/etc/rc.d/</span> qui se termine en <span class=filename>.sh</span> et qui est exécutable par <code>root</code>. La procédure devrait accepter les paramètres <code>start</code> et <code>stop</code>. Au moment du démarrage les procédures système exécuteront la commande</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/etc/rc.d/supermailer.sh start</pre></div></div><div class=paragraph><p>que vous pouvez également utiliser pour démarrer le serveur. Au moment de l’arrêt du système, les procédures système utiliseront l’option <code>stop</code> en exécutant la commande</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/etc/rc.d/supermailer.sh stop</pre></div></div><div class=paragraph><p>que vous pouvez également utiliser manuellement pour arrêter le serveur quand le système est en fonctionnement.</p></div></div><div class=sect4><h5 id=_freebsd_4_5_stable_daprès_le_2002411_y_compris_4_6_release_et_suivantes>30.4.3.2. FreeBSD 4.5-STABLE d’après le 2002/4/11 (y compris 4.6-RELEASE et suivantes)<a class=anchor href=#_freebsd_4_5_stable_daprès_le_2002411_y_compris_4_6_release_et_suivantes></a></h5><div class=paragraph><p>Avec les versions suivantes de FreeBSD, vous pouvez utiliser la méthode ci-dessus ou fixer</p></div><div class="literalblock programlisting"><div class=content><pre>mta_start_script=&#34;nomfichier&#34;</pre></div></div><div class=paragraph><p>dans <span class=filename>/etc/rc.conf</span>, où <em>nomfichier</em> est le nom d’une procédure que vous voulez exécuter au démarrage pour lancer votre agent.</p></div></div></div><div class=sect3><h4 id=_remplacer_sendmail_comme_gestionnaire_du_courrier_du_système_par_défaut>30.4.4. Remplacer sendmail comme gestionnaire du courrier du système par défaut<a class=anchor href=#_remplacer_sendmail_comme_gestionnaire_du_courrier_du_système_par_défaut></a></h4><div class=paragraph><p>Le programme sendmail est tellement omniprésent comme logiciel standard sur les systèmes UNIX® que certains programmes supposent qu’il est tout simplement déjà installé et configuré. Pour cette raison, de nombreux agents alternatifs fournissent leur propre implémentation compatible avec l’interface en ligne de commande de sendmail; cela facilite leur utilisation comme remplaçant pour sendmail.</p></div><div class=paragraph><p>Donc, si vous utilisez un programme alternatif, vous devrez vérifier que le logiciel essayant d’exécuter les binaires standards de sendmail comme <span class=filename>/usr/bin/sendmail</span> exécute réellement l’agent que vous avez choisi à la place. Heureusement, FreeBSD fournit un système appelé <a href="https://man.freebsd.org/cgi/man.cgi?query=mailwrapper&amp;sektion=8&amp;format=html">mailwrapper(8)</a> qui remplit ce travail pour vous.</p></div><div class=paragraph><p>Quand sendmail fonctionne tel qu’il a été installé, vous trouverez quelque chose comme ce qui suit dans <span class=filename>/etc/mail/mailer.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail	 /usr/libexec/sendmail/sendmail
send-mail	/usr/libexec/sendmail/sendmail
mailq		/usr/libexec/sendmail/sendmail
newaliases	/usr/libexec/sendmail/sendmail
hoststat	/usr/libexec/sendmail/sendmail
purgestat	/usr/libexec/sendmail/sendmail</pre></div></div><div class=paragraph><p>Cela signifie que lorsque l’une des commandes courantes (comme <span class=filename>sendmail</span> lui-même) est lancée, le système invoque en fait une copie de "mailwrapper" appelée <span class=filename>sendmail</span>, qui lit <span class=filename>mailer.conf</span> et exécute <span class=filename>/usr/libexec/sendmail/sendmail</span> à la place. Ce système rend aisé le changement des binaires qui sont réellement exécutés quand les fonctions de <span class=filename>sendmail</span> par défaut sont invoquées.</p></div><div class=paragraph><p>Donc si vous avez voulu que <span class=filename>/usr/local/supermailer/bin/sendmail-compat</span> soit lancé en place de sendmail, vous pourrez modifier <span class=filename>/etc/mail/mailer.conf</span> de cette façon:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail	 /usr/local/supermailer/bin/sendmail-compat
send-mail	/usr/local/supermailer/bin/sendmail-compat
mailq		/usr/local/supermailer/bin/mailq-compat
newaliases	/usr/local/supermailer/bin/newaliases-compat
hoststat	/usr/local/supermailer/bin/hoststat-compat
purgestat	/usr/local/supermailer/bin/purgestat-compat</pre></div></div></div><div class=sect3><h4 id=_pour_en_terminer>30.4.5. Pour en terminer<a class=anchor href=#_pour_en_terminer></a></h4><div class=paragraph><p>Une fois que vous avez tout configuré de la façon dont vous le désirez, vous devriez soit tuer les processus de sendmail dont vous n’avez plus besoin et lancer les processus appartenant à votre nouveau logiciel, ou tout simplement redémarrer. Le redémarrage vous donnera l’opportunité de vous assurer que vous avez correctement configuré votre système pour le lancement automatique de votre nouvel agent au démarrage.</p></div></div></div><div class=sect2><h3 id=mail-trouble>30.5. Dépannage<a class=anchor href=#mail-trouble></a></h3><div class=sect3><h4 id=_pourquoi_faut_il_que_jutilise_le_fqdn_fully_qualified_domain_name_nom_complet_de_machine_pour_les_machines_de_mon_site>30.5.1. Pourquoi faut-il que j’utilise le FQDN ("Fully Qualified Domain Name" - nom complet de machine) pour les machines de mon site?<a class=anchor href=#_pourquoi_faut_il_que_jutilise_le_fqdn_fully_qualified_domain_name_nom_complet_de_machine_pour_les_machines_de_mon_site></a></h4><div class=paragraph><p>Vous vous rendrez probablement compte que la machine est en fait dans un domaine différent; par exemple, si vous êtes dans le domaine <code>foo.bar.edu</code> et que vous voulez atteindre la machine <code>mumble</code> du domaine <code>bar.edu</code>, vous devrez utiliser son nom de machine complet, <code>mumble.bar.edu</code>, au lieu de juste <code>mumble</code>.</p></div><div class=paragraph><p>C’était traditionnellement autorisé par les résolveurs BIND BSD. Néanmoins, la version de BIND qui est maintenant livrée avec FreeBSD ne sait pas compléter les noms de machines abrégés autrement qu’avec le nom de votre domaine. Donc le nom non qualifié <code>mumble</code> doit correspondre à <code>mumble.foo.bar.edu</code>, sans quoi il sera recherché dans le domaine racine.</p></div><div class=paragraph><p>Cela diffère du comportement précédent, où la recherche se prolongeait à <code>mumble.bar.edu</code>, puis <code>mumble.edu</code>. Consultez la RFC 1535 pour savoir pourquoi cela était considéré comme une mauvaise pratique, voire même un trou de sécurité.</p></div><div class=paragraph><p>Comme solution, vous pouvez mettre la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>search foo.bar.edu bar.edu</pre></div></div><div class=paragraph><p>à la place de:</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>dans votre fichier <span class=filename>/etc/resolv.conf</span>. Cependant, assurez-vous que la recherche ne franchit pas la "limite entre l’administration locale et publique", selon l’expression de la RFC 1535.</p></div></div><div class=sect3><h4 id=_sendmail_affiche_le_message_mail_loops_back_to_myself>30.5.2. sendmail affiche le message mail loops back to myself<a class=anchor href=#_sendmail_affiche_le_message_mail_loops_back_to_myself></a></h4><div class=paragraph><p>La réponse donnée dans la FAQ de sendmail est la suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>J&#39;obtiens les messages d&#39;erreur suivant:

553 MX list for domain.net points back to relay.domain.net
554 user@domain.net... Local configuration error

Comment puis-je résoudre ce problème?

Vous avez demandé que le courrier pour un domaine (e.g., domain.net)
soit transmis à une machine donnée (dans ce cas précis, relay.domain.net)
en utilisant un enregistrement MXMX record
, mais la machine relais ne se
connaît pas elle-même comme domain.net.  Ajoutez domain.net à
/etc/mail/local-host-names [connu sous le nom /etc/sendmail.cw dans les versionsantérieure à 8.10] (si vous utilisez FEATURE(use_cw_file))
ou ajoutez &#34;Cw domain.net&#34; à
/etc/mail/sendmail.cf.</pre></div></div><div class=paragraph><p>La FAQ de sendmail peut être trouvée à l’adresse <a href=http://www.sendmail.org/faq/>http://www.sendmail.org/faq/</a> et sa lecture est recommandée si vous voulez "bidouiller" votre configuration du courrier électronique.</p></div></div><div class=sect3><h4 id=_comment_puis_je_faire_tourner_un_serveur_de_courrier_électronique_avec_une_connexion_téléphonique_ppp_ppp>30.5.3. Comment puis-je faire tourner un serveur de courrier électronique avec une connexion téléphonique PPP PPP<a class=anchor href=#_comment_puis_je_faire_tourner_un_serveur_de_courrier_électronique_avec_une_connexion_téléphonique_ppp_ppp></a></h4><div class=paragraph><p>Vous voulez connecter une machine FreeBSD du réseau local à l’Internet. Cette machine servira de passerelle de courrier électronique pour le réseau local. La connexion PPP n’est pas dédiée.</p></div><div class=paragraph><p>Il y a au moins deux façons de faire. L’une d’elle est d’utiliser UUCP.</p></div><div class=paragraph><p>L’autre méthode étant d’obtenir un serveur Internet constamment connecté pour qu’il vous fournisse les services MX pour votre domaine. Par exemple, si le domaine de votre compagnie est <code>exemple.com</code> et votre fournisseur d’accès a configuré <code>exemple.net</code> pour fournir un MX secondaire pour votre domaine:</p></div><div class="literalblock programlisting"><div class=content><pre>exemple.com.            MX        10      exemple.com.
                      MX        20      exemple.net.</pre></div></div><div class=paragraph><p>Une seule machine devrait être spécifiée comme destinataire final (ajoutez <code>Cw exemple.com</code> au fichier <span class=filename>/etc/mail/sendmail.cf</span> de <code>exemple.com</code>).</p></div><div class=paragraph><p>Quand le <code>sendmail</code> expéditeur tente de vous délivrer du courrier, il essaiera de se connecter à votre serveur (<code>exemple.com</code>) via votre liaison par modem. Ce qui échouera très probablement par dépassement de délai puisque vous n’êtes pas en ligne. Le programme sendmail enverra automatiquement le courrier au site MX secondaire, i.e. votre fournisseur d’accès (<code>exemple.net</code>). Le site MX secondaire essayera périodiquement de se connecter à votre machine pour expédier le courrier au site MX primaire (<code>exemple.com</code>).</p></div><div class=paragraph><p>Vous pourrez vouloir utiliser quelque chose comme ceci comme procédure de connexion:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Mettez-moi dans /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q )
/usr/sbin/ppp -direct pppmyisp</pre></div></div><div class=paragraph><p>Si vous avez l’intention de définir une procédure de connexion particulière pour un utilisateur, vous pourrez utiliser <code>sendmail -qRexemple.com</code> à la place de la procédure ci-dessus. Cela forcera le traitement immédiat de tout le courrier dans votre file d’attente pour <code>exemple.com</code>.</p></div><div class=paragraph><p>On peut encore affiner la configuration comme suit:</p></div><div class=paragraph><p>Message emprunté à la <a href=https://lists.FreeBSD.org/subscription/freebsd-isp>liste de diffusion pour les fournisseurs d’accès Internet utilisant FreeBSD</a>.</p></div><div class="literalblock programlisting"><div class=content><pre> Nous fournissons un MX secondaire à un
client.  Le client se connecte
 à notre service automatiquement plusieurs fois par jour pour acheminer
 le courrier sur son MX primaire (nous n&#39;appelons pas son site lorsque
 du courrier pour ses domaines arrive).  Notre sendmail envoie le courrier de la
 file d&#39;attente toutes les demi-heures.  Pour l&#39;instant, il doit rester
 une demi-heure en ligne pour être sûr que tout le courrier soit
 arrivé au MX primaire.

 Y-a-t-il une commande qui permette de dire à sendmail d&#39;envoyer
 sur-le-champ tout le courrier? L&#39;utilisateur n&#39;a évidemment pas
 les droits super-utilisateur sur la machine.

Dans la section &#34;privacy flags&#34; (indicateurs de
confidentialité) de sendmail.cf, il y a la définition Opgoaway,restrictqrun

Supprimer restrictqrun permet à d&#39;autres utilisateurs que le
super-utilisateur de lancer le traitement de la file d&#39;attente.  Vous
pouvez aussi redéfinir les MXs.  Nous sommes le premier MX pour les
utilisateurs de ce type, et nous avons défini:

# Si nous sommes le meilleur MX pour une machine, essayer directement
# au lieu d&#39;émettre des messages d&#39;erreur de configuration locale.
OwTrue

De cette façon, un site distant vous enverra directement le courrier,
sans essayer de se connecter chez votre client.  Vous le lui
transmettez ensuite.  Cela ne marche qu&#39;avec les &#34;machines&#34;,
votre client doit nommer son serveur de courrier
&#34;client.com&#34; aussi bien que
&#34;machine.client.com&#34; dans le DNS.  Mettez seulement un
enregistrement A pour &#34;client.com&#34;.</pre></div></div></div><div class=sect3><h4 id=_pourquoi_jobtiens_le_message_derreur_relaying_denied_à_chaque_fois_que_jenvoie_du_courrier_à_partir_dautres_machines>30.5.4. Pourquoi j’obtiens le message d’erreur Relaying Denied à chaque fois que j’envoie du courrier à partir d’autres machines?<a class=anchor href=#_pourquoi_jobtiens_le_message_derreur_relaying_denied_à_chaque_fois_que_jenvoie_du_courrier_à_partir_dautres_machines></a></h4><div class=paragraph><p>Dans l’installation par défaut de FreeBSD, sendmail est configuré pour envoyer du courrier uniquement à partir de la machine sur laquelle il tourne. Par exemple, si un serveur POP est disponible, alors les utilisateurs pourront retirer leur courrier depuis l’école, le travail, ou toute autre machine distante mais ils ne seront toujours pas en mesure d’envoyer du courrier électronique à partir de machines extérieures. Généralement, quelques instants après une tentative, un courrier électronique sera envoyé par le MAILER-DAEMON avec un message <code>5.7 Relaying Denied</code>.</p></div><div class=paragraph><p>Il y a plusieurs façons d’y remédier. La solution la plus directe est de mettre l’adresse de votre fournisseur d’accès dans un fichier de domaine à relayer <span class=filename>/etc/mail/relay-domains</span>. Une façon rapide de le faire serait:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;votre.fai.exemple.com&#34; &gt; /etc/mail/relay-domains</span></code></pre></div></div><div class=paragraph><p>Après avoir créé ou édité ce fichier vous devez redémarrer sendmail. Cela fonctionne parfaitement si vous êtes l’administrateur d’un serveur et vous ne désirez pas envoyer de courrier localement, ou que vous désiriez utiliser un système ou un client "clic-bouton" sur une autre machine ou un autre FAI. C’est également très utile si vous avez uniquement qu’un ou deux comptes de courrier électronique configurés. S’il y a un grand nombre d’adresses à ajouter, vous pouvez tout simplement ouvrir ce fichier dans votre éditeur de texte favori et ensuite ajouter les domaines, un par ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>votre.fai.exemple.com
autre.fai.exemple.net
utilisateurs-fai.exemple.org
www.exemple.org</pre></div></div><div class=paragraph><p>Désormais tout courrier envoyé vers votre système, par n’importe quelle machine de cette liste (en supposant que l’utilisateur possède un compte sur votre système), sera accepté. C’est un bon moyen d’autoriser aux utilisateurs d’envoyer du courrier électronique à distance depuis votre système sans autoriser l’utilisation de votre système pour l’envoi de courrier électronique non sollicité (SPAM).</p></div></div></div><div class=sect2><h3 id=mail-advanced>30.6. Sujets avancés<a class=anchor href=#mail-advanced></a></h3><div class=paragraph><p>LA fonction suivante couvre des sujets plus avancés comme la configuration du courrier électronique pour l’intégralité de votre domaine.</p></div><div class=sect3><h4 id=mail-config>30.6.1. Basic Configuration<a class=anchor href=#mail-config></a></h4><div class=paragraph><p>Sans aucune configuration, vous devrez être en mesure d’envoyer du courrier électronique à des machines extérieures à partir du moment où vous avez configuré <span class=filename>/etc/resolv.conf</span> ou que vous avez votre propre serveur de noms. Si vous désirez que le courrier pour votre machine soit délivré au serveur de courrier (e.g., sendmail) sur votre propre machine FreeBSD, il y a deux méthodes:</p></div><div class=ulist><ul><li><p>Faites tourner votre propre serveur de noms et possédez votre propre domaine. Par exemple <code>FreeBSD.org</code></p></li><li><p>Faire délivrer le courrier directement sur votre machine. Cela est possible en délivrant directement le courrier à la machine sur lequel pointe le DNS pour le courrier qui vous est destiné. Par exemple <code>exemple.FreeBSD.org</code>.</p></li></ul></div><div class=paragraph><p>Indépendamment de la méthode que vous choisissez, afin d’avoir le courrier délivré directement à votre machine, elle doit avoir une adresse IP statique permanente (et non pas une adresse dynamique, comme avec la plupart des connexions PPP par modem). Si vous êtes derrière un coupe-feu, il doit autoriser le trafic SMTP en votre direction. Si vous voulez recevoir directement le courrier sur votre machine, vous devez être sûrs de l’une de ces deux choses:</p></div><div class=ulist><ul><li><p>Assurez-vous que l’enregistrement MX (le nombre le plus bas) de votre DNS pointe sur l’adresse IP de votre machine.</p></li><li><p>Assurez-vous qu’il n’y a pas d’entrée MX pour votre machine dans votre DNS.</p></li></ul></div><div class=paragraph><p>Une des deux conditions précédentes vous permettra de recevoir directement le courrier pour votre machine.</p></div><div class=paragraph><p>Essayez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hostname</span>
exemple.FreeBSD.org
<span class=c># host exemple.FreeBSD.org</span>
exemple.FreeBSD.org has address 204.216.27.XX</code></pre></div></div><div class=paragraph><p>Si c’est la réponse que vous obtenez, le courrier adressé à <a href=mailto:votreindentifiant@exemple.FreeBSD.org>votreindentifiant@exemple.FreeBSD.org</a> arrivera sans problème (en supposant que sendmail fonctionne correctement sur <code>exemple.FreeBSD.org</code>).</p></div><div class=paragraph><p>Si au lieu de cela vous obtenez quelque chose de similaire à ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host exemple.FreeBSD.org</span>
exemple.FreeBSD.org has address 204.216.27.XX
exemple.FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by hub.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Tout le courrier adressé à votre machine (<code>exemple.FreeBSD.org</code>) arrivera sur <code>hub</code> adressé au même utilisateur au lieu d’être directement envoyé à votre machine.</p></div><div class=paragraph><p>L’information précédente est gérée par votre serveur DNS. L’enregistrement du DNS qui contient l’information de routage de courrier est l’entrée MX (_M_ail e_X_change). S’il n’y pas d’enregistrement MX, le courrier sera directement envoyé à la machine en utilisant son adresse IP.</p></div><div class=paragraph><p>Voici ce que fut à un moment donné l’entrée MX pour <code>freefall.FreeBSD.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</pre></div></div><div class=paragraph><p>Comme vous pouvez le voir, <code>freefall</code> avait plusieurs entrées MX. L’entrée MX dont le numéro est le plus bas est la machine qui reçoit directement le courrier si elle est disponible; si elle n’est pas accessible pour diverses raisons, les autres (parfois appelées "MX de secours") acceptent temporairement les messages, et les transmettent à une machine de numéro plus faible quand elle devient disponible, et par la suite à la machine de numéro le plus bas.</p></div><div class=paragraph><p>Les sites MX alternatifs devraient avoir une connexion Internet séparée de la votre afin d’être les plus utiles. Votre fournisseur d’accès ou tout autre site amical ne devrait pas avoir de problème pour vous fournir ce service.</p></div></div><div class=sect3><h4 id=mail-domain>30.6.2. Courrier pour votre domaine<a class=anchor href=#mail-domain></a></h4><div class=paragraph><p>Pour configurer un serveur de courrier vous devez faire en sorte que tout le courrier à destination des diverses stations de travail lui soit envoyé. Concrètement, vous voulez "revendiquer" tout courrier pour n’importe quelle machine de votre domaine (dans ce cas <code>*.FreeBSD.org</code>) et le détourner vers votre serveur de courrier de sorte que vos utilisateurs puissent recevoir leur courrier sur le serveur de courrier principal.</p></div><div class=paragraph><p>Pour rendre les choses plus aisées, un compte utilisateur avec le même <em>nom d’utilisateur</em> devrait exister sur les deux machines. Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> pour ce faire.</p></div><div class=paragraph><p>Le serveur de courrier que vous utiliserez sera défini comme "mail exchanger" pour chaque station de travail du réseau. Cela est fait dans votre configuration de DNS de cette manière:</p></div><div class="literalblock programlisting"><div class=content><pre>exemple.FreeBSD.org	A	204.216.27.XX		; Station de travail
			MX	10 hub.FreeBSD.org	; Serveur de courrier</pre></div></div><div class=paragraph><p>Cela redirigera le courrier pour votre station de travail au serveur de courrier quelque soit la machine sur laquelle pointe l’enregistrement A. Le courrier est envoyé sur la machine MX.</p></div><div class=paragraph><p>Vous ne pouvez le faire vous-même que si vous gérez un serveur de noms. Si ce n’est pas le cas, ou que vous ne pouvez avoir votre propre serveur DNS, parlez-en à votre fournisseur d’accès ou à celui qui fournit votre DNS.</p></div><div class=paragraph><p>Si vous faites de l’hébergement virtuel du courrier électronique, l’information suivante sera utile. Pour cet exemple, nous supposerons que vous avez un client qui possède son propre domaine, dans notre cas <code>client1.org</code>, et vous voulez que tout le courrier pour <code>client1.org</code> arrive sur votre serveur de courrier, <code>mail.mamachine.com</code>. L’entrée dans votre DNS devrait ressembler à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>client1.org		MX	10	mail.mamachine.com</pre></div></div><div class=paragraph><p>Vous n’avez <em>pas</em> besoin d’un enregistrement A pour <code>client1.org</code> si vous ne voulez gérer que le courrier pour ce domaine.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Soyez conscient que "pinger" <code>client1.org</code> ne fonctionnera pas à moins qu’un enregistrement A existe pour cette machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La dernière chose que vous devez faire est d’indiquer à sendmail sur le serveur de courrier quels sont les domaines et/ou machines pour lesquels il devrait accepter du courrier. Il y a peu de façons différentes de le faire. L’une des deux méthodes suivantes devrait fonctionner:</p></div><div class=ulist><ul><li><p>Ajoutez les machines à votre fichier <span class=filename>/etc/mail/local-host-names</span> si vous utilisez la fonction <code>FEATURE(use_cw_file)</code>. Si vous utilisez une version de sendmail antérieure à la version 8.10, le fichier sera <span class=filename>/etc/sendmail.cw</span>.</p></li><li><p>Ajoutez une ligne <code>Cwyour.host.com</code> à votre fichier <span class=filename>/etc/sendmail.cf</span> ou <span class=filename>/etc/mail/sendmail.cf</span> si vous utilisez sendmail 8.10 ou supérieur.</p></li></ul></div></div></div><div class=sect2><h3 id=SMTP-UUCP>30.7. SMTP avec UUCP<a class=anchor href=#SMTP-UUCP></a></h3><div class=paragraph><p>La configuration de sendmail fournie avec FreeBSD est conçue pour les sites directement connectés à l’Internet. Les sites désirant échanger leur courrier électronique par l’intermédiaire d’UUCP doivent installer un autre fichier de configuration pour sendmail.</p></div><div class=paragraph><p>Modifier manuellement le fichier <span class=filename>/etc/mail/sendmail.cf</span> est un sujet réservé aux spécialistes. Dans version 8 de sendmail la génération des fichiers de configuration se fait par l’intermédiaire du processeur <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a>, où la configuration se fait à un haut niveau d’abstraction. Les fichiers de configuration <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> se trouvent dans le répertoire <span class=filename>/usr/src/usr.sbin/sendmail/cf</span>.</p></div><div class=paragraph><p>Si vous n’avez pas installé toutes les sources du système, l’ensemble des fichiers de configuration de sendmail a été regroupé dans une archive séparée des autres sources. En supposant que vous avez monté votre CDROM FreeBSD contenant les sources, faites:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /cdrom/src</span>
<span class=c># cat scontrib.?? | tar xzf - -C /usr/src/contrib/sendmail</span></code></pre></div></div><div class=paragraph><p>Cette extraction ne donne lieu qu’à une centaine de kilo-octets. Le fichier <span class=filename>README</span> dans le répertoire <span class=filename>cf</span> pourra faire office d’une introduction à la configuration <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a>.</p></div><div class=paragraph><p>La meilleure façon d’ajouter le support UUCP est d’utiliser la fonctionnalité <code>mailertable</code>. Cela créé une base de données que sendmail utilise pour décider de la manière dont il va router le courrier électronique.</p></div><div class=paragraph><p>Tout d’abord, vous devez créer votre fichier <span class=filename>.mc</span>. Le répertoire <span class=filename>/usr/src/usr.sbin/sendmail/cf/cf</span> contient quelques exemples. En supposant que vous avez appelé votre fichier <span class=filename>foo.mc</span>, tout ce dont vous avez besoin de faire pour le convertir en un fichier <span class=filename>sendmail.cf</span> valide est:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/sendmail/cf/cf</span>
<span class=c># make foo.cf</span>
<span class=c># cp foo.cf /etc/mail/sendmail.cf</span></code></pre></div></div><div class=paragraph><p>Un fichier <span class=filename>.mc</span> classique devrait ressembler à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`Votre numéro de version&#39;) OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable&#39;)

define(`UUCP_RELAY&#39;, votre.relai.uucp)
define(`UUCP_MAX_SIZE&#39;, 200000)
define(`confDONT_PROBE_INTERFACES&#39;)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    alias.de.votre.nom.de.machine
Cw    votrenomdenoeuduucp.UUCP</pre></div></div><div class=paragraph><p>Les lignes contenant les directives <code>accept_unresolvable_domains</code>, <code>nocanonify</code>, et <code>confDONT_PROBE_INTERFACES</code> empêcheront l’utilisation du DNS lors de l’envoi du courrier électronique. La directive <code>UUCP_RELAY</code> est nécessaire pour le support de l’UUCP. Mettez juste un nom de machine Internet capable de gérer des adresses d’un pseudo-domaine .UUCP; la plupart du temps, vous mettrez le nom du serveur de messagerie de votre fournisseur d’accès.</p></div><div class=paragraph><p>Après avoir défini tout ceci, vous avez besoin d’un fichier <span class=filename>/etc/mail/mailertable</span>. Si vous n’avez qu’un seul lien avec l’extérieur qui est utilisé pour votre courrier électronique, le fichier suivant devrait suffire:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db  /etc/mail/mailertable
.                             uucp-dom:your.uucp.relay</pre></div></div><div class=paragraph><p>Un exemple plus complexe ressemblerait à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db  /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre></div></div><div class=paragraph><p>Les trois premières lignes gèrent les cas spécifiques où les courriers électroniques pour l’extérieur ne devraient pas être envoyés au serveur par défaut, mais plutôt à des serveurs UUCP voisins afin de "raccourcir" le chemin à parcourir. La ligne suivante gère le courrier électronique destiné au domaine Ethernet local et qui peut être distribué en utilisant le protocole SMTP. Et enfin, les voisins UUCP sont mentionnés dans la notation de pseudo-domaine UUCP, pour permettre à un courrier du type <code>voisin-uucp !destinataire</code> de passer outre les règles par défaut. La dernière ligne doit toujours être un point, ce qui correspond à tout le reste, avec la distribution UUCP vers un voisin UUCP qui sert de passerelle universelle de courrier électronique vers le reste du monde. Tous les noms de noeuds placés après le mot clé <code>uucp-dom:</code> doivent être des noms valides de voisins UUCP, que vous pouvez vérifier en utilisant la commande <code>uuname</code>.</p></div><div class=paragraph><p>Pour vous rappeler que ce fichier doit être converti en un fichier de base de données DBM avant d’être utilisable. La ligne de commande pour accomplir cette conversion est rappelée dans les commentaires au début du fichier <span class=filename>mailertable</span>. Vous devez lancer cette commande à chaque fois que vous modifiez votre fichier <span class=filename>mailertable</span>.</p></div><div class=paragraph><p>Pour finir: si vous n’êtes pas certain du bon fonctionnement de certaines configurations de routage du courrier électronique, rappelez-vous de l’option <code>-bt</code> de sendmail. Cela lance sendmail dans le <em>mode test d’adresse</em>; entrez simplement <code>3,0</code>, suivi de l’adresse que vous désirez tester. La dernière ligne vous indiquera le type d’agent utilisé pour l’envoi, la machine de destination à laquelle l’agent doit envoyer le message, et l’adresse (peut-être traduite) à laquelle il l’enverra. Pour quitter ce mode tapez <span class=keyseq><kbd>Ctrl</kbd>+<kbd>D</kbd></span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sendmail <span class=nt>-bt</span>
ADDRESS TEST MODE <span class=o>(</span>ruleset 3 NOT automatically invoked<span class=o>)</span>
Enter &lt;ruleset&gt; &lt;address&gt;
<span class=o>&gt;</span> 3,0 foo@example.com
canonify           input: foo @ example <span class=nb>.</span> com
...
parse            returns: <span class=nv>$# </span>uucp-dom <span class=nv>$@</span> your.uucp.relay <span class=nv>$:</span> foo &lt; @ example <span class=nb>.</span> com <span class=nb>.</span> <span class=o>&gt;</span>
<span class=o>&gt;</span> ^D</code></pre></div></div></div><div class=sect2><h3 id=outgoing-only>30.8. Configuration pour l’envoi seul<a class=anchor href=#outgoing-only></a></h3><div class=paragraph><p>Il existe de nombreux cas où vous désirez être capable d’uniquement envoyer du courrier électronique par l’intermédiaire d’un relais. Quelques exemples:</p></div><div class=ulist><ul><li><p>Votre ordinateur est une machine de bureau, mais vous voulez utilisez des programmes comme <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. Pour cela vous devez utiliser le relais de courrier électronique de votre FAI.</p></li><li><p>L’ordinateur est un serveur qui ne gère pas le courrier électronique localement, mais a besoin de soumettre tout le courrier à un relais pour qu’il soit transmis.</p></li></ul></div><div class=paragraph><p>N’importe quel MTA est capable d’assurer cette fonction. Malheureusement, il peut être très compliqué de configurer correctement un MTA complet pour juste gérer le courrier sortant. Des logiciels comme sendmail et postfix sont largement surdimensionnés pour cette utilisation.</p></div><div class=paragraph><p>De plus, si vous utilisez un accès Internet classique, votre contrat peut vous interdire de faire tourner un "serveur de courrier électronique".</p></div><div class=paragraph><p>La manière la plus simple pour répondre à ce besoin est d’installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a>. Exécutez les commandes suivantes en tant que <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/mail/ssmtp</span>
<span class=c># make install replace clean</span></code></pre></div></div><div class=paragraph><p>Une fois installé, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> peut être configuré avec un fichier de quatre lignes, <span class=filename>/usr/local/etc/ssmtp/ssmtp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_</pre></div></div><div class=paragraph><p>Assurez-vous d’employer votre adresse électronique réelle pour l’utilisateur <code>root</code>. Utilisez le relais de courrier électronique sortant de votre FAI à la place de <code>mail.example.com</code> (certains FAIs appellent cela le "serveur de courrier sortant" ou le "serveur SMTP").</p></div><div class=paragraph><p>Assurez-vous également d’avoir désactivé sendmail en fixant <code>sendmail_enable="NONE"</code> dans le fichier <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> dispose d’autres options. Consultez le fichier de configuration d’exemple dans le répertoire <span class=filename>/usr/local/etc/ssmtp</span> ou la page de manuel de ssmtp pour quelques exemples et plus d’informations.</p></div><div class=paragraph><p>Configurer ssmtp de cette manière permettra à toute application tournant sur votre ordinateur et ayant besoin d’envoyer un courrier électronique de fonctionner correctement, tout en n’outrepassant pas la politique de votre FAI ou en ne permettant pas l’utilisation de votre ordinateur comme base arrière pour "spammers".</p></div></div><div class=sect2><h3 id=SMTP-dialup>30.9. Utiliser le courrier électronique avec une connexion temporaire<a class=anchor href=#SMTP-dialup></a></h3><div class=paragraph><p>Si vous disposez d’une adresse IP statique, vous ne devez rien changer du paramétrage par défaut. Définissez votre nom de machine pour qu’il corresponde à celui qui vous a été assigné pour l’Internet et sendmail s’occupera du reste.</p></div><div class=paragraph><p>Si votre adresse IP vous est attribuée dynamiquement et que vous utilisez une connexion PPP par modem pour accèder à l’Internet, vous disposez probablement d’une boite aux lettres chez votre fournisseur d’accès. Supposons que le domaine de votre fournisseur d’accès soit <code>example.net</code>, que votre nom d’utilisateur soit <code>user</code>, que vous avez appelé votre machine <code>bsd.home</code>, et que votre fournisseur vous ait demandé d’utiliser la machine <code>relay.example.net</code> comme serveur relai de messagerie électronique.</p></div><div class=paragraph><p>Pour pouvoir rapatrier votre courrier depuis votre boite aux lettres, vous devez installer un agent de rapatriement. L’utilitaire fetchmail est un bon choix car il supporte la plupart des protocoles de messagerie. Ce programme est disponible sous forme de paquetage ou à partir du catalogue des logiciels portés (<a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a>). La plupart du temps, votre fournisseur d’accès fournit l’accès aux boites aux lettre à l’aide du protocole POP. Si vous utilisez PPP en mode utilisateur, vous pouvez automatiquement récupérer votre courrier quand une connexion Internet est établie avec l’entrée suivante dans le fichier <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
!bg su user -c fetchmail</pre></div></div><div class=paragraph><p>Si vous utilisez sendmail (comme montré ci-dessous) pour distribuer le courrier aux comptes non-locaux, vous voudrez probablement que sendmail s’occupe de transmettre les messages en attente dès que votre connexion Internet est établie. Pour cela, ajoutez la commande suivante après la commande <code>fetchmail</code> dans le fichier <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>!bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p>En supposant que vous avez un compte <code>user</code> sur <code>bsd.home</code>. Dans le répertoire de l’utilisateur <code>user</code> sur <code>bsd.home</code>, créez un fichier <span class=filename>.fetchmailrc</span> contenant:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.net protocol pop3 fetchall pass MySecret</pre></div></div><div class=paragraph><p>Ce fichier ne devrait être lisible que par l’utilisateur <code>user</code> car il contient le mot de passe <code>MySecret</code>.</p></div><div class=paragraph><p>Afin de pouvoir envoyer du courrier avec l’entête <code>from:</code> correcte, vous devez configurer sendmail pour utiliser l’adresse <code>user@example.net</code> plutôt que <code>user@bsd.home</code>. Vous pouvez également dire à sendmail d’envoyer le courrier via le serveur <code>relay.example.net</code>, permettant une transmission du courrier plus rapide.</p></div><div class=paragraph><p>Le fichier <span class=filename>.mc</span> suivant devrait suffire:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.example.net&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;,`deferred&#39;)dnl</pre></div></div><div class=paragraph><p>Référez-vous à la section précédente pour des détails sur la conversion de ce fichier <span class=filename>.mc</span> en un fichier <span class=filename>sendmail.cf</span>. N’oubliez pas également de redémarrer sendmail après la mise à jour du fichier <span class=filename>sendmail.cf</span>.</p></div></div><div class=sect2><h3 id=SMTP-Auth>30.10. Authentification SMTP<a class=anchor href=#SMTP-Auth></a></h3><div class=paragraph><p>Disposer de l’authentification SMTP sur votre serveur de courrier présente un certain nombre d’avantages. L’authentification SMTP peut ajouter une autre couche de sécurité à sendmail, et a l’avantage de donner aux utilisateurs mobiles la possibilité d’utiliser le même serveur de courrier sans avoir besoin de reconfigurer les paramètres de leur client courrier à chaque déplacement.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Installez <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> à partir du catalogue des logiciels portés. Vous pouvez trouver ce logiciel porté dans <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a>. <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> dispose de nombreuses options de compilation possibles, pour la méthode que nous allons utiliser ici, assurez-vous de sélectionner l’option <code>pwcheck</code>.</p></li><li><p>Après avoir installé <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a>, éditez <span class=filename>/usr/local/lib/sasl/Sendmail.conf</span> (ou créez-le s’il n’existe pas) et ajoutez la ligne suivante:</p><div class="literalblock programlisting"><div class=content><pre>pwcheck_method: passwd</pre></div></div><div class=paragraph><p>Cette méthode activera au niveau de sendmail l’authentification par l’intermédiaire de votre base de données FreeBSD <span class=filename>passwd</span>. Cela nous épargne le problème de la création d’un nouvel ensemble de nom d’utilisateur et de mot de passe pour chaque utilisateur ayant besoin de recourir à l’authentification SMTP, et conserve le même nom d’utilisateur et mot de passe pour le courrier.</p></div></li><li><p>Maintenant éditez <span class=filename>/etc/make.conf</span> et ajoutez les lignes suivantes:</p><div class="literalblock programlisting"><div class=content><pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl1 -DSASL
SENDMAIL_LDFLAGS=-L/usr/local/lib
SENDMAIL_LDADD=-lsasl</pre></div></div><div class=paragraph><p>Ces lignes passeront à sendmail les bonnes options de configuration au moment de la compilation pour lier <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl/>cyrus-sasl</a>. Assurez-vous que <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl/>cyrus-sasl</a> a été installé avant de recompiler sendmail.</p></div></li><li><p>Recompilez sendmail en lançant les commandes suivantes:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/sendmail</span>
<span class=c># make cleandir</span>
<span class=c># make obj</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>La compilation de sendmail ne devrait pas présenter de problèmes si le répertoire <span class=filename>/usr/src</span> n’a pas subi d’énormes changements et si les bibliothèques partagés nécessaires sont disponibles.</p></div></li><li><p>Une fois que sendmail a été compilé et réinstallé, éditez votre fichier <span class=filename>/etc/mail/freebsd.mc</span> (ou tout autre fichier que vous utilisez comme fichier <span class=filename>.mc</span>. De nombreux administrateurs utilisent la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> comme nom de fichier <span class=filename>.mc</span> par unicité). Ajoutez-y les lignes qui suivents:</p><div class="literalblock programlisting"><div class=content><pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confDEF_AUTH_INFO&#39;, `/etc/mail/auth-info&#39;)dnl</pre></div></div><div class=paragraph><p>Ces options configurent les différentes méthodes disponibles pour sendmail pour l’authentification des utilisateurs. Si vous désirez utiliser une méthode autre que pwcheck, veuillez consulter la documentation fournie.</p></div></li><li><p>Enfin, exécutez <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> quand vous êtes dans <span class=filename>/etc/mail</span>. Cela prendra votre nouveau fichier <span class=filename>.mc</span> et créera un fichier <span class=filename>.cf</span> appelé <span class=filename>freebsd.cf</span> (ou selon tout autre nom que vous avez utilisé pour votre fichier <span class=filename>.mc</span>). Ensuite utilisez la commande <code>make install restart</code>, qui copiera le fichier en <span class=filename>sendmail.cf</span>, et redémarrera proprement sendmail. Pour plus d’informations sur ce processus, vous devriez vous réferrer au fichier <span class=filename>/etc/mail/Makefile</span>.</p></li></ol></div></div></div><div class=paragraph><p>Si tout s’est bien passé, vous devriez être en mesure d’entrer votre identifiant dans votre programme de courrier et d’envoyer un message de test. Pour plus d’investigation, fixez le <code>LogLevel</code> de sendmail à 13 et scrutez <span class=filename>/var/log/maillog</span> à la recherche d’une erreur.</p></div><div class=paragraph><p>Vous pourrez rajouter les lignes suivantes au fichier <span class=filename>/etc/rc.conf</span> afin de rendre ce service disponible après chaque démarrage du système:</p></div><div class="literalblock programlisting"><div class=content><pre>sasl_pwcheck_enable=&#34;YES&#34;
sasl_pwcheck_program=&#34;/usr/local/sbin/pwcheck&#34;</pre></div></div><div class=paragraph><p>Cela assurera l’initialisation de SMTP_AUTH, l’authentification SMTP, au démarrage du système.</p></div><div class=paragraph><p>Pour plus d’informations, veuillez consulter la page de la documentation de sendmail concernant <a href=http://www.sendmail.org/~ca/email/auth.html>l’authentification SMTP</a>.</p></div></div><div class=sect2><h3 id=mail-agents>30.11. Clients de messagerie<a class=anchor href=#mail-agents></a></h3><div class=paragraph><p>Un client de messagerie ("Mail User Agent"-MUA) est une application qui est utilisée pour envoyer et recevoir du courrier électronique. En outre, au fur et à mesure que le système du courrier électronique "évolue" et devient plus complexe, les MUA deviennent de plus en plus puissants, offrant aux utilisateurs plus de fonctionnalités et de flexibilité. FreeBSD offre le support pour de nombreux clients de messagerie, ils peuvent tous être aisément installés à partir du <a href=./#ports>catalogue des logiciels portés de FreeBSD</a>. Les utilisateurs pourront choisir entre des clients de messagerie graphiques comme evolution ou balsa, des clients en mode console tels que mutt, pine ou <code>mail</code>, ou encore les interfaces Web utilisées par certaines organisations importantes.</p></div><div class=sect3><h4 id=mail-command>30.11.1. mail<a class=anchor href=#mail-command></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> est le client de messagerie ("Mail User Agent"-MUA) par défaut de FreeBSD. C’est un MUA en mode console qui offre toutes les fonctionnalités de base nécessaires pour envoyer et lire son courrier électronique en mode texte, cependant il est limité en ce qui concerne les possibilités de pièces jointes et ne supporte que les boîtes aux lettres locales.</p></div><div class=paragraph><p>Bien que <code>mail</code> ne supporte pas l’intéraction avec les serveurs POP ou IMAP, ces boîtes aux lettres peuvent être téléchargées vers un fichier <span class=filename>mbox</span> local en utilisant une application telle que fetchmail, qui sera abordée plus tard dans ce chapitre (<a href=#mail-fetchmail>Utiliser fetchmail</a>).</p></div><div class=paragraph><p>Afin d’envoyer et de recevoir du courrier électronique, invoquez simplement la commande <code>mail</code> comme le montre l’exemple suivant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail</code></pre></div></div><div class=paragraph><p>Le contenu de la boîte aux lettres de l’utilisateur dans <span class=filename>/var/mail</span> est automatiquement lu par l’utilitaire <code>mail</code>. Si la boîte est vide, l’utilitaire rend la main avec un message indiquant qu’aucun courrier électronique ne peut être trouvé. Une fois que la boîte aux lettres a été lue, l’interface de l’application est lancée, et une liste de messages sera affichée. Les messages sont automatiquement numérotés, comme on peut le voir dans l’exemple suivant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mail version 8.1 6/6/93.  Type ? <span class=k>for </span>help.
<span class=s2>&#34;/var/mail/marcs&#34;</span>: 3 messages 3 new
<span class=o>&gt;</span>N  1 root@localhost        Mon Mar  8 14:05  14/510   <span class=s2>&#34;test&#34;</span>
 N  2 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;user account&#34;</span>
 N  3 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;sample&#34;</span></code></pre></div></div><div class=paragraph><p>Les messages peuvent désormais être lus en utilisant la commande <kbd>t</kbd> de <code>mail</code>, suivie du numéro du message qui devra être affiché. Dans cet exemple, nous lirons le premier courrier électronique:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: <span class=nb>test
</span>Date: Mon,  8 Mar 2004 14:05:52 +0200 <span class=o>(</span>SAST<span class=o>)</span>
From: root@localhost <span class=o>(</span>Charlie Root<span class=o>)</span>

This is a <span class=nb>test </span>message, please reply <span class=k>if </span>you receive it.</code></pre></div></div><div class=paragraph><p>Comme nous pouvons le constater dans l’exemple ci-dessus, l’appuie sur la touche <kbd>t</kbd> fera afficher le message avec les entêtes complètes. Pour afficher à nouveau la liste des messages, la touche <kbd>h</kbd> doit être utilisée.</p></div><div class=paragraph><p>Si le message nécessite une réponse, vous pouvez utiliser <code>mail</code> pour cela, en entrant soit la touche <kbd>R</kbd>, soit la touche <kbd>r</kbd>. La touche <kbd>R</kbd> demande à <code>mail</code> de ne répondre qu’à l’expéditeur du message, alors que <kbd>r</kbd> répond à l’expéditeur mais également aux autres destinataires du message. Vous pouvez ajouter à la suite de ces commandes le numéro du courrier auquel vous désirez répondre. Une fois cela effectué, la réponse doit être tapée, et la fin du message doit être indiquée par un <kbd>.</kbd> sur une nouvelle ligne. Ci-dessous est présenté un exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% R 1
To: root@localhost
Subject: Re: <span class=nb>test

</span>Thank you, I did get your email.
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Afin d’envoyer un nouveau courrier électronique, la touche <kbd>m</kbd> doit être utilisée, suivie de l’adresse électronique du destinataire. Plusieurs destinataires peuvent également être spécifiés en séparant chaque adresse par une <kbd>,</kbd>. Le sujet du message peut alors être entré, suivi du corps du message. La fin d’un message doit être indiquée en mettant un <kbd>.</kbd> seul sur une nouvelle ligne.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :<span class=o>)</span>
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Bien qu’à partir de l’utilitaire <code>mail</code>, la commande <kbd>?</kbd> puisse être utilisée à tout instant pour afficher l’aide, la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> devrait être consultée pour plus d’aide sur <code>mail</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Comme indiqué précédemment, la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> à l’origine n’a pas été conçue pour gérer les pièces jointes, et par conséquent ne s’en sort pas très bien à ce niveau. Les MUAs plus récents comme mutt gérent les pièces jointes de manière plus intelligente. Mais si vous souhaitez toujours utiliser <code>mail</code>, le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/converters/mpack/>converters/mpack</a> vous sera d’une grande aide.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mutt-command>30.11.2. mutt<a class=anchor href=#mutt-command></a></h4><div class=paragraph><p>mutt est un client de messagerie léger mais très puissant, avec de nombreuses fonctionnalités, parmi lesquelles:</p></div><div class=ulist><ul><li><p>la possibilité de gérer les fils ("threads") de discussions;</p></li><li><p>le support PGP pour la signature électronique et le chiffrage de courriers électroniques;</p></li><li><p>le support MIME;</p></li><li><p>le support du format maildir;</p></li><li><p>application hautement configurable et personnalisable.</p></li></ul></div><div class=paragraph><p>Toutes ces caractéristiques font de mutt un des clients de messagerie les plus avancés. Consultez <a href=http://www.mutt.org>http://www.mutt.org</a> pour plus d’informations sur mutt.</p></div><div class=paragraph><p>La version stable de mutt peut être installée en utilisant le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt/>mail/mutt</a>, tandis que la version actuellement en développement peut être installée par l’intermédiaire du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt-devel/>mail/mutt-devel</a>. Une fois installé, mutt peut être lancé en tapant la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mutt</code></pre></div></div><div class=paragraph><p>mutt lira automatiquement le contenu de la boîte aux lettres de l’utilisateur dans <span class=filename>/var/mail</span> et en affiche le contenu le cas échéant. Si aucun message n’est trouvé dans cette boîte, alors mutt attendra une commande de l’utilisateur. L’exemple ci-dessous montre mutt affichant une liste de messages:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt1.png alt=mutt1></div></div><div class=paragraph><p>Afin de lire un message, sélectionnez-le en utilisant les touches fléchées, et appuyez sur <kbd>Entrée</kbd>. Un exemple montrant mutt affichant le contenu d’un message est donné ci-dessous:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt2.png alt=mutt2></div></div><div class=paragraph><p>Comme avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, mutt permet aux utilisateurs de répondre uniquement à l’expéditeur du message comme également à l’ensemble de ses destinataires. Pour répondre uniquement à l’expéditeur du courrier électronique, utilisez le raccourci clavier <kbd>r</kbd>. Pour faire une réponse groupée, qui sera envoyée à l’expéditeur comme à tous les destinataires du message, utilisez la touche <kbd>g</kbd>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>mutt emploie <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> comme éditeur pour la création et la réponse aux courriers électronique. Cela peut être modifié par l’utilisateur en créant son propre fichier <span class=filename>.muttrc</span> dans leur répertoire personnel et en positionnant la variable <code>editor</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Pour rédiger un nouveau message, appuyez sur la touche <kbd>m</kbd>. Après avoir donné un sujet valide, mutt lancera <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> et l’intégralité du message pourra être écrite. Une fois le courrier électronique rédigé, sauvegardez et quittez <code>vi</code> et mutt réapparaîtra affichant un écran résumant le courrier devant être envoyé. Pour envoyer le message, appuyez sur <kbd>y</kbd>. Un exemple de résumé peut être vu ci-dessous:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt3.png alt=mutt3></div></div><div class=paragraph><p>mutt propose également une aide complète, qui peut être consultée à partir de la plupart des menus en appuyant sur la touche <kbd>?</kbd>. La ligne située en haut de l’écran affiche également les raccourcis clavier appropriés.</p></div></div><div class=sect3><h4 id=pine-command>30.11.3. pine<a class=anchor href=#pine-command></a></h4><div class=paragraph><p>pine est destiné aux débutants, mais il dispose également de fonctions avancées.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Plusieurs vulnérabilités exploitables à distance ont été découvertes dans le logiciel pine par le passé, autorisant à un agresseur distant d’exécuter un programme arbitraire en tant qu’utilisateur local du système, en envoyant un courrier électronique particulier. Tous les problèmes <em>connus</em> ont été corrigés, mais le code source de pine est écrit d’une manière assez peu sécurisée et l’officier de sécurité de FreeBSD pense qu’il existe d’autres failles qui ne sont pas encore découvertes. Vous installez donc pine à vos propres risques.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La version actuelle de pine peut être installée en utilisant le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/mail/pine4/>mail/pine4</a>. Une fois installé, pine peut être lancé en tapant la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pine</code></pre></div></div><div class=paragraph><p>Lors du premier lancement de pine, ce dernier affiche une page de présentation avec une brève introduction, ainsi qu’un message de la part de l’équipe de développement de pine demandant l’envoi d’un courrier électronique anonyme pour leur permettre d’évaluer le nombre d’utilisateurs de leur client de messagerie. Pour envoyer ce courrier anonyme, appuyez sur <kbd>Entrée</kbd>, ou sinon appuyez sur <kbd>E</kbd> pour quitter la présentation sans envoyer de message anonyme. Un exemple de page de présentation peut être vu ci-dessous:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine1.png alt=pine1></div></div><div class=paragraph><p>Le menu principal est ensuite affiché, menu dans lequel il est aisé de naviguer avec les touches fléchées. Ce menu principal fournit les raccourcis pour la rédaction de nouveaux messages, la navigation dans les répertoires de messages, et même la gestion des entrées du carnet d’adresses. Sous le menu principal, les raccourcis clavier correspondants pour effectuer les différentes tâches sont donnés.</p></div><div class=paragraph><p>Le répertoire ouvert par défaut par pine est <span class=filename>inbox</span>. Pour afficher l’index des messages, appuyez sur <kbd>I</kbd>, ou sélectionnez l’option <span class=guimenuitem>MESSAGE INDEX</span> comme montré ci-dessous:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine2.png alt=pine2></div></div><div class=paragraph><p>L’index des messages montre les messages dans le répertoire courant, on peut se déplacer dans l’index en utilisant les touches fléchées. Les messages en surbrillance peuvent être lus en appuyant sur la touche <kbd>Enter</kbd>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine3.png alt=pine3></div></div><div class=paragraph><p>Dans la capture d’écran ci-dessous, un message d’exemple est affiché par pine. Les raccourcis clavier sont affichés au bas de l’écran. Un exemple de raccourci est la touche <kbd>r</kbd>, qui demande au programme de répondre au message actuellement à l’écran.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine4.png alt=pine4></div></div><div class=paragraph><p>La rédaction d’une réponse à un courrier électronique avec pine se fait en utilisant l’éditeur pico, qui est installé par défaut avec pine. L’utilitaire pico rend aisé les déplacements dans le message et est plus indulgent avec les novices que <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>. Une fois la réponse rédigée, le message peut être envoyé en appuyant sur <span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>. pine vous demandera de confirmer votre action.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine5.png alt=pine5></div></div><div class=paragraph><p>Le programme pine peut être personnalisé en utilisant l’option <span class=guimenuitem>SETUP</span> du menu principal. Consultez <a href=http://www.washington.edu/pine/>http://www.washington.edu/pine/</a> pour plus d’information.</p></div></div></div><div class=sect2><h3 id=mail-fetchmail>30.12. Utiliser fetchmail<a class=anchor href=#mail-fetchmail></a></h3><div class=paragraph><p>fetchmail est un client IMAP et POP complet qui offre aux utilisateurs le téléchargement automatiquement de leur courrier électronique à partir de serveurs IMAP et POP distants et sa sauvegarde dans des boîtes aux lettres locales; ainsi, le courrier électronique pourra être consulté plus facilement. fetchmail peut être installé en utilisant le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a>, et offre diverses fonctionnalités, dont:</p></div><div class=ulist><ul><li><p>le support des protocoles POP3, APOP, KPOP, IMAP, ETRN et ODMR;</p></li><li><p>la capacité de faire suivre le courrier électronique en utilisant SMTP, ce qui autorise le filtrage, le transfert, et la gestion des alias de fonctionner correctement;</p></li><li><p>la possibilité de fonctionner en mode "daemon" pour contrôler périodiquement si il y a de nouveaux messages;</p></li><li><p>la possibilité de récupérer le courrier de plusieurs boîtes aux lettres et de le transférer en fonction d’une configuration bien précise aux différents utilisateurs locaux.</p></li></ul></div><div class=paragraph><p>Bien qu’expliquer l’intégralité des fonctions de fetchmail dépasse le cadre de ce document, certaines fonctions de base seront abordées. L’utilitaire fetchmail nécessite un fichier de configuration nommé <span class=filename>.fetchmailrc</span>, afin de fonctionner correctement. Ce fichier comprend les informations concernant les serveurs ainsi que les accréditations d’accès. En raison du caractère sensible du contenu de ce fichier, il est recommandé de ne le rendre lisible que par l’utilisateur, avec la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>600 .fetchmailrc</code></pre></div></div><div class=paragraph><p>Le fichier <span class=filename>.fetchmailrc</span> suivant sert d’exemple pour récupérer le courrier électronique pour un seul utilisateur à partir d’une boîte aux lettres utilisant le protocole POP. Il demande à fetchmail de se connecter à <code>example.com</code> en utilisant le nom d’utilisateur <code>joesoap</code> et le mot de passe <code>XXX</code>. Dans cet exemple on suppose que l’utilisateur <code>joesoap</code> est également un utilisateur sur le système local.</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com protocol pop3 username &#34;joesoap&#34; password &#34;XXX&#34;</pre></div></div><div class=paragraph><p>L’exemple suivant présente la connexion à plusieurs serveurs POP et IMAP et la redirection vers différents utilisateurs locaux quand c’est nécessaire:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com proto pop3:
user &#34;joesoap&#34;, with password &#34;XXX&#34;, is &#34;jsoap&#34; here;
user &#34;andrea&#34;, with password &#34;XXXX&#34;;
poll example2.net proto imap:
user &#34;john&#34;, with password &#34;XXXXX&#34;, is &#34;myth&#34; here;</pre></div></div><div class=paragraph><p>L’utilitaire fetchmail peut être exécuté en mode "daemon" en le lançant avec le paramètre <code>-d</code>, suivi par l’intervalle de temps (en secondes) que fetchmail doit respecter entre chaque consultation des serveurs listés dans le fichier <span class=filename>.fetchmailrc</span>. L’exemple suivant demandera à fetchmail de récupérer le courrier toutes les 60 secondes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% fetchmail <span class=nt>-d</span> 60</code></pre></div></div><div class=paragraph><p>Plus d’informations concernant fetchmail peuvent être trouvées sur <a href=http://www.catb.org/~esr/fetchmail/>http://www.catb.org/~esr/fetchmail/</a>.</p></div></div><div class=sect2><h3 id=mail-procmail>30.13. Utiliser procmail<a class=anchor href=#mail-procmail></a></h3><div class=paragraph><p>L’utilitaire procmail est une application extrêmement puissante utilisée pour filtrer le courrier électronique entrant. Il permet aux utilisateurs de définir des "règles" qui seront utilisées sur le courrier entrant pour effectuer des opérations particulières ou pour transférer le courrier vers d’autres boîtes aux lettres et/ou adresses électroniques. procmail peut être installé en utilisant le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/mail/procmail/>mail/procmail</a>. Une fois installé, il peut être intégré dans la plupart des MTAs, consultez la documentation de votre MTA pour plus d’information. Alternativement, procmail peut être intégré en ajoutant la ligne suivante à un fichier <span class=filename>.forward</span> dans le répertoire personnel de l’utilisateur employant les fonctionnalités de procmail:</p></div><div class="literalblock programlisting"><div class=content><pre>&#34;|exec /usr/local/bin/procmail || exit 75&#34;</pre></div></div><div class=paragraph><p>La suite de cette section présentera quelques règles de base pour procmail, avec une brève description de ce qu’elles font. Ces règles, ainsi que d’autres, doivent être ajoutées dans le fichier <span class=filename>.procmailrc</span>, qui doit résider dans le répertoire personnel de l’utilisateur.</p></div><div class=paragraph><p>La majorité de ces règles peut également être trouvée dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=procmailex&amp;sektion=5&amp;format=html">procmailex(5)</a>.</p></div><div class=paragraph><p>Transférer tout courrier en provenance de <code>user@example.com</code> vers l’adresse externe <code>goodmail@example2.com</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^From.*user@example.com
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Transférer tous les courriers d’une taille inférieure à 1000 octets vers l’adresse externe <code>goodmail@example2.com</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
*  1000
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Mettre tout le courrier à destination de <code>alternate@example.com</code> dans une boîte aux lettres appelée <span class=filename>alternate</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^TOalternate@example.com
alternate</pre></div></div><div class=paragraph><p>Envoyer tous les courriers avec pour sujet "Spam" vers <span class=filename>/dev/null</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
^Subject:.*Spam
/dev/null</pre></div></div><div class=paragraph><p>Une recette utile pour trier les courriers en provenance des listes de diffusion <code>FreeBSD.org</code> et placer chaque liste dans sa propre boîte aux lettres:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}</pre></div></div></div></div></div><div class=sect1><h2 id=network-servers>Chapitre 31. Serveurs réseau<a class=anchor href=#network-servers></a></h2><div class=sectionbody><div class=sect2><h3 id=network-servers-synopsis>31.1. Synopsis<a class=anchor href=#network-servers-synopsis></a></h3><div class=paragraph><p>Ce chapitre abordera certains des services réseaux les plus fréquemment utilisés sur les systèmes UNIX®. Nous verrons comment installer, configurer, tester et maintenir plusieurs types différents de services réseaux. De plus, des exemples de fichier de configuration ont été inclus tout au long de ce chapitre pour que vous puissiez en bénéficier.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Comment gérer le "daemon" inetd.</p></li><li><p>Comment configurer un système de fichiers réseau.</p></li><li><p>Comment mettre en place un serveur d’information sur le réseau pour partager les comptes utilisateurs.</p></li><li><p>Comment configurer le paramétrage réseau automatique en utilisant DHCP.</p></li><li><p>Comment configurer un serveur de noms de domaine.</p></li><li><p>Comment configurer le serveur HTTP Apache.</p></li><li><p>Comment configurer un serveur de transfert de fichier (FTP).</p></li><li><p>Comment configurer un serveur de fichiers et d’impression pour des clients Windows® en utilisant Samba.</p></li><li><p>Comment synchroniser l’heure et la date, et mettre en place en serveur de temps, avec le protocole NTP.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les bases des procédures <span class=filename>/etc/rc</span>.</p></li><li><p>Etre familier avec la terminologie réseau de base.</p></li><li><p>Savoir comment installer des applications tierce-partie (<a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-inetd>31.2. Le "super-serveur" inetd<a class=anchor href=#network-inetd></a></h3><div class=sect3><h4 id=network-inetd-overview>31.2.1. Généralités<a class=anchor href=#network-inetd-overview></a></h4><div class=paragraph><p>On fait parfois référence à <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> comme étant le "super-serveur Internet" parce qu’il gère les connexions pour plusieurs services. Quand une connexion est reçue par inetd, ce dernier détermine à quel programme la connexion est destinée, invoque le processus en question et lui délègue la "socket" (le programme est invoqué avec la "socket" service comme entrée standard, sortie et descripteurs d’erreur). Exécuter inetd pour les serveurs qui ne sont pas utilisés intensément peut réduire la charge système globale quand on compare avec l’exécution de chaque "daemon" individuellement en mode autonome.</p></div><div class=paragraph><p>inetd est utilisé pour invoquer d’autres "daemon"s, mais plusieurs protocoles triviaux sont gérés directement, comme chargen, auth, et daytime.</p></div><div class=paragraph><p>Cette section abordera la configuration de base d’inetd à travers ses options en ligne de commande et son fichier de configuration <span class=filename>/etc/inetd.conf</span>.</p></div></div><div class=sect3><h4 id=network-inetd-settings>31.2.2. Configuration<a class=anchor href=#network-inetd-settings></a></h4><div class=paragraph><p>inetd est initialisé par l’intermédiaire du système <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>. L’option <code>inetd_enable</code> est positionnée à la valeur <code>NO</code> par défaut, mais peut être activée par sysinstall lors de l’installation en fonction de la configuration choisie par l’utilisateur. Placer</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>ou</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>dans <span class=filename>/etc/rc.conf</span> activera ou désactivera le lancement d’inetd à la mise en route du système. La commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/inetd rcvar</span></code></pre></div></div><div class=paragraph><p>peut être lancée pour afficher le paramétrage en vigueur.</p></div><div class=paragraph><p>De plus, différentes options de ligne de commande peuvent être passées à inetd par l’intermédiaire de l’option <code>inetd_flags</code>.</p></div></div><div class=sect3><h4 id=network-inetd-cmdline>31.2.3. Options en ligne de commande<a class=anchor href=#network-inetd-cmdline></a></h4><div class=paragraph><p>Comme la plupart des "daemons", inetd possède de nombreuses options que l’on peut passer à son lancement afin de modifier son comportement. La liste complète des options se présente sous la forme:</p></div><div class=paragraph><p><code>inetd [-d] [-l] [-w] [-W] [-c maximum] [-C taux] [-a adresse | nom de machine] [-p fichier] [-R taux] [fichier de configuration]</code></p></div><div class=paragraph><p>Les options peuvent être passées à inetd en utilisant le paramètre <code>inetd_flags</code> dans <span class=filename>/etc/rc.conf</span>. Par défaut, <code>inetd_flags</code> contient <code>-wW -C 60</code>, qui active le "TCP wrapping" pour les services inetd, et empêche l’invocation d’un service plus de 60 fois par minute à partir d’une unique adresse IP.</p></div><div class=paragraph><p>Les novices seront heureux d’apprendre que ce paramétrage n’a en général pas besoin d’être modifié, cependant nous présentons ci-dessous les options de limitation du taux d’invocation étant donné que cela peut être utile si vous recevez une quantité excessive de connexions. Une liste complète d’options peut être trouvée dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>-c maximum</dt><dd><p>Spécifie le nombre maximal par défaut d’invocations simultanées pour chaque service; il n’y a pas de limite par défaut. Cette option peut être surchargée pour chaque service à l’aide du paramètre <code>nb-max-enfants</code>.</p></dd><dt class=hdlist1>-C taux</dt><dd><p>Précise le nombre maximal de fois qu’un service peut être invoqué à partir d’une unique adresse IP et cela sur une minute. Ce paramètre peut être configuré différemment pour chaque service avec le paramètre <code>nb-max-connexions-par-ip-par-minute</code>.</p></dd><dt class=hdlist1>-R taux</dt><dd><p>Précise le nombre maximal de fois qu’un service peut être invoqué par minute; la valeur par défaut est 256. Un taux de 0 autorise un nombre illimité d’invocations.</p></dd><dt class=hdlist1>-s maximum</dt><dd><p>Précise le nombre maximal de fois qu’un service peut être invoqué simultanément à partir d’une adresse IP unique; il n’y a pas de limite par défaut. Cette option peut-être surchargée pour chaque service individuellement avec le paramètre <code>max-child-per-ip</code>.</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-conf>31.2.4. <span class=filename>inetd.conf</span><a class=anchor href=#network-inetd-conf></a></h4><div class=paragraph><p>La configuration d’inetd se fait par l’intermédiaire du fichier <span class=filename>/etc/inetd.conf</span>.</p></div><div class=paragraph><p>Quand le fichier <span class=filename>/etc/inetd.conf</span> est modifié, inetd peut être forcé de relire son fichier de configuration en utilisant la commande:</p></div><div id=network-inetd-reread class=exampleblock><div class=title>Exemple 40. Recharger le fichier de configuration d’inetd</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/inetd reload</span></code></pre></div></div></div></div><div class=paragraph><p>Chaque ligne du fichier de configuration ne mentionne qu’un seul "daemon". Les commentaires dans le fichier sont précédés par un "#". Le format de chaque entrée du fichier <span class=filename>/etc/inetd.conf</span> est le suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>nom-du-service
type-de-socket
protocole
{wait|nowait}[/nb-max-enfants[/nb-connexions-max-par-minute]]
{wait|nowait}[/nb-max-enfants[/nb-connexions-max-par-minute[/nb-max-enfants-par-ip]]]
utilisateur[:groupe][/classe-session]
programme-serveur
arguments-du-programme-serveur</pre></div></div><div class=paragraph><p>Un exemple d’entrée pour le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> utilisant l’IPv4 ressemblerait:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre></div></div><div class=dlist><dl><dt class=hdlist1>nom-du-service</dt><dd><p>C’est le nom de service du "daemon" en question. Il doit correspondre à un des services listés dans le fichier <span class=filename>/etc/services</span>. Cela détermine quel port inetd doit écouter. Si un nouveau service est créé, il doit être ajouté en premier lieu dans <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>type-de-socket</dt><dd><p>Soit <code>stream</code>, soit <code>dgram</code>, soit <code>raw</code>, ou <code>seqpacket</code>. <code>stream</code> doit être utilisé pour les "daemon"s TCP, alors que <code>dgram</code> est utilisé pour les "daemon"s utilisant le protocole UDP.</p></dd><dt class=hdlist1>protocole</dt><dd><p>Un des suivants:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Protocole</th><th class="tableblock halign-left valign-top">Explication</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp, tcp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp, udp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4 et v6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4 et v6</p></td></tr></tbody></table></dd><dt class=hdlist1>{wait|nowait}[/nb-max-enfants[/nb-max-connexions-par-ip-par-minute[/nb-max-enfants-par-ip]]]</dt><dd><p><code>wait|nowait</code> indique si le "daemon" invoqué par inetd est capable ou non de gérer sa propre "socket". Les "socket"s de type <code>dgram</code> doivent utiliser l’option <code>wait</code>, alors que les "daemons à socket stream", qui sont généralement multi-threadés, devraient utiliser <code>nowait</code>. L’option <code>wait</code> a généralement pour conséquence de fournir plusieurs "socket"s à un "daemon", tandis que l’option <code>nowait</code> invoquera un "daemon" enfant pour chaque nouvelle "socket".</p><div class=paragraph><p>Le nombre maximal de "daemon"s qu’inetd peut invoquer peut être fixé en utilisant l’option <code>nb-max-enfants</code>. Si une limite de dix instances pour un "daemon" est nécessaire, <code>/10</code> devra être placé après <code>nowait</code>. Spécifier <code>/0</code> autorise un nombre illimité d’enfant.</p></div><div class=paragraph><p>En plus de <code>nb-max-enfants</code>, deux autres options limitant le nombre maximal de connexions à partir d’un emplacement vers un "daemon" particulier peuvent être activéees. L’option <code>nb-max-connexions-par-ip-par-minute</code> limite le nombre de connexions par minutes à partir d’une adresse IP donnée, par exemple, une valeur de dix limiterait à dix le nombre de tentatives de connexions par minute pour une adresse IP particulière. L’option <code>max-child-per-ip</code> limite le nombre d’enfants qui peuvent être lancés pour une adresse IP unique à un instant donné. Ces options sont utiles pour empêcher l’abus excessif intentionnel ou par inadvertance des ressources d’une machine et les attaques par déni de service ("Denial of Service-DOS").</p></div><div class=paragraph><p>Dans ce champ, <code>wait</code> ou <code>nowait</code> est obligatoire. <code>nb-max-enfants</code>, <code>nb-max-connexions-par-ip-par-minute</code> et <code>max-child-per-ip</code> sont optionnelles.</p></div><div class=paragraph><p>Un "daemon" utilisant un flux de type multi-threadé sans limites <code>nb-max-enfants</code>, <code>nb-max-connexions-par-ip-par-minute</code> ou <code>max-child-per-ip</code> sera tout simplement affecté de l’option <code>nowait</code>.</p></div><div class=paragraph><p>Le même "daemon" avec une limite maximale de dix "daemon" serait: <code>nowait/10</code>.</p></div><div class=paragraph><p>La même configuration avec une limite de vingt connexions par adresse IP par minute et une limite maximale de dix "daemon"s enfant serait: <code>nowait/10/20</code>.</p></div><div class=paragraph><p>Ces options sont utilisées comme valeurs par défaut par le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=fingerd&amp;sektion=8&amp;format=html">fingerd(8)</a>, comme le montre ce qui suit:</p></div><div class="literalblock programlisting"><div class=content><pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</pre></div></div><div class=paragraph><p>Et enfin, un exemple de champ avec un maximum de 100 enfants en tout, avec un maximum de 5 adresses IP distinctes serait: <code>nowait/100/0/5</code>.</p></div></dd><dt class=hdlist1>utilisateur</dt><dd><p>C’est l’utilisateur sous lequel le "daemon" en question est exécuté. En général les "daemon"s tournent sous l’utilisateur <code>root</code>. Pour des questions de sécurité, il est courant de rencontrer des serveurs tournant sous l’utilisateur <code>daemon</code>, ou sous l’utilisateur avec le moins de privilèges: <code>nobody</code>.</p></dd><dt class=hdlist1>programme-serveur</dt><dd><p>Le chemin complet du "daemon" qui doit être exécuté quand une requête est reçue. Si le "daemon" est un service fourni en interne par inetd, alors l’option <code>internal</code> devrait être utilisée.</p></dd><dt class=hdlist1>arguments-programme-serveur</dt><dd><p>Cette option va de pair avec <code>programme-serveur</code> en précisant les arguments, en commençant avec <code>argv[0]</code>, passés au "daemon" lors de son invocation. Si <code>mydaemon -d</code> est la ligne de commande, <code>mydaemon -d</code> sera la valeur de l’option <code>arguments-programme-serveur</code>. Ici également, si le "daemon" est un service interne, utilisez <code>internal</code>.</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-security>31.2.5. Sécurité<a class=anchor href=#network-inetd-security></a></h4><div class=paragraph><p>En fonction des choix effectués à l’installation, plusieurs services peuvent être activés par défaut. S’il n’y a pas de raison particulière à l’utilisation d’un "daemon", envisagez de le désactiver. Ajoutez un caractère "#" devant le "daemon" en question dans le fichier <span class=filename>/etc/inetd.conf</span>, et ensuite <a href=#network-inetd-reread>rechargez la configuration d’inetd</a>. Certains "daemon"s comme fingerd, devraient être évités parce qu’ils peuvent fournir des informations utiles aux personnes malveillantes.</p></div><div class=paragraph><p>Certains "daemon"s n’ont aucune conscience des problèmes de sécurité, et ont un long délai limite, ou pas du tout, d’expiration pour les tentatives de connexions. Cela permet à une personne malveillante d’envoyer régulièrement et de manière espacée des demandes de connexions à un "daemon" particulier, avec pour conséquence de saturer les ressources disponibles. Cela peut être une bonne idée de placer des limitations <code>nb-max-connexions-par-ip-par-minute</code>, <code>max-child</code> ou <code>nb-max-enfants</code> sur certains "daemon"s si vous trouvez que vous avez trop de connexions.</p></div><div class=paragraph><p>Par défaut, le "TCP wrapping" est activé. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> pour plus d’information sur le placement de restrictions TCP pour divers "daemon"s invoqués par inetd.</p></div></div><div class=sect3><h4 id=network-inetd-misc>31.2.6. Divers<a class=anchor href=#network-inetd-misc></a></h4><div class=paragraph><p>daytime, time, echo, discard, chargen, et auth sont des services fournis en interne par inetd.</p></div><div class=paragraph><p>Le service auth fournit les services réseau d’identification, et est configurable à un certain degré, alors que les autres services ne peuvent être que stoppés ou en fonctionnement.</p></div><div class=paragraph><p>Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> pour plus d’informations.</p></div></div></div><div class=sect2><h3 id=network-nfs>31.3. Système de fichiers réseau (NFS)<a class=anchor href=#network-nfs></a></h3><div class=paragraph><p>Parmi les différents systèmes de fichiers que FreeBSD supporte se trouve le système de fichiers réseau, connu sous le nom de NFS. NFS permet à un système de partager des répertoires et des fichiers avec d’autres systèmes par l’intermédiaire d’un réseau. En utilisant NFS, les utilisateurs et les programmes peuvent accéder aux fichiers sur des systèmes distants comme s’ils étaient des fichiers locaux.</p></div><div class=paragraph><p>Certains des avantages les plus remarquables offerts par NFS sont:</p></div><div class=ulist><ul><li><p>Les stations de travail utilisent moins d’espace disque en local parce que les données utilisées en commun peuvent être stockées sur une seule machine tout en restant accessibles aux autres machines sur le réseau.</p></li><li><p>Les utilisateurs n’ont pas besoin d’avoir un répertoire personnel sur chaque machine du réseau. Les répertoires personnels pourront se trouver sur le serveur NFS et seront disponibles par l’intermédiaire du réseau.</p></li><li><p>Les périphériques de stockage comme les lecteurs de disquettes, de CDROM, de disquettes Zip® peuvent être utilisés par d’autres machines sur le réseau. Cela pourra réduire le nombre de lecteurs de medias amovibles sur le réseau.</p></li></ul></div><div class=sect3><h4 id=_comment_nfs_fonctionne>31.3.1. Comment NFS fonctionne<a class=anchor href=#_comment_nfs_fonctionne></a></h4><div class=paragraph><p>NFS consiste en deux éléments principaux: un serveur et un ou plusieurs clients. Le client accède à distance aux données stockées sur la machine serveur. Afin que tout cela fonctionne correctement quelques processus doivent être configurés et en fonctionnement.</p></div><div class=paragraph><p>Sur le serveur, les "daemons" suivants doivent tourner:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Daemon</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nfsd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le "daemon" NFS qui répond aux requêtes des clients NFS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>mountd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le "daemon" de montage NFS qui traite les requêtes que lui passe <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsd&amp;sektion=8&amp;format=html">nfsd(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpcbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ce "daemon" permet aux clients NFS de trouver le port que le serveur NFS utilise.</p></td></tr></tbody></table><div class=paragraph><p>Le client peut également faire tourner un "daemon" connu sous le nom de nfsiod. Le "daemon" nfsiod traite les requêtes en provenance du serveur NFS. Ceci est optionnel, et améliore les performances, mais n’est pas indispensable pour une utilisation normale et correcte. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsiod&amp;sektion=8&amp;format=html">nfsiod(8)</a> pour plus d’informations.</p></div></div><div class=sect3><h4 id=network-configuring-nfs>31.3.2. Configurer NFS<a class=anchor href=#network-configuring-nfs></a></h4><div class=paragraph><p>La configuration de NFS est une opération relativement directe. Les processus qui doivent tourner peuvent tous être lancés au démarrage en modifiant légèrement votre fichier <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Sur le serveur NFS, assurez-vous que les options suivantes sont configurées dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rpcbind_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_flags=&#34;-r&#34;</pre></div></div><div class=paragraph><p>mountd est automatiquement exécuté dès que le serveur NFS est activé.</p></div><div class=paragraph><p>Sur le client, assurez-vous que cette option est présente dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nfs_client_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Le fichier <span class=filename>/etc/exports</span> indique quels systèmes de fichiers NFS devraient être exportés (parfois on utilise le terme de "partagés"). Chaque ligne dans <span class=filename>/etc/exports</span> précise un système de fichiers à exporter et quelles machines auront accès à ce système de fichiers. En plus des machines qui auront accès, des options d’accès peuvent également être présentes. Ces options sont nombreuses mais seules quelques unes seront abordées ici. Vous pouvez aisément découvrir d’autres options en lisant la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a>.</p></div><div class=paragraph><p>Voici quelques exemples d’entrées du fichier <span class=filename>/etc/exports</span>:</p></div><div class=paragraph><p>Les exemples suivants donnent une idée de comment exporter des systèmes de fichiers bien que certains paramètres peuvent être différents en fonction de votre environnement et votre configuration réseau. Par exemple, pour exporter le répertoire <span class=filename>/cdrom</span> pour les trois machines d’exemple qui appartiennent au même domaine que le serveur (d’où l’absence du nom de domaine pour chacune d’entre elles) ou qui ont une entrée dans votre fichier <span class=filename>/etc/hosts</span>. Le paramètre <code>-ro</code> limite l’accès en lecture seule au système de fichiers exporté. Avec ce paramètre, le système distant ne pourra pas écrire sur le système de fichiers exporté.</p></div><div class="literalblock programlisting"><div class=content><pre>/cdrom -ro host1 host2 host3</pre></div></div><div class=paragraph><p>La ligne suivante exporte <span class=filename>/home</span> pour les trois machines en utilisant les adresses IP. C’est une configuration utile si vous disposez d’un réseau privé sans serveur DNS configuré. Le fichier <span class=filename>/etc/hosts</span> pourrait éventuellement être configuré pour les noms de machines internes, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> pour plus d’information. Le paramètre <code>-alldirs</code> autorise l’utilisation des sous-répertoires en tant que point de montage. En d’autres termes, il ne montera pas les sous-répertoires mais autorisera le client à ne monter que les répertoires qui sont nécessaires ou désirés.</p></div><div class="literalblock programlisting"><div class=content><pre>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre></div></div><div class=paragraph><p>La ligne suivante exporte <span class=filename>/a</span> pour que deux clients d’un domaine différent puissent y accéder. Le paramètre <code>-maproot=root</code> autorise l’utilisateur <code>root</code> du système distant à écrire des données sur le système de fichiers exporté en tant que <code>root</code>. Si le paramètre <code>-maproot=root</code> n’est pas précisé, même si un utilisateur dispose d’un accès <code>root</code> sur le système distant, il ne pourra pas modifier de fichiers sur le système de fichiers exporté.</p></div><div class="literalblock programlisting"><div class=content><pre>/a  -maproot=root  host.example.com box.example.org</pre></div></div><div class=paragraph><p>Afin de pouvoir accéder à un système de fichiers exporté, le client doit avoir les permissions de le faire. Assurez-vous que le client est mentionné dans votre fichier <span class=filename>/etc/exports</span>.</p></div><div class=paragraph><p>Dans <span class=filename>/etc/exports</span>, chaque ligne représente l’information d’exportation d’un système de fichiers vers une machine. Une machine distante ne peut être spécifiée qu’une fois par système de fichiers, et ne devrait avoir qu’une seule entrée par défaut. Par exemple, supposons que <span class=filename>/usr</span> soit un seul système de fichiers. Le fichier <span class=filename>/etc/exports</span> suivant serait invalide:</p></div><div class="literalblock programlisting"><div class=content><pre># Invalide quand /usr est un système de fichiers
/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>Un système de fichiers, <span class=filename>/usr</span>, a deux lignes précisant des exportations vers la même machine, <code>client</code>. Le format correct pour une telle situation est:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>Les propriétés d’un système de fichiers exporté vers une machine donnée devraient apparaître sur une ligne. Les lignes sans client sont traitées comme destinée à une seule machine. Cela limite la manière dont vous pouvez exporter les systèmes de fichiers, mais pour la plupart des gens cela n’est pas un problème.</p></div><div class=paragraph><p>Ce qui suit est un exemple de liste d’exportation valide, où les répertoires <span class=filename>/usr</span> et <span class=filename>/exports</span> sont des systèmes de fichiers locaux:</p></div><div class="literalblock programlisting"><div class=content><pre># Exporte src et ports vers client01 et client02, mais seul
# client01 dispose des privilèges root dessus
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# Les machines clientes ont les privilèges root et peuvent monter tout
# de /exports.  N&#39;importe qui peut monter en lecture seule
# /exports/obj
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre></div></div><div class=paragraph><p>Le "daemon"mountd doit être forcé de relire le fichier <span class=filename>/etc/exports</span> à chacune de ses modifications, afin que les changements puissent prendre effet. Cela peut être effectué soit en envoyant un signal HUP au "daemon":</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div><div class=paragraph><p>soit en invoquant la procédure <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> de <code>mountd</code> avec le paramètre approprié:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/mountd onereload</span></code></pre></div></div><div class=paragraph><p>Veuillez consulter la <a href=./#configtuning-rcd>Utilisation du système rc sous FreeBSD</a> pour plus d’information sur l’utilisation des procédures rc.</p></div><div class=paragraph><p>De plus, un redémarrage permettra à FreeBSD de tout configurer proprement. Un redémarrage n’est cependant pas nécessaire. Exécuter les commandes suivantes en tant que <code>root</code> devrait mettre en place ce qui est nécessaire.</p></div><div class=paragraph><p>Sur le serveur NFS:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rpcbind</span>
<span class=c># nfsd -u -t -n 4</span>
<span class=c># mountd -r</span></code></pre></div></div><div class=paragraph><p>Sur le client NFS:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nfsiod -n 4</span></code></pre></div></div><div class=paragraph><p>Maintenant il devrait être possible de monter un système de fichiers distant. Dans nos exemples le nom du serveur sera <code>serveur</code> et le nom du client <code>client</code>. Si vous voulez monter temporairement un système de fichiers distant ou vous voulez simplement tester la configuration, exécutez juste une commande comme celle-ci en tant que <code>root</code> sur le client:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount serveur:/home /mnt</span></code></pre></div></div><div class=paragraph><p>Cela montera le répertoire <span class=filename>/home</span> situé sur le serveur au point <span class=filename>/mnt</span> sur le client. Si tout est correctement configuré vous devriez être en mesure d’entrer dans le répertoire <span class=filename>/mnt</span> sur le client et de voir tous les fichiers qui sont sur le serveur.</p></div><div class=paragraph><p>Si vous désirez monter automatiquement un système de fichiers distant à chaque démarrage de l’ordinateur, ajoutez le système de fichiers au fichier <span class=filename>/etc/fstab</span>. Voici un exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>server:/home	/mnt	nfs	rw	0	0</pre></div></div><div class=paragraph><p>La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> liste toutes les options disponibles.</p></div></div><div class=sect3><h4 id=_verrouillage>31.3.3. Verrouillage<a class=anchor href=#_verrouillage></a></h4><div class=paragraph><p>Certaines applications (par exemple mutt) ont besoin du verrouillage des fichiers pour fonctionner correctement. Dans le cas du NFS, rpc.lockd peut être utilisé pour assurer le verrouillage des fichiers. Pour l’activer, ajouter ce qui suit au fichier <span class=filename>/etc/rc.conf</span> sur les machines clientes et serveur (on suppose que les clients et le serveur NFS sont déjà configurés):</p></div><div class="literalblock programlisting"><div class=content><pre>rpc_lockd_enable=&#34;YES&#34;
rpc_statd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Lancez l’application en utilisant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/nfslocking start</span></code></pre></div></div><div class=paragraph><p>Si un verrouillage réel n’est pas nécessaire entre les clients et le serveur NFS, il est possible de laisser le client NFS effectuer le verrouillage localement en passant l’option <code>-L</code> à <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a>. Veuillez vous référer à la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a> pour de plus amples détails.</p></div></div><div class=sect3><h4 id=_exemples_pratiques_dutilisation>31.3.4. Exemples pratiques d’utilisation<a class=anchor href=#_exemples_pratiques_dutilisation></a></h4><div class=paragraph><p>Il existe de nombreuses applications pratiques de NFS. Les plus communes sont présentés ci-dessous:</p></div><div class=ulist><ul><li><p>Configurer plusieurs machines pour partager un CDROM ou un autre médium. C’est moins cher et souvent une méthode plus pratique pour installer des logiciels sur de multiples machines.</p></li><li><p>Sur les réseaux importants, il peut être plus pratique de configurer un serveur NFS central sur lequel tous les répertoires utilisateurs sont stockés. Ces répertoires utilisateurs peuvent alors être exportés vers le réseau, les utilisateurs devraient alors toujours avoir le même répertoire utilisateur indépendamment de la station de travail sur laquelle ils ouvrent une session.</p></li><li><p>Plusieurs machines pourront avoir un répertoire <span class=filename>/usr/ports/distfiles</span> commun. De cette manière, quand vous avez besoin d’installer un logiciel porté sur plusieurs machines, vous pouvez accéder rapidement aux sources sans les télécharger sur chaque machine.</p></li></ul></div></div><div class=sect3><h4 id=network-amd>31.3.5. Montages automatiques avec amd<a class=anchor href=#network-amd></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> ("automatic mounter daemon"-"daemon" de montage automatique) monte automatiquement un système de fichiers distant dès que l’on accède à un fichier ou un répertoire contenu par ce système de fichiers. Les systèmes de fichiers qui sont inactifs pendant une certaine période seront automatiquement démontés par amd. L’utilisation d’amd offre une alternative simple aux montages permanents qui sont généralement listés dans <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>amd opère en s’attachant comme un serveur NFS aux répertoires <span class=filename>/host</span> et <span class=filename>/net</span>. Quand on accède à un fichier à l’intérieur de ces répertoires, amd recherche le montage distant correspondant et le monte automatiquement. <span class=filename>/net</span> est utilisé pour monter un système de fichiers exporté à partir d’une adresse IP, alors que <span class=filename>/host</span> est utilisé pour monter un système de fichiers exporté à partir d’un nom de machine distant.</p></div><div class=paragraph><p>Un accès à un fichier dans <span class=filename>/host/foobar/usr</span> demandera à amd de tenter de monter l’export <span class=filename>/usr</span> sur la machine <code>foobar</code>.</p></div><div class=exampleblock><div class=title>Exemple 41. Monter un systèmes de fichiers exporté avec amd</div><div class=content><div class=paragraph><p>Vous pouvez voir les systèmes de fichiers exportés par une machine distante avec la commande <code>showmount</code>. Par exemple, pour voir les répertoires exportés par une machine appelée <code>foobar</code>, vous pouvez utiliser:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /host/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>Comme on le voit dans l’exemple, <code>showmount</code> liste <span class=filename>/usr</span> comme une exportation. Quand on change de répertoire pour <span class=filename>/host/foobar/usr</span>, amd tente de résoudre le nom de machine <code>foobar</code> et de monter automatiquement le système exporté désiré.</p></div><div class=paragraph><p>amd peut être lancé par les procédures de démarrage en ajoutant les lignes suivantes dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>amd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>De plus, des paramètres peuvent être passés à amd à l’aide de l’option <code>amd_flags</code>. Par défaut, l’option <code>amd_flags</code> est possitionnée à:</p></div><div class="literalblock programlisting"><div class=content><pre>amd_flags=&#34;-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map&#34;</pre></div></div><div class=paragraph><p>Le fichier <span class=filename>/etc/amd.map</span> définit les options par défaut avec lesquelles les systèmes exportés sont montés. Le fichier <span class=filename>/etc/amd.conf</span> définit certaines des fonctionnalités les plus avancées de amd.</p></div><div class=paragraph><p>Consultez les pages de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=amd.conf&amp;sektion=8&amp;format=html">amd.conf(8)</a> pour plus d’informations.</p></div></div><div class=sect3><h4 id=network-nfs-integration>31.3.6. Problèmes d’intégration avec d’autres systèmes<a class=anchor href=#network-nfs-integration></a></h4><div class=paragraph><p>Certaines cartes Ethernet ISA présentent des limitations qui peuvent poser de sérieux problèmes sur un réseau, en particulier avec NFS. Ce n’est pas une particularité de FreeBSD, mais FreeBSD en est également affecté.</p></div><div class=paragraph><p>Ce problème se produit pratiquement à chaque fois que des systèmes (FreeBSD) PC sont sur le même réseau que des stations de travail très performantes, comme celles de Silicon Graphics, Inc. et Sun Microsystems, Inc. Les montages NFS se feront sans difficulté, et certaines opérations pourront réussir, puis soudain le serveur semblera ne plus répondre au client, bien que les requêtes vers ou en provenance d’autres systèmes continueront à être traitées normalement. Cela se manifeste sur la machine cliente, que ce soit le système FreeBSD ou la station de travail. Sur de nombreux systèmes, il n’est pas possible d’arrêter le client proprement une fois que ce problème apparaît. La seule solution est souvent de réinitialiser le client parce que le problème NFS ne peut être résolu.</p></div><div class=paragraph><p>Bien que la solution "correcte" est d’installer une carte Ethernet plus performante et de plus grande capacité sur le système FreeBSD, il existe une solution simple qui donnera satisfaction. Si le système FreeBSD est le <em>serveur</em>, ajoutez l’option <code>-w=1024</code> lors du montage sur le client. Si le système FreeBSD est le <em>client</em>, alors montez le système de fichiers NFS avec l’option <code>-r=1024</code>. Ces options peuvent être spécifiées dans le quatrième champ de l’entrée <span class=filename>fstab</span> sur le client pour les montages automatiques, ou en utilisant le paramètre <code>-o</code> de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> pour les montages manuels.</p></div><div class=paragraph><p>Il faut noter qu’il existe un problème différent, que l’on confond parfois avec le précédent, qui peut se produire lorsque les serveurs et les clients NFS sont sur des réseaux différents. Si c’est le cas, <em>assurez-vous</em> que vos routeurs transmettent bien les informations UDP nécessaires, ou vous n’irez nulle part, quoi que vous fassiez par ailleurs.</p></div><div class=paragraph><p>Dans les exemples suivants, <code>fastws</code> est le nom de la station de travail (interface) performante, et <code>freebox</code> celui d’une machine (interface) FreeBSD avec une carte Ethernet moins performante. <span class=filename>/sharedfs</span> est le système de fichiers NFS qui sera exporté (consulter la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a>), et <span class=filename>/project</span> sera le point de montage sur le client pour le système de fichiers exporté. Dans tous les cas, des options supplémentaires, telles que <code>hard soft</code> et <code>bg</code> seront peut-être nécessaires pour vos applications.</p></div><div class=paragraph><p>Exemple d’extrait du fichier <span class=filename>/etc/fstab</span> sur <code>freebox</code> quand le système FreeBSD (<code>freebox</code>) est le client:</p></div><div class="literalblock programlisting"><div class=content><pre>fastws:/sharedfs /project nfs rw,-r=1024 0 0</pre></div></div><div class=paragraph><p>Commande de montage manuelle sur <code>freebox</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -r=1024 fastws:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>Exemple d’extrait du fichier <span class=filename>/etc/fstab</span> sur <code>fastws</code> quand le système FreeBSD est le serveur:</p></div><div class="literalblock programlisting"><div class=content><pre>freebox:/sharedfs /project nfs rw,-w=1024 0 0</pre></div></div><div class=paragraph><p>Commande de montage manuelle sur <code>fastws</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -w=1024 freebox:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>Presque n’importe quelle carte Ethernet 16 bits permettra d’opérer sans l’utilisation des paramètres restrictifs précédents sur les tailles des tampons de lecture et d’écriture.</p></div><div class=paragraph><p>Pour ceux que cela intéresse, voici ce qui se passe quand le problème survient, ce qui explique également pourquoi ce n’est pas récupérable. NFS travaille généralement avec une taille de "bloc" de 8 k (bien qu’il arrive qu’il les fragmente en de plus petits morceaux). Comme la taille maximale d’un paquet Ethernet est de 1500 octets, le "bloc" NFS est divisé en plusieurs paquets Ethernet, bien qu’il soit toujours vu comme quelque chose d’unitaire par les couches supérieures du code, et doit être réceptionné, assemblé, et <em>acquitté</em> comme tel. Les stations de travail performantes peuvent traiter les paquets qui composent le bloc NFS les uns après les autres, pratiquement aussi rapidement que le standard le permet. Sur les cartes les plus petites, de moindre capacité, les derniers paquets d’un même bloc écrasent les paquets précédents avant qu’ils aient pu être transmis à la machine et le bloc ne peut être réassemblé ou acquitté. Avec pour conséquence, le dépassement du délai d’attente sur la station de travail qui recommence alors la transmission, mais en renvoyant l’intégralité des 8 K, et ce processus se répète à l’infini.</p></div><div class=paragraph><p>En définissant la taille de bloc inférieure à la taille d’un paquet Ethernet, nous nous assurons que chaque paquet Ethernet complet sera acquitté individuellement, évitant ainsi la situation de blocage.</p></div><div class=paragraph><p>Des écrasements peuvent toujours survenir quand des stations de travail performantes surchargent un système PC de données, mais avec de meilleures cartes, de tels écrasements ne sont pas systématiques pour les "blocs" NFS. Quand un écrasement apparaît, les blocs affectés sont retransmis, et ils y a de fortes chances pour qu’ils soient reçus, assemblés et acquittés.</p></div></div></div><div class=sect2><h3 id=network-nis>31.4. Services d’information réseau (NIS/YP)<a class=anchor href=#network-nis></a></h3><div class=sect3><h4 id=_quest_ce_que_cest>31.4.1. Qu’est-ce que c’est?<a class=anchor href=#_quest_ce_que_cest></a></h4><div class=paragraph><p>NIS, qui signifie "Network Information Services" (services d’information réseau), fut développé par Sun Microsystems pour centraliser l’administration de systèmes UNIX® (à l’origine SunOS™). C’est devenu aujourd’hui un standard industriel; tous les systèmes importants de type UNIX® (Solaris™, HP-UX, AIX®, Linux, NetBSD, OpenBSD, FreeBSD, etc.) supportent NIS.</p></div><div class=paragraph><p>NIS était appelé au départ "Yellow Pages" (page jaunes), mais étant donné que c’était marque déposée, Sun changea le nom. L’ancienne appelation (et yp) est toujours rencontrée et utilisée.</p></div><div class=paragraph><p>C’est un système client/serveur basé sur les RPCs qui permet à un groupe de machines d’un domaine NIS de partager un ensemble de fichiers de configuration communs. Cela permet à un administrateur système de mettre en place des clients NIS avec un minimum de configuration et d’ajouter, modifier ou supprimer les informations de configuration à partir d’un unique emplacement.</p></div><div class=paragraph><p>C’est similaire au système de domaine Windows NT®; bien que l’implémentation interne des deux n’est pas du tout identique, les fonctionnalités de base sont comparables.</p></div></div><div class=sect3><h4 id=_termesprocessus_à_connaître>31.4.2. Termes/processus à connaître<a class=anchor href=#_termesprocessus_à_connaître></a></h4><div class=paragraph><p>Il existe plusieurs termes et processus utilisateurs que vous rencontrerez lors de la configuration de NIS sous FreeBSD, que vous vouliez mettre en place un serveur NIS ou un client NIS:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Terme</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Nom de domaine NIS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Un serveur maître NIS et tous ses clients (y compris ses serveurs esclaves) ont un domaine NIS. Similaire au nom de domaine Windows NT®, le nom de domaine NIS n’a rien à voir avec le système DNS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpcbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Doit tourner afin d’activer les RPC (Remote Procedure Call, appel de procédures distantes, un protocole réseau utilisé par NIS). Si rpcbind ne tourne pas, il sera impossible de faire fonctionner un serveur NIS, ou jouer le rôle d’un client NIS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fait pointer un client NIS vers son serveur NIS. Il récupérera le nom de domaine NIS auprès du système, et en utilisant les RPC, se connectera au serveur. ypbind est le coeur de la communication client-serveur dans un environnement NIS; si ypbind meurt sur une machine cliente, elle ne sera pas en mesure d’accéder au serveur NIS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypserv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ne devrait tourner que sur les serveurs NIS, c’est le processus serveur en lui-même. Si <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> meurt, alors le serveur ne pourra plus répondre aux requêtes NIS (avec un peu de chance, un serveur esclave prendra la relève). Il existe des implémentations de NIS (mais ce n’est pas le cas de celle de FreeBSD), qui n’essayent pas de se reconnecter à un autre serveur si le serveur utilisé précédemment meurt. Souvent, la seule solution dans ce cas est de relancer le processus serveur (ou même redémarrer le serveur) ou le processus ypbind sur le client.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpc.yppasswdd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Un autre processus qui ne devrait tourner que sur les serveurs maître NIS; c’est un "daemon" qui permettra aux clients de modifier leur mot de passe NIS. Si ce "daemon" ne tourne pas, les utilisateurs devront ouvrir une session sur le serveur maître NIS et y changer à cet endroit leur mot de passe.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_comment_cela_fonctionne_t_il>31.4.3. Comment cela fonctionne-t-il?<a class=anchor href=#_comment_cela_fonctionne_t_il></a></h4><div class=paragraph><p>Dans un environnement NIS il y a trois types de machines: les serveurs maîtres, les serveurs esclaves et les clients. Les serveurs centralisent les informations de configuration des machines. Les serveurs maîtres détiennent l’exemplaire de référence de ces informations, tandis que les serveurs esclaves en ont un double pour assurer la redondance. Les clients attendent des serveurs qu’ils leur fournissent ces informations.</p></div><div class=paragraph><p>Le contenu de nombreux fichiers peut être partagé de cette manière. Les fichiers <span class=filename>master.passwd</span>, <span class=filename>group</span>, et <span class=filename>hosts</span> sont fréquemment partagés par l’intermédiaire de NIS. A chaque fois qu’un processus d’une machine cliente a besoin d’une information qu’il trouverait normalement localement dans un de ces fichiers, il émet une requête au serveur NIS auquel il est rattaché pour obtenir cette information.</p></div><div class=sect4><h5 id=_type_de_machine>31.4.3.1. Type de machine<a class=anchor href=#_type_de_machine></a></h5><div class=ulist><ul><li><p>Un <em>serveur NIS maître</em>. Ce serveur, analogue à un contrôleur de domaine Windows NT® primaire, gère les fichiers utilisés par tous les clients NIS. Les fichiers <span class=filename>passwd</span>, <span class=filename>group</span>, et les autres fichiers utilisés par les clients NIS résident sur le serveur maître.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il est possible pour une machine d’être un serveur NIS maître pour plus qu’un domaine NIS. Cependant, ce cas ne sera pas abordé dans cette introduction, qui suppose un environnement NIS relativement petit.</p></div></td></tr></tbody></table></div></li><li><p><em>Serveurs NIS esclaves</em>. Similaire aux contrôleurs de domaine Windows NT® de secours, les serveurs NIS esclaves possèdent une copie des fichiers du serveur NIS maître. Les serveurs NIS esclaves fournissent la redondance nécessaire dans les environnements importants. Ils aident également à à la répartition de la charge du serveur maître: les clients NIS s’attachent toujours au serveur NIS dont ils reçoivent la réponse en premier, y compris si c’est la réponse d’un serveur esclave.</p></li><li><p><em>Clients NIS</em>. Les clients NIS, comme la plupart des stations de travail Windows NT®, s’identifient auprès du serveur NIS (ou le contrôleur de domaine Windows NT® dans le cas de stations de travail Windows NT®) pour l’ouverture de sessions.</p></li></ul></div></div></div><div class=sect3><h4 id=_utiliser_nisyp>31.4.4. Utiliser NIS/YP<a class=anchor href=#_utiliser_nisyp></a></h4><div class=paragraph><p>Cette section traitera de la configuration d’un exemple d’environnement NIS.</p></div><div class=sect4><h5 id=_planification>31.4.4.1. Planification<a class=anchor href=#_planification></a></h5><div class=paragraph><p>Supposons que vous êtes l’administrateur d’un petit laboratoire universitaire. Ce laboratoire dispose de 15 machines FreeBSD, et ne possède pas actuellement de point central d’administration; chaque machine a ses propres fichiers <span class=filename>/etc/passwd</span> et <span class=filename>/etc/master.passwd</span>. Ces fichiers sont maintenus à jour entre eux grâce à des interventions manuelles; actuellement quand vous ajoutez un utilisateur pour le laboratoire, vous devez exécuter <code>adduser</code> sur les 15 machines. Cela doit changer, vous avez donc décidé de convertir le laboratoire à l’utilisation de NIS en utilisant deux machines comme serveurs.</p></div><div class=paragraph><p>La configuration du laboratoire ressemble à quelque chose comme:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Nom de machine</th><th class="tableblock halign-left valign-top">Adresse IP</th><th class="tableblock halign-left valign-top">Rôle de la machine</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ellington</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Maître NIS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>coltrane</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Esclave NIS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>basie</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Station de travail</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bird</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Machine cliente</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cli[1-11]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.[6-17]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Autres machines clientes</p></td></tr></tbody></table><div class=paragraph><p>Si vous mettez en place un système NIS pour la première fois, c’est une bonne idée de penser à ce que vous voulez en faire. Peu importe la taille de votre réseau, il y a quelques décisions à prendre.</p></div><div class=sect5><h6 id=_choisir_un_nom_de_domaine_nis>31.4.4.1.1. Choisir un nom de domaine NIS<a class=anchor href=#_choisir_un_nom_de_domaine_nis></a></h6><div class=paragraph><p>Ce n’est pas le "nom de domaine" dont vous avez l’habitude. Il est plus exactement appelé "nom de domaine NIS". Quand un client diffuse des requêtes pour obtenir des informations, il y inclut le nom de domaine NIS auquel il appartient. C’est ainsi que plusieurs serveurs d’un même réseau peuvent savoir lequel d’entre eux doit répondre aux différentes requêtes. Pensez au nom de domaine NIS comme le nom d’un groupe de machines qui sont reliées entre elles.</p></div><div class=paragraph><p>Certains choisissent d’utiliser leur nom de domaine Internet pour nom de domaine NIS. Ce n’est pas conseillé parce que c’est une source de confusion quand il faut résoudre un problème réseau. Le nom de domaine NIS devrait être unique sur votre réseau et est utile s’il décrit le groupe de machines qu’il représente. Par exemple, le département artistique de Acme Inc. pourrait avoir "acme-art" comme nom de domaine NIS. Pour notre exemple, nous supposerons que vous avez choisi le nom <em>test-domain</em>.</p></div><div class=paragraph><p>Cependant, certains systèmes d’exploitation (notamment SunOS™) utilisent leur nom de domaine NIS pour nom de domaine Internet. Si une ou plusieurs machines sur votre réseau présentent cette restriction, vous <em>devez</em> utiliser votre nom de domaine Internet pour nom de domaine NIS.</p></div></div><div class=sect5><h6 id=_contraintes_au_niveau_du_serveur>31.4.4.1.2. Contraintes au niveau du serveur<a class=anchor href=#_contraintes_au_niveau_du_serveur></a></h6><div class=paragraph><p>Il y a plusieurs choses à garder à l’esprit quand on choisit une machine destinée à être un serveur NIS. Un des problèmes du NIS est le degré de dépendance des clients vis à vis du serveur. Si un client ne peut contacter le serveur de son domaine NIS, la plupart du temps la machine n’est plus utilisable. L’absence d’information sur les utilisateurs et les groupes bloque la plupart des systèmes. Vous devez donc vous assurer de choisir une machine qui ne sera pas redémarré fréquemment, ni utilisée pour du développement. Idéalement, le serveur NIS devrait être une machine dont l’unique utilisation serait d’être un serveur NIS. Si vous avez un réseau qui n’est pas très chargé, il peut être envisagé de mettre le serveur NIS sur une machine fournissant d’autres services, gardez juste à l’esprit que si le serveur NIS n’est pas disponible à un instant donné, cela affectera <em>tous</em> vos clients NIS.</p></div></div></div><div class=sect4><h5 id=_serveurs_nis>31.4.4.2. Serveurs NIS<a class=anchor href=#_serveurs_nis></a></h5><div class=paragraph><p>La copie de référence de toutes les informations NIS est stockée sur une seule machine appelée serveur NIS maître. Les bases de données utilisées pour le stockage de ces informations sont appelées tables NIS ("NIS maps"). Sous FreeBSD ces tables se trouvent dans <span class=filename>/var/yp/[domainname]</span> où <span class=filename>[domainname]</span> est le nom du domaine NIS concerné. Un seul serveur NIS peut gérer plusieurs domaines à la fois, il peut donc y avoir plusieurs de ces répertoires, un pour chaque domaine. Chaque domaine aura son propre jeu de tables.</p></div><div class=paragraph><p>Les serveurs NIS maîtres et esclaves traitent toutes les requêtes NIS à l’aide du "daemon" ypserv. ypserv reçoit les requêtes des clients NIS, traduit le nom de domaine et le nom de table demandés en chemin d’accès à la base de données correspondante et transmet l’information de la base de données au client.</p></div><div class=sect5><h6 id=_configurer_un_serveur_nis_maître>31.4.4.2.1. Configurer un serveur NIS maître<a class=anchor href=#_configurer_un_serveur_nis_maître></a></h6><div class=paragraph><p>Selon vos besoins, la configuration d’un serveur NIS maître peut être relativement simple. FreeBSD offre par défaut un support direct du NIS. Tout ce dont vous avez besoin est d’ajouter les lignes qui suivent au fichier <span class=filename>/etc/rc.conf</span>, et FreeBSD s’occupera du reste pour vous.</p></div><div class="exampleblock procedure"><div class=content><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;</pre></div></div><div class="olist arabic"><ol class=arabic><li><p>Cette ligne définie le nom de domaine NIS, <code>test-domain</code>, à la configuration du réseau (e.g. au démarrage).</p><div class="literalblock programlisting"><div class=content><pre>nis_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Demandera à FreeBSD de lancer les processus du serveur NIS dès que le réseau est en fonctionnement.</p><div class="literalblock programlisting"><div class=content><pre>nis_yppasswdd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Ceci activera le "daemon" rpc.yppasswdd, qui, comme mentionné précedement, permettra aux utilisateurs de modifier leur mot de passe à partir d’une machine cliente.</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Selon votre configuration NIS, vous aurez peut-être à ajouter des entrées supplémentaires. Consultez la <a href=#network-nis-server-is-client>section sur les serveurs NIS qui sont également des clients NIS</a>, plus bas, pour plus de détails.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Maintenant, tout ce que vous devez faire est d’exécuter la commande <code>/etc/netstart</code> en tant que super-utilisateur. Elle configurera tout en utilisant les valeurs que vous avez définies dans <span class=filename>/etc/rc.conf</span>.</p></div></div><div class=sect5><h6 id=_initialisation_des_tables_nis>31.4.4.2.2. Initialisation des tables NIS<a class=anchor href=#_initialisation_des_tables_nis></a></h6><div class=paragraph><p>Les <em>tables NIS</em> sont des fichiers de base de données, qui sont conservés dans le répertoire <span class=filename>/var/yp</span>. Elles sont générées à partir des fichiers de configuration du répertoire <span class=filename>/etc</span> du serveur NIS maître, avec une exception: le fichier <span class=filename>/etc/master.passwd</span>. Et cela pour une bonne raison, vous ne voulez pas divulguer les mots de passe pour l’utilisateur <code>root</code> et autres comptes d’administration aux autres serveurs du domaine NIS. Par conséquent, avant d’initialiser les tables NIS, vous devrez faire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/master.passwd /var/yp/master.passwd</span>
  <span class=c># cd /var/yp</span>
  <span class=c># vi master.passwd</span></code></pre></div></div><div class=paragraph><p>Vous devrez effacer toutes les entrées concernant les comptes système (<code>bin</code>, <code>tty</code>, <code>kmem</code>, <code>games</code>, etc.), tout comme les comptes que vous ne désirez pas propager aux clients NIS (par exemple <code>root</code> et tout autre compte avec un UID 0 (super-utilisateur)).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Assurez-vous que le fichier <span class=filename>/var/yp/master.passwd</span> n’est pas lisible par son groupe ou le reste du monde (mode 600)! Utilisez la commande <code>chmod</code> si nécessaire.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Cela achevé, il est temps d’initialiser les tables NIS! FreeBSD dispose d’une procédure appelée <code>ypinit</code> pour le faire à votre place (consultez sa page de manuel pour plus d’informations). Notez que cette procédure est disponible sur la plupart des systèmes d’exploitation du type UNIX®, mais pas tous. Sur Digital UNIX/Compaq Tru64 UNIX, elle est appelée <code>ypsetup</code>. Comme nous voulons générer les tables pour un maître NIS, nous passons l’option <code>-m</code> à <code>ypinit</code>. Pour générer les tables NIS, en supposant que vous avez effectué les étapes précédentes, lancez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# ypinit <span class=nt>-m</span> test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] y

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</span></code></pre></div></div><div class=paragraph><p><code>ypinit</code> devrait avoir créé <span class=filename>/var/yp/Makefile</span> à partir de <span class=filename>/var/yp/Makefile.dist</span>. Une fois créé, ce fichier suppose que vous être dans un environnement composé uniquement de machines FreeBSD et avec un seul serveur. Comme <code>test-domain</code> dispose également d’un serveur esclave, vous devez éditer <span class=filename>/var/yp/Makefile</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/Makefile</code></pre></div></div><div class=paragraph><p>Vous devez commenter la ligne</p></div><div class="literalblock programlisting"><div class=content><pre>NOPUSH = &#34;True&#34;</pre></div></div><div class=paragraph><p>(si elle n’est pas déjà commentée).</p></div></div><div class=sect5><h6 id=_configurer_un_serveur_nis_esclave>31.4.4.2.3. Configurer un serveur NIS esclave<a class=anchor href=#_configurer_un_serveur_nis_esclave></a></h6><div class=paragraph><p>Configurer un serveur NIS esclave est encore plus simple que de configurer un serveur maître. Ouvrez une session sur le serveur esclave et éditez le fichier <span class=filename>/etc/rc.conf</span> comme précédemment. La seule différence est que nous devons maintenant utiliser l’option <code>-s</code> avec <code>ypinit</code>. L’option <code>-s</code> a besoin du nom du serveur NIS maître, donc notre ligne de commande ressemblera à:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>coltrane# ypinit <span class=nt>-s</span> ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don&#39;</span>t forget to update map ypservers on ellington.</code></pre></div></div><div class=paragraph><p>Vous devriez avoir un répertoire appelé <span class=filename>/var/yp/test-domain</span>. Des copies des tables du serveur NIS maître devraient se trouver dans ce répertoire. Vous devrez vous assurer que ces tables restent à jour. Les entrées suivantes dans <span class=filename>/etc/crontab</span> sur vos serveurs esclaves s’en chargeront:</p></div><div class="literalblock programlisting"><div class=content><pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre></div></div><div class=paragraph><p>Ces deux lignes obligent le serveur esclave à synchroniser ses tables avec celles du serveur maître. Bien que ces entrées ne soient pas indispensables puisque le serveur maître essaye de s’assurer que toute modification de ses tables NIS soit répercutée à ses serveurs esclaves et comme l’information sur les mots de passe est vitale pour les systèmes qui dépendent du serveur, il est bon de forcer les mises à jour. C’est d’autant plus important sur les réseaux chargés où il n’est pas certain que les mises à jour soient intégrales.</p></div><div class=paragraph><p>Maintenant, exécutez la commande <code>/etc/netstart</code> sur le serveur esclave, ce qui lancera le serveur NIS.</p></div></div></div><div class=sect4><h5 id=_clients_nis>31.4.4.3. Clients NIS<a class=anchor href=#_clients_nis></a></h5><div class=paragraph><p>Un client NIS établit une connexion avec un serveur NIS donné par l’intermédiaire du "daemon" ypbind. ypbind consulte le nom de domaine par défaut du système (défini par la commande <code>domainname</code>), et commence à diffuser des requêtes RPC sur le réseau local. Ces requêtes précisent le nom de domaine auquel ypbind essaye de se rattacher. Si un serveur configuré pour ce domaine reçoit une des requêtes diffusées, il répond à ypbind, qui enregistrera l’adresse du serveur. S’il y a plusieurs serveurs disponibles (un maître et plusieurs esclaves par example), ypbind utilisera l’adresse du premier à répondre. Dès lors, le système client dirigera toutes ses requêtes NIS vers ce serveur. ypbind enverra de temps en temps des requêtes "ping" au serveur pour s’assurer qu’il fonctionne toujours. S’il ne reçoit pas de réponse dans un laps de temps raisonnable, ypbind considérera ne plus être attaché au domaine et recommencera à diffuser des requêtes dans l’espoir de trouver un autre serveur.</p></div><div class=sect5><h6 id=_configurer_un_client_nis>31.4.4.3.1. Configurer un client NIS<a class=anchor href=#_configurer_un_client_nis></a></h6><div class=paragraph><p>Configurer une machine FreeBSD en client NIS est assez simple.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Editez le fichier <span class=filename>/etc/rc.conf</span> et ajoutez les lignes suivantes afin de définir le nom de domaine NIS et lancez ypbind au démarrage du réseau:</p><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre></div></div></li><li><p>Pour importer tous les mots de passe disponibles du serveur NIS, effacez tous les comptes utilisateur de votre fichier <span class=filename>/etc/master.passwd</span> et utilisez <code>vipw</code> pour ajouter la ligne suivante à la fin du fichier:</p><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cette ligne permet à chaque utilisateur ayant un compte valide dans les tables de mots de passe du serveur d’avoir un compte sur le client. Il y a plusieurs façons de configurer votre client NIS en modifiant cette ligne. Consultez la section <a href=#network-netgroups>groupes réseau</a> plus bas pour plus d’informations. Pour en savoir plus, reportez-vous à l’ouvrage <code>Managing NFS and NIS</code> de chez O’Reilly.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vous devriez conservez au moins un compte local (i.e. non-importé via NIS) dans votre fichier <span class=filename>/etc/master.passwd</span> et ce compte devrait également être membre du groupe <code>wheel</code>. Si quelque chose se passe mal avec NIS, ce compte peut être utilisé pour ouvrir une session à distance, devenir <code>root</code>, et effectuer les corrections nécessaires.</p></div></td></tr></tbody></table></div></li><li><p>Pour importer tous les groupes disponibles du serveur NIS, ajoutez cette ligne à votre fichier <span class=filename>/etc/group</span>:</p><div class="literalblock programlisting"><div class=content><pre>+:*::</pre></div></div></li></ol></div></div></div><div class=paragraph><p>Une fois que c’est fait, vous devriez être en mesure d’exécuter <code>ypcat passwd</code> et voir la table des mots de passe du serveur NIS.</p></div></div></div></div><div class=sect3><h4 id=_sécurité_du_nis>31.4.5. Sécurité du NIS<a class=anchor href=#_sécurité_du_nis></a></h4><div class=paragraph><p>De façon générale, n’importe quel utilisateur distant peut émettre une requête RPC à destination de <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> et récupérer le contenu de vos tables NIS, en supposant que l’utilisateur distant connaisse votre nom de domaine. Pour éviter ces transactions non autorisées, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> dispose d’une fonctionnalité appelée "securenets" qui peut être utilisée pour restreindre l’accès à un ensemble donné de machines. Au démarrage, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> tentera de charger les informations sur les "securenets" à partir d’un fichier nommé <span class=filename>/var/yp/securenets</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ce chemin d’accès peut varier en fonction du chemin d’accès défini par l’option <code>-p</code>. Ce fichier contient des entrées sous la forme de définitions de réseau et d’un masque de sous-réseau séparé par une espace. Les lignes commençant par un "#" sont considérées comme des commentaires. Un exemple de fichier <span class=filename>securenets</span> peut ressembler à ceci:</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># autorise les connexions depuis la machine locale -- obligatoire
127.0.0.1     255.255.255.255
# autorise les connexions de n&#39;importe quelle machine
# du réseau 192.168.128.0
192.168.128.0 255.255.255.0
# autorise les connexions de n&#39;importe quelle machine
# entre 10.0.0.0 et 10.0.15.255
# y compris les machines du laboratoire de test
10.0.0.0      255.255.240.0</pre></div></div><div class=paragraph><p>Si <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> reçoit une requête d’une adresse qui satisfait à ces règles, il la traite normalement. Si une adresse ne correspond pas aux règles, la requête sera ignorée et un message d’avertissement sera enregistré. Si le fichier <span class=filename>/var/yp/securenets</span> n’existe pas, <code>ypserv</code> autorisera les connexions à partir de n’importe quelle machine.</p></div><div class=paragraph><p>Le programme <code>ypserv</code> supporte également l’outil TCP Wrapper de Wietse Venema. Cela permet à l’administrateur d’utiliser les fichiers de configuration de TCP Wrapper pour contrôler les accès à la place de <span class=filename>/var/yp/securenets</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bien que ces deux mécanismes de contrôle d’accès offrent une certaine sécurité, il sont, de même que le test du port privilégié, vulnérables aux attaques par "usurpation" d’adresses. Tout le trafic relatif à NIS devrait être bloqué par votre coupe-feu.</p></div><div class=paragraph><p>Les serveurs utilisant <span class=filename>/var/yp/securenets</span> pourront échouer à traiter les requêtes de clients NIS légitimes avec des implémentation TCP/IP archaïques. Certaines de ces implémentations positionnent à zéro les bits de la partie machine de l’adresse IP lors de diffusions et/ou sont incapables respecter le masque de sous-réseau lors du calcul de l’adresse de diffusion. Alors que certains de ces problèmes peuvent être corrigés en modifiant la configuration du client, d’autres problèmes peuvent forcer le retrait des systèmes clients fautifs ou l’abandon de <span class=filename>/var/yp/securenets</span>.</p></div><div class=paragraph><p>Utiliser <span class=filename>/var/yp/securenets</span> sur un serveur avec une implémentation TCP/IP archaïque est une mauvaise idée et sera à l’origine de pertes de la fonctionnalité NIS pour une grande partie de votre réseau.</p></div><div class=paragraph><p>L’utilisation du système TCP Wrapper augmente les temps de latence de votre serveur NIS. Le délai supplémentaire peut être suffisamment long pour dépasser le délai d’attente des programmes clients, tout particulièrement sur des réseaux chargés ou avec des serveurs NIS lents. Si un ou plusieurs de vos systèmes clients souffrent de ces symptômes, vous devrez convertir les systèmes clients en question en serveurs esclaves NIS et les forcer à se rattacher à eux-mêmes.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_interdire_laccès_à_certains_utilisateurs>31.4.6. Interdire l’accès à certains utilisateurs<a class=anchor href=#_interdire_laccès_à_certains_utilisateurs></a></h4><div class=paragraph><p>Dans notre laboratoire, il y a une machine <code>basie</code> qui est supposée être une station de travail de la faculté. Nous ne voulons pas retirer cette machine du domaine NIS, le fichier <span class=filename>passwd</span> sur le serveur maître NIS contient les comptes pour la faculté et les étudiants. Que pouvons-nous faire?</p></div><div class=paragraph><p>Il existe une méthode pour interdire à certains utilisateurs d’ouvrir une session sur une machine, même s’ils sont présents dans la base de données NIS. Pour cela, tout ce dont vous avez besoin de faire est d’ajouter <em>-nom_utilisateur</em> à la fin du fichier <span class=filename>/etc/master.passwd</span> sur la machine cliente, où <em>nom_utilisateur</em> est le nom de l’utilisateur auquel vous désirez refuser l’accès. Ceci doit être fait de préférence avec <code>vipw</code>, puisque <code>vipw</code> contrôlera vos changements au fichier <span class=filename>/etc/master.passwd</span>, et régénérera automatiquement la base de données à la fin de l’édition. Par exemple, si nous voulions interdire l’ouverture de session à l’utilisateur <code>bill</code> sur la machine <code>basie</code> nous ferions:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>basie# vipw
<span class=o>[</span>add <span class=nt>-bill</span> to the end, <span class=nb>exit</span><span class=o>]</span>
vipw: rebuilding the database...
vipw: <span class=k>done

</span>basie# <span class=nb>cat</span> /etc/master.passwd

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class=k>*</span>:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:<span class=k>*</span>:2:5::0:0:System &amp;:/:/sbin/nologin
bin:<span class=k>*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
<span class=nb>tty</span>:<span class=k>*</span>:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:<span class=k>*</span>:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:<span class=k>*</span>:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:<span class=k>*</span>:8:8::0:0:News Subsystem:/:/sbin/nologin
man:<span class=k>*</span>:9:9::0:0:Mister Man Pages:/usr/shared/man:/sbin/nologin
<span class=nb>bind</span>:<span class=k>*</span>:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:<span class=k>*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class=k>*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:<span class=k>*</span>:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:<span class=k>*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
<span class=nt>-bill</span>

basie#</code></pre></div></div></div><div class=sect3><h4 id=network-netgroups>31.4.7. Utiliser les groupes réseau ("netgroups")<a class=anchor href=#network-netgroups></a></h4><div class=paragraph><p>La méthode présentée dans la section précédente fonctionne relativement bien si vous avez besoin de règles spécifiques pour un petit nombre d’utilisateurs et/ou de machines. Sur les réseaux plus important, vous <em>oublierez</em> d’interdire l’accès aux machines sensibles à certains utilisateurs, ou vous devrez même modifier chaque machine séparément, perdant par là même les avantages du NIS: l’administration <em>centralisée</em>.</p></div><div class=paragraph><p>La solution des développeurs du NIS pour ce problème est appelé <em>groupes réseau</em> ("netgroups"). Leur objet et définition peuvent être comparés aux groupes utilisés par les systèmes UNIX®. La principale différence étant l’absence d’identifiants (ID) numériques et la capacité de définir un groupe réseau à l’aide de comptes utilisateur et d’autres groupes réseau.</p></div><div class=paragraph><p>Les groupes réseau furent développés pour gérer des réseaux importants et complexes avec des centaines de machines et d’utilisateurs. C’est une bonne option si vous êtes forcés de faire avec une telle situation. Cependant leur complexité rend impossible une explication avec des exemples simples. L’exemple utilisé dans le reste de cette section met en évidence ce problème.</p></div><div class=paragraph><p>Supposons que l’introduction avec succès de NIS dans votre laboratoire a retenu l’attention de vos supérieurs. Votre mission suivante est d’étendre la couverture de votre domaine NIS à d’autres machines sur le campus. Les deux tables contiennent les noms des nouveaux utilisateurs et des nouvelles machines ainsi qu’une courte description de chacun.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nom(s) d’utilisateurs</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>alpha</code>, <code>beta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les employés du département IT ("Information Technology")</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>charlie</code>, <code>delta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les nouveaux apprentis du département IT</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>echo</code>, <code>foxtrott</code>, <code>golf</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les employés ordinaires</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>able</code>, <code>baker</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les internes actuels</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nom(s) de machines</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>war</code>, <code>death</code>, <code>famine</code>, <code>pollution</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vos serveurs les plus importants. Seuls les employés du département IT sont autorisés à ouvrir des sessions sur ces machines.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pride</code>, <code>greed</code>, <code>envy</code>, <code>wrath</code>, <code>lust</code>, <code>sloth</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Serveurs moins importants. Tous les membres du laboratoire IT sont autorisés à ouvrir des sessions sur ces machines.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>one</code>, <code>two</code>, <code>three</code>, <code>four</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Stations de travail ordinaires. Seuls les employés <em>réels</em> sont autorisés à utiliser ces machines.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>trashcan</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Une très vielle machine sans données sensibles. Même les internes peuvent utiliser cette machine.</p></td></tr></tbody></table><div class=paragraph><p>Si vous avez essayé d’implémenter ces restrictions en bloquant séparément chaque utilisateur, vous avez dû ajouter une ligne <code>-utilisateur</code> à chaque fichier <span class=filename>passwd</span> de chaque système pour chaque utilisateur non-autorisé à ouvrir une session sur le système. Si vous omettez ne serait-ce qu’une entrée, vous aurez des problèmes. Il doit être possible de faire cela lors de la configuration initiale, cependant vous <em>finirez</em> par oublier d’ajouter les lignes pour de nouveaux utilisateurs lors d’opérations quotidiennes. Après tout, Murphy était quelqu’un d’optimiste.</p></div><div class=paragraph><p>Traiter cette situation avec les groupes réseau présente plusieurs avantages. Chaque utilisateur n’a pas besoin d’être traité séparément; vous assignez un utilisateur à un ou plusieurs groupes réseau et autorisez ou refusez l’ouverture de session à tous les membres du groupe réseau. Si vous ajoutez une nouvelle machine, vous n’aurez à définir les restrictions d’ouverture de session que pour les groupes réseau. Ces modifications sont indépendantes les unes des autres, plus de "pour chaque combinaison d’utilisateur et de machine faire…​" Si votre configuration NIS est réfléchie, vous n’aurez à modifier qu’une configuration centrale pour autoriser ou refuser l’accès aux machines.</p></div><div class=paragraph><p>La première étape est l’initialisation de la table NIS du groupe réseau. La version FreeBSD d’<a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a> ne crée pas de table par défaut, mais son implémentation NIS la supportera une fois créée. Pour créer une table vide, tapez simplement</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/netgroup</code></pre></div></div><div class=paragraph><p>et commencez à ajouter du contenu. Pour notre exemple, nous avons besoin de quatre groupes réseau: les employées du département IT, les apprentis du département IT, les employés normaux et les internes.</p></div><div class="literalblock programlisting"><div class=content><pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre></div></div><div class=paragraph><p><code>IT_EMP</code>, <code>IT_APP</code> etc. sont les noms des groupes réseau. Chaque groupement entre parenthèses ajoute un ou plusieurs comptes utilisateurs aux groupes. Les trois champs dans un groupement sont:</p></div><div class="olist arabic"><ol class=arabic><li><p>Le nom de la/les machine(s) où les éléments suivants sont valides. Si vous ne précisez pas un nom de machine, l’entrée est valide sur toutes les machines. Si vous précisez un nom de machine, vous pénétrerez dans un royaume obscure, d’horreur et de confusion totale.</p></li><li><p>Le nom du compte qui appartient au groupe réseau.</p></li><li><p>Le domaine NIS pour le compte. Vous pouvez importer les comptes d’autres domaines NIS dans votre groupe réseau si vous êtes une de ces personnes malchanceuses avec plus d’un domaine NIS.</p></li></ol></div><div class=paragraph><p>Chacun de ces champs peut contenir des jokers. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a> pour plus de détails.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Les noms de groupes réseau plus long que 8 caractères ne devraient pas être utilisés, tout particulièrement si vous avez des machines utilisant d’autres systèmes d’exploitation dans votre domaine NIS. Les noms sont sensibles à la casse des caractères; utiliser des majuscules pour vos noms de groupes réseau est une méthode simple pour distinguer les utilisateurs, les machines et les noms de groupes réseau.</p></div><div class=paragraph><p>Certains clients NIS (autres que FreeBSD) ne peuvent gérer les groupes réseau avec un grand nombre d’entrées. Par exemple, certaines anciennes versions de SunOS™ commencent à causer des problèmes si un groupe réseau contient plus de 15 <em>entrées</em>. Vous pouvez contourner cette limite en créant plusieurs sous-groupes réseau avec 15 utilisateurs ou moins et un véritable groupe réseau constitué des sous-groupes réseau:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre></div></div><div class=paragraph><p>Vous pouvez répéter ce processus si vous avez besoin de plus de 255 utilisateurs dans un seul groupe réseau.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Activer et propager votre nouvelle table NIS est simple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# <span class=nb>cd</span> /var/yp
ellington# make</code></pre></div></div><div class=paragraph><p>Ceci générera les trois tables NIS <span class=filename>netgroup</span>, <span class=filename>netgroup.byhost</span> et <span class=filename>netgroup.byuser</span>. Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a> pour contrôler si vos nouvelles tables NIs sont disponibles:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington% ypcat <span class=nt>-k</span> netgroup
ellington% ypcat <span class=nt>-k</span> netgroup.byhost
ellington% ypcat <span class=nt>-k</span> netgroup.byuser</code></pre></div></div><div class=paragraph><p>La sortie devrait être semblable au contenu de <span class=filename>/var/yp/netgroup</span>. La deuxième commande ne produira pas de sortie si vous n’avez pas précisé les groupes réseau spécifiques à une machine. La troisième commande peut être utilisée pour obtenir les listes des groupes réseau pour un utilisateur.</p></div><div class=paragraph><p>La configuration du client est plutôt simple. Pour configurer le serveur <code>war</code>, vous devez lancer <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> et remplacer la ligne</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>par</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::</pre></div></div><div class=paragraph><p>Maintenant, seules les données pour les utilisateurs définis dans le groupe réseau <code>IT_EMP</code> sont importées dans la base de données de mots de passe de <code>war</code> et seuls ces utilisateurs sont autorisés à ouvrir une session.</p></div><div class=paragraph><p>Malheureusement, cette limitation s’applique également à la fonction <code>~</code> de l’interpréteur de commandes et toutes les routines de conversion entre nom d’utilisateur et identifiant numérique d’utilisateur. En d’autres termes, <code>cd ~utilisateur</code> ne fonctionnera pas, et <code>ls -l</code> affichera l’ID numérique à la place du nom d’utilisateur et <code>find . -user joe -print</code> échouera avec le message d’erreur <code>No such user</code>. Pour corriger cela, vous devrez importer toutes les entrées d’utilisateurs <em>sans leur autoriser l’ouverture de session sur vos serveurs</em>.</p></div><div class=paragraph><p>Cela peut être fait en ajoutant une autre ligne au fichier <span class=filename>/etc/master.passwd</span>. Cette ligne devrait contenir:</p></div><div class=paragraph><p><code>+:::::::::/sbin/nologin</code>, signifiant "Importer toutes les entrées mais remplacer l’interpréteur de commandes avec <span class=filename>/sbin/nologin</span> dans les entrées importées". Vous pouvez remplacer n’importe quel champ dans l’entrée <code>passwd</code> en plaçant une valeur par défaut dans votre fichier <span class=filename>/etc/master.passwd</span>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Assurez-vous que <code>:::::::::/sbin/nologin` est placée après `@IT_EMP:::::::::</code>. Sinon, tous les comptes utilisateur importés du NIS auront <span class=filename>/sbin/nologin</span> comme interpréteur de commandes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Après cette modification, vous ne devrez uniquement que modifier une des tables NIS si un nouvel employé rejoint le département IT. Vous pourrez utiliser une approche similaire pour les serveurs moins importants en remplaçant l’ancienne ligne <code>+:::::::::</code> dans leur version locale de <span class=filename>/etc/master.passwd</span> avec quelque chose de semblable à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>Les lignes correspondantes pour les stations de travail normales seraient:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>Tout était parfait jusqu’au changement de politique quelques semaines plus tard: le département IT commença à engager des internes. Les internes du département IT sont autorisés à utiliser les stations de travail normales et les serveurs les moins importants; les apprentis du département IT sont autorisés à ouvrir des sessions sur les serveurs principaux. Vous ajoutez alors un nouveau groupe réseau <code>IT_INTERN</code>, ajoutez les nouveaux internes IT à ce groupe réseau et commencez à modifier la configuration sur chaque machine…​ Comme disait l’ancien: "Erreurs dans la planification centralisée mènent à un désordre général".</p></div><div class=paragraph><p>La capacité de NIS à créer des groupes réseau à partir d’autres groupes réseau peut être utilisée pour éviter de telles situations. Une possibilité est la création de groupes réseau basés sur le rôle du groupe. Par exemple vous pourriez créer un groupe réseau appelé <code>BIGSRV</code> pour définir les restrictions d’ouverture de session pour les serveurs importants, un autre groupe réseau appelé <code>SMALLSRV</code> pour les serveurs moins importants et un troisième groupe réseau nommé <code>USERBOX</code> pour les stations de travail normales. Chacun de ces groupes réseau contient les groupes réseau autorisés à ouvrir des sessions sur ces machines. Les nouvelles entrées pour la table NIS de groupes réseau devrait ressembler à ceci:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre></div></div><div class=paragraph><p>Cette méthode qui consiste à définir des restrictions d’ouverture de session fonctionne relativement bien si vous pouvez définir des groupes de machines avec des restrictions identiques. Malheureusement, ceci est une exception et pas une généralité. La plupart du temps, vous aurez besoin de définir des restrictions d’ouverture de session par machine.</p></div><div class=paragraph><p>La définition de groupes réseau spécifiques aux machines est une autre possibilité pour traiter la modification de politique soulignée précédemment. Dans ce scénario, le fichier <span class=filename>/etc/master.passwd</span> de chaque machine contient deux lignes débutant par "+". La première ajoute un groupe réseau avec les comptes autorisés à ouvrir une session sur cette machine, la seconde ajoute tous les comptes avec l’interpréteur de commandes <span class=filename>/sbin/nologin</span>. C’est une bonne idée d’utiliser des majuscules pour le nom de la machine ainsi que celui du groupe réseau. Dans d’autres termes, les lignes en question devraient être semblables à:</p></div><div class="literalblock programlisting"><div class=content><pre>+@NOMMACHINE:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>Une fois cette tâche achevée pour toutes vos machines, vous n’aurez plus jamais à modifier les versions locales du fichier <span class=filename>/etc/master.passwd</span>. Tous les changements futurs peuvent être gérés en modifiant la table NIS. Voici un exemple d’une table de groupes réseau possible pour ce scénario avec quelques petits plus:</p></div><div class="literalblock programlisting"><div class=content><pre># Définir tout d&#39;abord les groupes d&#39;utilisateurs
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Définir, maintenant, des groupes basés sur les rôles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# Et un groupe pour les tâches spéciales
# Permettre à echo et golf d&#39;accéder à notre machine anti-virus
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# les groupes réseau basés sur un ensemble de machines
# Nos principaux serveurs
WAR       BIGSRV
FAMINE    BIGSRV
# L&#39;utilisateur india a besoin d&#39;un accès à ce serveur
POLLUTION  BIGSRV  (,india,test-domain)
#
# Celle-ci est très importante et nécessite plus de restrictions d&#39;accès
DEATH     IT_EMP
#
# La machine anti-virus mentionnée précédemment
ONE       SECURITY
#
# Restreindre l&#39;accès à une machine à un seul utilisateur
TWO       (,hotel,test-domain)
# [...d&#39;autres groupes suivent]</pre></div></div><div class=paragraph><p>Si vous utilisez une sorte de base de données pour gérer vos comptes utilisateur, vous devriez pouvoir créer la première partie de la table avec les outils de votre base de données. De cette façon, les nouveaux utilisateurs auront automatiquement accès aux machines.</p></div><div class=paragraph><p>Dernier avertissement: il n’est pas toujours conseillé d’utiliser des groupes réseau basés sur les machines. Si vous déployez quelques douzaines ou même centaines de machines identiques pour des laboratoires pour étudiants, vous devriez utiliser des groupes basés sur les types d’utilisateurs plutôt que sur les machines pour conserver la taille de la table NIS dans des limites raisonnables.</p></div></div><div class=sect3><h4 id=_les_choses_importantes_à_ne_pas_oublier>31.4.8. Les choses importantes à ne pas oublier<a class=anchor href=#_les_choses_importantes_à_ne_pas_oublier></a></h4><div class=paragraph><p>Il y a un certain nombre de choses que vous devrez effectuer différemment maintenant que vous êtes dans un environnement NIS.</p></div><div class=ulist><ul><li><p>A chaque fois que vous désirez ajouter un utilisateur au laboratoire, vous devez l’ajouter <em>uniquement</em> sur le serveur NIS et <em>vous devez ne pas oublier de reconstruire les tables NIS</em>. Si vous oubliez de le faire, le nouvel utilisateur ne pourra pas ouvrir de session en dehors du serveur maître NIS. Par exemple, si nous devons ajouter au laboratoire un nouvel utilisateur <code>jsmith</code>, nous ferions:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd jsmith</span>
<span class=c># cd /var/yp</span>
<span class=c># make test-domain</span></code></pre></div></div><div class=paragraph><p>Vous pouvez lancer <code>adduser jsmith</code> à la place de <code>pw useradd jsmith</code>.</p></div></li><li><p><em>Conservez les comptes d’administration en dehors des tables NIS</em>. Vous ne voulez pas propager les comptes et mots de passe d’administration sur les machines qui auront des utilisateurs qui ne devraient pas avoir accès à ces comptes.</p></li><li><p><em>Sécurisez les serveurs maître et esclave NIS, et réduisez leur temps d’arrêt</em>. Si quelqu’un tente soit d’attaquer soit de simplement arrêter ces machines, de nombreuses personnes ne pourront plus ouvrir de session dans le laboratoire.</p><div class=paragraph><p>C’est la principale faiblesse d’un système d’administration centralisée. Si vous ne protégez pas vos serveurs NIS, vous aurez à faire face à de nombreux utilisateurs mécontents!</p></div></li></ul></div></div><div class=sect3><h4 id=_compatibilité_nis_version_1>31.4.9. Compatibilité NIS version 1<a class=anchor href=#_compatibilité_nis_version_1></a></h4><div class=paragraph><p>ypserv sous FreeBSD offre un support des clients NIS version 1. L’implémentation NIS de FreeBSD utilise uniquement le protocole NIS version 2, cependant d’autres implémentations disposent du support pour le protocole version 1 pour des raisons de compatibilité avec d’anciens systèmes. Les "daemons" ypbind fournis avec ces systèmes tenteront de s’attacher à un serveur NIS version 1 même s’ils n’en ont pas besoin (et ils pourront continuer à diffuser des requêtes pour en trouver un même après avoir reçu une réponse d’un serveur NIS version 2). Notez que bien que les requêtes des clients normaux soient supportées, cette version d’ypserv ne supporte pas les requêtes de transfert de tables version 1; par conséquent il n’est pas possible de l’utiliser comme serveur maître ou esclave avec des serveurs NIS plus anciens qui ne supportent que la version 1 du protocole. Heureusement, il n’y a, aujourd’hui, presque plus de serveurs de ce type actifs.</p></div></div><div class=sect3><h4 id=network-nis-server-is-client>31.4.10. Serveurs NIS qui sont aussi des clients NIS<a class=anchor href=#network-nis-server-is-client></a></h4><div class=paragraph><p>Il faut faire attention quand on utilise ypserv dans un domaine avec plusieurs serveurs NIS qui sont également des clients NIS. Il est en général préférable de forcer les serveurs de se rattacher à eux-mêmes plutôt que de les laisser diffuser des requêtes de rattachement et éventuellement se rattacher réciproquement les uns aux autres. Il peut en résulter de curieux problèmes si l’un des serveurs tombe et que d’autres en dépendent. Tous les clients finiront par dépasser leur délai d’attente et se tenteront de se rattacher à d’autres serveurs, mais ce délai peut être considérable et le problème persistera puisque les serveurs peuvent à nouveau se rattacher les uns aux autres.</p></div><div class=paragraph><p>Vous pouvez obliger une machine à se rattacher à un serveur particulier en exécutant <code>ypbind</code> avec l’option <code>-S</code>. Si vous ne désirez pas faire cela à la main à chaque fois que vous redémarrez votre serveur NIS, vous pouvez ajouter les lignes suivantes à votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nis_client_enable=&#34;YES&#34;	# run client stuff as well
nis_client_flags=&#34;-S NIS domain,server&#34;</pre></div></div><div class=paragraph><p>Voir la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> pour plus d’informations.</p></div></div><div class=sect3><h4 id=_formats_des_mots_de_passe>31.4.11. Formats des mots de passe<a class=anchor href=#_formats_des_mots_de_passe></a></h4><div class=paragraph><p>Un des problèmes les plus courants que l’on rencontre en mettant en oeuvre NIS est celui de la compatibilité des formats de mots de passe. Si votre serveur NIS utilise des mots de passe chiffrés avec l’algorithme DES, il ne supportera que les clients utilisant également DES. Par exemple, si vous avez des client NIS Solaris™ sur votre réseau, alors vous aurez presque certainement besoin d’utiliser des mots de passe chiffrés avec le système DES.</p></div><div class=paragraph><p>Pour déterminer quel format vos serveurs et clients utilisent, consultez le fichier <span class=filename>/etc/login.conf</span>. Si la machine est configurée pour utiliser des mots de passe chiffrés avec DES, alors la classe <code>default</code> contiendra une entrée comme celle-ci:</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Entrées suivantes omises]</pre></div></div><div class=paragraph><p>D’autres valeurs possibles pour la capacité <code>passwd_format</code> sont <code>blf</code> et <code>md5</code> (respectivement pour les chiffrages de mots de passe Blowfish et MD5).</p></div><div class=paragraph><p>Si vous avez modifié le fichier <span class=filename>/etc/login.conf</span>, vous devrez également regénérer la base de données des capacités de classes de session, ce qui est accompli en exécutant la commande suivante en tant que <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Le format des mots de passe utilisés dans <span class=filename>/etc/master.passwd</span> ne sera pas mis à jour avant qu’un utilisateur ne change son mot de passe pour la première fois <em>après</em> la régénération de la base de données des capacités de classes de session.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ensuite, afin de s’assurer que les mots de passe sont chiffrés avec le format que vous avez choisi, vous devez vérifier que l’entrée <code>crypt_default</code> dans le fichier <span class=filename>/etc/auth.conf</span> donne la priorité au format de mots de passe choisi. Par exemple, quand les mots de passe DES sont utilisés, l’entrée serait:</p></div><div class="literalblock programlisting"><div class=content><pre>crypt_default	=	des blf md5</pre></div></div><div class=paragraph><p>En suivant les points précédents sur chaque serveur et client NIS sous FreeBSD, vous pouvez être sûr qu’ils seront tous d’accord sur le format de mot de passe utilisé dans le réseau. Si vous avez des problèmes d’authentification sur un client NIS, c’est probablement la première chose à vérifier. Rappelez-vous: si vous désirez mettre en place un serveur NIS pour un réseau hétérogène, vous devrez probablement utiliser DES sur tous les systèmes car c’est le standard le plus courant.</p></div></div></div><div class=sect2><h3 id=network-dhcp>31.5. Configuration réseau automatique (DHCP)<a class=anchor href=#network-dhcp></a></h3><div class=sect3><h4 id=_quest_ce_que_dhcp>31.5.1. Qu’est-ce que DHCP?<a class=anchor href=#_quest_ce_que_dhcp></a></h4><div class=paragraph><p>DHCP, le protocole d’attribution dynamique des adresses ("Dynamic Host Configuration Protocol"), décrit les moyens par lesquels un système peut se connecter à un réseau et obtenir les informations nécessaires pour dialoguer sur ce réseau. Les versions de FreeBSD antérieures à la version 6.0 utilisent l’implémentation du client DHCP (<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>) de l’ISC (Internet Software Consortium). Les versions suivantes utilisent le programme <code>dhclient</code> d’OpenBSD issu d’OpenBSD 3.7. Toutes les informations données ici au sujet de <code>dhclient</code> sont valables aussi bien pour le client DHCP d’ISC que pour celui d’OpenBSD. Le serveur DHCP est celui distribué par le consortium ISC.</p></div></div><div class=sect3><h4 id=_ce_que_traite_cette_section>31.5.2. Ce que traite cette section<a class=anchor href=#_ce_que_traite_cette_section></a></h4><div class=paragraph><p>Cette section décrit les composants côté client des clients DHCP d’ISC et d' OpenBSD et côté serveur du système DHCP ISC. Le programme client, <code>dhclient</code>, est intégré à FreeBSD, la partie serveur est disponible à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a>. Les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a>, en plus des références données plus bas, sont des ressources utiles.</p></div></div><div class=sect3><h4 id=_comment_cela_fonctionne_t_il_2>31.5.3. Comment cela fonctionne-t-il?<a class=anchor href=#_comment_cela_fonctionne_t_il_2></a></h4><div class=paragraph><p>Quand <code>dhclient</code>, le client DHCP, est exécuté sur la machine cliente, il commence à diffuser des requêtes de demandes d’information de configuration. Par défaut, ces requêtes sont effectuées sur le port UDP 68. Le serveur répond sur le port UDP 67, fournissant au client une adresse IP et d’autres informations réseau importantes comme le masque de sous-réseau, les routeurs, et les serveurs DNS. Toutes ces informations viennent sous la forme d’un "bail" DHCP qui est uniquement valide pendant un certain temps (configuré par l’administrateur du serveur DHCP). De cette façon, les adresses IP expirées pour les clients qui ne sont plus connectés peuvent être automatiquement récupérées.</p></div><div class=paragraph><p>Les clients DHCP peuvent obtenir une grande quantité d’informations à partir du serveur. Une liste exhaustive est donnée dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a>.</p></div></div><div class=sect3><h4 id=_intégration_dans_freebsd>31.5.4. Intégration dans FreeBSD<a class=anchor href=#_intégration_dans_freebsd></a></h4><div class=paragraph><p>Le client DHCP ISC ou OpenBSD (en fonction de la version de FreeBSD que vous utilisez), <code>dhclient</code>, est complètement intégré à FreeBSD. Le support du client DHCP est fourni avec l’installeur et le système de base, rendant évident le besoin d’une connaissance détaillée des configurations réseaux pour n’importe quel réseau utilisant un serveur DHCP. <code>dhclient</code> fait partie de toutes les versions de FreeBSD depuis la version 3.2.</p></div><div class=paragraph><p>DHCP est supporté par sysinstall. Quand on configure une interface réseau sous sysinstall, la deuxième question posée est: "Voulez-vous tenter la configuration DHCP de l’interface?". Répondre par l’affirmative à cette question lancera <code>dhclient</code>, et en cas de succès, complétera automatiquement les informations de configuration réseau.</p></div><div class=paragraph><p>Vous devez faire deux choses pour que votre système utilise DHCP au démarrage:</p></div><div class=ulist><ul><li><p>Assurez-vous que le périphérique <span class=filename>bpf</span> est compilé dans votre noyau. Pour cela, vous devez ajouter la ligne <code>device bpf</code> à votre fichier de configuration du noyau, et recompiler le noyau. Pour plus d’informations sur la compilation de noyaux, consultez le <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>.</p><div class=paragraph><p>Le périphérique <span class=filename>bpf</span> est déjà présent dans le noyau <span class=filename>GENERIC</span> qui est fourni avec FreeBSD, vous ne devez donc pas créer de noyau spécifique pour faire fonctionner DHCP.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ceux qui sont particulièrement conscients de l’aspect sécurité devraient noter que <span class=filename>bpf</span> est également le périphérique qui permet le fonctionnement de "renifleurs" de paquets (de tels programmes doivent être lancés sous l’utilisateur <code>root</code>). <span class=filename>bpf</span><em>est</em> nécessaire pour utiliser DHCP, mais si vous êtes très sensible à la sécurité, vous ne devriez probablement pas ajouter <span class=filename>bpf</span> à votre noyau parce que vous projetez d’utiliser DHCP dans le futur.</p></div></td></tr></tbody></table></div></li><li><p>Editez votre fichier <span class=filename>/etc/rc.conf</span> pour y ajouter ce qui suit:</p><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;DHCP&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Assurez-vous de bien remplacer <code>fxp0</code> par l’interface que vous voulez configurer de façon dynamique comme décrit dans la <a href=./#config-network-setup>Configuration des cartes réseaux</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous utilisez un emplacement différent pour <code>dhclient</code>, ou si vous désirez passer des arguments supplémentaires à <code>dhclient</code>, ajoutez ce qui suit (en effectuant des modifications si nécessaire):</p></div><div class="literalblock programlisting"><div class=content><pre>dhcp_program=&#34;/sbin/dhclient&#34;
dhcp_flags=&#34;&#34;</pre></div></div></li></ul></div><div class=paragraph><p>Le serveur DHCP, dhcpd, fait partie du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> disponible dans le catalogue des logiciels portés. Ce logiciel porté contient le serveur DHCP ISC et sa documentation.</p></div></div><div class=sect3><h4 id=_fichiers>31.5.5. Fichiers<a class=anchor href=#_fichiers></a></h4><div class=ulist><ul><li><p><span class=filename>/etc/dhclient.conf</span></p><div class=paragraph><p><code>dhclient</code> nécessite un fichier de configuration, <span class=filename>/etc/dhclient.conf</span>. Généralement le fichier ne contient que des commentaires, les valeurs par défaut étant suffisantes. Ce fichier de configuration est décrit par la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a>.</p></div></li><li><p><span class=filename>/sbin/dhclient</span></p><div class=paragraph><p><code>dhclient</code> est lié statiquement et réside dans le répertoire <span class=filename>/sbin</span>. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> donne beaucoup plus d’informations au sujet de <code>dhclient</code>.</p></div></li><li><p><span class=filename>/sbin/dhclient-script</span></p><div class=paragraph><p><code>dhclient-script</code> est la procédure de configuration du client DHCP spécifique à FreeBSD. Elle est décrite dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a>, mais ne devrait pas demander de modification de la part de l’utilisateur pour fonctionner correctement.</p></div></li><li><p><span class=filename>/var/db/dhclient.leases</span></p><div class=paragraph><p>Le client DHCP conserve une base de données des baux valides, qui est écrite comme un fichier journal. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a> en donne une description légèrement plus longue.</p></div></li></ul></div></div><div class=sect3><h4 id=_lecture_supplémentaire>31.5.6. Lecture supplémentaire<a class=anchor href=#_lecture_supplémentaire></a></h4><div class=paragraph><p>Le protocole DHCP est intégralement décrit dans la <a href=http://www.freesoft.org/CIE/RFC/2131/>RFC 2131</a>. Des informations sont également disponibles à l’adresse <a href=http://www.dhcp.org/>http://www.dhcp.org/</a>.</p></div></div><div class=sect3><h4 id=network-dhcp-server>31.5.7. Installer et configurer un serveur DHCP<a class=anchor href=#network-dhcp-server></a></h4><div class=sect4><h5 id=_ce_que_traite_cette_section_2>31.5.7.1. Ce que traite cette section<a class=anchor href=#_ce_que_traite_cette_section_2></a></h5><div class=paragraph><p>Cette section fournit les informations nécessaires à la configuration d’un système FreeBSD comme serveur DHCP en utilisant l’implémentation ISC (Internet Software Consortium) du serveur DHCP.</p></div><div class=paragraph><p>Le serveur n’est pas fourni dans le système de base de FreeBSD, et vous devrez installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> pour bénéficier de ce service. Lisez le <a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a> pour plus d’information sur l’utilisation du catalogue des logiciels portés.</p></div></div><div class=sect4><h5 id=_installation_dun_serveur_dhcp>31.5.7.2. Installation d’un serveur DHCP<a class=anchor href=#_installation_dun_serveur_dhcp></a></h5><div class=paragraph><p>Afin de configurer votre système FreeBSD en serveur DHCP, vous devrez vous assurer que le support du périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> est compilé dans votre noyau. Pour cela ajouter la ligne <code>device bpf</code> dans votre fichier de configuration du noyau. Pour plus d’information sur la compilation de noyaux, consultez le <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>.</p></div><div class=paragraph><p>Le périphérique <span class=filename>bpf</span> est déjà présent dans le noyau <span class=filename>GENERIC</span> qui est fourni avec FreeBSD, vous ne devez donc pas créer de noyau spécifique pour faire fonctionner DHCP.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ceux qui sont particulièrement conscients de l’aspect sécurité devraient noter que <span class=filename>bpf</span> est également le périphérique qui permet le fonctionnement de "renifleurs" de paquets (de tels programmes nécessitent également un accès avec privilèges). <span class=filename>bpf</span><em>est</em> nécessaire pour utiliser DHCP, mais si vous êtes très sensible à la sécurité, vous ne devriez probablement pas ajouter <span class=filename>bpf</span> à votre noyau parce que vous projetez d’utiliser DHCP dans le futur.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Il vous reste ensuite à éditer le fichier <span class=filename>dhcpd.conf</span> d’exemple qui a été installé par le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a>. Par défaut, cela sera <span class=filename>/usr/local/etc/dhcpd.conf.sample</span>, et vous devriez le copier vers <span class=filename>/usr/local/etc/dhcpd.conf</span> avant de commencer vos modifications.</p></div></div><div class=sect4><h5 id=_configuration_du_serveur_dhcp>31.5.7.3. Configuration du serveur DHCP<a class=anchor href=#_configuration_du_serveur_dhcp></a></h5><div class=paragraph><p><span class=filename>dhcpd.conf</span> est composé de déclarations concernant les masques de sous-réseaux et les machines, il est peut-être plus facile à expliquer à l’aide d’un exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>option domain-name &#34;example.com&#34;; <i class=conum data-value=1></i><b>(1)</b>
option domain-name-servers 192.168.4.100; <i class=conum data-value=2></i><b>(2)</b>
option subnet-mask 255.255.255.0; <i class=conum data-value=3></i><b>(3)</b>

default-lease-time 3600; <i class=conum data-value=4></i><b>(4)</b>
max-lease-time 86400; <i class=conum data-value=5></i><b>(5)</b>
ddns-update-style none; <i class=conum data-value=6></i><b>(6)</b>

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254; <i class=conum data-value=7></i><b>(7)</b>
  option routers 192.168.4.1; <i class=conum data-value=8></i><b>(8)</b>
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07; <i class=conum data-value=9></i><b>(9)</b>
  fixed-address mailhost.example.com; <i class=conum data-value=10></i><b>(10)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Cette option spécifie le domaine qui sera donné aux clients comme domaine par défaut. Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> pour plus d’information sur sa signification.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Cette option donne une liste, séparée par des virgules, de serveurs DNS que le client devrait utiliser.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Le masque de sous-réseau qui sera fourni aux clients.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Un client peut demander un bail d’une durée bien précise. Sinon par défaut le serveur alloue un bail avec cette durée avant expiration (en secondes).</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>C’est la durée maximale d’allocation autorisée par le serveur. Si un client demande un bail plus long, le bail sera accordé mais il ne sera valide que durant <code>max-lease-time</code> secondes.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Cette option indique si le serveur DHCP doit tenter de mettre à jour le DNS quand un bail est accepté ou révoqué. Dans l’implémentation ISC, cette option est <em>obligatoire</em>.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Ceci indique quelles adresses IP devraient être utilisées dans l’ensemble des adresses réservées aux clients. Les adresses comprises dans l’intervalle spécifiée sont allouées aux clients.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Définit la passerelle par défaut fournie aux clients.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>L’adresse matérielle MAC d’une machine (de manière à ce que le serveur DHCP puisse reconnaître une machine quand elle envoie une requête).</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>Indique que la machine devrait se voir attribuer toujours la même adresse IP. Notez que l’utilisation d’un nom de machine ici est correct, puisque le serveur DHCP effectuera une résolution de nom sur le nom de la machine avant de renvoyer l’information sur le bail.</td></tr></tbody></table></div><div class=paragraph><p>Une fois l’écriture de votre fichier <span class=filename>dhcpd.conf</span> terminée, vous devez activer le serveur DHCP dans le fichier <span class=filename>/etc/rc.conf</span>, en ajoutant:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;
dhcpd_ifaces=&#34;dc0&#34;</pre></div></div><div class=paragraph><p>Remplacez le nom de l’interface <code>dc0</code> avec celui de l’interface (ou des interfaces, séparées par un espace) sur laquelle votre serveur DHCP attendra les requêtes des clients DHCP.</p></div><div class=paragraph><p>Ensuite, vous pouvez lancer le serveur en tapant la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/isc-dhcpd.sh start</span></code></pre></div></div><div class=paragraph><p>Si vous devez, dans le futur, effectuer des changements dans la configuration de votre serveur, il est important de savoir que l’envoi d’un signal <code>SIGHUP</code> à dhcpd ne provoque <em>pas</em> le rechargement de la configuration, contrairement à la plupart des "daemons". Vous devrez envoyer un signal <code>SIGTERM</code> pour arrêter le processus, puis le relancer en utilisant la commande ci-dessus.</p></div></div><div class=sect4><h5 id=_fichiers_2>31.5.7.4. Fichiers<a class=anchor href=#_fichiers_2></a></h5><div class=ulist><ul><li><p><span class=filename>/usr/local/sbin/dhcpd</span></p><div class=paragraph><p>dhcpd est lié statiquement et réside dans le répertoire <span class=filename>/usr/local/sbin</span>. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd&amp;sektion=8&amp;format=html">dhcpd(8)</a> installée avec le logiciel porté donne beaucoup plus d’informations au sujet de dhcpd.</p></div></li><li><p><span class=filename>/usr/local/etc/dhcpd.conf</span></p><div class=paragraph><p>dhcpd nécessite un fichier de configuration, <span class=filename>/usr/local/etc/dhcpd.conf</span> avant de pouvoir commencer à offrir ses services aux client. Ce fichier doit contenir toutes les informations à fournir aux clients qui seront traités, en plus des informations concernant le fonctionnement du serveur. Ce fichier de configuration est décrit par la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a> installée par le logiciel porté.</p></div></li><li><p><span class=filename>/var/db/dhcpd.leases</span></p><div class=paragraph><p>Le serveur DHCP conserve une base de données des baux qu’il a délivré, qui est écrite comme un fichier journal. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.leases&amp;sektion=5&amp;format=html">dhcpd.leases(5)</a> installée par le logiciel porté en donne une description légèrement plus longue.</p></div></li><li><p><span class=filename>/usr/local/sbin/dhcrelay</span></p><div class=paragraph><p>dhcrelay est utilisé dans les environnements avancés où un serveur DHCP fait suivre la requête d’un client vers un autre serveur DHCP sur un réseau séparé. Si vous avez besoin de cette fonctionnalité, installez alors le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a>. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcrelay&amp;sektion=8&amp;format=html">dhcrelay(8)</a> fournie avec le logiciel porté contient plus de détails.</p></div></li></ul></div></div></div></div><div class=sect2><h3 id=network-dns>31.6. Serveurs de noms (DNS)<a class=anchor href=#network-dns></a></h3><div class=sect3><h4 id=_généralités>31.6.1. Généralités<a class=anchor href=#_généralités></a></h4><div class=paragraph><p>FreeBSD utilise, par défaut, BIND (Berkeley Internet Name Domain), qui est l’implémentation la plus courante du protocole DNS. Le DNS est le protocole qui effectue la correspondance entre noms et adresses IP, et inversement. Par exemple une requête pour <code>www.FreeBSD.org</code> aura pour réponse l’adresse IP du serveur Web du projet FreeBSD, et une requête pour <code>ftp.FreeBSD.org</code> renverra l’adresse IP de la machine FTP correspondante. De même, l’opposé est possible. Une requête pour une adresse IP retourne son nom de machine. Il n’est pas nécessaire de faire tourner un serveur DNS pour effectuer des requêtes DNS sur un système.</p></div><div class=paragraph><p>FreeBSD est actuellement fourni par défaut avec le serveur DNSBIND9. Notre installation est dotée de fonctionnalités étendues au niveau de la sécurité, d’une nouvelle organisation du système de fichiers et d’une configuration en environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> automatisée.</p></div><div class=paragraph><p>Le DNS est coordonné sur l’Internet à travers un système complexe de serveurs de noms racines faisant autorité, de domaines de premier niveau ("Top Level Domain", TLD), et d’autres serveurs de noms de plus petites tailles qui hébergent, directement ou font office de "cache", l’information pour des domaines individuels.</p></div><div class=paragraph><p>Actuellement, BIND est maintenu par l’Internet Software Consortium <a href=http://www.isc.org/>http://www.isc.org/</a>.</p></div></div><div class=sect3><h4 id=_terminologie>31.6.2. Terminologie<a class=anchor href=#_terminologie></a></h4><div class=paragraph><p>Pour comprendre ce document, certains termes relatifs au DNS doivent être maîtrisés.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Terme</th><th class="tableblock halign-left valign-top">Definition</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>"Forward" DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Correspondance noms de machine vers adresses IP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Origine</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fait référence au domaine couvert par un fichier de zone particulier.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>named, BIND, serveur de noms</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Noms courants pour le serveur de noms BIND de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Resolveur</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Un processus système par l’intermédiaire duquel une machine contacte un serveur de noms pour obtenir des informations sur une zone.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DNS inverse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>C’est l’inverse du DNS "classique" ("Forward" DNS). C’est la correspondance adresses IP vers noms de machine.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Zone racine</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Début de la hiérarchie de la zone Internet. Toutes les zones sont rattachées à la zone racine, de la même manière qu’un système de fichier est rattaché au répertoire racine.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Zone</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Un domaine individuel, un sous-domaine, ou une partie des noms administrés par un même serveur faisant autorité.</p></td></tr></tbody></table><div class=paragraph><p>Exemples de zones:</p></div><div class=ulist><ul><li><p><code>.</code> est la zone racine</p></li><li><p><code>org.</code> est un domaine de premier niveau (TLD) sous la zone racine</p></li><li><p><code>example.org.</code> est une zone sous le TLD <code>org.</code></p></li><li><p><code>1.168.192.in-addr.arpa</code> est une zone faisant référence à toutes les adresses IP qui appartiennent l’espace d’adresse <code>192.168.1.*</code>.</p></li></ul></div><div class=paragraph><p>Comme on peut le remarquer, la partie la plus significative d’un nom de machine est à sa gauche. Par exemple, <code>example.org.</code> est plus spécifique que <code>org.</code>, comme <code>org.</code> est à son tour plus spécifique que la zone racine. La constitution de chaque partie d’un nom de machine est proche de celle d’un système de fichiers: le répertoire <span class=filename>/dev</span> se trouve sous la racine, et ainsi de suite.</p></div></div><div class=sect3><h4 id=_les_raisons_de_faire_tourner_un_serveur_de_noms>31.6.3. Les raisons de faire tourner un serveur de noms<a class=anchor href=#_les_raisons_de_faire_tourner_un_serveur_de_noms></a></h4><div class=paragraph><p>Les serveurs de noms se présentent généralement sous deux formes: un serveur de noms faisant autorité, et un serveur de noms cache.</p></div><div class=paragraph><p>Un serveur de noms faisant autorité est nécessaire quand:</p></div><div class=ulist><ul><li><p>on désire fournir des informations DNS au reste du monde, être le serveur faisant autorité lors des réponses aux requêtes.</p></li><li><p>un domaine, comme par exemple <code>example.org</code>, est enregistré et des adresses IP doivent être assignées à des noms de machine appartenant à ce domaine.</p></li><li><p>un bloc d’adresses IP nécessite des entrées DNS inverses (IP vers nom de machine).</p></li><li><p>un second serveur de noms ou de secours, appelé esclave, qui répondra aux requêtes.</p></li></ul></div><div class=paragraph><p>Un serveur de noms cache est nécessaire quand:</p></div><div class=ulist><ul><li><p>un serveur de noms local peut faire office de cache et répondre plus rapidement que l’interrogation d’un serveur de noms extérieur.</p></li></ul></div><div class=paragraph><p>Quand on émet des requêtes pour <code>www.FreeBSD.org</code>, le résolveur interroge généralement le serveur de noms du fournisseur d’accès, et récupère la réponse. Avec un serveur DNS cache local, la requête doit être effectuée qu’une seule fois vers le monde extérieur par le serveur DNS cache. Chaque interrogation suivante n’aura pas à être transmise en dehors du réseau local, puisque l’information est désormais disponible localement dans le cache.</p></div></div><div class=sect3><h4 id=_comment_cela_fonctionne_t_il_3>31.6.4. Comment cela fonctionne-t-il?<a class=anchor href=#_comment_cela_fonctionne_t_il_3></a></h4><div class=paragraph><p>Sous FreeBSD le "daemon" BIND est appelé named pour des raisons évidentes.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Fichier</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>le "daemon" BIND</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rndc&amp;sektion=8&amp;format=html">rndc(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>le programme de contrôle du serveur de noms</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>répertoire où se trouvent les informations sur les zones de BIND</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb/named.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>le fichier de configuration du "daemon"</p></td></tr></tbody></table><div class=paragraph><p>En fonction de la manière dont est configurée sur le serveur une zone donnée, les fichiers relatifs à cette zone pourront être trouvés dans les sous-répertoires <span class=filename>master</span>, <span class=filename>slave</span>, ou <span class=filename>dynamic</span> du répertoire <span class=filename>/etc/namedb</span>. Ces fichiers contiennent les informations DNS qui seront données par le serveur de noms en réponse aux requêtes.</p></div></div><div class=sect3><h4 id=_lancer_bind>31.6.5. Lancer BIND<a class=anchor href=#_lancer_bind></a></h4><div class=paragraph><p>Puisque BIND est installé par défaut, sa configuration est relativement simple.</p></div><div class=paragraph><p>La configuration par défaut de named est un serveur de noms résolveur basique, tournant dans un environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a>. Pour lancer le serveur avec cette configuration, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/named forcestart</span></code></pre></div></div><div class=paragraph><p>Pour s’assurer que le "daemon" named est lancé à chaque démarrage, ajoutez la ligne suivante dans <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Il existe, bien évidemment, de nombreuses options de configuration pour <span class=filename>/etc/namedb/named.conf</span> qui dépassent le cadre de ce document. Si vous êtes intéressé par les options de démarrage de named sous FreeBSD, jetez un oeil aux paramètres <code>named_*</code> dans <span class=filename>/etc/defaults/rc.conf</span> et consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. La section <a href=./#configtuning-rcd>Utilisation du système rc(8) sous FreeBSD</a> constitue également une bonne lecture.</p></div></div><div class=sect3><h4 id=_fichiers_de_configuration_2>31.6.6. Fichiers de configuration<a class=anchor href=#_fichiers_de_configuration_2></a></h4><div class=paragraph><p>Les fichiers de configuration pour named se trouvent dans le répertoire <span class=filename>/etc/namedb</span> et devront être adaptés avant toute utilisation, à moins que l’on ait besoin que d’un simple résolveur. C’est dans ce répertoire où la majeure partie de la configuration se fera.</p></div><div class=sect4><h5 id=_utilisation_de_make_localhost>31.6.6.1. Utilisation de <code>make-localhost</code><a class=anchor href=#_utilisation_de_make_localhost></a></h5><div class=paragraph><p>Pour configurer une zone maître, il faut se rendre dans le répertoire <span class=filename>/etc/namedb/</span> et exécuter la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh make-localhost</span></code></pre></div></div><div class=paragraph><p>Si tout s’est bien passé, un nouveau fichier devrait apparaître dans le sous-répertoire <span class=filename>master</span>. Les noms de fichiers devraient être <span class=filename>localhost.rev</span> pour le nom de domaine local et <span class=filename>localhost-v6.rev</span> pour les configurations IPv6. Tout comme le fichier de configuration par défaut, les informations nécessaires seront présentes dans le fichier <span class=filename>named.conf</span>.</p></div></div><div class=sect4><h5 id=_etcnamedbnamed_conf>31.6.6.2. <span class=filename>/etc/namedb/named.conf</span><a class=anchor href=#_etcnamedbnamed_conf></a></h5><div class="literalblock programlisting"><div class=content><pre>// $FreeBSD$
//
// Reportez-vous aux pages de manuel named.conf(5) et named(8), et à
// la documentation se trouvant dans /usr/shared/doc/bind9 pour plus de
// détails.
//
// Si vous devez configurer un serveur primaire, assurez-vous d&#39;avoir
// compris les détails épineux du fonctionnement du DNS.  Même avec de
// simples erreurs, vous pouvez rompre la connexion entre les parties
// affectées, ou causer un important et inutile trafic Internet.

options {
        directory &#34;/etc/namedb&#34;;
	pid-file	&#34;/var/run/named/pid&#34;;
	dump-file	&#34;/var/dump/named_dump.db&#34;;
	statistics-file	&#34;/var/stats/named.stats&#34;;

// Si named est utilisé uniquement en tant que résolveur local, ceci
// est un bon réglage par défaut.  Pour un named qui doit être
// accessible à l&#39;ensemble du réseau, commentez cette option, précisez
// l&#39;adresse IP correcte, ou supprimez cette option.
	listen-on	{ 127.0.0.1; };

// Si l&#39;IPv6 est activé sur le système, décommentez cette option pour
// une utilisation en résolveur local.  Pour donner l&#39;accès au réseau,
// précisez une adresse IPv6, ou le mot-clé &#34;any&#34;.
//	listen-on-v6	{ ::1; };

// En plus de la clause &#34;forwarders&#34;, vous pouvez forcer votre serveur
// de noms à ne jamais être à l&#39;origine de
// requêtes, mais plutôt faire suivre les demandes en
// activant la ligne suivante:
//
//      forward only;

// Si vous avez accès à un serveur de noms au niveau de
// votre fournisseur d&#39;accès, ajoutez ici son adresse IP, et
// activez la ligne ci-dessous.  Cela vous permettra de
// bénéficier de son cache, réduisant ainsi le
// trafic Internet.
/*
        forwarders {
                127.0.0.1;
        };
*/</pre></div></div><div class=paragraph><p>Comme les commentaires le précisent, pour bénéficier d’un cache en amont de votre connexion, le paramètre <code>forwarders</code> peut être activé. Dans des circonstances normales, un serveur de noms interrogera de façon récursive certains serveurs de noms jusqu’à obtenir la réponse à sa requête. Avec ce paramètre activé, votre serveur interrogera le serveur de noms en amont (ou le serveur de noms fourni) en premier, en bénéficiant alors de son cache. Si le serveur en question gère beaucoup de trafic, et est un serveur rapide, activer cette option peut en valoir la peine.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><code>127.0.0.1</code> ne fonctionnera <em>pas</em> ici. Remplacez cette adresse IP par un serveur de noms en amont de votre connexion.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>        /*
         * S&#39;il y a un coupe-feu entre vous et les serveurs de noms
         * avec lesquels vous voulez communiquer, vous aurez
         * peut-être besoin de décommenter la directive
         * query-source ci-dessous.  Les versions
         * précédentes de BIND lançaient des
         * requêtes à partir du port 53, mais depuis la
         * version 8, BIND utilise
         * par défaut un port pseudo-aléatoire quelconque non
         * réservé.
         */
        // query-source address * port 53;
};

// Si vous activez un serveur de noms local, n&#39;oubliez pas d&#39;entrer
// 127.0.0.1 dans votre fichier /etc/resolv.conf de sorte que ce
// serveur soit interrogé le premier.  Assurez-vous
// également de l&#39;activer dans /etc/rc.conf.

zone &#34;.&#34; {
        type hint;
        file &#34;named.root&#34;;
};

zone &#34;0.0.127.IN-ADDR.ARPA&#34; {
        type master;
	file &#34;master/localhost.rev&#34;;
};

// RFC 3152
zone &#34;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA&#34; {
	type master;
	file &#34;master/localhost-v6.rev&#34;;
};

// NB: N&#39;utilisez pas les adresses IP ci-dessous, elles sont factices,
// et ne servent que pour des besoins de
// démonstration/documentation!
//
// Exemple d&#39;entrées de configuration de zone esclave.
// Il peut être pratique de devenir serveur esclave pour la
// zone à laquelle appartient votre domaine.  Demandez à
// votre administrateur réseau l&#39;adresse IP du serveur primaire
// responsable de la zone.
//
// N&#39;oubliez jamais d&#39;inclure la résolution de la zone inverse
// (IN-ADDR.ARPA)!
// (Ce sont les premiers octets de l&#39;adresse IP, en ordre inverse,
// auxquels ont a ajouté &#34;.IN-ADDR.ARPA&#34;.)
//
// Avant de commencer à configurer une zone primaire, il faut
// être sûr que vous avez parfaitement compris comment le
// DNS et BIND fonctionnent.  Il apparaît parfois des pièges
// peu évidents à saisir.  En comparaison, configurer une
// zone esclave est plus simple.
//
// NB: N&#39;activez pas aveuglément les exemples ci-dessous. :-)
// Utilisez des noms et des adresses réelles.

/* Un exemple de zone maître
zone &#34;example.net&#34; {
	type master;
	file &#34;master/example.net&#34;;
};
*/

/* Un exemple de zone dynamique
key &#34;exampleorgkey&#34; {
	algorithm hmac-md5;
	secret &#34;sf87HJqjkqh8ac87a02lla==&#34;;
};
zone &#34;example.org&#34; {
	type master;
	allow-update {
		key &#34;exampleorgkey&#34;;
	};
	file &#34;dynamic/example.org&#34;;
};
*/

/* Exemple de zones esclaves directes et inverses
zone &#34;example.com&#34; {
	type slave;
	file &#34;slave/example.com&#34;;
	masters {
		192.168.1.1;
	};
};
zone &#34;1.168.192.in-addr.arpa&#34; {
	type slave;
	file &#34;slave/1.168.192.in-addr.arpa&#34;;
	masters {
		192.168.1.1;
	};
};
*/</pre></div></div><div class=paragraph><p>Dans <span class=filename>named.conf</span>, ce sont des exemples d’entrées d’un serveur esclave.</p></div><div class=paragraph><p>Pour chaque nouvelle zone gérée, une nouvelle entrée de zone doit être ajoutée au fichier <span class=filename>named.conf</span>.</p></div><div class=paragraph><p>Par exemple, l’entrée de zone la plus simple possible pour <code>example.org</code> serait:</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type master;
	file &#34;master/example.org&#34;;
};</pre></div></div><div class=paragraph><p>Ce sera un serveur maître pour la zone, comme indiqué par l’option <code>type</code>, concervant ses informations de zone dans le fichier <span class=filename>/etc/namedb/master/example.org</span> comme précisé par l’option <code>file</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type slave;
	file &#34;slave/example.org&#34;;
};</pre></div></div><div class=paragraph><p>Dans le cas d’un esclave, les informations concernant la zone seront transférées à partir du serveur maître pour la zone en question, et sauvegardées dans le fichier indiqué. Si ou lorsque le serveur maître tombe ou est inaccessible, le serveur esclave disposera des informations de la zone transférée et sera capable de les diffuser.</p></div></div><div class=sect4><h5 id=_fichiers_de_zone>31.6.6.3. Fichiers de zone<a class=anchor href=#_fichiers_de_zone></a></h5><div class=paragraph><p>Un exemple de fichier de zone maître pour <code>example.org</code> (défini dans <span class=filename>/etc/namedb/master/example.org</span>) suit:</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600        ; 1 hour
example.org.    IN      SOA      ns1.example.org. admin.example.org. (
                                2006051501      ; Serial
                                10800           ; Refresh
                                3600            ; Retry
                                604800          ; Expire
                                86400           ; Minimum TTL
                        )

; Serveurs DNS
                IN      NS      ns1.example.org.
                IN      NS      ns2.example.org.

; Enregistrements MX
                IN      MX 10   mx.example.org.
                IN      MX 20   mail.example.org.

                IN      A       192.168.1.1

; Noms de machine
localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5

; Alias
www             IN      CNAME   @</pre></div></div><div class=paragraph><p>Notez que chaque nom de machine se terminant par un "." est un nom de machine complet, alors que tout ce qui se termine pas par un "." est référencé par rapport à une origine. Par exemple, <code>www</code> sera traduit en <code>www.origine</code>. Dans notre fichier de zone fictif, notre origine est <code>example.org.</code>, donc <code>www</code> sera traduit en <code>www.example.org.</code></p></div><div class=paragraph><p>Le format d’un fichier de zone est le suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>nom-enregistrement      IN type-enregistrement   valeur</pre></div></div><div class=paragraph><p>Les enregistrements DNS les plus couramment utilisés:</p></div><div class=dlist><dl><dt class=hdlist1>SOA</dt><dd><p>début des données de zone</p></dd><dt class=hdlist1>NS</dt><dd><p>serveur de noms faisant autorité</p></dd><dt class=hdlist1>A</dt><dd><p>adresse d’une machine</p></dd><dt class=hdlist1>CNAME</dt><dd><p>alias d’un nom de machine</p></dd><dt class=hdlist1>MX</dt><dd><p>serveur de messagerie recevant le courrier pour le domaine</p></dd><dt class=hdlist1>PTR</dt><dd><p>un pointeur sur un nom de domaine (utilisé dans le DNS inverse)</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>example.org. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>example.org.</code></dt><dd><p>le nom de domaine, également l’origine pour ce fichier de zone.</p></dd><dt class=hdlist1><code>ns1.example.org.</code></dt><dd><p>le serveur de noms primaire/faisant autorité pour cette zone.</p></dd><dt class=hdlist1><code>admin.example.org.</code></dt><dd><p>la personne responsable pour cette zone avec le caractère "@" remplacé. (<a href=mailto:admin@example.org>admin@example.org</a> devient <code>admin.example.org</code>)</p></dd><dt class=hdlist1><code>2006051501</code></dt><dd><p>le numéro de série de ce fichier. Celui-ci doit être incrémenté à chaque modification du fichier de zone. De nos jours, de nombreux administrateurs préfèrent un format du type <code>aaaammjjrr</code> pour le numéro de série. <code>2006051501</code> signifierait dernière modification le 15/05/2006, le <code>01</code> indiquant que c’est la seconde fois que ce fichier a été révisé ce jour. Le numéro de série est important puisqu’il indique aux serveurs de noms esclaves pour la zone une modification de celle-ci.</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>       IN NS           ns1.example.org.</pre></div></div><div class=paragraph><p>C’est une entrée de type NS. Tous les serveurs de noms qui doivent faire autorité pour la zone devront inclure une de ces entrées.</p></div><div class="literalblock programlisting"><div class=content><pre>localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5</pre></div></div><div class=paragraph><p>Un enregistrement de type A indique des noms de machine. Comme présenté ci-dessus <code>ns1.example.org</code> sera résolu en <code>192.168.1.2</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>                IN      A       192.168.1.1</pre></div></div><div class=paragraph><p>Cette ligne assigne l’adresse IP <code>192.168.1.1</code> à l’origine, dans cet exemple <code>example.org</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>www             IN CNAME        @</pre></div></div><div class=paragraph><p>L’enregistrement de type CNAME est généralement utilisé pour créer des alias à une machine. Dans l’exemple, <code>www</code> est un alias de la machine connue sous le nom <code>localhost.example.org</code> (<code>127.0.0.1</code>). Les enregistrements CNAME peuvent être utilisés pour fournir des alias à des noms de machines, ou permettre la rotation ("round robin") d’un nom de machine entre plusieurs machines.</p></div><div class="literalblock programlisting"><div class=content><pre>               IN MX   10      mail.example.org.</pre></div></div><div class=paragraph><p>L’enregistrement MX indique quels serveurs de messagerie sont responsables de la gestion du courrier entrant pour la zone. <code>mail.example.org</code> est le nom de machine du serveur de messagerie, et 10 étant la priorité du serveur de messagerie.</p></div><div class=paragraph><p>On peut avoir plusieurs serveurs de messagerie, avec des priorités de 10, 20, etc. Un serveur de messagerie tentant de transmettre du courrier au domaine <code>example.org</code> essaiera en premier le MX avec la plus haute priorité (l’enregistrement avec le numéro de priorité le plus bas), puis celui venant en second, etc, jusqu’à ce que le courrier puisse être correctement délivré.</p></div><div class=paragraph><p>Pour les fichiers de zone in-addr.arpa (DNS inverse), le même format est utilisé, à l’exception du fait que des entrées PTR seront utilisées en place de A ou CNAME.</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600

1.168.192.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

        IN      NS      ns1.example.org.
        IN      NS      ns2.example.org.

1       IN      PTR     example.org.
2       IN      PTR     ns1.example.org.
3       IN      PTR     ns2.example.org.
4       IN      PTR     mx.example.org.
5       IN      PTR     mail.example.org.</pre></div></div><div class=paragraph><p>Ce fichier donne la correspondance entre adresses IP et noms de machines de notre domaine fictif.</p></div></div></div><div class=sect3><h4 id=_serveur_de_noms_cache>31.6.7. Serveur de noms cache<a class=anchor href=#_serveur_de_noms_cache></a></h4><div class=paragraph><p>Un serveur de noms cache est un serveur de noms qui ne fait autorité pour aucune zone. Il émet simplement des requêtes, et se souvient du résultat pour une utilisation ultérieure. Pour mettre en place un tel serveur, configurez le serveur de noms comme à l’accoutumé, en prenant bien soin de n’inclure aucune zone.</p></div></div><div class=sect3><h4 id=_sécurité>31.6.8. Sécurité<a class=anchor href=#_sécurité></a></h4><div class=paragraph><p>Bien que BIND soit l’implémentation la plus courante du DNS, le problème de la sécurité subsiste toujours. De possibles problèmes de sécurité exploitables sont parfois découvert.</p></div><div class=paragraph><p>Bien que FreeBSD enferme automatiquement named dans un environnement <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a>, il existe plusieurs autres mécanismes de sécurité qui pourraient aider à se prémunir contre de possibles attaques DNS.</p></div><div class=paragraph><p>C’est une bonne idée de lire les avis de sécurité du <a href=http://www.cert.org/>CERT</a> et de s’inscrire à la <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>liste de diffusion des avis de sécurité pour FreeBSD</a> pour se maintenir au courant des problèmes de sécurité actuels de l’Internet et de FreeBSD.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Si un problème surgit, conserver les sources à jour et disposer d’une version compilée de named récente ne seront pas de trop.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_lectures_supplémentaires_3>31.6.9. Lectures supplémentaires<a class=anchor href=#_lectures_supplémentaires_3></a></h4><div class=paragraph><p>Les pages de manuel de BIND/named: <a href="https://man.freebsd.org/cgi/man.cgi?query=rndc&amp;sektion=8&amp;format=html">rndc(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named.conf&amp;sektion=8&amp;format=html">named.conf(8)</a>.</p></div><div class=ulist><ul><li><p><a href=http://www.isc.org/products/BIND/>Page officielle ISC concernant BIND</a></p></li><li><p><a href=http://www.isc.org/sw/guild/bf/>Forum officiel ISC concernant BIND</a></p></li><li><p><a href="http://www.nominum.com/getOpenSourceResource.php?id=6">FAQ BIND</a></p></li><li><p><a href=http://www.oreilly.com/catalog/dns5/>DNS et BIND 5ème Edition de chez O’Reilly</a></p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1034.txt>RFC1034 - Domain Names - Concepts and Facilities</a></p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1035.txt>RFC1035 - Domain Names - Implementation and Specification</a></p></li></ul></div></div></div><div class=sect2><h3 id=network-apache>31.7. Serveur HTTP Apache<a class=anchor href=#network-apache></a></h3><div class=sect3><h4 id=_généralités_2>31.7.1. Généralités<a class=anchor href=#_généralités_2></a></h4><div class=paragraph><p>FreeBSD est utilisé pour faire tourner certains des sites les plus chargés au monde. La majorité des serveurs web sur l’Internet utilisent le serveur HTTP Apache. Les versions pré-compilées d’Apache devraient se trouver sur le support d’installation de FreeBSD que vous avez utilisé. Si vous n’avez pas installé Apache à l’installation de FreeBSD, alors vous pouvez installer le serveur à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13/>www/apache13</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache20/>www/apache20</a>.</p></div><div class=paragraph><p>Une fois qu’Apache a été installé avec succès, il doit être configuré.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cette section traite de la version 1.3.X du serveur HTTP Apache étant donné que c’est la version la plus largement utilisée sous FreeBSD. Apache 2.X introduit de nombreuses nouvelles technologies mais elles ne sont pas abordées ici. Pour plus d’informations concernant Apache 2.X veuillez consulter <a href=http://httpd.apache.org/>http://httpd.apache.org/</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_configuration_5>31.7.2. Configuration<a class=anchor href=#_configuration_5></a></h4><div class=paragraph><p>Le fichier principal de configuration du serveur HTTP Apache est, sous FreeBSD, le fichier <span class=filename>/usr/local/etc/apache/httpd.conf</span>. Ce fichier est un fichier texte de configuration UNIX® typique avec des lignes de commentaires débutant par un caractère <code>#</code>. Une description complète de toutes les options de configuration possibles dépasse le cadre de cet ouvrage, aussi seules les directives les plus fréquemment modifiées seront décrites ici.</p></div><div class=dlist><dl><dt class=hdlist1><code>ServerRoot "/usr/local"</code></dt><dd><p>Indique le répertoire d’installation par défaut pour l’arborescence Apache. Les binaires sont stockés dans les sous-répertoires <span class=filename>bin</span> et <span class=filename>sbin</span> de la racine du serveur, et les fichiers de configuration dans <span class=filename>etc/apache</span>.</p></dd><dt class=hdlist1><code>ServerAdmin you@your.address</code></dt><dd><p>L’adresse électronique à laquelle tous les problèmes concernant le serveur doivent être rapportés. Cette adresse apparaît sur certaines pages générées par le serveur, comme des pages d’erreur.</p></dd><dt class=hdlist1><code>ServerName www.example.com</code></dt><dd><p>La directive <code>ServerName</code> vous permet de fixer un nom de machine qui est renvoyé aux clients de votre serveur si le nom est différent de celui de la machine (i.e, utilisez <code>www</code> à la place du véritable nom de la machine).</p></dd><dt class=hdlist1><code>DocumentRoot "/usr/local/www/data"</code></dt><dd><p><code>DocumentRoot</code> est le répertoire où se trouvent les documents que votre serveur diffusera. Par défaut, toutes les requêtes sont prises en compte par rapport à ce répertoire, mais des liens symboliques et des alias peuvent être utilisés pour pointer vers d’autres emplacements.</p></dd></dl></div><div class=paragraph><p>C’est toujours une bonne idée de faire des copies de sauvegarde de votre fichier de configuration d’Apache avant de faire des modifications. Une fois que vous êtes satisfait avec votre configuration, vous êtes prêt à lancer Apache.</p></div></div><div class=sect3><h4 id=_exécuter_apache>31.7.3. Exécuter Apache<a class=anchor href=#_exécuter_apache></a></h4><div class=paragraph><p>Apache n’est pas lancé à partir du "super-serveur" inetd comme pour beaucoup d’autres serveurs réseau. Il est configuré pour tourner de façon autonome pour de meilleures performances à la réception des requêtes HTTP des navigateurs web. Une procédure est fournie pour rendre le démarrage, l’arrêt, et le redémarrage du serveur aussi simple que possible. Pour démarrer Apache pour la première fois, exécutez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl start</span></code></pre></div></div><div class=paragraph><p>Vous pouvez arrêter le serveur à tout moment en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl stop</span></code></pre></div></div><div class=paragraph><p>Après avoir effectué des modifications dans le fichier de configuration, vous devez redémarrer le serveur:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl restart</span></code></pre></div></div><div class=paragraph><p>Pour redémarrer Apache sans faire échouer les connexions en cours, exécutez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/apachectl graceful</span></code></pre></div></div><div class=paragraph><p>Des informations supplémentaires sont disponibles dans la page de manuel d’<a href="https://man.freebsd.org/cgi/man.cgi?query=apachectl&amp;sektion=8&amp;format=html">apachectl(8)</a>.</p></div><div class=paragraph><p>Pour lancer Apache au démarrage du système, ajoutez la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>apache_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Si vous désirez passer des options en ligne de commande supplémentaires au programme <code>httpd</code> d’Apache lancé au démarrage du système, vous pouvez les spécifier à l’aide d’une ligne dans <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>apache_flags=&#34;&#34;</pre></div></div><div class=paragraph><p>Maintenant que le serveur web tourne, vous pouvez voir votre site web en pointant votre navigateur sur <code><a href=http://localhost/ class=bare>http://localhost/</a></code>. La page web affichée par défaut est <span class=filename>/usr/local/www/data/index.html</span>.</p></div></div><div class=sect3><h4 id=_serveurs_virtuels>31.7.4. Serveurs virtuels<a class=anchor href=#_serveurs_virtuels></a></h4><div class=paragraph><p>Apache supporte deux types différents de serveurs virtuels. Le premier type est celui des serveurs virtuels basés sur les noms. Ce type de serveurs virtuels utilise les entêtes HTTP/1.1 pour déterminer le nom de la machine. Cela autorise le partage de la même adresse IP entre plusieurs domaines différents.</p></div><div class=paragraph><p>Pour configurer Apache à l’utilisation de serveurs virtuels basés sur les noms, ajoutez une entrée comme la suivante à votre fichier <span class=filename>httpd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>NameVirtualHost *</pre></div></div><div class=paragraph><p>Si votre serveur web est appelé <code>www.domain.tld</code> et que vous voulez mettre en place un domain virtuel pour <code>www.someotherdomain.tld</code> alors vous ajouterez les entrées suivantes au fichier <span class=filename>httpd.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&lt;VirtualHost <span class=k>*</span><span class=o>&gt;</span>
ServerName www.domain.tld
DocumentRoot /www/domain.tld
&lt;/VirtualHost&gt;

&lt;VirtualHost <span class=k>*</span><span class=o>&gt;</span>
ServerName www.someotherdomain.tld
DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</code></pre></div></div><div class=paragraph><p>Remplacez les addresses avec celles que vous désirez utiliser et le chemin d’accès des documents avec celui que vous utilisez.</p></div><div class=paragraph><p>Pour plus d’informations sur la mise en place de serveurs virtuels, veuillez consulter la documentation officielle d’Apache à l’adresse <a href=http://httpd.apache.org/docs/vhosts/>http://httpd.apache.org/docs/vhosts/</a>.</p></div></div><div class=sect3><h4 id=_modules_apache>31.7.5. Modules Apache<a class=anchor href=#_modules_apache></a></h4><div class=paragraph><p>Il existe de nombreux modules Apache disponibles en vue d’ajouter des fonctionnalités au serveur de base. Le catalogue des logiciels portés offre une méthode simple d’installation d’Apache avec certains des modules les plus populaires.</p></div><div class=sect4><h5 id=_mod_ssl>31.7.5.1. mod_ssl<a class=anchor href=#_mod_ssl></a></h5><div class=paragraph><p>Le module mod_ssl utilise la bibliothèque OpenSSL pour offrir un chiffrement solide à l’aide des protocoles "Secure Sockets Layer" (SSL v2/v3) et "Transport Layer Security". Ce module fourni tout ce qui est nécessaire à la demande de certificats signés auprès d’une autorité de certification connue de façon à pouvoir faire tourner un serveur web sécurisé sous FreeBSD.</p></div><div class=paragraph><p>Si vous n’avez pas déjà installé Apache, alors une version d’Apache 1.3.X comprenant mod_ssl peut être installée à l’aide du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-modssl/>www/apache13-modssl</a>. Le support SSL est également disponible pour Apache 2.X avec le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache20/>www/apache20</a>, où il est activé par défaut.</p></div></div><div class=sect4><h5 id=_sites_web_dynamiques_avec_perl_php>31.7.5.2. Sites Web dynamiques avec Perl PHP<a class=anchor href=#_sites_web_dynamiques_avec_perl_php></a></h5><div class=paragraph><p>Ces dernières années, de plus en plus d’entreprises se sont tournées vers l’Internet pour augmenter leurs revenus et renforcer leur exposition. Cela a eu pour conséquence d’accroître le besoin de contenus Web interactifs. Quand certaines entreprises, comme Microsoft®, ont introduit dans leurs produits propriétaires des solutions à ces besoins, la communauté des logiciels libres a également répondu à l’appel. Deux options pour obtenir du contenu Web dynamique sont mod_perl et mod_php.</p></div><div class=sect5><h6 id=_mod_perl>31.7.5.2.1. mod_perl<a class=anchor href=#_mod_perl></a></h6><div class=paragraph><p>Le projet d’intégration Apache/Perl réuni la puissance du langage de programmation Perl et le serveur HTTP Apache. Avec le module mod_perl il est alors possible d’écrire des modules Apache entièrement en Perl. De plus, la présence d’un interpréteur intégré au serveur évite la surcharge due au lancement d’un interpréteur externe et le délai pénalisant du démarrage de Perl.</p></div><div class=paragraph><p>Le module mod_perl est peut être obtenu de diverses manières. Pour l’utilisation du module mod_perl souvenez-vous que mod_perl 1.0 ne fonctionne qu’avec Apache 1.3 et mod_perl 2.0 ne fonctionne qu’avec Apache 2. Le module mod_perl 1.0 est disponible sous <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_perl/>www/mod_perl</a> et une version compilée en statique sous <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-modperl/>www/apache13-modperl</a>. Le module mod_perl 2.0 est disponible sous <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_perl2/>www/mod_perl2</a>.</p></div></div><div class=sect5><h6 id=_mod_php>31.7.5.2.2. mod_php<a class=anchor href=#_mod_php></a></h6><div class=paragraph><p>PHP, aussi connu sous le nom de "PHP: Hypertext Preprocessor" est un langage de script tout particulièrement adapté au développement Web. Pouvant être intégré à du HTML, sa syntaxe est dérivée du C, Java™, et du Perl avec pour objectif de permettre aux développeurs Web d’écrire rapidement des pages Web au contenu généré dynamiquement.</p></div><div class=paragraph><p>Pour ajouter le support de PHP5 au serveur Web Apache, commencez par installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a>.</p></div><div class=paragraph><p>Si c’est la première installation du logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a>, les <code>OPTIONS</code> disponibles seront affichées automatiquement. Si aucun menu n’est affiché, parce que le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> a été installé par le passé, il est toujours possible de forcer l’affichage du menu des options de compilation en utilisant la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make config</span></code></pre></div></div><div class=paragraph><p>dans le répertoire du logiciel porté.</p></div><div class=paragraph><p>Dans le menu des options de compilation, sélectionnez l’option <code>APACHE</code> pour compiler mod_php5 sous forme de module chargeable pour le serveur Web Apache.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>De nombreux sites utilisent toujours PHP4 pour diverses raisons (des problèmes de compatibilité ou des applications Web déjà déployées). Si mod_php4 est requis à la place de mod_php5, utilisez alors le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php4/>lang/php4</a>. Le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php4/>lang/php4</a> supporte plusieurs des options de configuration et de compilation du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Cela installera et configurera les modules requis au support des applications dynamiques PHP. Assurez-vous que les sections suivantes ont été ajoutées au fichier <span class=filename>/usr/local/etc/apache/httpd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>LoadModule php5_module        libexec/apache/libphp5.so</pre></div></div><div class="literalblock programlisting"><div class=content><pre>AddModule mod_php5.c
    IfModule mod_php5.c
        DirectoryIndex index.php index.html
    /IfModule
    IfModule mod_php5.c
        AddType application/x-httpd-php .php
        AddType application/x-httpd-php-source .phps
    /IfModule</pre></div></div><div class=paragraph><p>Ensuite, un simple appel à la commande <code>apachectl</code> pour un redémarrage élégant est requis pour charger le module PHP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div><div class=paragraph><p>Lors des futures mises à jour de PHP, la commande <code>make config</code> ne sera pas nécessaire; les <code>OPTIONS</code> précédemment sélectionnées sont automatiquement sauvegardées par le système des logiciels portés de FreeBSD.</p></div><div class=paragraph><p>Le support de PHP sous FreeBSD est extrêmement modulaire ce qui donne lieu à une installation de base limitée. Il est très simple d’ajouter une fonctionnalité en utilisant le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5-extensions/>lang/php5-extensions</a>. Ce logiciel porté fournit un menu pour l’installation des extensions PHP. Alternativement, il est possible d’installer les extensions individuellement en utilisant les logiciels portés correspondants.</p></div><div class=paragraph><p>Par exemple, pour ajouter à PHP5 le support pour le serveur de bases de données MySQL, installez simplement le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/databases/php5-mysql/>databases/php5-mysql</a>.</p></div><div class=paragraph><p>Après l’installation d’une extension, le serveur Apache doit être redémarré pour prendre en compte les changements de configuration:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div></div></div></div></div><div class=sect2><h3 id=network-ftp>31.8. Protocole de transfert de fichiers (FTP)<a class=anchor href=#network-ftp></a></h3><div class=sect3><h4 id=_généralités_3>31.8.1. Généralités<a class=anchor href=#_généralités_3></a></h4><div class=paragraph><p>Le protocol de transfert de fichiers (FTP) offre aux utilisateurs une méthode simple pour transférer des fichiers vers ou à partir d’un serveur FTP. FreeBSD comprend un serveur FTP, ftpd, dans le système de base. Cela rend la configuration et l’administration d’un serveur FTP sous FreeBSD très simple.</p></div></div><div class=sect3><h4 id=_configuration_6>31.8.2. Configuration<a class=anchor href=#_configuration_6></a></h4><div class=paragraph><p>L’étape de configuration la plus important est de décider quels comptes seront autorisés à accéder au serveur FTP. Un système FreeBSD classique possède de nombreux comptes système utilisés par divers "daemon"s, mais les utilisateurs inconnus ne devraient pas être autorisés à ouvrir de session sous ces comptes. Le fichier <span class=filename>/etc/ftpusers</span> est une liste d’utilisateurs interdits d’accès au serveur FTP. Par défaut, il inclut les comptes systèmes précédemment mentionnés, mais il est possible d’ajouter des utilisateurs précis qui ne devraient pas avoir accès au serveur FTP.</p></div><div class=paragraph><p>Vous pouvez vouloir restreindre l’accès à certains utilisateurs sans leur refuser complètement l’utilisation du serveur FTP. Cela peut être réalisé à l’aide du fichier <span class=filename>/etc/ftpchroot</span>. Ce fichier liste les utilisateurs et les groupes sujet à des restrictions d’accès FTP. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpchroot&amp;sektion=5&amp;format=html">ftpchroot(5)</a> fournit tous les détails, cela ne sera donc pas décrit ici.</p></div><div class=paragraph><p>Si vous désirez activer l’accès FTP anonyme sur votre serveur, vous devez alors créer un utilisateur appelé <code>ftp</code> sur votre serveur FreeBSD. Les utilisateurs seront donc en mesure d’ouvrir une session FTP sur votre serveur sous le nom d’utilisateur <code>ftp</code> ou <code>anonymous</code> et sans aucun mot de passe (par convention l’adresse électronique de l’utilisateur devrait être utilisée comme mot de passe). Le serveur FTP appellera <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> quand un utilisateur anonyme ouvrira une session, pour restreindre l’accès juste au répertoire personnel de l’utilisateur <code>ftp</code>.</p></div><div class=paragraph><p>Il existe deux fichiers texte qui spécifient les messages de bienvenue à afficher aux clients FTP. Le contenu du fichier <span class=filename>/etc/ftpwelcome</span> sera affiché aux utilisateurs avant qu’ils atteignent l’invite de session. Après une ouverture de session, le contenu du fichier <span class=filename>/etc/ftpmotd</span> sera affiché. Notez que le chemin d’accès à ce fichier est relatif à l’environnement de la session, aussi le fichier <span class=filename>~ftp/etc/ftpmotd</span> sera affiché aux utilisateurs anonymes.</p></div><div class=paragraph><p>Une fois que le serveur FTP a été configuré correctement, il doit être activé dans le fichier <span class=filename>/etc/inetd.conf</span>. Ici il faut juste retirer le symbole de commentaire "#" en face de la ligne ftpd:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l</pre></div></div><div class=paragraph><p>Comme expliqué dans la <a href=#network-inetd-reread>Recharger le fichier de configuration d’inetd</a>, la configuration d’inetd doit être rechargée après que le fichier de configuration ait été modifié.</p></div><div class=paragraph><p>Vous pouvez maintenant ouvrir une session FTP sur votre serveur en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftp localhost</code></pre></div></div></div><div class=sect3><h4 id=_maintenance>31.8.3. Maintenance<a class=anchor href=#_maintenance></a></h4><div class=paragraph><p>Le "daemon" ftpd utilise <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> pour l’enregistrement des messages. Par défaut, le "daemon" de gestion des journaux du système enverra les messages relatifs au FTP dans le fichier <span class=filename>/var/log/xferlog</span>. L’emplacement des journaux FTP peut être modifié en changeant la ligne suivante dans le fichier <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp.info      /var/log/xferlog</pre></div></div><div class=paragraph><p>Soyez conscient des éventuels problèmes impliqués par l’utilisation d’un serveur FTP acceptant les connexions anonymes. Vous devriez, tout particulièrement, penser à deux fois avant d’autoriser les utilisateurs anonyme à déposer des fichiers sur le serveur. Votre site FTP pourrait devenir un forum d’échange de logiciels commerciaux sans les licences ou pire. Si vous devez autoriser le dépôt de fichiers de façon anonyme sur le serveur FTP, alors vous devriez fixer les permissions sur ces fichiers de telle sorte qu’ils ne puissent être lus par d’autres utilisateurs anonymes avant qu’ils n’aient pu être contrôlés.</p></div></div></div><div class=sect2><h3 id=network-samba>31.9. Serveur de fichiers et d’impression pour clients Microsoft® Windows® (Samba)<a class=anchor href=#network-samba></a></h3><div class=sect3><h4 id=_généralités_4>31.9.1. Généralités<a class=anchor href=#_généralités_4></a></h4><div class=paragraph><p>Samba est un logiciel libre très populaire qui offre des services de partage de fichiers et d’imprimantes pour les clients Microsoft® Windows®. De tels clients peuvent se connecter et utiliser l’espace de fichiers d’une machine FreeBSD comme si c’était un disque local, ou utiliser des imprimantes FreeBSD comme si elles étaient des imprimantes locales.</p></div><div class=paragraph><p>Samba devrait se trouver sur votre support d’installation. Si vous n’avez pas installé Samba à l’installation de FreeBSD, vous pouvez alors l’installer à partir de la version pré-compilée ou portée <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba3/>net/samba3</a>.</p></div></div><div class=sect3><h4 id=_configuration_7>31.9.2. Configuration<a class=anchor href=#_configuration_7></a></h4><div class=paragraph><p>Le fichier de configuration par défaut de Samba est installé sous le nom <span class=filename>/usr/local/etc/smb.conf.default</span>. Ce fichier doit être copié vers <span class=filename>/usr/local/etc/smb.conf</span> et personnalisé avant que Samba ne puisse être utilisé.</p></div><div class=paragraph><p>Le fichier <span class=filename>smb.conf</span> contient la configuration nécessaire à l’exécution de Samba, comme la définition des imprimantes et des "systèmes de fichiers partagés" que vous désirez partager avec les clients Windows®. Le logiciel Samba comprend une interface Web appelé swat qui offre une méthode simple de configuration du fichier <span class=filename>smb.conf</span>.</p></div><div class=sect4><h5 id=_utilisation_de_linterface_web_dadministration_de_samba_swat>31.9.2.1. Utilisation de l’interface web d’administration de Samba (SWAT)<a class=anchor href=#_utilisation_de_linterface_web_dadministration_de_samba_swat></a></h5><div class=paragraph><p>L’interface web d’administration de Samba (SWAT) est exécutée sous la forme d’un "daemon" à partir d’inetd. Par conséquent, la ligne suivante dans le fichier <span class=filename>/etc/inetd.conf</span> doit être décommentée avant que swat ne puisse être utilisé pour configurer Samba:</p></div><div class="literalblock programlisting"><div class=content><pre>swat   stream  tcp     nowait/400      root    /usr/local/sbin/swat    swat</pre></div></div><div class=paragraph><p>Comme expliqué dans la <a href=#network-inetd-reread>Recharger le fichier de configuration d’inetd</a>, la configuration d’inetd doit être rechargée après modification de ce fichier de configuration.</p></div><div class=paragraph><p>Une fois que swat a été activé dans <span class=filename>inetd.conf</span>, vous pouvez utiliser un navigateur pour vous connecter à l’adresse <a href=http://localhost:901>http://localhost:901</a>. Vous devez ouvrir tout d’abord une session sous le compte système <code>root</code>.</p></div><div class=paragraph><p>Une fois que vous avez ouvert une session sur la page principale de configuration de Samba, vous pouvez naviguer dans la documentation du système, ou commencer par cliquer sur l’onglet <b class=menuref>Globals</b>. Le menu <b class=menuref>Globals</b> correspond aux variables situées dans la section <code>[global]</code> du fichier <span class=filename>/usr/local/etc/smb.conf</span>.</p></div></div><div class=sect4><h5 id=_paramétrages_généraux>31.9.2.2. Paramétrages généraux<a class=anchor href=#_paramétrages_généraux></a></h5><div class=paragraph><p>Que vous utilisiez swat ou éditiez directement le fichier <span class=filename>/usr/local/etc/smb.conf</span>, les premières directives que vous allez sûrement rencontrer en configurant Samba seront:</p></div><div class=dlist><dl><dt class=hdlist1><code>workgroup</code></dt><dd><p>Le nom de domaine NT ou le groupe de travail pour les ordinateurs qui accéderont à ce serveur.</p></dd><dt class=hdlist1><code>netbios name</code></dt><dd><p>Fixe le nom NetBIOS sous lequel est connu le serveur Samba. Par défaut c’est le même que la première composante du nom de la machine pour le DNS.</p></dd><dt class=hdlist1><code>server string</code></dt><dd><p>Cette directive définie la chaîne de caractères qui sera affichée lors de l’utilisation de la commande <code>net view</code> et par d’autres outils réseau recherchant à afficher une description du serveur.</p></dd></dl></div></div><div class=sect4><h5 id=_paramètres_de_sécurité>31.9.2.3. Paramètres de sécurité<a class=anchor href=#_paramètres_de_sécurité></a></h5><div class=paragraph><p>Deux des plus importants paramétrages de <span class=filename>/usr/local/etc/smb.conf</span> sont le mode de sécurité choisi, et le format de mot de passe pour les utilisateurs. Les directives suivantes contrôlent ces options:</p></div><div class=dlist><dl><dt class=hdlist1><code>security</code></dt><dd><p>Les deux options les plus courantes sont <code>security = share</code> et <code>security = user</code>. Si vos clients utilisent des noms d’utilisateur identiques à ceux sur votre machine FreeBSD, alors vous voudrez utiliser un niveau de sécurité utilisateur. C’est le mode de sécurité par défaut et qui demande aux clients de d’ouvrir une session avant de pouvoir accéder aux ressources partagées.</p><div class=paragraph><p>Dans le niveau de sécurité partage ("share"), le client n’a pas besoin d’ouvrir de session avant de pouvoir se connecter à une ressource partagée. C’était le mode de sécurité par défaut d’anciennes versions de Samba.</p></div></dd><dt class=hdlist1><code>passdb backend</code></dt><dd><p>Samba possède plusieurs modèles de support d’authentification. Vous pouvez authentifier des clients avec LDAP, NIS+, une base de données SQL ou un fichier de mot de passe modifié. La méthode d’authentification par défaut est appelée <code>smbpasswd</code>, et c’est celle qui sera présentée ici.</p></dd></dl></div><div class=paragraph><p>En supposant que le modèle <code>smbpasswd</code> par défaut est utilisé, le fichier <span class=filename>/usr/local/private/smbpasswd</span> doit être créé pour permettre à Samba d’identifier les clients. Si vous désirez donner accès à vos comptes utilisateur UNIX® à partir de clients Windows®, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># smbpasswd -a username</span></code></pre></div></div><div class=paragraph><p>Veuillez consulter le <a href=http://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/>tutorial officiel de Samba</a> pour des informations supplémentaires sur les options de configuration. Avec les bases présentées ici, vous devriez disposer de tous les éléments nécessaires au démarrage de Samba.</p></div></div></div><div class=sect3><h4 id=_démarrage_de_samba>31.9.3. Démarrage de Samba<a class=anchor href=#_démarrage_de_samba></a></h4><div class=paragraph><p>Le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba3/>net/samba3</a> amène une nouvelle procédure de démarrage qui peut être employée pour contrôler Samba. Pour activer cette procédure de manière à ce qu’elle soit utilisée pour par exemple lancer, arrêter ou relancer Samba, ajoutez la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>samba_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ou, pour un contrôle plus fin:</p></div><div class="literalblock programlisting"><div class=content><pre>nmbd_enable=&#34;YES&#34;
	smbd_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Avec cela, Samba sera automatiquement lancé au démarrage.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Il est alors possible de démarrer Samba à n’importe quel moment en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/samba start</span>
Starting SAMBA: removing stale tdbs :
Starting nmbd.
Starting smbd.</code></pre></div></div><div class=paragraph><p>Veuillez consulter la <a href=./#configtuning-rcd>Utilisation du système rc(8) sous FreeBSD</a> pour plus d’information sur les procédures rc.</p></div><div class=paragraph><p>Samba consiste essentiellement en trois "daemon"s séparés. Vous devriez vous rendre compte que les "daemon"s nmbd et smbd sont lancés par la procédure <span class=filename>samba</span>. Si vous avez activé la résolution de noms winbind dans le fichier <span class=filename>smb.conf</span>, alors le "daemon" winbindd sera également lancé.</p></div><div class=paragraph><p>Vous pouvez arrêter Samba à tout moment en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/samba stop</span></code></pre></div></div><div class=paragraph><p>Samba est une suite logiciels complexes avec des fonctionnalités permettant une large intégration avec les réseaux Microsoft® Windows®. Pour plus d’information sur les fonctionnalités non-abordées dans ce document, veuillez consulter <a href=http://www.samba.org>http://www.samba.org</a>.</p></div></div></div><div class=sect2><h3 id=network-ntp>31.10. Synchronisation de l’horloge avec NTP<a class=anchor href=#network-ntp></a></h3><div class=sect3><h4 id=_généralités_5>31.10.1. Généralités<a class=anchor href=#_généralités_5></a></h4><div class=paragraph><p>Avec le temps, l’horloge d’un ordinateur tend à dériver. Le protocole NTP ("Network Time Protocol") est une des manières pour s’assurer que votre horloge reste précise.</p></div><div class=paragraph><p>De nombreux services Internet ont besoin, ou tirent partie, de la précision des horloges des ordinateurs. Par exemple, un serveur web, peut recevoir des requêtes pour n’envoyer un fichier que s’il a été modifié depuis un certain temps. Sur un réseau local, il est essentiel que les ordinateurs partageant des fichiers à partir du même serveur de fichiers aient des horloges synchronisées de manière à ce que les dates de création ou de dernière modification d’un fichier ("timestamp") soient cohérentes. Des services comme <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> reposent sur une horloge système précise pour exécuter des commandes à des moments précis.</p></div><div class=paragraph><p>FreeBSD est fourni avec le serveur NTP <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> qui peut être utilisé pour contacter d’autres serveurs NTP pour régler l’horloge de votre machine ou pour jouer le rôle de serveur de temps pour d’autres.</p></div></div><div class=sect3><h4 id=_choisir_les_serveurs_ntp_appropriés>31.10.2. Choisir les serveurs NTP appropriés<a class=anchor href=#_choisir_les_serveurs_ntp_appropriés></a></h4><div class=paragraph><p>Afin de synchroniser votre horloge, vous devrez trouver un ou plusieurs serveurs NTP. Votre administrateur réseau ou votre FAI peuvent avoir mis en place un serveur NTP dans cet objectif-consultez leur documentation pour voir si c’est le cas. Il existe une <a href=http://ntp.isc.org/bin/view/Servers/WebHome>liste en ligne de serveurs NTP accessibles par le public</a> que vous pouvez utiliser pour trouver un serveur NTP proche de vous. Assurez-vous d’avoir pris connaissance de la politique d’utilisation des serveurs que vous choisissez, et demandez la permission si nécessaire.</p></div><div class=paragraph><p>Choisir plusieurs serveurs NTP non-connectés entre eux est une bonne idée au cas où un des serveurs que vous utilisez devient inaccessible ou que son horloge n’est plus fiable. <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> utilise intelligemment les réponses qu’il reçoit d’autres serveurs-il favorisera les plus fiables par rapport aux moins fiables.</p></div></div><div class=sect3><h4 id=_configuration_de_votre_machine>31.10.3. Configuration de votre machine<a class=anchor href=#_configuration_de_votre_machine></a></h4><div class=sect4><h5 id=_configuration_de_base>31.10.3.1. Configuration de base<a class=anchor href=#_configuration_de_base></a></h5><div class=paragraph><p>Si vous désirez synchroniser votre horloge uniquement lors du démarrage de la machine, vous pouvez alors employer <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a>. Cela peut être approprié pour certaines machines de bureau qui sont fréquemment redémarrées et qui ne nécessites qu’une synchronisation épisodique, cependant la plupart des machines devraient utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>.</p></div><div class=paragraph><p>Utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> au moment du démarrage est également une bonne idée pour les machines qui exécutent <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> modifie l’horloge graduellement, alors que <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> change directement l’horloge, peu importe la différence entre l’heure actuelle de la machine et l’heure correcte.</p></div><div class=paragraph><p>Pour activer <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> au démarrage, ajoutez la ligne <code>ntpdate_enable="YES"</code> au fichier <span class=filename>/etc/rc.conf</span>. Vous devrez également préciser tous les serveurs avec lesquels vous désirez vous synchroniser et tous les indicateurs devant être passés à <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> avec <code>ntpdate_flags</code>.</p></div></div><div class=sect4><h5 id=_configuration_générale>31.10.3.2. Configuration générale<a class=anchor href=#_configuration_générale></a></h5><div class=paragraph><p>NTP est configuré par l’intermédiaire du fichier <span class=filename>/etc/ntp.conf</span> suivant le format décrit dans la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a>. Voici un exemple simple:</p></div><div class="literalblock programlisting"><div class=content><pre>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</pre></div></div><div class=paragraph><p>L’option <code>server</code> précise quels serveurs doivent être utilisés, avec un serveur listé par ligne. Si un serveur est spécifié avec l’argument <code>prefer</code>, comme c’est le cas pour <code>ntplocal.example.com</code>, ce serveur est préféré par rapport aux autres serveurs. Une réponse en provenance d’un serveur <em>préféré</em> sera ignorée si elle diffère de façon significative des réponses des autres serveurs, sinon elle sera utilisée sans considérer les autres réponses. L’argument <code>prefer</code> est normalement employé pour les serveurs NTP qui sont connus pour leur grande précision, comme ceux avec des systèmes spéciaux de contrôle du matériel.</p></div><div class=paragraph><p>L’option <code>driftfile</code> précise quel fichier est utilisé pour stocker le décalage de fréquence de l’horloge. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> l’utilise pour compenser automatiquement la dérive naturelle de l’horloge, permettant de maintenir un réglage raisonnablement correct même s’il est coupé d’autres sources extérieures de temps pendant une certaine période.</p></div><div class=paragraph><p>L’option <code>driftfile</code> précise également quel fichier est utilisé pour stocker l’information concernant les réponses précédentes des serveurs NTP que vous utilisez. Il ne devrait pas être modifié par un autre processus.</p></div></div><div class=sect4><h5 id=_contrôler_laccès_à_votre_serveur>31.10.3.3. Contrôler l’accès à votre serveur<a class=anchor href=#_contrôler_laccès_à_votre_serveur></a></h5><div class=paragraph><p>Par défaut, votre serveur NTP sera accessible par toutes les machines sur l’Internet. L’option <code>restrict</code> du fichier <span class=filename>/etc/ntp.conf</span> vous permet de contrôler quelles machines peuvent accéder à votre serveur.</p></div><div class=paragraph><p>Si vous voulez refuser à tout le monde l’accès à votre serveur NTP, ajoutez la ligne suivante au fichier <span class=filename>/etc/ntp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>restrict default ignore</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cela empêchera également à votre serveur d’accéder à tout serveur listé dans votre configuration locale. Si vous avez besoin de synchroniser votre serveur NTP avec un serveur NTP externe, vous devez alors autoriser le serveur en question. Consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> pour plus d’information.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous désirez autoriser uniquement l’accès aux machines de votre réseau pour qu’elles puissent synchroniser leur horloge, tout en vous assurant qu’elles ne peuvent configurer le serveur ou être utilisées comme point de de synchronisation, ajoutez:</p></div><div class="literalblock programlisting"><div class=content><pre>restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</pre></div></div><div class=paragraph><p>à la place, où <code>192.168.1.0</code> est une adresse IP de votre réseau et <code>255.255.255.0</code> est votre masque de sous-réseau.</p></div><div class=paragraph><p>Le fichier <span class=filename>/etc/ntp.conf</span> peut contenir plusieurs options <code>restrict</code>. Pour plus de détails, lisez la section <code>Access Control Support</code> de la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a>.</p></div></div></div><div class=sect3><h4 id=_exécuter_le_serveur_ntp>31.10.4. Exécuter le serveur NTP<a class=anchor href=#_exécuter_le_serveur_ntp></a></h4><div class=paragraph><p>Pour s’assurer que le serveur NTP est lancé au démarrage, ajoutez la ligne <code>ntpd_enable="YES"</code> dans le fichier <span class=filename>/etc/rc.conf</span>. Si vous désirez passer des indicateurs supplémentaires à <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>, éditez les paramètres de l’option <code>ntpd_flags</code> dans <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Pour lancer le serveur sans redémarrer votre machine, exécutez <code>ntpd</code> en étant sûr de préciser tout paramètre supplémentaire de <code>ntpd_flags</code> dans <span class=filename>/etc/rc.conf</span>. Par exemple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ntpd -p /var/run/ntpd.pid</span></code></pre></div></div></div><div class=sect3><h4 id=_utiliser_ntpd_avec_une_connexion_internet_temporaire>31.10.5. Utiliser ntpd avec une connexion Internet temporaire<a class=anchor href=#_utiliser_ntpd_avec_une_connexion_internet_temporaire></a></h4><div class=paragraph><p>Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> n’a pas besoin d’une connexion permanente à l’Internet pour fonctionner correctement. Cependant, si vous disposez d’une connexion temporaire qui est configurée de telle sorte qu’il y ait établissement de la connexion à la demande, c’est une bonne idée d’empêcher le trafic NTP de déclencher la numérotation ou de maintenir constamment établie la connexion. Si vous utilisez PPP en mode utilisateur, vous pouvez employer les directives <code>filter</code> dans le fichier <span class=filename>/etc/ppp/ppp.conf</span>. Par exemple:</p></div><div class="literalblock programlisting"><div class=content><pre> set filter dial 0 deny udp src eq 123
 # Empêche le trafic NTP de lancer une connexion
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Empêche le trafic NTP entrant de garder la connexion établie
 set filter alive 1 deny udp dst eq 123
 # Empêche le trafic NTP sortant de garder la connexion établie
 set filter alive 2 permit 0/0 0/0</pre></div></div><div class=paragraph><p>Pour plus de détails lisez la section <code>PACKET FILTERING</code> de la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> et les exemples du répertoire <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains fournisseurs d’accès Internet bloquent les ports dont le numéro est faible, empêchant NTP de fonctionner puisque les réponses n’atteignent jamais votre machine.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_information_supplémentaire>31.10.6. Information supplémentaire<a class=anchor href=#_information_supplémentaire></a></h4><div class=paragraph><p>La documentation pour le serveur NTP peut être trouvée dans le répertoire <span class=filename>/usr/shared/doc/ntp/</span> sous le format HTML.</p></div></div></div></div></div><div class=sect1><h2 id=firewalls>Chapitre 32. Firewalls <strong>Traduction en Cours </strong><a class=anchor href=#firewalls></a></h2><div class=sectionbody><div class=sect2><h3 id=firewalls-intro>32.1. Introduction<a class=anchor href=#firewalls-intro></a></h3></div><div class=sect2><h3 id=firewalls-concepts>32.2. Firewall Concepts<a class=anchor href=#firewalls-concepts></a></h3></div><div class=sect2><h3 id=firewalls-apps>32.3. Firewall Packages<a class=anchor href=#firewalls-apps></a></h3></div><div class=sect2><h3 id=firewalls-pf>32.4. The OpenBSD Packet Filter (PF) and ALTQ<a class=anchor href=#firewalls-pf></a></h3></div><div class=sect2><h3 id=firewalls-ipf>32.5. The IPFILTER (IPF) Firewall<a class=anchor href=#firewalls-ipf></a></h3></div><div class=sect2><h3 id=firewalls-ipfw>32.6. IPFW<a class=anchor href=#firewalls-ipfw></a></h3></div></div></div><div class=sect1><h2 id=advanced-networking>Chapitre 33. Administration réseau avancée<a class=anchor href=#advanced-networking></a></h2><div class=sectionbody><div class=sect2><h3 id=advanced-networking-synopsis>33.1. Synopsis<a class=anchor href=#advanced-networking-synopsis></a></h3><div class=paragraph><p>Ce chapitre abordera certains nombre de sujets réseau avancés.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Les bases sur les passerelles et les routes.</p></li><li><p>Comment configurer les périphériques IEEE 802.11 et Bluetooth®.</p></li><li><p>Comment utiliser FreeBSD en tant que pont ("bridge").</p></li><li><p>Comment configurer le démarrage via le réseau pour une machine sans disque dur.</p></li><li><p>Comment configurer la translation d’adresse réseau.</p></li><li><p>Comment connecter deux ordinateurs via PLIP.</p></li><li><p>Comment configurer l’IPv6 sur une machine FreeBSD.</p></li><li><p>Comment configurer ATM.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les bases des procédures <span class=filename>/etc/rc</span>.</p></li><li><p>Etre familier avec la terminologie réseau de base.</p></li><li><p>Savoir comment configurer et installer un nouveau noyau FreeBSD (<a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li><li><p>Savoir comment installer des logiciels tierce-partie (<a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-routing>33.2. Passerelles et routes<a class=anchor href=#network-routing></a></h3><div class=paragraph><p>Pour qu’une machine soit en mesure d’en contacter une autre, il faut que soit mis en place un mécanisme qui décrive comment aller de l’une à l’autre. C’est ce que l’on appelle le <em>routage</em>. Une "route" est définie par une paire d’adresses: une "destination" et une "passerelle". Cette paire signifie que pour atteindre cette <em>destination</em>, vous devez passer par cette <em>passerelle</em>. Il y a trois sortes de destination: les machines individuelles, les sous-réseaux, et "default"-la destination par défaut. La route par défaut ("default route") est utilisée lorsqu’aucune autre route n’est applicable. Nous parlerons un peu plus des routes par défaut par la suite. Il existe également trois sortes de passerelles: les machines individuelles, les interfaces (aussi appelées "liens"), et les adresses Ethernet matérielles (adresses MAC).</p></div><div class=sect3><h4 id=_un_exemple>33.2.1. Un exemple<a class=anchor href=#_un_exemple></a></h4><div class=paragraph><p>Pour illustrer différents aspects du routage, nous utiliserons l’exemple suivant, qui est produit par la commande <code>netstat</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1             UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>Les deux premières lignes définissent la route par défaut (dont nous parlerons dans la <a href=#network-routing-default>section suivante</a>) et la route <code>localhost</code>.</p></div><div class=paragraph><p>L’interface (colonne <code>Netif</code>) qu’il est indiqué d’utiliser pour <code>localhost</code> est <span class=filename>lo0</span>, aussi appelée interface "loopback"-en boucle. Ce qui veut dire que tout le trafic vers cette destination doit rester interne, au lieu d’être envoyé sur le réseau local, puisqu’il reviendra de toute façon à son point de départ.</p></div><div class=paragraph><p>Ce qui se remarque ensuite, ce sont les adresses commençant par <code>0:e0:</code>. Ce sont les adresses Ethernet matérielles, qui sont également connues sous le nom d’adresses MAC. FreeBSD reconnaîtra automatiquement toute machine (<code>test0</code> dans l’exemple) sur le réseau local Ethernet et ajoutera une route vers cette machine, directement via l’interface Ethernet <span class=filename>ed0</span>. Il y a aussi un délai (colonne <code>Expire</code>) associé à ce type de route, qui est utilisé si l’on entend plus parler de cette machine pendant un laps de temps précis. Quand cela arrive, la route vers cette machine est automatiquement supprimée. Ces machines sont identifiées par un mécanisme appelé RIP ("Routing Information Protocol"-protocole d’information de routage), qui met en place des routes vers les machines locales en déterminant le chemin le plus court.</p></div><div class=paragraph><p>FreeBSD ajoutera également des routes de sous-réseau pour le sous-réseau local (<code>10.20.30.255</code> est l’adresse de diffusion pour le sous-réseau <code>10.20.30</code>, et <code>example.com</code> est le nom de domaine associé à ce sous-réseau). La dénomination <code>link#1</code> fait référence à la première carte Ethernet de la machine. Vous constaterez qu’il n’y a pas d’autre interface associée à ces routes.</p></div><div class=paragraph><p>Ces deux types de routes (vers les machines du réseau local et les sous-réseaux locaux) sont automatiquement configurés par un "daemon" appelé routed. S’il ne tourne pas, alors seules les routes définies comme statiques (i.e. explicitement définies) existeront.</p></div><div class=paragraph><p>La ligne <code>host1</code> fait référence à votre machine, qui est identifiée par l’adresse Ethernet. Puisque nous sommes l’émetteur, FreeBSD sait qu’il faut utiliser l’interface en "boucle" (<span class=filename>lo0</span>) plutôt que d’envoyer les données sur l’interface Ethernet.</p></div><div class=paragraph><p>Les deux lignes <code>host2</code> montrent ce qui se passe quand on utilise un alias avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> (lisez la section sur l’Ethernet pour savoir pour quelles raisons on peut vouloir cela). Le symbole <code>=</code> qui suit l’interface <span class=filename>lo0</span> indique que non seulement nous utilisons l’interface en "boucle" (puisque cette adresse correspond également à la machine locale), mais que c’est plus spécifiquement un alias. Ce type de route n’apparaît que sur la machine pour laquelle est défini l’alias; sur toutes les autres machines du réseau local il n’y aura q’une ligne <code>link#1</code> pour cette machine.</p></div><div class=paragraph><p>La dernière ligne (le sous-réseau destinataire <code>224</code>) concerne le multicasting (diffusion pour plusieurs destinataires), qui sera abordé dans une autre section.</p></div><div class=paragraph><p>Et enfin, diverses caractéristiques de chaque route sont indiquées dans la colonne <code>Flags</code> (indicateurs). Ci-dessous, une courte table présente certains de ces indicateurs et leur signification:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Active ("Up"): la route est active.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Machine ("Host"): la destination de la route est une machine.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Passerelle ("Gateway"): envoyer tout ce qui concerne cette destination sur la machine distante indiquée, qui déterminera à qui transmettre ensuite.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Statique ("Static"): cette route a été configurée manuellement et non pas générée automatiquement par le système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clone: génère une nouvelle route sur la base de celle-ci pour les machines auxquelles nous nous connectons. Ce type de route est normalement utilisé pour les réseaux locaux.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clonée ("WasCloned"): cette route a été auto-configurée (Clone) à partir d’une route pour le réseau local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lien ("Link"): la route fait référence à une adresse matérielle Ethernet.</p></td></tr></tbody></table></div><div class=sect3><h4 id=network-routing-default>33.2.2. Routes par défaut<a class=anchor href=#network-routing-default></a></h4><div class=paragraph><p>Quand le système local doit établir une connexion avec une machine distante, il consulte la table de routage pour voir s’il existe déjà une route connue. Si la machine distante appartient à un sous-réseau auquel le système sait se connecter (routes clonées), alors le système vérifie s’il peut se connecter via cette interface.</p></div><div class=paragraph><p>Si toutes les routes connues échouent, il reste alors au système une dernière option: la route par "défaut". Cette route est un type particulier de route passerelle (c’est généralement la seule du système), et est toujours marquée avec un <code>c</code> dans le champ des indicateurs. Pour les machines du réseau local, cette passerelle est définie avec la machine qui est directement connectée au monde extérieur (que ce soit par une liaison PPP, DSL, cable, T1, ou toute autre interface réseau).</p></div><div class=paragraph><p>Si vous configurez la route par défaut sur une machine qui fonctionne comme passerelle vers le monde extérieur, alors la route par défaut sera la passerelle de votre Fournisseur d’Accès à Internet (FAI).</p></div><div class=paragraph><p>Examinons un exemple de route par défaut. Voici une configuration classique:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/net-routing.png alt="net routing"></div></div><div class=paragraph><p>Les machines <code>Local1</code> et <code>Local2</code> sont sur votre site. <code>Local1</code> est connectée au serveur du FAI via une liaison PPP par modem. Ce serveur PPP est connecté par l’intermédiaire d’un réseau local à un autre ordinateur passerelle relié au point d’entrée Internet du FAI.</p></div><div class=paragraph><p>Les routes par défaut sur chacune de vos machines seront:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Machine</th><th class="tableblock halign-left valign-top">Passerelle par défaut</th><th class="tableblock halign-left valign-top">Interface</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ethernet</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PPP</p></td></tr></tbody></table><div class=paragraph><p>Une question qui revient souvent est "Pourquoi (ou comment) définir <code>T1-GW</code> comme passerelle par défaut pour <code>Local1</code>, plutôt que le serveur du FAI auquel elle est connectée?".</p></div><div class=paragraph><p>Rappelez-vous, puisque l’interface PPP utilise, de votre côté de la connexion, une adresse IP du réseau local du FAI, les routes vers toute autre machine du réseau local du FAI seront automatiquement générées. Par conséquent vous savez déjà comment atteindre la machine <code>T1-GW</code>, il n’y a donc pas besoin d’étape intermédiaire qui passe par le serveur du FAI.</p></div><div class=paragraph><p>Il est habituel d’attribuer l’adresse <code>X.X.X.1</code> à la passerelle sur votre réseau local. Donc (dans notre exemple), si votre espace d’adresse de classe C local était <code>10.20.30</code> et que votre FAI utilisait l’espace <code>10.9.9</code>, alors les routes par défaut seraient:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machine</th><th class="tableblock halign-left valign-top">Route par défaut</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2 (10.20.30.2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1, 10.9.9.30)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW (10.9.9.1)</p></td></tr></tbody></table><div class=paragraph><p>Vous pouvez aisément définir la route par défaut via le fichier <span class=filename>/etc/rc.conf</span>. Dans notre exemple, sur la machine <code>Local2</code>, nous avons ajouté la ligne suivante dans <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>Il est également possible de faire directement cela à partir de la ligne de commande avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Pour plus d’informations sur la manipulation à la main des tables de routage réseau, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect3><h4 id=_machines_sur_deux_réseaux>33.2.3. Machines sur deux réseaux<a class=anchor href=#_machines_sur_deux_réseaux></a></h4><div class=paragraph><p>Il y a un autre type de configuration dont il faut parler, c’est celle d’une machine qui est connectée à deux réseaux différents. Techniquement, toute machine servant de passerelle (comme dans l’exemple ci-dessus, en utilisant une connexion PPP) est une machine sur deux réseaux. Mais ce terme n’est normalement utilisé que pour faire référence à une machine qui est sur deux réseaux locaux différents.</p></div><div class=paragraph><p>Selon le cas, la machine dispose de deux cartes Ethernet, ayant chacune une adresse sur des sous-réseaux séparés. Alternativement, la machine peut ne disposer que d’une seule carte Ethernet, et utiliser des alias avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Le premier cas correspond à l’utilisation de deux réseaux Ethernet physiquement séparés, le deuxième cas est employé s’il n’y a qu’un seul réseau physique mais deux sous-réseaux logiquement distincts.</p></div><div class=paragraph><p>Dans les deux cas, les tables de routage sont définies de telle sorte que chaque sous-réseau sache que cette machine est la passerelle (route entrante) vers l’autre sous-réseau. Cette configuration, où la machine sert de routeur entre les deux sous-réseaux, est souvent utilisée quand il faut mettre en place un dispositif de sécurité: filtrage de paquets ou coupe-feu, dans l’une ou dans les deux directions.</p></div><div class=paragraph><p>Si vous voulez que cette machine transmette réellement les paquets entre les deux interfaces, vous devez demander à FreeBSD d’activer cette fonctionnalité. Lisez la section suivante pour plus de détails sur comment faire cela.</p></div></div><div class=sect3><h4 id=network-dedicated-router>33.2.4. Mettre en place un routeur<a class=anchor href=#network-dedicated-router></a></h4><div class=paragraph><p>Un routeur est un système qui transmet les paquets d’une interface à une autre. Les standards de l’Internet et de bons principes d’ingénierie empêchent le projet FreeBSD d’activer cette fonction par défaut sous FreeBSD. Vous pouvez l’activer en positionnant à <code>YES</code> la variable suivante du fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>Cette option fixera la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>net.inet.ip.forwarding</code> à la valeur <code>1</code>. Si vous devez arrêter temporairement le routage, vous pouvez positionner la variable momentanément à <code>0</code>.</p></div><div class=paragraph><p>Votre nouveau routeur aura besoin de route pour savoir où envoyer le trafic. Si votre réseau est suffisamment simple vous pouvez utiliser des routes statiques. FreeBSD est également fourni avec le "daemon" de routage BSD standard <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, qui comprend et utilise les protocoles RIP (version 1 est 2) et IRDP. Le support de BGP v4, OSPF v2, et d’autres protocoles de routage sophistiqué est disponible avec le logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a>. Des produits commerciaux comme GateD® sont également disponibles comme solutions avancées de routage.</p></div></div><div class=sect3><h4 id=_configurarion_des_routes_statiques>33.2.5. Configurarion des routes statiques<a class=anchor href=#_configurarion_des_routes_statiques></a></h4><div class=sect4><h5 id=_configuration_manuelle>33.2.5.1. Configuration manuelle<a class=anchor href=#_configuration_manuelle></a></h5><div class=paragraph><p>Supposons que nous avons un réseau comme celui-ci:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>Dans ce scénario, <code>RouteurA</code> est notre machine FreeBSD qui joue le rôle de routeur pour l’Internet. Elle a une route par défaut vers <code>10.0.0.1</code> qui permet de se connecter au reste du monde extérieur. Nous supposerons que la machine <code>RouteurB</code> est correctement configurée et sait comment transmettre vers n’importe quelle destination (D’après notre schéma c’est relativement simple. Ajoutez juste une route par défaut sur <code>RouteurB</code> en utilisant <code>192.168.1.1</code> comme passerelle).</p></div><div class=paragraph><p>Si nous regardons la table de routage de <code>RouteurA</code> nous verrions quelque chose comme:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Avec la table de routage actuelle, <code>RouteurA</code> ne sera pas en mesure d’atteindre notre réseau interne 2. Elle ne dispose pas de route pour <code>192.168.2.0/24</code>. Une manière de résoudre cela est d’ajouter manuellement la route. La commande suivante ajouterait le réseau interne 2 à la table de routage de <code>RouteurA</code> en utilisant <code>192.168.1.2</code> comme point intermédiaire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Maintenant <code>RouteurA</code> peut joindre n’importe quelle machine du réseau <code>192.168.2.0/24</code>.</p></div></div><div class=sect4><h5 id=_configuration_persistante>33.2.5.2. Configuration persistante<a class=anchor href=#_configuration_persistante></a></h5><div class=paragraph><p>L’exemple précédent est parfait pour configurer une route statique sur un système en fonctionnement. Cependant, le problème est que l’information de routage ne sera pas conservée si vous redémarrez votre machine FreeBSD. L’addition d’une route statique doit se faire dans votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>La variable <code>static_routes</code> est une liste de chaîne de caractères séparées par une espace. Chaque chaîne fait référence à un nom de route. Dans notre exemple nous avons qu’une seule chaîne dans <code>static_routes</code>. Cette chaîne est <em>internalnet2</em>. Nous ajoutons ensuite une variable de configuration appelée <code>route_internalnet2</code> dans laquelle nous mettons tous les paramètres de configuration que nous passerions à la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>. Pour nous exemple précédent nous aurions utilisé la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>nous avons donc besoin de <code>"-net 192.168.2.0/24 192.168.1.2"</code>.</p></div><div class=paragraph><p>Comme cela a été précisé, nous pouvons avoir plus d’une chaîne dans la variable <code>static_routes</code>. Cela nous permet de créer plusieurs routes statiques. Les lignes suivantes donnent un exemple d’ajout de routes statiques pour les réseaux <code>192.168.0.0/24</code> et <code>192.168.1.0/24</code> sur un routeur imaginaire:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div></div><div class=sect3><h4 id=_propagation_de_route>33.2.6. Propagation de route<a class=anchor href=#_propagation_de_route></a></h4><div class=paragraph><p>Nous avons déjà expliqué comment définir nos routes vers le monde extérieur, mais pas comment le monde extérieur apprend à nous localiser.</p></div><div class=paragraph><p>Nous savons déjà que les tables de routages peuvent être renseignées pour que tout le trafic pour un espace d’adresses donné (dans nos exemples, un sous-réseau de classe C) soit envoyé à une machine précise de ce réseau, qui transmettra les paquets entrants.</p></div><div class=paragraph><p>Lorsqu’il attribue un espace d’adresses à votre site, votre fournisseur d’accès définira ses tables de routage de sorte que tout le trafic destiné à votre sous-réseau vous soit envoyé sur votre liaison PPP. Mais comment les sites à l’autre bout du pays savent-ils qu’ils doivent passer par votre fournisseur d’accès?</p></div><div class=paragraph><p>Il existe un mécanisme (assez semblable au système d’information distribué du DNS) qui conserve un enregistrement de tous les espaces d’adresses affectés, et définit leur point de connexion à la dorsale Internet ("backbone"). La "dorsale" comprend les liaisons principales qui véhiculent le trafic Internet à travers le pays et le monde entier. Chaque machine de la dorsale dispose d’une copie de l’ensemble des tables maîtresses qui aiguillent le trafic pour un réseau donné vers le transporteur correspondant de la dorsale, et de là par l’intermédiaire de fournisseurs d’accès successifs, jusqu’à atteindre votre réseau.</p></div><div class=paragraph><p>C’est le rôle de votre fournisseur d’accès d’annoncer aux sites de la dorsale qu’il est le point de connexion (et par conséquent la route entrante) pour votre site. C’est ce que l’on appelle la propagation de route.</p></div></div><div class=sect3><h4 id=_en_cas_de_problème_2>33.2.7. En cas de problème<a class=anchor href=#_en_cas_de_problème_2></a></h4><div class=paragraph><p>Il se peut qu’il y ait parfois un problème avec la propagation de route et que certains sites ne puissent vous atteindre. La commande probablement la plus utile pour déterminer où une route est défaillante est la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>. Elle est également utile si vous n’arrivez pas à vous connecter à une machine distante (i.e. lorsque <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> échoue).</p></div><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> prend comme paramètre le nom de la machine distante avec laquelle vous essayez d’établir une connexion. Elle vous donnera la liste de passerelles intermédiaires jusqu’à la machine cible, ou jusqu’à ce qu’il n’y ait plus de connexion.</p></div><div class=paragraph><p>Pour plus d’informations, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect3><h4 id=_routage_multicast>33.2.8. Routage multicast<a class=anchor href=#_routage_multicast></a></h4><div class=paragraph><p>FreeBSD supporte nativement les applications et le routage multicast (diffusion pour plusieurs destinataires). Les applications multicast ne nécessitent pas de configuration spécifique de FreeBSD, généralement, elles fonctionneront directement. Le routage multicast demande à ce que le support soit compilé dans le noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>De plus, le "daemon" de routage multicast, <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> doit être configuré par l’intermédiaire du fichier <span class=filename>/etc/mrouted.conf</span> pour mettre en place des tunnels et le protocole DVMRP. Plus de détails sur la configuration du routage multicast peuvent être trouvés dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a>.</p></div></div></div><div class=sect2><h3 id=network-wireless>33.3. Réseau sans fil<a class=anchor href=#network-wireless></a></h3><div class=sect3><h4 id=_introduction_5>33.3.1. Introduction<a class=anchor href=#_introduction_5></a></h4><div class=paragraph><p>Il peut être très utile de pouvoir utiliser un micro-ordinateur sans le désagrément d’être constamment relié à un câble réseau. FreeBSD peut être utilisé comme client sans fil, et même comme "point d’accès" sans fil.</p></div></div><div class=sect3><h4 id=_modes_de_fonctionnement_des_systèmes_sans_fils>33.3.2. Modes de fonctionnement des systèmes sans fils<a class=anchor href=#_modes_de_fonctionnement_des_systèmes_sans_fils></a></h4><div class=paragraph><p>Il existe deux manières différentes de configurer les périphériques sans fil 802.11: les modes BSS et IBSS.</p></div><div class=sect4><h5 id=_mode_bss>33.3.2.1. Mode BSS<a class=anchor href=#_mode_bss></a></h5><div class=paragraph><p>Le mode BSS est le mode généralement utilisé. Le mode BSS est également appelé mode infrastructure. Dans ce mode, plusieurs points d’accès sans fils sont connectés à un réseau câblé. Chaque réseau sans fil possède son propre nom. Ce nom est ce que l’on appelle le "SSID" du réseau.</p></div><div class=paragraph><p>Les clients sans fils se connectent à ces points d’accès sans fils. La norme IEEE 802.11 définie le protocole que les réseaux sans fils utilisent pour les connexions. Un client sans fil peut être attaché à un réseau particulier quand un SSID est fixé. Un client peut s’attacher à n’importe quel réseau en ne définissant pas explicitement de SSID.</p></div></div><div class=sect4><h5 id=_mode_ibss>33.3.2.2. Mode IBSS<a class=anchor href=#_mode_ibss></a></h5><div class=paragraph><p>Le mode IBSS, également appelé mode "ad-hoc", est conçu pour les connexions point à point. Il existe en fait deux types de mode ad-hoc. Le premier est le mode IBSS, également appelé mode ad-hoc ou IEEE ad-hoc. Ce mode est défini par les normes IEEE 802.11. Le deuxième mode est appelé ad-hoc démo ou encore mode ad-hoc Lucent (et parfois, ce qui prête à confusion, mode ad-hoc). C’est l’ancien mode ad-hoc pré-standard 802.11 et ne devrait être utilisé qu’avec d’anciennes installations. Nous ne parlerons pas des modes ad-hoc dans ce qui suit.</p></div></div></div><div class=sect3><h4 id=_mode_infrastructure>33.3.3. Mode infrastructure<a class=anchor href=#_mode_infrastructure></a></h4><div class=sect4><h5 id=_points_daccès>33.3.3.1. Points d’accès<a class=anchor href=#_points_daccès></a></h5><div class=paragraph><p>Un point d’accès est un périphérique sans fil qui permet à un ou plusieurs clients sans fils d’utiliser ce périphérique comme un hub. Quand ils utilisent un point d’accès, tous les clients communiquent par l’intermédiaire de ce point d’accès. Plusieurs points d’accès sont souvent utilisés pour couvrir l’intégralité d’une zone géographique comme une maison, une entreprise, ou un parc avec un réseau sans fil.</p></div><div class=paragraph><p>Les points d’accès ont généralement plusieurs connexions réseaux: la carte réseaux sans fil, et une ou plusieurs cartes réseaux Ethernet pour les connexions avec le reste du réseau.</p></div><div class=paragraph><p>Les points d’accès peuvent être achetés tout fait, ou vous pouvez construire le votre avec FreeBSD et une carte réseau sans fil supportée. De nombreux constructeurs proposent des points d’accès et des cartes réseaux sans fils avec diverses fonctionnalités.</p></div></div><div class=sect4><h5 id=_construire_un_point_daccès_avec_freebsd>33.3.3.2. Construire un point d’accès avec FreeBSD<a class=anchor href=#_construire_un_point_daccès_avec_freebsd></a></h5><div class=sect5><h6 id=_pré_requis>33.3.3.2.1. Pré-requis<a class=anchor href=#_pré_requis></a></h6><div class=paragraph><p>En vue de mettre en place un point d’accès sans fil sous FreeBSD, vous avez besoin d’une carte réseau sans fil compatible. Actuellement seule les cartes basées sur le circuit Prism sont supportées. Vous aurez également besoin d’une carte réseau câblée supportée par FreeBSD (cela ne devrait pas être difficile à trouver, FreeBSD supporte de nombreuses cartes). Dans le cadre de cette section, nous supposerons que le trafic passera par un pont entre la carte sans fil et le réseau relié à la carte réseau classique.</p></div><div class=paragraph><p>Le mode point d’accès implémenté par FreeBSD fonctionne mieux avec certaines versions de firmware. Les cartes utilisant un circuit Prism 2 devraient utiliser un firmware 1.3.4 ou plus récent. Les cartes Prism 2.5 et Prism 3 devraient utiliser la version 1.4.9. Des versions de firmware plus anciennes pourront ne pas fonctionner correctement. Actuellement, la seule manière de mettre à jour vos cartes est d’utiliser les outils de mise à jour du firmware pour Windows® disponibles auprès du constructeur de votre carte.</p></div></div><div class=sect5><h6 id=_configuration_8>33.3.3.2.2. Configuration<a class=anchor href=#_configuration_8></a></h6><div class=paragraph><p>Assurez-vous tout d’abord que votre système voit la carte réseau sans fil:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
	status: no carrier
	ssid <span class=s2>&#34;&#34;</span>
	stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>Ne vous préoccupez pas des détails, verifiez juste que s’affiche quelque chose qui vous indique qu’une carte réseau sans fil est installée. Si vous avez des problèmes à voir l’interface réseau sans fil correspondante, et que vous utilisez une carte de type PC Card, vous devriez consultez les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardc&amp;sektion=8&amp;format=html">pccardc(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardd&amp;sektion=8&amp;format=html">pccardd(8)</a> pour plus d’information.</p></div><div class=paragraph><p>Ensuite, vous devrez charger un module afin de mettre en place la partie de FreeBSD faisant office de pont pour le point d’accès. Pour charger le module <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a>, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload bridge</span></code></pre></div></div><div class=paragraph><p>Vous ne devriez pas voir apparaître de message d’erreur lors du chargement du module. Si ce n’est pas le cas, vous devrez peut-être compiler le support <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> dans votre noyau. La section sur le <a href=#network-bridging>Bridging</a> de ce manuel devrait pouvoir vous aider dans cette tâche.</p></div><div class=paragraph><p>Maintenant que cette partie est assurée, nous devons dire à FreeBSD entre quelles interface le pont doit être installé. Nous effectuons cette configuration en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge.enable=1</span>
<span class=c># sysctl net.link.ether.bridge.config=&#34;wi0 xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Sous les versions antérieures à la 5.2, vous devez utiliser à la place les options suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge=1</span>
<span class=c># sysctl net.link.ether.bridge_cfg=&#34;wi0,xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Il est maintenant possible de configurer la carte. La commande suivante positionnera la carte en mode point d’accès:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname &#34;FreeBSD AP&#34;</span></code></pre></div></div><div class=paragraph><p>La ligne <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> active l’interface <span class=filename>wi0</span>, fixe son paramètre SSID à la valeur <em>my_net</em>, et fixe le nom de station à <em>FreeBSD AP</em>. L’option <code>media DS/11Mbps</code> positionne la carte dans le mode 11Mbps et est nécessaire pour que le paramètre <code>mediaopt</code> soit pris en compte. L’option <code>mediaopt hostap</code> place l’interface dans le mode point d’accès. L’option <code>channel 11</code> fixe le canal 802.11b à employer. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> donne les options de canaux valides en fonction de votre zone géographique.</p></div><div class=paragraph><p>Vous devez maintenant disposer d’un point d’accès opérationnel et en fonctionnement. Vous êtes encouragés à lire les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> pour plus d’amples informations.</p></div><div class=paragraph><p>Il est également conseillé de lire la section qui suit sur le chiffrage.</p></div></div><div class=sect5><h6 id=_information_détat>33.3.3.2.3. Information d’état<a class=anchor href=#_information_détat></a></h6><div class=paragraph><p>Une fois que le point d’accès est configuré et opérationnel, les opérateurs voudront voir quels clients sont associés avec le point d’accès. A n’importe quel instant, l’opérateur pourra taper:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wicontrol -l</span>
1 station:
00:09:b7:7b:9d:16  <span class=nv>asid</span><span class=o>=</span>04c0, <span class=nv>flags</span><span class=o>=</span>3&lt;ASSOC,AUTH&gt;, <span class=nv>caps</span><span class=o>=</span>1&lt;ESS&gt;, <span class=nv>rates</span><span class=o>=</span>f&lt;1M,2M,5.5M,11M&gt;, <span class=nv>sig</span><span class=o>=</span>38/15</code></pre></div></div><div class=paragraph><p>Ceci nous montre qu’une station est associée, ainsi que son paramétrage. Les informations indiquées concernant le signal devraient être utilisées uniquement comme une indication relative sur sa puissance. Sa conversion en dBm ou tout autre unité varie en fonction des différentes versions de firmware.</p></div></div></div><div class=sect4><h5 id=_clients>33.3.3.3. Clients<a class=anchor href=#_clients></a></h5><div class=paragraph><p>Un client sans fil est un système qui se connecte à un point d’accès ou un autre client directement.</p></div><div class=paragraph><p>Typiquement, les clients sans fils disposent d’une seule interface réseau, la carte réseau sans fil.</p></div><div class=paragraph><p>Il existe quelques manières différentes de configurer un client sans fil. Elles sont basées sur les différents modes sans fils, généralement les modes BSS (mode infrastructure, qui nécessite un point d’accès), et IBSS (mode ad-hoc, ou mode point à point). Dans notre exemple, nous utiliserons le plus populaire des deux, le mode BSS, pour discuter avec un point d’accès.</p></div><div class=sect5><h6 id=_pré_requis_2>33.3.3.3.1. Pré-requis<a class=anchor href=#_pré_requis_2></a></h6><div class=paragraph><p>Il n’y a qu’un seul pré-requis pour configurer FreeBSD comme client sans fil. Vous aurez besoin d’une carte sans fil supportée par FreeBSD.</p></div></div><div class=sect5><h6 id=_configurer_un_client_sans_fil_freebsd>33.3.3.3.2. Configurer un client sans fil FreeBSD<a class=anchor href=#_configurer_un_client_sans_fil_freebsd></a></h6><div class=paragraph><p>Avant de commencer, vous aurez besoin de connaître certaines choses concernant le réseau sans fil auquel vous désirez vous connecter. Dans cet exemple, nous rejoignons un réseau ayant pour nom <em>my_net</em>, et avec le chiffrage des liaisons désactivé.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans cet exemple, nous n’utilisons pas le chiffrage des liaisons, ce qui est une situation dangereuse. Dans la section suivante, nous verrons comment activer le chiffrage, pourquoi il est important de le faire, et pourquoi certaines technologies de chiffrage ne vous protégerons pas complètement.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Assurez-vous que votre carte est reconnue par FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
	status: no carrier
	ssid <span class=s2>&#34;&#34;</span>
	stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>Maintenant, nous pouvons configurer la carte suivant les paramètres de notre réseau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</span></code></pre></div></div><div class=paragraph><p>Remplacez <code>192.168.0.20</code> et <code>255.255.255.0</code> avec une adresse IP ainsi qu’un masque de sous-réseau valides de votre réseau câblé. Rappelez-vous, notre point d’accès joue le rôle de pont entre le réseau sans fil et le réseau câblé, il apparaîtra aux autres cartes sur votre réseau que vous êtes sur le même réseau câblé.</p></div><div class=paragraph><p>Une fois cela effectué, vous devriez être en mesure d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> pour atteindre les machines sur le réseau câblé de la même façon que si vous étiez connecté en utilisant un câble réseau standard.</p></div><div class=paragraph><p>Si vous rencontrez des problèmes avec votre connexion sans fil, vérifiez que vous êtes associé-"associated" (connecté) avec le point d’accès:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0</span></code></pre></div></div><div class=paragraph><p>devrait retourner un certain nombre d’information; et vous devriez voir s’afficher:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>status: associated</code></pre></div></div><div class=paragraph><p>Si <code>associated</code> n’est pas affiché, alors il se peut que vous soyez hors de portée du point d’accès, que vous ayez le chiffrage activé, ou peut-être que vous ayez un problème de configuration.</p></div></div></div><div class=sect4><h5 id=_chiffrement>33.3.3.4. Chiffrement<a class=anchor href=#_chiffrement></a></h5><div class=paragraph><p>L’utilisation du chiffrement sur un réseau sans fil est important parce que vous n’avez plus la possibilité de conserver le réseau dans une zone protégée. Vos données sans fil seront diffusées dans tout le voisinage, et toute personne désirant y accéder pourra le faire. C’est ici que le chiffrement entre en jeu. En chiffrant les données qui sont envoyées par les ondes, vous rendez plus difficile l’interception de celles-ci par quiconque d’intéressé.</p></div><div class=paragraph><p>Les deux méthodes les plus courantes de chiffrage des données entre un client et un point d’accès sont le protocol WEP et <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a>.</p></div><div class=sect5><h6 id=_wep>33.3.3.4.1. WEP<a class=anchor href=#_wep></a></h6><div class=paragraph><p>WEP est l’abbrévation de "Wired Equivalency Protocol". Le protocole de chiffrage WEP est une tentative de rendre les réseaux sans fils aussi sûrs et sécurisés qu’un réseau filaire. Malheureusement, il a été craqué, et est relativement simple à déjouer. Cela signifie que l’on ne doit pas lui faire confiance quand il est nécessaire de chiffrer des données sensibles.</p></div><div class=paragraph><p>Cela reste mieux que rien du tout, utilisez ce qui suit pour activer WEP sur votre nouveau point d’accès FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</span></code></pre></div></div><div class=paragraph><p>Et vous pouvez activer WEP sur un client avec la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</span></code></pre></div></div><div class=paragraph><p>Notez que vous devriez remplacer <em>0x1234567890</em> par une clé plus personnelle.</p></div></div><div class=sect5><h6 id=_ipsec>33.3.3.4.2. IPsec<a class=anchor href=#_ipsec></a></h6><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> est un outil bien plus puissant et robuste pour chiffrer des données sur un réseau. C’est la méthode à préférer pour chiffrer les données sur un réseau sans fil. Vous pouvez obtenir plus de détails concernant <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> et comment l’implémenter dans la section <a href=#ipsec>IPsec</a> de ce manuel.</p></div></div></div><div class=sect4><h5 id=_outils>33.3.3.5. Outils<a class=anchor href=#_outils></a></h5><div class=paragraph><p>Il existe un petit nombre d’outils disponibles pour le débogage et la configuration d’un réseau sans fil, et nous tenterons ici d’en décrire certains ainsi que leurs fonctionnalités.</p></div><div class=sect5><h6 id=_la_suite_bsd_airtools>33.3.3.5.1. La suite bsd-airtools<a class=anchor href=#_la_suite_bsd_airtools></a></h6><div class=paragraph><p>La suite bsd-airtools est une trousse à outils complète qui comprend des outils d’audit sans fil pour le craquage du système WEP, la détection de points d’accès, etc.</p></div><div class=paragraph><p>Les utilitaires bsd-airtools peuvent être installés à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsd-airtools/>net-mgmt/bsd-airtools</a>. Des instructions sur l’installation des logiciels portés peuvent être trouvées dans le <a href=./#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a> de ce manuel.</p></div><div class=paragraph><p>Le programme <code>dstumbler</code> est l’outil qui permet la recherche de points d’accès et la mesure du rapport signal sur bruit. Si vous avez des difficultés à mettre en place et à faire fonctionner votre point d’accès, <code>dstumbler</code> pourra vous aider dans ce sens.</p></div><div class=paragraph><p>Pour tester la sécurité de votre réseau sans fil, vous pouvez choisir d’employer les outils "dweputils" (<code>dwepcrack</code>, <code>dwepdump</code> et <code>dwepkeygen</code>) pour vous aider à déterminer si WEP répond à vos besoins en matière de sécurité au niveau de votre réseau sans fil.</p></div></div><div class=sect5><h6 id=_les_utilitaires_wicontrol_ancontrol_et_raycontrol>33.3.3.5.2. Les utilitaires <code>wicontrol</code>, <code>ancontrol</code> et <code>raycontrol</code><a class=anchor href=#_les_utilitaires_wicontrol_ancontrol_et_raycontrol></a></h6><div class=paragraph><p>Il existe des outils que vous pouvez utiliser pour contrôler le comportement de votre carte réseau sans fil sur le réseau sans fil. Dans les exemples précédents, nous avons choisi d’employer <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> puisque notre carte sans fil utilise l’interface <span class=filename>wi0</span>. Si vous avez une carte sans fil Cisco, elle apparaîtrait comme <span class=filename>an0</span>, et vous utiliseriez alors le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=ancontrol&amp;sektion=8&amp;format=html">ancontrol(8)</a>.</p></div></div><div class=sect5><h6 id=_la_commande_ifconfig>33.3.3.5.3. La commande <code>ifconfig</code><a class=anchor href=#_la_commande_ifconfig></a></h6><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> propose plusieurs options identiques à celles de <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a>, cependant il manque quelques options. Consultez la page de manuel d’<a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> pour les différents paramètres et options en ligne de commande.</p></div></div></div><div class=sect4><h5 id=_cartes_supportées>33.3.3.6. Cartes supportées<a class=anchor href=#_cartes_supportées></a></h5><div class=sect5><h6 id=_points_daccès_2>33.3.3.6.1. Points d’accès<a class=anchor href=#_points_daccès_2></a></h6><div class=paragraph><p>Les seules cartes actuellement supportées pour le mode BSS (points d’accès) sont celles basées sur les circuits Prism 2, 2.5, ou 3. Pour une liste complète, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a>.</p></div></div><div class=sect5><h6 id=_clients_802_11b>33.3.3.6.2. Clients 802.11b<a class=anchor href=#_clients_802_11b></a></h6><div class=paragraph><p>Presque toutes les cartes réseaux sans fil 802.11b sont supportées sous FreeBSD. La plupart des cartes basées sur les circuits Prism, Spectrum24, Hermes, Aironet, et Raylink fonctionneront dans le mode IBSS (ad-hoc, point à point, et BSS).</p></div></div><div class=sect5><h6 id=_clients_802_11a_802_11g>33.3.3.6.3. Clients 802.11a 802.11g<a class=anchor href=#_clients_802_11a_802_11g></a></h6><div class=paragraph><p>Le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> supporte les normes 802.11a et 802.11g. Si votre carte est basée sur un circuit Atheros, vous devriez être en mesure d’utiliser ce pilote.</p></div><div class=paragraph><p>Malheureusement il y a toujours de nombreux fabricants qui ne fournissent pas à la communauté des logiciels libres les informations concernant les pilotes pour leurs cartes considérant de telles informations comme des secrets industriels. Par conséquent, il ne reste aux développeurs de FreeBSD et d’autres systèmes d’exploitation libres que deux choix: développer les pilotes en passant par un long et pénible processus de "reverse engineering" ou utiliser les pilotes binaires existants disponibles pour la plateforme Microsoft® Windows®. La plupart des développeurs, y compris ceux impliqués dans FreeBSD, ont choisi cette dernière approche.</p></div><div class=paragraph><p>Grâce aux contributions de Bill Paul (wpaul), depuis FreeBSD 5.3-RELEASE, il existe un support "natif" pour la spécification d’interface des pilotes de périphérique réseau (Network Driver Interface Specification-NDIS). Le NDISulator FreeBSD (connu également sous le nom de Project Evil) prend un pilote binaire réseau Windows® et lui fait penser qu’il est en train de tourner sous Windows®. Cette fonctionnalité est relativement nouvelle, mais semble fonctionner correctement dans la plupart des tests.</p></div><div class=paragraph><p>Pour utiliser le NDISulator, vous avez besoin de trois choses:</p></div><div class="olist arabic"><ol class=arabic><li><p>les sources du noyau;</p></li><li><p>le pilote binaire Windows® XP (extension <span class=filename>.SYS</span>);</p></li><li><p>le fichier de configuration du pilote Windows® XP (extension <span class=filename>.INF</span>).</p></li></ol></div><div class=paragraph><p>Vous aurez besoin de compiler le module d’interface du mini-pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>. En tant que <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/modules/ndis</span>
<span class=c># make  make install</span></code></pre></div></div><div class=paragraph><p>Recherchez les fichiers spécifiques à votre carte. Généralement, ils peuvent être trouvés sur les CDs livrés avec la carte ou sur le site du fabricant. Dans les exemples qui suivent nous utiliseront les fichiers <span class=filename>W32DRIVER.SYS</span> et <span class=filename>W32DRIVER.INF</span>.</p></div><div class=paragraph><p>L’étape suivante est de compiler le pilote binaire dans un module chargeable du noyau. Pour effectuer cela, en tant que <code>root</code>, rendez vous dans le répertoire du module <span class=filename>if_ndis</span> et copiez-y les fichiers du pilote Windows®:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/modules/if_ndis</span>
<span class=c># cp /path/to/driver/W32DRIVER.SYS ./</span>
<span class=c># cp /path/to/driver/W32DRIVER.INF ./</span></code></pre></div></div><div class=paragraph><p>Nous utiliserons maintenant l’utilitaire <code>ndiscvt</code> pour générer le fichier d’entête <span class=filename>ndis_driver_data.h</span> du pilote pour la compilation du module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndiscvt -i W32DRIVER.INF -s W32DRIVER.SYS -o ndis_driver_data.h</span></code></pre></div></div><div class=paragraph><p>Les options <code>-i</code> et <code>-s</code> précisent respectivement le fichier de configuration et le fichier binaire. Nous utilisons l’option <code>-o ndis_driver_data.h</code> car le <span class=filename>Makefile</span> recherchera ce fichier lors de la compilation du module.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains pilotes Windows® nécessitent des fichiers supplémentaires pour fonctionner. Vous pouvez les ajouter avec <code>ndiscvt</code> en utilisant l’option <code>-f</code>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ndiscvt&amp;sektion=8&amp;format=html">ndiscvt(8)</a> pour plus d’information.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nous pouvons enfin compiler et installer le module du pilote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make  make install</span></code></pre></div></div><div class=paragraph><p>Pour utiliser le pilote, vous devez charger les modules appropriés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>La première commande charge le pilote d’interface NDIS, la seconde charge l’interface réseau. Contrôlez la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> à la recherche d’une quelconque erreur au chargement. Si tout s’est bien passé, vous devriez obtenir une sortie ressemblant à ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
      ndis0: NDIS API version: 5.0
      ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
      ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
      ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>A partir de là, vous pouvez traiter le périphérique <span class=filename>ndis0</span> comme n’importe quel périphérique sans fil (e.g. <span class=filename>wi0</span>) et consulter les premières sections de ce chapitre.</p></div></div></div></div></div><div class=sect2><h3 id=network-bluetooth>33.4. Bluetooth<a class=anchor href=#network-bluetooth></a></h3><div class=sect3><h4 id=_introduction_6>33.4.1. Introduction<a class=anchor href=#_introduction_6></a></h4><div class=paragraph><p>Bluetooth® est une technologie sans fil pour créer des réseaux personnels sans fils fonctionnant dans la bande 2.4 GHz ne nécessitant pas d’autorisation, avec une portée de 10 mètres. Les réseaux étant généralement composés de périphériques nomades comme les téléphones portables, les assistants personnels et les ordinateurs portables. Contrairement à l’autre technologie sans fil, Wi-Fi, Bluetooth® offre un niveau plus élevé de profils de service, par exemple des serveurs de fichiers semblables à FTP, "file pushing", transport de la voix, émulation de lignes séries, et bien plus.</p></div><div class=paragraph><p>La pile Bluetooth® sous FreeBSD utilise le système Netgraph (voir <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>). Une large gamme d’adaptateurs USB Bluetooth® sont supportés par le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Les périphériques Bluetooth® basés sur le circuit Broadcom BCM2033 sont supportés par les pilotes <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. La carte 3Com Bluetooth® PC Card 3CRWB60-A demande le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>. Les périphériques Bluetooth® de type série et UART sont supportés via les pilotes <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>. Cette section décrit l’utilisation d’un adaptateur USB Bluetooth®. Le support Bluetooth® est disponible sur les systèmes 5.0 et suivants.</p></div></div><div class=sect3><h4 id=_branchement_du_périphérique>33.4.2. Branchement du périphérique<a class=anchor href=#_branchement_du_périphérique></a></h4><div class=paragraph><p>Par défaut les pilotes de périphériques Bluetooth® sont disponibles sous la forme de modules du noyau. Avant de brancher le périphérique, vous devrez charger le pilote dans le noyau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Si le périphérique Bluetooth® est présent au démarrage du système, chargez le module à partir de <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Branchez votre clé USB. Une sortie semblable à celle-ci devrait s’afficher sur la console (ou dans les journaux du système):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La pile Bluetooth doit être lancée manuellement sous FreeBSD 6.0, et sous les versions 5.0 antérieures à la 5.5. Ce lancement est automatique à partir de <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> sous FreeBSD 5.5, 6.1 et versions suivantes.</p></div><div class=paragraph><p>Copiez <span class=filename>/usr/shared/examples/netgraph/bluetooth/rc.bluetooth</span> à un emplacement adapté, comme <span class=filename>/etc/rc.bluetooth</span>. Cette procédure est utilisée pour démarrer et arrêter la pile Bluetooth®. C’est une bonne idée d’arrêter la pile avant de débrancher le périphérique, mais ce n’est pas (généralement) fatal. Quand la pile démarre, vous devriez avoir des messages similaires aux suivants:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_interface_de_contrôle_de_lhôte_hci>33.4.3. Interface de contrôle de l’hôte (HCI)<a class=anchor href=#_interface_de_contrôle_de_lhôte_hci></a></h4><div class=paragraph><p>L’interface de contrôle de l’hôte (HCI) fournit une interface de commande pour le contrôleur de la bande de base et le gestionnaire de liaisons, et l’accès à l’état du matériel et aux registres de contrôle. Cette interface offre une méthode uniforme d’accès aux fonctions de la bande de base Bluetooth®. La couche HCI de l’hôte échange des données et des commandes avec le firmware HCI du matériel Bluetooth®. Le pilote de la couche de transport du contrôleur d’hôte (i.e. le bus physique) fournit aux deux couches HCI la possibilité d’échanger des informations entre elles.</p></div><div class=paragraph><p>Un seul noeud Netgraph de type <em>hci</em> est créé pour un périphérique Bluetooth®. Le noeud HCI est normalement connecté au noeud du pilote Bluetooth® (flux descendant) et au noeud L2CAP (flux montant). Toutes les opérations HCI doivent être effectuées sur le noeud HCI et non pas sur le noeud du pilote de périphérique. Le nom par défaut pour le noeud HCI est "devicehci". Pour plus de détails consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Une des tâches les plus courantes est la recherche de périphériques Bluetooth® dans le voisinage hertzien. Cette opération est appelée <em>inquiry</em> (enquête, recherche). Cette recherche et les autres opérations relatives à HCI sont effectuées par l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. L’exemple ci-dessous montre comment déterminer quels périphériques Bluetooth® sont dans le voisinage. Vous devriez obtenir une listes de périphériques au bout de quelques secondes. Notez qu’un périphérique distant ne répondra à la recherche que s’il est placé dans le mode <em>discoverable</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> est l’adresse unique d’un périphérique Bluetooth®, similaire à l’adresse MAC d’une carte réseau. Cette adresse est nécessaire pour communiquer avec un périphérique. Il est possible d’assigner un nom humainement compréhensible à l’adresse BD_ADDR. Le fichier <span class=filename>/etc/bluetooth/hosts</span> contient des informations concernant les hôtes Bluetooth® connus. L’exemple suivant montre comment obtenir le nom qui a été assigné au périphérique distant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Si vous effectuez une recherche sur un périphérique Bluetooth® distant, vous devriez trouver votre ordinateur en tant que "votre.machine.nom (ubt0)". Le nom affecté au périphérique local peut être modifié à tout moment.</p></div><div class=paragraph><p>Le système Bluetooth® fournit une connexion point à point (seules deux matériels Bluetooth® sont concernés), ou une connexion point à multipoints. Dans le cas d’une connexion point à multipoints, la connexion est partagés entre plusieurs périphériques Bluetooth®. L’exemple suivant montre comment obtenir la liste des connexions en bande de base actives pour le périphérique local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Une <em>manipulation de la connexion</em> est utile quand la fin d’une connexion en bande de base est nécessaire. Notez qu’il n’est normalement pas nécessaire de le faire à la main. La pile mettra fin automatiquement aux connexions en bande de base inactives.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Référez-vous à la commande <code>hccontrol help</code> pour une liste complète des commandes HCI disponibles. La plupart des commandes HCI ne nécessitent pas les privilèges du super-utilisateur.</p></div></div><div class=sect3><h4 id=_protocole_dadaptation_et_de_contrôle_de_lien_logique_l2cap>33.4.4. Protocole d’adaptation et de contrôle de lien logique (L2CAP)<a class=anchor href=#_protocole_dadaptation_et_de_contrôle_de_lien_logique_l2cap></a></h4><div class=paragraph><p>Le protocole d’adaptation et de contrôle de lien logique (L2CAP) fournit des services orientés connexion ou non aux protocoles de niveaux supérieurs, et cela avec des possibilités de multiplexage de protocoles, de segmentation et de réassemblage. L2CAP permet aux applications et aux protocoles de niveaux supérieurs de transmettre et recevoir des paquets L2CAP d’une taille allant jusqu’à 64 Ko.</p></div><div class=paragraph><p>L2CAP est basé sur le concept de <em>canaux</em>. Un canal est une connexion logique au sommet de la connexion en bande de base. Chaque canal est attaché à un protocole suivant le schéma plusieurs-vers-un. Plusieurs canaux peuvent être attachés au même protocole, mais un canal ne peut être attachés à plusieurs protocoles. Chaque paquet L2CAP reçu sur un canal est dirigé vers le protocole de niveau supérieur approprié. Plusieurs canaux peuvent partager la même connexion en bande de base.</p></div><div class=paragraph><p>Un seul noeud Netgraph de type <em>l2cap</em> est créé pour un périphérique Bluetooth®. Le noeud L2CAP est normalement connecté au noeud HCI Bluetooth® (flux descendant) et aux noeuds des "sockets" Bluetooth® (flux montant). Le nom par défaut pour le noeud L2CAP est "device2cap". Pour plus de détails consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Une commande utile est <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, qui peut être utilisée pour "pinguer" les autres périphériques. Certaines implémentations de Bluetooth® peuvent ne pas renvoyer toutes les données qui leur sont envoyées, aussi <code>0 bytes</code> dans ce qui suit est normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> est employé pour effectuer diverses opérations sur les noeuds L2CAP. Cet exemple montre comment obtenir la liste des connexions logiques (canaux) et la liste des connexions en bande de base pour le périphérique local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Un autre outil de diagnostic est <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. Il effectue un travail similaire à celui de <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, mais relatif aux structures de données réseau Bluetooth®. L’exemple ci-dessous montre la même connexion logique que <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> ci-dessus.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect3><h4 id=_protocole_rfcomm>33.4.5. Protocole RFCOMM<a class=anchor href=#_protocole_rfcomm></a></h4><div class=paragraph><p>Le protocole RFCOMM permet l’émulation du port série au-dessus du protocole L2CAP. Le protocole est basé sur la norme ETSI TS 07.10. RFCOMM est un protocole de transport simple, avec les dispositions supplémentaires pour émuler les 9 circuits (signaux) d’un port série RS232 (EIATIA-232-E). Le protocole RFCOMM supporte jusqu’à 60 connexions simultanées (canaux RFCOMM) entre deux périphériques Bluetooth®.</p></div><div class=paragraph><p>Dans le cas de RFCOMM, l’établissement d’une communication implique deux applications tournant sur des périphériques différents (les extrémités de la communication) avec un segment de communication entre eux. RFCOMM est prévu pour couvrir les applications faisant usage des ports séries des périphériques sur lesquels elles résident. Le segment de communication est une liaison Bluetooth® d’un périphérique vers un autre (connexion directe).</p></div><div class=paragraph><p>RFCOMM est seulement concerné par la connexion entre périphériques dans le cas d’un raccordement direct, ou entre le périphérique et un modem dans le cas d’un réseau. RFCOMM peut supporter d’autres configurations, comme les modules qui communiquent par l’intermédiaire de la technologie sans fil Bluetooth® d’un côté et utilise une interface câblée de l’autre côté.</p></div><div class=paragraph><p>Sous FreeBSD, le protocole RFCOMM est implémenté au niveau de la couche des "sockets" Bluetooth®.</p></div></div><div class=sect3><h4 id=_couplage_des_périphériques>33.4.6. Couplage des périphériques<a class=anchor href=#_couplage_des_périphériques></a></h4><div class=paragraph><p>Par défaut, une communication Bluetooth® n’est pas authentifiée, et n’importe quel périphérique peut parler avec n’importe quel autre périphérique. Un périphérique Bluetooth® (par exemple un téléphone portable) peut choisir de demander une authentification pour fournir un service particulier (par exemple un service de connexion téléphonique). L’authentification Bluetooth® est généralement effectuée avec des <em>codes PIN</em>. Un code PIN est une chaîne ASCII d’une longueur de 16 caractères. L’utilisateur doit entrer le même code PIN sur les deux périphériques. Une fois que l’utilisateur a entré le code PIN, les deux périphériques génèrent une <em>clé de liaison</em> (link key). Ensuite la clé peut être enregistrée soit dans les périphériques eux-mêmes ou sur un moyen de stockage non-volatile. La fois suivante les deux périphériques utiliseront la clé précédemment générée. La procédure décrite est appelée <em>couplage</em>. Si la clé de liaison est perdue par un des périphériques alors l’opération de couplage doit être répétée.</p></div><div class=paragraph><p>Le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> est responsable de la gestion de toutes les requêtes d’authentification Bluetooth®. Le fichier de configuration par défaut est <span class=filename>/etc/bluetooth/hcsecd.conf</span>. Un exemple de section pour un téléphone portable avec un code PIN arbitraire de "1234" est donné ci-dessous:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>Il n’y pas de limitation sur les codes PIN (en dehors de la longueur). Certains périphériques (comme les casques-micro Bluetooth®) peuvent avoir un code PIN définitivement fixé. Le paramètre <code>-d</code> force le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> à rester en tâche de fond, il est donc aisé de voir ce qu’il se passe. Configurez le périphérique distant pour recevoir le couplage et initier la connexion Bluetooth® vers le périphérique distant. Le périphérique distant devrait annoncer que le couplage a été accepté, et demander le code PIN. Entrez le même code PIN que celui que vous avez dans le fichier <span class=filename>hcsecd.conf</span>. Maintenant votre PC et le périphérique distant sont couplés. Alternativement, vous pouvez initier le couplage sur le périphérique distant.</p></div><div class=paragraph><p>Sous FreeBSD 5.5, 6.1 et versions suivantes, la ligne suivante peut être ajoutée au fichier <span class=filename>/etc/rc.conf</span> pour obtenir un lancement automatique de hcsecd au démarrage du système:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ce qui suit est une partie de la sortie du "daemon" hcsecd:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect3><h4 id=_le_protocole_de_découverte_de_service_sdp>33.4.7. Le protocole de découverte de service (SDP)<a class=anchor href=#_le_protocole_de_découverte_de_service_sdp></a></h4><div class=paragraph><p>Le protocole de découverte de service (SDP) offre aux applications clientes les moyens de découvrir l’existence des services fournis par les applications serveurs ainsi que les propriétés (attributs) de ces services. Les attributs d’un service comprennent le type ou la classe du service offert et le mécanisme ou l’information sur le protocole nécessaire pour utiliser le service.</p></div><div class=paragraph><p>Le SDP implique la communication entre un serveur SDP et un client SDP. Le serveur maintient une liste d’enregistrements de services qui décrit les caractéristiques des services associés avec le serveur. Chaque enregistrement de service contient l’information sur un seul serveur. Un client peut récupérer l’information à partir d’un enregistrement de service maintenu par le serveur SDP en émettant une requête SDP. Si le client, ou une application associée avec le client, décide d’utiliser un service, il doit ouvrir une connexion séparée avec le fournisseur du service afin d’utiliser ce service. Le SDP fournit un mécanisme pour découvrir les services et leur attributs, mais n’offre pas de mécanisme pour utiliser ces services.</p></div><div class=paragraph><p>Généralement, un client SDP recherche les services sur la base de caractéristiques de services désirées. Cependant, il est parfois désirable de découvrir quel type de services sont décrits par les enregistrements de services d’un serveur SDP sans aucune information préalable sur les services. Ce processus de recherche des services offerts est appelé <em>navigation</em> ("browsing").</p></div><div class=paragraph><p>Le serveur SDP Bluetooth® <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> et le client en ligne de commande <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> font partie de l’installation FreeBSD standard. L’exemple suivant montre comment effectuer un requête de navigation ("browse") SDP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>et ainsi de suite. Remarquez que chaque service a une liste d’attributs (canal RFCOMM par exemple). En fonction du service vous pourrez avoir besoin de prendre note de certains de ces attributs. Certaines implémentations Bluetooth® ne supportent pas les requêtes de navigation et peuvent renvoyer une liste vide. Dans ce cas il est possible de chercher un service spécifique. L’exemple ci-dessous montre comment chercher le service OBEX Object Push (OPUSH):</p></li></ol></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Offrir des services sous FreeBSD aux clients Bluetooth® se fait à l’aide du serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>. Sous les versions de FreeBSD 5.5, 6.1 et plus récentes, la ligne suivante peut être ajoutée au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ensuite, le "démon"sdpd peut être démarré avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sdpd start</span></code></pre></div></div><div class=paragraph><p>Sous FreeBSD 6.0, et sous les versions FreeBSD 5.X antérieures à 5.5, sdpd n’est pas intégré aux procédures de démarrage du système. Il doit être lancé manuellement:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpd</span></code></pre></div></div><div class=paragraph><p>L’application serveur locale qui désire offrir un service Bluetooth® à des clients distants enregistrera le service auprès du "daemon" SDP local. Un exemple d’une telle application est <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Une fois démarré, il enregistrera un service de réseau local Bluetooth® auprès du serveur SDP local.</p></div><div class=paragraph><p>La liste des services enregistrés auprès du serveur SDP local peut être obtenue en émettant une requête de navigation ("browse") SDP par l’intermédiaire du canal de contrôle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect3><h4 id=_les_profils_dial_up_networking_dun_et_accès_au_réseau_local_avec_ppp_lan>33.4.8. Les profils Dial-Up Networking (DUN) et accès au réseau local avec PPP (LAN)<a class=anchor href=#_les_profils_dial_up_networking_dun_et_accès_au_réseau_local_avec_ppp_lan></a></h4><div class=paragraph><p>Le profil Dial-Up Networking (DUN) est principalement utilisé avec les modems et les téléphones portables. Les cas de figure couverts par ce profil sont les suivants:</p></div><div class=ulist><ul><li><p>Utilisation d’un téléphone portable ou d’un modem par un ordinateur comme modem sans fil pour se connecter à un serveur d’accès Internet, ou pour l’utilisation de services accessibles par téléphone;</p></li><li><p>Utilisation d’un téléphone portable ou d’un modem par un ordinateur pour recevoir des appels avec transmission de données.</p></li></ul></div><div class=paragraph><p>Le profil d’accès au réseau local avec PPP (LAN) peut être utilisé dans les situations suivantes:</p></div><div class=ulist><ul><li><p>Accès au réseau local pour un périphérique Bluetooth®;</p></li><li><p>Accès au réseau local pour plusieurs périphériques Bluetooth®;</p></li><li><p>Liaison PC à PC (en utilisant le protocole PPP sur une émulation de câble série).</p></li></ul></div><div class=paragraph><p>Sous FreeBSD les deux profils sont implémentés par <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>-un "wrapper" convertit la connexion Bluetooth® RFCOMM en quelque chose d’utilisable par PPP. Avant qu’un profil ne soit utilisable, un nouveau label doit être créé dans le fichier <span class=filename>/etc/ppp/ppp.conf</span>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> pour des exemples.</p></div><div class=paragraph><p>Dans l’exemple suivant <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> sera employé pour ouvrir un connexion RFCOMM avec le périphérique distant avec une adresse BD_ADDR 00:80:37:29:19:a4 sur un canal DUN RFCOMM. Le numéro de canal RFCOMM réel sera obtenu du périphérique distant par l’intermédiaire de SDP. Il est possible de préciser le canal RFCOMM à la main, dans ce cas <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> n’émettra pas de requête SDP. Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> pour trouver le canal RFCOMM sur le périphérique distant.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>Afin de fournir un service d’accès au réseau local avec PPP, le serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> doit être en fonctionnement. Une nouvelle entrée pour les clients du réseau local doit être créée dans le fichier <span class=filename>/etc/ppp/ppp.conf</span>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> pour des exemples. Enfin, lancez le serveur RFCOMM PPP sur un numéro de canal RFCOMM valide. Le serveur RFCOMM PPP enregistrera automatiquement un service Bluetooth® LAN auprès du "daemon" SDP local. L’exemple ci-dessous montre comment démarrer le serveur RFCOMM PPP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect3><h4 id=_le_profil_obex_object_push_opush>33.4.9. Le profil OBEX Object Push (OPUSH)<a class=anchor href=#_le_profil_obex_object_push_opush></a></h4><div class=paragraph><p>OBEX (échange d’objets) est un protocole très largement utilisé pour les transferts de fichiers entre périphériques mobiles. Son utilisation principale se trouve dans les communications par infrarouge, où il est utilisé pour le transfert des fichiers entre ordinateurs portables ou PDAs, et pour envoyer des cartes de visite électronique ou des éléments d’agenda entre téléphones portables et d’autres périphériques disposant d’applications de gestion d’informations personnelles (PIM).</p></div><div class=paragraph><p>Le serveur et le client OBEX sont implémentés dans le logiciel tierce-partie obexapp, qui est disponible sous la forme du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a>.</p></div><div class=paragraph><p>Le client OBEX est employé pour "pousser" et/ou "tirer" des objets du serveur OBEX. Un objet peut être, par exemple, une carte de visite ou un rendez-vous. Le client OBEX peut obtenir un numéro de canal RFCOMM d’un périphérique distant par l’intermédiaire de SDP. Cela peut être fait en spécifiant le nom du service plutôt que le numéro du canal RFCOMM. Les noms de service supportés sont: IrMC, FTRN et OPUSH. Il est possible de préciser le canal RFCOMM par un nombre. Un exemple de session OBEX est présenté ci-dessous, où l’objet information du périphérique d’un téléphone portable est récupéré, et un nouvel objet (carte de visite) est envoyé dans le répertoire du téléphone.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Afin de fournir le service OBEX Object Push, le serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> doit tourner. Un dossier racine où tous les objets entrant seront stockés doit être créé. Le chemin d’accès par défaut du répertoire racine est <span class=filename>/var/spool/obex</span>. Le serveur OBEX enregistrera automatiquement le service OBEX Object Push auprès du "daemon" SDP local. L’exemple ci-dessous montre comment démarrer le serveur OBEX:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect3><h4 id=_le_profil_port_série_spp>33.4.10. Le profil port série (SPP)<a class=anchor href=#_le_profil_port_série_spp></a></h4><div class=paragraph><p>Le profil port série (SPP) permet aux périphériques Bluetooth® d’émuler un câble série RS232 (ou similaire). Ce profil traite avec les applications classiques en utilisant Bluetooth® comme un câble de remplacement, à travers une abstraction de port série virtuel.</p></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implémente le profil port série. Un pseudo terminal est utilisé comme abstraction de port série virtuel. L’exemple ci-dessous montre comment se connecter à un service port série d’un périphérique distant. Notez que vous n’avez pas besoin d’indiquer un canal RFCOMM - <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> peut l’obtenir auprès du périphérique distant via SDP. Si vous désirez forcer cela, spécifiez un canal RFCOMM sur la ligne de commande.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</span>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</code></pre></div></div><div class=paragraph><p>Une fois connecté, le pseudo-terminal peut être utilisé comme un port série:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l ttyp6</span></code></pre></div></div></div><div class=sect3><h4 id=_dépannage_4>33.4.11. Dépannage<a class=anchor href=#_dépannage_4></a></h4><div class=sect4><h5 id=_un_périphérique_distant_ne_peut_pas_se_connecter>33.4.11.1. Un périphérique distant ne peut pas se connecter<a class=anchor href=#_un_périphérique_distant_ne_peut_pas_se_connecter></a></h5><div class=paragraph><p>Certains anciens périphériques Bluetooth® ne supportent pas de changement de rôle. Par défaut, quand FreeBSD accepte une nouvelle connexion, il tente d’effectuer un changement de rôle et de devenir maître. Les périphériques qui ne supportent pas cela ne seront pas en mesure de se connecter. Notez qu’un changement de rôle est effectué quand une nouvelle connexion est établie, il n’est donc pas possible de demander au périphérique distant s’il supporte le changement de rôle. Il existe une option HCI pour désactiver le changement de rôle au niveau local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div></div><div class=sect4><h5 id=_quelque_chose_ne_va_pas_puis_je_voir_ce_qui_se_passe_exactement>33.4.11.2. Quelque chose ne va pas, puis-je voir ce qui se passe exactement?<a class=anchor href=#_quelque_chose_ne_va_pas_puis_je_voir_ce_qui_se_passe_exactement></a></h5><div class=paragraph><p>Bien sûr. Utilisez le logiciel tierce-partie hcidump qui est disponible sous <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> dans le catalogue des logiciels portés. L’utilitaire hcidump est similaire à <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. Il peut être utilisé pour afficher le contenu des paquets Bluetooth® à l’écran et les sauvegarder dans un fichier.</p></div></div></div></div><div class=sect2><h3 id=network-bridging>33.5. Bridging<a class=anchor href=#network-bridging></a></h3><div class=sect3><h4 id=_introduction_7>33.5.1. Introduction<a class=anchor href=#_introduction_7></a></h4><div class=paragraph><p>Il est parfois utile de diviser un réseau physique (comme un réseau Ethernet) en deux réseaux séparés sans avoir à créer de sous-réseaux IPs et à utiliser un routeur pour connecter ces réseaux entre eux. Le périphérique qui connecte ensemble deux réseaux de cette manière est appelé "bridge"-pont. Un système FreeBSD avec deux cartes réseaux peut faire fonction de pont.</p></div><div class=paragraph><p>Le pont apprend les adresses MAC (adresses Ethernet) des périphériques branchés sur chacune de ses interfaces réseaux. Il transmet le trafic entre deux réseaux uniquement quand la source et la destination sont sur des réseaux différents.</p></div><div class=paragraph><p>Sous de nombreux aspects, un pont ressemble à un switch (commutateur) Ethernet avec très peu de ports.</p></div></div><div class=sect3><h4 id=_situations_où_lutilisation_dun_pont_est_appropriée>33.5.2. Situations où l’utilisation d’un pont est appropriée<a class=anchor href=#_situations_où_lutilisation_dun_pont_est_appropriée></a></h4><div class=paragraph><p>Il existe deux situations dans lesquelles un pont est de nos jours utilisé.</p></div><div class=sect4><h5 id=_trafic_important_sur_un_segment>33.5.2.1. Trafic important sur un segment<a class=anchor href=#_trafic_important_sur_un_segment></a></h5><div class=paragraph><p>La première situation apparaît quand un segment physique d’un réseau est submergé par le trafic, mais vous ne voulez pas, pour différentes raisons, subdiviser le réseau et interconnecter les sous-réseaux à l’aide d’un routeur.</p></div><div class=paragraph><p>Prenons comme exemple un journal où les bureaux de la rédaction et de la production sont sur le même sous-réseau. Les utilisateurs de la rédaction utilisent tous le serveur de fichiers <code>A</code>, et les utilisateurs de la production le serveur <code>B</code>. Un réseau Ethernet est utilisé pour connecter ensemble les utilisateurs, et des surcharges du réseau ralentissent les échanges.</p></div><div class=paragraph><p>Si les utilisateurs de la rédaction peuvent être cantonné sur un segment, et les utilisateurs de la production sur un autre, les deux réseaux pourront être connectés par un pont. Seul le trafic réseau destiné aux interfaces réseaux situées de l'"autre" côté du pont sera transmis à l’autre réseau, réduisant ainsi les congestions sur chaque segment.</p></div></div><div class=sect4><h5 id=_coupe_feu_filtrantrégulant_le_trafic>33.5.2.2. Coupe-feu filtrant/régulant le trafic<a class=anchor href=#_coupe_feu_filtrantrégulant_le_trafic></a></h5><div class=paragraph><p>La deuxième situation est quand un coupe-feu est nécessaire mais sans translation d’adresses (NAT).</p></div><div class=paragraph><p>Un exemple est une compagnie qui est connectée à son fournisseur d’accès internet par l’intermédiaire d’une connexion ISDN ou DSL. Elle dispose de 13 adresses IP routables fournies par le fournisseur d’accès et dispose de 10 PCs sur son réseau. Dans cette situation, utiliser un coupe-feu/routeur est complexe en raison des problèmes de sous-réseaux.</p></div><div class=paragraph><p>Un coupe-feu basé sur un pont peut être configuré et positionné dans le flux juste en aval de leur routeur DSL/ISDN sans aucun problème d’adressage IP.</p></div></div></div><div class=sect3><h4 id=_configuration_dun_pont>33.5.3. Configuration d’un pont<a class=anchor href=#_configuration_dun_pont></a></h4><div class=sect4><h5 id=_choix_des_cartes_réseaux>33.5.3.1. Choix des cartes réseaux<a class=anchor href=#_choix_des_cartes_réseaux></a></h5><div class=paragraph><p>Un pont nécessite au moins deux cartes réseaux pour fonctionner. Malheureusement toutes les cartes réseaux ne supportent pas le mode bridging. Lisez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> pour des détails sur les cartes supportées.</p></div><div class=paragraph><p>Installez et testez les deux cartes réseaux avant de poursuivre.</p></div></div><div class=sect4><h5 id=_modification_de_la_configuration_du_noyau>33.5.3.2. Modification de la configuration du noyau<a class=anchor href=#_modification_de_la_configuration_du_noyau></a></h5><div class=paragraph><p>Pour activer le support nécessaire pour mettre en place un pont ajouter la ligne suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>options BRIDGE</pre></div></div><div class=paragraph><p>à votre fichier de configuration du noyau, et recompilez votre noyau.</p></div></div><div class=sect4><h5 id=_support_du_coupe_feu>33.5.3.3. Support du coupe-feu<a class=anchor href=#_support_du_coupe_feu></a></h5><div class=paragraph><p>Si vous projetez d’utiliser un pont en tant que coupe-feu, vous devrez également ajouter l’option <code>IPFIREWALL</code>. Lisez la <a href=./#firewalls>Firewalls</a> pour des informations générales sur la configuration d’un pont en tant que coupe-feu.</p></div><div class=paragraph><p>Si vous avez besoin de permettre le passage à travers le pont des paquets non-IP (comme ARP), il existe une option du coupe-feu qui doit être activée. Cette option est <code>IPFIREWALL_DEFAULT_TO_ACCEPT</code>. Prennez note que cela modifie le fonctionnement par défaut du coupe-feu, ce dernier acceptera alors tous les paquets. Assurez-vous de savoir ce que ce changement signifie pour votre ensemble de règles de filtrage avant de l’effectuer.</p></div></div><div class=sect4><h5 id=_support_de_la_régulation_du_trafic>33.5.3.4. Support de la régulation du trafic<a class=anchor href=#_support_de_la_régulation_du_trafic></a></h5><div class=paragraph><p>Si vous désirez utiliser le pont comme régulateur de trafic, vous devrez ajouter l’option <code>DUMMYNET</code> à votre fichier de configuration du noyau. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> pour plus d’information.</p></div></div></div><div class=sect3><h4 id=_activer_le_pont>33.5.4. Activer le pont<a class=anchor href=#_activer_le_pont></a></h4><div class=paragraph><p>Ajoutez la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.enable=1</pre></div></div><div class=paragraph><p>au fichier <span class=filename>/etc/sysctl.conf</span> pour activer le pont au démarrage, et la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.config=if1,if2</pre></div></div><div class=paragraph><p>pour activer le mode bridging sur les interfaces spécifiées (remplacez <em>if1</em> et <em>if2</em> par les noms de vos interfaces réseaux). Si vous désirez que les paquets traversant le pont soient filtrés par <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, vous devrez ajouter également la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.ipfw=1</pre></div></div><div class=paragraph><p>Pour les versions antérieures à FreeBSD 5.2-RELEASE, utilisez les lignes suivantes:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge=1
net.link.ether.bridge_cfg=if1,if2
net.link.ether.bridge_ipfw=1</pre></div></div></div><div class=sect3><h4 id=_informations_supplémentaires>33.5.5. Informations supplémentaires<a class=anchor href=#_informations_supplémentaires></a></h4><div class=paragraph><p>Si vous désirez être en mesure de vous connecter au pont par l’intermédiaire de <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, il est correct d’ajouter à l’une des cartes réseaux une adresse IP. Il existe un consensus sur le fait qu’assigner une adresse aux deux cartes est une mauvaise idée.</p></div><div class=paragraph><p>Si vous avez plusieurs ponts sur votre réseau, il ne peut y en avoir plus d’un sur le chemin qui sera emprunté par le trafic entre deux stations de travail. Techniquement, cela signifie qu’il n’y a pas de support pour la gestion du "spanning tree".</p></div><div class=paragraph><p>Un pont peut ajouter des temps de latence lors de l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, et tout particulièrement dans le cas du trafic d’un segment vers un autre.</p></div></div></div><div class=sect2><h3 id=network-diskless>33.6. Système sans disque dur<a class=anchor href=#network-diskless></a></h3><div class=paragraph><p>Une machine FreeBSD peut démarrer via le réseau et fonctionner sans disque dur local, en utilisant des systèmes de fichiers montés à partir d’un serveur NFS. Aucune modification du système n’est nécessaire en dehors des fichiers de configuration standards. Un tel système est facile à mettre en oeuvre comme tous les éléments sont directement disponibles:</p></div><div class=ulist><ul><li><p>Il y a au moins deux méthodes possibles pour charger un noyau via le réseau:</p><div class=ulist><ul><li><p>PXE: l’environnement d’exécution préalable au démarrage d’Intel® (Preboot eXecution Environment) est une sorte de ROM intelligente présente sur certaines cartes réseau ou cartes mère. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> pour plus de détails.</p></li><li><p>Le logiciel porté Etherboot (<a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a>) produit un code stockable dans une ROM pour démarrer des noyaux via le réseau. Le code peut être soit implanté dans une PROM de démarrage sur une carte réseau, soit chargé à partir d’une disquette (ou d’un disque dur local), ou à partir d’un système MS-DOS® en fonctionnement. De nombreuses cartes réseau sont supportées.</p></li></ul></div></li><li><p>Une procédure d’exemple (<span class=filename>/usr/shared/examples/diskless/clone_root</span>) facilite la création et la maintenance du système de fichiers racine de la station de travail sur le serveur. La procédure demandera sûrement quelques modifications mais vous permettra de démarrer rapidement.</p></li><li><p>Des fichiers de démarrage du système existent dans le répertoire <span class=filename>/etc</span> pour détecter et supporter le démarrage d’un système sans disque dur.</p></li><li><p>La pagination, si nécessaire, peut être faite par l’intermédiaire d’un fichier NFS ou sur un disque local.</p></li></ul></div><div class=paragraph><p>Il existe plusieurs façons de configurer des stations de travail sans disque dur. Plusieurs éléments entrent en oeuvre, et la plupart peuvent être ajustés en fonction des besoins locaux. Ce qui suit décrit des variations sur la configuration d’un système complet, mettant en avant le simplicité et la compatibilité avec les procédures standards de démarrage de FreeBSD. Le système décrit présente les caractéristiques suivantes:</p></div><div class=ulist><ul><li><p>Les stations de travail sans disque dur utilisent des systèmes de fichiers <span class=filename>/</span> et <span class=filename>/usr</span> partagés et en lecture seule.</p><div class=paragraph><p>Le système de fichiers racine est une copie d’une racine FreeBSD standard (généralement celle du serveur), avec certains fichiers de configuration remplacés par des versions spécifiques à un fonctionnement sans disque dur, et parfois à la station de travail auxquels ils appartiennent.</p></div><div class=paragraph><p>Les parties de la racine qui doivent être inscriptibles sont remplacées par des systèmes de fichiers <a href="https://man.freebsd.org/cgi/man.cgi?query=mfs&amp;sektion=8&amp;format=html">mfs(8)</a> (FreeBSD 4.X) ou <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> (FreeBSD 5.X). Toute modification sera perdue au redémarrage du système.</p></div></li><li><p>Le noyau est transféré et chargé soit à l’aide d’Etherboot soit de PXE comme certaines situations peuvent exiger l’utilisation de l’une ou l’autre méthode.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Ainsi décrit, le système n’est pas sécurisé. Il devrait se trouver dans une partie protégée du réseau, et les autres machines ne devraient pas lui faire confiance aveuglément.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Toutes les instructions de cette section ont été testées sous FreeBSD 4.9-RELEASE et 5.2.1-RELEASE. Le texte est destiné à l’origine pour une utilisation sous 4.X. Des notes on été insérées aux endroits nécessaires pour indiquer les modifications concernant la branche 5.X.</p></div><div class=sect3><h4 id=_information_de_fond>33.6.1. Information de fond<a class=anchor href=#_information_de_fond></a></h4><div class=paragraph><p>Mettre en place des stations de travail sans disque dur est à la fois relativement simple et enclin aux erreurs. Ces dernières sont parfois difficiles à diagnostiquer pour de nombreuses raisons. Par exemple:</p></div><div class=ulist><ul><li><p>Des options de compilation peuvent donner lieu à des comportements différents à l’exécution.</p></li><li><p>Les messages d’erreurs sont souvent cachés ou totalement absents.</p></li></ul></div><div class=paragraph><p>Dans ce contexte, avoir quelques connaissances des mécanismes sous-jacents impliqués est très utile pour résoudre les problèmes qui peuvent surgir.</p></div><div class=paragraph><p>Plusieurs opérations doivent être effectuées pour un amorçage réussi:</p></div><div class=ulist><ul><li><p>La machine doit obtenir des paramètres de base comme son adresse IP, le nom du fichier exécutable, le nom du serveur, l’emplacement de la racine. Ceci est fait en utilisant le protocole DHCP ou le protocole BOOTP. DHCP est une extension compatible de BOOTP, et utilise les mêmes numéros de ports et son format de paquets basic.</p><div class=paragraph><p>Il est possible de configurer un système pour n’utiliser que BOOTP. Le programme serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> fait partie du système de base de FreeBSD.</p></div><div class=paragraph><p>Cependant, DHCP présente plusieurs avantage sur BOOTP (des fichiers de configuration plus lisibles, la possibilité d’utiliser PXE, plus de nombreux autres avantages n’ayant pas de relation directe avec les systèmes sans disque dur), et nous décrirons principalement une configuration DHCP, avec des exemples équivalent utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> quand cela est possible. L’exemple de configuration utilisera le logiciel ISC DHCP (la version 3.0.1.r12 était installée sur le serveur de test).</p></div></li><li><p>La machine a besoin de transférer un ou plusieurs programmes en mémoire locale. TFTP ou NFS sont utilisés. Le choix entre TFTP et NFS est à de nombreux endroits une option sélectionnée lors de la compilation. Une source d’erreur courante est d’indiquer des noms de fichiers pour le mauvais protocole: TFTP transfère généralement tous les fichiers à partir d’un seul répertoire sur le serveur, et attendra des noms de fichiers relatifs à ce répertoire. NFS a besoin de chemins d’accès absolus.</p></li><li><p>Les éventuels programmes d’amorce intermédiaires et le noyau doivent être initialisés et exécutés. Il existe plusieurs variations à ce niveau:</p><div class=ulist><ul><li><p>PXE chargera <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a>, qui est une version modifiée du chargeur. Le chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) récupérera la plupart des paramètres nécessaires au démarrage du système, et les transmettra au noyau avant de lui abandonner le contrôle du système. Dans ce cas il est possible d’utiliser un noyau <span class=filename>GENERIC</span>.</p></li><li><p>Etherboot, chargera directement le noyau avec moins de préparation. Vous devrez compiler un noyau avec des options particulières.</p><div class=paragraph><p>PXE et Etherboot fonctionnent aussi bien l’un que l’autre avec des systèmes 4.X. Comme le noyau des systèmes 5.X laisse au chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) un peu plus de travail à effectuer, PXE est préféré pour les systèmes 5.X.</p></div><div class=paragraph><p>Si votre BIOS et vos cartes réseau supportent PXE, vous devriez probablement l’utiliser. Cependant, il est toujours possible de démarrer un système 5.X à l’aide d’Etherboot.</p></div></li></ul></div></li><li><p>Et enfin, la machine a besoin d’accéder à ses systèmes de fichiers. NFS est utilisé dans tous les cas.</p></li></ul></div><div class=paragraph><p>Consultez également la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a>.</p></div></div><div class=sect3><h4 id=_configuration_9>33.6.2. Configuration<a class=anchor href=#_configuration_9></a></h4><div class=sect4><h5 id=_configuration_utilisant_isc_dhcp>33.6.2.1. Configuration utilisant ISC DHCP<a class=anchor href=#_configuration_utilisant_isc_dhcp></a></h5><div class=paragraph><p>Le serveur ISC DHCP peut répondre aux requêtes BOOTP et DHCP.</p></div><div class=paragraph><p>Avec la version 4.9, ISC DHCP 3.0 ne fait pas partie du système de base. Vous devrez installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> ou la version pré-compilée correspondante.</p></div><div class=paragraph><p>Une fois ISC DHCP installé, il nécessite un fichier de configuration pour fonctionner (normalement appelé <span class=filename>/usr/local/etc/dhcpd.conf</span>). Voici un exemple commenté, où la machine <code>margaux</code> utilise Etherboot et où la machine <code>corbieres</code> emploie PXE:</p></div><div class="literalblock programlisting"><div class=content><pre>default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name &#34;example.com&#34;;
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <i class=conum data-value=1></i><b>(1)</b>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <i class=conum data-value=2></i><b>(2)</b>
    filename &#34;/data/misc/kernel.diskless&#34;; <i class=conum data-value=3></i><b>(3)</b>
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;; <i class=conum data-value=4></i><b>(4)</b>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename &#34;pxeboot&#34;;
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;;
  }
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Cette option dit à dhcpd d’envoyer le paramètre des déclarations <code>host</code> comme nom de machine pour la machine sans disque dur. Une autre méthode aurait été d’ajouter <code>option host-name margaux</code> à l’intérieur des déclarations <code>host</code>.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>La directive <code>next-server</code> désigne le serveur TFTP ou NFS à utiliser pour télécharger le chargeur ou le noyau (le comportement par défaut étant d’utiliser la même machine que le serveur DHCP).</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>La directive <code>filename</code> précise le fichier que chargera Etherboot ou PXE à la prochaine étape. Il doit être défini en fonction de la méthode de transfert utilisée. Etherboot peut être compilé pour utiliser NFS ou TFTP. Le logiciel porté pour FreeBSD utilisera NFS par défaut. PXE emploie TFTP, c’est pourquoi un chemin d’accès relatif est utilisé ici (cela peut dépendre de la configuration du serveur TFTP, mais devrait être plutôt classique). De plus, PXE charge <span class=filename>pxeboot</span>, et non pas le noyau. Il existe d’autres possibilités intéressantes, comme le chargement de <span class=filename>pxeboot</span> à partir du répertoire <span class=filename>/boot</span> d’un CD-ROM FreeBSD (comme <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> peut charger un noyau <span class=filename>GENERIC</span> cela rend possible l’utilisation de PXE pour démarrer à partir d’un lecteur de CD-ROM distant).</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>L’option <code>root-path</code> définie le chemin d’accès au système de fichiers racine, suivant la notation classique de NFS. En utilisant PXE, il est possible de ne pas préciser l’adresse IP de la machine dès lors que vous n’activez pas l’option BOOTP du noyau. Le serveur NFS sera alors le même que le serveur TFTP.</td></tr></tbody></table></div></div><div class=sect4><h5 id=_configuration_utilisant_bootp>33.6.2.2. Configuration utilisant BOOTP<a class=anchor href=#_configuration_utilisant_bootp></a></h5><div class=paragraph><p>Ce qui suit présente une configuration bootpd équivalente (réduite à un seul client). Elle se trouverait sous <span class=filename>/etc/bootptab</span>.</p></div><div class=paragraph><p>Veuillez noter qu’Etherboot doit être compilé avec l’option <code>NO_DHCP_SUPPORT</code> (qui n’est pas activée par défaut) afin d’utiliser BOOTP et que PXE <em>nécessite</em> DHCP. The seul avantage évident de bootpd est qu’il est disponible dans le système de base.</p></div><div class="literalblock programlisting"><div class=content><pre>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd=&#34;/tftpboot&#34;:\
  :bf=&#34;/kernel.diskless&#34;:\
  :rp=&#34;192.168.4.4:/data/misc/diskless&#34;:

margaux:ha=0123456789ab:tc=.def100</pre></div></div></div><div class=sect4><h5 id=_préparation_dun_programme_de_démarrage_avec_etherboot>33.6.2.3. Préparation d’un programme de démarrage avec Etherboot<a class=anchor href=#_préparation_dun_programme_de_démarrage_avec_etherboot></a></h5><div class=paragraph><p>Le <a href=http://etherboot.sourceforge.net>site Web d’Etherboot</a> propose une <a href=http://etherboot.sourceforge.net/doc/html/userman/t1.html>documentation importante</a> principalement destinée aux systèmes Linux, mais contenant néamoins des informations utiles. Ce qui suit présente comment vous utiliseriez Etherboot sur un système FreeBSD.</p></div><div class=paragraph><p>Vous devez tout d’abord installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a> ou sa version pré-compilée.</p></div><div class=paragraph><p>Vous pouvez modifier la configuration d’Etherboot (i.e. pour utiliser TFTP au lieu de NFS) en éditant le fichier <span class=filename>Config</span> dans le répertoire des sources d’Etherboot.</p></div><div class=paragraph><p>Pour notre configuration nous utiliserons une disquette de démarrage. Pour d’autres méthodes (PROM, ou un programme MS-DOS®), consultez la documentation d’Etherboot.</p></div><div class=paragraph><p>Pour créer une disquette de démarrage, insérez une disquette dans le lecteur de la machine où vous avez installé Etherboot, puis rendez-vous dans le répertoire <span class=filename>src</span> de l’arborescence Etherboot et tapez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmake bin32/devicetype.fd0</span></code></pre></div></div><div class=paragraph><p><em>devicetype</em> dépend du type de carte Ethernet se trouvant dans la station de travail sans disque dur. Référez-vous au fichier <span class=filename>NIC</span> dans le même répertoire pour déterminer la valeur <em>devicetype</em> correcte.</p></div></div><div class=sect4><h5 id=_démarrer_avec_pxe>33.6.2.4. Démarrer avec PXE<a class=anchor href=#_démarrer_avec_pxe></a></h5><div class=paragraph><p>Par défaut le chargeur <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> charge le noyau via NFS. Il peut être compilé pour utiliser TFTP à la place en spécifiant l’option <code>LOADER_TFTP_SUPPORT</code> dans le fichier <span class=filename>/etc/make.conf</span>. Lisez les commentaires dans le fichier <span class=filename>/etc/defaults/make.conf</span> (ou <span class=filename>/usr/shared/examples/etc/make.conf</span> pour les systèmes 5.X) pour plus de détails.</p></div><div class=paragraph><p>Il existe deux autres options de <span class=filename>make.conf</span> non-documentées qui peuvent être utiles pour la configuration d’une machine faisant fonction de console série sans disque dur: <code>BOOT_PXELDR_PROBE_KEYBOARD</code>, et <code>BOOT_PXELDR_ALWAYS_SERIAL</code> (cette dernière n’existe que sous FreeBSD 5.X).</p></div><div class=paragraph><p>Pour utiliser PXE quand la machine démarre, vous aurez normalement besoin de sélectionner l’option <code>Boot from network</code> dans votre BIOS, ou d’appuyer sur une touche de fonction lors de l’initialisation du PC.</p></div></div><div class=sect4><h5 id=_configuration_des_serveurs_tftp_et_nfs>33.6.2.5. Configuration des serveurs TFTP et NFS<a class=anchor href=#_configuration_des_serveurs_tftp_et_nfs></a></h5><div class=paragraph><p>Si vous utilisez PXE ou Etherboot configurés pour employer TFTP, vous devez activer tftpd sur le serveur de fichier:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Créez un répertoire à partir duquel tftpd proposera les fichiers, e.g. <span class=filename>/tftpboot</span>.</p></li><li><p>Ajoutez la ligne suivante à votre fichier <span class=filename>/etc/inetd.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il apparaît que certaines versions de PXE veulent la version TCP de TFTP. Dans ce cas, ajoutez une seconde ligne, en remplaçant <code>dgram udp</code> par <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Demandez à inetd de relire son fichier de configuration:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Le répertoire <span class=filename>tftpboot</span> peut être placé n’importe où sur le serveur. Assurez-vous que son emplacement est défini dans les fichiers <span class=filename>inetd.conf</span> et <span class=filename>dhcpd.conf</span>.</p></div><div class=paragraph><p>Dans tous les cas, vous devez également activer NFS et exporter le système de fichiers approprié sur le serveur NFS.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ajoutez ce qui suit au fichier <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Exportez le système de fichiers contenant le répertoire racine du système sans disque dur en ajoutant ce qui suit au fichier <span class=filename>/etc/exports</span> (ajustez le point de montage et remplacez <em>margaux corbieres</em> avec les noms des stations de travail sans disque dur):</p><div class="literalblock programlisting"><div class=content><pre>/data/misc -alldirs -ro margaux corbieres</pre></div></div></li><li><p>Demandez à mountd de relire son fichier de configuration. Si vous avez eu besoin d’activer NFS dans <span class=filename>/etc/rc.conf</span> lors du premier point, vous voudrez probablement plutot redémarrer la machine.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect4><h5 id=_compilation_dun_noyau_pour_système_sans_disque_dur>33.6.2.6. Compilation d’un noyau pour système sans disque dur<a class=anchor href=#_compilation_dun_noyau_pour_système_sans_disque_dur></a></h5><div class=paragraph><p>Si vous utilisez Etherboot, vous devez créer un fichier de configuration du noyau pour le client sans disque dur avec les options suivantes (en plus des options habituelles):</p></div><div class="literalblock programlisting"><div class=content><pre>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info</pre></div></div><div class=paragraph><p>Vous pouvez vouloir également employer les options <code>BOOTP_NFSV3</code>, <code>BOOT_COMPAT</code> et <code>BOOTP_WIRED_TO</code> (référez-vous au fichier <span class=filename>LINT</span> sous 4.X ou <span class=filename>NOTES</span> sous 5.X).</p></div><div class=paragraph><p>Les noms de ces options sont historiques et légèrement trompeur comme elles activent indifférement l’utilisation de DHCP et BOOTP dans le noyau (il est également possible de forcer une utilisation stricte de BOOTP ou DHCP).</p></div><div class=paragraph><p>Compilez le noyau (voir <a href=./#kernelconfig>Configurer le noyau de FreeBSD</a>), et copiez-le à l’emplacement indiqué dans <span class=filename>dhcpd.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quand on utilise PXE, la compilation d’un noyau avec les options précédentes n’est pas strictement nécessaire (bien que conseillé). Les activer causera un plus grand nombre de requêtes DHCP générées lors du démarrage du noyau, avec un petit risque d’inconsistance entre les nouvelles valeurs et celles récupérées par <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> dans certains cas particuliers. L’avantage de leur utilisation est que le nom de la machine sera forcément défini. Sinon vous devrez définir le nom de la machine par une autre méthode, par exemple dans un fichier <span class=filename>rc.conf</span> particulier au client.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Afin d’être chargeable par Etherboot, un noyau 5.X doit être compilé avec les "device hints". Vous définirez normalement l’option suivante dans le fichier de configuration (voir le fichier de commentaires sur la configuration: <span class=filename>NOTES</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>hints		&#34;GENERIC.hints&#34;</pre></div></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_préparer_le_système_de_fichiers_racine>33.6.2.7. Préparer le système de fichiers racine<a class=anchor href=#_préparer_le_système_de_fichiers_racine></a></h5><div class=paragraph><p>Vous devez créer un système de fichiers racine pour les stations de travail sans disque dur, à l’emplacement défini par <code>root-path</code> dans le fichier <span class=filename>dhcpd.conf</span>. Les sections suivantes décrivent deux manières de le faire.</p></div><div class=sect5><h6 id=_utilisation_de_la_procédure_clone_root>33.6.2.7.1. Utilisation de la procédure <span class=filename>clone_root</span><a class=anchor href=#_utilisation_de_la_procédure_clone_root></a></h6><div class=paragraph><p>C’est la méthode la plus rapide pour créer un système de fichiers racine, mais elle est, pour le moment, uniquement supportée sous FreeBSD 4.X.. Cette procédure est située à l’emplacement <span class=filename>/usr/shared/examples/diskless/clone_root</span> et demande quelques modifications, pour au moins ajuster l’emplacement du système de fichiers à créer (la variable <code>DEST</code>).</p></div><div class=paragraph><p>Référez-vous aux commentaires situés en début de la procédure pour information. Ils expliquent comment le système de fichiers de base est construit, et comment les fichiers peuvent être remplacés de façon sélective par des versions spécifiques à un fonctionnement sans disque dur, ou à un sous-réseau, ou encore à une station de travail particulière. Ils donnent également des exemples de fichiers <span class=filename>/etc/fstab</span> et <span class=filename>/etc/rc.conf</span> pour un fonctionnement sans disque dur.</p></div><div class=paragraph><p>Les fichiers <span class=filename>README</span> dans le répertoire <span class=filename>/usr/shared/examples/diskless</span> contiennent beaucoup d’information de fond, mais, avec les autres exemples du répertoire <span class=filename>diskless</span>, ils documentent une méthode de configuration qui est distincte de celle utilisée par <span class=filename>clone_root</span> et les procédures de démarrage du système de <span class=filename>/etc</span>, ce qui est un peu à l’origine de confusions. Utilisez-les comme référence uniquement, à moins que vous préfériez la méthode qu’ils décrivent, dans quel cas vous devrez modifier les procédures <span class=filename>rc</span>.</p></div></div><div class=sect5><h6 id=_utilisation_de_la_procédure_make_world_standard>33.6.2.7.2. Utilisation de la procédure <code>make world</code> standard<a class=anchor href=#_utilisation_de_la_procédure_make_world_standard></a></h6><div class=paragraph><p>Cette méthode s’applique aussi bien à FreeBSD 4.X qu’à FreeBSD 5.X et installera un système complet (et non pas uniquement le système de fichiers racine) dans le répertoire défini par <code>DESTDIR</code>. Tout ce dont vous avez besoin de faire est d’exécuter la procédure suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make world  make kernel
cd /usr/src/etc; make distribution</pre></div></div><div class=paragraph><p>Une fois cela terminé, vous devrez personaliser vos fichiers <span class=filename>/etc/rc.conf</span> et <span class=filename>/etc/fstab</span> situés dans <code>DESTDIR</code> en fonction de vos besoins.</p></div></div></div><div class=sect4><h5 id=_configuration_de_lespace_de_pagination>33.6.2.8. Configuration de l’espace de pagination<a class=anchor href=#_configuration_de_lespace_de_pagination></a></h5><div class=paragraph><p>Si nécessaire, un fichier de pagination situé sur le serveur peut être utilisé via NFS. Une des méthodes couramment utilisées pour cela n’est plus supportée sous 5.X.</p></div><div class=sect5><h6 id=_pagination_via_nfs_sous_freebsd_4_x>33.6.2.8.1. Pagination via NFS sous FreeBSD 4.X<a class=anchor href=#_pagination_via_nfs_sous_freebsd_4_x></a></h6><div class=paragraph><p>L’emplacement et la taille du fichier de pagination peuvent être spécifiés avec les options BOOTP/DHCP 128 et 129 spécifiques à FreeBSD. Des exemples de fichiers de configuration pour ISC DHCP 3.0 ou bootpd suivent:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ajoutez les lignes suivantes au fichier <span class=filename>dhcpd.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre># Global section
option swap-path code 128 = string;
option swap-size code 129 = integer 32;

host margaux {
  ... # Standard lines, see above
  option swap-path &#34;192.168.4.4:/netswapvolume/netswap&#34;;
  option swap-size 64000;
}</pre></div></div><div class=paragraph><p><code>swap-path</code> est le chemin d’accès vers un répertoire où les fichiers de pagination sont situés. Chaque fichier sera nommé <span class=filename>swap.ip-client</span>.</p></div><div class=paragraph><p>Les anciennes version de dhcpd utilisaient une syntaxe du type <code>option option-128 "…​</code>, qui n’est plus supportée.</p></div><div class=paragraph><p><span class=filename>/etc/bootptab</span> utiliserait la syntaxe suivante à la place:</p></div><div class="literalblock programlisting"><div class=content><pre>T128=&#34;192.168.4.4:/netswapvolume/netswap&#34;:T129=0000fa00</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans le fichier <span class=filename>/etc/bootptab</span>, la taille de l’espace de pagination doit être exprimée en hexadécimal.</p></div></td></tr></tbody></table></div></li><li><p>Sur le serveur du fichier de pagination par NFS, créez le(s) fichier(s) de pagination:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /netswapvolume/netswap</span>
<span class=c># cd /netswapvolume/netswap</span>
<span class=c># dd if=/dev/zero bs=1024 count=64000 of=swap.192.168.4.6</span>
<span class=c># chmod 0600 swap.192.168.4.6</span></code></pre></div></div><div class=paragraph><p><em>192.168.4.6</em> est l’adresse IP du client sans disque dur.</p></div></li><li><p>Sur le serveur du fichier de pagination par NFS, ajoutez la ligne suivante au fichier <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/netswapvolume  -maproot=0:10 -alldirs margaux corbieres</pre></div></div><div class=paragraph><p>Ensuite demandez à mountd à relire le fichier <span class=filename>exports</span>, comme plus haut.</p></div></li></ol></div></div></div></div><div class=sect5><h6 id=_pagination_via_nfs_sous_freebsd_5_x>33.6.2.8.2. Pagination via NFS sous FreeBSD 5.X<a class=anchor href=#_pagination_via_nfs_sous_freebsd_5_x></a></h6><div class=paragraph><p>Le noyau ne supporte pas l’activation de la pagination par NFS au démarrage. L’espace de pagination doit être activé par les procédures de démarrage, en montant un système de fichiers accessible en écriture et en créant et en activant un fichier de pagination. Pour créer un fichier de pagination de la taille appropriée, vous pouvez effectuer ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</span></code></pre></div></div><div class=paragraph><p>Pour ensuite l’activer, vous devez ajouter la ligne suivante à votre fichier <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>swapfile=/path/to/swapfile</pre></div></div></div></div><div class=sect4><h5 id=_problèmes_divers>33.6.2.9. Problèmes divers<a class=anchor href=#_problèmes_divers></a></h5><div class=sect5><h6 id=_utilisation_dun_usr_en_lecture_seule>33.6.2.9.1. Utilisation d’un <span class=filename>/usr</span> en lecture seule<a class=anchor href=#_utilisation_dun_usr_en_lecture_seule></a></h6><div class=paragraph><p>Si la station de travail sans disque dur est configurée pour exécuter X, you devrez ajuster le fichier de configuration de XDM, qui envoie le journal d’erreurs sur <span class=filename>/usr</span> par défaut.</p></div></div><div class=sect5><h6 id=_utilisation_dun_serveur_non_freebsd>33.6.2.9.2. Utilisation d’un serveur non-FreeBSD<a class=anchor href=#_utilisation_dun_serveur_non_freebsd></a></h6><div class=paragraph><p>Quand le serveur pour le système de fichiers racine ne fait pas tourner FreeBSD, vous devrez créer le système de fichiers racine sur une machine FreeBSD, puis le copier vers sa destination en utilisant <code>tar</code> ou <code>cpio</code>.</p></div><div class=paragraph><p>Dans cette situation, il y a parfois des problèmes avec les fichiers spéciaux de périphériques dans <span class=filename>/dev</span>, en raison de différences de taille sur les entiers. Une solution à ce problème est d’exporter un répertoire à partir du serveur non-FreeBSD, de monter ce répertoire sur une machine FreeBSD, et exécuter <code>MAKEDEV</code> sur la machine FreeBSD pour créer les entrées de périphériques correctes (FreeBSD 5.X et les versions suivantes utilisent <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> pour l’allocation des fichiers spéciaux de périphériques de manière transparente pour l’utilisateur, exécuter <code>MAKEDEV</code> sur ces versions est inutile).</p></div></div></div></div></div><div class=sect2><h3 id=network-isdn>33.7. ISDN<a class=anchor href=#network-isdn></a></h3><div class=paragraph><p>Une bonne source d’information sur la technologie et le matériel ISDN (RNIS) est <a href=http://www.alumni.caltech.edu/~dank/isdn/>la page ISDN de Dan Kegel</a>.</p></div><div class=paragraph><p>Voici un rapide aperçu à propos de l’ISDN:</p></div><div class=ulist><ul><li><p>Si vous résidez en Europe, vous devriez étudier la section sur les cartes ISDN.</p></li><li><p>Si vous envisagez d’utiliser l’ISDN avant tout pour vous connecter à l’Internet par l’intermédiaire d’un fournisseur d’accès Internet et d’une ligne téléphonique non dédiée, vous devriez vous intéresser aux Adaptateurs Terminaux. C’est la solution la plus souple, qui vous posera le moins de problèmes si vous changez de fournisseur d’accès.</p></li><li><p>Si vous interconnectez deux réseaux locaux, ou si vous vous connectez à l’Internet avec une liaison ISDN dédiée, vous devriez envisager un pont/routeur autonome.</p></li></ul></div><div class=paragraph><p>Le coût est un facteur déterminant de la solution que vous choisirez. Les options suivantes sont listées de la moins chère à la plus chère.</p></div><div class=sect3><h4 id=network-isdn-cards>33.7.1. Cartes ISDN<a class=anchor href=#network-isdn-cards></a></h4><div class=paragraph><p>L’implémentation ISDN de FreeBSD ne supporte que la norme DSS1/Q.931 (ou Euro-ISDN) utilisant des cartes passives. Depuis FreeBSD 4.4, quelques cartes actives sont supportées où le firmware supporte également d’autres protocoles au niveau des signaux, cela inclut les premières cartes supportées du type "Primary Rate ISDN" (PRI).</p></div><div class=paragraph><p>Le logiciel isdn4bsd vous permet de vous connecter à d’autres routeurs ISDN soit en utilisant l’IP sur de l’HDLC de base, soit en utilisant PPP synchrone: en employant PPP intégré au noyau avec <code>isppp</code>, une version modifiée du pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=sppp&amp;sektion=4&amp;format=html">sppp(4)</a>, ou en employant <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> en mode utilisateur. L’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> en mode utilisateur rend possible l’agrégation de deux ou plus canaux ISDN de type B. Une application capable de répondre aux appels téléphoniques est également disponible, tout comme de nombreux utilitaires comme un modem logiciel 300 bauds.</p></div><div class=paragraph><p>Un nombre croissant de cartes ISDN pour PC sont supportées sous FreeBSD et les retours montrent qu’elles sont utilisées avec succès dans toute l’Europe et dans de nombreuses autres parties du monde.</p></div><div class=paragraph><p>Les cartes ISDN passives supportées sont principalement celles avec le circuit ISDN ISAC/HSCX/IPAC d’Infineon (précédemment Siemens), mais également les cartes avec des circuits en provenance de Cologne Chip (cartes ISA uniquement), les cartes PCI avec les circuits Winbond W6692, quelques cartes avec les circuits Tiger300/320/ISAC et quelques cartes avec des circuits spécifiques comme l’AVM Fritz!Card PCI V.1.0 de l’AVM Fritz!Card PnP.</p></div><div class=paragraph><p>Actuellement les cartes ISDN actives supportées sont les cartes AVM B1 (ISA et PCI) BRI et les cartes PCI AVM T1 PRI.</p></div><div class=paragraph><p>Pour de la documentation sur isdn4bsd, consultez le répertoire <span class=filename>/usr/shared/examples/isdn/</span> sur votre système FreeBSD ou sur la <a href=http://www.freebsd-support.de/i4b/>page web d’isdn4bsd</a> qui propose également des astuces, des erratas et bien plus de documentation que le <a href=http://people.FreeBSD.org/~hm/>manuel d’isdn4bsd</a>.</p></div><div class=paragraph><p>Au cas où vous seriez intéressé par l’ajout du support pour un protocole ISDN différent, d’une carte ISDN pour PC non encore supportée ou par l’amélioration d’isdn4bsd, veuillez contacter Hellmuth Michaelis &lt;<a href=mailto:hm@FreeBSD.org>hm@FreeBSD.org</a>>.</p></div><div class=paragraph><p>Pour les questions concernant l’installation, la configuration et le dépannage d’isdn4bsd, une liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a> est disponible.</p></div></div><div class=sect3><h4 id=_adaptateurs_terminaux_isdn>33.7.2. Adaptateurs terminaux ISDN<a class=anchor href=#_adaptateurs_terminaux_isdn></a></h4><div class=paragraph><p>Les adaptateurs terminaux-"Terminal adapters (TA)"; sont l’équivalent ISDN des modems pour les lignes téléphoniques ordinaires.</p></div><div class=paragraph><p>La plupart des TA utilisent le jeu de commandes standard des modems Hayes, et peuvent être utilisés en remplacement d’un modem.</p></div><div class=paragraph><p>Un TA fonctionne essentiellement de la même manière qu’un modem à la différence que la vitesse de la connexion sera plus élevée qu’avec votre vieux modem. Vous devrez configurer <a href=./#ppp>PPP</a> de façon exactement identique que pour un modem classique. Assurez-vous de fixer la vitesse de votre port série la plus haute possible.</p></div><div class=paragraph><p>Le principal avantage d’utiliser un TA pour vous connecter à votre fournisseur d’accès Internet est de pouvoir utiliser PPP en mode dynamic. Comme l’espace d’adressage IP disponible devient de plus en plus restreint, la plupart des fournisseurs d’accès ne désirent plus vous fournir d’adresse IP statique. La plupart des routeurs autonomes ne peuvent pas fonctionner avec une allocation dynamique d’adresse IP.</p></div><div class=paragraph><p>Les fonctionnalités et la stabilité de la connexion des adaptateurs terminaux reposent complètement sur le "daemon" PPP. Cela vous permet de passer facilement d’un modem classique à l’ISDN sur une machine FreeBSD, si vous avez déjà configuré PPP. Cependant, les problèmes que vous avez éventuellement rencontrés avec PPP persisteront.</p></div><div class=paragraph><p>Si vous désirez un maximum de stabilité, utilisez <a href=./#ppp>PPP intégré au noyau</a>, à la place du <a href=./#userppp>PPP en mode utilisateur</a>.</p></div><div class=paragraph><p>Les adaptateurs suivants sont connus pour fonctionner avec FreeBSD:</p></div><div class=ulist><ul><li><p>Motorola BitSurfer et Bitsurfer Pro</p></li><li><p>Adtran</p></li></ul></div><div class=paragraph><p>La plupart des adaptateurs terminaux fonctionneront probablement également, les fabricants de TA font en sorte que leurs produits acceptent la plupart du jeu de commandes AT des modems.</p></div><div class=paragraph><p>Le vrai problème avec les adaptateurs terminaux est que comme pour les modems, il vous faudra une bonne interface série dans votre ordinateur.</p></div><div class=paragraph><p>Vous devriez lire le document sur <a href=https://docs.freebsd.org/en/articles/serial-uart/>les ports série sous FreeBSD</a> pour comprendre en détail le fonctionnement des périphériques série et les différences entre les ports séries asynchrones et synchrones.</p></div><div class=paragraph><p>Un adaptateur terminal sur un port série PC standard (asynchrone) vous limite à 115.2 Kbs, même si vous disposez d’une connexion à 128 Kbs. Pour utiliser complètement les 128 Kbs offert par l’ISDN, vous devez brancher l’adaptateur sur une carte série synchrone.</p></div><div class=paragraph><p>Ne vous imaginez pas qu’il suffit d’acheter un adaptateur terminal interne pour s’affranchir du problème synchrone/asynchrone. Les adaptateurs internes disposent simplement d’un port série PC standard. Tout ce que vous y gagnerez sera d’économiser un câble série et de libérer une prise électrique.</p></div><div class=paragraph><p>Une carte synchrone avec un adaptateur terminal est au moins aussi rapide qu’un routeur autonome, piloté par une simple machine FreeBSD, et probablement plus souple.</p></div><div class=paragraph><p>Le choix entre carte synchrone/adaptateur ou routeur autonome est une question de goût. Ce sujet a été abordé dans les listes de diffusion. Nous vous suggérons de chercher dans les <a href=https://www.FreeBSD.org/search/>archives</a> pour obtenir l’intégralité de la discussion.</p></div></div><div class=sect3><h4 id=_pontsrouteurs_isdn_autonomes>33.7.3. Ponts/Routeurs ISDN autonomes<a class=anchor href=#_pontsrouteurs_isdn_autonomes></a></h4><div class=paragraph><p>Les ponts ou routeurs ISDN ne sont pas spécifiques à FreeBSD ou à tout autre système d’exploitation. Pour une description complète de la technologie du routage et des ponts, veuillez vous reportez à un ouvrage de référence sur les réseaux.</p></div><div class=paragraph><p>Dans le contexte de cette section, les termes de routeur et de pont seront utilisés indifféremment.</p></div><div class=paragraph><p>Comme le prix des routeurs/ponts ISDN d’entrée de gamme baissent, il est probable qu’ils deviennent un choix de plus en plus populaire. Un routeur ISDN est une petite boîte qui se branche directement sur votre réseau Ethernet, et gère sa propre connexion aux autres ponts/routeurs. Il intègre le logiciel nécessaire au support du protocole PPP et d’autres protocoles.</p></div><div class=paragraph><p>Un routeur vous offrira un débit plus élevé qu’un adaptateur terminal standard, puisqu’il utilisera une connexion ISDN synchrone.</p></div><div class=paragraph><p>Le principal problème avec les routeurs et ponts ISDN est que l’intéropérabilité entre les matériels des différents constructeurs n’est pas toujours garantie. Si vous projetez de vous connecter à un fournisseur d’accès Internet, vous devriez discuter de vos besoins avec ce dernier.</p></div><div class=paragraph><p>Si vous envisagez de connecter ensemble deux réseaux locaux, comme le réseau de votre domicile et celui de votre bureau, c’est la solution la plus simple et celle qui demande le moins de maintenance. Etant donné que vous êtes la personne qui achète les équipements pour les deux extrémités, vous êtes sûr que cela fonctionnera.</p></div><div class=paragraph><p>Par exemple pour connecter un ordinateur personnel situé à son domicile ou le réseau d’une agence à celui du siège social, la configuration suivante pourra être utilisée:</p></div><div class=exampleblock><div class=title>Exemple 42. Réseau d’agence ou à domicile</div><div class=content><div class=paragraph><p>Le réseau utilise une topologie en bus avec une connectique Ethernet 10 base 2 ("thinnet"). Connectez le routeur au réseau à l’aide d’un émetteur/récepteur AUI/10BT si nécessaire.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-bus.png alt="Ethernet 10 Base 2"></div></div><div class=paragraph><p>Si votre réseau de domicile/d’agence n’est constitué que d’un seul ordinateur, vous pouvez utiliser une paire torsadée croisée pour le connecter directement au routeur autonome.</p></div></div></div><div class=exampleblock><div class=title>Exemple 43. Siège social ou autre réseau</div><div class=content><div class=paragraph><p>Le réseau utilise une topologie en étoile avec une connectique Ethernet 10 base T ("paire torsadée").</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-twisted-pair.png alt="Architecture du Réseau ISDN"></div></div></div></div><div class=paragraph><p>Un des principaux avantages de la plupart des routeurs/ponts est le fait qu’ils permettent d’avoir deux connexions PPP <em>séparées et indépendantes</em> vers deux sites différents et cela en <em>même</em> temps. Ceci n’est pas supporté par la plupart des adaptateurs terminaux, en dehors de modèles spécifiques (en général coûteux) qui disposent de deux ports série. Ne confondez pas cette possibilité avec l’agrégation de canaux, MPP, etc.</p></div><div class=paragraph><p>Ceci peut être une fonctionnalité très utile si, par exemple, vous disposez d’une connexion ISDN dédiée au bureau et vous voudriez en profiter mais vous ne voulez pas acquérir une nouvelle ligne ISDN. Un routeur au bureau peut gérer un canal B dédié (64 Kbps) vers l’Internet et utiliser l’autre canal B pour une autre connexion. Le deuxième canal B peut être utilisé pour les connexions entrantes, sortantes ou pour l’agrégation de canaux (MPP, etc.) avec le premier canal B pour augmenter la bande passante.</p></div><div class=paragraph><p>Un pont Ethernet vous permettra de transmettre autre chose que juste du trafic IP. Vous pouvez également faire passer de l’IPX/SPX ou tout autre protocole que vous utilisez.</p></div></div></div><div class=sect2><h3 id=network-natd>33.8. Translation d’adresses<a class=anchor href=#network-natd></a></h3><div class=sect3><h4 id=network-natoverview>33.8.1. Généralités<a class=anchor href=#network-natoverview></a></h4><div class=paragraph><p>Le "daemon" de translation d’adresses ("Network Address Translation"-NAT) de FreeBSD, généralement connu sous le nom de <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> est un "daemon" qui accepte les paquets IP entrants, change l’adresse de la source par celle de la machine locale et ré-injecte les paquets dans le flux sortant des paquets IP. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> effectue cela en changeant l’adresse IP et le port source de sorte quand les données réponse arrivent il soit en mesure de déterminer la provenance des données d’origine et les transférer à l’émetteur original.</p></div><div class=paragraph><p>L’utilisation classique de NAT est le partage de connexion Internet.</p></div></div><div class=sect3><h4 id=network-natsetup>33.8.2. Architecture du réseau<a class=anchor href=#network-natsetup></a></h4><div class=paragraph><p>En raison de la diminution du nombre d’adresses IP libres sous IPv4, et de l’augmentation du nombre d’utilisateurs de lignes haut-débit comme le câble ou l’ADSL, le besoin d’utiliser une solution de partage de connexion est donc en constante augmentation. La possibilité de connecter plusieurs ordinateurs par l’intermédiaire d’une connexion et d’une adresse IP fait de <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> une solution de choix.</p></div><div class=paragraph><p>Plus généralement, un utilisateur dispose d’une machine connecté sur la câble ou une ligne ADSL avec une adresse IP et désire utiliser cet ordinateur connecté pour fournir un accès Internet à d’autres machines du réseau local.</p></div><div class=paragraph><p>Pour cela, la machine FreeBSD sur Internet doit jouer le rôle de passerelle. Cette machine passerelle doit avoir deux cartes réseaux-l’une pour se connecter au routeur Internet, l’autre est connectée au réseau local. Toutes les machines du réseau local sont connectées par l’intermédiaire d’un hub ou d’un switch.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il existe plusieurs manières pour connecter un réseau local à l’Internet à travers une passerelle FreeBSD. Cet exemple n’abordera que le cas d’une passerelle avec au moins deux cartes réseaux.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/natd.png alt="Organisation du réseau"></div></div><div class=paragraph><p>Une telle configuration est communément utilisée pour partager une connexion Internet. Une des machines du réseau local est connectée à Internet. Le reste des machines accède à Internet par l’intermédiaire de cette machine "passerelle".</p></div></div><div class=sect3><h4 id=network-natdkernconfiguration>33.8.3. Configuration<a class=anchor href=#network-natdkernconfiguration></a></h4><div class=paragraph><p>Les options suivantes doivent être présentes dans le fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL
options IPDIVERT</pre></div></div><div class=paragraph><p>De plus, les options suivantes peuvent également être utiles:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</pre></div></div><div class=paragraph><p>Ce qui suit doit figurer dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34; <i class=conum data-value=1></i><b>(1)</b>
firewall_enable=&#34;YES&#34; <i class=conum data-value=2></i><b>(2)</b>
firewall_type=&#34;OPEN&#34; <i class=conum data-value=3></i><b>(3)</b>
natd_enable=&#34;YES&#34;
natd_interface=&#34;fxp0&#34; <i class=conum data-value=4></i><b>(4)</b>
natd_flags=&#34;&#34; <i class=conum data-value=5></i><b>(5)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Configure la machine comme passerelle. Exécuter <code>sysctl net.inet.ip.forwarding=1</code> aurait le même effet.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Active au démarrage les règles du coupe-feu se trouvant dans le fichier <span class=filename>/etc/rc.firewall</span>.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Cela spécifie un ensemble de règles prédéfinies pour le coupe-feu qui autorise tous les paquets entrant. Consultez le fichier <span class=filename>/etc/rc.firewall</span> pour d’autres ensembles de régles.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Indique à travers quelle interface transférer les paquets (l’interface connectée à l’Internet).</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Toutes options de configuration supplémentaires passées à <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> au démarrage.</td></tr></tbody></table></div><div class=paragraph><p>Le fait d’avoir les options précédentes définies dans le fichier <span class=filename>/etc/rc.conf</span> lancera la commande <span class=filename>/etc/rc.conf</span> au démarrage. Cette commande peut être également exécutée à la main.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il est également possible d’utiliser un fichier de configuration pour <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> quand il y a trop d’options à passer. Dans ce cas, le fichier de configuration doit être défini en ajoutant la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class=paragraph><p>Le fichier <span class=filename>/etc/natd.conf</span> contiendra une liste d’options de configuration, une par ligne. Par exemple le cas de figure de la section suivante utiliserait le fichier suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Pour plus d’information concernant le fichier de configuration, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> au sujet de l’option <code>-f</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A chaque machine et interface derrière le réseau local doit être assigné une adresse IP de l’espace d’adresses privées comme défini par la <a href=ftp://ftp.isi.edu/in-notes/rfc1918.txt>RFC 1918</a> et doit disposer d’une passerelle par défaut qui est l’adresse IP interne de la machine <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>.</p></div><div class=paragraph><p>Par exemple, les clients <code>A</code> et <code>B</code> du réseau local ont les adresses IP <code>192.168.0.2</code> et <code>192.168.0.3</code>, tandis que l’interface sur le réseau local de la machine natd a pour adresse IP <code>192.168.0.1</code>. La passerelle par défaut des clients <code>A</code> et <code>B</code> doit être l’adresse <code>192.168.0.1</code> de la machine natd. L’interface externe ou Internet de cette dernière ne demande aucune modification spécifique pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> puisse fonctionner.</p></div></div><div class=sect3><h4 id=network-natdport-redirection>33.8.4. Redirection de ports<a class=anchor href=#network-natdport-redirection></a></h4><div class=paragraph><p>L’inconvénient avec <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> est que les clients du réseau local ne sont pas accessibles depuis l’Internet. Les clients sur le réseau local peuvent établir des connexions sortantes vers le monde extérieur mais ne peuvent recevoir de connexions entrantes. Cela présente un problème si l’on tente de faire tourner des services Internet sur une des machines du réseau local. Une solution simple à ce problème est de rediriger les ports Internet sélectionnés de la machine natd vers le client sur le réseau local.</p></div><div class=paragraph><p>Par exemple, un serveur IRC tourne sur le client <code>A</code>, et un serveur web sur le client <code>B</code>. Pour que cela fonctionne correctement, les connections reçues sur les ports 6667 (IRC) et 80 (web) doivent être redirigées vers les machines correspondantes.</p></div><div class=paragraph><p>L’option <code>-redirect_port</code> doit être passée à <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> avec les autres options adéquates. La syntaxe est la suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>Dans l’exemple précédent, l’argument passé à la commande devrait être:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_port tcp 192.168.0.2:6667 6667
-redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Cela va rediriger les ports <em>tcp</em> voulus vers les machines du réseau local.</p></div><div class=paragraph><p>L’option <code>-redirect_port</code> peut être utilisée pour indiquer une plage de ports plutôt que des ports individuels. Par exemple <em>tcp 192.168.0.2:2000-3000 2000-3000</em> redirigerait toutes les connexions reçues sur les ports 2000 à 3000 vers les ports 2000 à 3000 du client <code>A</code>.</p></div><div class=paragraph><p>Ces options peuvent être utilisées quand on exécute directement <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, placées dans l’option <code>natd_flags=""</code> du fichier <span class=filename>/etc/rc.conf</span>, ou passées par l’intermédiaire d’un fichier de configuration.</p></div><div class=paragraph><p>Pour plus d’éléments et d’options de configuration consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a></p></div></div><div class=sect3><h4 id=network-natdaddress-redirection>33.8.5. Redirection d’adresses<a class=anchor href=#network-natdaddress-redirection></a></h4><div class=paragraph><p>La redirection d’adresses est utile si plusieurs adresses IP sont disponibles mais doivent se trouver sur une seule machine. Avec cela, <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> peut assigner à chaque client du réseau local sa propre adresse IP externe. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> récrit alors les paquets sortant des clients du réseau local avec l’adresse IP externe correcte et redirige tout le trafic entrant sur une adresse IP particulière vers la machine du réseau local correspondante. Ce principe est également connu sous le nom de translation d’adresses statique. Par exemple, les adresses IP <code>128.1.1.1</code>, <code>128.1.1.2</code>, et <code>128.1.1.3</code> appartiennent à la passerelle natd. L’adresse <code>128.1.1.1</code> peut être utilisée comme adresse IP externe de la passerelle natd, tandis que <code>128.1.1.2</code> et <code>128.1.1.3</code> sont redirigées vers les machines <code>A</code> et <code>B</code> du réseau local.</p></div><div class=paragraph><p>La syntaxe de l’option <code>-redirect_address</code> est la suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address localIP publicIP</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>localIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’adresse IP interne du client sur le réseau local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>publicIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’adresse IP externe correspondant au client sur le réseau local.</p></td></tr></tbody></table><div class=paragraph><p>Dans l’exemple, les arguments passés à la commande seraient:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Comme pour l’option <code>-redirect_port</code>, ces options peuvent être placées dans l’option <code>natd_flags=""</code> du fichier <span class=filename>/etc/rc.conf</span>, ou passées par l’intermédiaire d’un fichier de configuration. Avec la redirection d’adresse, il n’y a pas besoin de redirection de ports puisque toutes les données reçues sur une IP particulière sont redirigées.</p></div><div class=paragraph><p>Les adresses IP sur la machine natd doivent être active et pointer sur l’interface externe. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> pour cela.</p></div></div></div><div class=sect2><h3 id=network-plip>33.9. IP sur liaison parallèle (PLIP)<a class=anchor href=#network-plip></a></h3><div class=paragraph><p>PLIP nous permet d’utiliser le protocole TCP/IP entre ports parallèles. C’est utile sur des machines sans cartes réseaux, ou pour effectuer une installation sur ordinateur portable. Dans cette section nous aborderons:</p></div><div class=ulist><ul><li><p>La fabrication d’un câble parallèle ("laplink").</p></li><li><p>La connexion de deux ordinateurs via PLIP.</p></li></ul></div><div class=sect3><h4 id=network-create-parallel-cable>33.9.1. Fabriquer un câble parallèle<a class=anchor href=#network-create-parallel-cable></a></h4><div class=paragraph><p>Vous pouvez acheter un câble parallèle auprès de la plupart des vendeurs de matériel informatique. Si ce n’est pas le cas, ou désirez savoir comment est fait un tel câble, le tableau suivant montre comment en faire un à partir d’un câble parallèle d’imprimante.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 8. Câblage d’un câble parallèle pour réseau</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">A-name</th><th class="tableblock halign-left valign-top">A-End</th><th class="tableblock halign-left valign-top">B-End</th><th class="tableblock halign-left valign-top">Descr.</th><th class="tableblock halign-left valign-top">Post/Bit</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA0
-ERROR
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
2
15
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
15
2
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x01
1/0x08
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA1
+SLCT
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
3
13
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
13
3
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x02
1/0x10
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA2
+PE
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
4
12
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
12
4
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x04
1/0x20
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA3
-ACK
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
5
10
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
10
5
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Strobe</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x08
1/0x40
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA4
BUSY
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
6
11
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
11
6
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x10
1/0x80
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>GND</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>GND</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>-</pre></div></td></tr></tbody></table></div><div class=sect3><h4 id=network-plip-setup>33.9.2. Configurer PLIP<a class=anchor href=#network-plip-setup></a></h4><div class=paragraph><p>Tout d’abord procurez-vous un câble "laplink". Vérifiez ensuite que les deux ordinateurs disposent d’un noyau avec le support pour le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep lp /var/run/dmesg.boot</span>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</code></pre></div></div><div class=paragraph><p>Le port parallèle doit fonctionner sous interruption, sous FreeBSD 4.X vous devriez avoir une ligne semblable à la ligne suivante dans le fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device ppc0 at isa? irq 7</pre></div></div><div class=paragraph><p>Sous FreeBSD 5.X, le fichier <span class=filename>/boot/device.hints</span> devrait contenir les lignes suivantes:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.at=&#34;isa&#34;
hint.ppc.0.irq=&#34;7&#34;</pre></div></div><div class=paragraph><p>Ensuite vérifiez si le fichier de configuration du noyau contient une ligne <code>device plip</code> ou si le module <span class=filename>plip.ko</span> est chargé. Dans les deux cas l’interface réseau parallèle devrait apparaître quand vous utilisez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>Branchez le câble "laplink" sur les interfaces parallèles des deux ordinateurs.</p></div><div class=paragraph><p>Configurez les paramètres de l’interface réseau des deux côtés en tant que <code>root</code>. Par exemple, si vous voulez connecter la machine <code>host1</code> avec la machine <code>host2</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>                 host1 ----- host2
IP Address    10.0.0.1      10.0.0.2</pre></div></div><div class=paragraph><p>Configurez l’interface sur <code>host1</code> en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.1 10.0.0.2</span></code></pre></div></div><div class=paragraph><p>Configurez l’interface sur <code>host2</code> en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.2 10.0.0.1</span></code></pre></div></div><div class=paragraph><p>Vous devriez avoir maintenant une connexion qui fonctionne. Veuillez consulter les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=lp&amp;sektion=4&amp;format=html">lp(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> pour plus de détails.</p></div><div class=paragraph><p>Vous devriez également ajouter les deux noms de machines dans le fichier <span class=filename>/etc/hosts</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</pre></div></div><div class=paragraph><p>Pour vérifier le bon fonctionnement de la connexion, aller sur les deux machines et effectuez un "ping" vers l’autre machine. Par exemple, sur <code>host1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class=nt>--</span><span class=o>&gt;</span> 10.0.0.2 netmask 0xff000000
<span class=c># netstat -r</span>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       plip0
<span class=c># ping -c 4 host2</span>
PING host2 <span class=o>(</span>10.0.0.2<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.774 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.530 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.556 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.714 ms

<span class=nt>---</span> host2 ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 2.530/2.643/2.774/0.103 ms</code></pre></div></div></div></div><div class=sect2><h3 id=network-ipv6>33.10. IPv6<a class=anchor href=#network-ipv6></a></h3><div class=paragraph><p>L’IPv6 (également connu sous le nom de IPng "IP nouvelle génération") est la nouvelle version du très célèbre protocole IP (aussi connu sous le nom d’IPv4). Comme les autres systèmes BSD, FreeBSD utilise l’implémentation IPv6 KAME. Votre système FreeBSD est donc fourni avec tout ce dont vous aurez besoin pour tester l’IPv6. Cette section se concentre sur la configuration et l’utilisation d’IPv6.</p></div><div class=paragraph><p>Au début des années 90, on a pris conscience de la diminution rapide de l’espace d’adresses IPv4. Etant donné le taux d’expansion de l’Internet, deux problèmes majeurs apparaissaient:</p></div><div class=ulist><ul><li><p>Le manque d’adresses. Aujourd’hui ce n’est plus vraiment un problème puisque les espaces d’adresses privées RFC1918 (<code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, et <code>192.168.0.0/16</code>) et la translation d’adresses (NAT) sont utilisés.</p></li><li><p>Les tables des routeurs devenaient trop importantes. C’est toujours un problème actuellement.</p></li></ul></div><div class=paragraph><p>L’IPv6 remédie à ces problèmes et à de nombreux autres:</p></div><div class=ulist><ul><li><p>Espace d’adressage sur 128 bits. Ou plus précisément, il y a 340 282 366 920 938 463 463 374 607 431 768 211 456 adresses disponibles. Cela équivaut à approximativement 6.67 * 10^27 adresses IPv6 par kilomètre-carré de surface de notre planète.</p></li><li><p>Les routeurs ne stockeront que des regroupements d’adresses dans leurs tables de routage réduisant donc l’espace moyen d’une table de routage à 8192 entrées.</p></li></ul></div><div class=paragraph><p>IPv6 présente également de nombreuses autres intéressantes fonctionnalités telles que:</p></div><div class=ulist><ul><li><p>L’autoconfiguration des adresses (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>)</p></li><li><p>Adresses unicast ("une parmi plusieurs")</p></li><li><p>Adresses multicast (multidestinataires) obligatoires</p></li><li><p>IPsec (protocole de sécurité IP)</p></li><li><p>Struture d’entête simplifiée</p></li><li><p>IP mobile</p></li><li><p>Mécanismes de transition IPv6-vers-IPv4</p></li></ul></div><div class=paragraph><p>Pour plus d’informations consultez les références suivantes:</p></div><div class=ulist><ul><li><p>Généralités sur l’IPv6 à <a href=http://playground.sun.com/pub/ipng/html/ipng-main.html>playground.sun.com</a></p></li><li><p><a href=http://www.kame.net>KAME.net</a></p></li><li><p><a href=http://www.6bone.net>6bone.net</a></p></li></ul></div><div class=sect3><h4 id=_les_adresses_ipv6>33.10.1. Les adresses IPv6<a class=anchor href=#_les_adresses_ipv6></a></h4><div class=paragraph><p>Il existe différent types d’adresses IPv6: unicast, anycast et multicast.</p></div><div class=paragraph><p>Les adresses unicast (mono-destinataire) sont les adresses classiques. Un paquet envoyé à une adresse unicast arrive à l’interface correspondant à l’adresse.</p></div><div class=paragraph><p>Les adresses anycast ne sont normalement pas distinguables des adresses unicast mais correspondent à un groupe d’interfaces. Un paquet destiné à une adresse anycast arrivera à l’interface la plus proche (en terme d’unité de distance du protocole de routage). Les adresses anycast devraient n’être utilisées que par les routeurs.</p></div><div class=paragraph><p>Les adresses multicast identifient un groupe d’interfaces. Un paquet destiné à une adresse multicast arrivera sur toutes les interfaces appartenant au groupe multicast.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’adresse de diffusion IPv4 (généralement <code>xxx.xxx.xxx.255</code>) est exprimée par des adresses multicast en IPv6.</p></div></td></tr></tbody></table></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 9. Adresses IPv6 réservées</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Adresse IPv6</th><th class="tableblock halign-left valign-top">Longueur du préfixe (bits)</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Notes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>non-spécifiée</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>similaire à <code>0.0.0.0</code> sous IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>adresse de boucle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>similaire à <code>127.0.0.1</code> sous IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 encapsulé</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les 32 bits de poids faible sont l’adresse IPv4. Egalement appelée "adresse IPv6 compatible IPv4".</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>adresse IPv6 mappée IPv4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les 32 bits de poids faible sont l’adresse IPv4. Destinées aux machines ne supportant pas l’IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::</code> - <code>feb::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lien-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>similaire à l’interface de boucle sous IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fec0::</code> - <code>fef::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>site-local</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>001</code> (base 2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unicast globale</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toutes les adresses unicast globales sont assignées à partir de ce pool. Les trois premiers bits de l’adresse sont "001".</p></td></tr></tbody></table></div><div class=sect3><h4 id=_lecture_des_adresses_ipv6>33.10.2. Lecture des adresses IPv6<a class=anchor href=#_lecture_des_adresses_ipv6></a></h4><div class=paragraph><p>La forme canonique est représentée suivant le schéma: <code>x:x:x:x:x:x:x:x</code>, où chaque "x" est une valeur héxadécimale sur 16 bits. Par exemple <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code></p></div><div class=paragraph><p>Souvent dans une adresse on aura de longues sous-parties constituées de zéros, une telle sous-partie peut être abrégée par "::". Les trois "0"s de poids fort de chaque quartet hexadécimal peuvent également être omis. Par exemple <code>fe80::1</code> correspond à la forme canonique <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>Une troisième forme est d’écrire les derniers 32 bits dans le style IPv4 bien connu (décimal) avec des points "." comme séparateurs. Par exemple <code>2002::10.0.0.1</code> correspond à la représentation canonique (hexadécimale) <code>2002:0000:0000:0000:0000:0000:0a00:0001</code> qui est à son tour équivalente à l’écriture <code>2002::a00:1</code>.</p></div><div class=paragraph><p>Maintenant le lecteur devrait être en mesure de comprendre ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p><code>fe80::200:21ff:fe03:8e1%rl0</code> est une adresse de lien local configurée automatiquement. Elle est générée à partir de l’adresse MAC dans le cas de l’autoconfiguration.</p></div><div class=paragraph><p>Pour plus d’informations sur la structure des adresses IPv6 consultez la <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect3><h4 id=_se_connecter>33.10.3. Se connecter<a class=anchor href=#_se_connecter></a></h4><div class=paragraph><p>Actuellement, il y a quatre façons de se connecter à des machines et des réseaux utilisant l’IPv6:</p></div><div class=ulist><ul><li><p>Rejoindre le réseau expérimental 6bone</p></li><li><p>Obtenir un réseau IPv6 auprès de votre fournisseur d’accès. Contactez votre fournisseur d’accès Internet pour plus d’informations.</p></li><li><p>Utilisation d’un tunnel 6-vers-4 (<a href=http://www.ietf.org/rfc/rfc3068.txt>RFC3068</a>)</p></li><li><p>Utilisation du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> si vous utilisez une connexion par modem.</p></li></ul></div><div class=paragraph><p>Ici nous ne parlerons que de la manière de se connecter au réseau 6bone puisque cela semble être aujourd’hui la méthode de connexion la plus populaire.</p></div><div class=paragraph><p>Consultez tout d’abord le site <a href=http://www.6bone.net/>6bone</a> et recherchez une connexion 6bone proche de vous. Contactez le responsable et avec un peu de chance on vous donnera les instructions à suivre pour configurer votre connexion. Généralement cela implique la mise en place d’un tunnel GRE (gif).</p></div><div class=paragraph><p>Voici un exemple typique de configuration d’un tunnel <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
<span class=c># ifconfig gif0 tunnel MON_ADR_IPv4 MON_ADR_IPv4_ASSIGNEE_A_LAUTRE_BOUT_DU_TUNNEL</span>
<span class=c># ifconfig gif0 inet6 alias MON_ADR_IPv6_ASSIGNEE_A_LEXTREMITE_DU_TUNNEL MON_ADR_IPv6_ASSIGNEE_A_LAUTRE_BOUT_DU_TUNNEL</span></code></pre></div></div><div class=paragraph><p>Remplacez les mots en majuscules par les informations que vous avez reçues du point d’accès 6bone.</p></div><div class=paragraph><p>Ceci établit le tunnel. Vérifiez si le tunnel fonctionne en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a> sur l’adresse <code>ff02::1%gif0</code>. Vous devriez récevoir les réponses aux requêtes ping.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Au cas où vous seriez intrigué par l’adresse <code>ff02:1%gif0</code>, sachez que c’est une adresse multicast. <code>%gif0</code> précise que l’adresse multicast de l’interface <span class=filename>gif0</span> doit être utilisée. Puisque nous utilisons <code>ping</code> sur une adresse multicast, l’autre bout du tunnel devrait également répondre.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Désormais, la mise en place d’une route vers votre lien 6bone devrait être relativement directe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -inet6 default -interface gif0</span>
<span class=c># ping6 -n MON_LIEN_MONTANT</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># traceroute6 www.jp.FreeBSD.org</span>
<span class=o>(</span>3ffe:505:2008:1:2a0:24ff:fe57:e561<span class=o>)</span> from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms <span class=k>*</span>
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</code></pre></div></div><div class=paragraph><p>La sortie pourra être différente d’une machine à une autre. Maintenant vous devriez être en mesure d’atteindre le site IPv6 <a href=http://www.kame.net>www.kame.net</a> et de voir la tortue dansante - et cela si vous disposez d’un navigateur supportant l’IPv6 comme <a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a>, Konqueror qui fait partie du logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/x11/kdebase3/>x11/kdebase3</a>, ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/epiphany/>www/epiphany</a>.</p></div></div><div class=sect3><h4 id=_dns_dans_le_monde_ipv6>33.10.4. DNS dans le monde IPv6<a class=anchor href=#_dns_dans_le_monde_ipv6></a></h4><div class=paragraph><p>A l’origine, il existait deux types d’enregistrement DNS pour l’IPv6. L’organisme IETF a déclaré obsolète l’enregistrement A6. Les enregistrements AAAA sont aujourd’hui le standard.</p></div><div class=paragraph><p>L’utilisation des enregistrements AAAA est assez direct. Assignez votre nom de machine à la nouvelle adresse IPv6 que vous venez d’obtenir en ajoutant:</p></div><div class="literalblock programlisting"><div class=content><pre>MYHOSTNAME           AAAA    MYIPv6ADDR</pre></div></div><div class=paragraph><p>à votre fichier de zone DNS primaire. Dans le cas où vous ne gérez pas vos propres zones DNS contactez le responsable de votre DNS. Les versions actuelles de bind (version 8.3 et 9) et <a class=package href=https://cgit.freebsd.org/ports/tree/dns/djbdns/>dns/djbdns</a> (avec le correctif IPv6) supportent les enregistrements AAAA.</p></div></div><div class=sect3><h4 id=_effectuer_les_changements_nécessaires_dans_le_fichier_etcrc_conf>33.10.5. Effectuer les changements nécessaires dans le fichier <span class=filename>/etc/rc.conf</span><a class=anchor href=#_effectuer_les_changements_nécessaires_dans_le_fichier_etcrc_conf></a></h4><div class=sect4><h5 id=_paramétrage_du_client_ipv6>33.10.5.1. Paramétrage du client IPv6<a class=anchor href=#_paramétrage_du_client_ipv6></a></h5><div class=paragraph><p>Ces paramètres vous permettront de configurer une machine qui sera sur votre réseau local et sera un client, non pas un routeur. Pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a> configure automatiquement votre interface réseau au démarrage tout ce dont vous avez besoin d’ajouter est:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Pour assigner une adresse IP statique telle que <code>2001:471:1f11:251:290:27ff:fee0:2093</code>, à votre interface <span class=filename>fxp0</span>, ajoutez:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_fxp0=&#34;2001:471:1f11:251:290:27ff:fee0:2093&#34;</pre></div></div><div class=paragraph><p>Pour assigner le routeur par défaut <code>2001:471:1f11:251::1</code>, ajoutez ce qui suit au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:471:1f11:251::1&#34;</pre></div></div></div><div class=sect4><h5 id=_paramétrage_dun_routeurpasserelle_ipv6>33.10.5.2. Paramétrage d’un routeur/passerelle IPv6<a class=anchor href=#_paramétrage_dun_routeurpasserelle_ipv6></a></h5><div class=paragraph><p>Ceci vous aidera à mettre en oeuvre les instructions que votre fournisseur de tunnel, tel que <a href=http://www.6bone.net/>6bone</a>, vous a donné et à les convertir en paramètres qui seront conservés à chaque démarrage. Pour rétablir votre tunnel au démarrage, utilisez quelque chose comme ce qui suit dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class=paragraph><p>Listez les interfaces génériques de tunnel qui seront configurées, par exemple <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gif_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Pour configurer l’interface avec une adresse (extrémité) locale <em>MY_IPv4_ADDR</em> vers une adresse (extrémité) distante <em>REMOTE_IPv4_ADDR</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig_gif0=&#34;MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>Pour utiliser l’adresse IPv6 que l’on vous a assigné en vue d’être utilisée pour votre extrémité du tunnel IPv6, ajoutez:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_gif0=&#34;MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Ensuite tout ce qu’il reste à faire est de définir la route par défaut pour l’IPv6. C’est l’autre extrémité du tunnel IPv6:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div></div><div class=sect4><h5 id=_paramétrage_dun_tunnel_ipv6>33.10.5.3. Paramétrage d’un tunnel IPv6<a class=anchor href=#_paramétrage_dun_tunnel_ipv6></a></h5><div class=paragraph><p>Si le serveur doit router de l’IPv6 entre votre réseau et le reste du monde, le paramètre suivant sera également nécessaire dans votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div></div><div class=sect3><h4 id=_annonce_du_routeur_et_auto_configuration>33.10.6. Annonce du routeur et auto-configuration<a class=anchor href=#_annonce_du_routeur_et_auto_configuration></a></h4><div class=paragraph><p>Cette section vous aidera à configurer <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> pour l’annonce de la route IPv6 par défaut.</p></div><div class=paragraph><p>Pour activer <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, vous devrez ajouter ce qui suit à votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Il est important que vous indiquiez l’interface sur laquelle le routeur IPv6 sera sollicité. Par exemple pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> utilise <span class=filename>fxp0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;fxp0&#34;</pre></div></div><div class=paragraph><p>Nous devons maintenant créer le fichier de configuration <span class=filename>/etc/rtadvd.conf</span>. Voici un exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>fxp0:\
	:addrs#1:addr=&#34;2001:471:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Remplacez <span class=filename>fxp0</span> avec l’interface que vous allez utiliser.</p></div><div class=paragraph><p>Ensuite remplacez <code>2001:471:1f11:246::</code> avec votre préfixe.</p></div><div class=paragraph><p>Si vous êtes un sous-réseau <code>/64</code> dédié, il ne sera pas nécessaire de modifier quelque chose d’autre. Sinon, vous devrez modifier <code>prefixlen#</code> avec la valeur correcte.</p></div></div></div><div class=sect2><h3 id=network-atm>33.11. ATM ("Asynchronous Transfer Mode")<a class=anchor href=#network-atm></a></h3><div class=sect3><h4 id=_configuration_ip_conventionnelle_sur_atm_pvcs>33.11.1. Configuration IP conventionnelle sur ATM (PVCs)<a class=anchor href=#_configuration_ip_conventionnelle_sur_atm_pvcs></a></h4><div class=paragraph><p>L’IP conventionnelle sur ATM ("Classical IP over ATM"-CLIP) est la méthode la plus simple pour utiliser ATM (Asynchronous Transfer Mode) avec l’IP. Elle peut être utilisée en mode non connecté ("Switched Virtual Connections"-SVCs) et en mode connecté ("Permanent Virtual Connections"-PVCs). Cette section décrit comment configurer un réseau basé sur les PVCs.</p></div><div class=sect4><h5 id=_configurations_en_réseau_maillé>33.11.1.1. Configurations en réseau maillé<a class=anchor href=#_configurations_en_réseau_maillé></a></h5><div class=paragraph><p>La première méthode de configuration CLIP avec des PVCs est de connecter entre elles chaque machine du réseau par l’intermédiaire d’une PVC dédiée. Bien que cela soit simple à configurer, cela tend à devenir impraticable avec un nombre important de machines. Notre exemple suppose que nous avons quatre machines sur le réseau, chacune connectée au réseau ATM à l’aide d’une carte réseau ATM. La première étape est d’établir le plan des adresses IP et des connexions ATM entre machines. Nous utilisons le plan suivant:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machine</th><th class="tableblock halign-left valign-top">Adresse IP</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.3</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.4</code></p></td></tr></tbody></table><div class=paragraph><p>Pour réaliser un réseau maillé, nous avons besoin d’une connexion ATM entre chaque paire de machines:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machines</th><th class="tableblock halign-left valign-top">Couple VPI.VCI</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.100</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.101</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.102</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.103</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.104</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.105</p></td></tr></tbody></table><div class=paragraph><p>Les valeurs VPI et VCI à chaque extrémité de la connexion peuvent bien évidemment être différentes, mais par souci de simplicité nous supposerons quelles sont identiques. Ensuite nous devons configurer les interfaces ATM sur chaque machine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# ifconfig hatm0 192.168.173.1 up
hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up
hostD# ifconfig hatm0 192.168.173.4 up</code></pre></div></div><div class=paragraph><p>en supposant que l’interface ATM est <span class=filename>hatm0</span> sur toutes les machines. Maintenant les PVCs doivent être configurées sur <code>hostA</code> (nous supposons qu’elles sont déjà configurées sur les switches ATM, vous devez consulter le manuel du switch sur comment réaliser cette configuration).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA# atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA# atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB# atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB# atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB# atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC# atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD# atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD# atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD# atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</code></pre></div></div><div class=paragraph><p>Bien évidemment des contrats de trafic autres qu’UBR ("Unspecified Bit Rate") peuvent être utilisés dès que la carte ATM les supportent. Dans ce cas le nom du contrat de trafic est suivi par les paramètres du trafic. De l’aide concernant l’outil <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a> peut être obtenue avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atmconfig help natm add</span></code></pre></div></div><div class=paragraph><p>ou dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a>.</p></div><div class=paragraph><p>La même configuration peut être faite par l’intermédiaire de <span class=filename>/etc/rc.conf</span>. Pour la machine <code>hostA</code> cela ressemblerait à:</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 hatm0&#34;
ifconfig_hatm0=&#34;inet 192.168.173.1 up&#34;
natm_static_routes=&#34;hostB hostC hostD&#34;
route_hostB=&#34;192.168.173.2 hatm0 0 100 llc/snap ubr&#34;
route_hostC=&#34;192.168.173.3 hatm0 0 101 llc/snap ubr&#34;
route_hostD=&#34;192.168.173.4 hatm0 0 102 llc/snap ubr&#34;</pre></div></div><div class=paragraph><p>L’état de toutes les routes CLIP peut être obtenu avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm show</code></pre></div></div></div></div></div></div></div><h1 id=appendices class=sect0>Partie V: Annexes<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=mirrors>Annexe A: Se procurer FreeBSD<a class=anchor href=#mirrors></a></h2><div class=sectionbody><div class=sect2><h3 id=mirrors-cdrom>A.1. Editeurs de CD-ROMs et DVDs<a class=anchor href=#mirrors-cdrom></a></h3><div class=sect3><h4 id=_produits_vendus_en_boîte>A.1.1. Produits vendus en boîte<a class=anchor href=#_produits_vendus_en_boîte></a></h4><div class=paragraph><p>Des versions en boîte de FreeBSD sont disponibles (CDs de FreeBSD, logiciels supplémentaires, et documentation papier) auprès de plusieurs revendeurs:</p></div><div class=ulist><ul><li><p>CompUSA<br>WWW: <a href=http://www.compusa.com/ class=bare>http://www.compusa.com/</a></p></li><li><p>Frys Electronics<br>WWW: <a href=http://www.frys.com/ class=bare>http://www.frys.com/</a></p></li></ul></div></div><div class=sect3><h4 id=_cds_et_dvds>A.1.2. CDs et DVDs<a class=anchor href=#_cds_et_dvds></a></h4><div class=paragraph><p>Les CDs et DVDs de FreeBSD sont disponibles auprès de nombreux revendeurs en ligne:</p></div><div class=ulist><ul><li><p>BSD Mall by Daemon News<br>PO Box 161<br>Nauvoo, IL 62354<br>USA<br>Phone: +1 866 273-6255<br>Fax: +1 217 453-9956<br>Email: &lt;<a href=mailto:sales@bsdmall.com>sales@bsdmall.com</a>><br>WWW: <a href=http://www.bsdmall.com/ class=bare>http://www.bsdmall.com/</a></p></li><li><p>BSD-Systems<br>Email: &lt;<a href=mailto:info@bsd-systems.co.uk>info@bsd-systems.co.uk</a>><br>WWW: <a href=http://www.bsd-systems.co.uk class=bare>http://www.bsd-systems.co.uk</a></p></li><li><p>FreeBSD Mall, Inc.<br>3623 Sanford Street<br>Concord, CA 94520-1405<br>USA<br>Phone: +1 925 240-6652<br>Fax: +1 925 674-0821<br>Email: &lt;<a href=mailto:info@freebsdmall.com>info@freebsdmall.com</a>><br>WWW: <a href=http://www.freebsdmall.com/ class=bare>http://www.freebsdmall.com/</a></p></li><li><p>Dr. Hinner EDV<br>St. Augustinus-Str. 10<br>D-81825 München<br>Allemagne<br>Phone: (089) 428 419<br>WWW: <a href=http://www.hinner.de/linux/freebsd.html class=bare>http://www.hinner.de/linux/freebsd.html</a></p></li><li><p>Ikarios<br>22-24 rue Voltaire<br>92000 Nanterre<br>France<br>WWW: <a href=http://ikarios.com/form/#freebsd class=bare>http://ikarios.com/form/#freebsd</a></p></li><li><p>JMC Software<br>Ireland<br>Phone: 353 1 6291282<br>WWW: <a href=http://www.thelinuxmall.com class=bare>http://www.thelinuxmall.com</a></p></li><li><p>Linux CD Mall<br>Private Bag MBE N348<br>Auckland 1030<br>New Zealand<br>Phone: +64 21 866529<br>WWW: <a href=http://www.linuxcdmall.co.nz/ class=bare>http://www.linuxcdmall.co.nz/</a></p></li><li><p>The Linux Emporium<br>Hilliard House, Lester Way<br>Wallingford<br>OX10 9TA<br>Royaume-Uni<br>Phone: +44 1491 837010<br>Fax: +44 1491 837016<br>WWW: <a href=http://www.linuxemporium.co.uk/products/freebsd/ class=bare>http://www.linuxemporium.co.uk/products/freebsd/</a></p></li><li><p>Linux+ DVD Magazine<br>Lewartowskiego 6<br>Warsaw<br>00-190<br>Poland<br>Phone: +48 22 860 18 18<br>Email: &lt;<a href=mailto:editors@lpmagazine.org>editors@lpmagazine.org</a>><br>WWW: <a href=http://www.lpmagazine.org/ class=bare>http://www.lpmagazine.org/</a></p></li><li><p>Linux System Labs Australie<br>21 Ray Drive<br>Balwyn North<br>VIC - 3104<br>Australie<br>Phone: +61 3 9857 5918<br>Fax: +61 3 9857 8974<br>WWW: <a href=http://www.lsl.com.au class=bare>http://www.lsl.com.au</a></p></li><li><p>LinuxCenter.Ru<br>Galernaya Street, 55<br>Saint-Petersburg<br>190000<br>Russia<br>Phone: +7-812-3125208<br>Email: &lt;<a href=mailto:info@linuxcenter.ru>info@linuxcenter.ru</a>><br>WWW: <a href=http://linuxcenter.ru/freebsd class=bare>http://linuxcenter.ru/freebsd</a></p></li></ul></div></div><div class=sect3><h4 id=_distributeurs>A.1.3. Distributeurs<a class=anchor href=#_distributeurs></a></h4><div class=paragraph><p>Si vous êtes un revendeur et désirez vendre des CDROMs de FreeBSD, veuillez contacter un distributeur:</p></div><div class=ulist><ul><li><p>Cylogistics<br>809B Cuesta Dr., #2149<br>Mountain View, CA 94040<br>USA<br>Phone: +1 650 694-4949<br>Fax: +1 650 694-4953<br>Email: &lt;<a href=mailto:sales@cylogistics.com>sales@cylogistics.com</a>><br>WWW: <a href=http://www.cylogistics.com/ class=bare>http://www.cylogistics.com/</a></p></li><li><p>Ingram Micro<br>1600 E. St. Andrew Place<br>Santa Ana, CA 92705-4926<br>USA<br>Phone: 1 (800) 456-8000<br>WWW: <a href=http://www.ingrammicro.com/ class=bare>http://www.ingrammicro.com/</a></p></li><li><p>Kudzu, LLC<br>7375 Washington Ave. S.<br>Edina, MN 55439<br>USA<br>Phone: +1 952 947-0822<br>Fax: +1 952 947-0876<br>Email: &lt;<a href=mailto:sales@kudzuenterprises.com>sales@kudzuenterprises.com</a>></p></li><li><p>Navarre Corp<br>7400 49th Ave South<br>New Hope, MN 55428<br>USA<br>Phone: +1 763 535-8333<br>Fax: +1 763 535-0341<br>WWW: <a href=http://www.navarre.com/ class=bare>http://www.navarre.com/</a></p></li></ul></div></div></div><div class=sect2><h3 id=mirrors-ftp>A.2. Sites FTP<a class=anchor href=#mirrors-ftp></a></h3><div class=paragraph><p>Les sources officielles de FreeBSD sont disponibles via FTP anonyme à partir d’un ensemble de sites miroir. Le site <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> dispose d’une bonne connectivité et autorise un grand nombre de connexions, mais vous avez intérêt à trouver plutôt un site miroir "plus proche" (tout particulièrement si vous décidez de mettre en place une sorte de miroir à votre tour).</p></div><div class=paragraph><p>La <a href=http://mirrorlist.FreeBSD.org/>base de données des sites miroir FreeBSD</a> est plus à jour que la liste de ce Manuel, parce qu’elle tire ses informations du DNS plutôt que se reposer sur une liste statique de machines.</p></div><div class=paragraph><p>De plus, FreeBSD est disponible via FTP anonyme à partir des sites miroir ci-dessous. Si vous décidez de vous procurer FreeBSD via FTP anonyme, essayez si possible d’utiliser un site proche de vous. Les sites miroir listés en tant que "sites miroir primaires" disposent généralement de l’intégralité de l’archive FreeBSD (toutes les versions actuellement disponibles pour chacune des architectures) mais vous obtiendrez les temps de téléchargements les plus courts à partir d’un site situé dans votre pays ou votre région. Les sites régionaux proposent les versions les plus récentes des architectures les plus populaires mais pourraient ne pas proposer l’intégralité de l’archive de FreeBSD. Tous les sites proposent un accès FTP anonyme mais certains sites fournissent également un accès suivant d’autres méthodes. Les méthodes d’accès disponibles pour chaque site sont données entre parenthèses après le nom de la machine.</p></div><div class=paragraph><p><a href=#central>Central Servers</a>, <a href=#primary>Primary Mirror Sites</a>, <a href=#armenia>Armenia</a>, <a href=#australia>Australia</a>, <a href=#austria>Austria</a>, <a href=#brazil>Brazil</a>, <a href=#czech-republic>Czech Republic</a>, <a href=#denmark>Denmark</a>, <a href=#estonia>Estonia</a>, <a href=#finland>Finland</a>, <a href=#france>France</a>, <a href=#germany>Germany</a>, <a href=#greece>Greece</a>, <a href=#hong-kong>Hong Kong</a>, <a href=#ireland>Ireland</a>, <a href=#japan>Japan</a>, <a href=#korea>Korea</a>, <a href=#latvia>Latvia</a>, <a href=#lithuania>Lithuania</a>, <a href=#netherlands>Netherlands</a>, <a href=#new-zealand>New Zealand</a>, <a href=#norway>Norway</a>, <a href=#poland>Poland</a>, <a href=#russia>Russia</a>, <a href=#saudi-arabia>Saudi Arabia</a>, <a href=#slovenia>Slovenia</a>, <a href=#south-africa>South Africa</a>, <a href=#spain>Spain</a>, <a href=#sweden>Sweden</a>, <a href=#switzerland>Switzerland</a>, <a href=#taiwan>Taiwan</a>, <a href=#ukraine>Ukraine</a>, <a href=#uk>United Kingdom</a>, <a href=#usa>United States of America</a>.</p></div><div class=paragraph><p>(as of UTC)</p></div><div id=central class=paragraph><p><strong>Central Servers</strong></p></div><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a>)</p></div><div id=primary class=paragraph><p><strong>Primary Mirror Sites</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:mirror-admin@FreeBSD.org>mirror-admin@FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp11.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=armenia class=paragraph><p><strong>Armenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@am.FreeBSD.org>hostmaster@am.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li></ul></div><div id=australia class=paragraph><p><strong>Australia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@au.FreeBSD.org>hostmaster@au.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=austria class=paragraph><p><strong>Austria</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@at.FreeBSD.org>hostmaster@at.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.at.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=brazil class=paragraph><p><strong>Brazil</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@br.FreeBSD.org>hostmaster@br.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp2.br.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp2.br.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp2.br.FreeBSD.org/ class=bare>http://ftp2.br.FreeBSD.org/</a>)</p></li><li><p><a href=ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=czech-republic class=paragraph><p><strong>Czech Republic</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@cz.FreeBSD.org>hostmaster@cz.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=denmark class=paragraph><p><strong>Denmark</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:staff@dotsrc.org>staff@dotsrc.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=estonia class=paragraph><p><strong>Estonia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ee.FreeBSD.org>hostmaster@ee.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=finland class=paragraph><p><strong>Finland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fi.FreeBSD.org>hostmaster@fi.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=france class=paragraph><p><strong>France</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fr.FreeBSD.org>hostmaster@fr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=germany class=paragraph><p><strong>Germany</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:de-bsd-hubs@de.FreeBSD.org>de-bsd-hubs@de.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.de.FreeBSD.org/freebsd/ class=bare>ftp://ftp1.de.FreeBSD.org/freebsd/</a> (ftp / <a href=http://www1.de.FreeBSD.org/freebsd/ class=bare>http://www1.de.FreeBSD.org/freebsd/</a> / rsync://rsync3.de.FreeBSD.org/freebsd/)</p></li><li><p><a href=ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp4.de.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp4.de.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp4.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp7.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=greece class=paragraph><p><strong>Greece</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@gr.FreeBSD.org>hostmaster@gr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=hong-kong class=paragraph><p><strong>Hong Kong</strong></p></div><div class=paragraph><p><a href=ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></div><div id=ireland class=paragraph><p><strong>Ireland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ie.FreeBSD.org>hostmaster@ie.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=japan class=paragraph><p><strong>Japan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@jp.FreeBSD.org>hostmaster@jp.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=korea class=paragraph><p><strong>Korea</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@kr.FreeBSD.org>hostmaster@kr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=latvia class=paragraph><p><strong>Latvia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lv.FreeBSD.org>hostmaster@lv.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lv.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=lithuania class=paragraph><p><strong>Lithuania</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lt.FreeBSD.org>hostmaster@lt.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lt.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=netherlands class=paragraph><p><strong>Netherlands</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@nl.FreeBSD.org>hostmaster@nl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nl.FreeBSD.org/os/FreeBSD/ class=bare>http://ftp.nl.FreeBSD.org/os/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=new-zealand class=paragraph><p><strong>New Zealand</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.nz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=norway class=paragraph><p><strong>Norway</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@no.FreeBSD.org>hostmaster@no.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.no.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.no.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=poland class=paragraph><p><strong>Poland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@pl.FreeBSD.org>hostmaster@pl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p>ftp2.pl.FreeBSD.org</p></li></ul></div><div id=russia class=paragraph><p><strong>Russia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ru.FreeBSD.org>hostmaster@ru.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ru.FreeBSD.org/FreeBSD/ class=bare>http://ftp.ru.FreeBSD.org/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=saudi-arabia class=paragraph><p><strong>Saudi Arabia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:ftpadmin@isu.net.sa>ftpadmin@isu.net.sa</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.isu.net.sa/pub/ftp.freebsd.org class=bare>ftp://ftp.isu.net.sa/pub/ftp.freebsd.org</a> (ftp)</p></li></ul></div><div id=slovenia class=paragraph><p><strong>Slovenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@si.FreeBSD.org>hostmaster@si.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.si.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.si.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=south-africa class=paragraph><p><strong>South Africa</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@za.FreeBSD.org>hostmaster@za.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=spain class=paragraph><p><strong>Spain</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@es.FreeBSD.org>hostmaster@es.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.es.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.es.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=sweden class=paragraph><p><strong>Sweden</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@se.FreeBSD.org>hostmaster@se.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.se.FreeBSD.org/)</p></li><li><p><a href=ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/ / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp6.se.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=switzerland class=paragraph><p><strong>Switzerland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ch.FreeBSD.org>hostmaster@ch.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ch.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=taiwan class=paragraph><p><strong>Taiwan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@tw.FreeBSD.org>hostmaster@tw.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.tw.FreeBSD.org/ class=bare>http://ftp6.tw.FreeBSD.org/</a> / rsync)</p></li><li><p><a href=ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp11.tw.FreeBSD.org/FreeBSD/ class=bare>http://ftp11.tw.FreeBSD.org/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=ukraine class=paragraph><p><strong>Ukraine</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ua.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.ua.FreeBSD.org/pub/FreeBSD class=bare>http://ftp6.ua.FreeBSD.org/pub/FreeBSD</a> / rsync://ftp6.ua.FreeBSD.org/FreeBSD/)</p></li><li><p><a href=ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=uk class=paragraph><p><strong>United Kingdom</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@uk.FreeBSD.org>hostmaster@uk.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.uk.FreeBSD.org/ftp.freebsd.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=usa class=paragraph><p><strong>United States of America</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@us.FreeBSD.org>hostmaster@us.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div></div><div class=sect2><h3 id=anoncvs>A.3. CVS anonyme<a class=anchor href=#anoncvs></a></h3><div class=sect3><h4 id=anoncvs-intro>A.3.1. Introduction<a class=anchor href=#anoncvs-intro></a></h4><div class=paragraph><p>CVS anonyme (ou comme on l’appelle également, <em>anoncvs</em>) est une de fonctionnalité des utilitaires CVS livrés avec FreeBSD qui permet la synchronisation avec un référentiel CVS sur une machine distante. Elle permet, entre autres, aux utilisateurs de FreeBSD, de lire, sans autorisation particulière, les archives disponibles sur l’un des serveurs anoncvs officiels du projet FreeBSD. Pour l’utiliser, il suffit simplement de définir la variable d’environnement <code>CVSROOT</code> pour qu’elle pointe sur le serveur anoncvs approprié, fournir le fameux mot de passe "anoncvs" avec la commande <code>cvs login</code>, puis ensuite utiliser la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> pour y accéder de la même manière qu’à un référentiel local.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La commande <code>cvs login</code>, stocke les mots de passe utilisés pour authentification sur le serveur CVS dans un fichier appelé <span class=filename>.cvspass</span> dans votre répertoire <code>HOME</code>. Si ce fichier n’existe pas, vous pourrez obtenir une erreur quand vous essaierez d’utiliser <code>cvs login</code> pour la première fois. Créez juste un fichier <span class=filename>.cvspass</span> vide, et relancez la commande.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Bien que l’on puisse aussi dire que <a href=#cvsup>CVSup</a> et anoncvs assurent globalement la même fonction, il y a diverses nuances qui peuvent influencer l’utilisateur dans son choix d’une méthode de synchronisation. En résumé, CVSup utilise plus efficacement les ressources réseau et est de loin la méthode la plus sophistiquée des deux, mais cela a un prix. Pour employer CVSup, il faut d’abord installer et configurer un programme client spécialisé avant de pouvoir récupérer quoi que ce soit, et il faut ensuite travailler par sous-ensemble relativement importants, que CVSup appelle <em>catalogues</em>.</p></div><div class=paragraph><p>anoncvs, au contraire, peut être utilisé pour examiner n’importe quoi, d’un seul fichier à un programme particulier (tel que <code>ls</code> ou <code>grep</code>) en faisant référence au nom du module CVS. Bien sûr, anoncvs n’est bon qu’à lire un référentiel CVS, si vous avez donc l’intention de développer localement sur un référentiel partagé avec le projet FreeBSD, alors vous n’avez d’autre choix que d’utiliser CVSup.</p></div></div><div class=sect3><h4 id=anoncvs-usage>A.3.2. Utiliser CVS anonyme<a class=anchor href=#anoncvs-usage></a></h4><div class=paragraph><p>Configurer <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> pour utiliser un référentiel CVS anonyme consiste simplement à définir la variable d’environnement <code>CVSROOT</code> pour qu’elle pointe sur l’un des serveurs anoncvs du projet FreeBSD. A la date de rédaction de ce document, les serveurs suivants sont disponibles:</p></div><div class=ulist><ul><li><p><em>Autriche</em>: :pserver:anoncvs@anoncvs.at.FreeBSD.org:/home/ncvs (Utilisez <code>cvs login</code> et entrez le mot de passe "anoncvs" quand on vous le demandera.)</p></li><li><p><em>France</em>: :pserver:anoncvs@anoncvs.fr.FreeBSD.org:/home/ncvs (pserver (mot de passe "anoncvs"), ssh (aucun mot de passe))</p></li><li><p><em>Allemagne</em>: :pserver:anoncvs@anoncvs.de.FreeBSD.org:/home/ncvs (rsh, pserver, ssh, ssh/2022)</p></li><li><p><em>Japon</em>: :pserver:anoncvs@anoncvs.jp.FreeBSD.org:/home/ncvs (Utilisez <code>cvs login</code> et entrez le mot de passe "anoncvs" quand on vous le demandera.)</p></li><li><p><em>Taiwan</em>: :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs (pserver (utilisez <code>cvs login</code> and entrez n’importe quel mot de passe quand on vous le demandera), ssh (pas de mot de passe))</p><div class="literalblock programlisting"><div class=content><pre>SSH2 HostKey: 1024 e8:3b:29:7b:ca:9f:ac:e9:45:cb:c8:17:ae:9b:eb:55 /etc/ssh/ssh_host_dsa_key.pub</pre></div></div></li><li><p><em>USA</em>: <a href=mailto:freebsdanoncvs@anoncvs.FreeBSD.org>freebsdanoncvs@anoncvs.FreeBSD.org</a>:/home/ncvs (ssh uniquement - pas de mot de passe)</p><div class="literalblock programlisting"><div class=content><pre>SSH HostKey: 1024 a1:e7:46:de:fb:56:ef:05:bc:73:aa:91:09:da:f7:f4 root@sanmateo.ecn.purdue.edu
SSH2 HostKey: 1024 52:02:38:1a:2f:a8:71:d3:f5:83:93:8d:aa:00:6f:65 ssh_host_dsa_key.pub</pre></div></div></li><li><p><em>USA</em>: <a href=mailto:anoncvs@anoncvs1.FreeBSD.org>anoncvs@anoncvs1.FreeBSD.org</a>:/home/ncvs (ssh2 uniquement - pas de mot de passe)</p><div class="literalblock programlisting"><div class=content><pre>SSH2 HostKey: 2048 53:1f:15:a3:72:5c:43:f6:44:0e:6a:e9:bb:f8:01:62 /etc/ssh/ssh_host_dsa_key.pub</pre></div></div></li></ul></div><div class=paragraph><p>Comme CVS vous permet de récupérer ("check out") pratiquement n’importe quelle version des sources de FreeBSD ayant existé (ou, dans certains cas, à venir), vous devez maîtriser l’indicateur de révision (<code>-r</code>) de <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> et connaître les valeurs qu’il peut prendre dans le référentiel du projet FreeBSD.</p></div><div class=paragraph><p>Il y a deux sortes d’étiquettes, les étiquettes de révision et les étiquettes de branches. Les étiquettes de révision s’appliquent à une révision particulière. Leur signification ne varie pas d’un jour à l’autre. Les étiquettes de branche, à l’inverse, se rapportent à la dernière révision sur une branche particulière à un moment donné. Comme les étiquettes de branche ne se rapportent pas à une révision particulière, elles peuvent désigner demain quelque chose de différent de ce qu’elles référencent aujourd’hui.</p></div><div class=paragraph><p><a href=#cvs-tags>Etiquettes CVS</a> présente les étiquettes de révision qui peuvent intéresser l’utilisateur. Encore une fois, aucune ne s’applique au catalogue des logiciels portés puisque ce dernier ne présente pas de multiples branches de développement.</p></div><div class=paragraph><p>Quand vous précisez une étiquette de branche, vous obtenez normalement la dernière version des fichiers de cette branche de développement. Si vous voulez une version antérieure, vous pouvez l’obtenir en précisant une date avec l’indicateur <code>-D date</code>. Reportez-vous aux pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> pour plus de détails.</p></div></div><div class=sect3><h4 id=_exemples>A.3.3. Exemples<a class=anchor href=#_exemples></a></h4><div class=paragraph><p>Bien qu’il soit vraiment recommandé de lire attentivement les pages de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a> avant de faire quoi que ce soit, voici quelques exemples rapides qui vous montrent essentiellement comment utiliser CVS anonyme:</p></div><div class=exampleblock><div class=title>Exemple 44. Récupérer quelque chose de -CURRENT (<a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>):</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
At the prompt, enter any word <span class=k>for</span> « password ».
% cvs co <span class=nb>ls</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Exemple 45. Utiliser SSH pour récupérer l’arborescence <span class=filename>src/</span>:</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cvs <span class=nt>-d</span> freebsdanoncvs@anoncvs.FreeBSD.org:/home/ncvs co src
The authenticity of host <span class=s1>&#39;anoncvs.freebsd.org (128.46.156.46)&#39;</span> can<span class=s1>&#39;t be established.
DSA key fingerprint is 52:02:38:1a:2f:a8:71:d3:f5:83:93:8d:aa:00:6f:65.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;</span>anoncvs.freebsd.org<span class=s1>&#39; (DSA) to the list of known hosts.</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Exemple 46. Récupérer la version 6-STABLE de <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>:</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
At the prompt, enter any word <span class=k>for</span> « password ».
% cvs co <span class=nt>-rRELENG_6</span> <span class=nb>ls</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Exemple 47. Générer la liste des différences concernant <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> (sous forme de "diffs unifiés") entre différentes versions de FreeBSD</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
At the prompt, enter any word <span class=k>for</span> « password ».
% cvs rdiff <span class=nt>-u</span> <span class=nt>-rRELENG_5_3_0_RELEASE</span> <span class=nt>-rRELENG_5_4_0_RELEASE</span> <span class=nb>ls</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Exemple 48. Savoir quels autres noms de modules peuvent être utilisés:</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv CVSROOT :pserver:anoncvs@anoncvs.tw.FreeBSD.org:/home/ncvs
% cvs login
At the prompt, enter any word <span class=k>for</span> « password ».
% cvs co modules
% more modules/modules</code></pre></div></div></div></div></div><div class=sect3><h4 id=_autres_ressources>A.3.4. Autres ressources<a class=anchor href=#_autres_ressources></a></h4><div class=paragraph><p>Les ressources supplémentaires suivantes peuvent être utiles pour apprendre à se servir de CVS:</p></div><div class=ulist><ul><li><p><a href=http://www.csc.calpoly.edu/~dbutler/tutorials/winter96/cvs/>Guide CVS</a> de Cal Poly.</p></li><li><p><a href=http://ximbiot.com/cvs/wiki/>CVS Home</a>, la communauté de développement et de support de CVS.</p></li><li><p><a href=http://www.FreeBSD.org/cgi/cvsweb.cgi>CVSweb</a> est l’interface Web pour CVS du projet FreeBSD.</p></li></ul></div></div></div><div class=sect2><h3 id=ctm>A.4. Utiliser CTM<a class=anchor href=#ctm></a></h3><div class=paragraph><p>CTM est une méthode pour synchroniser une arborescence de répertoires distants avec une arborescence centrale. Elle a été développée pour être utilisée avec l’arborescence des sources de FreeBSD, bien que d’autres puissent avec le temps la trouver utile pour d’autres besoins. Il existe actuellement très peu, sinon aucune, documentation sur la façon de créer les deltas, contactez-donc la liste de diffusion <a href=https://lists.FreeBSD.org/subscription/ctm-users>ctm-users-desc</a> pour obtenir plus d’informations et si vous souhaitez utiliser CTM pour autre chose.</p></div><div class=sect3><h4 id=_pourquoi_utiliser_ctm>A.4.1. Pourquoi utiliser CTM?<a class=anchor href=#_pourquoi_utiliser_ctm></a></h4><div class=paragraph><p>CTM vous procurera un exemplaire local de l’arborescence des sources de FreeBSD. Il y a plusieurs "moutures" de l’arborescence disponibles. Que vous désiriez suivre toute l’arborescence CVS ou seulement une de ses branches, CTM peut vous fournir ce dont vous avez besoin. Si vous développez activement sous FreeBSD, mais ne disposez que d’une connectivité TCP/IP peu fiable ou n’en avez pas du tout, ou voulez tout simplement que les modifications vous soient automatiquement envoyées, CTM est ce qu’il vous faut. Il vous faudra jusqu’à trois deltas par jour sur les branches les plus actives. Cependant, vous devriez envisager de vous les faire envoyer automatiquement par courrier électronique. La taille des mises à jour est toujours aussi petite que possible. Typiquement moins de 5KO, occasionnellement (une fois sur 10), entre 10 et 50KO, et de temps à autre, une grosse modification de 100KO ou plus.</p></div><div class=paragraph><p>Vous devrez aussi vous tenir au courant des différentes contre-parties liées au fait de travailler directement avec les sources en cours de développement plutôt qu’avec les versions publiées. C’est particulièrement vrai si vous choisissez les sources de la branche "-CURRENT". Il est recommandé de lire <a href=./#current>Se synchroniser avec la version -CURRENT de FreeBSD</a>.</p></div></div><div class=sect3><h4 id=_que_vous_faut_il_pour_utiliser_ctm>A.4.2. Que vous faut-il pour utiliser CTM?<a class=anchor href=#_que_vous_faut_il_pour_utiliser_ctm></a></h4><div class=paragraph><p>Vous aurez besoin de deux choses: le programme CTM, et les deltas initiaux à lui fournir (pour mettre à jour avec la version "courante").</p></div><div class=paragraph><p>Le programme CTM fait partie de FreeBSD depuis la publication de la version 2.0, et se trouve dans <span class=filename>/usr/src/usr.sbin/ctm</span> si vous avez un exemplaire des sources en ligne.</p></div><div class=paragraph><p>Vous pouvez obtenir les "deltas" à fournir à CTM de deux façons, par FTP ou par courrier électronique. Si vous avez un accès FTP à l’Internet, les sites suivants supportent l’accès à CTM:</p></div><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/CTM/>ftp://ftp.FreeBSD.org/pub/FreeBSD/CTM/</a></p></div><div class=paragraph><p>ou reportez-vous à la section <a href=#mirrors-ctm>Sites miroirs</a>.</p></div><div class=paragraph><p>Allez dans le répertoire vous concernant et commencez par télécharger le fichier <span class=filename>README</span>.</p></div><div class=paragraph><p>Si vous souhaitez récupérer vos deltas par courrier électronique:</p></div><div class=paragraph><p>Abonnez-vous à l’une des listes de distribution CTM. <a href=https://lists.FreeBSD.org/subscription/ctm-cvs-cur>ctm-cvs-cur-desc</a> comprend toute l’arborescence -CURRENT. <a href=https://lists.FreeBSD.org/subscription/ctm-src-4>liste de diffusion des sources de la branche 4-STABLE via CTM</a> concerne la branche 4.X, etc…​ (Si vous ne savez pas comment vous abonner à une liste, cliquez sur le nom de la liste ci-dessus ou sur <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> puis cliquez sur la liste à laquelle vous désirez vous abonner. La page devrait contenir toutes les instructions nécessaires à l’abonnement.)</p></div><div class=paragraph><p>Dès que vous commencez à recevoir vos mises à jour CTM par courrier électronique, vous pouvez utiliser le programme <code>ctm_rmail</code> pour les décompacter et les appliquer. Vous pouvez en fait utiliser directement le programme <code>ctm_rmail</code> à partir d’une entrée dans <span class=filename>/etc/aliases</span> si vous voulez automatiser complètement le processus. Consultez les pages de manuel de <code>ctm_rmail</code> pour plus de détails.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quelle que soit la méthode que vous utilisez pour récupérer les deltas CTM, vous devriez vous abonner à la liste de diffusion <a href=https://lists.FreeBSD.org/subscription/ctm-announce>ctm-announce-desc</a>. Ce sera, dans l’avenir, le seul endroit où les annonces concernant le fonctionnement du système CTM seront faites. Cliquez sur le nom de la liste et suivez les instructions pour s’inscrire à la liste.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_utiliser_ctm_pour_la_première_fois>A.4.3. Utiliser CTM pour la première fois<a class=anchor href=#_utiliser_ctm_pour_la_première_fois></a></h4><div class=paragraph><p>Avant de pouvoir utiliser les deltas CTM, il vous faut un point de départ pour appliquer les deltas générés à partir de là.</p></div><div class=paragraph><p>Tout d’abord vous devez déterminer ce que vous avez déjà. Tout le monde peut partir d’un répertoire "vide". Vous devez utiliser un delta "Empty" (vide) au départ pour débuter votre arborescence supportée par CTM. Il fut question que l’un de ces deltas de départ soit distribué sur le CD, cependant ce n’est actuellement pas le cas.</p></div><div class=paragraph><p>Puisque les arborescences représentent plusieurs dizaines de mégaoctets, vous préférerez commencer avec ce que vous avez déjà sous la main. Si vous disposez d’une version de FreeBSD sur CD, vous pouvez copier ou extraire les sources initiales qui s’y trouvent. Cela évitera un transfert de données conséquent.</p></div><div class=paragraph><p>Vous pouvez reconnaître ces deltas de transition au <code>X</code> qui suit leur numéro de séquence (<span class=filename>src-cur.3210XEmpty.gz</span> par exemple). La dénomination après le <code>X</code> correspond à l’origine de votre "racine" initiale. <span class=filename>Empty</span> est un répertoire vide. La règle est qu’une transition de base à partir de <span class=filename>Empty</span> est générée tous les 100 deltas. Au passage, elles sont volumineuses! De 70 à 80 mégaoctets de données compressées avec <code>gzip</code> est une taille habituelle pour les deltas <span class=filename>XEmpty</span>.</p></div><div class=paragraph><p>Une fois que vous avez sélectionné un delta initial à partir duquel commencer, il vous faudra également tous les deltas de numéro supérieur qui le suivent.</p></div></div><div class=sect3><h4 id=_utiliser_ctm_au_quotidien>A.4.4. Utiliser CTM au quotidien<a class=anchor href=#_utiliser_ctm_au_quotidien></a></h4><div class=paragraph><p>Pour appliquer les deltas, tapez simplement:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /où/vous/voulez/mettre/les/fichiers</span>
<span class=c># ctm -v -v /où/vous/mettez/vos/deltas/src-xxx.*</span></code></pre></div></div><div class=paragraph><p>CTM reconnaît les deltas qui ont été compressés avec <code>gzip</code>, vous n’avez donc pas besoin de les décompresser avant, ce qui économise de l’espace disque.</p></div><div class=paragraph><p>A moins d’être absolument sûr du résultat, CTM ne touchera pas à votre arborescence. Pour contrôler la validité d’un delta, vous pouvez également utiliser l’indicateur <code>-c</code> et CTM ne modifiera alors pas votre arborescence; il vérifiera simplement l’intégrité du delta et regardera s’il peut s’appliquer proprement à votre arborescence en l’état.</p></div><div class=paragraph><p>Il y a aussi d’autres option pour CTM, voyez les pages de manuel ou lisez les sources pour plus d’informations.</p></div><div class=paragraph><p>C’est à peu près tout. Chaque fois que vous recevez un delta, passez-le à CTM pour tenir à jour votre arborescence des sources.</p></div><div class=paragraph><p>N’effacez pas les deltas s’il vous est difficile de les télécharger de nouveau. Vous pouvez en avoir besoin si quelque chose mauvais se produit. Même si vous n’avez que des disquettes, envisagez d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=fdwrite&amp;sektion=1&amp;format=html">fdwrite(1)</a> pour en faire une copie.</p></div></div><div class=sect3><h4 id=_conserver_vos_modifications_locales>A.4.5. Conserver vos modifications locales<a class=anchor href=#_conserver_vos_modifications_locales></a></h4><div class=paragraph><p>Si vous êtes développeur vous voudrez expérimenter et modifier des fichiers de l’arborescence des sources. CTM supporte de façon limitée les modifications locales: avant de contrôler l’existence d’un fichier <span class=filename>foo</span>, il regarde tout d’abord s’il y a un fichier <span class=filename>foo.ctm</span>. Si ce fichier existe, CTM l’utilisera au lieu de <span class=filename>foo</span>.</p></div><div class=paragraph><p>Ce comportement vous permet de conserver de façon simple des modifications locales: copiez simplement les fichiers que vous envisagez de modifier dans des fichiers de même nom, mais avec le suffixe <span class=filename>.ctm</span>. Vous pouvez ensuite bidouiller tranquillement le code, pendant que CTM maintient à jour le fichier <span class=filename>.ctm</span>.</p></div></div><div class=sect3><h4 id=_dautres_options_intéressantes_de_ctm>A.4.6. D’autres options intéressantes de CTM<a class=anchor href=#_dautres_options_intéressantes_de_ctm></a></h4><div class=sect4><h5 id=_savoir_avec_précision_ce_que_va_modifier_une_mise_à_jour>A.4.6.1. Savoir avec précision ce que va modifier une mise à jour<a class=anchor href=#_savoir_avec_précision_ce_que_va_modifier_une_mise_à_jour></a></h5><div class=paragraph><p>Vous pouvez connaître la liste des modifications que CTM appliquera à votre archive des sources en utilisant CTM avec l’option <code>-l</code>.</p></div><div class=paragraph><p>C’est utile si vous voulez conserver la trace des modifications, pré- ou post- modifier les fichiers concernés, ou vous vous sentez un tantinet paranoïaque.</p></div></div><div class=sect4><h5 id=_faire_des_sauvegardes_avant_la_mise_à_jour>A.4.6.2. Faire des sauvegardes avant la mise à jour<a class=anchor href=#_faire_des_sauvegardes_avant_la_mise_à_jour></a></h5><div class=paragraph><p>Parfois vous voudrez sauvegarder tous les fichiers qui seraient toucher par une mise à jour CTM.</p></div><div class=paragraph><p>Avec l’option <code>-B fichier_de_sauvegarde</code>, CTM sauvegarde tous les fichiers que seraient modifiés par delta CTM donné dans <span class=filename>fichier_de_sauvegarde</span>.</p></div></div><div class=sect4><h5 id=_restreindre_la_liste_des_fichiers_touchés_par_une_mise_à_jour>A.4.6.3. Restreindre la liste des fichiers touchés par une mise à jour<a class=anchor href=#_restreindre_la_liste_des_fichiers_touchés_par_une_mise_à_jour></a></h5><div class=paragraph><p>Parfois vous voudrez restreindre le champ d’application d’une mise à jour CTM, ou serez intéressé à n’extraire que quelques fichiers d’une séquence de deltas.</p></div><div class=paragraph><p>Vous pouvez contrôler la liste de fichiers sur laquelle travaillera CTM en donnant comme filtre une expression régulière avec les options <code>-e</code> et <code>-x</code>.</p></div><div class=paragraph><p>Par exemple, pour extraire une version à jour de <span class=filename>lib/libc/Makefile</span> de la série de deltas CTM que vous avez sauvegardé, lancez les commandes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /where/ever/you/want/to/extract/it/</span>
<span class=c># ctm -e &#39;^lib/libc/Makefile&#39; ~ctm/src-xxx.*</span></code></pre></div></div><div class=paragraph><p>Pour chaque fichier d’un delta CTM, les options <code>-e</code> et <code>-x</code> sont appliquées dans l’ordre donné sur la ligne de commande. Le fichier est traité par CTM uniquement s’il est sélectionné après application des options <code>-e</code> et <code>-x</code>.</p></div></div></div><div class=sect3><h4 id=_perspectives_pour_ctm>A.4.7. Perspectives pour CTM<a class=anchor href=#_perspectives_pour_ctm></a></h4><div class=paragraph><p>Il y en a des tonnes:</p></div><div class=ulist><ul><li><p>Utiliser une méthode d’authentification au système CTM pour détecter la substitution de mises à jour.</p></li><li><p>Faire le ménage dans les options de CTM, elles commencent à engendrer de la confusion et à contredire l’intuition.</p></li></ul></div></div><div class=sect3><h4 id=_divers_2>A.4.8. Divers<a class=anchor href=#_divers_2></a></h4><div class=paragraph><p>Il existe aussi une séquence de deltas pour le catalogue des logiciels portés, mais elle n’a pas reçue beaucoup d’écho jusqu’ici.</p></div></div><div class=sect3><h4 id=mirrors-ctm>A.4.9. Miroirs CTM<a class=anchor href=#mirrors-ctm></a></h4><div class=paragraph><p><a href=#ctm>CTM</a>/FreeBSD est disponible via FTP anonyme sur les miroirs suivants. Si vous faites le choix de vous procurer CTM via FTP anonyme, utilisez s’il vous plaît un site proche de vous.</p></div><div class=paragraph><p>En cas de problème, contactez la liste de diffusion <a href=https://lists.FreeBSD.org/subscription/ctm-users>ctm-users-desc</a>.</p></div><div class=dlist><dl><dt class=hdlist1>Californie, Bay Area, source officielle</dt><dd><div class=ulist><ul><li><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li></ul></div></dd><dt class=hdlist1>Afrique du Sud, serveur de sauvegarde pour les anciens deltas</dt><dd><div class=ulist><ul><li><p><a href=ftp://ftp.za.FreeBSD.org/pub/FreeBSD/CTM/>ftp://ftp.za.FreeBSD.org/pub/FreeBSD/CTM/</a></p></li></ul></div></dd><dt class=hdlist1>Taïwan/R.O.C.</dt><dd><div class=ulist><ul><li><p><a href=ftp://ctm.tw.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ctm.tw.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li><li><p><a href=ftp://ctm2.tw.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ctm2.tw.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li><li><p><a href=ftp://ctm3.tw.FreeBSD.org/pub/FreeBSD/development/CTM/>ftp://ctm3.tw.FreeBSD.org/pub/FreeBSD/development/CTM/</a></p></li></ul></div></dd></dl></div><div class=paragraph><p>Si vous n’avez pas trouvé de miroir proche de vous, où si le miroir est incomplet, essayez d’utiliser un moteur de recherche comme <a href=http://www.alltheweb.com/>alltheweb</a>.</p></div></div></div><div class=sect2><h3 id=cvsup>A.5. Utiliser CVSup<a class=anchor href=#cvsup></a></h3><div class=sect3><h4 id=cvsup-intro>A.5.1. Introduction<a class=anchor href=#cvsup-intro></a></h4><div class=paragraph><p>CVSup est un ensemble de logiciels pour la distribution et la mise à jour d’arborescences de sources à partir d’un référentiel CVS principal sur une machine serveur distante. Les sources de FreeBSD sont archivées sous un référentiel CVS sur une machine centrale de développement en Californie. Grâce à CVSup, les utilisateurs de FreeBSD peuvent facilement tenir à jour leur propre arborescence de sources.</p></div><div class=paragraph><p>CVSup utilise le modèle <em>pull</em> de mise à jour. Dans ce schéma, chaque client réclame les mises à jour au serveur, si et quand il le souhaite. Le serveur attend passivement les demandes de mises à jour de ses clients. Toutes les mises à jour sont donc faites à la demande du client. Le serveur n’envoie jamais de mise à jour non sollicitée. Les utilisateurs doivent soit exécuter le client CVSup à la main pour obtenir une mise à jour, soit mettre en oeuvre une tâche <code>cron</code> pour l’exécuter automatiquement et à intervalles réguliers.</p></div><div class=paragraph><p>Le terme CVSup, avec les majuscules, désigne l’ensemble du logiciel. Ses principales composantes sont le client <code>cvsup</code> qui s’exécute sur les machines de chaque utilisateur, et le serveur <code>cvsupd</code>, qui tourne sur tous les sites miroir de FreeBSD.</p></div><div class=paragraph><p>En lisant la documentation et les listes de diffusion de FreeBSD, vous trouverez des références à sup. sup était le prédécesseur de CVSup, et remplissait la même fonction. CVSup est utilisé de la même façon que sup et, emploie de fait des fichiers de configuration qui sont compatibles avec ceux de <code>sup</code>. sup n’est plus utilisé pour le projet FreeBSD, parce que CVSup est à la fois plus rapide et plus souple.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’utilitaire csup est une réécriture en C du logiciel CVSup. Son plus grand avantage est d’être plus rapide et de ne pas dépendre du langage Modula-3, vous n’avez donc pas besoin de l’installer. De plus si vous utilisez FreeBSD 6.2 ou une version suivante, vous pouvez directement utiliser cet utilitaire puisqu’il fait partie du système de base. Les anciennes versions de FreeBSD ne disposent pas de <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> dans leur système de base, mais vous pouvez facilement installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/csup/>net/csup</a>, ou le paquetage pré-compilé correspondant. L’utilitaire csup ne supporte pas, cependant, le mode CVS. Si vous désirez dupliquer l’intégralité de dépôts, vous aurez toujours besoin de CVSup. Si vous avez décidé d’utiliser csup, passez les étapes concernant l’installation de CVSup et remplacez les références à CVSup par csup dans le reste de cette section.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=cvsup-install>A.5.2. Installation<a class=anchor href=#cvsup-install></a></h4><div class=paragraph><p>La méthode la plus simple pour installer CVSup est d’utiliser la version pré-compilée <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a> du <a href=./#ports>catalogue des logiciels portés</a> de FreeBSD. Si vous préférez compiler CVSup à partir des sources, vous pouvez directement utiliser le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a>. Cependant soyez averti: le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a> est écrit en Modula-3, qui demande un temps et un espace disque non négligeables pour le télécharger et le compiler.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si vous avez l’intention d’utiliser CVSup sur une machine qui ne disposera pas de XFree86™ ou Xorg, comme un serveur, assurez-vous que le logiciel porté de n’incluera pas l’interface graphique ("GUI") de CVSup, <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup-without-gui/>net/cvsup-without-gui</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si vous voulez installer csup sous FreeBSD 6.1 et version précédentes, vous pouvez utiliser le paquetage pré-compilé <a class=package href=https://cgit.freebsd.org/ports/tree/net/csup/>net/csup</a> du <a href=./#ports>catalogue des logiciels portés</a>. Si vous préférez compiler csup à partir des sources, vous pouvez directement utiliser le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/csup/>net/csup</a>.</p></div></div><div class=sect3><h4 id=cvsup-config>A.5.3. Configuration de CVSup<a class=anchor href=#cvsup-config></a></h4><div class=paragraph><p>Le fonctionnement de CVSup est contrôlé par un fichier de configuration appelé <span class=filename>supfile</span>. Il y a des exemples de fichiers <span class=filename>supfile</span> dans le répertoire <a href=file://localhost/usr/shared/examples/cvsup/>/usr/shared/examples/cvsup/</a>.</p></div><div class=paragraph><p>Les informations du fichier <span class=filename>supfile</span> répondent pour CVSup aux question suivantes:</p></div><div class=ulist><ul><li><p><a href=#cvsup-config-files>Quels fichiers voulez-vous télécharger?</a></p></li><li><p><a href=#cvsup-config-vers>Quelles versions de ces fichiers voulez-vous?</a></p></li><li><p><a href=#cvsup-config-where>D’où voulez-vous les télécharger?</a></p></li><li><p><a href=#cvsup-config-dest>Où voulez-vous les mettre sur votre machine?</a></p></li><li><p><a href=#cvsup-config-status>Où voulez-vous mettre les fichiers d’état de votre machine?</a></p></li></ul></div><div class=paragraph><p>Dans les sections suivantes, nous allons renseigner un fichier <span class=filename>supfile</span> typique en répondant une à une à chacune de ces questions. Commençons par décrire la structure d’ensemble d’un fichier <span class=filename>supfile</span>.</p></div><div class=paragraph><p>Un fichier <span class=filename>supfile</span> est un fichier texte. Les commentaires débutent par un <code>#</code> et se prolongent jusqu’à la fin de la ligne. Les lignes vides ou qui ne contiennent que des commentaires sont ignorées.</p></div><div class=paragraph><p>Les autres lignes décrivent les ensembles de fichiers que l’utilisateur souhaite recevoir. Ces lignes commencent par le nom d’un "catalogue" - <em>collection</em>, un regroupement logique de fichiers défini par le serveur. Le nom du catalogue dit au serveur quels fichiers vous voulez. Ce nom est éventuellement suivi d’un ou plusieurs champs, séparés par un espace. Ces champs répondent aux questions listées ci-dessus. Il y deux types de champs: des indicateurs et des valeurs. Un indicateur est un mot-clé autonome, e.g., <code>delete</code> ou <code>compress</code>. Une valeur commence aussi par un mot-clé, mais il est impérativement suivi sans espace par un <code>=</code> et un deuxième mot. Par exemple, <code>release=cvs</code> est un champ définissant une valeur.</p></div><div class=paragraph><p>Un fichier <span class=filename>supfile</span> spécifie en général plus d’un catalogue à télécharger. Une façon de construire un fichier <span class=filename>supfile</span> consiste à préciser explicitement tous les champs nécessaires pour chaque catalogue. Cependant, cela tend à donner des fichiers <span class=filename>supfile</span> avec des lignes assez longues, et ce n’est pas très pratique parce que la plupart des champs sont les mêmes pour tous les catalogues du fichier <span class=filename>supfile</span>. CVSup fournit un mécanisme pour s’affranchir de ce problème. Les lignes qui commencent par le nom du pseudo-catalogue spécial <code>*default</code> servent à définir les indicateurs et les valeurs qui seront pris par défaut pour les catalogues listés ensuite dans le fichier <span class=filename>supfile</span>. Une valeur par défaut peut-être surchargée pour un catalogue particulier, en associant au catalogue lui-même une valeur différente. Les valeurs par défaut peuvent également être redéfinies, ou bien on peut en définir de nouvelles, en cours de fichier <span class=filename>supfile</span>, par de nouvelles lignes <code>*default</code>.</p></div><div class=paragraph><p>Sachant cela, nous allons maintenant mettre au point un fichier <span class=filename>supfile</span> pour télécharger et mettre à jour l’arborescence principale de <a href=./#current>FreeBSD-CURRENT</a>.</p></div><div class=ulist><ul><li><p><a id=cvsup-config-files></a>Quels fichiers voulez-vous télécharger?</p><div class=paragraph><p>Les fichiers disponibles via CVSup sont regroupés par "catalogues" - <em>collections</em>. Les catalogues disponibles sont décrits dans la <a href=#cvsup-collec>section suivante</a>. Dans notre exemple, nous souhaitons recevoir toute l’arborescence principale du système FreeBSD. Il existe un unique gros catalogue <code>src-all</code> qui correspond à tout cela. Pour commencer à renseigner notre fichier <span class=filename>supfile</span>, nous listons simplement les catalogues, un par ligne (dans notre cas, une seule ligne):</p></div><div class="literalblock programlisting"><div class=content><pre>src-all</pre></div></div></li><li><p><a id=cvsup-config-vers></a>Quelle(s) version(s) voulez-vous télécharger?</p><div class=paragraph><p>Avec CVSup, vous pouvez obtenir pratiquement n’importe quelle version qui ait existé des sources. C’est possible parce que le serveur cvsupd travaille directement à partir du référentiel CVS, qui contient toutes les versions. Vous indiquez quelle version vous voulez en utilisant les valeurs <code>tag=</code> et <code>date=</code>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Faites très attention à définir correctement la valeur <code>tag=</code>. Certaines étiquettes ne s’appliquent qu’à certains catalogues. Si l’étiquette que vous donnez n’est pas valable ou mal orthographiée, CVSup effacera des fichiers que vous ne vouliez probablement pas supprimer. En particulier, n’utilisez <em>que</em>`tag=.` pour les catalogues <code>ports-*</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Les valeurs données avec <code>tag=</code> sont des étiquettes symboliques définies dans le référentiel. Il y a deux sortes d’étiquettes, les étiquettes de révision et les étiquettes de branches. Les étiquettes de révision s’appliquent à une révision particulière. Leur signification ne varie pas d’un jour à l’autre. Les étiquettes de branches, à l’inverse, se rapportent à la dernière révision sur une branche particulière à un moment donné. Comme les étiquettes de branches ne se rapportent pas à une révision particulière, elles peuvent désigner demain quelque chose de différent de ce qu’elles référencent aujourd’hui.</p></div><div class=paragraph><p><a href=#cvs-tags>Etiquettes CVS</a> contient les étiquettes de branches qui peuvent intéresser les utilisateurs. Quand on spécifie une étiquette dans le fichier de configuration de CVSup, elle doit être précédée du champ <code>tag=</code> (<code>RELENG_4</code> deviendra <code>tag=RELENG_4</code>). Gardez à l’esprit que seule l’étiquette <code>tag=.</code> n’a de signification pour le catalogue des logiciels portés.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Faites très attention à mentionner précisément l’étiquette exacte. CVSup ne sait différencier une étiquette valide d’une étiquette qui ne l’est pas. Si vous orthographiez mal l’étiquette, CVSup se comportera comme si vous aviez donné une étiquette valide qui ne se réfère à aucun fichier. Dans ce cas il supprimera toutes les sources que vous avez déjà.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Lorsque vous indiquez une étiquette de branche, vous recevez normalement les dernières versions des fichiers sur cette branche de développement. Si vous voulez récupérer des version antérieures, vous pouvez le faire en donnant une date avec le champ <code>date=</code>. La page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=cvsup&amp;sektion=1&amp;format=html">cvsup(1)</a> vous expliquent comment le faire.</p></div><div class=paragraph><p>Dans notre exemple, nous désirons obtenir FreeBSD-CURRENT. Nous ajoutons alors la ligne suivante au début de notre fichier <span class=filename>supfile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>*default tag=.</pre></div></div><div class=paragraph><p>Il existe un cas particulier important qui se produit lorsque que l’on ne spécifie ni le champ <code>tag=</code> ni le champ <code>date=</code>. Dans ce cas, vous obtenez alors les fichiers RCS directement du référentiel CVS du serveur, plutôt que de recevoir une version donnée. Les développeurs préfèrent généralement cette façon de travailler. En maintenant une version du référentiel lui-même sur leur système, ils ont la possibilité de consulter l’historique des révisions et d’accéder aux versions antérieures des fichiers. Cet avantage ne s’obtient cependant qu’au prix d’une consommation importante d’espace disque.</p></div></li><li><p><a id=cvsup-config-where></a>D’où voulez-vous les télécharger?</p><div class=paragraph><p>Nous employons le champ <code>host=</code> pour dire à <code>cvsup</code> où récupérer ses mises à jour. N’importe quel des <a href=#cvsup-mirrors>sites miroir CVSup</a> fera l’affaire, bien que vous devriez essayer de choisir un site proche de vous. Dans cet exemple, nous utiliserons un site fictif de distribution de FreeBSD <code>cvsup99.FreeBSD.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>*default host=cvsup99.FreeBSD.org</pre></div></div><div class=paragraph><p>Vous devrez changer le site pour un qui existe réellement avant d’exécuter CVSup. Lors de l’exécution de <code>cvsup</code>, vous pouvez surcharger cette définition sur la ligne de commande avec l’option <code>-h <em>nom_de_machine</em></code>.</p></div></li><li><p><a id=cvsup-config-dest></a>Où voulez-vous les mettre sur votre machine?</p><div class=paragraph><p>Le champ <code>prefix=</code> dit à <code>cvsup</code> où mettre les fichiers qu’il obtient. Dans l’exemple, nous mettrons les fichiers source directement dans notre arborescence des sources, <span class=filename>/usr/src</span>. Le répertoire <span class=filename>src</span> est déjà implicitement défini dans les catalogues que nous avons choisis de télécharger, voici donc la définition correcte:</p></div><div class="literalblock programlisting"><div class=content><pre>*default prefix=/usr</pre></div></div></li><li><p><a id=cvsup-config-status></a>Où <code>cvsup</code> doit-il mettre les fichiers d’état?</p><div class=paragraph><p>Le client CVSup tient à jour des fichiers d’état dans ce qui est appelé le répertoire de "base". Ces fichiers permettent à CVSup de travailler plus efficacement en gardant la trace des modifications que vous avez déjà reçues. Nous utiliserons le répertoire de base standard, <span class=filename>/var/db</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>*default base=/var/db</pre></div></div><div class=paragraph><p>Si votre répertoire de base n’existe pas encore, c’est le moment de le créer. Le client <code>cvsup</code> refusera de s’exécuter si le répertoire de base n’existe pas.</p></div></li><li><p>Diverses autres options de configuration dans le fichier <span class=filename>supfile</span>:</p><div class=paragraph><p>Il y a une autre ligne d’instruction qui doit normalement figurer dans le fichier <span class=filename>supfile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>*default release=cvs delete use-rel-suffix compress</pre></div></div><div class=paragraph><p><code>release=cvs</code> dit au serveur d’obtenir les informations du référentiel principal de FreeBSD. C’est quasiment toujours le cas, mais il existe d’autres possibilités qui sortent du cadre du présent document.</p></div><div class=paragraph><p><code>delete</code> donne à CVSup l’autorisation de supprimer des fichiers. Vous devriez toujours utiliser cette possibilité, de sorte que CVSup puisse vraiment maintenir à jour votre arborescence des sources. CVSup veille à ne supprimer que les fichiers qu’il maintient. Les fichiers supplémentaires que vous pourriez avoir ne seront pas touchés.</p></div><div class=paragraph><p><code>use-rel-suffix</code> est…​ ésotérique. Si vous voulez vraiment savoir de quoi il retourne, lisez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=cvsup&amp;sektion=1&amp;format=html">cvsup(1)</a>. Sinon, mettez cet indicateur et ne vous en souciez pas plus.</p></div><div class=paragraph><p><code>compress</code> permet d’utiliser un algorithme de compression de type <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> sur la ligne de communication. Si votre connexion a la vitesse d’une ligne T1 ou plus, vous ne devriez probablement pas utiliser la compression. Sinon, cela facilite substantiellement les choses.</p></div></li><li><p>Assembler les morceaux:</p><div class=paragraph><p>Voici le fichier <span class=filename>supfile</span> de notre exemple en entier:</p></div><div class="literalblock programlisting"><div class=content><pre>*default tag=.
*default host=cvsup99.FreeBSD.org
*default prefix=/usr
*default base=/var/db
*default release=cvs delete use-rel-suffix compress

src-all</pre></div></div></li></ul></div><div class=sect4><h5 id=cvsup-refuse-file>A.5.3.1. Le fichier <span class=filename>refuse</span><a class=anchor href=#cvsup-refuse-file></a></h5><div class=paragraph><p>Comme mentionné ci-dessus, CVSup utilise une méthode de type <em>pull</em>. Fondamentalement, cela signifie que vous vous connectez au serveur CVSup, ce dernier dit, "Voici ce que vous pouvez télécharger…​", puis votre client répond "Ok, je prendrai ceci, ceci, ceci et cela". Dans la configuration par défaut, le client CVSup téléchargera chaque fichier associé avec le catalogue et l’étiquette que vous avez choisi dans le fichier de configuration. Cependant cela ne correspond pas toujours à ce que vous désirez, tout particulièrement si vous mettez à jour les arborescences <span class=filename>doc</span>, <span class=filename>ports</span>, ou <span class=filename>www</span> - la plupart des personnes sont incapables de lire quatre ou cinq langues différentes, et donc elles n’ont pas besoin de télécharger les fichiers spécifiques à certaines langues. Si vous mettez à jour le catalogue des logiciels portés, vous pouvez remédier à cela en spécifiant chaque catalogue individuellement (e.g., <em>ports-astrology</em>, <em>ports-biology</em>, etc au lieu de spécifier simplement <em>ports-all</em>). Cependant puisque les arborescences <span class=filename>doc</span> et <span class=filename>www</span> ne disposent pas de catalogues spécifiques à chaque langue, vous devez utiliser une des nombreuses fonctions de CVSup: le fichier <span class=filename>refuse</span>.</p></div><div class=paragraph><p>Le fichier <span class=filename>refuse</span> indique essentiellement à CVSup qu’il ne doit pas télécharger chaque fichier d’un catalogue; en d’autre termes, il dit au client de <em>refuser</em> certains fichiers du serveur. Le fichier <span class=filename>refuse</span> peut être trouvé (ou, si vous n’en disposez pas encore d’un, doit être placé) dans <span class=filename>base/sup/</span>. <em>base</em> est défini dans votre <span class=filename>supfile</span>; notre répertoire <em>base</em> est défini en tant que <span class=filename>/var/db</span> ce qui signifie que le fichier <span class=filename>refuse</span> est par défaut <span class=filename>/var/db/sup/refuse</span>.</p></div><div class=paragraph><p>Le fichier <span class=filename>refuse</span> a un format très simple; il contient tout simplement les noms des fichiers ou des répertoires que vous ne désirez pas rapatrier. Par exemple, si vous ne pouvez parler d’autres langues que l’anglais ou un peu d’allemand, et vous ne ressentez pas le besoin de lire la traduction en allemand de la documentation, vous pouvez mettre ce qui suit dans le fichier <span class=filename>refuse</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>doc/bn_<span class=k>*</span>
doc/da_<span class=k>*</span>
doc/de_<span class=k>*</span>
doc/el_<span class=k>*</span>
doc/es_<span class=k>*</span>
doc/fr_<span class=k>*</span>
doc/it_<span class=k>*</span>
doc/ja_<span class=k>*</span>
doc/nl_<span class=k>*</span>
doc/no_<span class=k>*</span>
doc/pl_<span class=k>*</span>
doc/pt_<span class=k>*</span>
doc/ru_<span class=k>*</span>
doc/sr_<span class=k>*</span>
doc/tr_<span class=k>*</span>
doc/zh_<span class=k>*</span></code></pre></div></div><div class=paragraph><p>et ainsi de suite pour les autres langues (vous pouvez en trouver une liste complète en parcourant le <a href=http://www.FreeBSD.org/cgi/cvsweb.cgi/>référentiel CVS de FreeBSD</a>).</p></div><div class=paragraph><p>Avec cette fonction très utile, les utilisateurs disposant d’une connexion lente ou payant le temps de connexion à la minute seront en mesure d’économiser de précieuses minutes comme ils n’auront plus du tout besoin de télécharger des fichiers qu’ils n’utiliseront jamais. Pour plus d’information sur les fichiers <span class=filename>refuse</span> et d’autres caractéristiques intéressantes de CVSup, consultez sa page de manuel.</p></div></div></div><div class=sect3><h4 id=_exécuter_cvsup>A.5.4. Exécuter CVSup<a class=anchor href=#_exécuter_cvsup></a></h4><div class=paragraph><p>Vous êtes maintenant prêt à essayer de faire une mise à jour. La ligne de commande à utiliser est très simple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cvsup supfile</span></code></pre></div></div><div class=paragraph><p>où <span class=filename>supfile</span> est bien sûr le nom du fichier <span class=filename>supfile</span> que vous venez de créer. Si vous êtes sous X11, <code>cvsup</code> affichera une interface graphique avec des boutons pour les opérations courantes. Appuyez sur le bouton btn[go] et suivez le déroulement des opérations.</p></div><div class=paragraph><p>Comme, dans cet l’exemple, vous mettez directement à jour votre arborescence <span class=filename>/usr/src</span>, vous devrez exécuter le programme en tant que <code>root</code> de façon à ce que <code>cvsup</code> ait le droit de mettre à jour vos fichiers. Comme vous venez juste de créer votre fichier de configuration et n’avez encore jamais utilisé le programme, il est compréhensible que cela vous rende nerveux. Il est facile de faire un essai sans toucher à vos précieux fichiers. Créez juste un nouveau répertoire quelque part et donnez-le en argument supplémentaire sur la ligne de commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/tmp/dest</span>
<span class=c># cvsup supfile /var/tmp/dest</span></code></pre></div></div><div class=paragraph><p>Le répertoire indiqué sera pris comme destination pour tous les fichiers modifiés. CVSup examinera les fichiers habituels dans <span class=filename>/usr/src</span>, mais ne les modifiera pas et n’en supprimera aucun. Les modifications atterriront dans <span class=filename>/var/tmp/dest/usr/src</span>. CVSup ne touchera pas non plus à ses fichiers d’état dans le répertoire de base, lorsqu’il est invoqué de cette manière. Les nouvelles versions de ces fichiers iront dans le répertoire indiqué. A partir du moment où vous avez les les droits en lecture sur <span class=filename>/usr/src</span>, vous n’avez pas besoin d’être <code>root</code> pour faire ce genre d’essai.</p></div><div class=paragraph><p>Si vous n’êtes pas sous X11, ou si vous n’aimez tout simplement pas les interfaces graphiques, vous devrez ajouter quelques options supplémentaires sur la ligne de commande de <code>cvsup</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cvsup -g -L 2 supfile</span></code></pre></div></div><div class=paragraph><p>L’option <code>-g</code> dit à CVSup de ne pas utiliser son interface graphique. C’est automatique si vous n’êtes pas sous X11, sinon vous devez le préciser.</p></div><div class=paragraph><p>L’option`-L 2` dit à CVSup d’afficher le détail de ce qu’il est en train de faire. Il y a trois niveaux de trace, de <code>-L 0</code> à <code>-L 2</code>. La valeur par défaut est de 0, ce qui équivaut à n’émettre que les messages d’erreur.</p></div><div class=paragraph><p>Il y a de nombreuses autres option disponibles. Pour en obtenir un résumé, tapez <code>cvsup -H</code>. Pour une description plus détaillée, reportez-vous aux pages de manuel.</p></div><div class=paragraph><p>Une fois que vous êtes satisfait de la façon dont se passent les mises à jour, vous pouvez mettre en place une exécution de CVSup à intervalles réguliers en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. Bien évidemment, vous ne devez pas laisser CVSup utiliser don interface graphique quand vous le lancez depuis <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>.</p></div></div><div class=sect3><h4 id=cvsup-collec>A.5.5. Catalogue de fichiers CVSup<a class=anchor href=#cvsup-collec></a></h4><div class=paragraph><p>Les catalogues de fichiers disponibles via CVSup sont organisés hiérarchiquement. Il y a quelques gros catalogues, qui sont divisés en plus petits sous-catalogues. Recevoir un gros catalogue équivaut à recevoir chacun de ces sous-catalogues. Les relations hiérarchiques entre les sous-catalogues sont décrites par les indentations dans la liste ci-dessous.</p></div><div class=paragraph><p>Les catalogues habituellement les plus employés sont <code>src-all</code>, et <code>ports-all</code>. Les autres catalogues ne sont utilisés que par de petits groupes de personnes pour des besoins particuliers, et certains sites miroir ne les mettent pas à disposition.</p></div><div class=dlist><dl><dt class=hdlist1><code>cvs-all release=cvs</code></dt><dd><p>Le référentiel CVS principal de FreeBSD, incluant les logiciels de chiffrement.</p><div class=dlist><dl><dt class=hdlist1><code>distrib release=cvs</code></dt><dd><p>Les fichiers ayant trait à la distribution et à la mise en place de sites miroir FreeBSD.</p></dd><dt class=hdlist1><code>doc-all release=cvs</code></dt><dd><p>Les sources du manuel FreeBSD et d’autres documentations. Cela de comprend pas les fichiers pour le site Web de FreeBSD.</p></dd><dt class=hdlist1><code>ports-all release=cvs</code></dt><dd><p>Le catalogue des logiciels portés de FreeBSD.</p><div id=cvsup-collec-pbase-warn class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Si vous ne voulez pas mettre à jour l’intégralité du catalogue <code>ports-all</code> (l’intégralité du catalogue des logiciels portés), mais utiliser un des sous-catalogues listés ci-dessous, assurez-vous de <em>toujours</em> mettre à jour le sous-catalogue <code>ports-base</code>! Dès qu’il y a un changement dans l’infrastructure de compilation des logiciels portés représentée par <code>ports-base</code>, il est certain que ces changements seront utilisés par un logiciel porté très rapidement. Donc, si vous ne mettez à jour que les logiciels portés en tant que tel et qu’ils utilisent certains des changements, il y a de grandes chances pour que leur compilation échoue avec de mystérieux messages d’erreur. La <em>première</em> chose à faire dans ce cas est de vérifier que votre sous-catalogue <code>ports-base</code> est à jour.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Si vous voulez construire votre propre version locale du fichier <span class=filename>ports/INDEX</span>, vous <em>devez</em> accepter le catalogue <code>ports-all</code> (l’intégralité du catalogue des logiciels portés). La construction de <span class=filename>ports/INDEX</span> avec une arborescence partielle n’est pas supportée. Consultez la <a href=https://docs.freebsd.org/fr/books/faq/#MAKE-INDEX>FAQ</a>.</p></div></td></tr></tbody></table></div><div class=dlist><dl><dt class=hdlist1><code>ports-accessibility release=cvs</code></dt><dd><p>Logiciels pour utilisateurs handicapées.</p></dd><dt class=hdlist1><code>ports-arabic release=cvs</code></dt><dd><p>Support pour l’arabe.</p></dd><dt class=hdlist1><code>ports-archivers release=cvs</code></dt><dd><p>Outils d’archivage.</p></dd><dt class=hdlist1><code>ports-astro release=cvs</code></dt><dd><p>Logiciels d’astronomie.</p></dd><dt class=hdlist1><code>ports-audio release=cvs</code></dt><dd><p>Support du son.</p></dd><dt class=hdlist1><code>ports-base release=cvs</code></dt><dd><p>L’infrastructure de compilation du catalogue des logiciels portés - divers fichiers situés dans les répertoires <span class=filename>Mk/</span> et <span class=filename>Tools/</span> sous-répertoires de la hiérarchie <span class=filename>/usr/ports</span>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Lisez l'<a href=#cvsup-collec-pbase-warn>important avertissement ci-dessus</a>: vous devriez <em>toujours</em> mettre à jour ce sous-catalogue, dès que vous mettez à jour une partie du catalogue des logiciels portés de FreeBSD!</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><code>ports-benchmarks release=cvs</code></dt><dd><p>Evaluation de performances.</p></dd><dt class=hdlist1><code>ports-biology release=cvs</code></dt><dd><p>Biologie.</p></dd><dt class=hdlist1><code>ports-cad release=cvs</code></dt><dd><p>Outils de conception assistée par ordinateur.</p></dd><dt class=hdlist1><code>ports-chinese release=cvs</code></dt><dd><p>Support pour le chinois.</p></dd><dt class=hdlist1><code>ports-comms release=cvs</code></dt><dd><p>Logiciels de communication.</p></dd><dt class=hdlist1><code>ports-converters release=cvs</code></dt><dd><p>Conversion entre codages de caratères.</p></dd><dt class=hdlist1><code>ports-databases release=cvs</code></dt><dd><p>Bases de données.</p></dd><dt class=hdlist1><code>ports-deskutils release=cvs</code></dt><dd><p>Les choses que l’on trouvait sur un bureau avant l’invention des ordinateurs.</p></dd><dt class=hdlist1><code>ports-devel release=cvs</code></dt><dd><p>Outils de développement.</p></dd><dt class=hdlist1><code>ports-dns release=cvs</code></dt><dd><p>Logiciels relatifs au DNS.</p></dd><dt class=hdlist1><code>ports-editors release=cvs</code></dt><dd><p>Editeurs.</p></dd><dt class=hdlist1><code>ports-emulators release=cvs</code></dt><dd><p>Emulateurs d’autres systèmes d’exploitation.</p></dd><dt class=hdlist1><code>ports-finance release=cvs</code></dt><dd><p>Applications concernant les finances et l’argent.</p></dd><dt class=hdlist1><code>ports-ftp release=cvs</code></dt><dd><p>Clients et serveurs FTP.</p></dd><dt class=hdlist1><code>ports-games release=cvs</code></dt><dd><p>Jeux.</p></dd><dt class=hdlist1><code>ports-german release=cvs</code></dt><dd><p>Support pour l’allemand.</p></dd><dt class=hdlist1><code>ports-graphics release=cvs</code></dt><dd><p>Outils graphiques.</p></dd><dt class=hdlist1><code>ports-hebrew release=cvs</code></dt><dd><p>Support de l’hébreu.</p></dd><dt class=hdlist1><code>ports-hungarian release=cvs</code></dt><dd><p>Support du hongrois.</p></dd><dt class=hdlist1><code>ports-irc release=cvs</code></dt><dd><p>Outils pour l’IRC.</p></dd><dt class=hdlist1><code>ports-japanese release=cvs</code></dt><dd><p>Support pour le japonais.</p></dd><dt class=hdlist1><code>ports-java release=cvs</code></dt><dd><p>Outils Java™.</p></dd><dt class=hdlist1><code>ports-korean release=cvs</code></dt><dd><p>Support pour le coréen.</p></dd><dt class=hdlist1><code>ports-lang release=cvs</code></dt><dd><p>Langages de programmation.</p></dd><dt class=hdlist1><code>ports-mail release=cvs</code></dt><dd><p>Logiciels de courrier électronique.</p></dd><dt class=hdlist1><code>ports-math release=cvs</code></dt><dd><p>Logiciels de calcul numérique.</p></dd><dt class=hdlist1><code>ports-mbone release=cvs</code></dt><dd><p>Applications MBone.</p></dd><dt class=hdlist1><code>ports-misc release=cvs</code></dt><dd><p>Utilitaires divers.</p></dd><dt class=hdlist1><code>ports-multimedia release=cvs</code></dt><dd><p>Logiciels pour le multimedia.</p></dd><dt class=hdlist1><code>ports-net release=cvs</code></dt><dd><p>Logiciels réseau.</p></dd><dt class=hdlist1><code>ports-net-im release=cvs</code></dt><dd><p>Logiciels de messagerie instantanée.</p></dd><dt class=hdlist1><code>ports-net-mgmt release=cvs</code></dt><dd><p>Logiciels de gestion des réseaux.</p></dd><dt class=hdlist1><code>ports-net-p2p release=cvs</code></dt><dd><p>Logiciels pour le "peer to peer".</p></dd><dt class=hdlist1><code>ports-news release=cvs</code></dt><dd><p>Logiciels pour les forums de discussion USENET.</p></dd><dt class=hdlist1><code>ports-palm release=cvs</code></dt><dd><p>Logiciels de support des machines Palm™.</p></dd><dt class=hdlist1><code>ports-polish release=cvs</code></dt><dd><p>Support pour le polonais.</p></dd><dt class=hdlist1><code>ports-ports-mgmt release=cvs</code></dt><dd><p>Utilitaires pour la gestion des logiciels portés et des paquetages.</p></dd><dt class=hdlist1><code>ports-portuguese release=cvs</code></dt><dd><p>Support pour le portugais.</p></dd><dt class=hdlist1><code>ports-print release=cvs</code></dt><dd><p>Logiciels d’impression.</p></dd><dt class=hdlist1><code>ports-russian release=cvs</code></dt><dd><p>Support pour le russe.</p></dd><dt class=hdlist1><code>ports-science release=cvs</code></dt><dd><p>Science.</p></dd><dt class=hdlist1><code>ports-security release=cvs</code></dt><dd><p>Outils de sécurité.</p></dd><dt class=hdlist1><code>ports-shells release=cvs</code></dt><dd><p>Interpréteurs de commandes.</p></dd><dt class=hdlist1><code>ports-sysutils release=cvs</code></dt><dd><p>Utilitaires système.</p></dd><dt class=hdlist1><code>ports-textproc release=cvs</code></dt><dd><p>Outils de traitement de texte (sauf les logiciels de publication assistée par ordinateur).</p></dd><dt class=hdlist1><code>ports-ukrainian release=cvs</code></dt><dd><p>Support de l’ukrainien.</p></dd><dt class=hdlist1><code>ports-vietnamese release=cvs</code></dt><dd><p>Support du vietnamien.</p></dd><dt class=hdlist1><code>ports-www release=cvs</code></dt><dd><p>Logiciels concernant le World Wide Web.</p></dd><dt class=hdlist1><code>ports-x11 release=cvs</code></dt><dd><p>Logiciel pour le système X window.</p></dd><dt class=hdlist1><code>ports-x11-clocks release=cvs</code></dt><dd><p>Horloges pour X11.</p></dd><dt class=hdlist1><code>ports-x11-drivers release=cvs</code></dt><dd><p>pilotes de périphérique X11.</p></dd><dt class=hdlist1><code>ports-x11-fm release=cvs</code></dt><dd><p>Gestionnaires de fichiers pour X11.</p></dd><dt class=hdlist1><code>ports-x11-fonts release=cvs</code></dt><dd><p>Polices de caractères et outils associés pour X11.</p></dd><dt class=hdlist1><code>ports-x11-toolkits release=cvs</code></dt><dd><p>"Toolkits" X11.</p></dd><dt class=hdlist1><code>ports-x11-servers release=cvs</code></dt><dd><p>Serveurs X11.</p></dd><dt class=hdlist1><code>ports-x11-themes release=cvs</code></dt><dd><p>Thèmes X11.</p></dd><dt class=hdlist1><code>ports-x11-wm release=cvs</code></dt><dd><p>Gestionnaires de fenêtres pour X11.</p></dd></dl></div></dd><dt class=hdlist1><code>projects-all release=cvs</code></dt><dd><p>Les sources présentes dans le dépots des projets FreeBSD.</p></dd><dt class=hdlist1><code>src-all release=cvs</code></dt><dd><p>Les sources du système FreeBSD, comprenant les logiciels de chiffrement.</p><div class=dlist><dl><dt class=hdlist1><code>src-base release=cvs</code></dt><dd><p>Divers fichiers en haut de la hiérarchie <span class=filename>/usr/src</span>.</p></dd><dt class=hdlist1><code>src-bin release=cvs</code></dt><dd><p>Programmes utilisateurs qui peuvent être utiles en mode mono-utilisateur (<span class=filename>/usr/src/bin</span>).</p></dd><dt class=hdlist1><code>src-cddl release=cvs</code></dt><dd><p>Utilitaires et bibliothèques sous licence CDDL (<span class=filename>/usr/src/cddl</span>).</p></dd><dt class=hdlist1><code>src-contrib release=cvs</code></dt><dd><p>Utilitaires et bibliothèques d’origine indépendante du projet FreeBSD, employés à peu près tels quels (<span class=filename>/usr/src/contrib</span>).</p></dd><dt class=hdlist1><code>src-crypto release=cvs</code></dt><dd><p>Utilitaires et bibliothèques pour le chiffrement d’origine indépendante du projet FreeBSD, employés à peu près tels quels (<span class=filename>/usr/src/crypto</span>).</p></dd><dt class=hdlist1><code>src-eBones release=cvs</code></dt><dd><p>Kerberos et DES (<span class=filename>/usr/src/eBones</span>). Non utilisés dans les versions de FreeBSD actuellement publiées.</p></dd><dt class=hdlist1><code>src-etc release=cvs</code></dt><dd><p>Fichiers de configuration du système (<span class=filename>/usr/src/etc</span>).</p></dd><dt class=hdlist1><code>src-games release=cvs</code></dt><dd><p>Jeux (<span class=filename>/usr/src/games</span>).</p></dd><dt class=hdlist1><code>src-gnu release=cvs</code></dt><dd><p>Utilitaires soumis à la licence publique GNU (<span class=filename>/usr/src/gnu</span>).</p></dd><dt class=hdlist1><code>src-include release=cvs</code></dt><dd><p>Fichiers d’entête (<span class=filename>/usr/src/include</span>).</p></dd><dt class=hdlist1><code>src-kerberos5 release=cvs</code></dt><dd><p>Logiciel de sécurité Kerberos5 (<span class=filename>/usr/src/kerberos5</span>).</p></dd><dt class=hdlist1><code>src-kerberosIV release=cvs</code></dt><dd><p>Logiciel de sécurité KerberosIV (<span class=filename>/usr/src/kerberosIV</span>).</p></dd><dt class=hdlist1><code>src-lib release=cvs</code></dt><dd><p>Bibliothèques (<span class=filename>/usr/src/lib</span>).</p></dd><dt class=hdlist1><code>src-libexec release=cvs</code></dt><dd><p>Programmes système normalement exécutés par d’autres programmes (<span class=filename>/usr/src/libexec</span>).</p></dd><dt class=hdlist1><code>src-release release=cvs</code></dt><dd><p>Fichiers nécessaires à la génération d’une version publiable de FreeBSD (<span class=filename>/usr/src/release</span>).</p></dd><dt class=hdlist1><code>src-rescue release=cvs</code></dt><dd><p>Programmes liés en statique pour les dépannages d’urgence; consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a> (<span class=filename>/usr/src/rescue</span>).</p></dd><dt class=hdlist1><code>src-sbin release=cvs</code></dt><dd><p>Utilitaires système pour le mode mono-utilisateur (<span class=filename>/usr/src/sbin</span>).</p></dd><dt class=hdlist1><code>src-secure release=cvs</code></dt><dd><p>Commandes et bibliothèques pour le chiffrage (<span class=filename>/usr/src/secure</span>).</p></dd><dt class=hdlist1><code>src-share release=cvs</code></dt><dd><p>Fichiers qui peuvent être partagés par plusieurs systèmes (<span class=filename>/usr/src/share</span>).</p></dd><dt class=hdlist1><code>src-sys release=cvs</code></dt><dd><p>Le noyau (<span class=filename>/usr/src/sys</span>).</p></dd><dt class=hdlist1><code>src-sys-crypto release=cvs</code></dt><dd><p>Code du noyau destiné au chiffrement (<span class=filename>/usr/src/sys/crypto</span>).</p></dd><dt class=hdlist1><code>src-tools release=cvs</code></dt><dd><p>Divers outils pour la maintenance de FreeBSD (<span class=filename>/usr/src/tools</span>).</p></dd><dt class=hdlist1><code>src-usrbin release=cvs</code></dt><dd><p>Outils utilisateur (<span class=filename>/usr/src/usr.bin</span>).</p></dd><dt class=hdlist1><code>src-usrsbin release=cvs</code></dt><dd><p>Utilitaires système (<span class=filename>/usr/src/usr.sbin</span>).</p></dd></dl></div></dd><dt class=hdlist1><code>www release=cvs</code></dt><dd><p>Les sources du site WWW de FreeBSD.</p></dd></dl></div></dd><dt class=hdlist1><code>distrib release=self</code></dt><dd><p>Fichiers de configuration du serveur CVSup. Utilisés par les sites miroir CVSup.</p></dd><dt class=hdlist1><code>gnats release=current</code></dt><dd><p>Base de données GNATS d’historique des bogues.</p></dd><dt class=hdlist1><code>mail-archive release=current</code></dt><dd><p>Archives des listes de diffusion FreeBSD.</p></dd><dt class=hdlist1><code>www release=current</code></dt><dd><p>Les fichiers/données WWW publiés (pas les fichiers source). Utilisés par les sites miroir WWW.</p></dd></dl></div></div><div class=sect3><h4 id=_pour_plus_dinformations_2>A.5.6. Pour plus d’informations<a class=anchor href=#_pour_plus_dinformations_2></a></h4><div class=paragraph><p>Pour la FAQ de CVSup et d’autres informations concernant CVSup, consultez la <a href=http://www.cvsup.org>page Web de CVSup</a>.</p></div><div class=paragraph><p>La plupart des discussions relatives à l’utilisation de CVSup sous FreeBSD ont lieu sur la <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>liste de diffusion pour les discussions techniques sur FreeBSD</a>. Les nouvelles versions du logiciel y sont annoncés ainsi que sur la <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>liste de diffusion pour les annonces relatives à FreeBSD</a>.</p></div><div class=paragraph><p>Pour toutes les questions et rapports de bogues concernant CVSup, consultez la <a href=http://www.cvsup.org/faq.html#bugreports>FAQ CVSup</a>.</p></div></div><div class=sect3><h4 id=cvsup-mirrors>A.5.7. Sites CVSup<a class=anchor href=#cvsup-mirrors></a></h4><div class=paragraph><p>Des serveurs <a href=#cvsup>CVSup</a> pour FreeBSD fonctionnent aux sites suivants:</p></div></div></div><div class=sect2><h3 id=portsnap>A.6. Utiliser Portsnap<a class=anchor href=#portsnap></a></h3><div class=sect3><h4 id=portsnap-intro>A.6.1. Introduction<a class=anchor href=#portsnap-intro></a></h4><div class=paragraph><p>Portsnap est un système de distribution sécurisée du catalogue des logiciels portés de FreeBSD. Approximativement chaque heure, un "instantané" du catalogue des logiciels portés est généré, rassemblé et signé de manière chiffrée. Les fichiers résultants sont alors distribués par l’intermédiaire du protocole HTTP.</p></div><div class=paragraph><p>Tout comme CVSup, Portsnap utilise un modèle de mise à jour de type <em>pull</em>: le catalogue des logiciels portés packagé et signé est placé sur un serveur Web qui attend les requêtes des clients. Les utilisateurs doivent soit exécuter manuellement <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> pour télécharger les mises à jour, soit configurer <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> pour un téléchargement régulier et automatique des mises à jour.</p></div><div class=paragraph><p>Pour des raisons techniques, Portsnap ne met pas à jour le catalogue des logiciels portés directement dans le répertoire <span class=filename>/usr/ports</span>; le logiciel travaille plutôt par défaut sur une version compressée de l’arborescence des logiciels portés dans le répertoire <span class=filename>/var/db/portsnap</span>. Cette copie compressée est ensuite utilisée pour mettre à jour le catalogue des logiciels portés.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si Portsnap est installé à partir du catalogue des logiciels portés de FreeBSD, alors l’emplacement par défaut pour son instantané compressé sera <span class=filename>/usr/local/portsnap</span> au lieu de <span class=filename>/var/db/portsnap</span>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=portsnap-install>A.6.2. Installation<a class=anchor href=#portsnap-install></a></h4><div class=paragraph><p>Sous FreeBSD 6.0 et les versions plus récentes, Portsnap fait partie du système de base de FreeBSD. Sous des versions plus anciennes de FreeBSD, il peut être installé à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portsnap/>ports-mgmt/portsnap</a>.</p></div></div><div class=sect3><h4 id=portsnap-config>A.6.3. Configuration de Portsnap<a class=anchor href=#portsnap-config></a></h4><div class=paragraph><p>L’exécution de Portsnap est contrôlée par le fichier de configuration <span class=filename>/etc/portsnap.conf</span>. Pour la plupart des utilisateurs, le fichier de configuration par défaut sera suffisant; pour plus de détails, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap.conf&amp;sektion=5&amp;format=html">portsnap.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si Portsnap est installé à partir du catalogue des logiciels portés, il utilisera <span class=filename>/usr/local/etc/portsnap.conf</span> comme fichier de configuration au lieu de <span class=filename>/etc/portsnap.conf</span>. Ce fichier n’est pas créé lors de l’installation du logiciel, mais un fichier d’exemple est fourni; pour le copier à son emplacement correct, utilisez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/etc  cp portsnap.conf.sample portsnap.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_exécuter_portsnap_pour_la_première_fois>A.6.4. Exécuter Portsnap pour la première fois<a class=anchor href=#_exécuter_portsnap_pour_la_première_fois></a></h4><div class=paragraph><p>Au premier lancement de la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a>, il sera nécessaire de télécharger un instantané compressé de l’intégralité de l’arborescence des logiciels portés dans <span class=filename>/var/db/portsnap</span> (ou <span class=filename>/usr/local/portsnap</span> si Portsnap a été installé à partir du catalogue des logiciels portés). Au début de l’année 2006, cela représentait un téléchargement d’environ 41 Mo.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span></code></pre></div></div><div class=paragraph><p>Une fois que l’instantané compressé a été récupéré, une copie utilisable de l’arborescence des logiciels portés peut être extraite dans le répertoire <span class=filename>/usr/ports</span>. Cela est nécessaire même si une arborescence a déjà été créée dans ce répertoire (par exemple en utilisant CVSup), puisque cela met en place une version de référence à partir de laquelle <code>portsnap</code> peut déterminer plus tard quelles parties du catalogue des logiciels portés a besoin d’une mise à jour.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans l’installation par défaut de FreeBSD <span class=filename>/usr/ports</span> n’est pas créé. Si vous utilisez FreeBSD 6.0-RELEASE, ce répertoire doit être créé avant d’utiliser la commande <code>portsnap</code>. Sur les versions de FreeBSD plus récentes ou de Portsnap, cette création est effectuée automatiquement à la premiere utilisation de la commande <code>portsnap</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_mettre_à_jour_larborescence_des_logiciels_portés>A.6.5. Mettre à jour l’arborescence des logiciels portés<a class=anchor href=#_mettre_à_jour_larborescence_des_logiciels_portés></a></h4><div class=paragraph><p>Après qu’un instantané initial du catalogue des logiciels portés ait été récupéré puis décompressé dans le répertoire <span class=filename>/usr/ports</span>, la mise à jour du catalogue se divise en deux étapes: la récupération (<em>fetch</em>) des mises à jour de l’instantané, et leur utilisation pour mettre à jour (<em>update</em>) le catalogue des logiciels portés en tant que tel. Ces deux étapes peuvent être effectuées par l’intermédiaire d’une seule commande <code>portsnap</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch update</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Des versions anciennes de <code>portsnap</code> ne supporte pas cette syntaxe; en cas d’échec, utilisez à la place ceci:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span>
<span class=c># portsnap update</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_exécuter_portsnap_à_partir_de_cron>A.6.6. Exécuter Portsnap à partir de cron<a class=anchor href=#_exécuter_portsnap_à_partir_de_cron></a></h4><div class=paragraph><p>Afin d’éviter tout problème "d’embouteillage" lors de l’accès aux serveurs Portsnap, <code>portsnap fetch</code> ne fonctionnera pas à partir d’une tâche <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. Il existe, à la place, une commande <code>portsnap cron</code> spécifique, qui patiente durant un délai aléatoire pouvant aller jusqu’à 3600 secondes avant de récupérer les mises à jour.</p></div><div class=paragraph><p>De plus, il est fortement recommandé de ne pas exécuter <code>portsnap update</code> à partir d’une tâche <code>cron</code>, puisque cela peut être à l’origine de graves problèmes si la commande a lieu au même moment qu’un logiciel porté est en train d’être compilé ou installé. Cependant, les fichiers <span class=filename>INDEX</span> peuvent être mis à jour sans risque, et cela peut être fait en passant l’indicateur <code>-I</code> à la commande <code>portsnap</code> (bien entendu si <code>portsnap -I update</code> est exécuté à par <code>cron</code>, il sera alors nécessaire de lancer <code>portsnap update</code> sans l’option <code>-I</code> ultérieurement pour mettre à jour le reste de l’arborescence).</p></div><div class=paragraph><p>L’ajout de la ligne suivante dans le fichier <span class=filename>/etc/crontab</span> demandera à <code>portsnap</code> de mettre à jour son instantané compressé et les fichiers <span class=filename>INDEX</span> du répertoire <span class=filename>/usr/ports</span>, et enverra un courrier électronique si un logiciel porté installé n’est pas à jour:</p></div><div class="literalblock programlisting"><div class=content><pre>0 3 * * * root portsnap -I cron update  pkg_version -vIL=</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si l’horloge système n’est pas positionnée sur le fuseau horaire local, remplacez <code>3</code> par une valeur quelconque comprise entre 0 et 23, afin de répartir de manière plus équilibrée la charge sur les serveurs Portsnap.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Des versions anciennes de <code>portsnap</code> ne supportent pas l’utilisation de commandes multiples (par exemple <code>cron update</code>) lors de la même invocation de <code>portsnap</code>. Si la ligne précédente échoue, essayez de remplacer <code>portsnap -I cron update</code> par <code>portsnap cron portsnap -I update</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=cvs-tags>A.7. Etiquettes CVS<a class=anchor href=#cvs-tags></a></h3><div class=paragraph><p>Quand on récupère ou l’on met à jour les sources en utilisant cvs ou CVSup, une étiquette de révision doit être spécifiée. Une étiquette de révision fait référence soit à une branche particulière de développement de FreeBSD, soit à un moment particulier dans le temps. Le premier type d’étiquette est nommé "étiquette de branche", le second type "étiquette de publication" - <em>release tags</em>.</p></div><div class=sect3><h4 id=_etiquettes_de_branche>A.7.1. Etiquettes de branche<a class=anchor href=#_etiquettes_de_branche></a></h4><div class=paragraph><p>Toutes ces étiquettes, à l’exception de l’étiquette <code>HEAD</code> (qui est une étiquette toujours valide), ne s’appliquent qu’à l’arborescence <span class=filename>src/</span>. Il n’y a pas de branche pour les arborescences <span class=filename>ports/</span>, <span class=filename>doc/</span>, et <span class=filename>www/</span>.</p></div><div class=dlist><dl><dt class=hdlist1>HEAD</dt><dd><p>Nom symbolique pour la branche principale de développement, ou FreeBSD-CURRENT. C’est aussi la valeur par défaut lorsque la révision n’est pas précisée.</p><div class=paragraph><p>Sous CVSup, cette étiquette est représentée par un <code>.</code> (ce n’est pas une ponctuation, mais bien le caractère <code>.</code>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sous CVS, c’est la valeur par défaut quand aucune étiquette de révision n’est précisée. Ce n’est généralement <em>pas</em> une bonne idée de récupérer ou mettre à jour vers les sources CURRENT sur une machine STABLE, à moins que cela ne soit vraiment votre intention.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>RELENG_6</dt><dd><p>Branche de développement pour FreeBSD-6.X, également connue sous le nom de FreeBSD 6-STABLE.</p></dd><dt class=hdlist1>RELENG_6_2</dt><dd><p>Branche de publication de la version FreeBSD-6.2, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_6_1</dt><dd><p>Branche de publication de la version FreeBSD-6.1, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_6_0</dt><dd><p>Branche de publication de la version FreeBSD-6.0, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_5</dt><dd><p>Branche de développement pour FreeBSD-5.X, également connue sous le nom de FreeBSD 5-STABLE.</p></dd><dt class=hdlist1>RELENG_5_5</dt><dd><p>Branche de publication de la version FreeBSD-5.5, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_5_4</dt><dd><p>Branche de publication de la version FreeBSD-5.4, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_5_3</dt><dd><p>Branche de publication de la version FreeBSD-5.3, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_5_2</dt><dd><p>Branche de publication des versions FreeBSD-5.2 et FreeBSD-5.2.1, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_5_1</dt><dd><p>Branche de publication de la version FreeBSD-5.1, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_5_0</dt><dd><p>Branche de publication de la version FreeBSD-5.0, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4</dt><dd><p>Branche de développement de FreeBSD-4.X, aussi connue sous le nom de FreeBSD 4-STABLE.</p></dd><dt class=hdlist1>RELENG_4_11</dt><dd><p>Branche de publication de la version FreeBSD-4.11, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_10</dt><dd><p>Branche de publication de la version FreeBSD-4.10, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_9</dt><dd><p>Branche de publication de la version FreeBSD-4.9, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_8</dt><dd><p>Branche de publication de la version FreeBSD-4.8, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_7</dt><dd><p>Branche de publication de la version FreeBSD-4.7, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_6</dt><dd><p>Branche de publication des versions FreeBSD-4.6 et FreeBSD-4.6.2, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_5</dt><dd><p>Branche de publication de la version FreeBSD-4.5, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_4</dt><dd><p>Branche de publication de la version FreeBSD-4.4, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_4_3</dt><dd><p>Branche de publication de la version FreeBSD-4.3, utilisée uniquement pour les avis de sécurité et autres correctifs de problèmes critiques.</p></dd><dt class=hdlist1>RELENG_3</dt><dd><p>Branche de développement de FreeBSD-3.X, aussi connue sous le nom de 3.X-STABLE.</p></dd><dt class=hdlist1>RELENG_2_2</dt><dd><p>Branche de développement de FreeBSD-2.2.X, aussi connue sous le nom de 2.2-STABLE. Cette branche est en grande partie obsolète.</p></dd></dl></div></div><div class=sect3><h4 id=_etiquettes_de_publication>A.7.2. Etiquettes de publication<a class=anchor href=#_etiquettes_de_publication></a></h4><div class=paragraph><p>Ces étiquettes font référence à un moment bien précis dans le temps quand une version particulière de FreeBSD a été publiée. Le processus d’ingénierie des publications est documenté en détails dans les documents <a href=https://www.FreeBSD.org/releng/>Information sur la publication des versions</a> et <a href=https://docs.freebsd.org/en/articles/releng/#release-proc>Processus de publication</a>. L’arborescence <span class=filename>src</span> utilise des étiquettes commençant par <code>RELENG_</code>. Les arborescences <span class=filename>ports</span> et <span class=filename>doc</span> utilisent des étiquettes dont les noms commencent par <code>RELEASE</code>. Enfin, l’arborescence <span class=filename>www</span> ne bénéficie pas d’étiquette particulière pour les publications.</p></div><div class=dlist><dl><dt class=hdlist1>RELENG_6_2_0_RELEASE</dt><dd><p>FreeBSD 6.2</p></dd><dt class=hdlist1>RELENG_6_1_0_RELEASE</dt><dd><p>FreeBSD 6.1</p></dd><dt class=hdlist1>RELENG_6_0_0_RELEASE</dt><dd><p>FreeBSD 6.0</p></dd><dt class=hdlist1>RELENG_5_5_0_RELEASE</dt><dd><p>FreeBSD 5.5</p></dd><dt class=hdlist1>RELENG_5_4_0_RELEASE</dt><dd><p>FreeBSD 5.4</p></dd><dt class=hdlist1>RELENG_4_11_0_RELEASE</dt><dd><p>FreeBSD 4.11</p></dd><dt class=hdlist1>RELENG_5_3_0_RELEASE</dt><dd><p>FreeBSD 5.3</p></dd><dt class=hdlist1>RELENG_4_10_0_RELEASE</dt><dd><p>FreeBSD 4.10</p></dd><dt class=hdlist1>RELENG_5_2_1_RELEASE</dt><dd><p>FreeBSD 5.2.1</p></dd><dt class=hdlist1>RELENG_5_2_0_RELEASE</dt><dd><p>FreeBSD 5.2</p></dd><dt class=hdlist1>RELENG_4_9_0_RELEASE</dt><dd><p>FreeBSD 4.9</p></dd><dt class=hdlist1>RELENG_5_1_0_RELEASE</dt><dd><p>FreeBSD 5.1</p></dd><dt class=hdlist1>RELENG_4_8_0_RELEASE</dt><dd><p>FreeBSD 4.8</p></dd><dt class=hdlist1>RELENG_5_0_0_RELEASE</dt><dd><p>FreeBSD 5.0</p></dd><dt class=hdlist1>RELENG_4_7_0_RELEASE</dt><dd><p>FreeBSD 4.7</p></dd><dt class=hdlist1>RELENG_4_6_2_RELEASE</dt><dd><p>FreeBSD 4.6.2</p></dd><dt class=hdlist1>RELENG_4_6_1_RELEASE</dt><dd><p>FreeBSD 4.6.1</p></dd><dt class=hdlist1>RELENG_4_6_0_RELEASE</dt><dd><p>FreeBSD 4.6</p></dd><dt class=hdlist1>RELENG_4_5_0_RELEASE</dt><dd><p>FreeBSD 4.5</p></dd><dt class=hdlist1>RELENG_4_4_0_RELEASE</dt><dd><p>FreeBSD 4.4</p></dd><dt class=hdlist1>RELENG_4_3_0_RELEASE</dt><dd><p>FreeBSD 4.3</p></dd><dt class=hdlist1>RELENG_4_2_0_RELEASE</dt><dd><p>FreeBSD 4.2</p></dd><dt class=hdlist1>RELENG_4_1_1_RELEASE</dt><dd><p>FreeBSD 4.1.1</p></dd><dt class=hdlist1>RELENG_4_1_0_RELEASE</dt><dd><p>FreeBSD 4.1</p></dd><dt class=hdlist1>RELENG_4_0_0_RELEASE</dt><dd><p>FreeBSD 4.0</p></dd><dt class=hdlist1>RELENG_3_5_0_RELEASE</dt><dd><p>FreeBSD-3.5</p></dd><dt class=hdlist1>RELENG_3_4_0_RELEASE</dt><dd><p>FreeBSD-3.4</p></dd><dt class=hdlist1>RELENG_3_3_0_RELEASE</dt><dd><p>FreeBSD-3.3</p></dd><dt class=hdlist1>RELENG_3_2_0_RELEASE</dt><dd><p>FreeBSD-3.2</p></dd><dt class=hdlist1>RELENG_3_1_0_RELEASE</dt><dd><p>FreeBSD-3.1</p></dd><dt class=hdlist1>RELENG_3_0_0_RELEASE</dt><dd><p>FreeBSD-3.0</p></dd><dt class=hdlist1>RELENG_2_2_8_RELEASE</dt><dd><p>FreeBSD-2.2.8</p></dd><dt class=hdlist1>RELENG_2_2_7_RELEASE</dt><dd><p>FreeBSD-2.2.7</p></dd><dt class=hdlist1>RELENG_2_2_6_RELEASE</dt><dd><p>FreeBSD-2.2.6</p></dd><dt class=hdlist1>RELENG_2_2_5_RELEASE</dt><dd><p>FreeBSD-2.2.5</p></dd><dt class=hdlist1>RELENG_2_2_2_RELEASE</dt><dd><p>FreeBSD-2.2.2</p></dd><dt class=hdlist1>RELENG_2_2_1_RELEASE</dt><dd><p>FreeBSD-2.2.1</p></dd><dt class=hdlist1>RELENG_2_2_0_RELEASE</dt><dd><p>FreeBSD-2.2.0</p></dd></dl></div></div></div><div class=sect2><h3 id=mirrors-afs>A.8. Sites AFS<a class=anchor href=#mirrors-afs></a></h3><div class=paragraph><p>Il y a des serveurs AFS pour FreeBSD sur les sites suivants:</p></div><div class=dlist><dl><dt class=hdlist1>Suède</dt><dd><p>Le chemin d’accès au fichiers est <span class=filename>/afs/stacken.kth.se/ftp/pub/FreeBSD/</span></p><div class="literalblock programlisting"><div class=content><pre>stacken.kth.se         # Stacken Computer Club, KTH, Suède
130.237.234.43         #hot.stacken.kth.se
130.237.237.230        #fishburger.stacken.kth.se
130.237.234.3          #milko.stacken.kth.se</pre></div></div><div class=paragraph><p>Responsable <a href=mailto:ftp@stacken.kth.se>ftp@stacken.kth.se</a></p></div></dd></dl></div></div><div class=sect2><h3 id=mirrors-rsync>A.9. Sites rsync<a class=anchor href=#mirrors-rsync></a></h3><div class=paragraph><p>Les sites suivants fournissent FreeBSD en utilisant le protocole rsync. L’utilitaire rsync fonctionne globalement de la même manière que la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, mais il dispose de plus d’options et utilise le protocole de mise à jour à distance rsync qui ne transfert que les différences entre deux ensembles de fichiers, ce qui accélère énormément la synchronisation par le réseau. C’est surtout utile si vous disposez d’un miroir du serveur FTP de FreeBSD, ou du référentiel CVS. La suite rsync est disponible sur de nombreux systèmes d’exploitation, et sous FreeBSD, voir le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> ou utilisez la version pré-compilée.</p></div><div class=dlist><dl><dt class=hdlist1>République Tchèque</dt><dd><p>rsync://ftp.cz.FreeBSD.org/</p><div class=paragraph><p>Collections disponibles:</p></div><div class=ulist><ul><li><p>ftp: un miroir partiel du serveur FTP FreeBSD.</p></li><li><p>FreeBSD: un miroir complet du serveur FTP FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Allemagne</dt><dd><p>rsync://grappa.unix-ag.uni-kl.de/</p><div class=paragraph><p>Collections disponibles:</p></div><div class=ulist><ul><li><p>freebsd-cvs: référentiel CVS FreeBSD complet.</p></li></ul></div><div class=paragraph><p>Cette machine est également miroir des référentiels CVS des projets NetBSD et OpenBSD, parmi d’autres.</p></div></dd><dt class=hdlist1>Hollande</dt><dd><p>rsync://ftp.nl.FreeBSD.org/</p><div class=paragraph><p>Collections disponibles:</p></div><div class=ulist><ul><li><p>vol/4/freebsd-core: un miroir complet du serveur FTP FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Thailande</dt><dd><p>rsync://ftp.tw.FreeBSD.org/</p><div class=paragraph><p>rsync://ftp2.tw.FreeBSD.org/</p></div><div class=paragraph><p>rsync://ftp6.tw.FreeBSD.org/</p></div><div class=paragraph><p>Collections disponibles:</p></div><div class=ulist><ul><li><p>FreeBSD: Un miroir complet du serveur FTP FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Royaume-Uni</dt><dd><p>rsync://rsync.mirror.ac.uk/</p><div class=paragraph><p>Collections disponibles:</p></div><div class=ulist><ul><li><p>ftp.freebsd.org: Un miroir complet du serveur FTP FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Etats Unis d’Amérique</dt><dd><p>rsync://ftp-master.FreeBSD.org/</p><div class=paragraph><p>Ce serveur ne pourra être utilisé que par les sites miroirs primaires FreeBSD.</p></div><div class=paragraph><p>Collections disponibles:</p></div><div class=ulist><ul><li><p>FreeBSD: l’archive principale du serveur FTP FreeBSD.</p></li><li><p>acl: la liste principale ACL de FreeBSD.</p><div class=paragraph><p>rsync://ftp13.FreeBSD.org/</p></div><div class=paragraph><p>Collections disponibles:</p></div></li><li><p>FreeBSD: Un miroir complet du serveur FTP FreeBSD.</p></li></ul></div></dd></dl></div></div></div></div><div class=sect1><h2 id=bibliography>Annexe B: Bibliographie<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>Bien que les pages de manuel soient la documentation de référence pour chaque facette du système d’exploitation FreeBSD, il est de notoriété publique qu’elles n’expliquent pas comment assembler les morceaux pour avoir un système d’exploitation qui tourne sans encombre. Il n’y a pour cela pas d’autre alternative qu’un bon livre sur l’administration UNIX® et un bon manuel utilisateur.</p></div><div class=sect2><h3 id=bibliography-freebsd>B.1. Livres magazines consacrés à FreeBSD<a class=anchor href=#bibliography-freebsd></a></h3><div class=paragraph><p><em>Livres revues internationaux:</em></p></div><div class=ulist><ul><li><p><a href=http://jdli.tw.FreeBSD.org/publication/book/freebsd2/index.htm>Utiliser FreeBSD</a> (en chinois traditionnel), publié par <a href=http://www.drmaster.com.tw/>Drmaster.</a>, 1997. ISBN 9-578-39435-7.</p></li><li><p>FreeBSD Unleashed (traduction en chinois simplifié), publié par <a href=http://www.hzbook.com/>China Machine Press</a>. ISBN 7-111-10201-0.</p></li><li><p>FreeBSD From Scratch First Edition (en chinois simplifié), publié par China Machine Press. ISBN 7-111-07482-3.</p></li><li><p>FreeBSD From Scratch Second Edition (en chinois simplifié), publié par China Machine Press. ISBN 7-111-10286-X.</p></li><li><p>Manuel FreeBSD (traduction en chinois simplifié), publié par <a href=http://www.ptpress.com.cn/>Posts Telecom Press</a>. ISBN 7-115-10541-3.</p></li><li><p>FreeBSD 3.x Internet (en chinois simplifié), publié par <a href=http://www.tup.tsinghua.edu.cn/>Tsinghua University Press</a>. ISBN 7-900625-66-6.</p></li><li><p>FreeBSD Windows (en chinois simplifié), ISBN 7-113-03845-X</p></li><li><p>FreeBSD Internet Services HOWTO (en chinois simplifié), ISBN 7-113-03423-3</p></li><li><p>FreeBSD pour les utilisateurs de PC 98 (en Japonais), publié par SHUWA System Co, LTD. ISBN 4-87966-468-5 C3055 P2900E.</p></li><li><p>FreeBSD (en Japonais), publié par CUTT. ISBN 4-906391-22-2 C3055 P2400E.</p></li><li><p><a href="http://www.shoeisha.com/book/Detail.asp?bid=650">Introduction complète à FreeBSD</a> (en Japonais), publié par <a href=http://www.shoeisha.co.jp/>Shoeisha Co., Ltd</a>. ISBN 4-88135-473-6 P3600E.</p></li><li><p><a href=http://www.ascii.co.jp/pb/book1/shinkan/detail/1322785.html>Kit de démarrage pour Unix personnel FreeBSD</a> (en Japonais), publié par <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1733-3 P3000E.</p></li><li><p>Manuel de référence FreeBSD (traduction en Japonais), publié par <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1580-2 P3800E.</p></li><li><p>FreeBSD avec méthode (en Allemand), publié par <a href=http://www.cul.de>Computer und Literatur Verlag</a>/Vertrieb Hanser, 1998. ISBN 3-932311-31-0.</p></li><li><p><a href=http://www.cul.de/freebsd.html>FreeBSD 4 - Installieren, Konfigurieren, Administrieren</a> (en Allemand), publié par <a href=http://www.cul.de>Computer und Literatur Verlag</a>, 2001. ISBN 3-932311-88-4.</p></li><li><p><a href=http://www.cul.de/freebsd.html>FreeBSD 5 - Installieren, Konfigurieren, Administrieren</a> (en Allemand), publié par <a href=http://www.cul.de>Computer und Literatur Verlag</a>, 2003. ISBN 3-936546-06-1.</p></li><li><p><a href=http://www.mitp.de/vmi/mitp/detail/pWert/1343/>FreeBSD de Luxe</a> (en Allemand), publié par <a href=http://www.mitp.de>Verlag Modere Industrie</a>, 2003. ISBN 3-8266-1343-0.</p></li><li><p><a href=http://www.pc.mycom.co.jp/FreeBSD/install-manual.html>Manuel d’installation et d’utilisation de FreeBSD</a> (en Japonais), publié par <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN 4-8399-0112-0.</p></li><li><p>Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo <em><a href=http://maxwell.itb.ac.id/>Construire un serveur Internet avec FreeBSD</a></em> (en Indonésien), publié par <a href=http://www.elexmedia.co.id/>Elex Media Komputindo</a>.</p></li><li><p>Absolute BSD: The Ultimate Guide to FreeBSD (traduction en chinois traditionnel), publié par <a href=http://www.grandtech.com.tw/>GrandTech Press</a>, 2003. ISBN 986-7944-92-5.</p></li><li><p><a href=http://www.twbsd.org/cht/book/>The FreeBSD 6.0 Book</a> (en chinois traditionnel), publié par Drmaster, 2006. ISBN 9-575-27878-X.</p></li></ul></div><div class=paragraph><p><em>Livres revues en langue anglaise:</em></p></div><div class=ulist><ul><li><p><a href=http://www.AbsoluteBSD.com/>Absolute BSD: The Ultimate Guide to FreeBSD</a>, publié par <a href=http://www.nostarch.com/>No Starch Press</a>, 2002. ISBN: 1886411743</p></li><li><p><a href=http://www.freebsdmall.com/cgi-bin/fm/bsdcomp>The Complete FreeBSD</a>, publié par <a href=http://www.oreilly.com/>O’Reilly</a>, 2003. ISBN: 0596005164</p></li><li><p><a href=http://www.freebsd-corp-net-guide.com/>The FreeBSD Corporate Networker’s Guide</a>, publié par <a href=http://www.awl.com/aw/>Addison-Wesley</a>, 2000. ISBN: 0201704811</p></li><li><p><a href=http://andrsn.stanford.edu/FreeBSD/introbook/>FreeBSD: An Open-Source Operating System for Your Personal Computer</a>, publié par The Bit Tree Press, 2001. ISBN: 0971204500</p></li><li><p>Teach Yourself FreeBSD in 24 Hours, publié par <a href=http://www.samspublishing.com/>Sams</a>, 2002. ISBN: 0672324245</p></li><li><p>FreeBSD unleashed, publié par <a href=http://www.samspublishing.com/>Sams</a>, 2006. ISBN: 0672328755</p></li><li><p>FreeBSD: The Complete Reference, publié <a href=http://books.mcgraw-hill.com>McGrawHill</a>, 2003. ISBN: 0072224096</p></li></ul></div></div><div class=sect2><h3 id=bibliography-userguides>B.2. Manuels d’utilisation<a class=anchor href=#bibliography-userguides></a></h3><div class=ulist><ul><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD User’s Reference Manual</em>. O’Reilly Associates, Inc., 1994. ISBN 1-56592-075-9</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD User’s Supplementary Documents</em>. O’Reilly Associates, Inc., 1994. ISBN 1-56592-076-7</p></li><li><p><em>UNIX in a Nutshell</em>. O’Reilly Associates, Inc., 1990. ISBN 093717520X</p></li><li><p>Mui, Linda. <em>What You Need To Know When You Can’t Find Your UNIX System Administrator</em>. O’Reilly Associates, Inc., 1995. ISBN 1-56592-104-6</p></li><li><p><a href=http://www.osu.edu/>L’Université de l’Etat d’Ohio</a> a écrit un <a href=http://8help.osu.edu/wks/unix_course/unix.html>Cours d’introduction à Unix</a> qui est disponible en ligne aux formats HTML et PostScript.</p><div class=paragraph><p>Une <a href=https://www.FreeBSD.org/doc/it_IT.ISO8859-15/books/unix-introduction/index.html>version</a> en Italien de ce document fait partie du projet de documentation FreeBSD Italien.</p></div></li><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Groupe d’utilisateurs japonais de FreeBSD</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/urm.html>Manuel de référence utilisateur de FreeBSD</a> (traduction en Japonais). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0088-4 P3800E.</p></li><li><p><a href=http://www.ed.ac.uk/>L’Université d’Edinburgh</a> a écrit un <a href=http://unixhelp.ed.ac.uk/>Guide en ligne</a> pour les nouveaux venus à l’environnement Unix.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-adminguides>B.3. Manuels d’administration<a class=anchor href=#bibliography-adminguides></a></h3><div class=ulist><ul><li><p>Albitz, Paul and Liu, Cricket. <em>DNS and BIND</em>, 4th Ed. O’Reilly Associates, Inc., 2001. ISBN 1-59600-158-4</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD System Manager’s Manual</em>. O’Reilly Associates, Inc., 1994. ISBN 1-56592-080-5</p></li><li><p>Costales, Brian, et al. <em>Sendmail</em>, 2nd Ed. O’Reilly Associates, Inc., 1997. ISBN 1-56592-222-0</p></li><li><p>Frisch, Æleen. <em>Essential System Administration</em>, 2nd Ed. O’Reilly Associates, Inc., 1995. ISBN 1-56592-127-5</p></li><li><p>Hunt, Craig. <em>TCP/IP Network Administration</em>, 2nd Ed. O’Reilly Associates, Inc., 1997. ISBN 1-56592-322-7</p></li><li><p>Nemeth, Evi. <em>UNIX System Administration Handbook</em>. 3rd Ed. Prentice Hall, 2000. ISBN 0-13-020601-6</p></li><li><p>Stern, Hal <em>Managing NFS and NIS</em> O’Reilly Associates, Inc., 1991. ISBN 0-937175-75-7</p></li><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Groupe d’utilisateurs japonais de FreeBSD</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/sam.html>Manuel de l’administrateur système FreeBSD</a> (traduction en Japonais). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0109-0 P3300E.</p></li><li><p>Dreyfus, Emmanuel. <a href=http://www.eyrolles.com/Informatique/Livre/9782212114638/>Cahiers de l’Admin: BSD</a> 2nde Ed. (en Français), Eyrolles, 2004. ISBN 2-212-11463-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-programmers>B.4. Manuels de programmation<a class=anchor href=#bibliography-programmers></a></h3><div class=ulist><ul><li><p>Asente, Paul, Converse, Diana, and Swick, Ralph. <em>X Window System Toolkit</em>. Digital Press, 1998. ISBN 1-55558-178-1</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Reference Manual</em>. O’Reilly Associates, Inc., 1994. ISBN 1-56592-078-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Supplementary Documents</em>. O’Reilly Associates, Inc., 1994. ISBN 1-56592-079-1</p></li><li><p>Harbison, Samuel P. and Steele, Guy L. Jr. <em>C: A Reference Manual</em>. 4th ed. Prentice Hall, 1995. ISBN 0-13-326224-3</p></li><li><p>Kernighan, Brian and Dennis M. Ritchie. <em>The C Programming Language</em>. 2nd Ed. PTR Prentice Hall, 1988. ISBN 0-13-110362-8</p></li><li><p>Lehey, Greg. <em>Porting UNIX Software</em>. O’Reilly Associates, Inc., 1995. ISBN 1-56592-126-7</p></li><li><p>Plauger, P. J. <em>The Standard C Library</em>. Prentice Hall, 1992. ISBN 0-13-131509-9</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codereading/>Code Reading: The Open Source Perspective</a>. Addison-Wesley, 2003. ISBN 0-201-79940-5</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codequality/>Code Quality: The Open Source Perspective</a>. Addison-Wesley, 2006. ISBN 0-321-16607-8</p></li><li><p>Stevens, W. Richard and Stephen A. Rago. <em>Advanced Programming in the UNIX Environment</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN 0-201-43307-9</p></li><li><p>Stevens, W. Richard. <em>UNIX Network Programming</em>. 2nd Ed, PTR Prentice Hall, 1998. ISBN 0-13-490012-X</p></li><li><p>Wells, Bill. "Writing Serial Drivers for UNIX". <em>Dr. Dobb’s Journal</em>. 19(15), December 1994. pp68-71, 97-99.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-osinternals>B.5. "Internes" du système d’exploitation<a class=anchor href=#bibliography-osinternals></a></h3><div class=ulist><ul><li><p>Andleigh, Prabhat K. <em>UNIX System Architecture</em>. Prentice-Hall, Inc., 1990. ISBN 0-13-949843-5</p></li><li><p>Jolitz, William. "Porting UNIX to the 386". <em>Dr. Dobb’s Journal</em>. January 1991-July 1992.</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John Quarterman <em>The Design and Implementation of the 4.3BSD UNIX Operating System</em>. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, <em>The Design and Implementation of the 4.3BSD UNIX Operating System: Answer Book</em>. Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9</p></li><li><p>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John Quarterman. <em>The Design and Implementation of the 4.4BSD Operating System</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4</p><div class=paragraph><p>(Le chapitre 2 de ce livre est disponible <a href=https://docs.freebsd.org/en/books/design-44bsd/>en ligne</a> en tant que partie du Projet de Documentation de FreeBSD, et le chapitre 9 <a href=http://www.netapp.com/tech_library/nfsbook.html>ici</a>.)</p></div></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil <em>The Design and Implementation of the FreeBSD Operating System</em>. Boston, Mass. : Addison-Wesley, 2004. ISBN 0-201-70245-2</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 1: The Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9</p></li><li><p>Schimmel, Curt. <em>Unix Systems for Modern Architectures</em>. Reading, Mass. : Addison-Wesley, 1994. ISBN 0-201-63338-8</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63495-3</p></li><li><p>Vahalia, Uresh. <em>UNIX Internals — The New Frontiers</em>. Prentice Hall, 1996. ISBN 0-13-101908-2</p></li><li><p>Wright, Gary R. and W. Richard Stevens. <em>TCP/IP Illustrated, Volume 2: The Implementation</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-security>B.6. Ouvrages de référence en matière de sécurité<a class=anchor href=#bibliography-security></a></h3><div class=ulist><ul><li><p>Cheswick, William R. and Steven M. Bellovin. <em>Firewalls and Internet Security: Repelling the Wily Hacker</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63357-4</p></li><li><p>Garfinkel, Simson and Gene Spafford. <em>Practical UNIX Internet Security</em>. 2nd Ed. O’Reilly Associates, Inc., 1996. ISBN 1-56592-148-8</p></li><li><p>Garfinkel, Simson. <em>PGP Pretty Good Privacy</em> O’Reilly Associates, Inc., 1995. ISBN 1-56592-098-8</p></li></ul></div></div><div class=sect2><h3 id=bibliography-hardware>B.7. Ouvrages de référence sur le matériel<a class=anchor href=#bibliography-hardware></a></h3><div class=ulist><ul><li><p>Anderson, Don and Tom Shanley. <em>Pentium Processor System Architecture</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5</p></li><li><p>Ferraro, Richard F. <em>Programmer’s Guide to the EGA, VGA, and Super VGA Cards</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7</p></li><li><p>Intel Corporation publie la documentation sur ses processeurs, circuits et standards sur son <a href=http://developer.intel.com/>site web développeur</a>, généralement sous forme de fichiers PDF.</p></li><li><p>Shanley, Tom. <em>80486 System Architecture</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40994-1</p></li><li><p>Shanley, Tom. <em>ISA System Architecture</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40996-8</p></li><li><p>Shanley, Tom. <em>PCI System Architecture</em>. 4th ed. Reading, Mass. : Addison-Wesley, 1999. ISBN 0-201-30974-2</p></li><li><p>Van Gilluwe, Frank. <em>The Undocumented PC</em>, 2nd Ed. Reading, Mass: Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8</p></li><li><p>Messmer, Hans-Peter. <em>The Indispensable PC Hardware Book</em>, 4th Ed. Reading, Mass: Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4</p></li></ul></div></div><div class=sect2><h3 id=bibliography-history>B.8. Histoire d’UNIX®<a class=anchor href=#bibliography-history></a></h3><div class=ulist><ul><li><p>Lion, John <em>Lion’s Commentary on UNIX, 6th Ed. With Source Code</em>. ITP Media Group, 1996. ISBN 1573980137</p></li><li><p>Raymond, Eric S. <em>The New Hacker’s Dictionary, 3rd edition</em>. MIT Press, 1996. ISBN 0-262-68092-0. Aussi connu sous le nom de <a href=http://www.catb.org/~esr/jargon/html/index.html>Jargon File</a></p></li><li><p>Salus, Peter H. <em>A quarter century of UNIX</em>. Addison-Wesley Publishing Company, Inc., 1994. ISBN 0-201-54777-5</p></li><li><p>Simon Garfinkel, Daniel Weise, Steven Strassmann. <em>The UNIX-HATERS Handbook</em>. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. Epuisé, mais disponible <a href=http://research.microsoft.com/~daniel/unix-haters.html>en ligne</a>.</p></li><li><p>Don Libes, Sandy Ressler <em>Life with UNIX</em> - special edition. Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7</p></li><li><p><em>The BSD family tree</em>. <a href=http://www.FreeBSD.org/cgi/cvsweb.cgi/src/shared/misc/bsd-family-tree>http://www.FreeBSD.org/cgi/cvsweb.cgi/src/shared/misc/bsd-family-tree</a> ou <a href=file://localhost/usr/shared/misc/bsd-family-tree>local</a> sur une machine FreeBSD.</p></li><li><p><em>The BSD Release Announcements collection</em>. 1997. <a href=http://www.de.FreeBSD.org/de/ftp/releases/>http://www.de.FreeBSD.org/de/ftp/releases/</a></p></li><li><p><em>Networked Computer Science Technical Reports Library</em>. <a href=http://www.ncstrl.org/>http://www.ncstrl.org/</a></p></li><li><p><em>Anciennes version de BSD du Computer Systems Research group (CSRG)</em>. <a href=http://www.mckusick.com/csrg/>http://www.mckusick.com/csrg/</a>: Ces 4 CDROMs incluent toutes les versions de BSD de 1BSD à 4.4BSD et 4.4BSD-Lite2 (mais malheureusement pas 2.11BSD). De plus le dernier CDROM contient les dernières sources et les fichiers SCCS.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-journals>B.9. Revues et journaux<a class=anchor href=#bibliography-journals></a></h3><div class=ulist><ul><li><p><em>The C/C++ Users Journal</em>. RD Publications Inc. ISSN 1075-2838</p></li><li><p><em>Sys Admin - The Journal for UNIX System Administrators</em> Miller Freeman, Inc., ISSN 1061-2688</p></li><li><p><em>freeX - Das Magazin für Linux - BSD - UNIX</em> (in German) Computer- und Literaturverlag GmbH, ISSN 1436-7033</p></li></ul></div></div></div></div><div class=sect1><h2 id=eresources>Annexe C: Ressources sur Internet<a class=anchor href=#eresources></a></h2><div class=sectionbody><div class=paragraph><p>L’évolution rapide de FreeBSD rend peu pratique le suivi des développements via des supports imprimés. Les supports électroniques sont le meilleur, sinon la plupart du temps le seul, moyen de se tenir au courant des dernières avancées. Comme FreeBSD est un effort basé sur le volontariat, la communauté des utilisateurs sert généralement de "service de support technique", le courrier électronique et les forums de discussion étant le meilleur moyen de contacter cette communauté.</p></div><div class=paragraph><p>Les points de contact les plus importants avec la communauté des utilisateurs de FreeBSD sont listés ci-dessous. Si vous connaissez d’autres ressources qui n’y figurent pas, communiquez-les s’il vous plaît à la <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>liste de diffusion du groupe de documentation de FreeBSD</a> de façon à ce qu’elles soient aussi mentionnées.</p></div><div class=sect2><h3 id=eresources-mail>C.1. Listes de diffusion<a class=anchor href=#eresources-mail></a></h3><div class=paragraph><p>Bien qu’un grand de nombre de développeurs de FreeBSD lisent les forums de discussion, nous ne pouvons vous garantir de réponse en temps et en heure à vos questions (ni même de réponse tout court) si vous ne les postez que sur un des forums <code>comp.unix.bsd.freebsd.*</code>. En adressant vos questions sur la liste de diffusion appropriée vous nous contacterez en même temps qu’un auditoire FreeBSD concentré, ce qui vous garantit invariablement une meilleure (ou tout au moins une plus rapide) réponse.</p></div><div class=paragraph><p>Les chartes d’utilisation pour les différentes listes sont données à la fin de ce document. <em>Lisez-les s’il vous plaît avant de vous inscrire ou d’envoyer du courrier à une liste</em>. La plupart des inscrits à nos listes reçoivent maintenant des centaines de messages en rapport à FreeBSD chaque jour, et en définissant des chartes et des règles d’utilisation, nous essayons de garder assez élevé le rapport signal/bruit sur les listes. Ne pas le faire verrait l’échec des listes de diffusion comme moyen efficace de communication pour le projet.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Si vous désirez tester votre capacité à envoyer du courrier aux listes FreeBSD, envoyez un message de test à la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-test>liste de diffusion de test</a>.</em> Veuillez ne pas envoyer de messages de test vers une autre liste.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En cas de doute sur la liste sur laquelle poser une question, lisez <a href=https://docs.freebsd.org/en/articles/freebsd-questions/>Comment obtenir les meilleurs résultats sur la liste de diffusion FreeBSD-questions</a>.</p></div><div class=paragraph><p>Avant de poster sur une liste de diffusion, veuillez apprendre à utiliser au mieux les listes de diffusion, comme par exemple éviter de relancer des discussions qui reviennent régulièrement, en lisant le document (FAQ) sur <a href=https://docs.freebsd.org/en/articles/mailing-list-faq/>les questions fréquemment posées au sujet des listes de diffusion</a>.</p></div><div class=paragraph><p>Des archives de toutes les listes de diffusion sont conservées et on peut effectuer des recherches sur le <a href=https://www.FreeBSD.org/search/>serveur World Wide Web de FreeBSD</a>. Les archives interrogeables par mots-clés offrent un excellent moyen de trouver des réponses aux questions fréquemment posées et devraient être consultées avant de poster une question.</p></div><div class=sect3><h4 id=eresources-summary>C.1.1. Résumé des listes de diffusion<a class=anchor href=#eresources-summary></a></h4><div class=paragraph><p><em>Listes générales:</em> les listes suivantes sont des listes générales auxquelles chacun est libre (et encouragé) de s’inscrire:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Liste</th><th class="tableblock halign-left valign-top">Objet</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/cvs-all>cvs-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toutes les modifications de l’arborescence des sources</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-advocacy>freebsd-advocacy</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Propagande FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>liste de diffusion pour les annonces relatives à FreeBSD</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Evénements et étapes importantes du projet</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions sur l’architecture et l’implémentation de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions concernant la maintenance de la base des données des rapports de bogue de FreeBSD et des outils rattachés</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Rapports de bogue</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sujets non-techniques en rapport avec la communauté FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions concernant l’utilisation de FreeBSD-CURRENT</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pour les fournisseurs d’accès utilisant FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emplois et interventions de consultants en rapport avec FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-policy>freebsd-policy</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Décisions de la politique de l’équipe de base de FreeBSD. Volume faible, et accès en lecture uniquement</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Questions des utilisateurs et support technique</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>liste de diffusion des avis de sécurité pour FreeBSD</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Avis de sécurité</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>liste de diffusion à propos de la branche FreeBSD-STABLE;</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions concernant l’utilisation de FreeBSD-STABLE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-test>liste de diffusion de test</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Où envoyer vos messages de test au lieu que dans une des listes réelles</p></td></tr></tbody></table><div class=paragraph><p><em>Listes techniques:</em> les listes suivantes sont destinées aux discussions techniques. Vous devriez lire la charte d’utilisation pour chaque liste attentivement avant de s’y inscrire ou d’y envoyer du courrier parce qu’il y a des règles fermes quant à leur utilisation et leur contenu.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Liste</th><th class="tableblock halign-left valign-top">Objet</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Développement de l’ACPI et de la gestion d’energie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-afs>freebsd-afs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage d’AFS sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/aic7xxx>freebsd-aic7xxx</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Développement de pilotes pour les contrôleurs AIC 7xxx d’Adaptec®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-alpha>alpha</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD sur les systèmes Alpha</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-amd64>freebsd-amd64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD sur les systèmes AMD64</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-apache>freebsd-apache</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion sur les logiciels portés relatifs à Apache</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arm>freebsd-arm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD sur les processeurs ARM®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-atm>freebsd-atm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilisation de réseaux ATM avec FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-audit>freebsd-audit</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Projet d’audit du code source</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-binup>freebsd-binup</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Conception et développement du système de mise à jour binaire</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilisation de la technologie Bluetooth® sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cluster>freebsd-cluster</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilisation de FreeBSD dans un environnement en grappe</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cvsweb>freebsd-cvsweb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Maintenance du système CVSweb</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-database>freebsd-database</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions à propos de l’utilisation de bases de données et de leur développement sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Création de documents en rapport avec FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ecrire des pilotes de périphériques pour FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pour les utilisateurs FreeBSD de l’EDI Eclipse, les outils, les applications clientes et les logiciels portés.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilisation de FreeBSD dans les applications embarquées</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-eol>freebsd-eol</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Entre-aide sur les logiciels relatifs à FreeBSD et qui ne sont plus supportés par le projet FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emulation d’autres systèmes comme Linux/MS-DOS®/Windows®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion technique au sujet du FireWire® (iLink, IEEE 1394) sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Systèmes de fichiers</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions spécifiques à GEOM et à ses implémentations</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de GNOME et des applications GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions techniques générales</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion générale à propos du matériel fonctionnant sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-i18n>freebsd-i18n</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Internationalisation de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ia32>freebsd-ia32</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD sur la plate-forme IA-32 (Intel® x86)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ia64>freebsd-ia64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD sur les futurs système Intel® IA64</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion technique concernant le développement du nouveau code du coupe-feu</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Développeurs ISDN</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-jail>freebsd-jail</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion au sujet des environnements <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Développeurs Java™ et personnes portant et les JDKs sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de KDE et des applications pour KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-lfs>freebsd-lfs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de LFS sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-libh>freebsd-libh</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Le système d’installation et de logiciel pré-compilé de seconde génération</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mips>freebsd-mips</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD sur MIPS®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mobile>freebsd-mobile</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions à propos des ordinateurs portables</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mozilla>freebsd-mozilla</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de Mozilla sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>liste de diffusion pour les discussions concernant le multimédia sous FreeBSD</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Applications multimédia</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-new-bus>freebsd-new-bus</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions techniques au sujet de l’architecture de bus</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-net>freebsd-net</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion au sujet des réseaux et du code source TCP/IP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-openoffice>freebsd-openoffice</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage d’OpenOffice.org et de StarOffice™ sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Questions relatives à l’optimisation pour les installations à charge/performances élevées.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-perl>freebsd-perl</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Maintenance des logiciels portés relatifs à perl</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions et questions concernant le système de coupe-feu packet filter</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portages sur des plateformes à architecture non Intel®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion sur le catalogue des logiciels portés</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>freebsd-ports-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion sur les bogues/PRs des logiciels portés</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ppc>freebsd-ppc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD pour le PowerPC®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion technique sur l’utilisation de FreeBSD sur les serveurs HP ProLiant</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Problèmes concernant l’utilisation de Python sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-qa>qa</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion sur la qualité de FreeBSD, généralement entre deux versions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-rc>freebsd-rc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion relative au système <span class=filename>rc.d</span> et à son développement</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-realtime>freebsd-realtime</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Développement des extensions temps réel de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sous-système SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security>liste de diffusion pour les questions concernant la sécurité</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Questions concernant la sécurité</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-small>freebsd-small</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilisation de FreeBSD dans les applications embarquées (obsolète, utilisez <a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a> à la place)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-smp>smp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions sur la conception du traitement symétrique multiprocesseurs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sparc64>freebsd-sparc64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD sur les systèmes SPARC®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Conformité de FreeBSD aux normes C99 et POSIX®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sun4v>freebsd-sun4v</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portage de FreeBSD sur les systèmes basés sur UltraSPARC® T1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-threads>freebsd-threads</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Threading sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-testing>freebsd-testing</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tests de stabilité et de performance de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tokenring>freebsd-tokenring</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Support du Token Ring sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-x11>freebsd-x11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Support et maintenance de X11 sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion sur le support USB sous FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-vuxml>freebsd-vuxml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion sur l’infrastructure VuXML</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-x11>freebsd-x11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Maintenance and support of X11 on FreeBSD</p></td></tr></tbody></table><div class=paragraph><p><em>Liste à accès restreint:</em> les listes suivantes sont pour les assistances plus spécialisées (et exigeantes) et ne sont probablement pas d’intérêt général. C’est aussi une bonne idée d’être d’abord actif sur les listes techniques avant de vous inscrire à une de ces listes limités de sorte que vous compreniez l’étiquette impliquée dans ces communications.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Liste</th><th class="tableblock halign-left valign-top">Objet</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pour ceux qui gèrent des sites miroir (questions d’infrastructure)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Coordination des groupes d’utilisateurs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-vendors>freebsd-vendors</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Coordination des fournisseurs des pré-versions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-www>freebsd-www</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Webmestres de <a href=https://www.FreeBSD.org/>www.FreeBSD.org</a></p></td></tr></tbody></table><div class=paragraph><p><em>Résumé de liste:</em> Toutes les listes ci-dessus sont également disponibles sous forme de résumé. Une fois inscrit à une liste, vous pouvez modifier vos options de résumé dans les options de votre compte.</p></div><div class=paragraph><p><em>Listes CVS lists:</em> Les listes suivantes sont destinées aux personnes intéressées par la lecture des journaux des modifications effectuées sur les différentes partie de l’arborescence des sources. Ce sont des listes à <em>lecture seule</em> et on ne devrait pas y envoyer de messages.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Liste</th><th class="tableblock halign-left valign-top">Partie de l’arborescence des sources</th><th class="tableblock halign-left valign-top">Description de la partie (des sources concernées)</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/cvs-all>cvs-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/(CVSROOT|doc|ports|projects|src)</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toute modification de l’arborescence (agrégation de l’ensemble des listes CVS)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/cvs-doc>cvs-doc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/(doc|www)</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toutes les modifications effectuées sur les arborescences doc et www</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/cvs-ports>cvs-ports</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toutes les modifications effectuées sur l’arborescence des logiciels portés</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/cvs-projects>cvs-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toutes les modifications effectuées sur l’arborescence des projets</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/cvs-src>cvs-src</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toutes les modifications effectuées sur l’arborescence des sources</p></td></tr></tbody></table></div><div class=sect3><h4 id=eresources-subscribe>C.1.2. Comment s’inscrire<a class=anchor href=#eresources-subscribe></a></h4><div class=paragraph><p>Pour s’inscrire à une liste, cliquez sur le nom d’une liste ci-dessus où sur <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> et cliquez ensuite sur la liste qui vous intéresse. La page de la liste devrait contenir toutes les instructions nécessaires à l’inscription.</p></div><div class=paragraph><p>Pour poster réellement sur une liste, envoyez simplement un courrier électronique à l’adresse <a href=mailto:nom-de-la-liste@FreeBSD.org>nom-de-la-liste@FreeBSD.org</a>. Ce courrier sera alors redistribué à l’ensemble des membres de la liste de par le monde.</p></div><div class=paragraph><p>Pour vous désabonner d’une liste, cliquez sur l’URL se trouvant à la fin de chaque message reçu de la liste. Il est également possible d’envoyer un message à <a href=mailto:nom-de-la-liste-unsubscribe@FreeBSD.org>nom-de-la-liste-unsubscribe@FreeBSD.org</a> pour vous désabonner.</p></div><div class=paragraph><p>Encore une fois, nous voudrions vous demander de garder aux discussions sur les listes techniques leur caractère technique. Si vous n’êtes intéressés uniquement que par les annonces importantes alors nous vous suggérons de vous inscrire à la liste <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>liste de diffusion pour les annonces relatives à FreeBSD</a>, dont le trafic n’est qu’occasionnel.</p></div></div><div class=sect3><h4 id=eresources-charters>C.1.3. Chartes d’utilisation des listes<a class=anchor href=#eresources-charters></a></h4><div class=paragraph><p>Il y a pour <em>toutes</em> les listes de diffusion FreeBSD des règles de base auxquelles tous leurs utilisateurs doivent se conformer. En cas de non respect de ces règles, et après deux (2) avertissements écrits de la part du "Postmaster" de FreeBSD <a href=mailto:postmaster@FreeBSD.org>postmaster@FreeBSD.org</a>, au troisième manquement, le contrevenant sera désabonné de toutes les listes de diffusion de FreeBSD, et ses messages ultérieurs filtrés. Nous regrettons de devoir prendre de telles mesures, mais l’Internet d’aujourd’hui est un milieu relativement hostile, et beaucoup ne se rendent pas compte de la fragilité de certains de ses mécanismes.</p></div><div class=paragraph><p>Règles générales:</p></div><div class=ulist><ul><li><p>Le sujet de tout message doit correspondre au sujet traité par la liste à laquelle il est adressé, e.g., si c’est une liste concernant des problèmes techniques alors le contenu de votre message doit être technique. Le bavardage continu et les polémiques ne font que dégrader la qualité de la liste de diffusion pour tous les utilisateurs et ne seront pas tolérés. Pour des discussions libres sans sujet particulier, la <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>liste de diffusion pour la discussion de sujets non-techniques en rapport avec FreeBSD</a> est disponible et devrait être utilisée dans ce cas.</p></li><li><p>Aucun message ne doit être adressé à plus de 2 listes de diffusion, et à 2 listes uniquement dans le cas où il y a une nécessité évidente de poster sur les deux listes. Pour la plupart des listes, il y a déjà beaucoup de souscripteurs communs, et mis à part les cas les plus ésotériques (par exemple "-stable -scsi"), il n’y a pas vraiment de raison de poster sur plus d’une liste à la fois. Si vous recevez un message où apparaissent sur la ligne <code>Cc</code> plusieurs listes de diffusion, vous devez purger cette ligne <code>Cc</code> avant d’y répondre. <em>Vous êtes toujours responsable de vos expéditions croisées, peu importe qui en a été à l’origine</em>.</p></li><li><p>Les attaques personnelles et les insultes (dans le cadre d’une discussion) ne sont pas autorisés, et cela concerne tout autant les utilisateurs que les développeurs. Les manquements grossiers à la "nétiquette", citer ou reposter des courriers privés quand l’accord n’en a pas été donné et ne le sera pas, par exemple, sont désapprouvés, mais pas particulièrement réprimés. <em>Cependant</em> de tels contenus entrent rarement dans le cadre des règles d’utilisation d’une liste, et entraîneront donc probablement un avertissement (ou une exclusion) pour cette seule raison.</p></li><li><p>La publicité pour des produits ou services sans rapport avec FreeBSD est rigoureusement interdite et entraînera l’exclusion immédiate s’il s’avère que le contrevenant adresse ses publicités par "courrier électronique non sollicité" - spam.</p></li></ul></div><div class=paragraph><p><em>Chartes liste par liste:</em></p></div><div class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>liste de diffusion concernant ACPI sous FreeBSD</a></dt><dd><p><em>Développement de l’ACPI et de la gestion de l’énergie</em></p></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-afs>freebsd-afs</a></dt><dd><p><em>Système de fichiers Andrew - Andrew File System</em></p><div class=paragraph><p>C’est une liste de discussion sur le portage et l’utilisation d’AFS de CMU/Transarc.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>liste de diffusion pour les annonces relatives à FreeBSD</a></dt><dd><p><em>Evénements importants / étapes importantes pour le projet</em></p><div class=paragraph><p>C’est une liste pour les gens intéressés uniquement par les annonces occasionnelles d’évènements FreeBSD importants. Cela inclut les annonces d’instantanés et autres versions. Cela comprend également les annonces de nouvelles fonctionnalités de FreeBSD. Il peut y avoir aussi des appels à volontaires, etc…​ C’est une liste de faible volume et rigoureusement modérée.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></dt><dd><p><em>Discussions concernant l’architecture et l’implémentation</em></p><div class=paragraph><p>C’est une liste pour discuter de l’architecture de FreeBSD. Les messages y seront habituellement de nature technique. Des exemples de sujets qui cadrent avec cette liste sont:</p></div><div class=ulist><ul><li><p>Comment revoir le système de compilation pour que plusieurs compilations personnalisées puissent être effectuées en même temps.</p></li><li><p>Que faut-il corriger dans VFS pour que les couches Heidemann fonctionnent.</p></li><li><p>Comment modifier l’interface des pilotes de périphériques pour que la même interface fonctionne proprement sur différents bus et architectures.</p></li><li><p>Comment écrire un pilote réseau.</p></li></ul></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-audit>freebsd-audit</a></dt><dd><p><em>Projet d’audit du code source</em></p><div class=paragraph><p>C’est la liste de discussion pour le projet d’audit du code source de FreeBSD. Bien que n’étant à l’origine destinée qu’aux modifications relatives à la sécurité, sa charte a été élargie pour l’examen de toute modification de code.</p></div><div class=paragraph><p>Cette liste est très chargée de correctif, et n’est probablement pas intéressant pour l’utilisateur moyen de FreeBSD. Les discussions sur la sécurité non relatives à une modification particulière du code ont lieu sur freebsd-security. Réciproquement, tous les développeurs sont encouragés à envoyer leur correctifs sur la liste pour examen, tout particulièrement s’ils touchent une partie du système où un bogue peut compromettre l’intégrité du système.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-binup>freebsd-binup</a></dt><dd><p><em>Projet de mise à jour binaire de FreeBSD</em></p><div class=paragraph><p>Cette liste existe pour discuter du système de mise à jour binaire, ou binup. Problèmes de conception, détails d’implémentation, correctifs, rapports de bogue, rapport d’état, demandes de fonctionnalités, traces des modifications du code, et tout ce qui peut avoir rapport avec binup sont à leur place ici.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></dt><dd><p><em>Bluetooth® sous FreeBSD</em></p><div class=paragraph><p>C’est un forum où se rassemble les utilisateurs de la technologie Bluetooth® sous FreeBSD. Problèmes de conception, détails de l’implémentation, rapports de bogues, état du support, demande de fonctionnalités, et tous les sujets en rapport avec Bluetooth® sont les bienvenues.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></dt><dd><p><em>Coordination de la gestion des rapports de bogue</em></p><div class=paragraph><p>L’objet de cette liste est de servir de forum de coordination et de discussion entre le "Boguemestre", ses chasseurs de bogues et toute autre partie intéressée dans la base de données des PRs. Cette liste n’est pas destinée aux discussions sur des bogues spécifiques, correctifs ou PRs.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></dt><dd><p><em>Rapports de bogue</em></p><div class=paragraph><p>C’est la liste pour rapporter les bogues de FreeBSD. Chaque fois que c’est possible, les bogues devraient être soumis en utilisant la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> ou son <a href=https://www.FreeBSD.org/send-pr.html>interface WEB</a>.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></dt><dd><p><em>Sujets non-techniques en rapport avec la communauté FreeBSD</em></p><div class=paragraph><p>Cette liste reçoit le résidu des discussions sur les autres listes: informations sociologiques, et non techniques. Cela va de savoir si Jordan ressemble ou non à un furet de bande dessinée, s’il faut tapez en majuscules, qui boit trop de café, quelle est la meilleure bière, qui brasse de la bière dans sa cave, et ainsi de suite. Les annonces occasionnelles d’événements importants (les prochaines fêtes, mariages, naissances, nouveaux emplois, etc…​) peuvent être adressées aux listes techniques, mais doivent ensuite être redirigées sur cette liste.</p></div></dd><dt class=hdlist1>liste de diffusion de l’équipe de base de FreeBSD</dt><dd><p><em>Equipe de base de FreeBSD</em></p><div class=paragraph><p>C’est une liste interne à l’usage des membres de l’équipe de base. Des messages peuvent y être adressés lorsqu’un sujet en rapport avec FreeBSD demande arbitrage ou examen à haut niveau.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-current>liste de diffusion à propos de la branche FreeBSD-CURRENT</a></dt><dd><p><em>Discussions concernant l’utilisation de FreeBSD-CURRENT</em></p><div class=paragraph><p>C’est la liste de diffusion pour les utilisateurs de FreeBSD-CURRENT. Elle inclut avertissements au sujet de nouvelles fonctionnalités de -CURRENT qui affecteront les utilisateurs, et les instructions sur ce qu’il faut faire pour rester à jour avec -CURRENT. Tous les utilisateurs de "CURRENT" doivent s’inscrire à cette liste. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-cvsweb>freebsd-cvsweb</a></dt><dd><p><em>Project CVSweb de FreeBSD</em></p><div class=paragraph><p>Discussions techniques au sujet de l’utilisation, du développement et de la maintenance du FreeBSD-CVSweb.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></dt><dd><p><em>Project de documentation</em></p><div class=paragraph><p>C’est la liste de discussion sur les questions et projets liés à la rédaction de documentation pour FreeBSD. Les membres de cette liste sont collectivement appelés "Le Projet de Documentation de FreeBSD" - The FreeBSD Documentation Project. C’est une liste ouverte; n’hésitez pas à vous inscrire et à participer!</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></dt><dd><p><em>Ecrire des pilotes de périphériques pour FreeBSD</em></p><div class=paragraph><p>C’est une liste pour les discussions techniques au sujet des pilotes de périphériques sous FreeBSD. C’est principalement un lieu où les personnes écrivant les pilotes peuvent poser des questions sur l’écriture de pilotes utilisant les APIs du noyau FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></dt><dd><p><em>Pour les utilisateurs FreeBSD de l’EDI Eclipse, les outils, les applications clientes et les logiciels portés.</em></p><div class=paragraph><p>L’objectif de cette liste est de fournir un support pour tout que qui concerne le choix, l’installation, l’utilisation, le développement et la maintenance de l’EDI Eclipse, des ses outils, de ses applications clients sous FreeBSD et l’aide au portage de l’EDI Eclipse et de ses greffons sous l’environnement FreeBSD.</p></div><div class=paragraph><p>Le but est également de faciliter les échanges d’information entre les communautés Eclipse et FreeBSD pour un bénéfice mutuel.</p></div><div class=paragraph><p>Bien que cette liste soit principalement destinée à répondre aux demandes des utilisateurs d’Eclipse, elle est également un forum pour ceux qui désirent développer des applications spécifiques à FreeBSD en utilisant le système Eclipse.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></dt><dd><p><em>Utilisation de FreeBSD dans les applications embarquées</em></p><div class=paragraph><p>Cette liste aborde les sujets relatifs à l’utilisation de FreeBSD dans les systèmes embarqués. C’est une liste de diffusion à caractère technique pour laquelle on attend un contenu strictement technique. Dans le cadre de cette liste, nous définissons le terme de système embarqué pour les appareils informatisés qui ne sont pas des stations de travail et qui sont destinés à une application bien particulière et limitée par opposition aux systèmes informatiques classiques. Des exemples de systèmes embarqués, parmi tant d’autres, sont les combinés téléphoniques, les équipements réseau comme les routeurs, les commutateurs et les PABXs, les équipements de mesure à distance, les PDAs, les systèmes de distributeurs, et ainsi de suite.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></dt><dd><p><em>Emulation d’autres systèmes comme Linux/MS-DOS®/Windows®</em></p><div class=paragraph><p>C’est une liste pour les discussions techniques relativent à l’exécution sous FreeBSD de programmes écris pour d’autres systèmes d’exploitation.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-eol>freebsd-eol</a></dt><dd><p><em>Entre-aide sur les logiciels relatifs à FreeBSD et qui ne sont plus supportés par le projet FreeBSD.</em></p><div class=paragraph><p>Cette liste est destinée aux personnes désirant proposer ou recherchant une aide pour les logiciels relatifs à FreeBSD pour lesquels le projet FreeBSD ne fournir officiellement plus de support (par exemple sous la forme d’avis de sécutité et de correctifs).</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></dt><dd><p><em>FireWire® (iLink, IEEE 1394)</em></p><div class=paragraph><p>C’est une liste pour les discussions sur la conception et le développement d’un sous-système FireWire® (IEEE 1394, iLink) sous FreeBSD. Les sujets appropriés incluent spécifiquement les normes, les bus périphériques et leur protocole, l’ensemble d’adaptateurs/cartes/circuits, et l’architecture et l’implémentation de leur propre support.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></dt><dd><p><em>Systèmes de fichiers</em></p><div class=paragraph><p>Discussions concernant les systèmes de fichiers FreeBSD. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></dt><dd><p><em>GEOM</em></p><div class=paragraph><p>Discussions spécifiques à GEOM et aux implémentations relatives. C’est une liste de diffusion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></dt><dd><p><em>GNOME</em></p><div class=paragraph><p>Discussions concernant l’environnement de travail GNOME sous les systèmes FreeBSD. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></dt><dd><p><em>Coupe-feu IP</em></p><div class=paragraph><p>C’est le forum pour les discussions techniques concernant la nouvelle implémentation du code du coupe-feu IP sous FreeBSD. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ia64>freebsd-ia64</a></dt><dd><p><em>Portage de FreeBSD sur IA64</em></p><div class=paragraph><p>C’est une liste de discussion technique pour les personnes travaillant sur le portage de FreeBSD sur la plate-forme IA-64 d’Intel®, pour soulever les problèmes ou discuter de solutions alternatives. Ceux qui sont intéressés à suivre les discussions techniques sont aussi bienvenus.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></dt><dd><p><em>Communications ISDN</em></p><div class=paragraph><p>C’est la liste pour les personnes discutant du développement du support ISDN de FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></dt><dd><p><em>Développement Java™</em></p><div class=paragraph><p>C’est la liste pour les personnes discutant du développement d’applications Java™ significatives sous FreeBSD et du portage et de la maintenance des JDK™s.</p></div></dd></dl></div><div id=eresources-charters-jobs class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></dt><dd><p><em>Recherches et offres d’emplois</em></p><div class=paragraph><p>C’est un forum pour poster des offres d’emplois et des curriculum vitae relatifs à FreeBSD, c’est à dire si vous cherchez un emploi concernant FreeBSD ou que vous offrez un emploi impliquant FreeBSD, alors c’est le bon endroit. Ce n’est <em>pas</em> une liste de diffusion pour les problèmes généraux relatifs aux offres et à la recherche d’un emploi puisque des forums adéquats existent déjà par ailleurs.</p></div><div class=paragraph><p>Notez que cette liste, comme les autres listes de diffusion du domaine <code>FreeBSD.org</code>, est diffusée au niveau mondial. Par conséquent, vous devez être précis quant à l’emplacement, les possibilités de travail à distance ou de déplacement.</p></div><div class=paragraph><p>Les messages devraient utiliser uniquement des formats ouverts - de préférence du texte brut, mais le PDF, l’HTML, et quelques autres formats sont acceptables. Les formats propriétaires comme Microsoft® Word (<span class=filename>.doc</span>) seront rejetés par le serveur de la liste de diffusion.</p></div></dd><dt class=hdlist1><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></dt><dd><p><em>KDE</em></p><div class=paragraph><p>Discussions concernant KDE sous les systèmes FreeBSD. C’est une liste de discussion technique sur laquelle le contenu doit rester strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></dt><dd><p><em>Discussions techniques</em></p><div class=paragraph><p>C’est le forum pour les discussions techniques au sujet de FreeBSD. C’est la principale liste technique. Elle est destinée à ceux qui travaillent activement à FreeBSD, pour soulever des problèmes et discuter de solutions alternatives. Ceux qui sont intéressés à suivre les discussions techniques sont aussi bienvenus. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></dt><dd><p><em>Discussions générales sur le matériel pour FreeBSD</em></p><div class=paragraph><p>Discussions générales sur les types de matériel sur lesquels tourne FreeBSD, les problèmes rencontrés et suggestions sur quoi acheter ou éviter.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></dt><dd><p><em>Sites miroir</em></p><div class=paragraph><p>Annonces et discussions pour les personnes qui font fonctionner les sites miroir FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></dt><dd><p><em>Questions concernant les fournisseurs d’accès à Internet</em></p><div class=paragraph><p>C’est la liste pour discuter des sujets qui intéressent les fournisseurs d’accès Internet - Internet Service Providers (ISPs) - qui utilisent FreeBSD. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-openoffice>freebsd-openoffice</a></dt><dd><p><em>OpenOffice.org</em></p><div class=paragraph><p>Discussions concernant le portage et la maintenance d’OpenOffice.org et StarOffice™.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></dt><dd><p><em>Discussions au sujet de l’optimisation et l’accélération de la vitesse d’exécution de FreeBSD</em></p><div class=paragraph><p>Cette liste de diffusion existe pour offrir un endroit aux hackers, administrateurs, et/ou les parties concernées pour discuter de sujets ayant trait aux performances de FreeBSD. Les sujets acceptables comprennent les discussions concernant les installations de FreeBSD qui sont soit sous charge importante, soit présentant des problèmes de performance, ou encore qui repoussent les limites de FreeBSD. Les personnes désirant travailler sur l’amélioration des performances de FreeBSD sont grandement encouragées à s’inscrire à cette liste. C’est une liste hautement technique destinée aux utilisateurs expérimentés de FreeBSD, aux hackers, ou aux administrateurs intéressés par un FreeBSD rapide, robuste, et adaptable. Ce n’est pas une liste de questions-réponses qui remplace la lecture de la documentation, mais c’est un endroit où il est possible d’effectuer des contributions ou de se préoccuper de sujets non-résolus relatifs aux performances.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></dt><dd><p><em>Discussions et questions concernant le système de coupe-feu packet filter</em></p><div class=paragraph><p>Discussions concernant le système de coupe-feu packet filter (pf) sous FreeBSD. Les discussions techniques ainsi que les questions des utilisateurs sont les bienvenues. Cette liste est également un endroit où discuter du système de qualité de service ALTQ.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></dt><dd><p><em>Portage sur les plate-formes non Intel®</em></p><div class=paragraph><p>Questions concernant le support d’autres plates-formes, discussions générales et propositions pour les portages sur des plates-formes non Intel®. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-policy>freebsd-policy</a></dt><dd><p><em>Décisions de la politique de l’équipe de base</em></p><div class=paragraph><p>C’est une liste de discussion à faible trafic, et en lecture seule pour les décisions de la politique de l’équipe de base.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></dt><dd><p><em>Discussion sur les "logiciels portés"</em></p><div class=paragraph><p>Discussions concernant le ``catalogue des logiciels portés'' de FreeBSD (<span class=filename>/usr/ports</span>), propositions de portages, modifications de l’infrastructure du catalogue des logiciels portés et coordination générale. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></dt><dd><p><em>Discussion technique sur l’utilisation de FreeBSD sur les serveurs HP ProLiant</em></p><div class=paragraph><p>Cette liste de diffusion doit être utilisée pour les discussions techniques concernant l’utilisation de FreeBSD sur les serveurs HP ProLiant, y compris les discussions sur les pilotes spécifiques à ces machines, les logiciels de gestion, les outils de configuration, et les mises à jour du BIOS. C’est également le premier endroit où discuter des modules hpasmd, hpasmcli, et hpacucli.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></dt><dd><p><em>Python sous FreeBSD</em></p><div class=paragraph><p>C’est une liste pour les discussions relatives à l’amélioration du support de Python sous FreeBSD. C’est une liste de discussion technique. Elle est destinée aux personnes travaillant sur le portage de Python, de ses modules tiers partie et éléments relatifs à Zope sous FreeBSD. Les personnes intéressées par ces discussions techniques sont également les bienvenues.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></dt><dd><p><em>Questions des utilisateurs</em></p><div class=paragraph><p>C’est la liste pour les questions à propos de FreeBSD. Vous ne devriez pas adresser de questions du type "comment faire" aux listes techniques à moins que vous n’estimiez que la question soit vraiment très technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></dt><dd><p><em>Sous-système SCSI</em></p><div class=paragraph><p>C’est la liste de diffusion pour ceux qui travaillent sur le sous-système SCSI de FreeBSD. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security>liste de diffusion pour les questions concernant la sécurité</a></dt><dd><p><em>Questions relatives à la sécurité</em></p><div class=paragraph><p>Questions ayant trait à la sécurité des ordinateurs sous FreeBSD (DES, Kerberos, trous de sécurité connus et correctifs, etc…​). C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique. Notez que ce n’est pas une liste de question-réponse, mais ce type de contribution (la question ET la réponse) à la FAQ est le bienvenue.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>liste de diffusion des avis de sécurité pour FreeBSD</a></dt><dd><p><em>Avis de sécurité</em></p><div class=paragraph><p>Notifications des problèmes de sécurité concernant FreeBSD et correctifs. Ce n’est pas une liste de discussion. La liste de discussion correspondante est FreeBSD-security.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-small>freebsd-small</a></dt><dd><p><em>Utilisation de FreeBSD dans les applications embarquées</em></p><div class=paragraph><p>Cette liste discute de sujets relatifs aux installations inhabituellement petites et embarquées de FreeBSD. C’est une liste de discussion technique sur laquelle un contenu strictement technique est attendu.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cette liste est obsolète depuis la création de <a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a>.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>liste de diffusion à propos de la branche FreeBSD-STABLE;</a></dt><dd><p><em>Discussions concernant l’utilisation de FreeBSD-STABLE</em></p><div class=paragraph><p>C’est la liste de diffusion pour les utilisateurs de FreeBSD-STABLE. Elle inclut avertissements au sujet de nouvelles fonctionnalités de -STABLE qui affecteront les utilisateurs, et des instructions sur ce qu’il faut faire pour rester à jour avec -STABLE. Tous les utilisateurs de la branche "STABLE" devraient s’inscrire à cette liste. C’est une liste de discussion technique sur laquelle le contenu doit être strictement technique.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></dt><dd><p><em>Conformité aux normes C99 POSIX</em></p><div class=paragraph><p>C’est un forum pour les discussions techniques concernant la conformité de FreeBSD aux normes C99 et POSIX.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></dt><dd><p><em>Discussion sur le support USB sous FreeBSD</em></p><div class=paragraph><p>C’est une liste de diffusion pour les discussions techniques relatives au support de l’USB sous FreeBSD</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></dt><dd><p><em>Coordination des groupes d’utilisateurs</em></p><div class=paragraph><p>C’est la liste pour les coordinateurs des différents groupes locaux d’utilisateurs, destinée à leurs discussions entre eux et avec un membre désigné de l’équipe de base. Cette liste doit se limiter aux comptes-rendus de réunions et à la coordination de projets entre plusieurs groupes d’utilisateurs.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-vendors>freebsd-vendors</a></dt><dd><p><em>Fournisseurs</em></p><div class=paragraph><p>Coordination des discussions entre le projet FreeBSD et les fournisseurs de logiciel ou de matériel pour FreeBSD.</p></div></dd></dl></div></div><div class=sect3><h4 id=eresources-mailfiltering>C.1.4. Filtrages en vigueur sur les listes de diffusion<a class=anchor href=#eresources-mailfiltering></a></h4><div class=paragraph><p>Les listes de diffusion FreeBSD sont filtrées de plusieurs façons en vue d’éviter la distribution de SPAM, de virus, et tout autre message non-sollicité. Les opérations de filtrage décries dans cette section ne comprennent pas toutes celles utilisées pour protéger les listes re diffusion.</p></div><div class=paragraph><p>Seuls certains types de pièces jointes sont autorisés sur les listes de diffusion. Toutes les pièces jointes avec un format MIME qui ne figurent pas parmi la liste ci-dessous seront retirées avant que le message ne soit distribué sur les listes de diffusion.</p></div><div class=ulist><ul><li><p>application/octet-stream</p></li><li><p>application/pdf</p></li><li><p>application/pgp-signature</p></li><li><p>application/x-pkcs7-signature</p></li><li><p>message/rfc822</p></li><li><p>multipart/alternative</p></li><li><p>multipart/related</p></li><li><p>multipart/signed</p></li><li><p>text/html</p></li><li><p>text/plain</p></li><li><p>text/x-diff</p></li><li><p>text/x-patch</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certaines listes de diffusion pourront autoriser des pièces jointes sous d’autres formats MIME, mais la liste précédente devrait être applicable pour la plupart des listes de diffusion.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si un message contient une version HTML et une version texte du contenu du message, la version HTML sera retirée. Si le corps d’un message est uniquement sous forme HTML, il sera converti sous forme texte brut.</p></div></div></div><div class=sect2><h3 id=eresources-news>C.2. Forums de discussion<a class=anchor href=#eresources-news></a></h3><div class=paragraph><p>En plus de deux forums de discussion spécifiques à FreeBSD, il y en a de nombreux autres où il est question de FreeBSD ou qui sont par ailleurs d’intérêt pour les utilisateurs de FreeBSD. <a href=http://minnie.tuhs.org/BSD-info/bsdnews_search.html>Des archives interrogeables par mots-clés</a> sont disponibles pour certains de ces forums, grâce à Warren Toomey <a href=mailto:wkt@cs.adfa.edu.au>wkt@cs.adfa.edu.au</a>.</p></div><div class=sect3><h4 id=_forums_spécifiques_à_bsd>C.2.1. Forums spécifiques à BSD<a class=anchor href=#_forums_spécifiques_à_bsd></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a></p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li><li><p><a href=news:de.comp.os.unix.bsd>de.comp.os.unix.bsd</a> (Allemand)</p></li><li><p><a href=news:fr.comp.os.bsd>fr.comp.os.bsd</a> (Français)</p></li><li><p><a href=news:it.comp.os.freebsd>it.comp.os.freebsd</a> (Italien)</p></li><li><p><a href=news:tw.bbs.comp.386bsd>tw.bbs.comp.386bsd</a> (Chinois)</p></li></ul></div></div><div class=sect3><h4 id=_autres_forums_unix_intéressants>C.2.2. Autres forums UNIX® intéressants<a class=anchor href=#_autres_forums_unix_intéressants></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix>comp.unix</a></p></li><li><p><a href=news:comp.unix.questions>comp.unix.questions</a></p></li><li><p><a href=news:comp.unix.admin>comp.unix.admin</a></p></li><li><p><a href=news:comp.unix.programmer>comp.unix.programmer</a></p></li><li><p><a href=news:comp.unix.shell>comp.unix.shell</a></p></li><li><p><a href=news:comp.unix.user-friendly>comp.unix.user-friendly</a></p></li><li><p><a href=news:comp.security.unix>comp.security.unix</a></p></li><li><p><a href=news:comp.sources.unix>comp.sources.unix</a></p></li><li><p><a href=news:comp.unix.advocacy>comp.unix.advocacy</a></p></li><li><p><a href=news:comp.unix.misc>comp.unix.misc</a></p></li><li><p><a href=news:comp.bugs.4bsd>comp.bugs.4bsd</a></p></li><li><p><a href=news:comp.bugs.4bsd.ucb-fixes>comp.bugs.4bsd.ucb-fixes</a></p></li><li><p><a href=news:comp.unix.bsd>comp.unix.bsd</a></p></li></ul></div></div><div class=sect3><h4 id=_système_x_window>C.2.3. Système X Window<a class=anchor href=#_système_x_window></a></h4><div class=ulist><ul><li><p><a href=news:comp.windows.x.i386unix>comp.windows.x.i386unix</a></p></li><li><p><a href=news:comp.windows.x>comp.windows.x</a></p></li><li><p><a href=news:comp.windows.x.apps>comp.windows.x.apps</a></p></li><li><p><a href=news:comp.windows.x.announce>comp.windows.x.announce</a></p></li><li><p><a href=news:comp.windows.x.intrinsics>comp.windows.x.intrinsics</a></p></li><li><p><a href=news:comp.windows.x.motif>comp.windows.x.motif</a></p></li><li><p><a href=news:comp.windows.x.pex>comp.windows.x.pex</a></p></li><li><p><a href=news:comp.emulators.ms-windows.wine>comp.emulators.ms-windows.wine</a></p></li></ul></div></div></div><div class=sect2><h3 id=eresources-web>C.3. Serveurs World Wide Web<a class=anchor href=#eresources-web></a></h3></div><div class=sect2><h3 id=eresources-email>C.4. Adresses électroniques<a class=anchor href=#eresources-email></a></h3><div class=paragraph><p>Les groupes d’utilisateurs suivants fournissent à leurs membres des adresses électroniques liées à FreeBSD. Les administrateurs cités se réservent le droit de supprimer l’adresse si elle est à l’origine d’abus.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Domaine</th><th class="tableblock halign-left valign-top">Possibilités offertes</th><th class="tableblock halign-left valign-top">Groupe d’utilisateurs</th><th class="tableblock halign-left valign-top">Administrateur</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ukug.uk.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Transmission de courrier uniquement</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=mailto:freebsd-users@uk.FreeBSD.org>freebsd-users@uk.FreeBSD.org</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lee Johnston <a href=mailto:lee@uk.FreeBSD.org>lee@uk.FreeBSD.org</a></p></td></tr></tbody></table></div><div class=sect2><h3 id=eresources-shell>C.5. Comptes<a class=anchor href=#eresources-shell></a></h3><div class=paragraph><p>Les groupes d’utilisateurs suivants fournissent des comptes aux personnes supportant le projet FreeBSD. Les administrateurs cités se réservent le droit de supprimer le compte s’il est à l’origine d’abus.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Hôte</th><th class="tableblock halign-left valign-top">Accès</th><th class="tableblock halign-left valign-top">Possibilités offertes</th><th class="tableblock halign-left valign-top">Administrateur</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>dogma.freebsd-uk.eu.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Telnet/FTP/SSH</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Adresse électronique, espace Web, FTP anonyme</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lee Johnston <a href=mailto:lee@uk.FreeBSD.org>lee@uk.FreeBSD.org</a></p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=pgpkeys>Annexe D: Clés OpenPGP<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p>Les clés OpenPGP des officiers <code>FreeBSD.org</code> sont données ici. Ces clés peuvent être utilisées pour vérifier une signature ou pour envoyer un courrier électronique chiffré à un des officiers. Une liste complète des clés OpenPGP FreeBSD est disponible dans l’article <a href=https://docs.freebsd.org/en/articles/pgpkeys/>Clés PGP</a>. Le trouseau complet peut être télécharger depuis <a href=https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt>pgpkeyring.txt</a>.</p></div><div class=sect2><h3 id=pgpkeys-officers>D.1. Officers<a class=anchor href=#pgpkeys-officers></a></h3><div class=sect3><h4 id=_lofficier_de_sécurité_security_officerfreebsd_org>D.1.1. L’officier de sécurité <code>&lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code><a class=anchor href=#_lofficier_de_sécurité_security_officerfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2025-01-15]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2025-01-15]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31IkEcgQYAQoAJgIbAhYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJlhctvBQkD8n2mAkDBdCAEGQEKAB0WIQS2FSd+
gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBuWN6QHwAa77gbEADpUBT14cesITuM
sOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMPXih9G1tDo9ExIWT8jNjSSA+w0Viu
a/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJWy944YegHF/5ytntwZ/L4BMYc3Mzt
yZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37bbUVw62xHQIn2zafSmMQ4oMXZTm9
EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1G9jqkwlaRYWjcLD0qxwc5m9LNrF6
OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDClTTH+dAx3b6J1KFB0UiHP3FeTalF
h8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2RAo/o2X5r40qk/lhydQRZTSTFsiu
H3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7re0jj8XMIO7G5yjQKQCnYuPdXbx++
bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17MEPIton1+NRfsU0peEVggQXlwdTc
ZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpKa9qfIqBX/monjy7w5IHmhvLwAYI6
IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69PxMbOJbMpWSg8L7xW3LXKR1VwXgg
UC1+b3y67E5Ggi1hf0lfTnTMpL2ClAkQ2a0qGAV0dMsjqhAAorQ725G342raJ+os
6+E/EFNsr4SR5H+AeinlQ2ymNSeO/ODsV6dmyYD3hed0mAXvIJt2B46fFC4eAP9f
VOIbMMhPMpnJuZyLPDi8gXcZLgWSRhJ88R98KIsmKlh+/fdZM4RI1JLjICi7kyNR
4jtKCzLj0DYVBzp1mn0lTwtFzv7SC9djpqFLnO5YoGPWfQHHhY02Trh2posRwAHO
oacXSFvsoQv6k6XNlStJ4lnrkH6t+Od4kU3/TJ0eQXs7Zd2WEVnMe1IhbihsGcAY
mzZzZlLOhskHCeVE2taHiXC6h4tC3/69I16N8ICauxGY41clPhiNmVaAzmkunOPz
ry5utl6HkpZ5/3UMVHI1JIvsfJW+vSMUhdcQILAv6DbRWWHeax3ZZ6iAVGCtJS7U
glwZM1Xor0okGtIS+aJ/Cw7tZ8Nm18lutcrf2MVW+BWpzMQKnWFQYTn1NEWjzYnx
9Na22+E8AvW02TdS0NSiP0sG/0q7lBNEck9vH4WEbbEXktj51Dg4ISUhQyW8BWwW
X+kSiNeqtcaikUb8SFj5vpTDotTSzikfT/jisvR5goTMNFCVHFZdXCdsbUZd8Iub
egAOh6Db/06y3mFYDEfcGJipab400OY03a2xw9Vz+YxrKfELCTBo2tZv+3K8kXgq
XFcbyJnkXmjnYM/sw5kKqtzuc7i5Ag0EY5V3BwEQAMpFVczZo9ZPNsgW791UW5o6
wnrnd1nIO+S4rc37q2TEz8KGHCuxo5NwffZ2t6Ln04BI54pbapg17b7a0hPka37H
FkL28n4VyMdx0CsAm3QEfUsdK6xwKV2SucYeVcrV1upcN4PdXD7su1I7/A4CWXFJ
G047zJ0Z89lJZiQEiAq7ghvEoinC0sm+0a6ao/ocqCgWCKM1yCPOyzJXleRrv29S
RnYziMR+q2U0x9xg9Xl6GMwUmFwbJc9nORVvLH7fbU6/du8EgoAYrglFOFZG/TSo
lSGWRSMiavz0JSD/i+rEN4aIT4WfBe+L9Wy1AmrNxiAO+zKmzHQu3JSxDncr+y+h
cd+W0gqw10FoI9jWLcL7kR+6a0iOjuJSXSopq2l3DafiPxtCFmr4CGQhzBHM6e4/
v/NNd3F0XpVbJ6RQph7lkfvfz8q2lvUlHhezJ0p1xXmhff9CHjdVMhmAmz5+imBA
Xk2mottNfKb0pFEen1xY3K/UPA4g+oPsSj495MsvIg9eIMCcC3/z0SEUMWH/styy
JzPqfpyfGwZeTcIj9vg2o+RnGvmcLVYA/EGToPk905kv/cK73oy8bZyOB0zMg7T9
PaWgLUO0sqjqo0Mw3knFySg3oRXlcilPQvfPdX0JvwLpc9DWlr1+1GkCXJ08lWug
Jc96CJQupKRb1IbC0oUXABEBAAGJAjwEGAEKACYWIQQL4zJ110yVPHn4EQfZrSoY
BXR0ywUCY5V3BwIbDAUJAgIpAAAKCRDZrSoYBXR0ywwtD/wIDmEcHdFlyFRTomUB
jbeK2uzcZIhkkgL58lc63UPle5iJ2FBvmYS+0rQS53sVEsccn5KfkOwTryKllvWb
l0IzuiqfawxALcfWpfZJHzTMSnDHfgXvOOyFMQruqRDAHAr7PNC0CnbT0sEF2ZFz
ad8M9fLqtkXUx4mgECNGJ4CVqg75KY8uUzv/BmRwEf587FT5/iAIed5MjFB2VFDX
9GABcvTTbHxCZIxnxl3cs15SxT0lAofZ2ueU6kWYWZSXFeaEM/4ymPJws2mmV0Ak
bJghLXCn9Mx3nX6NTZZ9Harbru+RzW3/Hg3DZd0J9vko8PafP0l1NWtgyX74CqvT
gjzTxXTnqrRXzcczK7fhcC2u4i0prPtXXcyyi7SwpoLikaZCLFFhUmOx+mS5Tjtg
FyFZBNxnO7iAwkzfcTcC9sPoWaFmiQf6q5EIYzG+WQpncj80mxl3HWOP6oFj/hZJ
RYseKeMkvJzLTo87rFdM6CsMrLwETR6e+aWM0btPFil1rXVACNOjsy0bxTV8OJEf
yxnYmyjvnBvB0kdiaVEDdVhxgSqzLAX4mgXa49/V6M/uzMr+n3/A1Jdk4V6fVm8S
5cFIXxoUat3cB4xGaT9OWD3o1NPr6eS9Vo0EsJlRl81SG68fS+Qtk2fX27T68YG4
Aa3zMfZxUsVuFLtTuQbRC+fJpIkCPAQYAQoAJgIbDBYhBAvjMnXXTJU8efgRB9mt
KhgFdHTLBQJlhcuqBQkD8n1oAAoJENmtKhgFdHTLoO0QAJsTE9fkleb7YzPEuP9G
J3jx8PGdWm7n+8UNdr24kS6gOXVUfPZrWa5So21hcIwZb4PZDqHSVSQnRciKhSnG
7gplYPNGZ4+FWbLr/mBRYarjkVFLUuCPexSIjxV1KSGJnWs9YTVAKZAz75GpCML6
jD6biCOQCQ86wqOdWvZIZR8YvurrxR64ABB0rjbsaG8cNOUX1cwAfdLwthf64dS+
2m3lqNGDHkP5eNL0RIxC5gXYEp0lvmlMH3ZuO5WrfH73PTDg89bxXeuhrFmSEwf4
xWm603oi8/2qQvR9/7jb0o+t71NQuWrWIFONZWWgZBUGso+uyT3XgY4YqKGR3z2Q
zKHYnJ6M7SvSYpqS7RtcxcCXF0HGNfES8cAgtKVpFtbtSwXXp8O8oLyjmVIO/NjU
pbLOGdFIsarsezLFV9f2fqZ63J34hyUSg8LrYVV1fA5DJUpebbX4hLpdk0MMtgG4
3BwKIGlJTpL5RkQ/uQU3YW2kairy7o+1imDD0TRzQxtdjVOI5vnlTNcfJZIIfLx4
drABA12OvpX3dfPV62R+8BAlJFT430CG6AISJIBqJRFvuikmnZGUvEHmOUs/FLbb
aXTPkKc7tR2WIwljRvMV+Qk84cWcX6YchMslMuiDM1mtlQZig34WHGSE+zCWnXAs
lIHlSwox7qfdO0Kz2XncSbIA
=QvUh
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_le_secrétaire_de_léquipe_de_base_core_secretaryfreebsd_org>D.1.2. Le secrétaire de l’équipe de base <code>&lt;<a href=mailto:core-secretary@FreeBSD.org>core-secretary@FreeBSD.org</a>></code><a class=anchor href=#_le_secrétaire_de_léquipe_de_base_core_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/4D632518C3546B05 2024-02-17 [SC] [expires: 2025-02-16]
      Key fingerprint = 1A23 6A92 528D 00DD 7965  76FE 4D63 2518 C354 6B05
uid                            FreeBSD Core Team Secretary &lt;core-secretary@FreeBSD.org&gt;
sub   rsa4096/CABFDE12CA516ED2 2024-02-17 [E] [expires: 2025-02-16]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGXQ1o8BEAC+Rcg8cmVxuP17Vu+q5KgCx/XiulQuqKXAqqBlYCH2jqk6DINP
yFrREGBhzd/qNmlAYEahQ4Zgl0bUZNTrZVDyzicOvPP0jH+KSTQwRs7NOawEdlVO
cyHrwDCPEqf5ZzD4NhfTriEOw+j0pEH/onitUGvoQRtx15xWyaJQxDEBMTYMLewE
86D1bltwnTNczE3UZb7oQLJXkAX5hcLtou70XJGgZITvJkK+kp/xot2eFjnqRz/u
WeXnKhYAmC07EKwZ1uw047eHKwMMRBYqzApLwoQtfE430Kxf2q8de64x8zDbi6YM
1J4r8OAxOtHVyfJ0j7Q23DEZz0VVb4b1Tx5OG2Re/KSNvqI0awJO4TcRmOR88OyY
dzyXgnX6Sa7GVQY1FXvn7vtFuDAt7egZOzeomSHL9bdX07LTQ4UtM88EV9wm3q4q
smoatV9jsvPQ1zxCU3aQD/5eWTJH2/kz1LIuBL/Qi5XQpJn91lBtUWJrCgkHWPGu
f//rnnXmsG7DAChW+yZ7cFO8lfNa8sFhPqSxCYphWmJTrvadyQtDngB8JakWdnmK
pfGS6y5lel+181vw38ZZKt04AKM+nDY8051lBM7Q9Q6kTLI33UZeImndx5xYukVD
kV6aQ31HYfEark15c7iEz+OAcwFnM2ntXMt7kKGd40CqzusiPcQkPqPbAQARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QEZy
ZWVCU0Qub3JnPokCVwQTAQoAQRYhBBojapJSjQDdeWV2/k1jJRjDVGsFBQJl0NaP
AhsDBQkB4TOACAsJDQgMBwsDBRUKCQgLBRYDAgEAAh4FAheAAAoJEE1jJRjDVGsF
nacP/3PSg8JPmWoBfWrgT287NZ7OAU16/uGpDxlBUoVeEtkEDqZVW8yBFzrMhbwj
bJs3CZ+L85HMUDLZoxSwVnPM8PLVRzHTybYV7agYYzMox5C/jp2aeAgy9KYVd0Tk
07GMTYrSh4fhHWpxXz7IBOxk0RXvQxTHlg1u0DASkibYb2UTDcUNG5Q9kP/8jaIZ
kVDX8a5LDdOCgWaYdKPg4blv/UMjkegJz+Ayp7gXTcux6koW5F6ysSw9sgLBWb2D
b/KNIi4MBMe46xyXB/dqGAR4ibrUXTcQ4OAZNq1L6uWG1A49XuSgykdIwr00MzQw
wfVpKT31ww4ayVHLgj7NuqPlab9S5/fPfJ4MAvGE4GqWQFgsPKgKImUMgnnxTGpv
l7Dqk2MnWqn+wEi0bRES0PVBG96G+sZJQeaxBhoB+HwUSFqoZQg166AJIl//4t2w
bx0a1aWQSS0DZt3wsQW3NW9AE6L+FnFfIc2pQVoLjmvcGalDuvnemRmEOgotiZmt
32bi2aWxg0/Qio2rjLS2LpV+fhwDSN3Agvtnu53yUdD1TFFjTSMloM4SKhiXoPbI
XgfCLiBLNMsZL0AvO7wQfSePzPYxDLyEcwsfPJ8be+eGG1L62RUyad+MdfyXMH/S
m0sgqW/MW6Nv10RyPQOq3Jbgmp2laRMzKTOvQt5WwQf2FEl9uQINBGXQ1o8BEAC9
1cBYn6Z0QmM0OFWdXQI6fMOeNokaa6ngPgt7bzW5NjryqTdwyHOPZdm4DWf1SO/0
+fJRCqxbICyuMAFrb9fDle8bodALjm5ZquTL3D61HpZD4+RwOzOjYP6wLm7h38HT
/yIyK882Ovlw4Xz/TeSiL/VUSWE9twW7yz3oreCeLUBAfzacS9y+syO+aquEd0/x
JBz+mPQbrqfS64rCZXMZEivgsjkQoE6RM+n1rF4kw4Eu3E2kPevVwsoAaY+MEUM8
JAXaJMaNcLIhbeMy7dO/z6z2I3h5bUw5KxfVwzYSzSeRpYh53dNaB4NY+f5/vTrL
4dZmqBcLgcV0zZ02dj/u0SiwWlUFUpFGuSiW16DN7+2zG1zOWi7Nl44JawM62Tlf
mO8zruVGEHaV3e8fFwBLRKM0Sc7e3aLECISsfYeC5ZbRRbpQ1KX+VQr3FBKAMzG4
l9Go7vZ+UcLKpQx2rVPTJt1vDnRV49X6CF2Q/lV9iafQ4MTy6ACdAloT1yfH/lhU
iWQo1qDyRCSlmNBDsYl8gLrwMp4gGQAv3imZHxnJF5ru3nUYGG0U08D5mf2sWv5P
Wh7By8Jm8bmaP8cUF86lO9BJXh2d9QN5jqrAtXqYzenZ+ABSoL1XrD/yv3270rH7
H4gAUtgP+vJ3uMyRu9055OC+ie/b613NojCW5nYN2QARAQABiQI8BBgBCgAmFiEE
GiNqklKNAN15ZXb+TWMlGMNUawUFAmXQ1o8CGwwFCQHhM4AACgkQTWMlGMNUawXh
7w/+KjbEWTwAhjm2HJ3w4tXtPC5URg+A+BzYYVH/q0+956c1QeD0LYafHBw4LEMI
lhRvHQnmzwjtY8v/DgmLOVDMiMWVHo0Q2iQyMvOT1WyEPcgOTJLhvyVzDqRZx7AS
B4G8uNVkKAdBZ7OSXAP27lR/2SEoG05esw8b7Y39pVtucC3aeiua+19PLJWadBjj
XuvXuSCho0km+nk4IgadYmxIDyiMeyKZ8wCl7CJkzECm83q2OtNsMe3k8lgEXybt
KlQxnYApZmhqLMV5ob8WOk3AgAVsif1m332CiEIb1Sfx6wt3nXy/410CXdDDucuj
ndJVfJ6Un33tn0irZ5scPA2HmzK1PGMfgOGtkM8B3LE/x8kEKeWKb3l9boB32Unm
iTfKgEna+JISEab3bzOPWdCQFB8LyGXuWlhtvqmRoX8GtiMRy/F4mzh+l3lYHjj3
4EvPVyippO5zwU+S9HElJ2G37K6zrOmd5cGBrw4aBDoO70QVrMN4O86uvC9kChDb
qyFF5UgXg29QxJjiSCv98ksDMqpJ5AFYrmrsBtwU64OANrxxJ4AZLQ1apYmG9RWD
VHZgfeI60FNBLfKwix9UffFT7piQ/MLrjSde8gPH5S6ezBMrYpfGEopaI9A5qXe3
LnHz88gfdmaBM77YDZM/p23nmCrUxlE3kkbgjTY8NRjYyF8=
=MkAH
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_le_secrétaire_de_léquipe_de_gestion_des_logiciels_portés_portmgr_secretaryfreebsd_org>D.1.3. Le secrétaire de l’équipe de gestion des logiciels portés <code>&lt;<a href=mailto:portmgr-secretary@FreeBSD.org>portmgr-secretary@FreeBSD.org</a>></code><a class=anchor href=#_le_secrétaire_de_léquipe_de_gestion_des_logiciels_portés_portmgr_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_doceng_secretaryfreebsd_org>D.1.4. <code>&lt;<a href=mailto:doceng-secretary@FreeBSD.org>doceng-secretary@FreeBSD.org</a>></code><a class=anchor href=#_doceng_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 24 août 2022 by <a href="https://cgit.freebsd.org/doc/commit/?id=be8be77b5e" target=_blank>Marc Fonvieille</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Préface</a><ul><li><a href=#preface-audience>Public visé</a></li><li><a href=#preface-changes-from2>Modifications depuis la Seconde Edition</a></li><li><a href=#preface-changes>Modifications depuis la Première Edition</a></li><li><a href=#preface-overview>Organisation de cet ouvrage</a></li><li><a href=#preface-conv>Conventions utilisées dans ce livre</a></li><li><a href=#preface-acknowledgements>Remerciements</a></li></ul></li><li><a href=#getting-started>Partie I: Pour commencer</a><ul><li><a href=#introduction>Chapitre 1. Introduction</a></li><li><a href=#bsdinstall>Chapitre 2. Installing FreeBSD</a></li><li><a href=#basics>Chapitre 3. Quelques bases d’UNIX</a></li><li><a href=#ports>Chapitre 4. Installer des applications: les logiciels pré-compilés et les logiciels portés</a></li><li><a href=#x11>Chapitre 5. Le système X Window</a></li></ul></li><li><a href=#common-tasks>Partie II: Tâches courantes</a><ul><li><a href=#desktop>Chapitre 6. Bureautique</a></li><li><a href=#multimedia>Chapitre 7. Multimédia</a></li><li><a href=#kernelconfig>Chapitre 8. Configurer le noyau de FreeBSD</a></li><li><a href=#printing>Chapitre 9. Imprimer</a></li><li><a href=#linuxemu>Chapitre 10. Compatibilité binaire avec Linux</a></li><li><a href=#wine>Chapitre 11. WINE</a></li></ul></li><li><a href=#system-administration>Partie III: Administration Système</a><ul><li><a href=#config-tuning>Chapitre 12. Configuration et optimisation</a></li><li><a href=#boot>Chapitre 13. Processus de démarrage de FreeBSD</a></li><li><a href=#users>Chapitre 14. Gestion des comptes et des utilisateurs</a></li><li><a href=#security>Chapitre 15. Sécurité</a></li><li><a href=#jails>Chapitre 16. Jails</a></li><li><a href=#mac>Chapitre 17. Mandatory Access Control <strong>Traduction en Cours</strong></a></li><li><a href=#audit>Chapitre 18. Audit des événements relatifs à la sécurité du système</a></li><li><a href=#disks>Chapitre 19. Stockage des données</a></li><li><a href=#geom>Chapitre 20. GEOM: architecture modulaire de gestion des disques</a></li><li><a href=#zfs>Chapitre 21. The Z File System (ZFS) <strong>Traduction en Cours</strong></a></li><li><a href=#filesystems>Chapitre 22. Autres systèmes de fichiers</a></li><li><a href=#vinum-vinum>Chapitre 23. Le gestionnaire de volume Vinum</a></li><li><a href=#virtualization>Chapitre 24. Virtualisation</a></li><li><a href=#l10n>Chapitre 25. Localisation - Utilisation et configuration de l’I18N/L10N</a></li><li><a href=#updating-upgrading>Chapitre 26. Mise à jour de FreeBSD</a></li><li><a href=#dtrace>Chapitre 27. DTrace</a></li></ul></li><li><a href=#network-communication>Partie IV: Réseau</a><ul><li><a href=#serialcomms>Chapitre 28. Serial Communications <strong>Traduction en Cours</strong></a></li><li><a href=#ppp-and-slip>Chapitre 29. PPP et SLIP</a></li><li><a href=#mail>Chapitre 30. Courrier électronique</a></li><li><a href=#network-servers>Chapitre 31. Serveurs réseau</a></li><li><a href=#firewalls>Chapitre 32. Firewalls <strong>Traduction en Cours</strong></a></li><li><a href=#advanced-networking>Chapitre 33. Administration réseau avancée</a></li></ul></li><li><a href=#appendices>Partie V: Annexes</a><ul><li><a href=#mirrors>Annexe A: Se procurer FreeBSD</a></li><li><a href=#bibliography>Annexe B: Bibliographie</a></li><li><a href=#eresources>Annexe C: Ressources sur Internet</a></li><li><a href=#pgpkeys>Annexe D: Clés OpenPGP</a></li></ul></li></ul></nav><hr><div class=resources><h3>Ressources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Téléchargement en PDF"></i><a href=https://download.freebsd.org/doc/fr/books/handbook/handbook_fr.pdf>Téléchargement en PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Éditer cette page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/fr/book target=_blank>Éditer cette page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/fr/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>French</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Clair</option><option value=theme-dark>Sombre</option><option value=theme-high-contrast>Contraste élevé</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/fr class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/fr/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>