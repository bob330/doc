<!doctype html><html class=theme-light lang=fr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/><title>Chapitre 32. Administration réseau avancée | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Chapitre 32. Administration réseau avancée"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="fr"><meta property="og:url" content="https://docs.freebsd.org/fr/books/handbook/advanced-networking/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/fr\/books\/handbook\/advanced-networking\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/fr>Documentation portal</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/fr/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/fr/books>Books</a></li><li><a href=https://docs.freebsd.org/fr/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/fr/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=fr>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/preface/>Préface</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-audience>Public visé</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-changes-from2>Modifications depuis la Seconde Edition</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-changes>Modifications depuis la Première Edition</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-overview>Organisation de cet ouvrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-conv>Conventions utilisées dans ce livre</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/preface/#preface-acknowledgements>Remerciements</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/parti/>Partie I. Pour commencer</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/introduction/>Chapitre 1. Introduction</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/introduction/#introduction-synopsis>1.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/introduction/#nutshell>1.2. Bienvenue à FreeBSD!</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/introduction/#history>1.3. A propos du Projet FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/>Chapitre 2. Installer FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Configuration matérielle minimale</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Tâches de pré-installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-start>2.4. Lancer l’installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#using-bsdinstall>2.5. Utilisation de bsdinstall</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Allouer l’espace disque</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Récupération des fichiers de distribution</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-post>2.8. Comptes utilisateurs, fuseau horaire, services et renforcement de la sécurité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-network>2.9. Interfaces réseau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Dépannage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bsdinstall/#using-live-cd>2.11. Utilisation du CD Live</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/basics/>Chapitre 3. Quelques bases d'UNIX</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-synopsis>3.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#consoles>3.2. Consoles virtuelles terminaux</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#permissions>3.3. Permissions</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#dirstructure>3.4. Organisation de l’arborescence des répertoires</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#disk-organization>3.5. Organisation des disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#mount-unmount>3.6. Monter et démonter des systèmes de fichiers</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-processes>3.7. Processus</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-daemons>3.8. Daemons, signaux, et comment tuer un processus</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#shells>3.9. Interpréteurs de commandes - "Shells"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#editors>3.10. Editeurs de texte</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-devices>3.11. Périphériques et fichiers spéciaux de périphérique</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#binary-formats>3.12. Le format des fichiers binaires</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/basics/#basics-more-information>3.13. Pour plus d’information</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/ports/>Chapitre 4. Installer des applications: les logiciels pré-compilés et les logiciels portés</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-synopsis>4.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-overview>4.2. Généralités sur l’installation de logiciels</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-finding-applications>4.3. Trouver votre application</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#packages-using>4.4. Utiliser le système des logiciels pré-compilés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-using>4.5. Utiliser le catalogue des logiciels portés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-nextsteps>4.6. Activités de post-installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ports/#ports-broken>4.7. Que faire avec les logiciels portés ne fonctionnant pas?</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/x11/>Chapitre 5. Le système X Window</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x11-synopsis>5.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-understanding>5.2. Terminologie</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-install>5.3. Installer X11</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-config>5.4. Configuration d’Xorg</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-fonts>5.5. Utilisation des polices de caractères sous Xorg</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-xdm>5.6. Le gestionnaire de connexion graphique XDM</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x11-wm>5.7. Environnements de bureau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/x11/#x-compiz-fusion>5.8. Installation de Compiz Fusion</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partii/>Partie II. Tâches courantes</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/desktop/>Chapitre 6. Bureautique</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-synopsis>6.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-browsers>6.2. Navigateurs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-productivity>6.3. Productivité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-viewers>6.4. Lecteurs de document</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-finance>6.5. Finance</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/desktop/#desktop-summary>6.6. Résumé</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/>Chapitre 7. Multimédia</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#multimedia-synopsis>7.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#sound-setup>7.2. Configurer une carte son</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#sound-mp3>7.3. Fichiers MP3</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#video-playback>7.4. Lecture des Vidéos</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#tvcard>7.5. Configuration des cartes TV</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/multimedia/#scanners>7.6. Scanners</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/>Chapitre 8. Configurer le noyau de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Pourquoi compiler un noyau sur mesure?</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-building>8.3. Compiler et installer un noyau sur mesure</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-config>8.4. Le fichier de configuration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/kernelconfig/#kernelconfig-trouble>8.5. Si quelque chose se passe mal</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/printing/>Chapitre 9. Imprimer</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-synopsis>9.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-intro-spooler>9.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-intro-setup>9.3. Configuration de base</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-advanced>9.4. Configuration avancée de l’imprimante</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-using>9.5. Using Printers <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-lpd-alternatives>9.6. Alternatives to the Standard Spooler <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/printing/#printing-troubleshooting>9.7. Troubleshooting <strong>Traduction en Cours</strong></a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/>Chapitre 10. Compatibilité binaire avec Linux</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Configurer la compatibilité binaire avec Linux</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-packages>10.3. Système de base CentOS à partir des paquets binaires FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-debootstrap>10.4. Système de base Debian / Ubuntu avec debootstrap(8)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/linuxemu/#linuxemu-advanced>10.5. Sujets avancés</a></li></ul></li><li><input type=checkbox id=chapter-54c06b703788dcba4081bec5a0407412 class=toggle>
<label class="icon cursor" for=chapter-54c06b703788dcba4081bec5a0407412><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/wine/>Chapitre 11. WINE</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-synopsis>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-overview-concepts>11.2. WINE généralités et concepts</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#installing-wine-on-freebsd>11.3. Installer WINE sur FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#running-first-wine-program>11.4. Lancer un premier programme WINE sous FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#configuring-wine-installation>11.5. Configurer WINE après installation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-management-guis>11.6. Interfaces graphiques de gestion de WINE</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-in-multi-user-os-installations>11.7. WINE sur un système FreeBSD avec plusieurs utilisateurs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/wine/#wine-on-os-faq>11.8. WINE sur FreeBSD Foire Aux Questions</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partiii/>Partie III. Administration Système</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/config/>Chapitre 11. Configuration et optimisation</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#config-synopsis>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-core-configuration>11.2. Configuration principale</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-appconfig>11.3. Configuration des applications</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-starting-services>11.4. Démarrer des services</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-cron>11.5. Configuration de l’utilitaire <code>cron</code></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-rcd>11.6. Utilisation du système rc(8) sous FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#config-network-setup>11.7. Configuration des cartes réseaux</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-virtual-hosts>11.8. Hôtes virtuels</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-configfiles>11.9. Fichiers de configuration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-sysctl>11.10. Optimisation avec sysctl(8)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-disk>11.11. Optimiser les disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#configtuning-kernel-limits>11.12. Optimisation des limitations du noyau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#adding-swap-space>11.13. Ajouter de l’espace de pagination</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#acpi-overview>11.14. Gestion de l’énergie et des ressources</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/config/#ACPI-debug>11.15. Utiliser et déboguer l’ACPI sous FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/boot/>Chapitre 12. Processus de démarrage de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-synopsis>12.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-introduction>12.2. Le problème du démarrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-blocks>12.3. Le gestionnaire de démarrage et les étapes de démarrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-kernel>12.4. Interaction avec le noyau au démarrage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#device-hints>12.5. "Device Hints"-Paramétrage des périphériques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-init>12.6. Init: Initialisation de la gestion des processus</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/boot/#boot-shutdown>12.7. Séquence d’arrêt du système</a></li></ul></li><li><input type=checkbox id=chapter-d251c21b963b5ab783e5aec225e02b5a class=toggle>
<label class="icon cursor" for=chapter-d251c21b963b5ab783e5aec225e02b5a><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/users/>Chapitre 13. Gestion des comptes et des utilisateurs</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-synopsis>13.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-introduction>13.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-superuser>13.3. Le compte super-utilisateur</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-system>13.4. Comptes système</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-user>13.5. Comptes utilisateur</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-modifying>13.6. Modifier des comptes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-limiting>13.7. Mettre en place des restrictions pour les utilisateurs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/users/#users-groups>13.8. Groupes</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/security/>Chapitre 14. Sécurité</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-synopsis>14.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-intro>14.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#securing-freebsd>14.3. Securing FreeBSD <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#crypt>14.4. DES, MD5, et chiffrement</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#one-time-passwords>14.5. Mots de passe non réutilisables</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#tcpwrappers>14.6. L’encapsuleur TCP ("TCP Wrappers")</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#kerberosIV>14.7. Kerberos</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#kerberos5>14.8. Kerberos5 <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#openssl>14.9. OpenSSL</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#ipsec>14.10. IPsec</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#openssh>14.11. OpenSSH</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#fs-acl>14.12. Listes de contrôle d’accès au système de fichiers</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-portaudit>14.13. Surveillance des problèmes de sécurité relatifs aux programmes tierce-partie</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-advisories>14.14. Avis de sécurité de FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/security/#security-accounting>14.15. Comptabilité des processus</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/jails/>Chapitre 15. Environnements jail</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-synopsis>15.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-terms>15.2. Termes relatifs aux environnements jail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-intro>15.3. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-build>15.4. Création et contrôle de l’environnement jail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/jails/#jails-tuning>15.5. Optimisation et administration</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/mac/>Chapitre 16. Mandatory Access Control ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-synopsis>16.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-glossary>16.2. Key Terms in this Chapter</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-initial>16.3. Explanation of MAC</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-understandlabel>16.4. Understanding MAC Labels</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-modules>16.5. Module Configuration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-bsdextended>16.6. The MAC bsdextended Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-ifoff>16.7. The MAC ifoff Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-portacl>16.8. The MAC portacl Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-labelingpolicies>16.9. MAC Policies with Labeling Features</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-partition>16.10. The MAC partition Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-mls>16.11. The MAC Multi-Level Security Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-biba>16.12. The MAC Biba Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-lomac>16.13. The MAC LOMAC Module</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-implementing>16.14. Implementing a Secure Environment with MAC</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#MAC-examplehttpd>16.15. Another Example: Using MAC to Constrain a Web Server</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mac/#mac-troubleshoot>16.16. Troubleshooting the MAC Framework</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/audit/>Chapitre 17. Audit des événements relatifs à la sécurité du système</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-synopsis>17.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-inline-glossary>17.2. Mots-clés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-config>17.3. Configuration de l’audit</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/audit/#audit-administration>17.4. Travailler avec les traces d’audit</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/disks/>Chapitre 18. Stockage des données</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-synopsis>18.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-naming>18.2. Noms des périphériques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-adding>18.3. Ajouter des disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#raid>18.4. RAID</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#usb-disks>18.5. Périphériques de stockage USB</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#creating-cds>18.6. Création et utilisation de supports optiques (CDs)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#creating-dvds>18.7. Création et utilisation de supports optiques (DVDs)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#floppies>18.8. Création et utilisation de disquettes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backups-tapebackups>18.9. Créer et utiliser les bandes magnétiques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backups-floppybackups>18.10. Sauvegardes sur disquettes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backup-strategies>18.11. Stratégies de sauvegarde</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#backup-basics>18.12. Sauvegardes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-virtual>18.13. Systèmes de fichiers réseaux, en mémoire et sauvegardés sur fichier</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#snapshots>18.14. Instantané ("Snapshot") d’un système de fichiers</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#quotas>18.15. Quotas d’utilisation des disques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#disks-encrypting>18.16. Chiffrer les partitions d’un disque</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/disks/#swap-encrypting>18.17. Chiffrage de l’espace de pagination</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/geom/>Chapitre 19. GEOM: architecture modulaire de gestion des disques</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-synopsis>19.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-intro>19.2. Introduction à GEOM</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-striping>19.3. RAID0 - "Striping"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#GEOM-mirror>19.4. RAID1 - "mirroring"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#geom-ggate>19.5. Périphériques réseau "GEOM Gate"</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/geom/#geom-glabel>19.6. Ajouter un label à un disque</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/zfs/>Chapitre 20. The Z File System (ZFS) ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-differences>20.1. What Makes ZFS Different</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-quickstart>20.2. Quick Start Guide</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-zpool>20.3. <code>zpool</code> Administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-zfs>20.4. <code>zfs</code> Administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-zfs-allow>20.5. Delegated Administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-links>20.6. Additional Resources</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/zfs/#zfs-term>20.7. ZFS Features and Terminology</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/filesystems/>Chapitre 21. Autres systèmes de fichiers</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/filesystems/#filesystems-synopsis>21.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/filesystems/#filesystems-linux>21.2. Systèmes de fichiers Linux®</a></li></ul></li><li><input type=checkbox id=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e class=toggle>
<label class="icon cursor" for=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/vinum/>Chapitre 22. Le gestionnaire de volume Vinum</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-synopsis>22.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-intro>22.2. Les disques sont trop petits</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#_les_goulots_détranglement_daccès_aux_données>22.3. Les goulots d’étranglement d’accès aux données</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#_intégrité_des_données>22.4. Intégrité des données</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-objects>22.5. Objets Vinum</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-examples>22.6. Quelques exemples</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#_appellation_des_objets>22.7. Appellation des objets</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/vinum/#vinum-config>22.8. Configuration de Vinum</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/>Chapitre 23. Virtualisation</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/#virtualization-synopsis>23.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/#virtualization-guest>23.2. FreeBSD comme système d’exploitation invité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/virtualization/#virtualization-host>23.3. FreeBSD comme système d’exploitation hôte</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/l10n/>Chapitre 24. Localisation - Utilisation et configuration de l'I18N/L10N</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#l10n-synopsis>24.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#l10n-basics>24.2. Les bases</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#using-localization>24.3. Utiliser la localisation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#l10n-compiling>24.4. Compiler des programmes I18N</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/l10n/#lang-setup>24.5. Localiser FreeBSD pour des langues spécifiques</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/>Chapitre 25. Mise à jour de FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-synopsis>25.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>25.2. Mise à jour de FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-portsnap>25.3. Portsnap: un outil de mise à jour du catalogue des logiciels portés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#updating-upgrading-documentation>25.4. Updating the Documentation Set <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#current-stable>25.5. Suivre une branche de développement</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#synching>25.6. Synchroniser vos sources</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#makeworld>25.7. Recompiler le système</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/cutting-edge/#small-lan>25.8. Suivre les mises à jour pour plusieurs machines</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/>Chapitre 26. DTrace</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-synopsis>26.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-implementation>26.2. Des différences de mise en oeuvre</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-enable>26.3. Activer la prise en charge de DTrace</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-using>26.4. Utiliser DTrace</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/dtrace/#dtrace-language>26.5. Le langage D</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partiv/>Partie IV. Réseau</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/>Chapitre 27. Serial Communications ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#serial-synopsis>27.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#serial>27.2. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#term>27.3. Terminals</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#dialup>27.4. Dial-in Service</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#dialout>27.5. Dial-out Service</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/serialcomms/#serialconsole-setup>27.6. Setting Up the Serial Console</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/>Chapitre 28. PPP et SLIP</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>28.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#userppp>28.2. Using User PPP <strong>Traduction en Cours</strong></a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#ppp>28.3. Utiliser PPP intégré au noyau</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#pppoe>28.4. Utiliser PPP sur Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#pppoa>28.5. Utiliser PPP sur ATM (PPPoA)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/ppp-and-slip/#slip>28.6. Utiliser SLIP</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/mail/>Chapitre 29. Courrier électronique</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-synopsis>29.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-using>29.2. Utilisation du courrier électronique</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#sendmail>29.3. Configuration de sendmail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-changingmta>29.4. Changer votre agent de transfert de courrier</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-trouble>29.5. Dépannage</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-advanced>29.6. Sujets avancés</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#SMTP-UUCP>29.7. SMTP avec UUCP</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#outgoing-only>29.8. Configuration pour l’envoi seul</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#SMTP-dialup>29.9. Utiliser le courrier électronique avec une connexion temporaire</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#SMTP-Auth>29.10. Authentification SMTP</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-agents>29.11. Clients de messagerie</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-fetchmail>29.12. Utiliser fetchmail</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mail/#mail-procmail>29.13. Utiliser procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/>Chapitre 30. Serveurs réseau</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-servers-synopsis>30.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-inetd>30.2. Le "super-serveur" inetd</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-nfs>30.3. Système de fichiers réseau (NFS)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-nis>30.4. Services d’information réseau (NIS/YP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-dhcp>30.5. Configuration réseau automatique (DHCP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-dns>30.6. Serveurs de noms (DNS)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-apache>30.7. Serveur HTTP Apache</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-ftp>30.8. Protocole de transfert de fichiers (FTP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-samba>30.9. Serveur de fichiers et d’impression pour clients Microsoft® Windows® (Samba)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/network-servers/#network-ntp>30.10. Synchronisation de l’horloge avec NTP</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/>Chapitre 31. Firewalls ** Traduction en Cours **</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-intro>31.1. Introduction</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-concepts>31.2. Firewall Concepts</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-apps>31.3. Firewall Packages</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-pf>31.4. The OpenBSD Packet Filter (PF) and ALTQ</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-ipf>31.5. The IPFILTER (IPF) Firewall</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/firewalls/#firewalls-ipfw>31.6. IPFW</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle checked>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/>Chapitre 32. Administration réseau avancée</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#advanced-networking-synopsis>32.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-routing>32.2. Passerelles et routes</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-wireless>32.3. Réseau sans fil</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-bluetooth>32.4. Bluetooth</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-bridging>32.5. Bridging</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-diskless>32.6. Système sans disque dur</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-isdn>32.7. ISDN</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-natd>32.8. Translation d’adresses</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-plip>32.9. IP sur liaison parallèle (PLIP)</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-ipv6>32.10. IPv6</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/advanced-networking/#network-atm>32.11. ATM ("Asynchronous Transfer Mode")</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/partv/>Partie V. Annexes</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/>Annexe A. Se procurer FreeBSD</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-cdrom>A.1. Editeurs de CD-ROMs et DVDs</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-ftp>A.2. Sites FTP</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#anoncvs>A.3. CVS anonyme</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#ctm>A.4. Utiliser CTM</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#cvsup>A.5. Utiliser CVSup</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#portsnap>A.6. Utiliser Portsnap</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#cvs-tags>A.7. Etiquettes CVS</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-afs>A.8. Sites AFS</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/mirrors/#mirrors-rsync>A.9. Sites rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/>Annexe B. Bibliographie</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-freebsd>B.1. Livres magazines consacrés à FreeBSD</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-userguides>B.2. Manuels d’utilisation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-adminguides>B.3. Manuels d’administration</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-programmers>B.4. Manuels de programmation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-osinternals>B.5. "Internes" du système d’exploitation</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-security>B.6. Ouvrages de référence en matière de sécurité</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-hardware>B.7. Ouvrages de référence sur le matériel</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-history>B.8. Histoire d’UNIX®</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/bibliography/#bibliography-journals>B.9. Revues et journaux</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/eresources/>Annexe C. Ressources sur Internet</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-mail>C.1. Listes de diffusion</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-news>C.2. Forums de discussion</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-web>C.3. Serveurs World Wide Web</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-email>C.4. Adresses électroniques</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook/eresources/#eresources-shell>C.5. Comptes</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/fr/books/handbook/pgpkeys/>Annexe D. Clés OpenPGP</a><ul><li><a href=https://docs.freebsd.org/fr/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Chapitre 32. Administration réseau avancée</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>32.1. Synopsis</a></li><li><a href=#network-routing>32.2. Passerelles et routes</a></li><li><a href=#network-wireless>32.3. Réseau sans fil</a></li><li><a href=#network-bluetooth>32.4. Bluetooth</a></li><li><a href=#network-bridging>32.5. Bridging</a></li><li><a href=#network-diskless>32.6. Système sans disque dur</a></li><li><a href=#network-isdn>32.7. ISDN</a></li><li><a href=#network-natd>32.8. Translation d’adresses</a></li><li><a href=#network-plip>32.9. IP sur liaison parallèle (PLIP)</a></li><li><a href=#network-ipv6>32.10. IPv6</a></li><li><a href=#network-atm>32.11. ATM ("Asynchronous Transfer Mode")</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=advanced-networking-synopsis>32.1. Synopsis<a class=anchor href=#advanced-networking-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Ce chapitre abordera certains nombre de sujets réseau avancés.</p></div><div class=paragraph><p>Après la lecture de ce chapitre, vous connaîtrez:</p></div><div class=ulist><ul><li><p>Les bases sur les passerelles et les routes.</p></li><li><p>Comment configurer les périphériques IEEE 802.11 et Bluetooth®.</p></li><li><p>Comment utiliser FreeBSD en tant que pont ("bridge").</p></li><li><p>Comment configurer le démarrage via le réseau pour une machine sans disque dur.</p></li><li><p>Comment configurer la translation d’adresse réseau.</p></li><li><p>Comment connecter deux ordinateurs via PLIP.</p></li><li><p>Comment configurer l’IPv6 sur une machine FreeBSD.</p></li><li><p>Comment configurer ATM.</p></li></ul></div><div class=paragraph><p>Avant de lire ce chapitre, vous devrez:</p></div><div class=ulist><ul><li><p>Comprendre les bases des procédures <span class=filename>/etc/rc</span>.</p></li><li><p>Etre familier avec la terminologie réseau de base.</p></li><li><p>Savoir comment configurer et installer un nouveau noyau FreeBSD (<a href=../kernelconfig/#kernelconfig>Configurer le noyau de FreeBSD</a>).</p></li><li><p>Savoir comment installer des logiciels tierce-partie (<a href=../ports/#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=network-routing>32.2. Passerelles et routes<a class=anchor href=#network-routing></a></h2><div class=sectionbody><div class=paragraph><p>Pour qu’une machine soit en mesure d’en contacter une autre, il faut que soit mis en place un mécanisme qui décrive comment aller de l’une à l’autre. C’est ce que l’on appelle le <em>routage</em>. Une "route" est définie par une paire d’adresses: une "destination" et une "passerelle". Cette paire signifie que pour atteindre cette <em>destination</em>, vous devez passer par cette <em>passerelle</em>. Il y a trois sortes de destination: les machines individuelles, les sous-réseaux, et "default"-la destination par défaut. La route par défaut ("default route") est utilisée lorsqu’aucune autre route n’est applicable. Nous parlerons un peu plus des routes par défaut par la suite. Il existe également trois sortes de passerelles: les machines individuelles, les interfaces (aussi appelées "liens"), et les adresses Ethernet matérielles (adresses MAC).</p></div><div class=sect2><h3 id=_un_exemple>32.2.1. Un exemple<a class=anchor href=#_un_exemple></a></h3><div class=paragraph><p>Pour illustrer différents aspects du routage, nous utiliserons l’exemple suivant, qui est produit par la commande <code>netstat</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1             UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>Les deux premières lignes définissent la route par défaut (dont nous parlerons dans la <a href=#network-routing-default>section suivante</a>) et la route <code>localhost</code>.</p></div><div class=paragraph><p>L’interface (colonne <code>Netif</code>) qu’il est indiqué d’utiliser pour <code>localhost</code> est <span class=filename>lo0</span>, aussi appelée interface "loopback"-en boucle. Ce qui veut dire que tout le trafic vers cette destination doit rester interne, au lieu d’être envoyé sur le réseau local, puisqu’il reviendra de toute façon à son point de départ.</p></div><div class=paragraph><p>Ce qui se remarque ensuite, ce sont les adresses commençant par <code>0:e0:</code>. Ce sont les adresses Ethernet matérielles, qui sont également connues sous le nom d’adresses MAC. FreeBSD reconnaîtra automatiquement toute machine (<code>test0</code> dans l’exemple) sur le réseau local Ethernet et ajoutera une route vers cette machine, directement via l’interface Ethernet <span class=filename>ed0</span>. Il y a aussi un délai (colonne <code>Expire</code>) associé à ce type de route, qui est utilisé si l’on entend plus parler de cette machine pendant un laps de temps précis. Quand cela arrive, la route vers cette machine est automatiquement supprimée. Ces machines sont identifiées par un mécanisme appelé RIP ("Routing Information Protocol"-protocole d’information de routage), qui met en place des routes vers les machines locales en déterminant le chemin le plus court.</p></div><div class=paragraph><p>FreeBSD ajoutera également des routes de sous-réseau pour le sous-réseau local (<code>10.20.30.255</code> est l’adresse de diffusion pour le sous-réseau <code>10.20.30</code>, et <code>example.com</code> est le nom de domaine associé à ce sous-réseau). La dénomination <code>link#1</code> fait référence à la première carte Ethernet de la machine. Vous constaterez qu’il n’y a pas d’autre interface associée à ces routes.</p></div><div class=paragraph><p>Ces deux types de routes (vers les machines du réseau local et les sous-réseaux locaux) sont automatiquement configurés par un "daemon" appelé routed. S’il ne tourne pas, alors seules les routes définies comme statiques (i.e. explicitement définies) existeront.</p></div><div class=paragraph><p>La ligne <code>host1</code> fait référence à votre machine, qui est identifiée par l’adresse Ethernet. Puisque nous sommes l’émetteur, FreeBSD sait qu’il faut utiliser l’interface en "boucle" (<span class=filename>lo0</span>) plutôt que d’envoyer les données sur l’interface Ethernet.</p></div><div class=paragraph><p>Les deux lignes <code>host2</code> montrent ce qui se passe quand on utilise un alias avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> (lisez la section sur l’Ethernet pour savoir pour quelles raisons on peut vouloir cela). Le symbole <code>=</code> qui suit l’interface <span class=filename>lo0</span> indique que non seulement nous utilisons l’interface en "boucle" (puisque cette adresse correspond également à la machine locale), mais que c’est plus spécifiquement un alias. Ce type de route n’apparaît que sur la machine pour laquelle est défini l’alias; sur toutes les autres machines du réseau local il n’y aura q’une ligne <code>link#1</code> pour cette machine.</p></div><div class=paragraph><p>La dernière ligne (le sous-réseau destinataire <code>224</code>) concerne le multicasting (diffusion pour plusieurs destinataires), qui sera abordé dans une autre section.</p></div><div class=paragraph><p>Et enfin, diverses caractéristiques de chaque route sont indiquées dans la colonne <code>Flags</code> (indicateurs). Ci-dessous, une courte table présente certains de ces indicateurs et leur signification:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Active ("Up"): la route est active.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Machine ("Host"): la destination de la route est une machine.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Passerelle ("Gateway"): envoyer tout ce qui concerne cette destination sur la machine distante indiquée, qui déterminera à qui transmettre ensuite.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Statique ("Static"): cette route a été configurée manuellement et non pas générée automatiquement par le système.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clone: génère une nouvelle route sur la base de celle-ci pour les machines auxquelles nous nous connectons. Ce type de route est normalement utilisé pour les réseaux locaux.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clonée ("WasCloned"): cette route a été auto-configurée (Clone) à partir d’une route pour le réseau local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lien ("Link"): la route fait référence à une adresse matérielle Ethernet.</p></td></tr></tbody></table></div><div class=sect2><h3 id=network-routing-default>32.2.2. Routes par défaut<a class=anchor href=#network-routing-default></a></h3><div class=paragraph><p>Quand le système local doit établir une connexion avec une machine distante, il consulte la table de routage pour voir s’il existe déjà une route connue. Si la machine distante appartient à un sous-réseau auquel le système sait se connecter (routes clonées), alors le système vérifie s’il peut se connecter via cette interface.</p></div><div class=paragraph><p>Si toutes les routes connues échouent, il reste alors au système une dernière option: la route par "défaut". Cette route est un type particulier de route passerelle (c’est généralement la seule du système), et est toujours marquée avec un <code>c</code> dans le champ des indicateurs. Pour les machines du réseau local, cette passerelle est définie avec la machine qui est directement connectée au monde extérieur (que ce soit par une liaison PPP, DSL, cable, T1, ou toute autre interface réseau).</p></div><div class=paragraph><p>Si vous configurez la route par défaut sur une machine qui fonctionne comme passerelle vers le monde extérieur, alors la route par défaut sera la passerelle de votre Fournisseur d’Accès à Internet (FAI).</p></div><div class=paragraph><p>Examinons un exemple de route par défaut. Voici une configuration classique:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/net-routing.png alt="net routing"></div></div><div class=paragraph><p>Les machines <code>Local1</code> et <code>Local2</code> sont sur votre site. <code>Local1</code> est connectée au serveur du FAI via une liaison PPP par modem. Ce serveur PPP est connecté par l’intermédiaire d’un réseau local à un autre ordinateur passerelle relié au point d’entrée Internet du FAI.</p></div><div class=paragraph><p>Les routes par défaut sur chacune de vos machines seront:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Machine</th><th class="tableblock halign-left valign-top">Passerelle par défaut</th><th class="tableblock halign-left valign-top">Interface</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ethernet</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PPP</p></td></tr></tbody></table><div class=paragraph><p>Une question qui revient souvent est "Pourquoi (ou comment) définir <code>T1-GW</code> comme passerelle par défaut pour <code>Local1</code>, plutôt que le serveur du FAI auquel elle est connectée?".</p></div><div class=paragraph><p>Rappelez-vous, puisque l’interface PPP utilise, de votre côté de la connexion, une adresse IP du réseau local du FAI, les routes vers toute autre machine du réseau local du FAI seront automatiquement générées. Par conséquent vous savez déjà comment atteindre la machine <code>T1-GW</code>, il n’y a donc pas besoin d’étape intermédiaire qui passe par le serveur du FAI.</p></div><div class=paragraph><p>Il est habituel d’attribuer l’adresse <code>X.X.X.1</code> à la passerelle sur votre réseau local. Donc (dans notre exemple), si votre espace d’adresse de classe C local était <code>10.20.30</code> et que votre FAI utilisait l’espace <code>10.9.9</code>, alors les routes par défaut seraient:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machine</th><th class="tableblock halign-left valign-top">Route par défaut</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2 (10.20.30.2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1, 10.9.9.30)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW (10.9.9.1)</p></td></tr></tbody></table><div class=paragraph><p>Vous pouvez aisément définir la route par défaut via le fichier <span class=filename>/etc/rc.conf</span>. Dans notre exemple, sur la machine <code>Local2</code>, nous avons ajouté la ligne suivante dans <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>Il est également possible de faire directement cela à partir de la ligne de commande avec la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Pour plus d’informations sur la manipulation à la main des tables de routage réseau, consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect2><h3 id=_machines_sur_deux_réseaux>32.2.3. Machines sur deux réseaux<a class=anchor href=#_machines_sur_deux_réseaux></a></h3><div class=paragraph><p>Il y a un autre type de configuration dont il faut parler, c’est celle d’une machine qui est connectée à deux réseaux différents. Techniquement, toute machine servant de passerelle (comme dans l’exemple ci-dessus, en utilisant une connexion PPP) est une machine sur deux réseaux. Mais ce terme n’est normalement utilisé que pour faire référence à une machine qui est sur deux réseaux locaux différents.</p></div><div class=paragraph><p>Selon le cas, la machine dispose de deux cartes Ethernet, ayant chacune une adresse sur des sous-réseaux séparés. Alternativement, la machine peut ne disposer que d’une seule carte Ethernet, et utiliser des alias avec <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Le premier cas correspond à l’utilisation de deux réseaux Ethernet physiquement séparés, le deuxième cas est employé s’il n’y a qu’un seul réseau physique mais deux sous-réseaux logiquement distincts.</p></div><div class=paragraph><p>Dans les deux cas, les tables de routage sont définies de telle sorte que chaque sous-réseau sache que cette machine est la passerelle (route entrante) vers l’autre sous-réseau. Cette configuration, où la machine sert de routeur entre les deux sous-réseaux, est souvent utilisée quand il faut mettre en place un dispositif de sécurité: filtrage de paquets ou coupe-feu, dans l’une ou dans les deux directions.</p></div><div class=paragraph><p>Si vous voulez que cette machine transmette réellement les paquets entre les deux interfaces, vous devez demander à FreeBSD d’activer cette fonctionnalité. Lisez la section suivante pour plus de détails sur comment faire cela.</p></div></div><div class=sect2><h3 id=network-dedicated-router>32.2.4. Mettre en place un routeur<a class=anchor href=#network-dedicated-router></a></h3><div class=paragraph><p>Un routeur est un système qui transmet les paquets d’une interface à une autre. Les standards de l’Internet et de bons principes d’ingénierie empêchent le projet FreeBSD d’activer cette fonction par défaut sous FreeBSD. Vous pouvez l’activer en positionnant à <code>YES</code> la variable suivante du fichier <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>Cette option fixera la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>net.inet.ip.forwarding</code> à la valeur <code>1</code>. Si vous devez arrêter temporairement le routage, vous pouvez positionner la variable momentanément à <code>0</code>.</p></div><div class=paragraph><p>Votre nouveau routeur aura besoin de route pour savoir où envoyer le trafic. Si votre réseau est suffisamment simple vous pouvez utiliser des routes statiques. FreeBSD est également fourni avec le "daemon" de routage BSD standard <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, qui comprend et utilise les protocoles RIP (version 1 est 2) et IRDP. Le support de BGP v4, OSPF v2, et d’autres protocoles de routage sophistiqué est disponible avec le logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a>. Des produits commerciaux comme GateD® sont également disponibles comme solutions avancées de routage.</p></div></div><div class=sect2><h3 id=_configurarion_des_routes_statiques>32.2.5. Configurarion des routes statiques<a class=anchor href=#_configurarion_des_routes_statiques></a></h3><div class=sect3><h4 id=_configuration_manuelle>32.2.5.1. Configuration manuelle<a class=anchor href=#_configuration_manuelle></a></h4><div class=paragraph><p>Supposons que nous avons un réseau comme celui-ci:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>Dans ce scénario, <code>RouteurA</code> est notre machine FreeBSD qui joue le rôle de routeur pour l’Internet. Elle a une route par défaut vers <code>10.0.0.1</code> qui permet de se connecter au reste du monde extérieur. Nous supposerons que la machine <code>RouteurB</code> est correctement configurée et sait comment transmettre vers n’importe quelle destination (D’après notre schéma c’est relativement simple. Ajoutez juste une route par défaut sur <code>RouteurB</code> en utilisant <code>192.168.1.1</code> comme passerelle).</p></div><div class=paragraph><p>Si nous regardons la table de routage de <code>RouteurA</code> nous verrions quelque chose comme:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Avec la table de routage actuelle, <code>RouteurA</code> ne sera pas en mesure d’atteindre notre réseau interne 2. Elle ne dispose pas de route pour <code>192.168.2.0/24</code>. Une manière de résoudre cela est d’ajouter manuellement la route. La commande suivante ajouterait le réseau interne 2 à la table de routage de <code>RouteurA</code> en utilisant <code>192.168.1.2</code> comme point intermédiaire:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Maintenant <code>RouteurA</code> peut joindre n’importe quelle machine du réseau <code>192.168.2.0/24</code>.</p></div></div><div class=sect3><h4 id=_configuration_persistante>32.2.5.2. Configuration persistante<a class=anchor href=#_configuration_persistante></a></h4><div class=paragraph><p>L’exemple précédent est parfait pour configurer une route statique sur un système en fonctionnement. Cependant, le problème est que l’information de routage ne sera pas conservée si vous redémarrez votre machine FreeBSD. L’addition d’une route statique doit se faire dans votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>La variable <code>static_routes</code> est une liste de chaîne de caractères séparées par une espace. Chaque chaîne fait référence à un nom de route. Dans notre exemple nous avons qu’une seule chaîne dans <code>static_routes</code>. Cette chaîne est <em>internalnet2</em>. Nous ajoutons ensuite une variable de configuration appelée <code>route_internalnet2</code> dans laquelle nous mettons tous les paramètres de configuration que nous passerions à la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>. Pour nous exemple précédent nous aurions utilisé la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>nous avons donc besoin de <code>"-net 192.168.2.0/24 192.168.1.2"</code>.</p></div><div class=paragraph><p>Comme cela a été précisé, nous pouvons avoir plus d’une chaîne dans la variable <code>static_routes</code>. Cela nous permet de créer plusieurs routes statiques. Les lignes suivantes donnent un exemple d’ajout de routes statiques pour les réseaux <code>192.168.0.0/24</code> et <code>192.168.1.0/24</code> sur un routeur imaginaire:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div></div><div class=sect2><h3 id=_propagation_de_route>32.2.6. Propagation de route<a class=anchor href=#_propagation_de_route></a></h3><div class=paragraph><p>Nous avons déjà expliqué comment définir nos routes vers le monde extérieur, mais pas comment le monde extérieur apprend à nous localiser.</p></div><div class=paragraph><p>Nous savons déjà que les tables de routages peuvent être renseignées pour que tout le trafic pour un espace d’adresses donné (dans nos exemples, un sous-réseau de classe C) soit envoyé à une machine précise de ce réseau, qui transmettra les paquets entrants.</p></div><div class=paragraph><p>Lorsqu’il attribue un espace d’adresses à votre site, votre fournisseur d’accès définira ses tables de routage de sorte que tout le trafic destiné à votre sous-réseau vous soit envoyé sur votre liaison PPP. Mais comment les sites à l’autre bout du pays savent-ils qu’ils doivent passer par votre fournisseur d’accès?</p></div><div class=paragraph><p>Il existe un mécanisme (assez semblable au système d’information distribué du DNS) qui conserve un enregistrement de tous les espaces d’adresses affectés, et définit leur point de connexion à la dorsale Internet ("backbone"). La "dorsale" comprend les liaisons principales qui véhiculent le trafic Internet à travers le pays et le monde entier. Chaque machine de la dorsale dispose d’une copie de l’ensemble des tables maîtresses qui aiguillent le trafic pour un réseau donné vers le transporteur correspondant de la dorsale, et de là par l’intermédiaire de fournisseurs d’accès successifs, jusqu’à atteindre votre réseau.</p></div><div class=paragraph><p>C’est le rôle de votre fournisseur d’accès d’annoncer aux sites de la dorsale qu’il est le point de connexion (et par conséquent la route entrante) pour votre site. C’est ce que l’on appelle la propagation de route.</p></div></div><div class=sect2><h3 id=_en_cas_de_problème>32.2.7. En cas de problème<a class=anchor href=#_en_cas_de_problème></a></h3><div class=paragraph><p>Il se peut qu’il y ait parfois un problème avec la propagation de route et que certains sites ne puissent vous atteindre. La commande probablement la plus utile pour déterminer où une route est défaillante est la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>. Elle est également utile si vous n’arrivez pas à vous connecter à une machine distante (i.e. lorsque <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> échoue).</p></div><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> prend comme paramètre le nom de la machine distante avec laquelle vous essayez d’établir une connexion. Elle vous donnera la liste de passerelles intermédiaires jusqu’à la machine cible, ou jusqu’à ce qu’il n’y ait plus de connexion.</p></div><div class=paragraph><p>Pour plus d’informations, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect2><h3 id=_routage_multicast>32.2.8. Routage multicast<a class=anchor href=#_routage_multicast></a></h3><div class=paragraph><p>FreeBSD supporte nativement les applications et le routage multicast (diffusion pour plusieurs destinataires). Les applications multicast ne nécessitent pas de configuration spécifique de FreeBSD, généralement, elles fonctionneront directement. Le routage multicast demande à ce que le support soit compilé dans le noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>De plus, le "daemon" de routage multicast, <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> doit être configuré par l’intermédiaire du fichier <span class=filename>/etc/mrouted.conf</span> pour mettre en place des tunnels et le protocole DVMRP. Plus de détails sur la configuration du routage multicast peuvent être trouvés dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a>.</p></div></div></div></div><div class=sect1><h2 id=network-wireless>32.3. Réseau sans fil<a class=anchor href=#network-wireless></a></h2><div class=sectionbody><div class=sect2><h3 id=_introduction>32.3.1. Introduction<a class=anchor href=#_introduction></a></h3><div class=paragraph><p>Il peut être très utile de pouvoir utiliser un micro-ordinateur sans le désagrément d’être constamment relié à un câble réseau. FreeBSD peut être utilisé comme client sans fil, et même comme "point d’accès" sans fil.</p></div></div><div class=sect2><h3 id=_modes_de_fonctionnement_des_systèmes_sans_fils>32.3.2. Modes de fonctionnement des systèmes sans fils<a class=anchor href=#_modes_de_fonctionnement_des_systèmes_sans_fils></a></h3><div class=paragraph><p>Il existe deux manières différentes de configurer les périphériques sans fil 802.11: les modes BSS et IBSS.</p></div><div class=sect3><h4 id=_mode_bss>32.3.2.1. Mode BSS<a class=anchor href=#_mode_bss></a></h4><div class=paragraph><p>Le mode BSS est le mode généralement utilisé. Le mode BSS est également appelé mode infrastructure. Dans ce mode, plusieurs points d’accès sans fils sont connectés à un réseau câblé. Chaque réseau sans fil possède son propre nom. Ce nom est ce que l’on appelle le "SSID" du réseau.</p></div><div class=paragraph><p>Les clients sans fils se connectent à ces points d’accès sans fils. La norme IEEE 802.11 définie le protocole que les réseaux sans fils utilisent pour les connexions. Un client sans fil peut être attaché à un réseau particulier quand un SSID est fixé. Un client peut s’attacher à n’importe quel réseau en ne définissant pas explicitement de SSID.</p></div></div><div class=sect3><h4 id=_mode_ibss>32.3.2.2. Mode IBSS<a class=anchor href=#_mode_ibss></a></h4><div class=paragraph><p>Le mode IBSS, également appelé mode "ad-hoc", est conçu pour les connexions point à point. Il existe en fait deux types de mode ad-hoc. Le premier est le mode IBSS, également appelé mode ad-hoc ou IEEE ad-hoc. Ce mode est défini par les normes IEEE 802.11. Le deuxième mode est appelé ad-hoc démo ou encore mode ad-hoc Lucent (et parfois, ce qui prête à confusion, mode ad-hoc). C’est l’ancien mode ad-hoc pré-standard 802.11 et ne devrait être utilisé qu’avec d’anciennes installations. Nous ne parlerons pas des modes ad-hoc dans ce qui suit.</p></div></div></div><div class=sect2><h3 id=_mode_infrastructure>32.3.3. Mode infrastructure<a class=anchor href=#_mode_infrastructure></a></h3><div class=sect3><h4 id=_points_daccès>32.3.3.1. Points d’accès<a class=anchor href=#_points_daccès></a></h4><div class=paragraph><p>Un point d’accès est un périphérique sans fil qui permet à un ou plusieurs clients sans fils d’utiliser ce périphérique comme un hub. Quand ils utilisent un point d’accès, tous les clients communiquent par l’intermédiaire de ce point d’accès. Plusieurs points d’accès sont souvent utilisés pour couvrir l’intégralité d’une zone géographique comme une maison, une entreprise, ou un parc avec un réseau sans fil.</p></div><div class=paragraph><p>Les points d’accès ont généralement plusieurs connexions réseaux: la carte réseaux sans fil, et une ou plusieurs cartes réseaux Ethernet pour les connexions avec le reste du réseau.</p></div><div class=paragraph><p>Les points d’accès peuvent être achetés tout fait, ou vous pouvez construire le votre avec FreeBSD et une carte réseau sans fil supportée. De nombreux constructeurs proposent des points d’accès et des cartes réseaux sans fils avec diverses fonctionnalités.</p></div></div><div class=sect3><h4 id=_construire_un_point_daccès_avec_freebsd>32.3.3.2. Construire un point d’accès avec FreeBSD<a class=anchor href=#_construire_un_point_daccès_avec_freebsd></a></h4><div class=sect4><h5 id=_pré_requis>32.3.3.2.1. Pré-requis<a class=anchor href=#_pré_requis></a></h5><div class=paragraph><p>En vue de mettre en place un point d’accès sans fil sous FreeBSD, vous avez besoin d’une carte réseau sans fil compatible. Actuellement seule les cartes basées sur le circuit Prism sont supportées. Vous aurez également besoin d’une carte réseau câblée supportée par FreeBSD (cela ne devrait pas être difficile à trouver, FreeBSD supporte de nombreuses cartes). Dans le cadre de cette section, nous supposerons que le trafic passera par un pont entre la carte sans fil et le réseau relié à la carte réseau classique.</p></div><div class=paragraph><p>Le mode point d’accès implémenté par FreeBSD fonctionne mieux avec certaines versions de firmware. Les cartes utilisant un circuit Prism 2 devraient utiliser un firmware 1.3.4 ou plus récent. Les cartes Prism 2.5 et Prism 3 devraient utiliser la version 1.4.9. Des versions de firmware plus anciennes pourront ne pas fonctionner correctement. Actuellement, la seule manière de mettre à jour vos cartes est d’utiliser les outils de mise à jour du firmware pour Windows® disponibles auprès du constructeur de votre carte.</p></div></div><div class=sect4><h5 id=_configuration>32.3.3.2.2. Configuration<a class=anchor href=#_configuration></a></h5><div class=paragraph><p>Assurez-vous tout d’abord que votre système voit la carte réseau sans fil:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
	status: no carrier
	ssid <span class=s2>&#34;&#34;</span>
	stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>Ne vous préoccupez pas des détails, verifiez juste que s’affiche quelque chose qui vous indique qu’une carte réseau sans fil est installée. Si vous avez des problèmes à voir l’interface réseau sans fil correspondante, et que vous utilisez une carte de type PC Card, vous devriez consultez les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardc&amp;sektion=8&amp;format=html">pccardc(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardd&amp;sektion=8&amp;format=html">pccardd(8)</a> pour plus d’information.</p></div><div class=paragraph><p>Ensuite, vous devrez charger un module afin de mettre en place la partie de FreeBSD faisant office de pont pour le point d’accès. Pour charger le module <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a>, exécutez la commande suivante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload bridge</span></code></pre></div></div><div class=paragraph><p>Vous ne devriez pas voir apparaître de message d’erreur lors du chargement du module. Si ce n’est pas le cas, vous devrez peut-être compiler le support <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> dans votre noyau. La section sur le <a href=#network-bridging>Bridging</a> de ce manuel devrait pouvoir vous aider dans cette tâche.</p></div><div class=paragraph><p>Maintenant que cette partie est assurée, nous devons dire à FreeBSD entre quelles interface le pont doit être installé. Nous effectuons cette configuration en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge.enable=1</span>
<span class=c># sysctl net.link.ether.bridge.config=&#34;wi0 xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Sous les versions antérieures à la 5.2, vous devez utiliser à la place les options suivantes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge=1</span>
<span class=c># sysctl net.link.ether.bridge_cfg=&#34;wi0,xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Il est maintenant possible de configurer la carte. La commande suivante positionnera la carte en mode point d’accès:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname &#34;FreeBSD AP&#34;</span></code></pre></div></div><div class=paragraph><p>La ligne <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> active l’interface <span class=filename>wi0</span>, fixe son paramètre SSID à la valeur <em>my_net</em>, et fixe le nom de station à <em>FreeBSD AP</em>. L’option <code>media DS/11Mbps</code> positionne la carte dans le mode 11Mbps et est nécessaire pour que le paramètre <code>mediaopt</code> soit pris en compte. L’option <code>mediaopt hostap</code> place l’interface dans le mode point d’accès. L’option <code>channel 11</code> fixe le canal 802.11b à employer. La page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> donne les options de canaux valides en fonction de votre zone géographique.</p></div><div class=paragraph><p>Vous devez maintenant disposer d’un point d’accès opérationnel et en fonctionnement. Vous êtes encouragés à lire les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, et <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> pour plus d’amples informations.</p></div><div class=paragraph><p>Il est également conseillé de lire la section qui suit sur le chiffrage.</p></div></div><div class=sect4><h5 id=_information_détat>32.3.3.2.3. Information d’état<a class=anchor href=#_information_détat></a></h5><div class=paragraph><p>Une fois que le point d’accès est configuré et opérationnel, les opérateurs voudront voir quels clients sont associés avec le point d’accès. A n’importe quel instant, l’opérateur pourra taper:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wicontrol -l</span>
1 station:
00:09:b7:7b:9d:16  <span class=nv>asid</span><span class=o>=</span>04c0, <span class=nv>flags</span><span class=o>=</span>3&lt;ASSOC,AUTH&gt;, <span class=nv>caps</span><span class=o>=</span>1&lt;ESS&gt;, <span class=nv>rates</span><span class=o>=</span>f&lt;1M,2M,5.5M,11M&gt;, <span class=nv>sig</span><span class=o>=</span>38/15</code></pre></div></div><div class=paragraph><p>Ceci nous montre qu’une station est associée, ainsi que son paramétrage. Les informations indiquées concernant le signal devraient être utilisées uniquement comme une indication relative sur sa puissance. Sa conversion en dBm ou tout autre unité varie en fonction des différentes versions de firmware.</p></div></div></div><div class=sect3><h4 id=_clients>32.3.3.3. Clients<a class=anchor href=#_clients></a></h4><div class=paragraph><p>Un client sans fil est un système qui se connecte à un point d’accès ou un autre client directement.</p></div><div class=paragraph><p>Typiquement, les clients sans fils disposent d’une seule interface réseau, la carte réseau sans fil.</p></div><div class=paragraph><p>Il existe quelques manières différentes de configurer un client sans fil. Elles sont basées sur les différents modes sans fils, généralement les modes BSS (mode infrastructure, qui nécessite un point d’accès), et IBSS (mode ad-hoc, ou mode point à point). Dans notre exemple, nous utiliserons le plus populaire des deux, le mode BSS, pour discuter avec un point d’accès.</p></div><div class=sect4><h5 id=_pré_requis_2>32.3.3.3.1. Pré-requis<a class=anchor href=#_pré_requis_2></a></h5><div class=paragraph><p>Il n’y a qu’un seul pré-requis pour configurer FreeBSD comme client sans fil. Vous aurez besoin d’une carte sans fil supportée par FreeBSD.</p></div></div><div class=sect4><h5 id=_configurer_un_client_sans_fil_freebsd>32.3.3.3.2. Configurer un client sans fil FreeBSD<a class=anchor href=#_configurer_un_client_sans_fil_freebsd></a></h5><div class=paragraph><p>Avant de commencer, vous aurez besoin de connaître certaines choses concernant le réseau sans fil auquel vous désirez vous connecter. Dans cet exemple, nous rejoignons un réseau ayant pour nom <em>my_net</em>, et avec le chiffrage des liaisons désactivé.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans cet exemple, nous n’utilisons pas le chiffrage des liaisons, ce qui est une situation dangereuse. Dans la section suivante, nous verrons comment activer le chiffrage, pourquoi il est important de le faire, et pourquoi certaines technologies de chiffrage ne vous protégerons pas complètement.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Assurez-vous que votre carte est reconnue par FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
	status: no carrier
	ssid <span class=s2>&#34;&#34;</span>
	stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>Maintenant, nous pouvons configurer la carte suivant les paramètres de notre réseau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</span></code></pre></div></div><div class=paragraph><p>Remplacez <code>192.168.0.20</code> et <code>255.255.255.0</code> avec une adresse IP ainsi qu’un masque de sous-réseau valides de votre réseau câblé. Rappelez-vous, notre point d’accès joue le rôle de pont entre le réseau sans fil et le réseau câblé, il apparaîtra aux autres cartes sur votre réseau que vous êtes sur le même réseau câblé.</p></div><div class=paragraph><p>Une fois cela effectué, vous devriez être en mesure d’utiliser <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> pour atteindre les machines sur le réseau câblé de la même façon que si vous étiez connecté en utilisant un câble réseau standard.</p></div><div class=paragraph><p>Si vous rencontrez des problèmes avec votre connexion sans fil, vérifiez que vous êtes associé-"associated" (connecté) avec le point d’accès:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0</span></code></pre></div></div><div class=paragraph><p>devrait retourner un certain nombre d’information; et vous devriez voir s’afficher:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>status: associated</code></pre></div></div><div class=paragraph><p>Si <code>associated</code> n’est pas affiché, alors il se peut que vous soyez hors de portée du point d’accès, que vous ayez le chiffrage activé, ou peut-être que vous ayez un problème de configuration.</p></div></div></div><div class=sect3><h4 id=_chiffrement>32.3.3.4. Chiffrement<a class=anchor href=#_chiffrement></a></h4><div class=paragraph><p>L’utilisation du chiffrement sur un réseau sans fil est important parce que vous n’avez plus la possibilité de conserver le réseau dans une zone protégée. Vos données sans fil seront diffusées dans tout le voisinage, et toute personne désirant y accéder pourra le faire. C’est ici que le chiffrement entre en jeu. En chiffrant les données qui sont envoyées par les ondes, vous rendez plus difficile l’interception de celles-ci par quiconque d’intéressé.</p></div><div class=paragraph><p>Les deux méthodes les plus courantes de chiffrage des données entre un client et un point d’accès sont le protocol WEP et <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a>.</p></div><div class=sect4><h5 id=_wep>32.3.3.4.1. WEP<a class=anchor href=#_wep></a></h5><div class=paragraph><p>WEP est l’abbrévation de "Wired Equivalency Protocol". Le protocole de chiffrage WEP est une tentative de rendre les réseaux sans fils aussi sûrs et sécurisés qu’un réseau filaire. Malheureusement, il a été craqué, et est relativement simple à déjouer. Cela signifie que l’on ne doit pas lui faire confiance quand il est nécessaire de chiffrer des données sensibles.</p></div><div class=paragraph><p>Cela reste mieux que rien du tout, utilisez ce qui suit pour activer WEP sur votre nouveau point d’accès FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</span></code></pre></div></div><div class=paragraph><p>Et vous pouvez activer WEP sur un client avec la commande:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</span></code></pre></div></div><div class=paragraph><p>Notez que vous devriez remplacer <em>0x1234567890</em> par une clé plus personnelle.</p></div></div><div class=sect4><h5 id=_ipsec>32.3.3.4.2. IPsec<a class=anchor href=#_ipsec></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> est un outil bien plus puissant et robuste pour chiffrer des données sur un réseau. C’est la méthode à préférer pour chiffrer les données sur un réseau sans fil. Vous pouvez obtenir plus de détails concernant <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> et comment l’implémenter dans la section <a href=#ipsec>IPsec</a> de ce manuel.</p></div></div></div><div class=sect3><h4 id=_outils>32.3.3.5. Outils<a class=anchor href=#_outils></a></h4><div class=paragraph><p>Il existe un petit nombre d’outils disponibles pour le débogage et la configuration d’un réseau sans fil, et nous tenterons ici d’en décrire certains ainsi que leurs fonctionnalités.</p></div><div class=sect4><h5 id=_la_suite_bsd_airtools>32.3.3.5.1. La suite bsd-airtools<a class=anchor href=#_la_suite_bsd_airtools></a></h5><div class=paragraph><p>La suite bsd-airtools est une trousse à outils complète qui comprend des outils d’audit sans fil pour le craquage du système WEP, la détection de points d’accès, etc.</p></div><div class=paragraph><p>Les utilitaires bsd-airtools peuvent être installés à partir du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsd-airtools/>net-mgmt/bsd-airtools</a>. Des instructions sur l’installation des logiciels portés peuvent être trouvées dans le <a href=../ports/#ports>Installer des applications. les logiciels pré-compilés et les logiciels portés</a> de ce manuel.</p></div><div class=paragraph><p>Le programme <code>dstumbler</code> est l’outil qui permet la recherche de points d’accès et la mesure du rapport signal sur bruit. Si vous avez des difficultés à mettre en place et à faire fonctionner votre point d’accès, <code>dstumbler</code> pourra vous aider dans ce sens.</p></div><div class=paragraph><p>Pour tester la sécurité de votre réseau sans fil, vous pouvez choisir d’employer les outils "dweputils" (<code>dwepcrack</code>, <code>dwepdump</code> et <code>dwepkeygen</code>) pour vous aider à déterminer si WEP répond à vos besoins en matière de sécurité au niveau de votre réseau sans fil.</p></div></div><div class=sect4><h5 id=_les_utilitaires_wicontrol_ancontrol_et_raycontrol>32.3.3.5.2. Les utilitaires <code>wicontrol</code>, <code>ancontrol</code> et <code>raycontrol</code><a class=anchor href=#_les_utilitaires_wicontrol_ancontrol_et_raycontrol></a></h5><div class=paragraph><p>Il existe des outils que vous pouvez utiliser pour contrôler le comportement de votre carte réseau sans fil sur le réseau sans fil. Dans les exemples précédents, nous avons choisi d’employer <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> puisque notre carte sans fil utilise l’interface <span class=filename>wi0</span>. Si vous avez une carte sans fil Cisco, elle apparaîtrait comme <span class=filename>an0</span>, et vous utiliseriez alors le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=ancontrol&amp;sektion=8&amp;format=html">ancontrol(8)</a>.</p></div></div><div class=sect4><h5 id=_la_commande_ifconfig>32.3.3.5.3. La commande <code>ifconfig</code><a class=anchor href=#_la_commande_ifconfig></a></h5><div class=paragraph><p>La commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> propose plusieurs options identiques à celles de <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a>, cependant il manque quelques options. Consultez la page de manuel d’<a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> pour les différents paramètres et options en ligne de commande.</p></div></div></div><div class=sect3><h4 id=_cartes_supportées>32.3.3.6. Cartes supportées<a class=anchor href=#_cartes_supportées></a></h4><div class=sect4><h5 id=_points_daccès_2>32.3.3.6.1. Points d’accès<a class=anchor href=#_points_daccès_2></a></h5><div class=paragraph><p>Les seules cartes actuellement supportées pour le mode BSS (points d’accès) sont celles basées sur les circuits Prism 2, 2.5, ou 3. Pour une liste complète, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a>.</p></div></div><div class=sect4><h5 id=_clients_802_11b>32.3.3.6.2. Clients 802.11b<a class=anchor href=#_clients_802_11b></a></h5><div class=paragraph><p>Presque toutes les cartes réseaux sans fil 802.11b sont supportées sous FreeBSD. La plupart des cartes basées sur les circuits Prism, Spectrum24, Hermes, Aironet, et Raylink fonctionneront dans le mode IBSS (ad-hoc, point à point, et BSS).</p></div></div><div class=sect4><h5 id=_clients_802_11a_802_11g>32.3.3.6.3. Clients 802.11a 802.11g<a class=anchor href=#_clients_802_11a_802_11g></a></h5><div class=paragraph><p>Le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> supporte les normes 802.11a et 802.11g. Si votre carte est basée sur un circuit Atheros, vous devriez être en mesure d’utiliser ce pilote.</p></div><div class=paragraph><p>Malheureusement il y a toujours de nombreux fabricants qui ne fournissent pas à la communauté des logiciels libres les informations concernant les pilotes pour leurs cartes considérant de telles informations comme des secrets industriels. Par conséquent, il ne reste aux développeurs de FreeBSD et d’autres systèmes d’exploitation libres que deux choix: développer les pilotes en passant par un long et pénible processus de "reverse engineering" ou utiliser les pilotes binaires existants disponibles pour la plateforme Microsoft® Windows®. La plupart des développeurs, y compris ceux impliqués dans FreeBSD, ont choisi cette dernière approche.</p></div><div class=paragraph><p>Grâce aux contributions de Bill Paul (wpaul), depuis FreeBSD 5.3-RELEASE, il existe un support "natif" pour la spécification d’interface des pilotes de périphérique réseau (Network Driver Interface Specification-NDIS). Le NDISulator FreeBSD (connu également sous le nom de Project Evil) prend un pilote binaire réseau Windows® et lui fait penser qu’il est en train de tourner sous Windows®. Cette fonctionnalité est relativement nouvelle, mais semble fonctionner correctement dans la plupart des tests.</p></div><div class=paragraph><p>Pour utiliser le NDISulator, vous avez besoin de trois choses:</p></div><div class="olist arabic"><ol class=arabic><li><p>les sources du noyau;</p></li><li><p>le pilote binaire Windows® XP (extension <span class=filename>.SYS</span>);</p></li><li><p>le fichier de configuration du pilote Windows® XP (extension <span class=filename>.INF</span>).</p></li></ol></div><div class=paragraph><p>Vous aurez besoin de compiler le module d’interface du mini-pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>. En tant que <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/modules/ndis</span>
<span class=c># make  make install</span></code></pre></div></div><div class=paragraph><p>Recherchez les fichiers spécifiques à votre carte. Généralement, ils peuvent être trouvés sur les CDs livrés avec la carte ou sur le site du fabricant. Dans les exemples qui suivent nous utiliseront les fichiers <span class=filename>W32DRIVER.SYS</span> et <span class=filename>W32DRIVER.INF</span>.</p></div><div class=paragraph><p>L’étape suivante est de compiler le pilote binaire dans un module chargeable du noyau. Pour effectuer cela, en tant que <code>root</code>, rendez vous dans le répertoire du module <span class=filename>if_ndis</span> et copiez-y les fichiers du pilote Windows®:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/modules/if_ndis</span>
<span class=c># cp /path/to/driver/W32DRIVER.SYS ./</span>
<span class=c># cp /path/to/driver/W32DRIVER.INF ./</span></code></pre></div></div><div class=paragraph><p>Nous utiliserons maintenant l’utilitaire <code>ndiscvt</code> pour générer le fichier d’entête <span class=filename>ndis_driver_data.h</span> du pilote pour la compilation du module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndiscvt -i W32DRIVER.INF -s W32DRIVER.SYS -o ndis_driver_data.h</span></code></pre></div></div><div class=paragraph><p>Les options <code>-i</code> et <code>-s</code> précisent respectivement le fichier de configuration et le fichier binaire. Nous utilisons l’option <code>-o ndis_driver_data.h</code> car le <span class=filename>Makefile</span> recherchera ce fichier lors de la compilation du module.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Certains pilotes Windows® nécessitent des fichiers supplémentaires pour fonctionner. Vous pouvez les ajouter avec <code>ndiscvt</code> en utilisant l’option <code>-f</code>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ndiscvt&amp;sektion=8&amp;format=html">ndiscvt(8)</a> pour plus d’information.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nous pouvons enfin compiler et installer le module du pilote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make  make install</span></code></pre></div></div><div class=paragraph><p>Pour utiliser le pilote, vous devez charger les modules appropriés:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>La première commande charge le pilote d’interface NDIS, la seconde charge l’interface réseau. Contrôlez la sortie de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> à la recherche d’une quelconque erreur au chargement. Si tout s’est bien passé, vous devriez obtenir une sortie ressemblant à ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
      ndis0: NDIS API version: 5.0
      ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
      ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
      ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>A partir de là, vous pouvez traiter le périphérique <span class=filename>ndis0</span> comme n’importe quel périphérique sans fil (e.g. <span class=filename>wi0</span>) et consulter les premières sections de ce chapitre.</p></div></div></div></div></div></div><div class=sect1><h2 id=network-bluetooth>32.4. Bluetooth<a class=anchor href=#network-bluetooth></a></h2><div class=sectionbody><div class=sect2><h3 id=_introduction_2>32.4.1. Introduction<a class=anchor href=#_introduction_2></a></h3><div class=paragraph><p>Bluetooth® est une technologie sans fil pour créer des réseaux personnels sans fils fonctionnant dans la bande 2.4 GHz ne nécessitant pas d’autorisation, avec une portée de 10 mètres. Les réseaux étant généralement composés de périphériques nomades comme les téléphones portables, les assistants personnels et les ordinateurs portables. Contrairement à l’autre technologie sans fil, Wi-Fi, Bluetooth® offre un niveau plus élevé de profils de service, par exemple des serveurs de fichiers semblables à FTP, "file pushing", transport de la voix, émulation de lignes séries, et bien plus.</p></div><div class=paragraph><p>La pile Bluetooth® sous FreeBSD utilise le système Netgraph (voir <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>). Une large gamme d’adaptateurs USB Bluetooth® sont supportés par le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Les périphériques Bluetooth® basés sur le circuit Broadcom BCM2033 sont supportés par les pilotes <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. La carte 3Com Bluetooth® PC Card 3CRWB60-A demande le pilote <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>. Les périphériques Bluetooth® de type série et UART sont supportés via les pilotes <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>. Cette section décrit l’utilisation d’un adaptateur USB Bluetooth®. Le support Bluetooth® est disponible sur les systèmes 5.0 et suivants.</p></div></div><div class=sect2><h3 id=_branchement_du_périphérique>32.4.2. Branchement du périphérique<a class=anchor href=#_branchement_du_périphérique></a></h3><div class=paragraph><p>Par défaut les pilotes de périphériques Bluetooth® sont disponibles sous la forme de modules du noyau. Avant de brancher le périphérique, vous devrez charger le pilote dans le noyau:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Si le périphérique Bluetooth® est présent au démarrage du système, chargez le module à partir de <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Branchez votre clé USB. Une sortie semblable à celle-ci devrait s’afficher sur la console (ou dans les journaux du système):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La pile Bluetooth doit être lancée manuellement sous FreeBSD 6.0, et sous les versions 5.0 antérieures à la 5.5. Ce lancement est automatique à partir de <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> sous FreeBSD 5.5, 6.1 et versions suivantes.</p></div><div class=paragraph><p>Copiez <span class=filename>/usr/shared/examples/netgraph/bluetooth/rc.bluetooth</span> à un emplacement adapté, comme <span class=filename>/etc/rc.bluetooth</span>. Cette procédure est utilisée pour démarrer et arrêter la pile Bluetooth®. C’est une bonne idée d’arrêter la pile avant de débrancher le périphérique, mais ce n’est pas (généralement) fatal. Quand la pile démarre, vous devriez avoir des messages similaires aux suivants:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_interface_de_contrôle_de_lhôte_hci>32.4.3. Interface de contrôle de l’hôte (HCI)<a class=anchor href=#_interface_de_contrôle_de_lhôte_hci></a></h3><div class=paragraph><p>L’interface de contrôle de l’hôte (HCI) fournit une interface de commande pour le contrôleur de la bande de base et le gestionnaire de liaisons, et l’accès à l’état du matériel et aux registres de contrôle. Cette interface offre une méthode uniforme d’accès aux fonctions de la bande de base Bluetooth®. La couche HCI de l’hôte échange des données et des commandes avec le firmware HCI du matériel Bluetooth®. Le pilote de la couche de transport du contrôleur d’hôte (i.e. le bus physique) fournit aux deux couches HCI la possibilité d’échanger des informations entre elles.</p></div><div class=paragraph><p>Un seul noeud Netgraph de type <em>hci</em> est créé pour un périphérique Bluetooth®. Le noeud HCI est normalement connecté au noeud du pilote Bluetooth® (flux descendant) et au noeud L2CAP (flux montant). Toutes les opérations HCI doivent être effectuées sur le noeud HCI et non pas sur le noeud du pilote de périphérique. Le nom par défaut pour le noeud HCI est "devicehci". Pour plus de détails consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Une des tâches les plus courantes est la recherche de périphériques Bluetooth® dans le voisinage hertzien. Cette opération est appelée <em>inquiry</em> (enquête, recherche). Cette recherche et les autres opérations relatives à HCI sont effectuées par l’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. L’exemple ci-dessous montre comment déterminer quels périphériques Bluetooth® sont dans le voisinage. Vous devriez obtenir une listes de périphériques au bout de quelques secondes. Notez qu’un périphérique distant ne répondra à la recherche que s’il est placé dans le mode <em>discoverable</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> est l’adresse unique d’un périphérique Bluetooth®, similaire à l’adresse MAC d’une carte réseau. Cette adresse est nécessaire pour communiquer avec un périphérique. Il est possible d’assigner un nom humainement compréhensible à l’adresse BD_ADDR. Le fichier <span class=filename>/etc/bluetooth/hosts</span> contient des informations concernant les hôtes Bluetooth® connus. L’exemple suivant montre comment obtenir le nom qui a été assigné au périphérique distant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Si vous effectuez une recherche sur un périphérique Bluetooth® distant, vous devriez trouver votre ordinateur en tant que "votre.machine.nom (ubt0)". Le nom affecté au périphérique local peut être modifié à tout moment.</p></div><div class=paragraph><p>Le système Bluetooth® fournit une connexion point à point (seules deux matériels Bluetooth® sont concernés), ou une connexion point à multipoints. Dans le cas d’une connexion point à multipoints, la connexion est partagés entre plusieurs périphériques Bluetooth®. L’exemple suivant montre comment obtenir la liste des connexions en bande de base actives pour le périphérique local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Une <em>manipulation de la connexion</em> est utile quand la fin d’une connexion en bande de base est nécessaire. Notez qu’il n’est normalement pas nécessaire de le faire à la main. La pile mettra fin automatiquement aux connexions en bande de base inactives.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Référez-vous à la commande <code>hccontrol help</code> pour une liste complète des commandes HCI disponibles. La plupart des commandes HCI ne nécessitent pas les privilèges du super-utilisateur.</p></div></div><div class=sect2><h3 id=_protocole_dadaptation_et_de_contrôle_de_lien_logique_l2cap>32.4.4. Protocole d’adaptation et de contrôle de lien logique (L2CAP)<a class=anchor href=#_protocole_dadaptation_et_de_contrôle_de_lien_logique_l2cap></a></h3><div class=paragraph><p>Le protocole d’adaptation et de contrôle de lien logique (L2CAP) fournit des services orientés connexion ou non aux protocoles de niveaux supérieurs, et cela avec des possibilités de multiplexage de protocoles, de segmentation et de réassemblage. L2CAP permet aux applications et aux protocoles de niveaux supérieurs de transmettre et recevoir des paquets L2CAP d’une taille allant jusqu’à 64 Ko.</p></div><div class=paragraph><p>L2CAP est basé sur le concept de <em>canaux</em>. Un canal est une connexion logique au sommet de la connexion en bande de base. Chaque canal est attaché à un protocole suivant le schéma plusieurs-vers-un. Plusieurs canaux peuvent être attachés au même protocole, mais un canal ne peut être attachés à plusieurs protocoles. Chaque paquet L2CAP reçu sur un canal est dirigé vers le protocole de niveau supérieur approprié. Plusieurs canaux peuvent partager la même connexion en bande de base.</p></div><div class=paragraph><p>Un seul noeud Netgraph de type <em>l2cap</em> est créé pour un périphérique Bluetooth®. Le noeud L2CAP est normalement connecté au noeud HCI Bluetooth® (flux descendant) et aux noeuds des "sockets" Bluetooth® (flux montant). Le nom par défaut pour le noeud L2CAP est "device2cap". Pour plus de détails consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Une commande utile est <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, qui peut être utilisée pour "pinguer" les autres périphériques. Certaines implémentations de Bluetooth® peuvent ne pas renvoyer toutes les données qui leur sont envoyées, aussi <code>0 bytes</code> dans ce qui suit est normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> est employé pour effectuer diverses opérations sur les noeuds L2CAP. Cet exemple montre comment obtenir la liste des connexions logiques (canaux) et la liste des connexions en bande de base pour le périphérique local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Un autre outil de diagnostic est <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. Il effectue un travail similaire à celui de <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, mais relatif aux structures de données réseau Bluetooth®. L’exemple ci-dessous montre la même connexion logique que <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> ci-dessus.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect2><h3 id=_protocole_rfcomm>32.4.5. Protocole RFCOMM<a class=anchor href=#_protocole_rfcomm></a></h3><div class=paragraph><p>Le protocole RFCOMM permet l’émulation du port série au-dessus du protocole L2CAP. Le protocole est basé sur la norme ETSI TS 07.10. RFCOMM est un protocole de transport simple, avec les dispositions supplémentaires pour émuler les 9 circuits (signaux) d’un port série RS232 (EIATIA-232-E). Le protocole RFCOMM supporte jusqu’à 60 connexions simultanées (canaux RFCOMM) entre deux périphériques Bluetooth®.</p></div><div class=paragraph><p>Dans le cas de RFCOMM, l’établissement d’une communication implique deux applications tournant sur des périphériques différents (les extrémités de la communication) avec un segment de communication entre eux. RFCOMM est prévu pour couvrir les applications faisant usage des ports séries des périphériques sur lesquels elles résident. Le segment de communication est une liaison Bluetooth® d’un périphérique vers un autre (connexion directe).</p></div><div class=paragraph><p>RFCOMM est seulement concerné par la connexion entre périphériques dans le cas d’un raccordement direct, ou entre le périphérique et un modem dans le cas d’un réseau. RFCOMM peut supporter d’autres configurations, comme les modules qui communiquent par l’intermédiaire de la technologie sans fil Bluetooth® d’un côté et utilise une interface câblée de l’autre côté.</p></div><div class=paragraph><p>Sous FreeBSD, le protocole RFCOMM est implémenté au niveau de la couche des "sockets" Bluetooth®.</p></div></div><div class=sect2><h3 id=_couplage_des_périphériques>32.4.6. Couplage des périphériques<a class=anchor href=#_couplage_des_périphériques></a></h3><div class=paragraph><p>Par défaut, une communication Bluetooth® n’est pas authentifiée, et n’importe quel périphérique peut parler avec n’importe quel autre périphérique. Un périphérique Bluetooth® (par exemple un téléphone portable) peut choisir de demander une authentification pour fournir un service particulier (par exemple un service de connexion téléphonique). L’authentification Bluetooth® est généralement effectuée avec des <em>codes PIN</em>. Un code PIN est une chaîne ASCII d’une longueur de 16 caractères. L’utilisateur doit entrer le même code PIN sur les deux périphériques. Une fois que l’utilisateur a entré le code PIN, les deux périphériques génèrent une <em>clé de liaison</em> (link key). Ensuite la clé peut être enregistrée soit dans les périphériques eux-mêmes ou sur un moyen de stockage non-volatile. La fois suivante les deux périphériques utiliseront la clé précédemment générée. La procédure décrite est appelée <em>couplage</em>. Si la clé de liaison est perdue par un des périphériques alors l’opération de couplage doit être répétée.</p></div><div class=paragraph><p>Le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> est responsable de la gestion de toutes les requêtes d’authentification Bluetooth®. Le fichier de configuration par défaut est <span class=filename>/etc/bluetooth/hcsecd.conf</span>. Un exemple de section pour un téléphone portable avec un code PIN arbitraire de "1234" est donné ci-dessous:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>Il n’y pas de limitation sur les codes PIN (en dehors de la longueur). Certains périphériques (comme les casques-micro Bluetooth®) peuvent avoir un code PIN définitivement fixé. Le paramètre <code>-d</code> force le "daemon" <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> à rester en tâche de fond, il est donc aisé de voir ce qu’il se passe. Configurez le périphérique distant pour recevoir le couplage et initier la connexion Bluetooth® vers le périphérique distant. Le périphérique distant devrait annoncer que le couplage a été accepté, et demander le code PIN. Entrez le même code PIN que celui que vous avez dans le fichier <span class=filename>hcsecd.conf</span>. Maintenant votre PC et le périphérique distant sont couplés. Alternativement, vous pouvez initier le couplage sur le périphérique distant.</p></div><div class=paragraph><p>Sous FreeBSD 5.5, 6.1 et versions suivantes, la ligne suivante peut être ajoutée au fichier <span class=filename>/etc/rc.conf</span> pour obtenir un lancement automatique de hcsecd au démarrage du système:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ce qui suit est une partie de la sortie du "daemon" hcsecd:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect2><h3 id=_le_protocole_de_découverte_de_service_sdp>32.4.7. Le protocole de découverte de service (SDP)<a class=anchor href=#_le_protocole_de_découverte_de_service_sdp></a></h3><div class=paragraph><p>Le protocole de découverte de service (SDP) offre aux applications clientes les moyens de découvrir l’existence des services fournis par les applications serveurs ainsi que les propriétés (attributs) de ces services. Les attributs d’un service comprennent le type ou la classe du service offert et le mécanisme ou l’information sur le protocole nécessaire pour utiliser le service.</p></div><div class=paragraph><p>Le SDP implique la communication entre un serveur SDP et un client SDP. Le serveur maintient une liste d’enregistrements de services qui décrit les caractéristiques des services associés avec le serveur. Chaque enregistrement de service contient l’information sur un seul serveur. Un client peut récupérer l’information à partir d’un enregistrement de service maintenu par le serveur SDP en émettant une requête SDP. Si le client, ou une application associée avec le client, décide d’utiliser un service, il doit ouvrir une connexion séparée avec le fournisseur du service afin d’utiliser ce service. Le SDP fournit un mécanisme pour découvrir les services et leur attributs, mais n’offre pas de mécanisme pour utiliser ces services.</p></div><div class=paragraph><p>Généralement, un client SDP recherche les services sur la base de caractéristiques de services désirées. Cependant, il est parfois désirable de découvrir quel type de services sont décrits par les enregistrements de services d’un serveur SDP sans aucune information préalable sur les services. Ce processus de recherche des services offerts est appelé <em>navigation</em> ("browsing").</p></div><div class=paragraph><p>Le serveur SDP Bluetooth® <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> et le client en ligne de commande <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> font partie de l’installation FreeBSD standard. L’exemple suivant montre comment effectuer un requête de navigation ("browse") SDP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>et ainsi de suite. Remarquez que chaque service a une liste d’attributs (canal RFCOMM par exemple). En fonction du service vous pourrez avoir besoin de prendre note de certains de ces attributs. Certaines implémentations Bluetooth® ne supportent pas les requêtes de navigation et peuvent renvoyer une liste vide. Dans ce cas il est possible de chercher un service spécifique. L’exemple ci-dessous montre comment chercher le service OBEX Object Push (OPUSH):</p></li></ol></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Offrir des services sous FreeBSD aux clients Bluetooth® se fait à l’aide du serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>. Sous les versions de FreeBSD 5.5, 6.1 et plus récentes, la ligne suivante peut être ajoutée au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ensuite, le "démon"sdpd peut être démarré avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sdpd start</span></code></pre></div></div><div class=paragraph><p>Sous FreeBSD 6.0, et sous les versions FreeBSD 5.X antérieures à 5.5, sdpd n’est pas intégré aux procédures de démarrage du système. Il doit être lancé manuellement:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpd</span></code></pre></div></div><div class=paragraph><p>L’application serveur locale qui désire offrir un service Bluetooth® à des clients distants enregistrera le service auprès du "daemon" SDP local. Un exemple d’une telle application est <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Une fois démarré, il enregistrera un service de réseau local Bluetooth® auprès du serveur SDP local.</p></div><div class=paragraph><p>La liste des services enregistrés auprès du serveur SDP local peut être obtenue en émettant une requête de navigation ("browse") SDP par l’intermédiaire du canal de contrôle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect2><h3 id=_les_profils_dial_up_networking_dun_et_accès_au_réseau_local_avec_ppp_lan>32.4.8. Les profils Dial-Up Networking (DUN) et accès au réseau local avec PPP (LAN)<a class=anchor href=#_les_profils_dial_up_networking_dun_et_accès_au_réseau_local_avec_ppp_lan></a></h3><div class=paragraph><p>Le profil Dial-Up Networking (DUN) est principalement utilisé avec les modems et les téléphones portables. Les cas de figure couverts par ce profil sont les suivants:</p></div><div class=ulist><ul><li><p>Utilisation d’un téléphone portable ou d’un modem par un ordinateur comme modem sans fil pour se connecter à un serveur d’accès Internet, ou pour l’utilisation de services accessibles par téléphone;</p></li><li><p>Utilisation d’un téléphone portable ou d’un modem par un ordinateur pour recevoir des appels avec transmission de données.</p></li></ul></div><div class=paragraph><p>Le profil d’accès au réseau local avec PPP (LAN) peut être utilisé dans les situations suivantes:</p></div><div class=ulist><ul><li><p>Accès au réseau local pour un périphérique Bluetooth®;</p></li><li><p>Accès au réseau local pour plusieurs périphériques Bluetooth®;</p></li><li><p>Liaison PC à PC (en utilisant le protocole PPP sur une émulation de câble série).</p></li></ul></div><div class=paragraph><p>Sous FreeBSD les deux profils sont implémentés par <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>-un "wrapper" convertit la connexion Bluetooth® RFCOMM en quelque chose d’utilisable par PPP. Avant qu’un profil ne soit utilisable, un nouveau label doit être créé dans le fichier <span class=filename>/etc/ppp/ppp.conf</span>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> pour des exemples.</p></div><div class=paragraph><p>Dans l’exemple suivant <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> sera employé pour ouvrir un connexion RFCOMM avec le périphérique distant avec une adresse BD_ADDR 00:80:37:29:19:a4 sur un canal DUN RFCOMM. Le numéro de canal RFCOMM réel sera obtenu du périphérique distant par l’intermédiaire de SDP. Il est possible de préciser le canal RFCOMM à la main, dans ce cas <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> n’émettra pas de requête SDP. Utilisez <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> pour trouver le canal RFCOMM sur le périphérique distant.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>Afin de fournir un service d’accès au réseau local avec PPP, le serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> doit être en fonctionnement. Une nouvelle entrée pour les clients du réseau local doit être créée dans le fichier <span class=filename>/etc/ppp/ppp.conf</span>. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> pour des exemples. Enfin, lancez le serveur RFCOMM PPP sur un numéro de canal RFCOMM valide. Le serveur RFCOMM PPP enregistrera automatiquement un service Bluetooth® LAN auprès du "daemon" SDP local. L’exemple ci-dessous montre comment démarrer le serveur RFCOMM PPP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect2><h3 id=_le_profil_obex_object_push_opush>32.4.9. Le profil OBEX Object Push (OPUSH)<a class=anchor href=#_le_profil_obex_object_push_opush></a></h3><div class=paragraph><p>OBEX (échange d’objets) est un protocole très largement utilisé pour les transferts de fichiers entre périphériques mobiles. Son utilisation principale se trouve dans les communications par infrarouge, où il est utilisé pour le transfert des fichiers entre ordinateurs portables ou PDAs, et pour envoyer des cartes de visite électronique ou des éléments d’agenda entre téléphones portables et d’autres périphériques disposant d’applications de gestion d’informations personnelles (PIM).</p></div><div class=paragraph><p>Le serveur et le client OBEX sont implémentés dans le logiciel tierce-partie obexapp, qui est disponible sous la forme du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a>.</p></div><div class=paragraph><p>Le client OBEX est employé pour "pousser" et/ou "tirer" des objets du serveur OBEX. Un objet peut être, par exemple, une carte de visite ou un rendez-vous. Le client OBEX peut obtenir un numéro de canal RFCOMM d’un périphérique distant par l’intermédiaire de SDP. Cela peut être fait en spécifiant le nom du service plutôt que le numéro du canal RFCOMM. Les noms de service supportés sont: IrMC, FTRN et OPUSH. Il est possible de préciser le canal RFCOMM par un nombre. Un exemple de session OBEX est présenté ci-dessous, où l’objet information du périphérique d’un téléphone portable est récupéré, et un nouvel objet (carte de visite) est envoyé dans le répertoire du téléphone.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Afin de fournir le service OBEX Object Push, le serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> doit tourner. Un dossier racine où tous les objets entrant seront stockés doit être créé. Le chemin d’accès par défaut du répertoire racine est <span class=filename>/var/spool/obex</span>. Le serveur OBEX enregistrera automatiquement le service OBEX Object Push auprès du "daemon" SDP local. L’exemple ci-dessous montre comment démarrer le serveur OBEX:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect2><h3 id=_le_profil_port_série_spp>32.4.10. Le profil port série (SPP)<a class=anchor href=#_le_profil_port_série_spp></a></h3><div class=paragraph><p>Le profil port série (SPP) permet aux périphériques Bluetooth® d’émuler un câble série RS232 (ou similaire). Ce profil traite avec les applications classiques en utilisant Bluetooth® comme un câble de remplacement, à travers une abstraction de port série virtuel.</p></div><div class=paragraph><p>L’utilitaire <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implémente le profil port série. Un pseudo terminal est utilisé comme abstraction de port série virtuel. L’exemple ci-dessous montre comment se connecter à un service port série d’un périphérique distant. Notez que vous n’avez pas besoin d’indiquer un canal RFCOMM - <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> peut l’obtenir auprès du périphérique distant via SDP. Si vous désirez forcer cela, spécifiez un canal RFCOMM sur la ligne de commande.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</span>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</code></pre></div></div><div class=paragraph><p>Une fois connecté, le pseudo-terminal peut être utilisé comme un port série:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l ttyp6</span></code></pre></div></div></div><div class=sect2><h3 id=_dépannage>32.4.11. Dépannage<a class=anchor href=#_dépannage></a></h3><div class=sect3><h4 id=_un_périphérique_distant_ne_peut_pas_se_connecter>32.4.11.1. Un périphérique distant ne peut pas se connecter<a class=anchor href=#_un_périphérique_distant_ne_peut_pas_se_connecter></a></h4><div class=paragraph><p>Certains anciens périphériques Bluetooth® ne supportent pas de changement de rôle. Par défaut, quand FreeBSD accepte une nouvelle connexion, il tente d’effectuer un changement de rôle et de devenir maître. Les périphériques qui ne supportent pas cela ne seront pas en mesure de se connecter. Notez qu’un changement de rôle est effectué quand une nouvelle connexion est établie, il n’est donc pas possible de demander au périphérique distant s’il supporte le changement de rôle. Il existe une option HCI pour désactiver le changement de rôle au niveau local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div></div><div class=sect3><h4 id=_quelque_chose_ne_va_pas_puis_je_voir_ce_qui_se_passe_exactement>32.4.11.2. Quelque chose ne va pas, puis-je voir ce qui se passe exactement?<a class=anchor href=#_quelque_chose_ne_va_pas_puis_je_voir_ce_qui_se_passe_exactement></a></h4><div class=paragraph><p>Bien sûr. Utilisez le logiciel tierce-partie hcidump qui est disponible sous <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> dans le catalogue des logiciels portés. L’utilitaire hcidump est similaire à <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. Il peut être utilisé pour afficher le contenu des paquets Bluetooth® à l’écran et les sauvegarder dans un fichier.</p></div></div></div></div></div><div class=sect1><h2 id=network-bridging>32.5. Bridging<a class=anchor href=#network-bridging></a></h2><div class=sectionbody><div class=sect2><h3 id=_introduction_3>32.5.1. Introduction<a class=anchor href=#_introduction_3></a></h3><div class=paragraph><p>Il est parfois utile de diviser un réseau physique (comme un réseau Ethernet) en deux réseaux séparés sans avoir à créer de sous-réseaux IPs et à utiliser un routeur pour connecter ces réseaux entre eux. Le périphérique qui connecte ensemble deux réseaux de cette manière est appelé "bridge"-pont. Un système FreeBSD avec deux cartes réseaux peut faire fonction de pont.</p></div><div class=paragraph><p>Le pont apprend les adresses MAC (adresses Ethernet) des périphériques branchés sur chacune de ses interfaces réseaux. Il transmet le trafic entre deux réseaux uniquement quand la source et la destination sont sur des réseaux différents.</p></div><div class=paragraph><p>Sous de nombreux aspects, un pont ressemble à un switch (commutateur) Ethernet avec très peu de ports.</p></div></div><div class=sect2><h3 id=_situations_où_lutilisation_dun_pont_est_appropriée>32.5.2. Situations où l’utilisation d’un pont est appropriée<a class=anchor href=#_situations_où_lutilisation_dun_pont_est_appropriée></a></h3><div class=paragraph><p>Il existe deux situations dans lesquelles un pont est de nos jours utilisé.</p></div><div class=sect3><h4 id=_trafic_important_sur_un_segment>32.5.2.1. Trafic important sur un segment<a class=anchor href=#_trafic_important_sur_un_segment></a></h4><div class=paragraph><p>La première situation apparaît quand un segment physique d’un réseau est submergé par le trafic, mais vous ne voulez pas, pour différentes raisons, subdiviser le réseau et interconnecter les sous-réseaux à l’aide d’un routeur.</p></div><div class=paragraph><p>Prenons comme exemple un journal où les bureaux de la rédaction et de la production sont sur le même sous-réseau. Les utilisateurs de la rédaction utilisent tous le serveur de fichiers <code>A</code>, et les utilisateurs de la production le serveur <code>B</code>. Un réseau Ethernet est utilisé pour connecter ensemble les utilisateurs, et des surcharges du réseau ralentissent les échanges.</p></div><div class=paragraph><p>Si les utilisateurs de la rédaction peuvent être cantonné sur un segment, et les utilisateurs de la production sur un autre, les deux réseaux pourront être connectés par un pont. Seul le trafic réseau destiné aux interfaces réseaux situées de l'"autre" côté du pont sera transmis à l’autre réseau, réduisant ainsi les congestions sur chaque segment.</p></div></div><div class=sect3><h4 id=_coupe_feu_filtrantrégulant_le_trafic>32.5.2.2. Coupe-feu filtrant/régulant le trafic<a class=anchor href=#_coupe_feu_filtrantrégulant_le_trafic></a></h4><div class=paragraph><p>La deuxième situation est quand un coupe-feu est nécessaire mais sans translation d’adresses (NAT).</p></div><div class=paragraph><p>Un exemple est une compagnie qui est connectée à son fournisseur d’accès internet par l’intermédiaire d’une connexion ISDN ou DSL. Elle dispose de 13 adresses IP routables fournies par le fournisseur d’accès et dispose de 10 PCs sur son réseau. Dans cette situation, utiliser un coupe-feu/routeur est complexe en raison des problèmes de sous-réseaux.</p></div><div class=paragraph><p>Un coupe-feu basé sur un pont peut être configuré et positionné dans le flux juste en aval de leur routeur DSL/ISDN sans aucun problème d’adressage IP.</p></div></div></div><div class=sect2><h3 id=_configuration_dun_pont>32.5.3. Configuration d’un pont<a class=anchor href=#_configuration_dun_pont></a></h3><div class=sect3><h4 id=_choix_des_cartes_réseaux>32.5.3.1. Choix des cartes réseaux<a class=anchor href=#_choix_des_cartes_réseaux></a></h4><div class=paragraph><p>Un pont nécessite au moins deux cartes réseaux pour fonctionner. Malheureusement toutes les cartes réseaux ne supportent pas le mode bridging. Lisez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> pour des détails sur les cartes supportées.</p></div><div class=paragraph><p>Installez et testez les deux cartes réseaux avant de poursuivre.</p></div></div><div class=sect3><h4 id=_modification_de_la_configuration_du_noyau>32.5.3.2. Modification de la configuration du noyau<a class=anchor href=#_modification_de_la_configuration_du_noyau></a></h4><div class=paragraph><p>Pour activer le support nécessaire pour mettre en place un pont ajouter la ligne suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>options BRIDGE</pre></div></div><div class=paragraph><p>à votre fichier de configuration du noyau, et recompilez votre noyau.</p></div></div><div class=sect3><h4 id=_support_du_coupe_feu>32.5.3.3. Support du coupe-feu<a class=anchor href=#_support_du_coupe_feu></a></h4><div class=paragraph><p>Si vous projetez d’utiliser un pont en tant que coupe-feu, vous devrez également ajouter l’option <code>IPFIREWALL</code>. Lisez la <a href=../firewalls/#firewalls>Firewalls</a> pour des informations générales sur la configuration d’un pont en tant que coupe-feu.</p></div><div class=paragraph><p>Si vous avez besoin de permettre le passage à travers le pont des paquets non-IP (comme ARP), il existe une option du coupe-feu qui doit être activée. Cette option est <code>IPFIREWALL_DEFAULT_TO_ACCEPT</code>. Prennez note que cela modifie le fonctionnement par défaut du coupe-feu, ce dernier acceptera alors tous les paquets. Assurez-vous de savoir ce que ce changement signifie pour votre ensemble de règles de filtrage avant de l’effectuer.</p></div></div><div class=sect3><h4 id=_support_de_la_régulation_du_trafic>32.5.3.4. Support de la régulation du trafic<a class=anchor href=#_support_de_la_régulation_du_trafic></a></h4><div class=paragraph><p>Si vous désirez utiliser le pont comme régulateur de trafic, vous devrez ajouter l’option <code>DUMMYNET</code> à votre fichier de configuration du noyau. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> pour plus d’information.</p></div></div></div><div class=sect2><h3 id=_activer_le_pont>32.5.4. Activer le pont<a class=anchor href=#_activer_le_pont></a></h3><div class=paragraph><p>Ajoutez la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.enable=1</pre></div></div><div class=paragraph><p>au fichier <span class=filename>/etc/sysctl.conf</span> pour activer le pont au démarrage, et la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.config=if1,if2</pre></div></div><div class=paragraph><p>pour activer le mode bridging sur les interfaces spécifiées (remplacez <em>if1</em> et <em>if2</em> par les noms de vos interfaces réseaux). Si vous désirez que les paquets traversant le pont soient filtrés par <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, vous devrez ajouter également la ligne:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.ipfw=1</pre></div></div><div class=paragraph><p>Pour les versions antérieures à FreeBSD 5.2-RELEASE, utilisez les lignes suivantes:</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge=1
net.link.ether.bridge_cfg=if1,if2
net.link.ether.bridge_ipfw=1</pre></div></div></div><div class=sect2><h3 id=_informations_supplémentaires>32.5.5. Informations supplémentaires<a class=anchor href=#_informations_supplémentaires></a></h3><div class=paragraph><p>Si vous désirez être en mesure de vous connecter au pont par l’intermédiaire de <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, il est correct d’ajouter à l’une des cartes réseaux une adresse IP. Il existe un consensus sur le fait qu’assigner une adresse aux deux cartes est une mauvaise idée.</p></div><div class=paragraph><p>Si vous avez plusieurs ponts sur votre réseau, il ne peut y en avoir plus d’un sur le chemin qui sera emprunté par le trafic entre deux stations de travail. Techniquement, cela signifie qu’il n’y a pas de support pour la gestion du "spanning tree".</p></div><div class=paragraph><p>Un pont peut ajouter des temps de latence lors de l’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, et tout particulièrement dans le cas du trafic d’un segment vers un autre.</p></div></div></div></div><div class=sect1><h2 id=network-diskless>32.6. Système sans disque dur<a class=anchor href=#network-diskless></a></h2><div class=sectionbody><div class=paragraph><p>Une machine FreeBSD peut démarrer via le réseau et fonctionner sans disque dur local, en utilisant des systèmes de fichiers montés à partir d’un serveur NFS. Aucune modification du système n’est nécessaire en dehors des fichiers de configuration standards. Un tel système est facile à mettre en oeuvre comme tous les éléments sont directement disponibles:</p></div><div class=ulist><ul><li><p>Il y a au moins deux méthodes possibles pour charger un noyau via le réseau:</p><div class=ulist><ul><li><p>PXE: l’environnement d’exécution préalable au démarrage d’Intel® (Preboot eXecution Environment) est une sorte de ROM intelligente présente sur certaines cartes réseau ou cartes mère. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> pour plus de détails.</p></li><li><p>Le logiciel porté Etherboot (<a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a>) produit un code stockable dans une ROM pour démarrer des noyaux via le réseau. Le code peut être soit implanté dans une PROM de démarrage sur une carte réseau, soit chargé à partir d’une disquette (ou d’un disque dur local), ou à partir d’un système MS-DOS® en fonctionnement. De nombreuses cartes réseau sont supportées.</p></li></ul></div></li><li><p>Une procédure d’exemple (<span class=filename>/usr/shared/examples/diskless/clone_root</span>) facilite la création et la maintenance du système de fichiers racine de la station de travail sur le serveur. La procédure demandera sûrement quelques modifications mais vous permettra de démarrer rapidement.</p></li><li><p>Des fichiers de démarrage du système existent dans le répertoire <span class=filename>/etc</span> pour détecter et supporter le démarrage d’un système sans disque dur.</p></li><li><p>La pagination, si nécessaire, peut être faite par l’intermédiaire d’un fichier NFS ou sur un disque local.</p></li></ul></div><div class=paragraph><p>Il existe plusieurs façons de configurer des stations de travail sans disque dur. Plusieurs éléments entrent en oeuvre, et la plupart peuvent être ajustés en fonction des besoins locaux. Ce qui suit décrit des variations sur la configuration d’un système complet, mettant en avant le simplicité et la compatibilité avec les procédures standards de démarrage de FreeBSD. Le système décrit présente les caractéristiques suivantes:</p></div><div class=ulist><ul><li><p>Les stations de travail sans disque dur utilisent des systèmes de fichiers <span class=filename>/</span> et <span class=filename>/usr</span> partagés et en lecture seule.</p><div class=paragraph><p>Le système de fichiers racine est une copie d’une racine FreeBSD standard (généralement celle du serveur), avec certains fichiers de configuration remplacés par des versions spécifiques à un fonctionnement sans disque dur, et parfois à la station de travail auxquels ils appartiennent.</p></div><div class=paragraph><p>Les parties de la racine qui doivent être inscriptibles sont remplacées par des systèmes de fichiers <a href="https://man.freebsd.org/cgi/man.cgi?query=mfs&amp;sektion=8&amp;format=html">mfs(8)</a> (FreeBSD 4.X) ou <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> (FreeBSD 5.X). Toute modification sera perdue au redémarrage du système.</p></div></li><li><p>Le noyau est transféré et chargé soit à l’aide d’Etherboot soit de PXE comme certaines situations peuvent exiger l’utilisation de l’une ou l’autre méthode.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Ainsi décrit, le système n’est pas sécurisé. Il devrait se trouver dans une partie protégée du réseau, et les autres machines ne devraient pas lui faire confiance aveuglément.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Toutes les instructions de cette section ont été testées sous FreeBSD 4.9-RELEASE et 5.2.1-RELEASE. Le texte est destiné à l’origine pour une utilisation sous 4.X. Des notes on été insérées aux endroits nécessaires pour indiquer les modifications concernant la branche 5.X.</p></div><div class=sect2><h3 id=_information_de_fond>32.6.1. Information de fond<a class=anchor href=#_information_de_fond></a></h3><div class=paragraph><p>Mettre en place des stations de travail sans disque dur est à la fois relativement simple et enclin aux erreurs. Ces dernières sont parfois difficiles à diagnostiquer pour de nombreuses raisons. Par exemple:</p></div><div class=ulist><ul><li><p>Des options de compilation peuvent donner lieu à des comportements différents à l’exécution.</p></li><li><p>Les messages d’erreurs sont souvent cachés ou totalement absents.</p></li></ul></div><div class=paragraph><p>Dans ce contexte, avoir quelques connaissances des mécanismes sous-jacents impliqués est très utile pour résoudre les problèmes qui peuvent surgir.</p></div><div class=paragraph><p>Plusieurs opérations doivent être effectuées pour un amorçage réussi:</p></div><div class=ulist><ul><li><p>La machine doit obtenir des paramètres de base comme son adresse IP, le nom du fichier exécutable, le nom du serveur, l’emplacement de la racine. Ceci est fait en utilisant le protocole DHCP ou le protocole BOOTP. DHCP est une extension compatible de BOOTP, et utilise les mêmes numéros de ports et son format de paquets basic.</p><div class=paragraph><p>Il est possible de configurer un système pour n’utiliser que BOOTP. Le programme serveur <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> fait partie du système de base de FreeBSD.</p></div><div class=paragraph><p>Cependant, DHCP présente plusieurs avantage sur BOOTP (des fichiers de configuration plus lisibles, la possibilité d’utiliser PXE, plus de nombreux autres avantages n’ayant pas de relation directe avec les systèmes sans disque dur), et nous décrirons principalement une configuration DHCP, avec des exemples équivalent utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> quand cela est possible. L’exemple de configuration utilisera le logiciel ISC DHCP (la version 3.0.1.r12 était installée sur le serveur de test).</p></div></li><li><p>La machine a besoin de transférer un ou plusieurs programmes en mémoire locale. TFTP ou NFS sont utilisés. Le choix entre TFTP et NFS est à de nombreux endroits une option sélectionnée lors de la compilation. Une source d’erreur courante est d’indiquer des noms de fichiers pour le mauvais protocole: TFTP transfère généralement tous les fichiers à partir d’un seul répertoire sur le serveur, et attendra des noms de fichiers relatifs à ce répertoire. NFS a besoin de chemins d’accès absolus.</p></li><li><p>Les éventuels programmes d’amorce intermédiaires et le noyau doivent être initialisés et exécutés. Il existe plusieurs variations à ce niveau:</p><div class=ulist><ul><li><p>PXE chargera <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a>, qui est une version modifiée du chargeur. Le chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) récupérera la plupart des paramètres nécessaires au démarrage du système, et les transmettra au noyau avant de lui abandonner le contrôle du système. Dans ce cas il est possible d’utiliser un noyau <span class=filename>GENERIC</span>.</p></li><li><p>Etherboot, chargera directement le noyau avec moins de préparation. Vous devrez compiler un noyau avec des options particulières.</p><div class=paragraph><p>PXE et Etherboot fonctionnent aussi bien l’un que l’autre avec des systèmes 4.X. Comme le noyau des systèmes 5.X laisse au chargeur (<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) un peu plus de travail à effectuer, PXE est préféré pour les systèmes 5.X.</p></div><div class=paragraph><p>Si votre BIOS et vos cartes réseau supportent PXE, vous devriez probablement l’utiliser. Cependant, il est toujours possible de démarrer un système 5.X à l’aide d’Etherboot.</p></div></li></ul></div></li><li><p>Et enfin, la machine a besoin d’accéder à ses systèmes de fichiers. NFS est utilisé dans tous les cas.</p></li></ul></div><div class=paragraph><p>Consultez également la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a>.</p></div></div><div class=sect2><h3 id=_configuration_2>32.6.2. Configuration<a class=anchor href=#_configuration_2></a></h3><div class=sect3><h4 id=_configuration_utilisant_isc_dhcp>32.6.2.1. Configuration utilisant ISC DHCP<a class=anchor href=#_configuration_utilisant_isc_dhcp></a></h4><div class=paragraph><p>Le serveur ISC DHCP peut répondre aux requêtes BOOTP et DHCP.</p></div><div class=paragraph><p>Avec la version 4.9, ISC DHCP 3.0 ne fait pas partie du système de base. Vous devrez installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> ou la version pré-compilée correspondante.</p></div><div class=paragraph><p>Une fois ISC DHCP installé, il nécessite un fichier de configuration pour fonctionner (normalement appelé <span class=filename>/usr/local/etc/dhcpd.conf</span>). Voici un exemple commenté, où la machine <code>margaux</code> utilise Etherboot et où la machine <code>corbieres</code> emploie PXE:</p></div><div class="literalblock programlisting"><div class=content><pre>default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name &#34;example.com&#34;;
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <i class=conum data-value=1></i><b>(1)</b>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <i class=conum data-value=2></i><b>(2)</b>
    filename &#34;/data/misc/kernel.diskless&#34;; <i class=conum data-value=3></i><b>(3)</b>
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;; <i class=conum data-value=4></i><b>(4)</b>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename &#34;pxeboot&#34;;
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;;
  }
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Cette option dit à dhcpd d’envoyer le paramètre des déclarations <code>host</code> comme nom de machine pour la machine sans disque dur. Une autre méthode aurait été d’ajouter <code>option host-name margaux</code> à l’intérieur des déclarations <code>host</code>.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>La directive <code>next-server</code> désigne le serveur TFTP ou NFS à utiliser pour télécharger le chargeur ou le noyau (le comportement par défaut étant d’utiliser la même machine que le serveur DHCP).</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>La directive <code>filename</code> précise le fichier que chargera Etherboot ou PXE à la prochaine étape. Il doit être défini en fonction de la méthode de transfert utilisée. Etherboot peut être compilé pour utiliser NFS ou TFTP. Le logiciel porté pour FreeBSD utilisera NFS par défaut. PXE emploie TFTP, c’est pourquoi un chemin d’accès relatif est utilisé ici (cela peut dépendre de la configuration du serveur TFTP, mais devrait être plutôt classique). De plus, PXE charge <span class=filename>pxeboot</span>, et non pas le noyau. Il existe d’autres possibilités intéressantes, comme le chargement de <span class=filename>pxeboot</span> à partir du répertoire <span class=filename>/boot</span> d’un CD-ROM FreeBSD (comme <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> peut charger un noyau <span class=filename>GENERIC</span> cela rend possible l’utilisation de PXE pour démarrer à partir d’un lecteur de CD-ROM distant).</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>L’option <code>root-path</code> définie le chemin d’accès au système de fichiers racine, suivant la notation classique de NFS. En utilisant PXE, il est possible de ne pas préciser l’adresse IP de la machine dès lors que vous n’activez pas l’option BOOTP du noyau. Le serveur NFS sera alors le même que le serveur TFTP.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_configuration_utilisant_bootp>32.6.2.2. Configuration utilisant BOOTP<a class=anchor href=#_configuration_utilisant_bootp></a></h4><div class=paragraph><p>Ce qui suit présente une configuration bootpd équivalente (réduite à un seul client). Elle se trouverait sous <span class=filename>/etc/bootptab</span>.</p></div><div class=paragraph><p>Veuillez noter qu’Etherboot doit être compilé avec l’option <code>NO_DHCP_SUPPORT</code> (qui n’est pas activée par défaut) afin d’utiliser BOOTP et que PXE <em>nécessite</em> DHCP. The seul avantage évident de bootpd est qu’il est disponible dans le système de base.</p></div><div class="literalblock programlisting"><div class=content><pre>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd=&#34;/tftpboot&#34;:\
  :bf=&#34;/kernel.diskless&#34;:\
  :rp=&#34;192.168.4.4:/data/misc/diskless&#34;:

margaux:ha=0123456789ab:tc=.def100</pre></div></div></div><div class=sect3><h4 id=_préparation_dun_programme_de_démarrage_avec_etherboot>32.6.2.3. Préparation d’un programme de démarrage avec Etherboot<a class=anchor href=#_préparation_dun_programme_de_démarrage_avec_etherboot></a></h4><div class=paragraph><p>Le <a href=http://etherboot.sourceforge.net>site Web d’Etherboot</a> propose une <a href=http://etherboot.sourceforge.net/doc/html/userman/t1.html>documentation importante</a> principalement destinée aux systèmes Linux, mais contenant néamoins des informations utiles. Ce qui suit présente comment vous utiliseriez Etherboot sur un système FreeBSD.</p></div><div class=paragraph><p>Vous devez tout d’abord installer le logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a> ou sa version pré-compilée.</p></div><div class=paragraph><p>Vous pouvez modifier la configuration d’Etherboot (i.e. pour utiliser TFTP au lieu de NFS) en éditant le fichier <span class=filename>Config</span> dans le répertoire des sources d’Etherboot.</p></div><div class=paragraph><p>Pour notre configuration nous utiliserons une disquette de démarrage. Pour d’autres méthodes (PROM, ou un programme MS-DOS®), consultez la documentation d’Etherboot.</p></div><div class=paragraph><p>Pour créer une disquette de démarrage, insérez une disquette dans le lecteur de la machine où vous avez installé Etherboot, puis rendez-vous dans le répertoire <span class=filename>src</span> de l’arborescence Etherboot et tapez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmake bin32/devicetype.fd0</span></code></pre></div></div><div class=paragraph><p><em>devicetype</em> dépend du type de carte Ethernet se trouvant dans la station de travail sans disque dur. Référez-vous au fichier <span class=filename>NIC</span> dans le même répertoire pour déterminer la valeur <em>devicetype</em> correcte.</p></div></div><div class=sect3><h4 id=_démarrer_avec_pxe>32.6.2.4. Démarrer avec PXE<a class=anchor href=#_démarrer_avec_pxe></a></h4><div class=paragraph><p>Par défaut le chargeur <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> charge le noyau via NFS. Il peut être compilé pour utiliser TFTP à la place en spécifiant l’option <code>LOADER_TFTP_SUPPORT</code> dans le fichier <span class=filename>/etc/make.conf</span>. Lisez les commentaires dans le fichier <span class=filename>/etc/defaults/make.conf</span> (ou <span class=filename>/usr/shared/examples/etc/make.conf</span> pour les systèmes 5.X) pour plus de détails.</p></div><div class=paragraph><p>Il existe deux autres options de <span class=filename>make.conf</span> non-documentées qui peuvent être utiles pour la configuration d’une machine faisant fonction de console série sans disque dur: <code>BOOT_PXELDR_PROBE_KEYBOARD</code>, et <code>BOOT_PXELDR_ALWAYS_SERIAL</code> (cette dernière n’existe que sous FreeBSD 5.X).</p></div><div class=paragraph><p>Pour utiliser PXE quand la machine démarre, vous aurez normalement besoin de sélectionner l’option <code>Boot from network</code> dans votre BIOS, ou d’appuyer sur une touche de fonction lors de l’initialisation du PC.</p></div></div><div class=sect3><h4 id=_configuration_des_serveurs_tftp_et_nfs>32.6.2.5. Configuration des serveurs TFTP et NFS<a class=anchor href=#_configuration_des_serveurs_tftp_et_nfs></a></h4><div class=paragraph><p>Si vous utilisez PXE ou Etherboot configurés pour employer TFTP, vous devez activer tftpd sur le serveur de fichier:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Créez un répertoire à partir duquel tftpd proposera les fichiers, e.g. <span class=filename>/tftpboot</span>.</p></li><li><p>Ajoutez la ligne suivante à votre fichier <span class=filename>/etc/inetd.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il apparaît que certaines versions de PXE veulent la version TCP de TFTP. Dans ce cas, ajoutez une seconde ligne, en remplaçant <code>dgram udp</code> par <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Demandez à inetd de relire son fichier de configuration:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Le répertoire <span class=filename>tftpboot</span> peut être placé n’importe où sur le serveur. Assurez-vous que son emplacement est défini dans les fichiers <span class=filename>inetd.conf</span> et <span class=filename>dhcpd.conf</span>.</p></div><div class=paragraph><p>Dans tous les cas, vous devez également activer NFS et exporter le système de fichiers approprié sur le serveur NFS.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ajoutez ce qui suit au fichier <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Exportez le système de fichiers contenant le répertoire racine du système sans disque dur en ajoutant ce qui suit au fichier <span class=filename>/etc/exports</span> (ajustez le point de montage et remplacez <em>margaux corbieres</em> avec les noms des stations de travail sans disque dur):</p><div class="literalblock programlisting"><div class=content><pre>/data/misc -alldirs -ro margaux corbieres</pre></div></div></li><li><p>Demandez à mountd de relire son fichier de configuration. Si vous avez eu besoin d’activer NFS dans <span class=filename>/etc/rc.conf</span> lors du premier point, vous voudrez probablement plutot redémarrer la machine.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=_compilation_dun_noyau_pour_système_sans_disque_dur>32.6.2.6. Compilation d’un noyau pour système sans disque dur<a class=anchor href=#_compilation_dun_noyau_pour_système_sans_disque_dur></a></h4><div class=paragraph><p>Si vous utilisez Etherboot, vous devez créer un fichier de configuration du noyau pour le client sans disque dur avec les options suivantes (en plus des options habituelles):</p></div><div class="literalblock programlisting"><div class=content><pre>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info</pre></div></div><div class=paragraph><p>Vous pouvez vouloir également employer les options <code>BOOTP_NFSV3</code>, <code>BOOT_COMPAT</code> et <code>BOOTP_WIRED_TO</code> (référez-vous au fichier <span class=filename>LINT</span> sous 4.X ou <span class=filename>NOTES</span> sous 5.X).</p></div><div class=paragraph><p>Les noms de ces options sont historiques et légèrement trompeur comme elles activent indifférement l’utilisation de DHCP et BOOTP dans le noyau (il est également possible de forcer une utilisation stricte de BOOTP ou DHCP).</p></div><div class=paragraph><p>Compilez le noyau (voir <a href=../kernelconfig/#kernelconfig>Configurer le noyau de FreeBSD</a>), et copiez-le à l’emplacement indiqué dans <span class=filename>dhcpd.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quand on utilise PXE, la compilation d’un noyau avec les options précédentes n’est pas strictement nécessaire (bien que conseillé). Les activer causera un plus grand nombre de requêtes DHCP générées lors du démarrage du noyau, avec un petit risque d’inconsistance entre les nouvelles valeurs et celles récupérées par <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> dans certains cas particuliers. L’avantage de leur utilisation est que le nom de la machine sera forcément défini. Sinon vous devrez définir le nom de la machine par une autre méthode, par exemple dans un fichier <span class=filename>rc.conf</span> particulier au client.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Afin d’être chargeable par Etherboot, un noyau 5.X doit être compilé avec les "device hints". Vous définirez normalement l’option suivante dans le fichier de configuration (voir le fichier de commentaires sur la configuration: <span class=filename>NOTES</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>hints		&#34;GENERIC.hints&#34;</pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_préparer_le_système_de_fichiers_racine>32.6.2.7. Préparer le système de fichiers racine<a class=anchor href=#_préparer_le_système_de_fichiers_racine></a></h4><div class=paragraph><p>Vous devez créer un système de fichiers racine pour les stations de travail sans disque dur, à l’emplacement défini par <code>root-path</code> dans le fichier <span class=filename>dhcpd.conf</span>. Les sections suivantes décrivent deux manières de le faire.</p></div><div class=sect4><h5 id=_utilisation_de_la_procédure_clone_root>32.6.2.7.1. Utilisation de la procédure <span class=filename>clone_root</span><a class=anchor href=#_utilisation_de_la_procédure_clone_root></a></h5><div class=paragraph><p>C’est la méthode la plus rapide pour créer un système de fichiers racine, mais elle est, pour le moment, uniquement supportée sous FreeBSD 4.X.. Cette procédure est située à l’emplacement <span class=filename>/usr/shared/examples/diskless/clone_root</span> et demande quelques modifications, pour au moins ajuster l’emplacement du système de fichiers à créer (la variable <code>DEST</code>).</p></div><div class=paragraph><p>Référez-vous aux commentaires situés en début de la procédure pour information. Ils expliquent comment le système de fichiers de base est construit, et comment les fichiers peuvent être remplacés de façon sélective par des versions spécifiques à un fonctionnement sans disque dur, ou à un sous-réseau, ou encore à une station de travail particulière. Ils donnent également des exemples de fichiers <span class=filename>/etc/fstab</span> et <span class=filename>/etc/rc.conf</span> pour un fonctionnement sans disque dur.</p></div><div class=paragraph><p>Les fichiers <span class=filename>README</span> dans le répertoire <span class=filename>/usr/shared/examples/diskless</span> contiennent beaucoup d’information de fond, mais, avec les autres exemples du répertoire <span class=filename>diskless</span>, ils documentent une méthode de configuration qui est distincte de celle utilisée par <span class=filename>clone_root</span> et les procédures de démarrage du système de <span class=filename>/etc</span>, ce qui est un peu à l’origine de confusions. Utilisez-les comme référence uniquement, à moins que vous préfériez la méthode qu’ils décrivent, dans quel cas vous devrez modifier les procédures <span class=filename>rc</span>.</p></div></div><div class=sect4><h5 id=_utilisation_de_la_procédure_make_world_standard>32.6.2.7.2. Utilisation de la procédure <code>make world</code> standard<a class=anchor href=#_utilisation_de_la_procédure_make_world_standard></a></h5><div class=paragraph><p>Cette méthode s’applique aussi bien à FreeBSD 4.X qu’à FreeBSD 5.X et installera un système complet (et non pas uniquement le système de fichiers racine) dans le répertoire défini par <code>DESTDIR</code>. Tout ce dont vous avez besoin de faire est d’exécuter la procédure suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make world  make kernel
cd /usr/src/etc; make distribution</pre></div></div><div class=paragraph><p>Une fois cela terminé, vous devrez personaliser vos fichiers <span class=filename>/etc/rc.conf</span> et <span class=filename>/etc/fstab</span> situés dans <code>DESTDIR</code> en fonction de vos besoins.</p></div></div></div><div class=sect3><h4 id=_configuration_de_lespace_de_pagination>32.6.2.8. Configuration de l’espace de pagination<a class=anchor href=#_configuration_de_lespace_de_pagination></a></h4><div class=paragraph><p>Si nécessaire, un fichier de pagination situé sur le serveur peut être utilisé via NFS. Une des méthodes couramment utilisées pour cela n’est plus supportée sous 5.X.</p></div><div class=sect4><h5 id=_pagination_via_nfs_sous_freebsd_4_x>32.6.2.8.1. Pagination via NFS sous FreeBSD 4.X<a class=anchor href=#_pagination_via_nfs_sous_freebsd_4_x></a></h5><div class=paragraph><p>L’emplacement et la taille du fichier de pagination peuvent être spécifiés avec les options BOOTP/DHCP 128 et 129 spécifiques à FreeBSD. Des exemples de fichiers de configuration pour ISC DHCP 3.0 ou bootpd suivent:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Ajoutez les lignes suivantes au fichier <span class=filename>dhcpd.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre># Global section
option swap-path code 128 = string;
option swap-size code 129 = integer 32;

host margaux {
  ... # Standard lines, see above
  option swap-path &#34;192.168.4.4:/netswapvolume/netswap&#34;;
  option swap-size 64000;
}</pre></div></div><div class=paragraph><p><code>swap-path</code> est le chemin d’accès vers un répertoire où les fichiers de pagination sont situés. Chaque fichier sera nommé <span class=filename>swap.ip-client</span>.</p></div><div class=paragraph><p>Les anciennes version de dhcpd utilisaient une syntaxe du type <code>option option-128 "…​</code>, qui n’est plus supportée.</p></div><div class=paragraph><p><span class=filename>/etc/bootptab</span> utiliserait la syntaxe suivante à la place:</p></div><div class="literalblock programlisting"><div class=content><pre>T128=&#34;192.168.4.4:/netswapvolume/netswap&#34;:T129=0000fa00</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dans le fichier <span class=filename>/etc/bootptab</span>, la taille de l’espace de pagination doit être exprimée en hexadécimal.</p></div></td></tr></tbody></table></div></li><li><p>Sur le serveur du fichier de pagination par NFS, créez le(s) fichier(s) de pagination:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /netswapvolume/netswap</span>
<span class=c># cd /netswapvolume/netswap</span>
<span class=c># dd if=/dev/zero bs=1024 count=64000 of=swap.192.168.4.6</span>
<span class=c># chmod 0600 swap.192.168.4.6</span></code></pre></div></div><div class=paragraph><p><em>192.168.4.6</em> est l’adresse IP du client sans disque dur.</p></div></li><li><p>Sur le serveur du fichier de pagination par NFS, ajoutez la ligne suivante au fichier <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/netswapvolume  -maproot=0:10 -alldirs margaux corbieres</pre></div></div><div class=paragraph><p>Ensuite demandez à mountd à relire le fichier <span class=filename>exports</span>, comme plus haut.</p></div></li></ol></div></div></div></div><div class=sect4><h5 id=_pagination_via_nfs_sous_freebsd_5_x>32.6.2.8.2. Pagination via NFS sous FreeBSD 5.X<a class=anchor href=#_pagination_via_nfs_sous_freebsd_5_x></a></h5><div class=paragraph><p>Le noyau ne supporte pas l’activation de la pagination par NFS au démarrage. L’espace de pagination doit être activé par les procédures de démarrage, en montant un système de fichiers accessible en écriture et en créant et en activant un fichier de pagination. Pour créer un fichier de pagination de la taille appropriée, vous pouvez effectuer ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</span></code></pre></div></div><div class=paragraph><p>Pour ensuite l’activer, vous devez ajouter la ligne suivante à votre fichier <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>swapfile=/path/to/swapfile</pre></div></div></div></div><div class=sect3><h4 id=_problèmes_divers>32.6.2.9. Problèmes divers<a class=anchor href=#_problèmes_divers></a></h4><div class=sect4><h5 id=_utilisation_dun_usr_en_lecture_seule>32.6.2.9.1. Utilisation d’un <span class=filename>/usr</span> en lecture seule<a class=anchor href=#_utilisation_dun_usr_en_lecture_seule></a></h5><div class=paragraph><p>Si la station de travail sans disque dur est configurée pour exécuter X, you devrez ajuster le fichier de configuration de XDM, qui envoie le journal d’erreurs sur <span class=filename>/usr</span> par défaut.</p></div></div><div class=sect4><h5 id=_utilisation_dun_serveur_non_freebsd>32.6.2.9.2. Utilisation d’un serveur non-FreeBSD<a class=anchor href=#_utilisation_dun_serveur_non_freebsd></a></h5><div class=paragraph><p>Quand le serveur pour le système de fichiers racine ne fait pas tourner FreeBSD, vous devrez créer le système de fichiers racine sur une machine FreeBSD, puis le copier vers sa destination en utilisant <code>tar</code> ou <code>cpio</code>.</p></div><div class=paragraph><p>Dans cette situation, il y a parfois des problèmes avec les fichiers spéciaux de périphériques dans <span class=filename>/dev</span>, en raison de différences de taille sur les entiers. Une solution à ce problème est d’exporter un répertoire à partir du serveur non-FreeBSD, de monter ce répertoire sur une machine FreeBSD, et exécuter <code>MAKEDEV</code> sur la machine FreeBSD pour créer les entrées de périphériques correctes (FreeBSD 5.X et les versions suivantes utilisent <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> pour l’allocation des fichiers spéciaux de périphériques de manière transparente pour l’utilisateur, exécuter <code>MAKEDEV</code> sur ces versions est inutile).</p></div></div></div></div></div></div><div class=sect1><h2 id=network-isdn>32.7. ISDN<a class=anchor href=#network-isdn></a></h2><div class=sectionbody><div class=paragraph><p>Une bonne source d’information sur la technologie et le matériel ISDN (RNIS) est <a href=http://www.alumni.caltech.edu/~dank/isdn/>la page ISDN de Dan Kegel</a>.</p></div><div class=paragraph><p>Voici un rapide aperçu à propos de l’ISDN:</p></div><div class=ulist><ul><li><p>Si vous résidez en Europe, vous devriez étudier la section sur les cartes ISDN.</p></li><li><p>Si vous envisagez d’utiliser l’ISDN avant tout pour vous connecter à l’Internet par l’intermédiaire d’un fournisseur d’accès Internet et d’une ligne téléphonique non dédiée, vous devriez vous intéresser aux Adaptateurs Terminaux. C’est la solution la plus souple, qui vous posera le moins de problèmes si vous changez de fournisseur d’accès.</p></li><li><p>Si vous interconnectez deux réseaux locaux, ou si vous vous connectez à l’Internet avec une liaison ISDN dédiée, vous devriez envisager un pont/routeur autonome.</p></li></ul></div><div class=paragraph><p>Le coût est un facteur déterminant de la solution que vous choisirez. Les options suivantes sont listées de la moins chère à la plus chère.</p></div><div class=sect2><h3 id=network-isdn-cards>32.7.1. Cartes ISDN<a class=anchor href=#network-isdn-cards></a></h3><div class=paragraph><p>L’implémentation ISDN de FreeBSD ne supporte que la norme DSS1/Q.931 (ou Euro-ISDN) utilisant des cartes passives. Depuis FreeBSD 4.4, quelques cartes actives sont supportées où le firmware supporte également d’autres protocoles au niveau des signaux, cela inclut les premières cartes supportées du type "Primary Rate ISDN" (PRI).</p></div><div class=paragraph><p>Le logiciel isdn4bsd vous permet de vous connecter à d’autres routeurs ISDN soit en utilisant l’IP sur de l’HDLC de base, soit en utilisant PPP synchrone: en employant PPP intégré au noyau avec <code>isppp</code>, une version modifiée du pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=sppp&amp;sektion=4&amp;format=html">sppp(4)</a>, ou en employant <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> en mode utilisateur. L’utilisation de <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> en mode utilisateur rend possible l’agrégation de deux ou plus canaux ISDN de type B. Une application capable de répondre aux appels téléphoniques est également disponible, tout comme de nombreux utilitaires comme un modem logiciel 300 bauds.</p></div><div class=paragraph><p>Un nombre croissant de cartes ISDN pour PC sont supportées sous FreeBSD et les retours montrent qu’elles sont utilisées avec succès dans toute l’Europe et dans de nombreuses autres parties du monde.</p></div><div class=paragraph><p>Les cartes ISDN passives supportées sont principalement celles avec le circuit ISDN ISAC/HSCX/IPAC d’Infineon (précédemment Siemens), mais également les cartes avec des circuits en provenance de Cologne Chip (cartes ISA uniquement), les cartes PCI avec les circuits Winbond W6692, quelques cartes avec les circuits Tiger300/320/ISAC et quelques cartes avec des circuits spécifiques comme l’AVM Fritz!Card PCI V.1.0 de l’AVM Fritz!Card PnP.</p></div><div class=paragraph><p>Actuellement les cartes ISDN actives supportées sont les cartes AVM B1 (ISA et PCI) BRI et les cartes PCI AVM T1 PRI.</p></div><div class=paragraph><p>Pour de la documentation sur isdn4bsd, consultez le répertoire <span class=filename>/usr/shared/examples/isdn/</span> sur votre système FreeBSD ou sur la <a href=http://www.freebsd-support.de/i4b/>page web d’isdn4bsd</a> qui propose également des astuces, des erratas et bien plus de documentation que le <a href=http://people.FreeBSD.org/~hm/>manuel d’isdn4bsd</a>.</p></div><div class=paragraph><p>Au cas où vous seriez intéressé par l’ajout du support pour un protocole ISDN différent, d’une carte ISDN pour PC non encore supportée ou par l’amélioration d’isdn4bsd, veuillez contacter Hellmuth Michaelis &lt;<a href=mailto:hm@FreeBSD.org>hm@FreeBSD.org</a>>.</p></div><div class=paragraph><p>Pour les questions concernant l’installation, la configuration et le dépannage d’isdn4bsd, une liste de diffusion <a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a> est disponible.</p></div></div><div class=sect2><h3 id=_adaptateurs_terminaux_isdn>32.7.2. Adaptateurs terminaux ISDN<a class=anchor href=#_adaptateurs_terminaux_isdn></a></h3><div class=paragraph><p>Les adaptateurs terminaux-"Terminal adapters (TA)"; sont l’équivalent ISDN des modems pour les lignes téléphoniques ordinaires.</p></div><div class=paragraph><p>La plupart des TA utilisent le jeu de commandes standard des modems Hayes, et peuvent être utilisés en remplacement d’un modem.</p></div><div class=paragraph><p>Un TA fonctionne essentiellement de la même manière qu’un modem à la différence que la vitesse de la connexion sera plus élevée qu’avec votre vieux modem. Vous devrez configurer <a href=../ppp-and-slip/#ppp>PPP</a> de façon exactement identique que pour un modem classique. Assurez-vous de fixer la vitesse de votre port série la plus haute possible.</p></div><div class=paragraph><p>Le principal avantage d’utiliser un TA pour vous connecter à votre fournisseur d’accès Internet est de pouvoir utiliser PPP en mode dynamic. Comme l’espace d’adressage IP disponible devient de plus en plus restreint, la plupart des fournisseurs d’accès ne désirent plus vous fournir d’adresse IP statique. La plupart des routeurs autonomes ne peuvent pas fonctionner avec une allocation dynamique d’adresse IP.</p></div><div class=paragraph><p>Les fonctionnalités et la stabilité de la connexion des adaptateurs terminaux reposent complètement sur le "daemon" PPP. Cela vous permet de passer facilement d’un modem classique à l’ISDN sur une machine FreeBSD, si vous avez déjà configuré PPP. Cependant, les problèmes que vous avez éventuellement rencontrés avec PPP persisteront.</p></div><div class=paragraph><p>Si vous désirez un maximum de stabilité, utilisez <a href=../ppp-and-slip/#ppp>PPP intégré au noyau</a>, à la place du <a href=../ppp-and-slip/#userppp>PPP en mode utilisateur</a>.</p></div><div class=paragraph><p>Les adaptateurs suivants sont connus pour fonctionner avec FreeBSD:</p></div><div class=ulist><ul><li><p>Motorola BitSurfer et Bitsurfer Pro</p></li><li><p>Adtran</p></li></ul></div><div class=paragraph><p>La plupart des adaptateurs terminaux fonctionneront probablement également, les fabricants de TA font en sorte que leurs produits acceptent la plupart du jeu de commandes AT des modems.</p></div><div class=paragraph><p>Le vrai problème avec les adaptateurs terminaux est que comme pour les modems, il vous faudra une bonne interface série dans votre ordinateur.</p></div><div class=paragraph><p>Vous devriez lire le document sur <a href=https://docs.freebsd.org/en/articles/serial-uart/>les ports série sous FreeBSD</a> pour comprendre en détail le fonctionnement des périphériques série et les différences entre les ports séries asynchrones et synchrones.</p></div><div class=paragraph><p>Un adaptateur terminal sur un port série PC standard (asynchrone) vous limite à 115.2 Kbs, même si vous disposez d’une connexion à 128 Kbs. Pour utiliser complètement les 128 Kbs offert par l’ISDN, vous devez brancher l’adaptateur sur une carte série synchrone.</p></div><div class=paragraph><p>Ne vous imaginez pas qu’il suffit d’acheter un adaptateur terminal interne pour s’affranchir du problème synchrone/asynchrone. Les adaptateurs internes disposent simplement d’un port série PC standard. Tout ce que vous y gagnerez sera d’économiser un câble série et de libérer une prise électrique.</p></div><div class=paragraph><p>Une carte synchrone avec un adaptateur terminal est au moins aussi rapide qu’un routeur autonome, piloté par une simple machine FreeBSD, et probablement plus souple.</p></div><div class=paragraph><p>Le choix entre carte synchrone/adaptateur ou routeur autonome est une question de goût. Ce sujet a été abordé dans les listes de diffusion. Nous vous suggérons de chercher dans les <a href=https://www.FreeBSD.org/search/>archives</a> pour obtenir l’intégralité de la discussion.</p></div></div><div class=sect2><h3 id=_pontsrouteurs_isdn_autonomes>32.7.3. Ponts/Routeurs ISDN autonomes<a class=anchor href=#_pontsrouteurs_isdn_autonomes></a></h3><div class=paragraph><p>Les ponts ou routeurs ISDN ne sont pas spécifiques à FreeBSD ou à tout autre système d’exploitation. Pour une description complète de la technologie du routage et des ponts, veuillez vous reportez à un ouvrage de référence sur les réseaux.</p></div><div class=paragraph><p>Dans le contexte de cette section, les termes de routeur et de pont seront utilisés indifféremment.</p></div><div class=paragraph><p>Comme le prix des routeurs/ponts ISDN d’entrée de gamme baissent, il est probable qu’ils deviennent un choix de plus en plus populaire. Un routeur ISDN est une petite boîte qui se branche directement sur votre réseau Ethernet, et gère sa propre connexion aux autres ponts/routeurs. Il intègre le logiciel nécessaire au support du protocole PPP et d’autres protocoles.</p></div><div class=paragraph><p>Un routeur vous offrira un débit plus élevé qu’un adaptateur terminal standard, puisqu’il utilisera une connexion ISDN synchrone.</p></div><div class=paragraph><p>Le principal problème avec les routeurs et ponts ISDN est que l’intéropérabilité entre les matériels des différents constructeurs n’est pas toujours garantie. Si vous projetez de vous connecter à un fournisseur d’accès Internet, vous devriez discuter de vos besoins avec ce dernier.</p></div><div class=paragraph><p>Si vous envisagez de connecter ensemble deux réseaux locaux, comme le réseau de votre domicile et celui de votre bureau, c’est la solution la plus simple et celle qui demande le moins de maintenance. Etant donné que vous êtes la personne qui achète les équipements pour les deux extrémités, vous êtes sûr que cela fonctionnera.</p></div><div class=paragraph><p>Par exemple pour connecter un ordinateur personnel situé à son domicile ou le réseau d’une agence à celui du siège social, la configuration suivante pourra être utilisée:</p></div><div class=exampleblock><div class=title>Exemple 1. Réseau d’agence ou à domicile</div><div class=content><div class=paragraph><p>Le réseau utilise une topologie en bus avec une connectique Ethernet 10 base 2 ("thinnet"). Connectez le routeur au réseau à l’aide d’un émetteur/récepteur AUI/10BT si nécessaire.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-bus.png alt="Ethernet 10 Base 2"></div></div><div class=paragraph><p>Si votre réseau de domicile/d’agence n’est constitué que d’un seul ordinateur, vous pouvez utiliser une paire torsadée croisée pour le connecter directement au routeur autonome.</p></div></div></div><div class=exampleblock><div class=title>Exemple 2. Siège social ou autre réseau</div><div class=content><div class=paragraph><p>Le réseau utilise une topologie en étoile avec une connectique Ethernet 10 base T ("paire torsadée").</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-twisted-pair.png alt="Architecture du Réseau ISDN"></div></div></div></div><div class=paragraph><p>Un des principaux avantages de la plupart des routeurs/ponts est le fait qu’ils permettent d’avoir deux connexions PPP <em>séparées et indépendantes</em> vers deux sites différents et cela en <em>même</em> temps. Ceci n’est pas supporté par la plupart des adaptateurs terminaux, en dehors de modèles spécifiques (en général coûteux) qui disposent de deux ports série. Ne confondez pas cette possibilité avec l’agrégation de canaux, MPP, etc.</p></div><div class=paragraph><p>Ceci peut être une fonctionnalité très utile si, par exemple, vous disposez d’une connexion ISDN dédiée au bureau et vous voudriez en profiter mais vous ne voulez pas acquérir une nouvelle ligne ISDN. Un routeur au bureau peut gérer un canal B dédié (64 Kbps) vers l’Internet et utiliser l’autre canal B pour une autre connexion. Le deuxième canal B peut être utilisé pour les connexions entrantes, sortantes ou pour l’agrégation de canaux (MPP, etc.) avec le premier canal B pour augmenter la bande passante.</p></div><div class=paragraph><p>Un pont Ethernet vous permettra de transmettre autre chose que juste du trafic IP. Vous pouvez également faire passer de l’IPX/SPX ou tout autre protocole que vous utilisez.</p></div></div></div></div><div class=sect1><h2 id=network-natd>32.8. Translation d’adresses<a class=anchor href=#network-natd></a></h2><div class=sectionbody><div class=sect2><h3 id=network-natoverview>32.8.1. Généralités<a class=anchor href=#network-natoverview></a></h3><div class=paragraph><p>Le "daemon" de translation d’adresses ("Network Address Translation"-NAT) de FreeBSD, généralement connu sous le nom de <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> est un "daemon" qui accepte les paquets IP entrants, change l’adresse de la source par celle de la machine locale et ré-injecte les paquets dans le flux sortant des paquets IP. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> effectue cela en changeant l’adresse IP et le port source de sorte quand les données réponse arrivent il soit en mesure de déterminer la provenance des données d’origine et les transférer à l’émetteur original.</p></div><div class=paragraph><p>L’utilisation classique de NAT est le partage de connexion Internet.</p></div></div><div class=sect2><h3 id=network-natsetup>32.8.2. Architecture du réseau<a class=anchor href=#network-natsetup></a></h3><div class=paragraph><p>En raison de la diminution du nombre d’adresses IP libres sous IPv4, et de l’augmentation du nombre d’utilisateurs de lignes haut-débit comme le câble ou l’ADSL, le besoin d’utiliser une solution de partage de connexion est donc en constante augmentation. La possibilité de connecter plusieurs ordinateurs par l’intermédiaire d’une connexion et d’une adresse IP fait de <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> une solution de choix.</p></div><div class=paragraph><p>Plus généralement, un utilisateur dispose d’une machine connecté sur la câble ou une ligne ADSL avec une adresse IP et désire utiliser cet ordinateur connecté pour fournir un accès Internet à d’autres machines du réseau local.</p></div><div class=paragraph><p>Pour cela, la machine FreeBSD sur Internet doit jouer le rôle de passerelle. Cette machine passerelle doit avoir deux cartes réseaux-l’une pour se connecter au routeur Internet, l’autre est connectée au réseau local. Toutes les machines du réseau local sont connectées par l’intermédiaire d’un hub ou d’un switch.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il existe plusieurs manières pour connecter un réseau local à l’Internet à travers une passerelle FreeBSD. Cet exemple n’abordera que le cas d’une passerelle avec au moins deux cartes réseaux.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/natd.png alt="Organisation du réseau"></div></div><div class=paragraph><p>Une telle configuration est communément utilisée pour partager une connexion Internet. Une des machines du réseau local est connectée à Internet. Le reste des machines accède à Internet par l’intermédiaire de cette machine "passerelle".</p></div></div><div class=sect2><h3 id=network-natdkernconfiguration>32.8.3. Configuration<a class=anchor href=#network-natdkernconfiguration></a></h3><div class=paragraph><p>Les options suivantes doivent être présentes dans le fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL
options IPDIVERT</pre></div></div><div class=paragraph><p>De plus, les options suivantes peuvent également être utiles:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</pre></div></div><div class=paragraph><p>Ce qui suit doit figurer dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34; <i class=conum data-value=1></i><b>(1)</b>
firewall_enable=&#34;YES&#34; <i class=conum data-value=2></i><b>(2)</b>
firewall_type=&#34;OPEN&#34; <i class=conum data-value=3></i><b>(3)</b>
natd_enable=&#34;YES&#34;
natd_interface=&#34;fxp0&#34; <i class=conum data-value=4></i><b>(4)</b>
natd_flags=&#34;&#34; <i class=conum data-value=5></i><b>(5)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Configure la machine comme passerelle. Exécuter <code>sysctl net.inet.ip.forwarding=1</code> aurait le même effet.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Active au démarrage les règles du coupe-feu se trouvant dans le fichier <span class=filename>/etc/rc.firewall</span>.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Cela spécifie un ensemble de règles prédéfinies pour le coupe-feu qui autorise tous les paquets entrant. Consultez le fichier <span class=filename>/etc/rc.firewall</span> pour d’autres ensembles de régles.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Indique à travers quelle interface transférer les paquets (l’interface connectée à l’Internet).</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Toutes options de configuration supplémentaires passées à <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> au démarrage.</td></tr></tbody></table></div><div class=paragraph><p>Le fait d’avoir les options précédentes définies dans le fichier <span class=filename>/etc/rc.conf</span> lancera la commande <span class=filename>/etc/rc.conf</span> au démarrage. Cette commande peut être également exécutée à la main.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il est également possible d’utiliser un fichier de configuration pour <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> quand il y a trop d’options à passer. Dans ce cas, le fichier de configuration doit être défini en ajoutant la ligne suivante au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class=paragraph><p>Le fichier <span class=filename>/etc/natd.conf</span> contiendra une liste d’options de configuration, une par ligne. Par exemple le cas de figure de la section suivante utiliserait le fichier suivant:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Pour plus d’information concernant le fichier de configuration, consultez la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> au sujet de l’option <code>-f</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A chaque machine et interface derrière le réseau local doit être assigné une adresse IP de l’espace d’adresses privées comme défini par la <a href=ftp://ftp.isi.edu/in-notes/rfc1918.txt>RFC 1918</a> et doit disposer d’une passerelle par défaut qui est l’adresse IP interne de la machine <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>.</p></div><div class=paragraph><p>Par exemple, les clients <code>A</code> et <code>B</code> du réseau local ont les adresses IP <code>192.168.0.2</code> et <code>192.168.0.3</code>, tandis que l’interface sur le réseau local de la machine natd a pour adresse IP <code>192.168.0.1</code>. La passerelle par défaut des clients <code>A</code> et <code>B</code> doit être l’adresse <code>192.168.0.1</code> de la machine natd. L’interface externe ou Internet de cette dernière ne demande aucune modification spécifique pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> puisse fonctionner.</p></div></div><div class=sect2><h3 id=network-natdport-redirection>32.8.4. Redirection de ports<a class=anchor href=#network-natdport-redirection></a></h3><div class=paragraph><p>L’inconvénient avec <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> est que les clients du réseau local ne sont pas accessibles depuis l’Internet. Les clients sur le réseau local peuvent établir des connexions sortantes vers le monde extérieur mais ne peuvent recevoir de connexions entrantes. Cela présente un problème si l’on tente de faire tourner des services Internet sur une des machines du réseau local. Une solution simple à ce problème est de rediriger les ports Internet sélectionnés de la machine natd vers le client sur le réseau local.</p></div><div class=paragraph><p>Par exemple, un serveur IRC tourne sur le client <code>A</code>, et un serveur web sur le client <code>B</code>. Pour que cela fonctionne correctement, les connections reçues sur les ports 6667 (IRC) et 80 (web) doivent être redirigées vers les machines correspondantes.</p></div><div class=paragraph><p>L’option <code>-redirect_port</code> doit être passée à <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> avec les autres options adéquates. La syntaxe est la suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>Dans l’exemple précédent, l’argument passé à la commande devrait être:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_port tcp 192.168.0.2:6667 6667
-redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Cela va rediriger les ports <em>tcp</em> voulus vers les machines du réseau local.</p></div><div class=paragraph><p>L’option <code>-redirect_port</code> peut être utilisée pour indiquer une plage de ports plutôt que des ports individuels. Par exemple <em>tcp 192.168.0.2:2000-3000 2000-3000</em> redirigerait toutes les connexions reçues sur les ports 2000 à 3000 vers les ports 2000 à 3000 du client <code>A</code>.</p></div><div class=paragraph><p>Ces options peuvent être utilisées quand on exécute directement <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, placées dans l’option <code>natd_flags=""</code> du fichier <span class=filename>/etc/rc.conf</span>, ou passées par l’intermédiaire d’un fichier de configuration.</p></div><div class=paragraph><p>Pour plus d’éléments et d’options de configuration consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a></p></div></div><div class=sect2><h3 id=network-natdaddress-redirection>32.8.5. Redirection d’adresses<a class=anchor href=#network-natdaddress-redirection></a></h3><div class=paragraph><p>La redirection d’adresses est utile si plusieurs adresses IP sont disponibles mais doivent se trouver sur une seule machine. Avec cela, <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> peut assigner à chaque client du réseau local sa propre adresse IP externe. Le programme <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> récrit alors les paquets sortant des clients du réseau local avec l’adresse IP externe correcte et redirige tout le trafic entrant sur une adresse IP particulière vers la machine du réseau local correspondante. Ce principe est également connu sous le nom de translation d’adresses statique. Par exemple, les adresses IP <code>128.1.1.1</code>, <code>128.1.1.2</code>, et <code>128.1.1.3</code> appartiennent à la passerelle natd. L’adresse <code>128.1.1.1</code> peut être utilisée comme adresse IP externe de la passerelle natd, tandis que <code>128.1.1.2</code> et <code>128.1.1.3</code> sont redirigées vers les machines <code>A</code> et <code>B</code> du réseau local.</p></div><div class=paragraph><p>La syntaxe de l’option <code>-redirect_address</code> est la suivante:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address localIP publicIP</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>localIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’adresse IP interne du client sur le réseau local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>publicIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’adresse IP externe correspondant au client sur le réseau local.</p></td></tr></tbody></table><div class=paragraph><p>Dans l’exemple, les arguments passés à la commande seraient:</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Comme pour l’option <code>-redirect_port</code>, ces options peuvent être placées dans l’option <code>natd_flags=""</code> du fichier <span class=filename>/etc/rc.conf</span>, ou passées par l’intermédiaire d’un fichier de configuration. Avec la redirection d’adresse, il n’y a pas besoin de redirection de ports puisque toutes les données reçues sur une IP particulière sont redirigées.</p></div><div class=paragraph><p>Les adresses IP sur la machine natd doivent être active et pointer sur l’interface externe. Consultez la page de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> pour cela.</p></div></div></div></div><div class=sect1><h2 id=network-plip>32.9. IP sur liaison parallèle (PLIP)<a class=anchor href=#network-plip></a></h2><div class=sectionbody><div class=paragraph><p>PLIP nous permet d’utiliser le protocole TCP/IP entre ports parallèles. C’est utile sur des machines sans cartes réseaux, ou pour effectuer une installation sur ordinateur portable. Dans cette section nous aborderons:</p></div><div class=ulist><ul><li><p>La fabrication d’un câble parallèle ("laplink").</p></li><li><p>La connexion de deux ordinateurs via PLIP.</p></li></ul></div><div class=sect2><h3 id=network-create-parallel-cable>32.9.1. Fabriquer un câble parallèle<a class=anchor href=#network-create-parallel-cable></a></h3><div class=paragraph><p>Vous pouvez acheter un câble parallèle auprès de la plupart des vendeurs de matériel informatique. Si ce n’est pas le cas, ou désirez savoir comment est fait un tel câble, le tableau suivant montre comment en faire un à partir d’un câble parallèle d’imprimante.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 1. Câblage d’un câble parallèle pour réseau</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">A-name</th><th class="tableblock halign-left valign-top">A-End</th><th class="tableblock halign-left valign-top">B-End</th><th class="tableblock halign-left valign-top">Descr.</th><th class="tableblock halign-left valign-top">Post/Bit</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA0
-ERROR
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
2
15
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
15
2
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x01
1/0x08
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA1
+SLCT
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
3
13
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
13
3
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x02
1/0x10
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA2
+PE
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
4
12
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
12
4
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x04
1/0x20
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA3
-ACK
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
5
10
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
10
5
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Strobe</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x08
1/0x40
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA4
BUSY
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
6
11
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
11
6
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x10
1/0x80
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>GND</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>GND</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>-</pre></div></td></tr></tbody></table></div><div class=sect2><h3 id=network-plip-setup>32.9.2. Configurer PLIP<a class=anchor href=#network-plip-setup></a></h3><div class=paragraph><p>Tout d’abord procurez-vous un câble "laplink". Vérifiez ensuite que les deux ordinateurs disposent d’un noyau avec le support pour le pilote de périphérique <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep lp /var/run/dmesg.boot</span>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</code></pre></div></div><div class=paragraph><p>Le port parallèle doit fonctionner sous interruption, sous FreeBSD 4.X vous devriez avoir une ligne semblable à la ligne suivante dans le fichier de configuration du noyau:</p></div><div class="literalblock programlisting"><div class=content><pre>device ppc0 at isa? irq 7</pre></div></div><div class=paragraph><p>Sous FreeBSD 5.X, le fichier <span class=filename>/boot/device.hints</span> devrait contenir les lignes suivantes:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.at=&#34;isa&#34;
hint.ppc.0.irq=&#34;7&#34;</pre></div></div><div class=paragraph><p>Ensuite vérifiez si le fichier de configuration du noyau contient une ligne <code>device plip</code> ou si le module <span class=filename>plip.ko</span> est chargé. Dans les deux cas l’interface réseau parallèle devrait apparaître quand vous utilisez la commande <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>Branchez le câble "laplink" sur les interfaces parallèles des deux ordinateurs.</p></div><div class=paragraph><p>Configurez les paramètres de l’interface réseau des deux côtés en tant que <code>root</code>. Par exemple, si vous voulez connecter la machine <code>host1</code> avec la machine <code>host2</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>                 host1 ----- host2
IP Address    10.0.0.1      10.0.0.2</pre></div></div><div class=paragraph><p>Configurez l’interface sur <code>host1</code> en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.1 10.0.0.2</span></code></pre></div></div><div class=paragraph><p>Configurez l’interface sur <code>host2</code> en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.2 10.0.0.1</span></code></pre></div></div><div class=paragraph><p>Vous devriez avoir maintenant une connexion qui fonctionne. Veuillez consulter les pages de manuel <a href="https://man.freebsd.org/cgi/man.cgi?query=lp&amp;sektion=4&amp;format=html">lp(4)</a> et <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> pour plus de détails.</p></div><div class=paragraph><p>Vous devriez également ajouter les deux noms de machines dans le fichier <span class=filename>/etc/hosts</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</pre></div></div><div class=paragraph><p>Pour vérifier le bon fonctionnement de la connexion, aller sur les deux machines et effectuez un "ping" vers l’autre machine. Par exemple, sur <code>host1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class=nt>--</span><span class=o>&gt;</span> 10.0.0.2 netmask 0xff000000
<span class=c># netstat -r</span>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       plip0
<span class=c># ping -c 4 host2</span>
PING host2 <span class=o>(</span>10.0.0.2<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.774 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.530 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.556 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.714 ms

<span class=nt>---</span> host2 ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 2.530/2.643/2.774/0.103 ms</code></pre></div></div></div></div></div><div class=sect1><h2 id=network-ipv6>32.10. IPv6<a class=anchor href=#network-ipv6></a></h2><div class=sectionbody><div class=paragraph><p>L’IPv6 (également connu sous le nom de IPng "IP nouvelle génération") est la nouvelle version du très célèbre protocole IP (aussi connu sous le nom d’IPv4). Comme les autres systèmes BSD, FreeBSD utilise l’implémentation IPv6 KAME. Votre système FreeBSD est donc fourni avec tout ce dont vous aurez besoin pour tester l’IPv6. Cette section se concentre sur la configuration et l’utilisation d’IPv6.</p></div><div class=paragraph><p>Au début des années 90, on a pris conscience de la diminution rapide de l’espace d’adresses IPv4. Etant donné le taux d’expansion de l’Internet, deux problèmes majeurs apparaissaient:</p></div><div class=ulist><ul><li><p>Le manque d’adresses. Aujourd’hui ce n’est plus vraiment un problème puisque les espaces d’adresses privées RFC1918 (<code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, et <code>192.168.0.0/16</code>) et la translation d’adresses (NAT) sont utilisés.</p></li><li><p>Les tables des routeurs devenaient trop importantes. C’est toujours un problème actuellement.</p></li></ul></div><div class=paragraph><p>L’IPv6 remédie à ces problèmes et à de nombreux autres:</p></div><div class=ulist><ul><li><p>Espace d’adressage sur 128 bits. Ou plus précisément, il y a 340 282 366 920 938 463 463 374 607 431 768 211 456 adresses disponibles. Cela équivaut à approximativement 6.67 * 10^27 adresses IPv6 par kilomètre-carré de surface de notre planète.</p></li><li><p>Les routeurs ne stockeront que des regroupements d’adresses dans leurs tables de routage réduisant donc l’espace moyen d’une table de routage à 8192 entrées.</p></li></ul></div><div class=paragraph><p>IPv6 présente également de nombreuses autres intéressantes fonctionnalités telles que:</p></div><div class=ulist><ul><li><p>L’autoconfiguration des adresses (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>)</p></li><li><p>Adresses unicast ("une parmi plusieurs")</p></li><li><p>Adresses multicast (multidestinataires) obligatoires</p></li><li><p>IPsec (protocole de sécurité IP)</p></li><li><p>Struture d’entête simplifiée</p></li><li><p>IP mobile</p></li><li><p>Mécanismes de transition IPv6-vers-IPv4</p></li></ul></div><div class=paragraph><p>Pour plus d’informations consultez les références suivantes:</p></div><div class=ulist><ul><li><p>Généralités sur l’IPv6 à <a href=http://playground.sun.com/pub/ipng/html/ipng-main.html>playground.sun.com</a></p></li><li><p><a href=http://www.kame.net>KAME.net</a></p></li><li><p><a href=http://www.6bone.net>6bone.net</a></p></li></ul></div><div class=sect2><h3 id=_les_adresses_ipv6>32.10.1. Les adresses IPv6<a class=anchor href=#_les_adresses_ipv6></a></h3><div class=paragraph><p>Il existe différent types d’adresses IPv6: unicast, anycast et multicast.</p></div><div class=paragraph><p>Les adresses unicast (mono-destinataire) sont les adresses classiques. Un paquet envoyé à une adresse unicast arrive à l’interface correspondant à l’adresse.</p></div><div class=paragraph><p>Les adresses anycast ne sont normalement pas distinguables des adresses unicast mais correspondent à un groupe d’interfaces. Un paquet destiné à une adresse anycast arrivera à l’interface la plus proche (en terme d’unité de distance du protocole de routage). Les adresses anycast devraient n’être utilisées que par les routeurs.</p></div><div class=paragraph><p>Les adresses multicast identifient un groupe d’interfaces. Un paquet destiné à une adresse multicast arrivera sur toutes les interfaces appartenant au groupe multicast.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>L’adresse de diffusion IPv4 (généralement <code>xxx.xxx.xxx.255</code>) est exprimée par des adresses multicast en IPv6.</p></div></td></tr></tbody></table></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tableau 2. Adresses IPv6 réservées</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Adresse IPv6</th><th class="tableblock halign-left valign-top">Longueur du préfixe (bits)</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Notes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>non-spécifiée</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>similaire à <code>0.0.0.0</code> sous IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>adresse de boucle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>similaire à <code>127.0.0.1</code> sous IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 encapsulé</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les 32 bits de poids faible sont l’adresse IPv4. Egalement appelée "adresse IPv6 compatible IPv4".</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>adresse IPv6 mappée IPv4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Les 32 bits de poids faible sont l’adresse IPv4. Destinées aux machines ne supportant pas l’IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::</code> - <code>feb::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lien-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>similaire à l’interface de boucle sous IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fec0::</code> - <code>fef::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>site-local</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>001</code> (base 2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unicast globale</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Toutes les adresses unicast globales sont assignées à partir de ce pool. Les trois premiers bits de l’adresse sont "001".</p></td></tr></tbody></table></div><div class=sect2><h3 id=_lecture_des_adresses_ipv6>32.10.2. Lecture des adresses IPv6<a class=anchor href=#_lecture_des_adresses_ipv6></a></h3><div class=paragraph><p>La forme canonique est représentée suivant le schéma: <code>x:x:x:x:x:x:x:x</code>, où chaque "x" est une valeur héxadécimale sur 16 bits. Par exemple <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code></p></div><div class=paragraph><p>Souvent dans une adresse on aura de longues sous-parties constituées de zéros, une telle sous-partie peut être abrégée par "::". Les trois "0"s de poids fort de chaque quartet hexadécimal peuvent également être omis. Par exemple <code>fe80::1</code> correspond à la forme canonique <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>Une troisième forme est d’écrire les derniers 32 bits dans le style IPv4 bien connu (décimal) avec des points "." comme séparateurs. Par exemple <code>2002::10.0.0.1</code> correspond à la représentation canonique (hexadécimale) <code>2002:0000:0000:0000:0000:0000:0a00:0001</code> qui est à son tour équivalente à l’écriture <code>2002::a00:1</code>.</p></div><div class=paragraph><p>Maintenant le lecteur devrait être en mesure de comprendre ce qui suit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p><code>fe80::200:21ff:fe03:8e1%rl0</code> est une adresse de lien local configurée automatiquement. Elle est générée à partir de l’adresse MAC dans le cas de l’autoconfiguration.</p></div><div class=paragraph><p>Pour plus d’informations sur la structure des adresses IPv6 consultez la <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect2><h3 id=_se_connecter>32.10.3. Se connecter<a class=anchor href=#_se_connecter></a></h3><div class=paragraph><p>Actuellement, il y a quatre façons de se connecter à des machines et des réseaux utilisant l’IPv6:</p></div><div class=ulist><ul><li><p>Rejoindre le réseau expérimental 6bone</p></li><li><p>Obtenir un réseau IPv6 auprès de votre fournisseur d’accès. Contactez votre fournisseur d’accès Internet pour plus d’informations.</p></li><li><p>Utilisation d’un tunnel 6-vers-4 (<a href=http://www.ietf.org/rfc/rfc3068.txt>RFC3068</a>)</p></li><li><p>Utilisation du logiciel porté <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> si vous utilisez une connexion par modem.</p></li></ul></div><div class=paragraph><p>Ici nous ne parlerons que de la manière de se connecter au réseau 6bone puisque cela semble être aujourd’hui la méthode de connexion la plus populaire.</p></div><div class=paragraph><p>Consultez tout d’abord le site <a href=http://www.6bone.net/>6bone</a> et recherchez une connexion 6bone proche de vous. Contactez le responsable et avec un peu de chance on vous donnera les instructions à suivre pour configurer votre connexion. Généralement cela implique la mise en place d’un tunnel GRE (gif).</p></div><div class=paragraph><p>Voici un exemple typique de configuration d’un tunnel <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
<span class=c># ifconfig gif0 tunnel MON_ADR_IPv4 MON_ADR_IPv4_ASSIGNEE_A_LAUTRE_BOUT_DU_TUNNEL</span>
<span class=c># ifconfig gif0 inet6 alias MON_ADR_IPv6_ASSIGNEE_A_LEXTREMITE_DU_TUNNEL MON_ADR_IPv6_ASSIGNEE_A_LAUTRE_BOUT_DU_TUNNEL</span></code></pre></div></div><div class=paragraph><p>Remplacez les mots en majuscules par les informations que vous avez reçues du point d’accès 6bone.</p></div><div class=paragraph><p>Ceci établit le tunnel. Vérifiez si le tunnel fonctionne en utilisant <a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a> sur l’adresse <code>ff02::1%gif0</code>. Vous devriez récevoir les réponses aux requêtes ping.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Au cas où vous seriez intrigué par l’adresse <code>ff02:1%gif0</code>, sachez que c’est une adresse multicast. <code>%gif0</code> précise que l’adresse multicast de l’interface <span class=filename>gif0</span> doit être utilisée. Puisque nous utilisons <code>ping</code> sur une adresse multicast, l’autre bout du tunnel devrait également répondre.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Désormais, la mise en place d’une route vers votre lien 6bone devrait être relativement directe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -inet6 default -interface gif0</span>
<span class=c># ping6 -n MON_LIEN_MONTANT</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># traceroute6 www.jp.FreeBSD.org</span>
<span class=o>(</span>3ffe:505:2008:1:2a0:24ff:fe57:e561<span class=o>)</span> from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms <span class=k>*</span>
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</code></pre></div></div><div class=paragraph><p>La sortie pourra être différente d’une machine à une autre. Maintenant vous devriez être en mesure d’atteindre le site IPv6 <a href=http://www.kame.net>www.kame.net</a> et de voir la tortue dansante - et cela si vous disposez d’un navigateur supportant l’IPv6 comme <a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a>, Konqueror qui fait partie du logiciel <a class=package href=https://cgit.freebsd.org/ports/tree/x11/kdebase3/>x11/kdebase3</a>, ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/epiphany/>www/epiphany</a>.</p></div></div><div class=sect2><h3 id=_dns_dans_le_monde_ipv6>32.10.4. DNS dans le monde IPv6<a class=anchor href=#_dns_dans_le_monde_ipv6></a></h3><div class=paragraph><p>A l’origine, il existait deux types d’enregistrement DNS pour l’IPv6. L’organisme IETF a déclaré obsolète l’enregistrement A6. Les enregistrements AAAA sont aujourd’hui le standard.</p></div><div class=paragraph><p>L’utilisation des enregistrements AAAA est assez direct. Assignez votre nom de machine à la nouvelle adresse IPv6 que vous venez d’obtenir en ajoutant:</p></div><div class="literalblock programlisting"><div class=content><pre>MYHOSTNAME           AAAA    MYIPv6ADDR</pre></div></div><div class=paragraph><p>à votre fichier de zone DNS primaire. Dans le cas où vous ne gérez pas vos propres zones DNS contactez le responsable de votre DNS. Les versions actuelles de bind (version 8.3 et 9) et <a class=package href=https://cgit.freebsd.org/ports/tree/dns/djbdns/>dns/djbdns</a> (avec le correctif IPv6) supportent les enregistrements AAAA.</p></div></div><div class=sect2><h3 id=_effectuer_les_changements_nécessaires_dans_le_fichier_etcrc_conf>32.10.5. Effectuer les changements nécessaires dans le fichier <span class=filename>/etc/rc.conf</span><a class=anchor href=#_effectuer_les_changements_nécessaires_dans_le_fichier_etcrc_conf></a></h3><div class=sect3><h4 id=_paramétrage_du_client_ipv6>32.10.5.1. Paramétrage du client IPv6<a class=anchor href=#_paramétrage_du_client_ipv6></a></h4><div class=paragraph><p>Ces paramètres vous permettront de configurer une machine qui sera sur votre réseau local et sera un client, non pas un routeur. Pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a> configure automatiquement votre interface réseau au démarrage tout ce dont vous avez besoin d’ajouter est:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Pour assigner une adresse IP statique telle que <code>2001:471:1f11:251:290:27ff:fee0:2093</code>, à votre interface <span class=filename>fxp0</span>, ajoutez:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_fxp0=&#34;2001:471:1f11:251:290:27ff:fee0:2093&#34;</pre></div></div><div class=paragraph><p>Pour assigner le routeur par défaut <code>2001:471:1f11:251::1</code>, ajoutez ce qui suit au fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:471:1f11:251::1&#34;</pre></div></div></div><div class=sect3><h4 id=_paramétrage_dun_routeurpasserelle_ipv6>32.10.5.2. Paramétrage d’un routeur/passerelle IPv6<a class=anchor href=#_paramétrage_dun_routeurpasserelle_ipv6></a></h4><div class=paragraph><p>Ceci vous aidera à mettre en oeuvre les instructions que votre fournisseur de tunnel, tel que <a href=http://www.6bone.net/>6bone</a>, vous a donné et à les convertir en paramètres qui seront conservés à chaque démarrage. Pour rétablir votre tunnel au démarrage, utilisez quelque chose comme ce qui suit dans le fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class=paragraph><p>Listez les interfaces génériques de tunnel qui seront configurées, par exemple <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gif_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Pour configurer l’interface avec une adresse (extrémité) locale <em>MY_IPv4_ADDR</em> vers une adresse (extrémité) distante <em>REMOTE_IPv4_ADDR</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig_gif0=&#34;MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>Pour utiliser l’adresse IPv6 que l’on vous a assigné en vue d’être utilisée pour votre extrémité du tunnel IPv6, ajoutez:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ifconfig_gif0=&#34;MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Ensuite tout ce qu’il reste à faire est de définir la route par défaut pour l’IPv6. C’est l’autre extrémité du tunnel IPv6:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div></div><div class=sect3><h4 id=_paramétrage_dun_tunnel_ipv6>32.10.5.3. Paramétrage d’un tunnel IPv6<a class=anchor href=#_paramétrage_dun_tunnel_ipv6></a></h4><div class=paragraph><p>Si le serveur doit router de l’IPv6 entre votre réseau et le reste du monde, le paramètre suivant sera également nécessaire dans votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_annonce_du_routeur_et_auto_configuration>32.10.6. Annonce du routeur et auto-configuration<a class=anchor href=#_annonce_du_routeur_et_auto_configuration></a></h3><div class=paragraph><p>Cette section vous aidera à configurer <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> pour l’annonce de la route IPv6 par défaut.</p></div><div class=paragraph><p>Pour activer <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, vous devrez ajouter ce qui suit à votre fichier <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Il est important que vous indiquiez l’interface sur laquelle le routeur IPv6 sera sollicité. Par exemple pour que <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> utilise <span class=filename>fxp0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;fxp0&#34;</pre></div></div><div class=paragraph><p>Nous devons maintenant créer le fichier de configuration <span class=filename>/etc/rtadvd.conf</span>. Voici un exemple:</p></div><div class="literalblock programlisting"><div class=content><pre>fxp0:\
	:addrs#1:addr=&#34;2001:471:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Remplacez <span class=filename>fxp0</span> avec l’interface que vous allez utiliser.</p></div><div class=paragraph><p>Ensuite remplacez <code>2001:471:1f11:246::</code> avec votre préfixe.</p></div><div class=paragraph><p>Si vous êtes un sous-réseau <code>/64</code> dédié, il ne sera pas nécessaire de modifier quelque chose d’autre. Sinon, vous devrez modifier <code>prefixlen#</code> avec la valeur correcte.</p></div></div></div></div><div class=sect1><h2 id=network-atm>32.11. ATM ("Asynchronous Transfer Mode")<a class=anchor href=#network-atm></a></h2><div class=sectionbody><div class=sect2><h3 id=_configuration_ip_conventionnelle_sur_atm_pvcs>32.11.1. Configuration IP conventionnelle sur ATM (PVCs)<a class=anchor href=#_configuration_ip_conventionnelle_sur_atm_pvcs></a></h3><div class=paragraph><p>L’IP conventionnelle sur ATM ("Classical IP over ATM"-CLIP) est la méthode la plus simple pour utiliser ATM (Asynchronous Transfer Mode) avec l’IP. Elle peut être utilisée en mode non connecté ("Switched Virtual Connections"-SVCs) et en mode connecté ("Permanent Virtual Connections"-PVCs). Cette section décrit comment configurer un réseau basé sur les PVCs.</p></div><div class=sect3><h4 id=_configurations_en_réseau_maillé>32.11.1.1. Configurations en réseau maillé<a class=anchor href=#_configurations_en_réseau_maillé></a></h4><div class=paragraph><p>La première méthode de configuration CLIP avec des PVCs est de connecter entre elles chaque machine du réseau par l’intermédiaire d’une PVC dédiée. Bien que cela soit simple à configurer, cela tend à devenir impraticable avec un nombre important de machines. Notre exemple suppose que nous avons quatre machines sur le réseau, chacune connectée au réseau ATM à l’aide d’une carte réseau ATM. La première étape est d’établir le plan des adresses IP et des connexions ATM entre machines. Nous utilisons le plan suivant:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machine</th><th class="tableblock halign-left valign-top">Adresse IP</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.3</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>192.168.173.4</code></p></td></tr></tbody></table><div class=paragraph><p>Pour réaliser un réseau maillé, nous avons besoin d’une connexion ATM entre chaque paire de machines:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Machines</th><th class="tableblock halign-left valign-top">Couple VPI.VCI</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostB</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.100</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.101</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostA</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.102</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostC</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.103</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostB</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.104</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hostC</code> - <code>hostD</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.105</p></td></tr></tbody></table><div class=paragraph><p>Les valeurs VPI et VCI à chaque extrémité de la connexion peuvent bien évidemment être différentes, mais par souci de simplicité nous supposerons quelles sont identiques. Ensuite nous devons configurer les interfaces ATM sur chaque machine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# ifconfig hatm0 192.168.173.1 up
hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up
hostD# ifconfig hatm0 192.168.173.4 up</code></pre></div></div><div class=paragraph><p>en supposant que l’interface ATM est <span class=filename>hatm0</span> sur toutes les machines. Maintenant les PVCs doivent être configurées sur <code>hostA</code> (nous supposons qu’elles sont déjà configurées sur les switches ATM, vous devez consulter le manuel du switch sur comment réaliser cette configuration).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA# atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA# atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB# atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB# atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB# atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC# atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD# atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD# atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD# atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</code></pre></div></div><div class=paragraph><p>Bien évidemment des contrats de trafic autres qu’UBR ("Unspecified Bit Rate") peuvent être utilisés dès que la carte ATM les supportent. Dans ce cas le nom du contrat de trafic est suivi par les paramètres du trafic. De l’aide concernant l’outil <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a> peut être obtenue avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atmconfig help natm add</span></code></pre></div></div><div class=paragraph><p>ou dans la page de manuel de <a href="https://man.freebsd.org/cgi/man.cgi?query=atmconfig&amp;sektion=8&amp;format=html">atmconfig(8)</a>.</p></div><div class=paragraph><p>La même configuration peut être faite par l’intermédiaire de <span class=filename>/etc/rc.conf</span>. Pour la machine <code>hostA</code> cela ressemblerait à:</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 hatm0&#34;
ifconfig_hatm0=&#34;inet 192.168.173.1 up&#34;
natm_static_routes=&#34;hostB hostC hostD&#34;
route_hostB=&#34;192.168.173.2 hatm0 0 100 llc/snap ubr&#34;
route_hostC=&#34;192.168.173.3 hatm0 0 101 llc/snap ubr&#34;
route_hostD=&#34;192.168.173.4 hatm0 0 102 llc/snap ubr&#34;</pre></div></div><div class=paragraph><p>L’état de toutes les routes CLIP peut être obtenu avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hostA# atmconfig natm show</code></pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9 mars 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/fr/books/handbook/firewalls class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/fr/books/handbook/partv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>32.1. Synopsis</a></li><li><a href=#network-routing>32.2. Passerelles et routes</a></li><li><a href=#network-wireless>32.3. Réseau sans fil</a></li><li><a href=#network-bluetooth>32.4. Bluetooth</a></li><li><a href=#network-bridging>32.5. Bridging</a></li><li><a href=#network-diskless>32.6. Système sans disque dur</a></li><li><a href=#network-isdn>32.7. ISDN</a></li><li><a href=#network-natd>32.8. Translation d’adresses</a></li><li><a href=#network-plip>32.9. IP sur liaison parallèle (PLIP)</a></li><li><a href=#network-ipv6>32.10. IPv6</a></li><li><a href=#network-atm>32.11. ATM ("Asynchronous Transfer Mode")</a></li></ul></nav><hr><div class=resources><h3>Ressources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Téléchargement en PDF"></i><a href=https://download.freebsd.org/doc/fr/books/handbook/handbook_fr.pdf>Téléchargement en PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Éditer cette page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/fr/_index target=_blank>Éditer cette page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/fr/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>French</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Clair</option><option value=theme-dark>Sombre</option><option value=theme-high-contrast>Contraste élevé</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/fr class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/fr/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>