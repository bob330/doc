<!doctype html><html class=theme-light lang=fr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/fr/books/developers-handbook/><title>Livre de chevet du développeur FreeBSD | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Livre de chevet du développeur FreeBSD"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="fr"><meta property="og:url" content="https://docs.freebsd.org/fr/books/developers-handbook/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/fr\/books\/developers-handbook\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/fr>Documentation portal</a></li><li><a href=https://docs.freebsd.org/fr/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/fr/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/fr/books>Books</a></li><li><a href=https://docs.freebsd.org/fr/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/fr/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=fr>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>Livre de chevet du développeur FreeBSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>Marques déposées</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390, and ThinkPad are trademarks of International Business Machines Corporation in the United States, other countries, or both.</p><p>IEEE, POSIX, and 802 are registered trademarks of Institute of Electrical and Electronics Engineers, Inc. in the United States.</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. and other countries.</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, and Xeon are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.</p><p>Linux is a registered trademark of Linus Torvalds.</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries.</p><p>Motif, OSF/1, and UNIX are registered trademarks and IT DialTone and The Open Group are trademarks of The Open Group in the United States and other countries.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS and VirtualBox are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#introduction>Partie I: Introduction</a><ul><li><a href=#developmentplatform>Chapitre 1. Développer sous FreeBSD</a></li><li><a href=#bsdvision>Chapitre 2. La vision BSD</a></li><li><a href=#archoverview>Chapitre 3. Survol de l’architecture</a></li><li><a href=#sourcelayout>Chapitre 4. L’agencement de /usr/src</a></li></ul></li><li><a href=#Basics>Partie II: Les fondamentaux</a><ul><li><a href=#tools>Chapitre 5. Outils de programmation</a></li><li><a href=#secure>Chapitre 6. Programmation sécurisée</a></li></ul></li><li><a href=#kernel>Partie III: Le noyau</a><ul><li><a href=#kernelhistory>Chapitre 7. Histoire du noyau Unix</a></li><li><a href=#locking>Chapitre 8. Notes sur le verrouillage</a></li></ul></li><li><a href=#memory>Partie IV: Mémoire et mémoire virtuelle</a><ul><li><a href=#virtualmemory>Chapitre 9. La mémoire virtuelle</a></li></ul></li><li><a href=#iosystem>Partie V: Système E/S (Entrées/Sorties)</a><ul><li><a href=#UFS>Chapitre 10. UFS</a></li></ul></li><li><a href=#ipc>Partie VI: Communication InterProcessus (IPC)</a><ul><li><a href=#signals>Chapitre 11. Les signaux</a></li></ul></li><li><a href=#networking>Partie VII: Le réseau</a><ul><li><a href=#sockets>Chapitre 12. Les prises</a></li></ul></li><li><a href=#networkfs>Partie VIII: Systèmes de fichiers en réseau</a><ul><li><a href=#afs>Chapitre 13. AFS</a></li></ul></li><li><a href=#terminal>Partie IX: Gestion du terminal</a><ul><li><a href=#syscons>Chapitre 14. Syscons</a></li></ul></li><li><a href=#sound>Partie X: Le son</a><ul><li><a href=#oss>Chapitre 15. OSS</a></li></ul></li><li><a href=#devicedrivers>Partie XI: Pilotes de périphérique</a><ul><li><a href=#driverbasics>Chapitre 16. Ecrire des pilotes de périphériques pour FreeBSD</a></li><li><a href=#pci>Chapitre 17. Les périphériques PCI</a></li><li><a href=#scsi>Chapitre 18. Contrôleurs SCSI Common Access Method (CAM) **</a></li><li><a href=#usb>Chapitre 19. Périphériques USB <strong>*</strong></a></li><li><a href=#newbus>Chapitre 20. NewBus</a></li></ul></li><li><a href=#architectures>Partie XII: Architectures</a><ul><li><a href=#ia32>Chapitre 21. IA-32</a></li><li><a href=#alpha>Chapitre 22. Alpha</a></li><li><a href=#ia64>Chapitre 23. IA-64</a></li></ul></li><li><a href=#debuggingpart>Partie XIII: Déverminage</a><ul><li><a href=#truss>Chapitre 24. Truss</a></li></ul></li><li><a href=#compatibility>Partie XIV: Les couches de compatibilité</a><ul><li><a href=#linux>Chapitre 25. Linux</a></li></ul></li><li><a href=#appendices>Bibligraphie</a></li><li><a href=#_bibliographie>Bibliographie</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>Résumé</blockquote></div><div class=paragraph><p>Bienvenue dans le livre de chevet du développeur</p></div><div class=paragraph><p>Version française de Frédéric Praca &lt;<a href=mailto:frederic.praca@freebsd-fr.org>frederic.praca@freebsd-fr.org</a>>.</p></div><div class=paragraph><p>N.d.T.: La version française est publiée sur le <a href=https://www.FreeBSD.org/>serveur World Wide Web du groupe de traduction en langue française de la documentation de FreeBSD</a>.</p></div><div class=paragraph><p>N.d.T.: Contactez la liste de diffusion du groupe d’utilisateurs francophones de FreeBSD &lt;<a href=mailto:freebsd-questions@FreeBSD-fr.org>freebsd-questions@FreeBSD-fr.org</a>> si vous voulez collaborer à la traduction.</p></div><div class=paragraph><p>La traduction de ce manuel est "en cours". Dans la table des matières ci-dessous:</p></div><div class=ulist><ul><li><p>Les chapitres marqués de deux astérisques sont en cours de traduction.</p></li><li><p>Les chapitres marqués de trois astérisques sont à traduire.</p></li><li><p>L’astérisque simple est réservé aux chapitres et sections en cours de rédaction dans la version U.S.</p></li></ul></div><hr></div></div><h1 id=introduction class=sect0>Partie I: Introduction<a class=anchor href=#introduction></a></h1><div class=sect1><h2 id=developmentplatform>Chapitre 1. Développer sous FreeBSD<a class=anchor href=#developmentplatform></a></h2><div class=sectionbody><div class=paragraph><p>Ce document a pour but de décrire FreeBSD comme une plateforme de développement, la vision de BSD, un survol de l’architecture, l’agencement de /usr/src, l’histoire, etc.</p></div><div class=paragraph><p>Merci d’adopter FreeBSD comme votre plateforme de développement ! Nous espérons qu’elle ne vous laissera pas tomber.</p></div></div></div><div class=sect1><h2 id=bsdvision>Chapitre 2. La vision BSD<a class=anchor href=#bsdvision></a></h2><div class=sectionbody></div></div><div class=sect1><h2 id=archoverview>Chapitre 3. Survol de l’architecture<a class=anchor href=#archoverview></a></h2><div class=sectionbody></div></div><div class=sect1><h2 id=sourcelayout>Chapitre 4. L’agencement de /usr/src<a class=anchor href=#sourcelayout></a></h2><div class=sectionbody><div class=paragraph><p>Le code source complet de FreeBSD est disponible depuis notre base CVS publique. Le code source est normalement installé sous <span class=filename>/usr/src</span> qui contient les sous-répertoires suivants.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Répertoire</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/bin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>contrib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers des logiciels fournis ("contributed").</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>crypto/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources du DES</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/etc</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>games/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/usr/games</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>gnu/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilitaires sous licence publique GNU</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/usr/include</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>kerberosIV/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources de Kerbereros version IV</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>kerberos5/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources de Kerbereros version 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/usr/lib</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/usr/libexec</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>release/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers requis pour la production d’une version stable de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/sbin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>secure/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources de FreeSec</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>share/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/sbin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>sys/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fichiers source du noyau</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>tools/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Outils utilisés pour la maintenance et les tests de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>usr.bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/usr/bin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>usr.sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sources des fichiers de <span class=filename>/usr/sbin</span></p></td></tr></tbody></table></div></div><h1 id=Basics class=sect0>Partie II: Les fondamentaux<a class=anchor href=#Basics></a></h1><div class=sect1><h2 id=tools>Chapitre 5. Outils de programmation<a class=anchor href=#tools></a></h2><div class=sectionbody><div class=paragraph><p><em>Ce chapître a été écrit par James Raynard. Les modifications pour le livre de chevet du développeur par Murray Stokely.</em></p></div><div class=sect2><h3 id=_synopsis>5.1. Synopsis<a class=anchor href=#_synopsis></a></h3><div class=paragraph><p>Ce document est une introduction à l’utilisation de quelques outils de programmation fournis avec FreeBSD, toutefois tout sera applicable à beaucoup d’autres versions d’Unix. Cette introduction <em>n’essaye</em> pas de décrire la programmation dans le détail. La plupart du document suppose que vous possédez peu ou pas de connaissances en programmation, espérant que les programmeurs trouveront un intérêt dans ce document.</p></div></div><div class=sect2><h3 id=_introduction>5.2. Introduction<a class=anchor href=#_introduction></a></h3><div class=paragraph><p>FreeBSD offre un excellent environnement de développement. Des compilateurs pour c, c++ et Fortran ainsi qu’un assembleur sont fournis avec le système de base, sans parler de l’interpréteur PERL ni des outils classiques Unix comme <code>sed</code> et <code>awk</code>. Si cela n’est pas suffisant, il y a encore plus de compilateurs et d’interpréteurs dans la collection des logiciels portés. FreeBSD est compatible avec les standards comme POSIX et C ANSI, aussi bien qu’avec son propre héritage BSD, aussi il est possible d’écrire des applications qui se compileront et s’exécuteront avec peu ou pas de modifications sur un grand nombre de plateformes.</p></div><div class=paragraph><p>Toutefois, toute cette puissance peut être plutôt écrasante au premier abord si vous n’avez jamais écrit de programmes sur une plateforme Unix auparavant. Ce document a pour but de vous aider à commencer, sans entrer trop loin dans des sujets plus avancés. L’intention est que ce document devrait vous donner assez de bases pour être capable de donner du sens à la documentation.</p></div><div class=paragraph><p>La majeure partie du document requiert peu ou pas de connaissance de la programmation, bien qu’il suppose une compétence de base dans l’utilisation d’Unix et dans la bonne volonté d’apprendre !</p></div></div><div class=sect2><h3 id=_introduction_à_la_programmation>5.3. Introduction à la programmation<a class=anchor href=#_introduction_à_la_programmation></a></h3><div class=paragraph><p>Un programme est un ensemble d’instructions qui disent à l’ordinateur de faire diverses choses; quelques fois, l’instruction qu’il a à exécuter dépend de ce qui s’est passé lors de l’exécution d’une instruction précédente. Cette section donne un aperçu des deux manières par lesquelles vous pouvez donner ces instructions, ou "commandes" comme elles sont habituellement nommées. Une façon utilise un <em>interpréteur</em>, l’autre un <em>compilateur</em>. Comme les langages humains sont trop difficiles à comprendre sans ambiguïté par un ordinateur, les commandes sont habituellement écrites dans un langage ou un autre spécialement conçus pour cet usage.</p></div><div class=sect3><h4 id=_les_interpréteurs>5.3.1. Les interpréteurs<a class=anchor href=#_les_interpréteurs></a></h4><div class=paragraph><p>Avec un interpréteur, le langage va avec un environnement où vous entrez des commandes à un invite de commandes et l’environnement les exécute pour vous. Pour des programmes plus compliqués, vous pouvez entrer les commandes dans un fichier et demander à l’interpréteur de charger le fichier et d’exécuter les commandes qui sont à l’intérieur. Si quoique ce soit se passe mal, beaucoup d’interpréteurs vous enverrons dans un dévermineur pour vous aider à débusquer le problème.</p></div><div class=paragraph><p>L’avantage de cela est que vous pouvez voir les résultats de vos commandes immédiatement, et les erreurs peuvent être corrigées facilement. Le plus gros désavantage arrive quand vous voulez partager vos programmes avec d’autres personnes. Ils doivent avoir le même interpréteur ou bien vous devez avoir un moyen de leur donner, et ils doivent comprendre comment l’utiliser. Par ailleurs, les utilisateurs pourraient ne pas apprécier d’être renvoyés dans un dévermineur s’ils ont appuyé sur la mauvaise touche ! D’un point de vue performance, les interpréteurs peuvent utiliser beaucoup de mémoire et généralement ne génèrent pas un code aussi efficace que les compilateurs.</p></div><div class=paragraph><p>A mon avis, les langages interprétés sont le meilleur moyen pour démarrer si vous n’avez jamais programmé. Ce genre d’environnement se trouve typiquement avec des langages comme Lisp, Smalltalk, Perl et Basic. Il peut aussi être dit que l’interpréteur de commandes Unix (<code>sh</code>, <code>csh</code>) est lui-même un interpréteur, et beaucoup de gens écrivent en fait des "scripts" (procédures) pour l’interpréteur pour les aider dans diverses tâches "domestiques" sur leur machine. En effet, une partie de la philosophie d’origine d’Unix était de fournir plein de petits programmes utilitaires qui pouvaient être liés ensemble dans des procédures pour effectuer des tâches utiles.</p></div></div><div class=sect3><h4 id=_les_interpréteurs_disponibles_avec_freebsd>5.3.2. Les interpréteurs disponibles avec FreeBSD<a class=anchor href=#_les_interpréteurs_disponibles_avec_freebsd></a></h4><div class=paragraph><p>Voici la liste des interpréteurs qui sont disponibles sous la forme de <a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/>logiciels pré-compilés pour FreeBSD</a>, avec une brève description de quelques uns des langages interprétés les plus populaires.</p></div><div class=paragraph><p>Pour obtenir un de ces logiciels pré-compilés, tout ce que vous avez à faire est de cliquer sur le lien du logiciel et d’exécuter</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add nom du logiciel</span></code></pre></div></div><div class=paragraph><p>en tant que super-utilisateur. Evidemment, vous aurez besoin d’un FreeBSD 2.1.0 ou plus en état de marche pour que le logiciel fonctionne !</p></div><div class=dlist><dl><dt class=hdlist1>BASIC</dt><dd><p>Abbréviation de "Beginner’s All-purpose Symbolic Instruction Code" (code d’instruction symbolique tout usage pour le débutant). Développé dans les années 50 pour apprendre aux étudiants d’université à programmer et fourni avec tout ordinateur qui se respecte dans les années 80, BASIC a été le premier langage de programmation pour beaucoup de programmeurs. Il est aussi le fondement même du Visual Basic.</p><div class=paragraph><p>L’interpréteur Basic <a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/bwbasic-2.10.tgz>Bywater </a>et l’interpréteur Basic de <a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/pbasic-2.0.tgz>Phil Cockroft</a> (anciennement Rabbit Basic) sont disponibles pour FreeBSD sous forme de<a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/> logiciels pré-compilés</a></p></div></dd><dt class=hdlist1>Lisp</dt><dd><p>Un langage qui a été développé à la fin des années 50 comme une alternative aux langages "dévoreurs de calculs" qui étaient très populaires à l’époque. Plutôt qu’être basé sur les nombres, Lisp est basé sur les listes; en fait le nom est l’abbréviation de "List Processing". Très populaire en IA (Intelligence Artificielle).</p><div class=paragraph><p>Lisp est un langage extrèmement puissant et sophistiqué , mais peut être assez lourd et peu maniable.</p></div><div class=paragraph><p>FreeBSD a <a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/gcl-2.0.tgz>GNU Common Lisp</a> de disponible sous la forme d’un logiciel pré-compilé.</p></div></dd><dt class=hdlist1>Perl</dt><dd><p>Très populaire auprès des administrateurs système pour la rédaction de procédures; aussi souvent utilisé sur les serveurs Internet pour l’écriture de procédures CGI.</p><div class=paragraph><p>La dernière version (version 5) est fournie avec FreeBSD.</p></div></dd><dt class=hdlist1>Scheme</dt><dd><p>Un dérivé du Lisp qui est plutôt plus compact et plus propre que le Common Lisp. Populaire dans les universités étant suffisamment simple à apprendre aux étudiants comme premier langage , il possède un niveau d’abstraction suffisamment important pour être utilisé dans le travail de recherche.</p><div class=paragraph><p>On trouve pour FreeBSD les logiciels pré-compilés <a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/elk-3.0.tgz>interpréteur Scheme Elk</a>, <a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/mit-scheme-7.3.tgz>l’interpréteur Scheme du MIT</a> et <a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/scm-4e1.tgz>l’interpréteur Scheme SCM</a>.</p></div></dd><dt class=hdlist1>Icon</dt><dd><p><a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/icon-9.0.tgz>Le langage de programmation Icon</a>.</p></dd><dt class=hdlist1>Logo</dt><dd><p><a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/ucblogo-3.3.tgz>l’interpréteur Logo de Brian Harvey</a>.</p></dd><dt class=hdlist1>Python</dt><dd><p><a href=ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/python-1.2>Le langage orienté objet Python</a></p></dd></dl></div></div><div class=sect3><h4 id=_les_compilateurs>5.3.3. Les compilateurs<a class=anchor href=#_les_compilateurs></a></h4><div class=paragraph><p>Les compilateurs sont plutôt différents entre eux. Tout d’abord, vous écrivez votre code dans un fichier (ou des fichiers) en utilisant un éditeur de texte. Vous exécutez ensuite le compilateur et vérifiez qu’il accepte votre programme. S’il ne compile pas, grincez des dents et retournez à l’éditeur; s’il compile et vous donne un programme, vous pouvez exécuter ce dernier à l’invite de commande ou dans un dévermineur pour voir s’il fonctionne correctement.</p></div><div class=paragraph><p>Evidemment, ce n’est pas aussi direct que d’utiliser un interpréteur. Toutefois cela vous permet de faire beaucoup de choses qui sont difficiles ou même impossibles avec un interpréteur, comme écrire du code qui interagit de façon proche du système d’exploitation ou même d’écrire votre propre système d’exploitation ! C’est aussi utile si vous avez besoin d’écrire du code très efficace, étant donné que le compilateur peut prendre son temps et optimiser le code, ce qui ne serait pas acceptable avec un interpréteur. Et distribuer un programme écrit pour un compilateur est habituellement plus évident qu’un écrit pour un interpréteur-vous pouvez juste donner une copie de l’exécutable, en supposant que l’utilisateur possède le même système d’exploitation que vous.</p></div><div class=paragraph><p>Les langages compilés incluent Pascal, C et C. C et C sont des langages plutôt impitoyables et conviennent mieux aux programmeurs expérimentés; Pascal, d’autre part, a été conçu comme un langage éducatif, et est un assez bon langage pour commencer. Malheureusement, FreeBSD ne possède aucun support Pascal, excepté pour un convertisseur Pascal vers C dans les logiciels portés.</p></div><div class=paragraph><p>Le cycle édition-compilation-exécution-déverminage étant relativement pénible lors de l’utilisation de programmes séparés, beaucoup de fabricants de compilateur ont produit des environnements de développement intégrés (ou IDE pour Integrated Development Environments et EDI dans la langue de Molière). FreeBSD ne possède pas d’EDI tel quel; toutefois il est possible d’utiliser Emacs à cet effet. Ceci est vu dans <a href=#emacs>Utiliser Emacs comme environnement de développement</a>.</p></div></div></div><div class=sect2><h3 id=_compiler_avec_cc>5.4. Compiler avec <code>cc</code><a class=anchor href=#_compiler_avec_cc></a></h3><div class=paragraph><p>Cette section traite uniquement du compilateur GNU pour C et C++, celui-ci faisant partie du système FreeBSD de base. Il peut être invoqué soit par <code>cc</code> ou <code>gcc</code>. Les détails de production d’un programme avec un interpréteur varient considérablement d’un interpréteur à l’autre, et sont habituellement bien couverts par la documentation et l’aide en ligne de l’interpréteur.</p></div><div class=paragraph><p>Une fois que vous avez écrit votre chef d’oeuvre, la prochaine étape est de le convertir en quelque chose qui s’exécutera (espérons !) sur FreeBSD. Cela implique normalement plusieurs étapes, réalisées chacune par un programme différent.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Pré-traiter votre code source pour retirer les commentaires et faire d’autres trucs comme développer (expanser) les macros en C.</p></li><li><p>Vérifier la syntaxe de votre code source pour voir si vous avez obéi aux règles du langage. Si vous ne l’avez pas fait, il se plaindra !</p></li><li><p>Convertir le code source en langage assembleur- cela est vraiment proche du code machine, mais reste compréhensible par des humains. Prétendument.</p></li><li><p>Convertir le langage assembleur en code machine -ouais, on parle de bits et d’octets, de uns et de zéros.</p></li><li><p>Vérifier que vous avez utilisé des choses comme des fonctions et des variables globales de façon consistente. Par exemple, si vous avez appelé une fonction inexistente, le compilateur se plaindra.</p></li><li><p>Si vous essayez de produire un exécutable depuis plusieurs fichiers de code source, résoudre comment les faire fonctionner ensemble.</p></li><li><p>Résoudre comment produire quelque chose que le chargeur au vol du système sera capable de charger en mémoire et exécuter.</p></li><li><p>Finalement, écrire l’exécutable dans le système de fichiers.</p></li></ol></div></div></div><div class=paragraph><p>Le mot <em>compilation</em> est souvent utilisé pour les étapes 1 à 4 seules-les autres correspondent au terme <em>liaison</em>. Quelquefois, l’étape 1 est appelée <em>pre-traitement</em> et les étapes 3-4 <em>assemblage</em>.</p></div><div class=paragraph><p>Heureusement, la plupart de ces détails vous sont cachés, étant donné que <code>cc</code> est un frontal qui s’occupe d’appeler tous les programmes avec les arguments corrects pour vous; tapez simplement</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foobar.c</code></pre></div></div><div class=paragraph><p>compilera <span class=filename>foobar.c</span> avec toutes les étapes au-dessus. Si vous avez plus d’un fichier à compiler, faites simplement quelque chose comme</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foo.c bar.c</code></pre></div></div><div class=paragraph><p>Notez que la vérification de syntaxe n’est que cela-vérifier la syntaxe. Cela ne vérifiera pas les erreurs de logique que vous pouvez avoir faites, comme mettre le programme en boucle infinie ou utiliser un tri à bulles quand vous devriez utiliser un tri binaire.</p></div><div class=paragraph><p>Il y a beaucoup d’options pour <code>cc</code>, qui qui se trouvent toutes dans les pages de manuel en ligne. Voici quelques unes des plus importantes, avec des exemples illustrant leur utilisation.</p></div><div class=dlist><dl><dt class=hdlist1><code>-o <em>nom_du_fichier</em></code></dt><dd><p>Le nom de sortie du fichier. Si vous n’utilisez pas cette option, <code>cc</code> produira un exécutable appelé <span class=filename>a.out</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foobar.c               l<span class=s1>&#39;exécutable est a.out
% cc -o foobar foobar.c     l&#39;</span>exécutable est foobar</code></pre></div></div></dd><dt class=hdlist1><code>-c</code></dt><dd><p>Compile juste le fichier, ne le lie pas. Utile pour les programmes jouets dont vous voulez juste vérifier la syntaxe, ou si vous utilisez un <span class=filename>Makefile</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-c</span> foobar.c</code></pre></div></div><div class=paragraph><p>Cela va produire un <em>fichier objet</em> (pas un exécutable) appelé <span class=filename>foobar.o</span>. Celui-ci peut être lié ensuite avec d’autres fichiers objets pour produire un exécutable.</p></div></dd><dt class=hdlist1><code>-g</code></dt><dd><p>Crée une version de déverminage de l’exécutable. Cela oblige le compilateur à placer des informations dans l’exécutable comme telle ligne du fichier source correspond à tel appel de fonction. Un dévermineur peut utiliser cette information pour vous montrer le code source au fur et à mesure que vous avancez pas à pas dans le programme, ce qui est <em>très</em> utile; le désavantage est que toutes ces informations supplémentaires rendent le programme plus gros. Normalement, vous compilez avec l’option <code>-g</code> quand vous êtes en train de développer un programme et compilez ensuite une "version de production" sans <code>-g</code> quand vous êtes satisfait du fonctionnement.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-g</span> foobar.c</code></pre></div></div><div class=paragraph><p>Cela va produire une version de déverminage du programme foobar.</p></div></dd><dt class=hdlist1><code>-O</code></dt><dd><p>Crée une version optimisée de l’exécutable. Le compilateur effectue différents trucs malins pour essayer de produire un exécutable qui s’exécute plus rapidement que normal. Vous pouvez ajouter un nombre après l’option <code>-O</code> pour spécifier un niveau d’optimisation plus important, mais cela vous expose souvent aux bogues dans l’optimiseur du compilateur. Par exemple, la version de <code>cc</code> fournit avec la version 2.1.0 FreeBSD est connue pour produire du mauvais code avec l’option <code>-O2</code> dans certaines circonstances.</p><div class=paragraph><p>L’optimisation est habituellement activée uniquement lors de la compilation d’une version de production.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-O</span> <span class=nt>-o</span> foobar foobar.c</code></pre></div></div><div class=paragraph><p>Cela va produire une version optimisée de <span class=filename>foobar</span>.</p></div></dd></dl></div><div class=paragraph><p>Les trois prochaines options vont forcer <code>cc</code> à vérifier que votre code est conforme au standard international en cours, se référant souvent à la norme ANSI, qui pour dire précisement est un standard ISO.</p></div><div class=dlist><dl><dt class=hdlist1><code>-Wall</code></dt><dd><p>Active tous les avertissements que les auteurs de <code>cc</code> pensent valoir le coup. Malgré le nom, il n’active pas tous les avertissements dont <code>cc</code> est capable.</p></dd><dt class=hdlist1><code>-ansi</code></dt><dd><p>Désactive la plupart, mais pas toutes, des caractéristiques du C fournies par <code>cc</code> qui sont non-ANSI . Malgré le nom, cela ne garantit pas strictement que votre code sera conforme au standard.</p></dd><dt class=hdlist1><code>-pedantic</code></dt><dd><p>Désactive <em>toutes</em> les caractéristiques de <code>cc</code> qui ne sont pas ANSI .</p></dd></dl></div><div class=paragraph><p>Sans ces options, <code>cc</code> vous permettrait d’utiliser quelques extensions au standard non-standards. Quelques unes de celles-ci sont très utiles, mais ne fonctionneront pas avec d’autres compilateurs -en fait, un des principaux buts du standard est de permettre aux gens d’écrire du code qui fonctionnera avec n’importe quel compilateur sur n’importe quel système. Cela est connu sous le nom de <em>code portable</em>.</p></div><div class=paragraph><p>Generalement, vous devriez essayer de faire votre code aussi portable que possible, sinon vous pourriez avoir a ré-écrire totalement votre programme plus tard pour le faire fonctionner autre part-et qui sait ce que vous utiliserez dans quelques années?</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-Wall</span> <span class=nt>-ansi</span> <span class=nt>-pedantic</span> <span class=nt>-o</span> foobar foobar.c</code></pre></div></div><div class=paragraph><p>Cela produira un exécutable <span class=filename>foobar</span> après avoir vérifié que <span class=filename>foobar.c</span> est conforme au standard.</p></div><div class=dlist><dl><dt class=hdlist1><code>-l <em>librairie</em></code></dt><dd><p>Spécifie une librairie de fonctions à utiliser lors de l’édition des liens.</p><div class=paragraph><p>L’exemple le plus commun de cela est lors de la compilation d’un programme qui utilise quelques fonctions mathématiques en C. A l’inverse de la plupart des plateformes, celles-ci se trouvent dans une librairie standard du C et vous devez dire au compilateur de l’ajouter.</p></div><div class=paragraph><p>La règle est que si une librairie est appelée <span class=filename>libquelque_chose.a</span>, vous donnez à <code>cc</code> l’argument <code>-l <em>quelque_chose</em></code>. Par exemple, la librairie des fonctions mathématiques est <span class=filename>libm.a</span>, aussi vous donnez à <code>cc</code> le paramètre <code>-lm</code>. Un "piège" habituel avec la librairie math est qu’elle doit être la dernière sur la ligne de commande.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c <span class=nt>-lm</span></code></pre></div></div><div class=paragraph><p>Cela va lier les fonctions de la librairie math à l’interieur de <span class=filename>foobar</span>.</p></div><div class=paragraph><p>Si vous compilez du c++; vous devrez ajouter -lg++, ou -lstdc++ si vous utilisez FreeBSD 2.2 ou ultérieur, à la ligne de commande de <code>cc</code> pour lier avec les fonctions de la librairie c++. Alternativement, vous pouvez utiliser c++ plutôt que <code>cc</code>, qui fait tout cela pour vous. c++ peut aussi être invoqué par gcc++ sur FreeBSD.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.cc <span class=nt>-lg</span>++     Pour FreeBSD 2.1.6 et antérieur
% cc <span class=nt>-o</span> foobar foobar.cc <span class=nt>-lstdc</span>++  Pour FreeBSD 2.2 et ultérieur
% c++ <span class=nt>-o</span> foobar foobar.cc</code></pre></div></div><div class=paragraph><p>Chacune de ces commandes va produire un exécutable <span class=filename>foobar</span> à partir du fichier source c++ <span class=filename>foobar.cc</span>. Notez que, sur les systèmes Unix , les fichiers source c++ se terminent traditionnellement en <span class=filename>.C</span>, <span class=filename>.cxx</span> ou <span class=filename>.cc</span>, plutôt que le style MS-DOS <span class=filename>.cpp</span> (qui était déjà utilisé pour autre chose). <code>gcc</code> a utilisé cela pour trouver le type de compilateur à utiliser sur le fichier source; toutefois, cette restriction ne s’applique plus, aussi vous pouvez maintenant appeler vos fichiers c++ <span class=filename>.cpp</span> en toute impunité !</p></div></dd></dl></div><div class=sect3><h4 id=_questions_et_problèmes_usuels_sur_cc>5.4.1. Questions et problèmes usuels sur <code>cc</code><a class=anchor href=#_questions_et_problèmes_usuels_sur_cc></a></h4><div class=sect4><h5 id=_jessaye_décrire_un_programme_qui_utilise_la_fonction_sin_et_je_reçois_lerreur_suivante_que_cela_signifie_t_il>5.4.1.1. J’essaye d’écrire un programme qui utilise la fonction sin() et je reçois l’erreur suivante. Que cela signifie-t-il ?<a class=anchor href=#_jessaye_décrire_un_programme_qui_utilise_la_fonction_sin_et_je_reçois_lerreur_suivante_que_cela_signifie_t_il></a></h5><div class=paragraph><p>Lors de l’utilisation des fonctions mathématiques comme <code>sin()</code>, vous devez dire à <code>cc</code> de lier avec la librairie math, comme :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c <span class=nt>-lm</span></code></pre></div></div></div><div class=sect4><h5 id=_jai_écrit_un_programme_simple_pour_mexercer_à_lutilisation_de_loption_lm_tout_ce_quil_fait_est_délever_21_à_la_puissance_6>5.4.1.2. J’ai écrit un programme simple pour m’exercer à l’utilisation de l’option -lm. Tout ce qu’il fait est d’élever 2,1 à la puissance 6.<a class=anchor href=#_jai_écrit_un_programme_simple_pour_mexercer_à_lutilisation_de_loption_lm_tout_ce_quil_fait_est_délever_21_à_la_puissance_6></a></h5><div class=paragraph><p>Quand le compilateur voit que vous appelez une fonction, il vérifie s’il a déjà un prototype pour celle-ci. S’il ne l’a pas vu, il suppose que la fonction retourne un <span class=type>int</span>, ce qui n’est absolument pas ce que vous voulez ici.</p></div></div><div class=sect4><h5 id=_alors_comment_puis_je_le_réparer>5.4.1.3. Alors comment puis-je le réparer?<a class=anchor href=#_alors_comment_puis_je_le_réparer></a></h5><div class=paragraph><p>Les prototypes des fonctions mathématiques sont dans <span class=filename>math.h</span>. Si vous incluez ce fichier, le compilateur sera capable de trouver le prototype et il arrêtera de faire des trucs étranges à vos calculs!</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main() {
...</pre></div></div><div class=paragraph><p>Après avoir recompilé comme précédemment, exécutez :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./a.out
2.1 ^ 6 <span class=o>=</span> 85.766121</code></pre></div></div><div class=paragraph><p>Si vous utilisez quelques fonctions mathématiques que ce soit, incluez <em>toujours</em> <span class=filename>math.h</span> et n’oubliez pas de lier avec la librairie math.</p></div></div><div class=sect4><h5 id=_jai_compilé_un_fichier_appelé_foobar_c_et_je_ne_trouve_pas_dexécutable_appelé_foobar_où_est_il_parti>5.4.1.4. J’ai compilé un fichier appelé foobar.c et je ne trouve pas d’exécutable appelé foobar. Où est-il parti?<a class=anchor href=#_jai_compilé_un_fichier_appelé_foobar_c_et_je_ne_trouve_pas_dexécutable_appelé_foobar_où_est_il_parti></a></h5><div class=paragraph><p>Souvenez-vous, <code>cc</code> appellera l’exécutable <span class=filename>a.out</span> sauf si vous lui dites de faire autrement. Utilisez l’option <code>-o <em>nomfichier</em></code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c</code></pre></div></div></div><div class=sect4><h5 id=_ok_jai_un_exécutable_appelé_foobar_je_peux_le_voir_en_exécutant_ls_mais_quand_je_tape_foobar_à_linvite_de_commandes_la_réponse_est_quil_ny_a_pas_de_tel_fichier_pourquoi_le_système_ne_le_trouve_pas>5.4.1.5. OK, j’ai un exécutable appelé foobar, je peux le voir en exécutant ls, mais quand je tape foobar à l’invite de commandes, la réponse est qu’il n’y a pas de tel fichier. Pourquoi le système ne le trouve pas?<a class=anchor href=#_ok_jai_un_exécutable_appelé_foobar_je_peux_le_voir_en_exécutant_ls_mais_quand_je_tape_foobar_à_linvite_de_commandes_la_réponse_est_quil_ny_a_pas_de_tel_fichier_pourquoi_le_système_ne_le_trouve_pas></a></h5><div class=paragraph><p>A l’inverse de MS-DOS, Unix ne regarde pas dans le répertoire courant lorsqu’il essaye de trouver un exécutable que vous voulez exécuter, sauf si vous lui avez dit de le faire. Vous pouvez soit taper <code>./foobar</code>, ce qui signifie "exécute le fichier nommé <span class=filename>foobar</span> dans le répertoire courant", soit changer votre variable d’environnement <code>PATH</code> de façon à ce qu’elle ressemble à quelque chose comme</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bin:/usr/bin:/usr/local/bin:.</code></pre></div></div><div class=paragraph><p>Le point à la fin signifie "regarde dans le repertoire courant s’il n’est dans aucun autre".</p></div></div><div class=sect4><h5 id=_jai_appelé_mon_exécutable_test_mais_rien_ne_se_passe_quand_je_lexécute_que_se_passe_t_il>5.4.1.6. J’ai appelé mon exécutable test, mais rien ne se passe quand je l’exécute. Que se passe-t-il?<a class=anchor href=#_jai_appelé_mon_exécutable_test_mais_rien_ne_se_passe_quand_je_lexécute_que_se_passe_t_il></a></h5><div class=paragraph><p>La plupart des systèmes Unix ont un programme appelé <code>test</code> dans <span class=filename>/usr/bin</span> et l’interpréteur prend celui-ci avant de vérifier dans le répertoire courant. Soit vous tapez</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./test</code></pre></div></div><div class=paragraph><p>soit vous choisissez un meilleur nom pour votre programme !!</p></div></div><div class=sect4><h5 id=_jai_compilé_mon_programme_et_il_semble_fonctionner_au_premier_abord_puis_il_y_a_une_erreur_et_le_système_a_dit_quelque_chose_comme_core_dumped_que_cela_signifie_t_il>5.4.1.7. J’ai compilé mon programme et il semble fonctionner au premier abord, puis il y a une erreur et le système a dit quelque chose comme core dumped. Que cela signifie-t-il?<a class=anchor href=#_jai_compilé_mon_programme_et_il_semble_fonctionner_au_premier_abord_puis_il_y_a_une_erreur_et_le_système_a_dit_quelque_chose_comme_core_dumped_que_cela_signifie_t_il></a></h5><div class=paragraph><p>Le nom <em>core dump</em> date des tous premiers jours d’Unix, quand les machines utilisaient la mémoire centralepour stocker les données. Simplement, si le programme a échoué sous certaines conditions, le système va écrire le contenu de la mémoire centrale sur le disque dans un fichier appelé <span class=filename>core</span>, que le programmeur peut ensuite examiner de près pour trouver ce qui s’est mal passé.</p></div></div><div class=sect4><h5 id=_fascinant_mais_que_suis_je_supposé_faire>5.4.1.8. Fascinant, mais que suis-je supposé faire ?<a class=anchor href=#_fascinant_mais_que_suis_je_supposé_faire></a></h5><div class=paragraph><p>Utilisez <code>gdb</code> pour analyser le fichier <span class=filename>core</span> (voir <a href=#debugging>Déverminer</a>).</p></div></div><div class=sect4><h5 id=_quand_mon_programme_a_généré_un_fichier_core_il_a_parlé_dune_erreur_segmentation_fault_quest_ce_que_cest>5.4.1.9. Quand mon programme a généré un fichier core, il a parlé d’une erreur segmentation fault. Qu’est-ce que c’est ?<a class=anchor href=#_quand_mon_programme_a_généré_un_fichier_core_il_a_parlé_dune_erreur_segmentation_fault_quest_ce_que_cest></a></h5><div class=paragraph><p>Cela signifie simplement que votre programme a essayé d’effectuer une opération illégale sur la mémoire; Unix est conçu pour protéger le système d’exploitation et les autres programmes des programmes crapuleux.</p></div><div class=paragraph><p>Les causes habituelles de cela sont :</p></div><div class=ulist><ul><li><p>Essayer d’écrire dans un pointeur NULL, par exemple</p><div class="literalblock programlisting"><div class=content><pre>char *foo = NULL;
strcpy(foo, &#34;bang!&#34;);</pre></div></div></li><li><p>Utiliser un pointeur qui n’a pas été initialisé, par exemple</p><div class="literalblock programlisting"><div class=content><pre>char *foo;
strcpy(foo, &#34;bang!&#34;);</pre></div></div><div class=paragraph><p>Le pointeur va avoir une valeur aléatoire qui avec de la chance, pointera dans une zone de la mémoire qui n’est pas disponible pour votre programme et le noyau va tuer votre programme avant qu’il ne fasse des dommages. Si vous êtes malchanceux, il pointera quelque part dans votre propre programme et altèrera une de vos structures de données, faisant planter votre programme mystérieusement.</p></div></li><li><p>Essayer d’accèder la mémoire au-delà de la fin d’un tableau, par exemple</p><div class="literalblock programlisting"><div class=content><pre>int bar[20];
bar[27] = 6;</pre></div></div></li><li><p>Essayer de stocker quelque chose dans la mémoire en lecture seule, par exemple</p><div class="literalblock programlisting"><div class=content><pre>char *foo = &#34;Ma chaine&#34;;
strcpy(foo, &#34;bang!&#34;);</pre></div></div><div class=paragraph><p>Les compilateurs Unix mettent souvent les chaînes comme <code>"Ma chaine"</code> dans des zones de mémoire en lecture seule.</p></div></li><li><p>Faire des trucs sales avec <code>malloc()</code> et <code>free()</code>, par exemple</p><div class="literalblock programlisting"><div class=content><pre>char bar[80];
free(bar);</pre></div></div><div class=paragraph><p>ou</p></div><div class="literalblock programlisting"><div class=content><pre>char *foo = malloc(27);
free(foo);
free(foo);</pre></div></div></li></ul></div><div class=paragraph><p>Faire une de ces fautes ne conduit pas toujours à une erreur, mais elles sont toujours de mauvais entrainements. Certains systèmes et compilateurs sont plus tolérants que d’autres, ce qui explique pourquoi des programmes qui fonctionnent bien sur un système peuvent planter si vous les essayer sur un autre.</p></div></div><div class=sect4><h5 id=_des_fois_quand_je_reçoit_une_erreur_core_dump_il_est_précisé_bus_error_il_est_dit_dans_mon_livre_unix_quil_sagit_dun_problème_matériel_mais_lordinateur_semble_toujours_fonctionner_est_ce_vrai>5.4.1.10. Des fois quand je reçoit une erreur core dump, il est précisé bus error. Il est dit dans mon livre Unix qu’il s’agit d’un problème matériel mais l’ordinateur semble toujours fonctionner. Est-ce vrai ?<a class=anchor href=#_des_fois_quand_je_reçoit_une_erreur_core_dump_il_est_précisé_bus_error_il_est_dit_dans_mon_livre_unix_quil_sagit_dun_problème_matériel_mais_lordinateur_semble_toujours_fonctionner_est_ce_vrai></a></h5><div class=paragraph><p>Non, heureusement non (sauf si bien sûr vous avez réellement un problème matériel…​). Cela est habituellement une manière de dire que vous avez accédé à la mémoire d’une façon que vous n’auriez pas dû.</p></div></div><div class=sect4><h5 id=_toute_cette_affaire_de_fichier_core_semble_être_assez_utile_si_je_peux_le_faire_apparaître_quand_je_le_désire_puis_je_faire_cela_ou_dois_je_attendre_la_prochaine_erreur>5.4.1.11. Toute cette affaire de fichier core semble être assez utile, si je peux le faire apparaître quand je le désire. Puis-je faire cela, ou dois-je attendre la prochaine erreur ?<a class=anchor href=#_toute_cette_affaire_de_fichier_core_semble_être_assez_utile_si_je_peux_le_faire_apparaître_quand_je_le_désire_puis_je_faire_cela_ou_dois_je_attendre_la_prochaine_erreur></a></h5><div class=paragraph><p>Oui, ouvrez une autre console ou xterm, faites</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps</code></pre></div></div><div class=paragraph><p>pour trouver l’identifiant du processus de votre programme, et faites</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>kill</span> <span class=nt>-ABRT</span> identifiant</code></pre></div></div><div class=paragraph><p>où <span class=parameter><em>identifiant</em></span> est l’identifiant du processus que vous avez trouvé.</p></div><div class=paragraph><p>Ceci est utile si votre programme est bloqué dans une boucle infinie, par exemple. Si votre programme arrive à bloquer le signal SIGABRT, il y a d’autres signaux qui ont des effets similaires.</p></div><div class=paragraph><p>Alternativement, vous pouvez créer un fichier <span class=filename>core</span> depuis votre programme, en appelant la fonction <code>abort()</code>. Voir la page de manuel en ligne de <a href="https://man.freebsd.org/cgi/man.cgi?query=abort&amp;sektion=3&amp;format=html">abort(3)</a> pour en savoir plus.</p></div><div class=paragraph><p>Si vous voulez créer un fichier <span class=filename>core</span> depuis l’extérieur de votre programme, mais ne voulez pas que le processus s’arrêt,vous pouvez utiliser le programme <code>gcore</code>. Voir la page de manuel en ligne de <a href="https://man.freebsd.org/cgi/man.cgi?query=gcore&amp;sektion=1&amp;format=html">gcore(1)</a> pour plus d’informations.</p></div></div></div></div><div class=sect2><h3 id=_make>5.5. Make<a class=anchor href=#_make></a></h3><div class=sect3><h4 id=_quest_ce_que_make>5.5.1. Qu’est-ce que <code>make</code>?<a class=anchor href=#_quest_ce_que_make></a></h4><div class=paragraph><p>Quand vous travaillez sur un programme simple avec seulement un ou deux fichiers source, taper</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc fichier1.c fichier2.c</code></pre></div></div><div class=paragraph><p>n’est pas si mal, mais cela devient rapidement fastidieux quand il y a plusieurs fichiers-et cela peut prendre du temps à compiler aussi.</p></div><div class=paragraph><p>Une façon de contourner cela est d’utiliser les fichiers objet et de recompiler le fichier source seulement si le code source a changé. Aussi, nous pourrions avoir quelque chose comme ça:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc fichier1.o fichier2.o … fichier37.c …</code></pre></div></div><div class=paragraph><p>si nous avions changé le fichier <span class=filename>fichier37.c</span> mais aucun des autres depuis la dernère compilation. Cela pourrait accélerer assez bien la compilation mais cela ne resoud pas le problème de la frappe au clavier.</p></div><div class=paragraph><p>Ou nous pourrions écrire une procédure pour résoudre ce problème de frappe, mais celle-ci devrait tout re-compiler, devenant ainsi inefficace sur un gros projet.</p></div><div class=paragraph><p>Que se passe-t-il si nous avons des centaines de fichiers source ? Que se passe-t-il si nous travaillons dans une équipe avec d’autres personnes qui oublient de nous dire quand ils ont changé un de leurs fichiers source que nous utilisons ?</p></div><div class=paragraph><p>Peut-être pourrions nous mettre ensemble les deux solutions et écrire quelque chose comme une procédure qui contiendrait quelque règle magique disant quand notre fichier source doit être compilé. Maintenant, tout ce dont nous avons besoin est un programme qui comprend ces règles, alors que c’est trop compliqué pour l’interpréteur.</p></div><div class=paragraph><p>Ce programme s’appelle <code>make</code>. Il lit dans un fichier, appelé un <em>makefile</em>, qui lui dit comment les différents fichiers dépendent les uns des autres, et détermine quels fichiers ont besoin d’être recompilés et quels n’en ont pas besoin. Par exemple, une règle pourrait dire quelque chose comme "si <span class=filename>fromboz.o</span> est plus ancien que <span class=filename>fromboz.c</span>, cela signifie que quelqu’un a dû changer <span class=filename>fromboz.c</span>, aussi il a besoin d’être recompilé." Le makefile possède aussi des règles pour dire à <code>make</code> <em>comment</em> re-compiler un fichier source, en faisant ainsi un outil encore plus puissant.</p></div><div class=paragraph><p>Les <span class=filename>Makefile</span>s sont typiquement stockés dans le même répertoire que le source auxquels il s’appliquent, et peuvent être appelés <span class=filename>makefile</span>, <span class=filename>Makefile</span> ou <span class=filename>MAKEFILE</span>. La plupart des programmeurs utilise le nom <span class=filename>Makefile</span>, celui-ci se trouvant proche du début de la liste du contenu du répertoire où il peut être facilement vu.</p></div></div><div class=sect3><h4 id=_exemple_dutilisation_de_make>5.5.2. Exemple d’utilisation de <code>make</code><a class=anchor href=#_exemple_dutilisation_de_make></a></h4><div class=paragraph><p>Voici un exemple très simple de <span class=filename>Makefile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c
	cc -o foo foo.c</pre></div></div><div class=paragraph><p>Il consiste en deux lignes, une ligne de dépendance et une ligne de création.</p></div><div class=paragraph><p>La ligne de dépendance ici consiste en le nom du programme (connu comme <em>cible</em>), suivi de deux-points puis un espace et enfin le nom du fichier source. Quand <code>make</code> lit cette ligne, il vérifie si <span class=filename>foo</span> existe; s’il existe, il compare la date à laquelle <span class=filename>foo</span> a été modifié la dernière fois avec la date de dernière modification de <span class=filename>foo.c</span>. Si <span class=filename>foo</span> n’existe pas ou est plus ancien que <span class=filename>foo.c</span>, il regarde la ligne de création pour trouver ce qu’il doit faire. En d’autres termes, il s’agit de la règle à utiliser quand <span class=filename>foo.c</span> a besoin d’être re-compilé.</p></div><div class=paragraph><p>La ligne de création commence avec un tab (appuyez sur la touche <kbd>tab</kbd>) suivi de la commande que vous taperiez pour créer <span class=filename>foo</span> si vous deviez le faire à l’invite de commandes. Si <span class=filename>foo</span> n’est pas à jour ou n’existe pas, <code>make</code> exécute alors cette commande pour le créer. En d’autres termes, il s’agit de la règle permettant à make de re-compiler <span class=filename>foo.c</span>.</p></div><div class=paragraph><p>Aussi, quand vous tapez <code>make</code>, il vérifiera que <span class=filename>foo</span> est à jour en respect de vos derniers changements sur <span class=filename>foo.c</span>. Ce principe peut être étendu à des <span class=filename>Makefile</span>s de plusieurs centaines de cibles-en fait, sur FreeBSD, il est possible de compiler un système d’exploitation entier en tapant juste <code>make world</code> dans le répertoire approprié !</p></div><div class=paragraph><p>Une autre propriété utile des makefiles est que les cibles n’ont pas nécessairement besoin d’être des programmes. Par exemple, nous pourrions avoir un <span class=filename>Makefile</span> qui ressemble à cela:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c
	cc -o foo foo.c

install:
	cp foo /home/moi</pre></div></div><div class=paragraph><p>Nous pouvons dire à <code>make</code> quelle cible nous voulons en tapant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% make cible</code></pre></div></div><div class=paragraph><p><code>make</code> ira seulement voir cette cible et ingorera les autres. Par exemple, si nous tapons <code>make foo</code> avec le <span class=filename>Makefile</span> du dessus, <code>make</code> ignorera la cible install.</p></div><div class=paragraph><p>Si nous tapons juste <code>make</code>, <code>make</code> regardera toujours la première cible et s’arrêtera sans regarder aucune autre. Aussi, si nous avions tapé <code>make</code> seul, <code>make</code> serait juste allé à la cible foo, aurait recompilé <span class=filename>foo</span> si nécessaire et se serait arrêté sans aller à la cible install.</p></div><div class=paragraph><p>Notez que la cible install ne dépend pour l’instant de rien ! Cela signifie que la commande qui suit est toujours exécutée lorsque nous essayons de créer cette cible en tapant <code>make install</code>. Dans ce cas, <code>make</code> va copier <span class=filename>foo</span> dans le répertoire de l’utilisateur. Cela est souvent utilisé par les <span class=filename>Makefile</span>s des applications, ainsi l’application peut être installée dans le répertoire correct quand elle a été correctement compilée</p></div><div class=paragraph><p>Il s’agit d’un sujet légèrement embrouillant à essayer et expliquer. Si vous ne comprenez pas bien comment <code>make</code> fonctionne, la meilleure chose à faire est d’écrire un petit programme comme "bonjour monde" et un fichier <span class=filename>Makefile</span> comme le précédent et de le tester. Ensuite continuez en utilisant plus d’un fichier source ou en ayant un fichier source incluant un fichier d’en-tête. La commande <code>touch</code> est très utile ici-elle change la date sur un fichier sans avoir à l’éditer.</p></div></div><div class=sect3><h4 id=_les_makefiles_de_freebsd>5.5.3. Les <span class=filename>Makefiles</span> de FreeBSD<a class=anchor href=#_les_makefiles_de_freebsd></a></h4><div class=paragraph><p>Les <span class=filename>Makefile</span>s peuvent être plutôt compliqués à écrire. Heureusement, les systèmes BSD comme FreeBSD sont fournis avec des fichiers très puissants comme partie intégrante du système. Un très bon exemple est le système des logiciels portés. Voici la partie essentielle d’un <span class=filename>Makefile</span> typique des logiciels portés:</p></div><div class="literalblock programlisting"><div class=content><pre>MASTER_SITES=   ftp://freefall.cdrom.com/pub/FreeBSD/LOCAL_PORTS/
DISTFILES=      scheme-microcode+dist-7.3-freebsd.tgz

.include &lt;bsd.port.mk&gt;</pre></div></div><div class=paragraph><p>Maintenant, si nous allons dans le répertoire de ce logiciel porté et tapons <code>make</code>, la chose suivante se passe :</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Une vérification est faite pour voir si le code source de ce logiciel porté est déjà dans le système.</p></li><li><p>Si celui-ci n’y est pas, une connexion FTP à l’URL dans MASTER_SITES est faite pour télécharger le source.</p></li><li><p>La somme de contrôle (<code>checksum</code>) du source est calculée et comparée avec celle d’une bonne et connue copie du source. Cela est fait pour être sûr que le source n’a pas été corrompu pendant le transfert.</p></li><li><p>Tout changement requis pour faire fonctionner le source sur FreeBSD est appliqué- cela est connu sous le nom de <em>correctif</em>.</p></li><li><p>Toute configuration spéciale nécessaire pour le source est faite. (Beaucoup de distributions de programmes Unix essaye de fonctionner quelle que soit la version d’Unix sur laquelle elles sont compilées et quelles que soient les caractéristiques optionnelles qui sont présentes-c’est ce qui se trouve dans le scénario des logiciels portés pour FreeBSD).</p></li><li><p>Le code source pour ce programme est compilé. En effet, nous changeons de répertoire pour le répertoire où le source a été décompressé et faisons <code>make</code>-le fichier <span class=filename>Makefile</span> du programme contient les informations nécessaires pour construire le programme.</p></li><li><p>Nous avons maintenant une version compilée du programme. Si nous le désirons, nous pouvons le tester maintenant; quand nous sommes confiant dans le programme, nous pouvons taper <code>make install</code>. Cela va installer le programme et ses fichiers de soutien nécessaires au bon endroit; une entrée est aussi créée dans la <code>base de données des logiciels pré-compilés</code>, ainsi le logiciel porté peut être facilement désinstallé plus tard si nous changeons d’avis sur ce programme.</p></li></ol></div></div></div><div class=paragraph><p>Maintenant je pense que vous serez d’accord que c’est plus impressionnant qu’une procédure de quatre lignes !</p></div><div class=paragraph><p>Le secret réside dans la dernière ligne qui dit à <code>make</code> de regarder dans le <span class=filename>Makefile</span> système appelé <span class=filename>bsd.port.mk</span>. Il est facile de fermer les yeux sur cette ligne mais c’est ici que tous les trucs forts se passent-quelqu’un a écrit un <span class=filename>Makefile</span> qui dit à <code>make</code> de faire tout ce qu’il y a au-dessus (plus un couple d’autres choses que je n’ai pas mentionnées, comme la gestion des erreurs) et n’importe qui peut avoir accès à cela simplement est ajoutant une simple ligne dans son propre fichier <span class=filename>Makefile</span> !</p></div><div class=paragraph><p>Si vous voulez jeter un regard sur ces <span class=filename>Makefile</span>s système, ils se trouvent <span class=filename>/usr/shared/mk</span> mais il est probablement mieux d’attendre un moment jusqu’à ce que vous ayez un peu d’entrainement avec les <span class=filename>Makefile</span>s car ceux-ci sont très compliqués (et si vous les lisez, soyez sûr d’avoir un thermos de café fort à portée de main !)</p></div></div><div class=sect3><h4 id=_utilisations_plus_avancées_de_make>5.5.4. Utilisations plus avancées de <code>make</code><a class=anchor href=#_utilisations_plus_avancées_de_make></a></h4><div class=paragraph><p><code>Make</code> est un outil très puissant et peut faire beaucoup plus que le simple exemple précédent ne l’a montré. Malheureusement, il y a différentes versions de <code>make</code> et elles diffèrent considérablement. Le meilleur moyen d’apprendre ce qu’elles peuvent faire est probablement de lire la documentation-heureusement cette introduction vous donnera la base à partir de laquelle vous pourrez faire cela.</p></div><div class=paragraph><p>La version de <code>make</code> fournies avec FreeBSD est le Berkeley make(make de Berkeley); il y a un cours d’instruction pour celui-ci dans <span class=filename>/usr/shared/doc/psd/12.make</span>. Pour le voir, faites</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zmore paper.ascii.gz</code></pre></div></div><div class=paragraph><p>dans ce répertoire.</p></div><div class=paragraph><p>Beaucoup d’applications dans les logiciels portés utilisent GNU make, qui possède un très bon ensemble de page d'"info". Si vous avez installé un de ces logiciels portés, GNU make aura été automatiquement installé sous le nom de <code>gmake</code>. Il est aussi disponible comme logiciel porté ou logiciel pré-compilé seul.</p></div><div class=paragraph><p>Pour voir les pages d’info pour GNU make, vous devrez editer le fichier <span class=filename>dir</span> dans le répertoire <span class=filename>/usr/local/info</span> pour ajouter une entrée pour celui-ci. Cela implique d’ajouter une ligne</p></div><div class="literalblock programlisting"><div class=content><pre> * Make: (make).                 l&#39;utilitaire GNU Make.</pre></div></div><div class=paragraph><p>au fichier. Une fois que vous avez fait ceci, vous pouvez taper <code>info</code> et ensuite sélectionner <span class=guimenuitem>make</span> dans le menu (ou dans Emacs, faites <code>C-h i</code>).</p></div></div></div><div class=sect2><h3 id=debugging>5.6. Déverminer<a class=anchor href=#debugging></a></h3><div class=sect3><h4 id=_le_dévermineur>5.6.1. Le dévermineur<a class=anchor href=#_le_dévermineur></a></h4><div class=paragraph><p>Le dévermineur fourni avec FreeBSD est appelé <code>gdb</code> (GNU debugger). Vous pouvez le démarrer en tapant</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb nomprog</code></pre></div></div><div class=paragraph><p>bien que la plupart des gens préfèrent le démarrer au sein d’Emacs. Vous pouvez faire cela avec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> M-x gdb RET nomprog RET</code></pre></div></div><div class=paragraph><p>Utiliser un dévermineur vous permet d’exécuter le programme dans des circonstances plus contrôlées. Typiquement, vous pouvez exécuter le programme ligne à ligne, inspecter la valeur des variables, changer cette dernière, dire au dévermineur d’exécuter jusqu’à un certain point puis de s’arrêter etc…​ Vous pouvez même vous brancher sur un programme en fonctionnement, ou charger un fichier <span class=filename>core</span> pour enquêter sur le plantage du programme. Il est même possible de déverminer le noyau, quoique ce soit un peu plus rusé que de déverminer des applications utilisateur dont nous discuterons dans cette section.</p></div><div class=paragraph><p><code>gdb</code> dispose d’une assez bonne aide en ligne comme d’un ensemble de pages d’info, aussi cette section va se concentrer sur quelques commandes basiques.</p></div><div class=paragraph><p>Finalement, si vous trouvez son interface texte non fonctionnelle, il y a une interface graphique pour celui-ci, <a href=../../ports/devel.html>xxgdb</a>, dans la collection des logiciels portés.</p></div><div class=paragraph><p>Cette section a pour but d’être une introduction à l’utilisation de <code>gdb</code> et ne couvre pas les sujets très spécialisés comme le déverminage du noyau.</p></div></div><div class=sect3><h4 id=_exécuter_un_programme_dans_le_dévermineur>5.6.2. Exécuter un programme dans le dévermineur<a class=anchor href=#_exécuter_un_programme_dans_le_dévermineur></a></h4><div class=paragraph><p>Vous devrez avoir compilé le programme avec l’option <code>-g</code> pour avoir la meilleure utilisation de <code>gdb</code>. Il fonctionnera sans mais vous ne verrez que le nom de la fonction dans laquelle vous vous trouvez plutôt que son code source. Si vous voyez une ligne comme:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>... <span class=o>(</span>no debugging symbols found<span class=o>)</span> ...</code></pre></div></div><div class=paragraph><p>quand <code>gdb</code> démarre, vous saurez que le programme n’a pas été compilé avec l’option <code>-g</code>.</p></div><div class=paragraph><p>A l’invite de <code>gdb</code>, tapez <code>break main</code>. Cela dira au dévermineur de passer le code préliminaire d’initialisation du programme et de démarrer au début de votre code. Maintenant tapez <code>run</code> pour démarrer le programme-cela va démarrer au début du code d’initialisation et ensuite s’arrêtera lors de l’appel à <code>main()</code>. (Si vous vous êtes toujours demandé où <code>main()</code> était appelé, maintenant vous le savez !).</p></div><div class=paragraph><p>Vous pouvez maintenant vous déplacer dans le programme ligne par ligne en pressant <code>n</code>. Si vous arrivez à l’appel d’une fonction, vous pouvez entrer dans celle-ci en appuyant sur <code>s</code>. Une fois que vous êtes dans l’appel de la fonction, vous pouvez retourner dans le code appelant en appuyant sur <code>f</code>. Vous pouvez aussi utiliser <code>up</code> et <code>down</code> pour avoir une vue rapide de l’appelant.</p></div><div class=paragraph><p>Voici un exemple simple de comment détecter une erreur dans un programme avec <code>gdb</code>. Voici notre programme (avec une erreur délibérée):</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;

int bazz(int anint);

main() {
	int i;

	printf(&#34;C&#39;est mon programme\n&#34;);
	bazz(i);
	return 0;
}

int bazz(int anint) {
	printf(&#34;Vous m&#39;avez fourni %d\n&#34;, anint);
	return anint;
}</pre></div></div><div class=paragraph><p>Le programme met i à <code>5</code> et le passe à une fonction <code>bazz()</code> qui imprime le nombre que nous lui avons donné.</p></div><div class=paragraph><p>Puis nous compilons et exécutons le programme obtenu</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-g</span> <span class=nt>-o</span> temp temp.c
% ./temp
C<span class=s1>&#39;est mon programme
Vous m&#39;</span>avez fourni 4231</code></pre></div></div><div class=paragraph><p>Ce n’était pas ce que nous attendions ! Il est temps de voir ce qui se passe !</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb temp
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.13 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>, Copyright 1994 Free Software Foundation, Inc.
<span class=o>(</span>gdb<span class=o>)</span> <span class=nb>break </span>main				passe le code d<span class=s1>&#39;initialisation
Breakpoint 1 at 0x160f: file temp.c, line 9.	gdb met un point d&#39;</span>arrêt sur main<span class=o>()</span>
<span class=o>(</span>gdb<span class=o>)</span> run					Exécute jusqu<span class=s1>&#39;à main()
Starting program: /home/james/tmp/temp		Le programme démarre

Breakpoint 1, main () at temp.c:9		gdb s&#39;</span>arrête à main<span class=o>()</span>
<span class=o>(</span>gdb<span class=o>)</span> n						Va à la ligne suivante
C<span class=s1>&#39;est mon programme				Le programme écrit
(gdb) s						entre dans bazz()
bazz (anint=4231) at temp.c:17			gdb montre la pile
(gdb)</span></code></pre></div></div><div class=paragraph><p>Arrêtons-nous une minute! Comment anint a eu la valeur <code>4231</code>? Ne l’avons-nous pas mis à <code>5</code> dans <code>main()</code>? Remontons dans <code>main()</code> et regardons.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> up					Remonte la pile des appels
<span class=c>#1  0x1625 in main () at temp.c:11		gdb montre la pile</span>
<span class=o>(</span>gdb<span class=o>)</span> p i					Montre la valeur de i
<span class=nv>$1</span> <span class=o>=</span> 4231					gdb montre 4231</code></pre></div></div><div class=paragraph><p>Oh ! En regardant dans le code, nous avons oublié d’initialiser i. Nous aurions dû mettre</p></div><div class="literalblock programlisting"><div class=content><pre>...
main() {
	int i;

	i = 5;
	printf(&#34;C&#39;est mon programme\n&#34;);
...</pre></div></div><div class=paragraph><p>mais nous n’avions pas mis la ligne <code>i=5;</code>. Comme nous n’avons pas initialisé i, il a pris le nombre se trouvant dans la zone de mémoire quand le programme a démarré, ce qui dans ce cas était <code>4231</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>gdb</code> montre la pile chaque fois que nous entrons ou sortons d’une fonction, même si nous avons utilisé <code>up</code> et <code>down</code> pour nous déplacer dans la pile des appels. Cela montre le nom de la fonction et les valeurs de ses arguments, ce qui nous aide à garder une trace d’où nous sommes et de ce qui se passe. (La pile est une zone de stockage où le programme stocke les informations sur les arguments passés aux fonctions et où il doit aller quand il revient d’une fonction).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_examiner_un_fichier_core>5.6.3. Examiner un fichier <span class=filename>core</span><a class=anchor href=#_examiner_un_fichier_core></a></h4><div class=paragraph><p>Un fichier <span class=filename>core</span> est basiquement un fichier qui contient l’état complet du processus quand il s’est planté. Dans "le bon vieux temps", les programmeurs devait imprimer des listings en hexadécimal de fichiers <span class=filename>core</span> et transpirer sur leur manuels de code machine, mais la vie est maintenant un peu plus facile. Par chance, sous FreeBSD et les autres systèmes 4.4BSD, un fichier <span class=filename>core</span> est appelé <span class=filename>nomprog.core</span> plutôt que juste <span class=filename>core</span>, pour mieux savoir à quel programme appartient un fichier <span class=filename>core</span>.</p></div><div class=paragraph><p>Pour examiner un fichier <span class=filename>core</span>, démarrez <code>gdb</code> de façon habituel. Plutôt que de taper <code>break</code> ou <code>run</code>, tapez</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> core nomprog.core</code></pre></div></div><div class=paragraph><p>Si vous n’êtes pas dans le même répertoire que le fichier <span class=filename>core</span>, vous devrez faire <code>dir /path/to/core/file</code> d’abord.</p></div><div class=paragraph><p>Vous devriez voir quelque chose comme cela:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb a.out
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.13 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>, Copyright 1994 Free Software Foundation, Inc.
<span class=o>(</span>gdb<span class=o>)</span> core a.out.core
Core was generated by <span class=sb>`</span>a.out<span class=s1>&#39;.
Program terminated with signal 11, Segmentation fault.
Cannot access memory at address 0x7020796d.
#0  0x164a in bazz (anint=0x5) at temp.c:17
(gdb)</span></code></pre></div></div><div class=paragraph><p>Dans ce cas, le programme a été appelé <span class=filename>a.out</span>, aussi le fichier <span class=filename>core</span> s’appelle <span class=filename>a.out.core</span>. Nous pouvons voir que le programme s’est planté car il a essayé d’accèder à une zone dans la mémoire qui n’était pas disponible dans la fonction appelée <code>bazz</code>.</p></div><div class=paragraph><p>Quelquefois il est utile de pouvoir voir comment une fonction a été appelée car le problème peut avoir eu lieu bien avant dans la pile des appels dans un programme complexe. La commande <code>bt</code> demande à <code>gdb</code> d’afficher une trace inverse de la pile des appels:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> bt
<span class=c>#0  0x164a in bazz (anint=0x5) at temp.c:17</span>
<span class=c>#1  0xefbfd888 in end ()</span>
<span class=c>#2  0x162c in main () at temp.c:11</span>
<span class=o>(</span>gdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>La fonction <code>end()</code> est appelée lorsque le programme se plante; dans ce cas, la fonction <code>bazz()</code> a été appelée <code>main()</code>.</p></div></div><div class=sect3><h4 id=_se_brancher_sur_un_programme_en_cours_dexécution>5.6.4. Se brancher sur un programme en cours d’exécution<a class=anchor href=#_se_brancher_sur_un_programme_en_cours_dexécution></a></h4><div class=paragraph><p>Une des plus belles caractéristiques de <code>gdb</code> est qu’il peut se brancher sur un programme qui s’exécute déjà. Bien sûr, cela suppose que vous ayez les privilèges suffisants pour le faire. Un problème habituel est quand vous vous déplacez dans un programme qui se dédouble et que vous voulez tracer le programme fils cependant le dévermineur ne vous laissera seulement tracer le père.</p></div><div class=paragraph><p>Ce que vous devez faire est de démarrer un autre <code>gdb</code>, utiliser <code>ps</code> pour trouver l’ID du processus fils et faire</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> attach identifiant_processus</code></pre></div></div><div class=paragraph><p>dans <code>gdb</code>, et déverminer ensuite comme d’habitude.</p></div><div class=paragraph><p>"C’est tout simple," pensez-vous certainement," mais pendant le temps que je faisais ça, le processus fils sera déjà parti loin". Ne vous en faites pas, noble lecteur, voici comment faire (avec l’appui des pages d’info de <code>gdb</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>…
<span class=k>if</span> <span class=o>((</span>pid <span class=o>=</span> fork<span class=o>())</span> &lt; 0<span class=o>)</span>		/<span class=k>*</span> _Toujours_ verifier cela <span class=k>*</span>/
	error<span class=o>()</span><span class=p>;</span>
<span class=k>else if</span> <span class=o>(</span>pid <span class=o>==</span> 0<span class=o>)</span> <span class=o>{</span>		/<span class=k>*</span> le fils <span class=k>*</span>/
	int PauseMode <span class=o>=</span> 1<span class=p>;</span>

	<span class=k>while</span> <span class=o>(</span>PauseMode<span class=o>)</span>
		<span class=nb>sleep</span><span class=o>(</span>10<span class=o>)</span><span class=p>;</span>	/<span class=k>*</span> Attendre jusqu<span class=s1>&#39;a ce que quelqu&#39;</span>un se brache sur nous <span class=k>*</span>/
	…
<span class=o>}</span> <span class=k>else</span> <span class=o>{</span>			/<span class=k>*</span> le pere <span class=k>*</span>/
	…</code></pre></div></div><div class=paragraph><p>Maintenant tout ce que nous avons à faire est de nous brancher sur le processus fils, de mettre PauseMode à <code>0</code> et d’attendre que l’appel à la fonction <code>sleep()</code> retourne !</p></div></div></div><div class=sect2><h3 id=emacs>5.7. Utiliser Emacs comme environnement de développement<a class=anchor href=#emacs></a></h3><div class=sect3><h4 id=_emacs>5.7.1. Emacs<a class=anchor href=#_emacs></a></h4><div class=paragraph><p>Malheureusement, les systèmes Unix ne sont pas fournis avec des sortes d’environnements de développement intégrés tout-ce-que-vous-avez-toujours-voulu-et-beaucoup-plus-dans-un-ensemble-gigantesque que d’autres sytèmes ont. Toutefois, il est possible de se faire son propre environnement. Cela n’est pas forcément aussi joli et il peut ne pas être autant intégré mais vous pouvez le personnaliser comme vous voulez. Et c’est gratuit. Et vous en avez les sources.</p></div><div class=paragraph><p>La clé de tout cela est Emacs. Maintenant il y a des gens qui le détestent, mais beaucoup l’aiment. Si vous êtes un du premier groupe, j’ai peur que cette section ait peu d’intérêt pour vous. Vous aurez besoin d’une quantité moyenne de mémoire pour le faire fonctionner-Je recommenderai 8Mo en mode texte et 16Mo dans X pour avoir un minimum de performances.</p></div><div class=paragraph><p>Emacs est basiquement un éditeur hautement personnalisable -en effet, il a été personnalisé au point de ressembler plus à un système d’exploitation qu’à un éditeur! Beaucoup de développeurs et d’administrateurs système passent en fait pratiquement tout leur temps à travailler dans Emacs, en ne le quittant qu’à leur déconnexion.</p></div><div class=paragraph><p>Il est impossible de dire tout ce qu’Emacs peut faire ici, mais voici quelques unes des caractéristiques d’intérêt pour les développeurs:</p></div><div class=ulist><ul><li><p>Un très puissant éditeur, permettant le chercher-remplacer sur les chaînes et les expressions régulières (motifs), sauter à la fin ou au début d’un bloc, etc, etc.</p></li><li><p>Menus déroulants et aide en ligne.</p></li><li><p>Colorisation syntaxique en fonction du langage et indentation.</p></li><li><p>Totalement personnalisable.</p></li><li><p>Vous pouvez compiler et déverminer des programmes dans Emacs.</p></li><li><p>Sur erreur de compilation, vous pouvez aller directement à la ligne de code source fautive.</p></li><li><p>Une interface amicale au programme <code>info</code> utilisé pour lire la documentation hypertexte GNU, incluant la documentation sur Emacs elle-même.</p></li><li><p>Une interface agréable à <code>gdb</code>, vous permettant de voir le code source au fur et à mesure que vous vous déplacez dans votre programme.</p></li><li><p>Vous pouvez lire les nouvelles Usenet et envoyer des e-mails pendant que votre programme est en compilation.</p></li></ul></div><div class=paragraph><p>Et sans doute beaucoup plus que je n’ai survolé.</p></div><div class=paragraph><p>Emacs peut être installé sur FreeBSD en utilisant Emacs <a href=../../ports/editors.html>le logiciel porté Emacs</a>.</p></div><div class=paragraph><p>Une fois installé, démarrez-le et faites <code>C-h t</code> pour lire un cours sur Emacs-cela signifie maintenir la touche <kbd>control</kbd>, presser <kbd>h</kbd>, relâcher la touche <kbd>control</kbd> et presser <kbd>t</kbd>. (Alternativement, vous pouvez utiliser la souris pour sélectionner <span class=guimenuitem>Emacs Tutorial</span> dans le menu <b class=menuref>Help</b>).</p></div><div class=paragraph><p>Bien que Emacs possède des menus, il est valable d’apprendre les raccourcis clavier, étant plus rapide quand vous éditez quelque chose d’appuyer sur un couple de touches que de reprendre la souris et de cliquer au bon endroit. Et, quand vous discutez avec des utilisateurs expérimentés d’Emacs, vous trouverez qu’ils parlent souvent de choses comme “M-x replace-s RET foo RET bar RET” aussi il est utile de savoir ce que cela veut dire. Et dans tous les cas, Emacs possède beaucoup trop de fonctions pour qu’elles soient dans les barres de menus.</p></div><div class=paragraph><p>Heureusement, il est assez simple de récupérer les raccourcis clavier car ils sont affichés à côté des éléments des menus déroulants. Mon conseil est d’utiliser un élément de menu pour, disons, ouvrir un fichier jusqu’à ce que vous sachiez comment cela fonctionne et que quand vous vous sentez à l’aise avec, essayez <code>C-x C-f</code>. Quand vous serez content avec ça, passez à une autre commande du menu.</p></div><div class=paragraph><p>Si vous ne pouvez pas vous rappeler de ce qu’une combinaison de touches particulières fait, sélectionnez <span class=guimenuitem>Describe Key</span> dans le menu <b class=menuref>Help</b> et tapez-la-Emacs vous dira ce qu’elle fait. Vous pouvez aussi utiliser l’élément de menu <span class=guimenuitem>Command Apropos</span> pour trouver toutes les commandes qui contiennent un mot particulier, avec leur raccourci clavier.</p></div><div class=paragraph><p>De cette manière, l’expression ci-dessus signifie maintenir la touche <kbd>Meta</kbd>, taper <kbd>x</kbd>, relâcher la touche <kbd>Meta</kbd>, taper <code>replace-s</code> (raccourci pour <code>replace-string</code>- une autre caractéristique d’Emacs est que vous pouvez abréger les commandes), appuyer sur la touche <kbd>Entrée</kbd>, taper <code>foo</code> (la chaîne que vous voulez remplacer), presser la touche <kbd>Entrée</kbd>, taper <code>bar</code> (la chaîne que vous voulez substituer à <code>foo</code>) puis appuyer sur <kbd>Entrée</kbd> une dernière fois. Emacs va alors faire l’opération chercher-remplacer que vous avez demandé.</p></div><div class=paragraph><p>Si vous vous demandez ce qu’est cette touche <kbd>Meta</kbd>, il s’agit d’une touche spéciale que beaucoup de stations de travail Unix possèdent. Malheureusement, les PC n’en ont pas, aussi c’est habituellement la touche <kbd>alt</kbd> (ou si vous n’avez pas de chance, la touche <kbd>échap</kbd>).</p></div><div class=paragraph><p>Oh, et pour sortir d’Emacs, faites <code>C-x C-c</code> (ce qui signifie maintenir la touche <kbd>control</kbd> appuyée, appuyer <kbd>c</kbd> et relâcher la touche <kbd>control</kbd>. Si vous avez des fichiers non sauvegardés ouverts, Emacs vous demandera si vous voulez les sauvegarder. (Ignorez le bout de documentation où il est dit que <code>C-z</code> est la manière habituelle de quitter Emacs- qui quitte Emacs en le laissant tourner en tâche de fond et qui n’est vraiment utile que si vous avez un système sans terminal virtuel).</p></div></div><div class=sect3><h4 id=_configurer_emacs>5.7.2. Configurer Emacs<a class=anchor href=#_configurer_emacs></a></h4><div class=paragraph><p>Emacs fait des choses merveilleuses; une partie est intégrée directement, une autre doit être configurée.</p></div><div class=paragraph><p>Plutôt que d’utiliser un macro langage propriétaire pour la configuration, Emacs utilise une version du Lisp spécialement adaptée pour les éditeurs, connue sous le nom d’Emacs Lisp. Celui-ci peut être assez utile si vous voulez poursuivre et apprendre quelque chose comme le Common Lisp, car il est considérablement plus petit que le Common Lisp (bien que déjà assez gros!).</p></div><div class=paragraph><p>La meilleure façon d’apprendre l’Emacs Lisp est de télécharger le <a href=ftp://prep.ai.mit.edu:pub/gnu/elisp-manual-19-2.4.tar.gz>cours d’Emacs</a></p></div><div class=paragraph><p>Toutefois, il n’y a pas besoin de connaître le Lisp pour commencer la configuration d’Emacs, car j’ai inclus un exemple de fichier <span class=filename>.emacs</span> qui devrait être suffisant pour commencer. Copiez juste celui-ci dans votre répertoire utilisateur et redémarrez Emacs si celui-ci s’exécute, il lira les commandes du fichier et (si tout va bien!) vous donnera une configuration basique utile.</p></div></div><div class=sect3><h4 id=_un_fichier_exemple_emacs>5.7.3. Un fichier exemple <span class=filename>.emacs</span><a class=anchor href=#_un_fichier_exemple_emacs></a></h4><div class=paragraph><p>Malheureusement, il y a beaucoup trop de choses ici pour les expliquer en détail; toutefois, il y a un ou deux points qui valent d’être mentionnés.</p></div><div class=ulist><ul><li><p>Tout ce qui commence avec un <code>;</code> est un commentaire et est ignoré par Emacs.</p></li><li><p>A la première ligne, le <code>-<strong>- Emacs-Lisp -</strong>-</code> est tel que vous pouvez éditer le fichier <span class=filename>.emacs</span> lui-même à l’intérieur d’Emacs et d’obtenir tous les fantaisistes dispositifs pour l’édition en Emacs Lisp. Emacs essaye habituellement de deviner cela en se basant sur le nom du fichier, et ne trouvera peut-être pas pour <span class=filename>.emacs</span>.</p></li><li><p>La touche <kbd>tab</kbd> est liée à la fonction d’indentation dans certains modes, aussi quand vous l’enfoncez, cela va indenter la ligne courante de code. Si vous voulez mettre un caractère tab dans quoique ce soit que vous tapiez, maintenez la touche <kbd>control</kbd> enfoncée pendant que vous appuyez sur <kbd>tab</kbd>.</p></li><li><p>Ce fichier supporte la colorisation de syntaxe pour les langages C, C++, Perl, Lisp et Scheme en devinant le langage par leur nom.</p></li><li><p>Emacs possède déjà une fonction pré-définie appelée <code>next-error</code>. Dans la fenêtre de sortie d’une compilation, cela vous permet de vous déplacer d’une erreur de compilation à la suivante en faisant <code>M-n</code>; nous définissons une fonction complémentaire <code>previous-error</code>, qui vous permet d’aller à l’erreur précédente en faisant <code>M-p</code>. Le plus beau dispositif de tous est que <code>C-c C-c</code> va ouvrir le fichier source dans lequel l’erreur a eu lieu et sautera à la ligne appropriée.</p></li><li><p>Nous autorisons la capacité d’Emacs à agir comme un serveur ainsi si vous faites quelque chose en dehors d’Emacs et voulez éditer un fichier, tapez juste</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% emacsclient nomfichier</code></pre></div></div><div class=paragraph><p>et alors vous pouvez éditer le fichier dans votre Emacs!</p></div></li></ul></div><div class=exampleblock><div class=title>Exemple 1. Un fichier exemple <span class=filename>.emacs</span></div><div class=content><div class="literalblock programlisting"><div class=content><pre>;; -*-Emacs-Lisp-*-

;; Ce fichier est concu pour etre reevalue, utiliser la variable first-time
;; pour eviter tout probleme.
(defvar first-time t
  &#34;Valeur signifiant que c&#39;est la premiere fois que .emacs a ete evalue&#34;
  )

;; Meta
(global-set-key &#34;\M- &#34; &#39;set-mark-command)
(global-set-key &#34;\M-\C-h&#34; &#39;backward-kill-word)
(global-set-key &#34;\M-\C-r&#34; &#39;query-replace)
(global-set-key &#34;\M-r&#34; &#39;replace-string)
(global-set-key &#34;\M-g&#34; &#39;goto-line)
(global-set-key &#34;\M-h&#34; &#39;help-command)

;; Function keys
(global-set-key [f1] &#39;manual-entry)
(global-set-key [f2] &#39;info)
(global-set-key [f3] &#39;repeat-complex-command)
(global-set-key [f4] &#39;advertised-undo)
(global-set-key [f5] &#39;eval-current-buffer)
(global-set-key [f6] &#39;buffer-menu)
(global-set-key [f7] &#39;other-window)
(global-set-key [f8] &#39;find-file)
(global-set-key [f9] &#39;save-buffer)
(global-set-key [f10] &#39;next-error)
(global-set-key [f11] &#39;compile)
(global-set-key [f12] &#39;grep)
(global-set-key [C-f1] &#39;compile)
(global-set-key [C-f2] &#39;grep)
(global-set-key [C-f3] &#39;next-error)
(global-set-key [C-f4] &#39;previous-error)
(global-set-key [C-f5] &#39;display-faces)
(global-set-key [C-f8] &#39;dired)
(global-set-key [C-f10] &#39;kill-compilation)

;; Keypad bindings
(global-set-key [up] &#34;\C-p&#34;)
(global-set-key [down] &#34;\C-n&#34;)
(global-set-key [left] &#34;\C-b&#34;)
(global-set-key [right] &#34;\C-f&#34;)
(global-set-key [home] &#34;\C-a&#34;)
(global-set-key [end] &#34;\C-e&#34;)
(global-set-key [prior] &#34;\M-v&#34;)
(global-set-key [next] &#34;\C-v&#34;)
(global-set-key [C-up] &#34;\M-\C-b&#34;)
(global-set-key [C-down] &#34;\M-\C-f&#34;)
(global-set-key [C-left] &#34;\M-b&#34;)
(global-set-key [C-right] &#34;\M-f&#34;)
(global-set-key [C-home] &#34;\M-&lt;&#34;)
(global-set-key [C-end] &#34;\M-&gt;&#34;)
(global-set-key [C-prior] &#34;\M-&lt;&#34;)
(global-set-key [C-next] &#34;\M-&gt;&#34;)

;; Souris
(global-set-key [mouse-3] &#39;imenu)

;; Divers
(global-set-key [C-tab] &#34;\C-q\t&#34;)	; Control tab quotes a tab.
(setq backup-by-copying-when-mismatch t)

;; Traite &#39;y&#39; ou &lt;CR&gt; comme yes, &#39;n&#39; comme no.
(fset &#39;yes-or-no-p &#39;y-or-n-p)
    (define-key query-replace-map [return] &#39;act)
    (define-key query-replace-map [?\C-m] &#39;act)

;; Charge les ajouts
(require &#39;desktop)
(require &#39;tar-mode)

;; Diff mode sympa
(autoload &#39;ediff-buffers &#34;ediff&#34; &#34;Intelligent Emacs interface to diff&#34; t)
(autoload &#39;ediff-files &#34;ediff&#34; &#34;Intelligent Emacs interface to diff&#34; t)
(autoload &#39;ediff-files-remote &#34;ediff&#34;
  &#34;Intelligent Emacs interface to diff&#34;)

(if first-time
    (setq auto-mode-alist
	  (append &#39;((&#34;\\.cpp$&#34; . c++-mode)
		    (&#34;\\.hpp$&#34; . c++-mode)
                    (&#34;\\.lsp$&#34; . lisp-mode)
		    (&#34;\\.scm$&#34; . scheme-mode)
		    (&#34;\\.pl$&#34; . perl-mode)
		    ) auto-mode-alist)))

;; Mode de verrouillage automatique de la police de caracteres
(defvar font-lock-auto-mode-list
  (list &#39;c-mode &#39;c++-mode &#39;c++-c-mode &#39;emacs-lisp-mode &#39;lisp-mode &#39;perl-mode &#39;scheme-mode)
  &#34;List of modes to always start in font-lock-mode&#34;)

(defvar font-lock-mode-keyword-alist
  &#39;((c++-c-mode . c-font-lock-keywords)
    (perl-mode . perl-font-lock-keywords))
  &#34;Associations between modes and keywords&#34;)

(defun font-lock-auto-mode-select ()
  &#34;Automatically select font-lock-mode if the current major mode is
in font-lock-auto-mode-list&#34;
  (if (memq major-mode font-lock-auto-mode-list)
      (progn
	(font-lock-mode t))
    )
  )

(global-set-key [M-f1] &#39;font-lock-fontify-buffer)

;; New dabbrev stuff
;(require &#39;new-dabbrev)
(setq dabbrev-always-check-other-buffers t)
(setq dabbrev-abbrev-char-regexp &#34;\\sw\\|\\s_&#34;)
(add-hook &#39;emacs-lisp-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) nil)
	     (set (make-local-variable &#39;dabbrev-case-replace) nil)))
(add-hook &#39;c-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) nil)
	     (set (make-local-variable &#39;dabbrev-case-replace) nil)))
(add-hook &#39;text-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) t)
	     (set (make-local-variable &#39;dabbrev-case-replace) t)))

;; mode C++ et C...
(defun my-c++-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key c++-mode-map &#34;\C-ce&#34; &#39;c-comment-edit)
  (setq c++-auto-hungry-initial-state &#39;none)
  (setq c++-delete-function &#39;backward-delete-char)
  (setq c++-tab-always-indent t)
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c++-empty-arglist-indent 4))

(defun my-c-mode-hook ()
  (setq tab-width 4)
  (define-key c-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key c-mode-map &#34;\C-ce&#34; &#39;c-comment-edit)
  (setq c-auto-hungry-initial-state &#39;none)
  (setq c-delete-function &#39;backward-delete-char)
  (setq c-tab-always-indent t)
;; Style d&#39;indentation BSD
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c-brace-offset -4)
  (setq c-argdecl-indent 0)
  (setq c-label-offset -4))

;; mode Perl
(defun my-perl-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (setq perl-indent-level 4)
  (setq perl-continued-statement-offset 4))

;; mode Scheme...
(defun my-scheme-mode-hook ()
  (define-key scheme-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent))

;; mode Emacs-Lisp...
(defun my-lisp-mode-hook ()
  (define-key lisp-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key lisp-mode-map &#34;\C-i&#34; &#39;lisp-indent-line)
  (define-key lisp-mode-map &#34;\C-j&#34; &#39;eval-print-last-sexp))

;; Ajoute tout le reste...
(add-hook &#39;c++-mode-hook &#39;my-c++-mode-hook)
(add-hook &#39;c-mode-hook &#39;my-c-mode-hook)
(add-hook &#39;scheme-mode-hook &#39;my-scheme-mode-hook)
(add-hook &#39;emacs-lisp-mode-hook &#39;my-lisp-mode-hook)
(add-hook &#39;lisp-mode-hook &#39;my-lisp-mode-hook)
(add-hook &#39;perl-mode-hook &#39;my-perl-mode-hook)

;; Le complement a next-error
(defun previous-error (n)
  &#34;Visit previous compilation error message and corresponding source code.&#34;
  (interactive &#34;p&#34;)
  (next-error (- n)))

;; Divers...
(transient-mark-mode 1)
(setq mark-even-if-inactive t)
(setq visible-bell nil)
(setq next-line-add-newlines nil)
(setq compile-command &#34;make&#34;)
(setq suggest-key-bindings nil)
(put &#39;eval-expression &#39;disabled nil)
(put &#39;narrow-to-region &#39;disabled nil)
(put &#39;set-goal-column &#39;disabled nil)

;; Recherche des archives Elisp
(autoload &#39;format-lisp-code-directory &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-apropos &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-retrieve &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-verify &#34;lispdir&#34; nil t)

;; Mode de verrouillage de police
(defun my-make-face (face colour &amp;optional bold)
  &#34;Create a face from a colour and optionally make it bold&#34;
  (make-face face)
  (copy-face &#39;default face)
  (set-face-foreground face colour)
  (if bold (make-face-bold face))
  )

(if (eq window-system &#39;x)
    (progn
      (my-make-face &#39;blue &#34;blue&#34;)
      (my-make-face &#39;red &#34;red&#34;)
      (my-make-face &#39;green &#34;dark green&#34;)
      (setq font-lock-comment-face &#39;blue)
      (setq font-lock-string-face &#39;bold)
      (setq font-lock-type-face &#39;bold)
      (setq font-lock-keyword-face &#39;bold)
      (setq font-lock-function-name-face &#39;red)
      (setq font-lock-doc-string-face &#39;green)
      (add-hook &#39;find-file-hooks &#39;font-lock-auto-mode-select)

      (setq baud-rate 1000000)
      (global-set-key &#34;\C-cmm&#34; &#39;menu-bar-mode)
      (global-set-key &#34;\C-cms&#34; &#39;scroll-bar-mode)
      (global-set-key [backspace] &#39;backward-delete-char)
					;      (global-set-key [delete] &#39;delete-char)
      (standard-display-european t)
      (load-library &#34;iso-transl&#34;)))

;; X11 ou PC utilisant les ecritures directes a l&#39;ecran
(if window-system
    (progn
      ;;      (global-set-key [M-f1] &#39;hilit-repaint-command)
      ;;      (global-set-key [M-f2] [?\C-u M-f1])
      (setq hilit-mode-enable-list
	    &#39;(not text-mode c-mode c++-mode emacs-lisp-mode lisp-mode
		  scheme-mode)
	    hilit-auto-highlight nil
	    hilit-auto-rehighlight &#39;visible
	    hilit-inhibit-hooks nil
	    hilit-inhibit-rebinding t)
      (require &#39;hilit19)
      (require &#39;paren))
  (setq baud-rate 2400)			; For slow serial connections
  )

;; Terminal de type TTY
(if (and (not window-system)
	 (not (equal system-type &#39;ms-dos)))
    (progn
      (if first-time
	  (progn
	    (keyboard-translate ?\C-h ?\C-?)
	    (keyboard-translate ?\C-? ?\C-h)))))

;; Sous Unix
(if (not (equal system-type &#39;ms-dos))
    (progn
      (if first-time
	  (server-start))))

;; Add any face changes here
(add-hook &#39;term-setup-hook &#39;my-term-setup-hook)
(defun my-term-setup-hook ()
  (if (eq window-system &#39;pc)
      (progn
;;	(set-face-background &#39;default &#34;red&#34;)
	)))

;; Restaure le  &#34;desktop&#34; - faire cela le plus tard possible
(if first-time
    (progn
      (desktop-load-default)
      (desktop-read)))

;; Indique que ce fichier a ete lu au moins une fois
(setq first-time nil)

;; Pas besoin de deverminer quoique ce soit maintenant

(setq debug-on-error nil)

;; Tout est fait
(message &#34;All done, %s%s&#34; (user-login-name) &#34;.&#34;)</pre></div></div></div></div></div><div class=sect3><h4 id=_etendre_la_palette_de_langages_quemacs_comprend>5.7.4. Etendre la palette de langages qu’Emacs comprend<a class=anchor href=#_etendre_la_palette_de_langages_quemacs_comprend></a></h4><div class=paragraph><p>Maintenant, Emacs est très bien si vous voulez seulement programmer dans des langages déjà fournis dans le fichier <span class=filename>.emacs</span> (C, C++, Perl, Lisp et Scheme), mais qu’arrive-t-il si un nouveau langage appelé "whizbang" sort, plein d’excitantes fonctionnalités ?</p></div><div class=paragraph><p>La première chose à faire est de savoir si whizbang est fourni avec des fichiers de configuration pour Emacs. Ceux-ci se terminent habituellement par <span class=filename>.el</span>, raccourci pour "Emacs Lisp". Par exemple, si whizbang est un logiciel porté FreeBSD, nous pouvons localiser ces fichiers en faisant</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% find /usr/ports/lang/whizbang <span class=nt>-name</span> <span class=s2>&#34;*.el&#34;</span> <span class=nt>-print</span></code></pre></div></div><div class=paragraph><p>et les installer en les copiant dans le répertoire Lisp d’Emacs. Sur FreeBSD 2.1.0-RELEASE, il s’agit de <span class=filename>/usr/local/shared/emacs/site-lisp</span>.</p></div><div class=paragraph><p>Aisni par exemple, si la sortie de la commande <code>find</code> était</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/usr/ports/lang/whizbang/work/misc/whizbang.el</code></pre></div></div><div class=paragraph><p>nous ferions</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/ports/lang/whizbang/work/misc/whizbang.el /usr/local/shared/emacs/site-lisp</span></code></pre></div></div><div class=paragraph><p>Ensuite, nous devons décider quel extension les fichiers source whizbang ont. Disons qu’il s’agit de fichiers se terminant par <span class=filename>.wiz</span>. Nous devons ajouter une entrée dans notre fichier <span class=filename>.emacs</span> pour être sûr qu’Emacs sera capable d’utiliser les informations dans <span class=filename>whizbang.el</span>.</p></div><div class=paragraph><p>Trouvez l’entrée auto-mode-alist dans <span class=filename>.emacs</span> et ajoutez une ligne pour whizbang, comme :</p></div><div class="literalblock programlisting"><div class=content><pre>...
(&#34;\\.lsp$&#34; . lisp-mode)
(&#34;\\.wiz$&#34; . whizbang-mode)
(&#34;\\.scm$&#34; . scheme-mode)
...</pre></div></div><div class=paragraph><p>Cela signifie qu’Emacs ira automatiquement dans la fonction <code>whizbang-mode</code> quand vous éditerez un fichier se terminant par <span class=filename>.wiz</span>.</p></div><div class=paragraph><p>Juste en-dessous, vous trouverez l’entrée font-lock-auto-mode-list. Ajoutez <code>whizbang-mode</code> à celle-ci comme ceci :</p></div><div class="literalblock programlisting"><div class=content><pre>;; Auto font lock mode
(defvar font-lock-auto-mode-list
  (list &#39;c-mode &#39;c++-mode &#39;c++-c-mode &#39;emacs-lisp-mode &#39;whizbang-mode &#39;lisp-mode &#39;perl-mode &#39;scheme-mode)
  &#34;List of modes to always start in font-lock-mode&#34;)</pre></div></div><div class=paragraph><p>Cela signifie qu’Emacs autorisera toujours <code>font-lock-mode</code> (ie colorisation de la syntaxe) pendant l’édition d’un fichier <span class=filename>.wiz</span>.</p></div><div class=paragraph><p>Et c’est tout ce qui est nécessaire. S’il y a quoique ce soit que vous voulez de fait automatiquement quand vous ouvrez un fichier <span class=filename>.wiz</span>, vous pouvez ajouter un <code>whizbang-mode hook</code> (voir <code>my-scheme-mode-hook</code> pour un exemple simple qui ajoute <code>auto-indent</code>, l’auto-indentation).</p></div></div></div><div class=sect2><h3 id=_pour_aller_plus_loin>5.8. Pour aller plus loin<a class=anchor href=#_pour_aller_plus_loin></a></h3><div class=ulist><ul><li><p>Brian Harvey and Matthew Wright <em>Simply Scheme</em> MIT 1994. ISBN 0-262-08226-8</p></li><li><p>Randall Schwartz <em>Learning Perl</em> O’Reilly 1993 ISBN 1-56592-042-2</p></li><li><p>Patrick Henry Winston and Berthold Klaus Paul Horn <em>Lisp (3rd Edition)</em> Addison-Wesley 1989 ISBN 0-201-08319-1</p></li><li><p>Brian W. Kernighan and Rob Pike <em>The Unix Programming Environment</em> Prentice-Hall 1984 ISBN 0-13-937681-X</p></li><li><p>Brian W. Kernighan and Dennis M. Ritchie <em>The C Programming Language (2nd Edition)</em> Prentice-Hall 1988 ISBN 0-13-110362-8</p></li><li><p>Bjarne Stroustrup <em>The C++ Programming Language</em> Addison-Wesley 1991 ISBN 0-201-53992-6</p></li><li><p>W. Richard Stevens <em>Advanced Programming in the Unix Environment</em> Addison-Wesley 1992 ISBN 0-201-56317-7</p></li><li><p>W. Richard Stevens <em>Unix Network Programming</em> Prentice-Hall 1990 ISBN 0-13-949876-1</p></li></ul></div></div></div></div><div class=sect1><h2 id=secure>Chapitre 6. Programmation sécurisée<a class=anchor href=#secure></a></h2><div class=sectionbody><div class=paragraph><p>Ce chapître a été écrit par Murray Stokely.</p></div><div class=sect2><h3 id=_synopsis_2>6.1. Synopsis<a class=anchor href=#_synopsis_2></a></h3><div class=paragraph><p>Ce chapître décrit quelques problèmes de sécurité qui ont tourmenté les programmeurs Unix depuis des dizaines d’années et quelques uns des nouveaux outils disponibles pour aider les programmeurs à éviter l’écriture de code non sécurisé.</p></div></div><div class=sect2><h3 id=secure-philosophy>6.2. Méthodologie de développement sécurisé<a class=anchor href=#secure-philosophy></a></h3><div class=paragraph><p>Ecrire des applications sécurisées demande une très minutieuse et pessimiste vision de la vie. Les applications devrait fonctionner avec le principe du "privilège moindre" de façon à ce qu’aucun processus ne fonctionne avec plus que le strict minimum dont il a besoin pour accomplir sa tâche. Le code pré-testé devrait être réutilisé autant que possible pour éviter les erreurs communes que d’autres peuvent déjà avoir réparées.</p></div><div class=paragraph><p>Un des pièges de l’environnement Unix est qu’il est facile d’affecter la stabilité de l’environnement. Les applications ne devraient jamais avoir confiance dans la saisie de l’utilisateur (sous toutes ses formes), les ressources système, la communication inter-processus, ou l’enchaînement des évènements. Les processus Unix n’exécutent pas de manière synchrone aussi, logiquement, les opérations sont rarement atomiques.</p></div></div><div class=sect2><h3 id=_dépassement_de_capacité>6.3. Dépassement de capacité<a class=anchor href=#_dépassement_de_capacité></a></h3><div class=paragraph><p>Les dépassements de capacité ("Buffer Overflows") existent depuis les débuts de l’architecture de Von-Neuman <a href=#COD>1</a>. Ils gagnèrent une grande notoriété en 1988 avec le ver pour Internet de Morris. Malheureusement, la même attaque basique reste effective aujourd’hui. Des 17 rapports de sécurité du CERT de 1999, 10 furent causés directement des bogues logiciels de dépassement de capacité. De loin la plus commune de types d’attaques par dépassement de capacité est basée sur la corruption de la pile.</p></div><div class=paragraph><p>La plupart des systèmes informatiques modernes utilise une pile pour passer les arguments aux procédures et stocker les variables locales Une pile est une zone mémoire dernier entré-premier sorti (Last In-First Out : LIFO) dans la zone de mémoire haute de l’image d’un processus. Quand un programme invoque une fonction une nouvelle structure pile est créée. Cette structure pile consiste dans les arguments passés à la fonction aussi bien que dans une quantité dynamique d’espace pour la variable locale. Le pointeur de pile est un registre qui référence la position courante du sommet de la pile. Etant donné que cette valeur change constamment au fur et à mesure que de nouvelles valeurs sont ajoutées au sommet de la pile, beaucoup d’implémentations fournissent aussi un pointeur de structure qui est positionné dans le voisinage du début de la structure pile de façon à ce que les variables locales soient plus facilement adressables relativement à cette valeur. <a href=#COD>1</a> L’adresse de retour des appels de fonction est aussi stocké dans la pile, et cela est la cause des découvertes des dépassements de pile puisque faire déborder une variable locale dans une fonction peut écraser l’adresse de retour de cette fonction, permettant potentiellement à un utilisateur malveillant d’exécuter le code qu’il ou elle désire.</p></div><div class=paragraph><p>Bien que les attaques basées sur les dépassements de pile soient de loin les plus communes, il serait aussi possible de faire exploser la pile avec une attaque du tas (malloc/free).</p></div><div class=paragraph><p>Le langage de programmation C ne réalise pas de vérifications automatiques des limites sur les tableaux ou pointeurs comme d’autres langages le font. De plus, la librairie standard du C est remplie d’une poignée de fonctions très dangereuses.</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcpy</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peut faire déborder le tampon dest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcat</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peut faire déborder le tampon dest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>getwd</code>(char *buf)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peut faire déborder le tampon buf</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>gets</code>(char *s)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peut faire déborder le tampon s</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[vf]scanf</code>(const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peut faire déborder ses arguments.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>realpath</code>(char *path, char resolved_path[])</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peut faire déborder le tampon path</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[v]sprintf</code>(char *str, const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peut faire déborder le tampon str.</p></td></tr></tbody></table><div class=sect3><h4 id=_exemple_de_dépassement_de_capacité>6.3.1. Exemple de dépassement de capacité<a class=anchor href=#_exemple_de_dépassement_de_capacité></a></h4><div class=paragraph><p>L’exemple de code suivant contient un dépassement de capacité conçu pour écraser l’adresse de retour et "sauter" l’instruction suivant immédiatement l’appel de la fonction. (Inspiré par <a href=#Phrack>4</a>)</p></div><div class="literalblock programlisting"><div class=content><pre>#include stdio.h

void manipulate(char *buffer) {
  char newbuffer[80];
  strcpy(newbuffer,buffer);
}

int main() {
  char ch,buffer[4096];
  int i=0;

  while ((buffer[i++] = getchar()) != &#39;\n&#39;) {};

  i=1;
  manipulate(buffer);
  i=2;
  printf(&#34;La valeur de i est : %d\n&#34;,i);
  return 0;
}</pre></div></div><div class=paragraph><p>Examinons quel serait l’aspect de l’image mémoire de ce processus si nous avions entré 160 espaces dans notre petit programme avant d’appuyer sur <kbd>Entrée</kbd>.</p></div><div class=paragraph><p>Evidemment une entrée plus malveillante pourrait être imaginée pour exécuter des instructions déjà compilées (comme exec(/bin/sh)).</p></div></div><div class=sect3><h4 id=_eviter_les_dépassements_de_capacité>6.3.2. Eviter les dépassements de capacité<a class=anchor href=#_eviter_les_dépassements_de_capacité></a></h4><div class=paragraph><p>La solution la plus simple au problème de débordement de pile est de toujours utiliser de la mémoire restreinte en taille et les fonctions de copie de chaîne de caractères. <code>strncpy</code> et <code>strncat</code> font parties de la libraire standard du C. Ces fonctions acceptent une valeur de longueur comme paramètre qui qui ne devrait pas être plus grande que la taille du tampon de destination. Ces fonctions vont ensuite copier <code>taille</code> octets de la source vers la destination. Toutefois, il y a un certain nombre de problèmes avec ces fonctions. Aucune fonction ne garantit une terminaison par le caractère NULL si la taille du tampon d’entrée est aussi grand que celui de destination. Le paramètre taille est aussi utilisé de façon illogique entre <code>strncpy</code> et <code>strncat</code> aussi il est facile pour les programmeurs d’être déroutés sur leur utilisation convenable. Il y a aussi une perte significative des performances comparé à <code>strcpy</code> lorsque l’on copie une courte chaîne dans un grand tampon puisque <code>strncpy</code> remplit de caractères NULL jusqu’à la taille spécifiée.</p></div><div class=paragraph><p>Dans OpenBSD, une autre implémentation de la copie de mémoire a été créée pour contourner ces problèmes. Les fonctions <code>strlcpy</code> et <code>strlcat</code> garantissent qu’elles termineront toujours le tampon de destination par un caractère NULL losque l’argument de taille est différent de zéro. Pour plus d’informations sur ces fonctions, voir <a href=#OpenBSD>6</a>. Les fonctions <code>strlcpy</code> et <code>strlcat</code> d’OpenBSD ont été inclues dans FreeBSD depuis la version 3.5.</p></div><div class=sect4><h5 id=_v233rifications_des_limites_en_fonctionnement_basées_sur_le_compilateur>6.3.2.1. V#233;rifications des limites en fonctionnement basées sur le compilateur<a class=anchor href=#_v233rifications_des_limites_en_fonctionnement_basées_sur_le_compilateur></a></h5><div class=paragraph><p>Malheureusement il y a toujours un très important assortiment de code en utilisation publique qui copie aveuglément la mémoire sans utiliser une des routines de copie limitée dont nous venons juste de discuter. Heureusement, il y a une autre solution. Plusieurs produits complémentaires pour compilateur et librairies existent pour faire de la vérification de limites pendant le fonctionnement en C/C++.</p></div><div class=paragraph><p>StackGuard est un de ces produits qui est implémenté comme un petit correctif ("patch") pour le générateur de code gcc. Extrait du site Internet de StackGuard, <a href=http://immunix.org/stackguard.html class=bare>http://immunix.org/stackguard.html</a> :</p></div><div class="paragraph blockquote"><p>"StackGuard détecte et fait échouer les attaques par débordement de pile en empêchant l’adresse de retour sur la pile d’être altérée. StackGuard place un mot "canari" à côté de l’adresse de retour quand la fontion est appelée. Si le mot "canari" a été altéré au retour de la fonction, alors une attaque par débordement de pile a été tentée et le programme répond en envoyant une alerte d’intrusion dans la trace système (syslog) et s’arrête alors."</p></div><div class="paragraph blockquote"><p>"StackGuard est implémenté comme un petit correctif au générateur de code gcc, spécifiquement sur les routines function_prolog() et function_epilog(). function_prolog() a été amélioré pour laisser des "canaris" sur la pile quand les fonctions démarrent, et function_epilog vérifie l’intégrité des "canaris" quand la fonction se termine. Tout essai pour corrompre l’adresse de retour est alors détectée avant que la fonction ne retourne."</p></div><div class=paragraph><p>Recompiler votre application avec StackGuard est un moyen efficace pour stopper la plupart des attques par dépassement de capacité, mais cela peut toujours être compromis.</p></div></div><div class=sect4><h5 id=_vérifications_des_limites_en_fonctionnement_basées_sur_les_librairies>6.3.2.2. Vérifications des limites en fonctionnement basées sur les librairies<a class=anchor href=#_vérifications_des_limites_en_fonctionnement_basées_sur_les_librairies></a></h5><div class=paragraph><p>Les mécanismes basés sur le compilateur sont totalement inutiles pour logiciel seulement binaire que vous ne pouvez recompiler. Pour ces situations, il existe un nombre de librairies qui re-implémente les fonctions peu sûres de la librairie C (<code>strcpy</code>, <code>fscanf</code>, <code>getwd</code>, etc..) et assurent que ces fonctions ne peuvent pas écrire plus loin que le pointeur de pile.</p></div><div class=ulist><ul><li><p>libsafe</p></li><li><p>libverify</p></li><li><p>libparnoia</p></li></ul></div><div class=paragraph><p>Malheureusement ces défenses basées sur les librairies possèdent un certain nombre de défauts. Ces librairies protègent seulement d’un très petit ensemble de problèmes liés à la sécurité et oublient de réparer le problème actuel. Ces défenses peuvent échouer si l’application a été compilée avec -fomit-frame-pointer. De même, les variables d’environnement LD_PRELOAD et LD_LIBRARY_PATH peuvent être réécrites/non définies par l’utilisateur.</p></div></div></div></div><div class=sect2><h3 id=_les_problèmes_liés_à_setuid>6.4. Les problèmes liés à SetUID<a class=anchor href=#_les_problèmes_liés_à_setuid></a></h3><div class=paragraph><p>Il y a au moins 6 differents ID (identifiants) associés à un processus donné. A cause de cela, vous devez être très attentif avec l’accès que votre processus possède à un instant donné. En particulier, toutes les applications ayant reçu des privilèges par seteuid doivent les abandonnés dès qu’ils ne sont plus nécessaires.</p></div><div class=paragraph><p>L’identifiant de l’utilisateur réel (real user ID) peut seulement être changé par un processus super-utilisateur. Le programme login met celui à jour quand un utilisateur se connecte et il est rarement changé.</p></div><div class=paragraph><p>L’identifiant de l’utilisateur effectif (effective user ID) est mis à jour par les fonctions <code>exec()</code> si un programme possède son bit seteuid placé. Une application peut appeler <code>seteuid()</code> à n’importe quel moment pour règler l’identifiant de l’utilisateur effectif sur l’identifiant d’un utilisateur réel ou sur le "set-user-ID" sauvé. Quand l’identifiant de l’utilisateur effectif est placé par les fonctions <code>exec()</code>, la valeur précédente est sauvée dans le "set-user-ID" sauvé.</p></div></div><div class=sect2><h3 id=chroot>6.5. Limiter l’environnement de votre programme<a class=anchor href=#chroot></a></h3><div class=paragraph><p>La méthode traditionnelle pour restreindre l’accès d’un processus se fait avec l’appel système <code>chroot()</code>. Cet appel système change le répertoire racine depuis lequel tous les autres chemins sont référencés pour un processus et ses fils. Pour que cet appel réussisse, le processus doit avoir exécuté (recherché) la permission dans le répertoire référencé. Le nouvel environnement environment ne prend pas effet que lorsque vous appelez <code>chdir()</code> dans celui-ci. Il doit être aussi noté qu’un processus peut facilement s’échapper d’un environnement chroot s’il a les privilèges du super-utilisateur. Cela devrait être accompli en créant des fichiers spéciaux de périphérique pour la mémoire du noyau, en attachant un dévermineur à un processus depuis l’extérieur de sa "prison", ou par d’autres manières créatrices.</p></div><div class=paragraph><p>Le comportement de l’appel système <code>chroot()</code> peut être un peu contrôlé avec la commande <code>sysctl</code> et la variable kern.chroot_allow_open_directories. Quand cette valeur est règlée à 0, <code>chroot()</code> échouera avec EPERM s’il y a un répertoire d’ouvert. Si la variable est règlée sur la valeur par défaut 1, alors <code>chroot()</code> échouera avec EPERM s’il y a un répertoire d’ouvert et que le processus est déjà sujet à un appel <code>chroot()</code>. Pour toute autre valeur, la vérification des répertoires ouverts sera totalement court-circuitée.</p></div><div class=sect3><h4 id=_la_fonctionnalité_prison_de_freebsd>6.5.1. La fonctionnalité "prison" de FreeBSD<a class=anchor href=#_la_fonctionnalité_prison_de_freebsd></a></h4><div class=paragraph><p>Le concept de Prison ("Jail") étend <code>chroot()</code> en limitant les droits du super-utilisateur pour créer un véritable <code>serveur virtuel</code>. Une fois qu’une prison est mise en place, toute communication réseau doit avoir lieu au travers de l’adresse IP spécifiée, et le droit du "privilège super-utilisateur" dans cette prison est sévèrement gêné.</p></div><div class=paragraph><p>Tant qu’il se trouve en prison, tout test avec les droits du super-utilisateur dans le noyau au travers d’un appel à <code>suser()</code> échouera. Toutefois, quelques appels à <code>suser()</code> ont été changés par la nouvelle interface <code>suser_xxx()</code>. Cette fonction est responsable de fournir ou de retirer les accès aux droits du super-utilisateur pour les processus emprisonnés.</p></div><div class=paragraph><p>Un processus super-utilisateur dans un environnement emprisonné a le pouvoir de :</p></div><div class=ulist><ul><li><p>Manipuler les identitifications avec <code>setuid</code>, <code>seteuid</code>, <code>setgid</code>, <code>setegid</code>, <code>setgroups</code>, <code>setreuid</code>, <code>setregid</code>, <code>setlogin</code></p></li><li><p>Règler les limites en ressources avec <code>setrlimit</code></p></li><li><p>Modifier quelques variables du noyau par sysctl (kern.hostname)</p></li><li><p><code>chroot()</code></p></li><li><p>Règler les paramètres d’un noeud virtuel (vnode): <code>chflags</code>, <code>fchflags</code></p></li><li><p>Règler les attributs d’un noeud virtuel comme les permissions d’un fichier, le propriétaire, le groupe, la taille, la date d’accès, et la date de modification.</p></li><li><p>Se lier à des ports privilégiés sur Internet (ports &lt; 1024)</p></li></ul></div><div class=paragraph><p><code>Jail</code> est un outil très utile pour exécuter des applications dans un environnement sécurisé mais il a des imperfections. Actuellement, les mécanismes IPC (Inter-Process Communications) n’ont pas été convertis pour utiliser <code>suser_xxx</code> aussi des applications comme MySQL ne peuvent être exécutée dans une prison. L’accès super-utilisateur peut avoir un sens très limité dans une prison, mais il n’y aucune façon de spécifier exactement ce que très limité veut dire.</p></div></div><div class=sect3><h4 id=_les_capacitès_des_processus_posix_1e>6.5.2. Les capacitès des processus POSIX.1e<a class=anchor href=#_les_capacitès_des_processus_posix_1e></a></h4><div class=paragraph><p>Posix a réalisé un document de travail qui ajoute l’audit d’évènement, les listes de contrôle d’accès, les privilèges fins, l’étiquetage d’information, et le contrôle d’accès mandaté.</p></div><div class=paragraph><p>Il s’agit d’un travail en cours et c’est l’objectif du projet <a href=http://www.trustedbsd.org>TrustedBSD</a>. Une partie du travail initial a été intégré dans FreeBSD-current (cap_set_proc(3)).</p></div></div></div><div class=sect2><h3 id=_la_confiance>6.6. La confiance<a class=anchor href=#_la_confiance></a></h3><div class=paragraph><p>Une application ne devrait jamais supposer que tout est sain dans l’environnement des utilisateurs. Cela inclut (mais n’est certainement pas limité à) : la saisie de l’utilisateur, les signaux, les variables d’environnement, les ressources, les communication inter-processus, les mmaps, le répertoire de travail du système de fichiers, les descripteurs de fichier, le nombre de fichiers ouverts, etc.</p></div><div class=paragraph><p>Vous ne devriez jamais supposer que vous pouvez gérer toutes les formes de saisie invalide qu’un utilisateur peut entrer. Votre application devrait plutôt utiliser un filtrage positif pour seulement permettre un sous-ensemble spécifique que vous jugez sain. Une mauvaise validation des entrées a été la cause de beaucoup découvertes de bogues, spécialement avec les scripts CGI sur le web. Pour les noms de fichier, vous devez être tout particulièrement attentif aux chemins ("../", "/"), liens symboliques et caractères d’échappement de l’interpréteur de commandes.</p></div><div class=paragraph><p>Perl possède une caractéristique tès sympathique appelée mode "Taint" qui peut être utilisée pour empêcher les scripts d’utiliser des données externes au programme par un moyen non sûr. Ce mode vérifiera les arguments de la ligne de commandes, les variables d’environnement, les informations localisées (propres aux pays), les résultats de certains appels système (<code>readdir()</code>, <code>readlink()</code>, <code>getpwxxx()</code>) et toute entrée de fichier.</p></div></div><div class=sect2><h3 id=_les_conditions_de_course>6.7. Les conditions de course<a class=anchor href=#_les_conditions_de_course></a></h3><div class=paragraph><p>Une condition de course est un comportement anormal causé par une dépendance inattendue sur le séquencement relatif des évènements. En d’autres mots, un programmeur a supposé à tort qu’un évènement particulier se passerait avant un autre.</p></div><div class=paragraph><p>Quelques causes habituelles de conditions de course sont les signaux, les vérifications d’accès et les fichiers ouverts. Les signaux sont des évènements asynchrones par nature aussi un soin particulier doit être pris pour les utiliser. Vérifier les accès avec <code>access(2)</code> puis <code>open(2)</code> n’est clairement pas atomique. Les utilisateurs peuvent déplacer des fichiers entre les deux appels. Les applications privilégiées devraient plutôt faire un appel à <code>seteuid()</code> puis appeler <code>open()</code> directement. Dans le même esprit, une application devrait toujours règler un umask correct avant un appel à <code>open()</code> pour prévenir le besoin d’appels non valides à <code>chmod()</code>.</p></div></div></div></div><h1 id=kernel class=sect0>Partie III: Le noyau<a class=anchor href=#kernel></a></h1><div class=sect1><h2 id=kernelhistory>Chapitre 7. Histoire du noyau Unix<a class=anchor href=#kernelhistory></a></h2><div class=sectionbody><div class=paragraph><p>Un peu d’histoire sur le noyau Unix/BSD, les appels système, comment fonctionnent les processus, bloquer, planifier, les threads (noyau), le basculement de contexte, les signaux, les interruptions, les modules, etc.</p></div></div></div><div class=sect1><h2 id=locking>Chapitre 8. Notes sur le verrouillage<a class=anchor href=#locking></a></h2><div class=sectionbody><div class=paragraph><p><em>Ce chapître est maintenu par The FreeBSD SMP Next Generation Project. Envoyez leur directement les commentaires et les suggestions à link:{freebsd-smp}.</em></p></div><div class=paragraph><p>Ce document souligne le verrouillage utilisé dans le noyau FreeBSD pour permettre d’utiliser du vrai multi-processeur à l’intérieur du noyau. Le verrouillage peut être réalisé par différents moyens. Les structures de données puvent être protégées par des mutex ou <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a> verrous. Quelques variables sont protégées simplement par l’utilisation continuelle d’opérations atomiques pour y accéder.</p></div><div class=sect2><h3 id=_les_mutex>8.1. Les mutex<a class=anchor href=#_les_mutex></a></h3><div class=paragraph><p>Un mutex est simplement un verrou utilisé pour garantir exclusion mutuelle. Spécifiquement, un mutex ne peut appartenir qu’à une entité à la fois. Si une autre entité désire obtenir un mutex déjà pris , elle doit attendre jusqu’à ce que le mutex soit relaché. Dans le noyau FreeBSD, les mutex appartiennent aux processus.</p></div><div class=paragraph><p>Les mutex peuvent être acquis récursivement, mais ils sont conçus pour n’être pris que pendant une courte période. Spécifiquement, le détenteur ne doit pas se suspendre pendant qu’il retient un mutex. Si vous avez besoin de maintenir un verrouillage pendant une suspension, utilisez un <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a> verrou ("lock").</p></div><div class=paragraph><p>Chaque mutex a plusieurs intérêts :</p></div><div class=dlist><dl><dt class=hdlist1>Nom de la variable</dt><dd><p>Nom de la variable struct mtx dans le code source du noyau.</p></dd><dt class=hdlist1>Nom logique</dt><dd><p>Le nom du mutex lui est assigné par <code>mtx_init</code>. Ce nom est affiché dans les messages de trace KTR, témoigne des erreurs et avertissements et est utilisé pour distinguer les mutex dans les traces.</p></dd><dt class=hdlist1>Type</dt><dd><p>Le type du mutex en termes de constantes nommées MTX_*. La signification de chaque constante nommée est documentée dans <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a>.</p><div class=dlist><dl><dt class=hdlist1>MTX_DEF</dt><dd><p>Un mutex endormi</p></dd><dt class=hdlist1>MTX_SPIN</dt><dd><p>Un mutex tournant</p></dd><dt class=hdlist1>MTX_COLD</dt><dd><p>Ce mutex est initialisé très tard. Toutefois, il doit être déclaré via <code>MUTEX_DECLARE</code>, et la constante nommée MTX_COLD doit être passée à <code>mtx_init</code>.</p></dd><dt class=hdlist1>MTX_TOPHALF</dt><dd><p>Ce mutex tournant ne désactive pas les interruptions.</p></dd><dt class=hdlist1>MTX_NORECURSE</dt><dd><p>Ce mutex n’a pas la permission d’être recursif.</p></dd></dl></div></dd><dt class=hdlist1>Protégés</dt><dd><p>Une liste de structures de données ou des membres de structure de données que cette entrée protège. Pour les membres de structures de données, le nom sera de la forme <code>structure name</code>.<code>member name</code>.</p></dd><dt class=hdlist1>Fonctions dépendantes</dt><dd><p>Les fonctions qui peuvent seulement être appelées si ce mutex est pris.</p></dd></dl></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Tableau 1. Liste du mutex</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Nom de la variable</th><th class="tableblock halign-left valign-top">Nom logique</th><th class="tableblock halign-left valign-top">Type</th><th class="tableblock halign-left valign-top">Protégés</th><th class="tableblock halign-left valign-top">Fonctions dépendantes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>sched_lock</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"sched lock"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MTX_SPIN | MTX_COLD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>_gmonparam</code>, <code>cnt.v_swtch</code>, <code>cp_time</code>, <code>curpriority</code>, <code>mtx</code>.<code>mtx_blocked</code>, <code>mtx</code>.<code>mtx_contested</code>, <code>proc</code>.<code>p_contested</code>, <code>proc</code>.<code>p_blocked</code>, <code>proc</code>.<code>p_flag</code> (P_PROFIL XXX, P_INMEM, P_SINTR, P_TIMEOUT, P_SWAPINREQ XXX, P_INMEN XXX), <code>proc</code>.<code>p_nice</code>, <code>proc</code>.<code>p_procq</code>, <code>proc</code>.<code>p_blocked</code>, <code>proc</code>.<code>p_estcpu</code>, <code>proc</code>.<code>p_nativepri</code>, <code>proc</code>.<code>p_priority</code>, <code>proc</code>.<code>p_usrpri</code>, <code>proc</code>.<code>p_rtprio</code>, <code>proc</code>.<code>p_rqindex</code>, <code>proc</code>.<code>p_stats→p_prof</code>, <code>proc</code>.<code>p_stats→p_ru</code>, <code>proc</code>.<code>p_stat</code>, <code>proc</code>.<code>p_cpticks</code>, <code>proc</code>.<code>p_iticks</code>, <code>proc</code>.<code>p_uticks</code>, <code>proc</code>.<code>p_sticks</code>, <code>proc</code>.<code>p_swtime</code>, <code>proc</code>.<code>p_slptime</code>, <code>proc</code>.<code>p_runtime</code>, <code>proc</code>.<code>p_pctcpu</code>, <code>proc</code>.<code>p_oncpu</code>, <code>proc</code>.<code>p_asleep</code>, <code>proc</code>.<code>p_wchan</code>, <code>proc</code>.<code>p_wmesg</code>, <code>proc</code>.<code>p_slpq</code>, <code>proc</code>.<code>p_vmspace</code> (XXX - in <code>statclock</code>), <code>pscnt</code>, <code>slpque</code>, <code>itqueuebits</code>, <code>itqueues</code>, <code>rtqueuebits</code>, <code>rtqueues</code>, <code>queuebits</code>, <code>queues</code>, <code>idqueuebits</code>, <code>idqueues</code>, <code>switchtime</code>,</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>setrunqueue</code>, <code>remrunqueue</code>, <code>mi_switch</code>, <code>chooseproc</code>, <code>schedclock</code>, <code>resetpriority</code>, <code>updatepri</code>, <code>maybe_resched</code>, <code>cpu_switch</code>, <code>cpu_throw</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>vm86pcb_lock</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"vm86pcb lock"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MTX_DEF | MTX_COLD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>vm86pcb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>vm86_bioscall</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Giant</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"Giant"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MTX_DEF | MTX_COLD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>nearly everything</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lots</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>callout_lock</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>"callout lock"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>MTX_SPIN</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>callfree</code>, <code>callwheel</code>, <code>nextsoftcheck</code>, <code>proc</code>.<code>p_itcallout</code>, <code>proc</code>.<code>p_slpcallout</code>, <code>softticks</code>, <code>ticks</code></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table></div><div class=sect2><h3 id=_les_verrous_du_gestionnaire_de_verrous_lock_manager>8.2. Les verrous du gestionnaire de verrous (Lock Manager)<a class=anchor href=#_les_verrous_du_gestionnaire_de_verrous_lock_manager></a></h3><div class=paragraph><p>Les verrous qui sont fournis par l’interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a> sont les verrous du gestionnaire de verrous. Ces verrous sont des verrous lecture-écriture et peuvent être retenus par un process suspendu.</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Tableau 2. <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a> List de verrou</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nom de la variable</th><th class="tableblock halign-left valign-top">Protégés</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top"></th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>allproc_lock</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>allproc</code> <code>zombproc</code> <code>pidhashtbl</code> <code>proc.p_list</code> <code>proc.p_hash</code> <code>nextpid</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>proctree_lock</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>proc.p_children</code> <code>proc.p_sibling</code></p></td></tr></tbody></table></div><div class=sect2><h3 id=_variables_protégées_atomiquement>8.3. Variables protégées atomiquement<a class=anchor href=#_variables_protégées_atomiquement></a></h3><div class=paragraph><p>Une variable protégée atomiquement est une variable spéciale qui n’est pas protégé par un verrou explicite. Toutefois, tous les accès de données aux variables utilisent des opérations atomiques spéciales comme décrit dans <a href="https://man.freebsd.org/cgi/man.cgi?query=atomic&amp;sektion=9&amp;format=html">atomic(9)</a>. Très peu de variables sont traitées de cette façon, bien que les autres primitives de synchronisation comme les mutex soient implémentées avec des variables protégées atomiquement.</p></div><div class=ulist><ul><li><p><code>astpending</code></p></li><li><p><code>mtx</code>.<code>mtx_lock</code></p></li></ul></div></div></div></div><h1 id=memory class=sect0>Partie IV: Mémoire et mémoire virtuelle<a class=anchor href=#memory></a></h1><div class=sect1><h2 id=virtualmemory>Chapitre 9. La mémoire virtuelle<a class=anchor href=#virtualmemory></a></h2><div class=sectionbody><div class=paragraph><p>MV, gestion par page, gestion sur disque, allouer de la mémoire, tester les fuites de mémoires, mmap, vnodes, etc.</p></div></div></div><h1 id=iosystem class=sect0>Partie V: Système E/S (Entrées/Sorties)<a class=anchor href=#iosystem></a></h1><div class=sect1><h2 id=UFS>Chapitre 10. UFS<a class=anchor href=#UFS></a></h2><div class=sectionbody><div class=paragraph><p>UFS, FFS, Ext2FS, JFS, inodes, mémoire tampon, mettre à jour les données d’un disque, verrouillage, metadata, soft-updates, LFS, portalfs, procfs, vnodes, partage de mémoire, objets en mémoire, TLBs, mettre en cache</p></div></div></div><h1 id=ipc class=sect0>Partie VI: Communication InterProcessus (IPC)<a class=anchor href=#ipc></a></h1><div class=sect1><h2 id=signals>Chapitre 11. Les signaux<a class=anchor href=#signals></a></h2><div class=sectionbody><div class=paragraph><p>Signaux, tubes, sémaphores, files de message, segments de mémoire partagée, ports, prises, portes</p></div></div></div><h1 id=networking class=sect0>Partie VII: Le réseau<a class=anchor href=#networking></a></h1><div class=sect1><h2 id=sockets>Chapitre 12. Les prises<a class=anchor href=#sockets></a></h2><div class=sectionbody><div class=paragraph><p>Prises, bpf, IP, TCP, UDP, ICMP, OSI, ponts, pare-feux, translation d’adresses (NAT), séparation de réseaux, etc</p></div></div></div><h1 id=networkfs class=sect0>Partie VIII: Systèmes de fichiers en réseau<a class=anchor href=#networkfs></a></h1><div class=sect1><h2 id=afs>Chapitre 13. AFS<a class=anchor href=#afs></a></h2><div class=sectionbody><div class=paragraph><p>AFS, NFS, SANs etc]</p></div></div></div><h1 id=terminal class=sect0>Partie IX: Gestion du terminal<a class=anchor href=#terminal></a></h1><div class=sect1><h2 id=syscons>Chapitre 14. Syscons<a class=anchor href=#syscons></a></h2><div class=sectionbody><div class=paragraph><p>Syscons, tty, PCVT, console en liaison série, économiseurs d’écran, etc</p></div></div></div><h1 id=sound class=sect0>Partie X: Le son<a class=anchor href=#sound></a></h1><div class=sect1><h2 id=oss>Chapitre 15. OSS<a class=anchor href=#oss></a></h2><div class=sectionbody><div class=paragraph><p>OSS, formes d’ondes, etc</p></div></div></div><h1 id=devicedrivers class=sect0>Partie XI: Pilotes de périphérique<a class=anchor href=#devicedrivers></a></h1><div class=sect1><h2 id=driverbasics>Chapitre 16. Ecrire des pilotes de périphériques pour FreeBSD<a class=anchor href=#driverbasics></a></h2><div class=sectionbody><div class=paragraph><p>Ce chapitre a été écrit par Murray Stokely &lt;<a href=mailto:murray@FreeBSD.org>murray@FreeBSD.org</a>> avec des sélections depuis une variété de codes source inclus dans la page de manuel d’<a href="https://man.freebsd.org/cgi/man.cgi?query=intro&amp;sektion=4&amp;format=html">intro(4)</a> de Joerg Wunsch.</p></div><div class=sect2><h3 id=_introduction_2>16.1. Introduction<a class=anchor href=#_introduction_2></a></h3><div class=paragraph><p>Ce chapitre fournit une brève introduction sur l’écriture de pilotes de périphériques pour FreeBSD. Un périphérique, dans ce contexte, est un terme utilisé le plus souvent pour tout ce qui est lié au matériel et qui dépend du système, comme les disques, imprimantes, ou un écran avec son clavier. Un pilote de périphérique est un composant logiciel du système d’exploitation qui contrôle un périphérique spécifique. Il y a aussi ce que l’on appelle les pseudo-périphériques ("pseudo-devices") où un pilote de périphérique émule le comportement d’un périphérique dans un logiciel sans matériel particulier sous-jacent. Les pilotes de périphériques peuvent être compilés dans le système statiquement ou chargé à la demande via l’éditeur de liens dynamique du noyau "kld".</p></div><div class=paragraph><p>La plupart des périphériques dans un système d’exploitation de type Unix sont accessibles au travers de fichiers spéciaux de périphérique (device-nodes), appelés parfois fichiers spéciaux. Ces fichiers sont habituellement stockés dans le répertoire <span class=filename>/dev</span> de la hiérarchie du système de fichiers. Jusqu’à ce que devfs soit totalement intégré dans FreeBSD, chaque fichier spécial de périphérique doit être créé statiquement et indépendamment de l’existence du pilote de périphérique associé. La plupart des fichiers spéciaux de périphérique du système sont créés en exécutant <code>MAKEDEV</code>.</p></div><div class=paragraph><p>Les pilotes de périphérique peuvent être en gros séparés en deux catégories; les pilotes de périphérique en mode caractère et les pilotes de périphériques réseau.</p></div></div><div class=sect2><h3 id=_léditeur_de_liens_dynamiques_du_noyau_kld>16.2. L’éditeur de liens dynamiques du noyau - KLD<a class=anchor href=#_léditeur_de_liens_dynamiques_du_noyau_kld></a></h3><div class=paragraph><p>L’interface kld permet aux administrateurs système d’ajouter et d’enlever dynamiquement une fonctionnalité à un système en marche. Cela permet aux développeurs de pilote de périphérique de charger leurs nouveaux changements dans le noyau en fonctionnement sans redémarrer constamment pour tester ces derniers.</p></div><div class=paragraph><p>L’interface kld est utilisé au travers des commandes d’administrateur suivantes :</p></div><div class=ulist><ul><li><p><code>kldload</code> - charge un nouveau module dans le noyau</p></li><li><p><code>kldunload</code> - décharge un module du noyau</p></li><li><p><code>kldstat</code> - liste les modules chargés dans le noyau</p></li></ul></div><div class=paragraph><p>Structure squelettique d’un module de noyau</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Squelette KLD
 * Inspiré de l&#39;article d&#39;Andrew Reiter paru sur Daemonnews
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines utilise dans kernel.h */
#include &lt;sys/kernel.h&gt; /* types utilise dans le module d&#39;initialisation */

/*
 * charge le gestionnaire quit traite du chargement et déchargement d&#39;un KLD.
 */

static int
skel_loader(struct module *m, int what, void *arg)
{
  int err = 0;

  switch (what) {
  case MOD_LOAD:                /* kldload */

    uprintf(&#34;Skeleton KLD charge.\n&#34;);
    break;
  case MOD_UNLOAD:
    uprintf(&#34;Skeleton KLD decharge.\n&#34;);
    break;
  default:
    err = EINVAL;
    break;
  }
  return(err);
}

/* Declare ce module au reste du noyau */

DECLARE_MODULE(skeleton, skel_loader, SI_SUB_KLD, SI_ORDER_ANY);</pre></div></div><div class=sect3><h4 id=_makefile>16.2.1. Makefile<a class=anchor href=#_makefile></a></h4><div class=paragraph><p>FreeBSD fournit un fichier d’inclusion "makefile" que vous pouvez utiliser pour compiler rapidement votre ajout au noyau.</p></div><div class="literalblock programlisting"><div class=content><pre>SRCS=skeleton.c
KMOD=skeleton

.include &lt;bsd.kmod.mk&gt;</pre></div></div><div class=paragraph><p>Lancer simplement la commande <code>make</code> avec ce fichier Makefile créera un fichier <span class=filename>skeleton.ko</span> qui peut être chargé dans votre système en tapant :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload -v ./skeleton.ko</span></code></pre></div></div></div></div><div class=sect2><h3 id=_accéder_au_pilote_dun_périphérique>16.3. Accéder au pilote d’un périphérique<a class=anchor href=#_accéder_au_pilote_dun_périphérique></a></h3><div class=paragraph><p>Unix fournit un ensemble d’appels système communs utilisable par les applications de l’utilisateur. Les couches supérieures du noyau renvoient ces appels au pilote de périphérique correspondant quand un utilisateur accède au fichier spécial de périphérique. Le script <code>/dev/MAKEDEV</code> crée la plupart des fichiers spéciaux de périphérique pour votre système mais si vous faites votre propre développement de pilote, il peut être nécessaire de créer vos propres fichiers spéciaux de périphérique avec la commande <code>mknod</code></p></div><div class=sect3><h4 id=_créer_des_fichiers_spéciaux_de_périphériques_statiques>16.3.1. Créer des fichiers spéciaux de périphériques statiques<a class=anchor href=#_créer_des_fichiers_spéciaux_de_périphériques_statiques></a></h4><div class=paragraph><p>La commande <code>mknod</code> nécessite quatre arguments pou créer un fichier spécial de périphérique. Vous devez spécifier le nom de ce fichier spécial de périphérique, le type de périphérique, le numéro majeur et le numéro mineur du périphérique.</p></div></div><div class=sect3><h4 id=_les_fichiers_spéciaux_de_périphérique_dynamiques>16.3.2. Les fichiers spéciaux de périphérique dynamiques<a class=anchor href=#_les_fichiers_spéciaux_de_périphérique_dynamiques></a></h4><div class=paragraph><p>Le périphérique système de fichiers, ou devfs, fournit l’accès à l’espace des noms des périphériques du noyau dans l’espace du système de fichiers global. Ceci élimine les problèmes de pilote sans fichier spécial statique, ou de fichier spécial sans pilote installé. Devfs est toujours un travail en cours mais il fonctionne déjà assez bien.</p></div></div></div><div class=sect2><h3 id=_les_périphériques_caractères>16.4. Les périphériques caractères<a class=anchor href=#_les_périphériques_caractères></a></h3><div class=paragraph><p>Un pilote de périphérique caractère est un pilote qui transfère les données directement au processus utilisateur ou vers celui-ci. Il s’agit du plus commun des types de pilote de périphérique et il y en a plein d’exemples simples dans l’arbre des sources.</p></div><div class=paragraph><p>Cet exemple simple de pseudo-périphérique enregistre toutes les valeurs que vous lui avez écrites et peut vous les renvoyer quand vous les lui demandez.</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * un simple pseudo-périphérique `echo&#39; KLD
 *
 * Murray Stokely
 */

#define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt; /* uprintf */
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines utilises dans kernel.h */
#include &lt;sys/kernel.h&gt; /* types utilises dans me module d&#39;initialisation */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;

#define BUFFERSIZE 256

/* Prototypes des fonctions */
d_open_t      echo_open;
d_close_t     echo_close;
d_read_t      echo_read;
d_write_t     echo_write;

/* Points d&#39;entrée du périphérique Caractère */
static struct cdevsw echo_cdevsw = {
  echo_open,
  echo_close,
  echo_read,
  echo_write,
  noioctl,
  nopoll,
  nommap,
  nostrategy,
  &#34;echo&#34;,
  33,                   /* reserve pour lkms - /usr/src/sys/conf/majors */
  nodump,
  nopsize,
  D_TTY,
  -1
};

typedef struct s_echo {
  char msg[BUFFERSIZE];
  int len;
} t_echo;

/* variables */
static dev_t sdev;
static int len;
static int count;
static t_echo *echomsg;

MALLOC_DECLARE(M_ECHOBUF);
MALLOC_DEFINE(M_ECHOBUF, &#34;echobuffer&#34;, &#34;cache pour le module echo&#34;);

/*
 * Cette fonction est appelee par les appels systeme kld[un]load(2) pour
 * determiner quelles actions doivent etre faites quand le
 * module est charge ou decharge
 */

static int
echo_loader(struct module *m, int what, void *arg)
{
  int err = 0;

  switch (what) {
  case MOD_LOAD:                /* kldload */
    sdev = make_dev(&amp;echo_cdevsw,
		    0,
		    UID_ROOT,
		    GID_WHEEL,
		    0600,
		    &#34;echo&#34;);
    /* aloocation de mémoire noyau pour l&#39;utilisation de ce module */
    /*    malloc(256,M_ECHOBUF,M_WAITOK); */
    MALLOC(echomsg, t_echo *, sizeof(t_echo), M_ECHOBUF, M_WAITOK);
    printf(&#34;Peripherique Echo charge.\n&#34;);
    break;
  case MOD_UNLOAD:
    destroy_dev(sdev);
    FREE(echomsg,M_ECHOBUF);
    printf(&#34;Peripherique Echo decharge.\n&#34;);
    break;
  default:
    err = EINVAL;
    break;
  }
  return(err);
}

int
echo_open(dev_t dev, int oflags, int devtype, struct proc *p)
{
  int err = 0;

  uprintf(&#34;Peripherique \&#34;echo\&#34; ouvert avec succes.\n&#34;);
  return(err);
}

int
echo_close(dev_t dev, int fflag, int devtype, struct proc *p)
{
  uprintf(&#34;Fermeture du peripherique \&#34;echo.\&#34;\n&#34;);
  return(0);
}

/*
 * La fonction read prend juste comme parametre
 * le cache qui a ete sauve par l&#39;appel à echo_write()
 * et le retourne a l&#39;utilisateur pour acces.
 * uio(9)
 */

int
echo_read(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;
  int amt;

  /* De quelle taille est cette operation read ?  Aussi grande que l&#39;utilisateur le veut,
     ou aussi grande que les donnees restantes */
  amt = MIN(uio-&gt;uio_resid, (echomsg-&gt;len - uio-&gt;uio_offset &gt; 0) ? echomsg-&gt;len - uio-&gt;uio_offset : 0);
  if ((err = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset,amt,uio)) != 0) {
    uprintf(&#34;uiomove echoue!\n&#34;);
  }

  return err;
}

/*
 * echo_write prend un caractere en entree et le sauve
 * dans le cache pour une utilisation ulterieure.
 */

int
echo_write(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  /* Copie la chaine d&#39;entree de la memoire de l&#39;utilisateur a la memoire du noyau*/
  err = copyin(uio-&gt;uio_iov-&gt;iov_base, echomsg-&gt;msg, MIN(uio-&gt;uio_iov-&gt;iov_len,BUFFERSIZE));

  /* Maintenant nous avons besoin de terminer la chaine par NULL */
  *(echomsg-&gt;msg + MIN(uio-&gt;uio_iov-&gt;iov_len,BUFFERSIZE)) = 0;
  /* Enregistre la taille */
  echomsg-&gt;len = MIN(uio-&gt;uio_iov-&gt;iov_len,BUFFERSIZE);

  if (err != 0) {
    uprintf(&#34;Ecriture echouee: mauvaise adresse!\n&#34;);
  }

  count++;
  return(err);
}

DEV_MODULE(echo,echo_loader,NULL);</pre></div></div><div class=paragraph><p>Pour installer ce pilote, vous devrez d’abord créer un fichier spécial dans votre système de fichiers avec une commande comme :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mknod /dev/echo c 33 0</span></code></pre></div></div><div class=paragraph><p>Avec ce pilote chargé, vous devriez maintenant être capable de taper quelque chose comme :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo -n &#34;Test Donnees&#34; &gt; /dev/echo</span>
<span class=c># cat /dev/echo</span>
Test Donnees</code></pre></div></div><div class=paragraph><p>Périphériques réels dans le chapitre suivant.</p></div><div class=paragraph><p>Informations additionnelles</p></div><div class=ulist><ul><li><p><a href=http://www.daemonnews.org/200010/blueprints.html>Dynamic Kernel Linker (KLD) Facility Programming Tutorial</a> - <a href=http://www.daemonnews.org>Daemonnews</a> October 2000</p></li><li><p><a href=http://www.daemonnews.org/200007/newbus-intro.html>How to Write Kernel Drivers with NEWBUS</a> - <a href=http://www.daemonnews.org>Daemonnews</a> July 2000</p></li></ul></div></div><div class=sect2><h3 id=_pilotes_réseau>16.5. Pilotes Réseau<a class=anchor href=#_pilotes_réseau></a></h3><div class=paragraph><p>Les pilotes pour périphérique réseau n’utilisent pas les fichiers spéciaux pour pouvoir être accessibles. Leur sélection est basée sur d’autres décisions faites à l’intérieur du noyau et plutôt que d’appeler open(), l’utilisation d’un périphérique réseau se fait généralement en se servant de l’appel système <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a>.</p></div><div class=paragraph><p>man ifnet(), périphérique "en boucle", drivers de Bill Paul, etc..</p></div></div></div></div><div class=sect1><h2 id=pci>Chapitre 17. Les périphériques PCI<a class=anchor href=#pci></a></h2><div class=sectionbody><div class=paragraph><p>Ce chapître traitera des mécanismes de FreeBSD pour écrire un pilote de périphérique pour un périphérique sur bus PCI.</p></div><div class=sect2><h3 id=_rechercher_et_rattacher>17.1. Rechercher et rattacher<a class=anchor href=#_rechercher_et_rattacher></a></h3><div class=paragraph><p>Informations ici sur comment le code du bus PCI fait un cycle sur les périphériques non rattachés et voir si le nouvellement chargé pilote de périphérique chargeable dans le noyau (kld) sera rattaché à l’un d’eux.</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Simple KLD pour jouer avec les fonctions PCI.
 *
 * Murray Stokely
 */

#define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;
#include &lt;sys/bus.h&gt;	/* structs, prototypes for pci bus stuff */

#include &lt;pci/pcivar.h&gt; /* For get_pci macros! */

/* Prototypes des fonctions */
d_open_t      mypci_open;
d_close_t     mypci_close;
d_read_t      mypci_read;
d_write_t     mypci_write;

/* Points d&#39;entrée du pilote de périphérique caractère */

static struct cdevsw mypci_cdevsw = {
  mypci_open,
  mypci_close,
  mypci_read,
  mypci_write,
  noioctl,
  nopoll,
  nommap,
  nostrategy,
  &#34;mypci&#34;,
  36,                   /* reserved for lkms - /usr/src/sys/conf/majors */
  nodump,
  nopsize,
  D_TTY,
  -1
};

/* variables */
static dev_t sdev;

/* Nous sommes plus interresses dans la recherche/attachement
que dans l&#39;ouverture/fermeture/lecture/ecriture a ce point */

int
mypci_open(dev_t dev, int oflags, int devtype, struct proc *p)
{
  int err = 0;

  uprintf(&#34;Peripherique \&#34;monpci\&#34; ouvert avec succes.\n&#34;);
  return(err);
}

int
mypci_close(dev_t dev, int fflag, int devtype, struct proc *p)
{
  int err=0;

  uprintf(&#34;Peripherique \&#34;monpci.\ &#34;ferme\n&#34;);
  return(err);
}

int
mypci_read(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  uprintf(&#34;lecture dans monpci!\n&#34;);
  return err;
}

int
mypci_write(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  uprintf(&#34;Ecriture dans monpci!\n&#34;);
  return(err);
}

/* PCI Support Functions */

/*
 * Retourne la chaine d&#39;identification si ce peripherique est le notre
 */
static int
mypci_probe(device_t dev)
{
  uprintf(&#34;MonPCI Probe\n&#34;
	  &#34;ID Fabricant: 0x%x\n&#34;
	  &#34;ID Peripherique : 0x%x\n&#34;,pci_get_vendor(dev),pci_get_device(dev));

  if (pci_get_vendor(dev) == 0x11c1) {
    uprintf(&#34;Nous avons le WinModem, recherche reussi!\n&#34;);
    return 0;
  }

  return ENXIO;
}

/* La fonction Attach n&#39;est appelée que si
la recherche est reussie*/

static int
mypci_attach(device_t dev)
{
  uprintf(&#34;Rattachement de MonPCI pour: ID Peripherique: 0x%x\n&#34;,pci_get_vendor(dev));
  sdev = make_dev(&amp;mypci_cdevsw,
		  0,
		  UID_ROOT,
		  GID_WHEEL,
		  0600,
		  &#34;monpci&#34;);
  uprintf(&#34;Peripherique Monpci charge.\n&#34;);
  return ENXIO;
}

/* Detach le peripherique. */

static int
mypci_detach(device_t dev)
{
  uprintf(&#34;Monpci detache!\n&#34;);
  return 0;
}

/* Appele lors de l&#39;arret du systeme apres sync. */

static int
mypci_shutdown(device_t dev)
{
  uprintf(&#34;Monpci arrete!\n&#34;);
  return 0;
}

/*
 * routine de suspension du peripherique
 */
static int
mypci_suspend(device_t dev)
{
  uprintf(&#34;Monpci suspendu!\n&#34;);
  return 0;
}

/*
 * routine de reprise du peripherique
 */

static int
mypci_resume(device_t dev)
{
  uprintf(&#34;Monpci resume!\n&#34;);
  return 0;
}

static device_method_t mypci_methods[] = {
	/* Interface Peripherique*/
	DEVMETHOD(device_probe,		mypci_probe),
	DEVMETHOD(device_attach,	mypci_attach),
	DEVMETHOD(device_detach,	mypci_detach),
	DEVMETHOD(device_shutdown,	mypci_shutdown),
	DEVMETHOD(device_suspend,	mypci_suspend),
	DEVMETHOD(device_resume,	mypci_resume),

	{ 0, 0 }
};

static driver_t mypci_driver = {
	&#34;monpci&#34;,
	mypci_methods,
	0,
	/*	sizeof(struct mypci_softc), */
};

static devclass_t mypci_devclass;

DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);</pre></div></div><div class=paragraph><p>Informations complémentaires</p></div><div class=ulist><ul><li><p><a href=http://www.pcisig.org>PCI Special Interest Group</a></p></li><li><p>PCI System Architecture, Fourth Edition by Tom Shanley, et al.</p></li></ul></div></div><div class=sect2><h3 id=_les_ressources_du_bus>17.2. Les ressources du bus<a class=anchor href=#_les_ressources_du_bus></a></h3><div class=paragraph><p>FreeBSD fournit un mécanisme orienté objet pour demander des ressources du bus parent. Pratiquement tous les périphériques seront un fils membre d’un type de bus (PCI, ISA, USB, SCSI, etc) et ces périphériques nécessite des ressources issues de leur bus parent (comme des segments de mémoire, des interruptions or des canaux DMA).</p></div><div class=sect3><h4 id=_registres_dadresse_de_base>17.2.1. Registres d’adresse de base<a class=anchor href=#_registres_dadresse_de_base></a></h4><div class=paragraph><p>Pour faire de particulièrement utile avec un périphérique PCI, vous aurez besoin d’obtenir les <em>registres d’adresse de base</em> (Base Address Registers ou BARs) de l’espace de configuration PCI. Les détails spécifiques au PCI sur l’obtention du registre d’adresse de base sont masqués dans la fonction <code>bus_alloc_resource()</code>.</p></div><div class=paragraph><p>Par exemple, un pilote typique aura sa fonction <code>attach()</code> similaire à ceci :</p></div><div class="literalblock programlisting"><div class=content><pre>    sc-&gt;bar0id = 0x10;
    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;(sc-&gt;bar0id),
				  0, ~0, 1, RF_ACTIVE);
    if (sc-&gt;bar0res == NULL) {
        uprintf(&#34;Allocation memoire du registre PCI de base 0 echouee!\n&#34;);
        error = ENXIO;
        goto fail1;
    }

    sc-&gt;bar1id = 0x14;
    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;(sc-&gt;bar1id),
				  0, ~0, 1, RF_ACTIVE);
    if (sc-&gt;bar1res == NULL) {
        uprintf(&#34;Allocation memoire du registre PCI de base 1 echouee!\n&#34;);
        error =  ENXIO;
        goto fail2;
    }
    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);
    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);
    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);
    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);</pre></div></div><div class=paragraph><p>Des références pour chaque registre d’adresse de base sont gardées dans la structure <code>softc</code> afin qu’elle puisse être utilisée pour écrire dans le périphérique plus tard.</p></div><div class=paragraph><p>Ces références peuvent alors être utilisées pour lire ou écrire dans les registres du périphérique avec les fonctions <code>bus_space_*</code>. Par exemple, un pilote peut contenir une fonction raccourci pour lire dans un registre spécifique à une carte comme cela :</p></div><div class="literalblock programlisting"><div class=content><pre>uint16_t
board_read(struct ni_softc *sc, uint16_t address) {
    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);
}</pre></div></div><div class=paragraph><p>De façon similaire, une autre peut écrire dans les registres avec :</p></div><div class="literalblock programlisting"><div class=content><pre>void
board_write(struct ni_softc *sc, uint16_t address, uint16_t value) {
    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);
}</pre></div></div><div class=paragraph><p>Ces fonctions existent en versions 8bit, 16bit et 32bit et vous devriez utiliser <code>bus_space_{read|write}_{1|2|4}</code> en conséquence.</p></div></div><div class=sect3><h4 id=_les_interruptions>17.2.2. Les interruptions<a class=anchor href=#_les_interruptions></a></h4><div class=paragraph><p>Les interruptions sont alloués à partir du code orienté objet du bus de façon similaire aux ressources mémoire. D’abord une ressource IRQ doit être allouée à partir du bus parent, et alors le gestionnaire d’interruption doit être règlé pour traiter cet IRQ.</p></div><div class=paragraph><p>A nouveau, un exemple de fonction <code>attach()</code> en dit plusqu’un long discours.</p></div><div class="literalblock programlisting"><div class=content><pre>/* Recupere la ressource IRQ */

    sc-&gt;irqid = 0x0;
    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),
				  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);
    if (sc-&gt;irqres == NULL) {
	uprintf(&#34;Allocation IRQ echouee!\n&#34;);
	error = ENXIO;
	goto fail3;
    }

    /* Maitnenant nous choisissons notre gestionnaire d&#39;interruption */

    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,
			   my_handler, sc, &amp;(sc-&gt;handler));
    if (error) {
	printf(&#34;Ne peut regler l&#39;IRQ\n&#34;);
	goto fail4;
    }

    sc-&gt;irq_bt = rman_get_bustag(sc-&gt;irqres);
    sc-&gt;irq_bh = rman_get_bushandle(sc-&gt;irqres);</pre></div></div></div><div class=sect3><h4 id=_dma>17.2.3. DMA<a class=anchor href=#_dma></a></h4><div class=paragraph><p>Sur les PC, les périphériques qui veulent utiliser la gestion de bus DMA doivent travailler avec des adresses physiques. C’est un problème puisque FreeBSD utilise une mémoire virtuelle et travaille presque exclusivement avec des adresses virtuelles. Heureusement, il y a une fonction <code>vtophys()</code> pour nous aider.</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;vm/vm.h&gt;
#include &lt;vm/pmap.h&gt;

#define vtophys(virtual_address) (...)</pre></div></div><div class=paragraph><p>La solution est toutefois un peu différente sur Alpha, et ce que nous voulons réellement est une fonction appelée <code>vtobus()</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>#if defined(__alpha__)
#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)
#else
#define vtobus(va)      vtophys(va)
#endif</pre></div></div></div><div class=sect3><h4 id=_désallouer_les_resources>17.2.4. Désallouer les resources<a class=anchor href=#_désallouer_les_resources></a></h4><div class=paragraph><p>Il est très important de désallouer toutes les ressources qui furent allouées pendant <code>attach()</code>. Unsoin tout particulier doit être pris pour désallouer les bonnes choses même lors d’un échec afin que le système reste utilisable lorsque votre driver meurt.</p></div></div></div></div></div><div class=sect1><h2 id=scsi>Chapitre 18. Contrôleurs SCSI Common Access Method (CAM) **<a class=anchor href=#scsi></a></h2><div class=sectionbody><div class=sect2><h3 id=_en_cours_de_traduction>18.1. En cours de traduction<a class=anchor href=#_en_cours_de_traduction></a></h3><div class=paragraph><p>En cours de traduction</p></div></div></div></div><div class=sect1><h2 id=usb>Chapitre 19. Périphériques USB <strong>*</strong><a class=anchor href=#usb></a></h2><div class=sectionbody><div class=paragraph><p><em>Ce chapître a été écrit par Nick Hibma &lt;<a href=mailto:n_hibma@FreeBSD.org>n_hibma@FreeBSD.org</a>>. Les modifications pour le manuel par Murray Stokely &lt;<a href=mailto:murray@FreeBSD.org>murray@FreeBSD.org</a>>.</em></p></div><div class=sect2><h3 id=_introduction_3>19.1. Introduction<a class=anchor href=#_introduction_3></a></h3><div class=paragraph><p>Chapître à traduire.</p></div></div></div></div><div class=sect1><h2 id=newbus>Chapitre 20. NewBus<a class=anchor href=#newbus></a></h2><div class=sectionbody><div class=paragraph><p>Ce chapître traitera de l’architecture NewBus de FreeBSD.</p></div></div></div><h1 id=architectures class=sect0>Partie XII: Architectures<a class=anchor href=#architectures></a></h1><div class=sect1><h2 id=ia32>Chapitre 21. IA-32<a class=anchor href=#ia32></a></h2><div class=sectionbody><div class=paragraph><p>Traite des spécificités de l’architecture x86 sous FreeBSD.</p></div></div></div><div class=sect1><h2 id=alpha>Chapitre 22. Alpha<a class=anchor href=#alpha></a></h2><div class=sectionbody><div class=paragraph><p>Traite des spécificités de l’architecture Alpha sous FreeBSD.</p></div><div class=paragraph><p>Explication des erreurs d’alignements, comment les réparer, comment les ignorer.</p></div><div class=paragraph><p>Exemple de code assembleur pour FreeBSD/alpha.</p></div></div></div><div class=sect1><h2 id=ia64>Chapitre 23. IA-64<a class=anchor href=#ia64></a></h2><div class=sectionbody><div class=paragraph><p>Traite des spécificités de l’architecture IA-64 sous FreeBSD.</p></div></div></div><h1 id=debuggingpart class=sect0>Partie XIII: Déverminage<a class=anchor href=#debuggingpart></a></h1><div class=sect1><h2 id=truss>Chapitre 24. Truss<a class=anchor href=#truss></a></h2><div class=sectionbody><div class=paragraph><p>diverses descriptions sur les méthodes de déverminage de certains aspects du système utilisant truss, ktrace, gdb, kgdb, etc</p></div></div></div><h1 id=compatibility class=sect0>Partie XIV: Les couches de compatibilité<a class=anchor href=#compatibility></a></h1><div class=sect1><h2 id=linux>Chapitre 25. Linux<a class=anchor href=#linux></a></h2><div class=sectionbody><div class=paragraph><p>Linux, SVR4, etc</p></div></div></div><div class=sect1><h2 id=appendices>Bibligraphie<a class=anchor href=#appendices></a></h2><div class=sectionbody></div></div><div class=sect1><h2 id=_bibliographie>Bibliographie<a class=anchor href=#_bibliographie></a></h2><div class=sectionbody><div class=paragraph><p><a id=COD></a>[1] Dave A Patterson and John L Hennessy. Copyright® 1998 Morgan Kaufmann Publishers, Inc. 1-55860-428-6. Morgan Kaufmann Publishers, Inc. Computer Organization and Design. The Hardware / Software Interface. 1-2.</p></div><div class=paragraph><p><a id=APUE></a>[2] W. Richard Stevens. Copyright® 1993 Addison Wesley Longman, Inc. 0-201-56317-7. Addison Wesley Longman, Inc. Advanced Programming in the Unix Environment. 1-2.</p></div><div class=paragraph><p><a id=DIFOS></a>[3] Marshall Kirk McKusick and George Neville-Neil. Copyright® 2004 Addison-Wesley. 0-201-70245-2. Addison-Wesley. The Design and Implementation of the FreeBSD Operating System. 1-2.</p></div><div class=paragraph><p><a id=Phrack></a>[4] Aleph One. Phrack 49; "Smashing the Stack for Fun and Profit".</p></div><div class=paragraph><p><a id=StackGuard></a>[5] Chrispin Cowan, Calton Pu, and Dave Maier. StackGuard; Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks.</p></div><div class=paragraph><p><a id=OpenBSD></a>[6] Todd Miller and Theo de Raadt. strlcpy and strlcat — consistent, safe string copy and concatenation.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 3 novembre 2021 by <a href="https://cgit.freebsd.org/doc/commit/?id=64acd169b8" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Sommaire</h3><nav id=TableOfContents><ul><li><a href=#introduction>Partie I: Introduction</a><ul><li><a href=#developmentplatform>Chapitre 1. Développer sous FreeBSD</a></li><li><a href=#bsdvision>Chapitre 2. La vision BSD</a></li><li><a href=#archoverview>Chapitre 3. Survol de l’architecture</a></li><li><a href=#sourcelayout>Chapitre 4. L’agencement de /usr/src</a></li></ul></li><li><a href=#Basics>Partie II: Les fondamentaux</a><ul><li><a href=#tools>Chapitre 5. Outils de programmation</a></li><li><a href=#secure>Chapitre 6. Programmation sécurisée</a></li></ul></li><li><a href=#kernel>Partie III: Le noyau</a><ul><li><a href=#kernelhistory>Chapitre 7. Histoire du noyau Unix</a></li><li><a href=#locking>Chapitre 8. Notes sur le verrouillage</a></li></ul></li><li><a href=#memory>Partie IV: Mémoire et mémoire virtuelle</a><ul><li><a href=#virtualmemory>Chapitre 9. La mémoire virtuelle</a></li></ul></li><li><a href=#iosystem>Partie V: Système E/S (Entrées/Sorties)</a><ul><li><a href=#UFS>Chapitre 10. UFS</a></li></ul></li><li><a href=#ipc>Partie VI: Communication InterProcessus (IPC)</a><ul><li><a href=#signals>Chapitre 11. Les signaux</a></li></ul></li><li><a href=#networking>Partie VII: Le réseau</a><ul><li><a href=#sockets>Chapitre 12. Les prises</a></li></ul></li><li><a href=#networkfs>Partie VIII: Systèmes de fichiers en réseau</a><ul><li><a href=#afs>Chapitre 13. AFS</a></li></ul></li><li><a href=#terminal>Partie IX: Gestion du terminal</a><ul><li><a href=#syscons>Chapitre 14. Syscons</a></li></ul></li><li><a href=#sound>Partie X: Le son</a><ul><li><a href=#oss>Chapitre 15. OSS</a></li></ul></li><li><a href=#devicedrivers>Partie XI: Pilotes de périphérique</a><ul><li><a href=#driverbasics>Chapitre 16. Ecrire des pilotes de périphériques pour FreeBSD</a></li><li><a href=#pci>Chapitre 17. Les périphériques PCI</a></li><li><a href=#scsi>Chapitre 18. Contrôleurs SCSI Common Access Method (CAM) **</a></li><li><a href=#usb>Chapitre 19. Périphériques USB <strong>*</strong></a></li><li><a href=#newbus>Chapitre 20. NewBus</a></li></ul></li><li><a href=#architectures>Partie XII: Architectures</a><ul><li><a href=#ia32>Chapitre 21. IA-32</a></li><li><a href=#alpha>Chapitre 22. Alpha</a></li><li><a href=#ia64>Chapitre 23. IA-64</a></li></ul></li><li><a href=#debuggingpart>Partie XIII: Déverminage</a><ul><li><a href=#truss>Chapitre 24. Truss</a></li></ul></li><li><a href=#compatibility>Partie XIV: Les couches de compatibilité</a><ul><li><a href=#linux>Chapitre 25. Linux</a></li></ul></li><li><a href=#appendices>Bibligraphie</a></li><li><a href=#_bibliographie>Bibliographie</a></li></ul></nav><hr><div class=resources><h3>Ressources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Téléchargement en PDF"></i><a href=https://download.freebsd.org/doc/fr/books/developers-handbook/developers-handbook_fr.pdf>Téléchargement en PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Éditer cette page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/fr/_index target=_blank>Éditer cette page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/fr/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>French</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Clair</option><option value=theme-dark>Sombre</option><option value=theme-high-contrast>Contraste élevé</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/fr class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/fr/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>